CREATE SCHEMA x.x;
SET x = TESTLIBPQ2;
CREATE TABLE x (x INT);
CREATE TABLE x (x INT);
CREATE RULE r1 AS ON INSERT TO TBL1 DO   (INSERT INTO TBL2 VALUES (new.i);
CREATE SCHEMA x.x;
SET x = testlibpq3;
SET x = ON;
CREATE TABLE x (x INT, x TEXT, x VARBINARY);
INSERT INTO x VALUES (1, 'joe''s place', '\000\001\002\003\004');
INSERT INTO x VALUES (2, 'ho there', '\004\003\002\001\000');
DROP TABLE x;
CREATE INDEX x ON x USING btree(REGEXP_LIKE(x, x) NULLS LAST);
CREATE INDEX x ON x USING hash(x NULLS LAST);
INSERT INTO x VALUES ('�q���~', '�F�F���', '�_A01��');
INSERT INTO x VALUES ('�s�y�~', '�]���������q', '��B10��');
INSERT INTO x VALUES ('�\���~', '�����ѥ��������q', '��Z01�E');
VACUUM �t�Ӹ��;
SELECT * FROM x;
SELECT * FROM x WHERE REGEXP_LIKE(x, '�F�F��[�H�O��]');
SELECT * FROM x WHERE REGEXP_I_LIKE(x, '�F�F��[�H�O��]');
SELECT *, LENGTH(REGEXP_LIKE(x, x)) FROM x;
SELECT *, OCTET_LENGTH(REGEXP_LIKE(x, x)) FROM x;
SELECT *, STR_POSITION(x, '����') FROM x;
SELECT *, SUBSTRING(x, 3, 6) FROM x;
DROP TABLE x;
CREATE TABLE x (x TEXT, x VARCHAR, x CHAR(16));
CREATE INDEX x ON x USING btree(x NULLS LAST);
CREATE INDEX x ON x USING btree(x NULLS LAST);
INSERT INTO x VALUES ('������ʾ��', '��A01��');
INSERT INTO x VALUES ('����ͼ��', '��B01��');
INSERT INTO x VALUES ('���Գ���Ա', '��Z01��');
VACUUM ���������;
SELECT * FROM x;
SELECT * FROM x WHERE x = '��Z01��';
SELECT * FROM x WHERE REGEXP_I_LIKE(x, '��z01��');
SELECT * FROM x WHERE x LIKE '_Z01_';
SELECT * FROM x WHERE x LIKE '_Z%';
SELECT * FROM x WHERE REGEXP_LIKE(x, '����[��ͼ]');
SELECT * FROM x WHERE REGEXP_I_LIKE(x, '����[��ͼ]');
SELECT *, LENGTH(x) FROM x;
SELECT *, OCTET_LENGTH(x) FROM x;
SELECT *, STR_POSITION(x, '��') FROM x;
SELECT *, SUBSTRING(x, 3, 4) FROM x;
DROP TABLE x;
CREATE TABLE x (x TEXT, x VARCHAR, x CHAR(16));
CREATE INDEX x ON x USING btree(x NULLS LAST);
CREATE INDEX x ON x USING hash(x NULLS LAST);
INSERT INTO x VALUES ('����ԥ塼���ǥ����ץ쥤', '��A01��');
INSERT INTO x VALUES ('����ԥ塼������ե��å���', 'ʬB10��');
INSERT INTO x VALUES ('����ԥ塼���ץ�����ޡ�', '��Z01��');
VACUUM �׻����Ѹ�;
SELECT * FROM x;
SELECT * FROM x WHERE x = '��Z01��';
SELECT * FROM x WHERE REGEXP_I_LIKE(x, '��z01��');
SELECT * FROM x WHERE x LIKE '_Z01_';
SELECT * FROM x WHERE x LIKE '_Z%';
SELECT * FROM x WHERE REGEXP_LIKE(x, '����ԥ塼��[�ǥ�]');
SELECT * FROM x WHERE REGEXP_I_LIKE(x, '����ԥ塼��[�ǥ�]');
SELECT *, LENGTH(x) FROM x;
SELECT *, OCTET_LENGTH(x) FROM x;
SELECT *, STR_POSITION(x, '��') FROM x;
SELECT *, SUBSTRING(x, 10, 4) FROM x;
DROP TABLE x;
CREATE TABLE x (x TEXT, x VARCHAR, x VARCHAR(16));
CREATE INDEX x ON x USING btree(x NULLS LAST);
CREATE INDEX x ON x USING hash(x NULLS LAST);
INSERT INTO x VALUES ('�����', '������', 'ơA01��');
INSERT INTO x VALUES ('������', '����ȴ����Ƴ', '��B10��');
INSERT INTO x VALUES ('����', 'ӡ��ϴǹȴ����Ƴ', '��Z01Ħ');
VACUUM ��ٸ����;
SELECT * FROM x;
SELECT * FROM x WHERE x = '��Z01Ħ';
SELECT * FROM x WHERE REGEXP_I_LIKE(x, '��z01Ħ');
SELECT * FROM x WHERE x LIKE '_Z01_';
SELECT * FROM x WHERE x LIKE '_Z%';
SELECT * FROM x WHERE REGEXP_LIKE(x, '����[��ش��]');
SELECT * FROM x WHERE REGEXP_I_LIKE(x, '����[��ش��]');
SELECT *, LENGTH(x) FROM x;
SELECT *, OCTET_LENGTH(x) FROM x;
SELECT *, STR_POSITION(x, 'ȴ��') FROM x;
SELECT *, SUBSTRING(x, 3, 6) FROM x;
DROP TABLE x;
CREATE INDEX x ON x USING btree(x NULLS LAST);
INSERT INTO x VALUES ('����ԥ�`���ǥ����ץ쥤', '�CA01��');
INSERT INTO x VALUES ('����ԥ�`������ե��å���', '��B10��');
INSERT INTO x VALUES ('����ԥ�`���ץ�����ީ`', '��Z01��');
VACUUM Ӌ��C���Z;
SELECT * FROM x;
SELECT * FROM x WHERE REGEXP_LIKE(x, '����ԥ�`��[�ǥ�]');
SELECT * FROM x WHERE REGEXP_I_LIKE(x, '����ԥ�`��[�ǥ�]');
SELECT *, LENGTH(x) FROM x;
SELECT *, OCTET_LENGTH(x) FROM x;
SELECT *, STR_POSITION(x, '��') FROM x;
SELECT *, SUBSTRING(x, 10, 4) FROM x;
create table �v�Z�@�p�� (�p�� text, ���ރR�[�h varchar, ���l1A���� char(16));
create index �v�Z�@�p��index1 on �v�Z�@�p�� using btree (�p��);
create index �v�Z�@�p��index2 on �v�Z�@�p�� using hash (���ރR�[�h);
VACUUM �v�Z�@�p��;
SELECT * FROM x AS @�p��;
SELECT * FROM x AS @�p�� WHERE REGEXP_LIKE(x, '�R���s���[�^[�f�O]');
SELECT * FROM x AS @�p�� WHERE REGEXP_I_LIKE(x, '�R���s���[�^[�f�O]');
SELECT *, LENGTH(x) FROM x AS @�p��;
SELECT *, OCTET_LENGTH(x) FROM x AS @�p��;
SELECT *, STR_POSITION(x, '�f') FROM x AS @�p��;
SELECT *, SUBSTRING(x, 10, 4) FROM x AS @�p��;
COPY INTO x FROM @�p�� WITH (to stdout);
DROP TABLE x;
CREATE TABLE x (x TEXT, x VARCHAR, x CHAR(16));
CREATE INDEX x ON x USING btree(x NULLS LAST);
CREATE INDEX x ON x USING hash(x NULLS LAST);
INSERT INTO x VALUES ('コンピュータディスプレイ', '機A01上');
INSERT INTO x VALUES ('コンピュータグラフィックス', '分B10中');
INSERT INTO x VALUES ('コンピュータプログラマー', '人Z01下');
VACUUM 計算機用語;
SELECT * FROM x;
SELECT * FROM x WHERE x = '人Z01下';
SELECT * FROM x WHERE REGEXP_I_LIKE(x, '人z01下');
SELECT * FROM x WHERE x LIKE '_Z01_';
SELECT * FROM x WHERE x LIKE '_Z%';
SELECT * FROM x WHERE REGEXP_LIKE(x, 'コンピュータ[デグ]');
SELECT * FROM x WHERE REGEXP_I_LIKE(x, 'コンピュータ[デグ]');
SELECT *, LENGTH(x) FROM x;
SELECT *, OCTET_LENGTH(x) FROM x;
SELECT *, STR_POSITION(x, 'デ') FROM x;
SELECT *, SUBSTRING(x, 10, 4) FROM x;
/* Commit Timestamp */ SHOW track_commit_timestamp;
CREATE TABLE x (x SERIAL, x TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP());
SELECT x, PG_XACT_COMMIT_TIMESTAMP(x) >= x, PG_XACT_COMMIT_TIMESTAMP(x) <= CURRENT_TIMESTAMP(), PG_XACT_COMMIT_TIMESTAMP(x) - x < '60s' /* 60s should give a lot of reserve */ FROM x ORDER BY x NULLS LAST;
DROP TABLE x;
SELECT PG_XACT_COMMIT_TIMESTAMP(CAST('0' AS xid));
SELECT PG_XACT_COMMIT_TIMESTAMP(CAST('1' AS xid));
SELECT PG_XACT_COMMIT_TIMESTAMP(CAST('2' AS xid));
SELECT CAST(CAST(x.x AS TEXT) AS BIGINT) > 0 AS x, x.x > CAST('-infinity' AS TIMESTAMPTZ) AS x, x.x <= CURRENT_TIMESTAMP() AS x, x <> 0 AS x FROM x AS x;
/* Test non-normal transaction ids. */ SELECT * FROM x;
/* ok, NULL */ SELECT * FROM x;
/* error */ SELECT * FROM x;
/* ok, NULL */ SELECT * FROM x;
/* Test transaction with replication origin */ SELECT PG_REPLICATION_ORIGIN_CREATE('regress_commit_ts: get_origin') <> 0 AS x;
SELECT PG_REPLICATION_ORIGIN_SESSION_SETUP('regress_commit_ts: get_origin');
SELECT PG_REPLICATION_ORIGIN_SESSION_RESET();
SELECT PG_REPLICATION_ORIGIN_DROP('regress_commit_ts: get_origin');
/* Access method */ CREATE ACCESS METHOD dummy_index_am TYPE INDEX HANDLER dihandler;
COMMENT ON ACCESS METHOD dummy_index_am IS 'dummy index access method';
/* Operator classes */ CREATE OPERATOR CLASS int4_ops DEFAULT FOR TYPE int4 USING dummy_index_am AS   OPERATOR 1 = (int4, int4),   FUNCTION 1 hashint4(int4);
/* Tests for relation options */ CREATE EXTENSION dummy_index_am;
CREATE TABLE x (x INT);
SET x = 'warning' /* Silence validation checks for strings */;
/* Test with default values. */ CREATE INDEX x ON x USING dummy_index_am(x NULLS LAST);
SELECT EXPLODE(x) FROM x WHERE x = 'dummy_test_idx';
DROP INDEX x;
SET x = 'notice' /* Test with full set of options. */ /* Allow validation checks for strings, just for the index creation */;
CREATE INDEX x ON x USING dummy_index_am(x NULLS LAST) WITH (option_bool=FALSE, option_int=5, option_real=3.1, option_enum='two', option_string_val=NULL, option_string_null='val');
SET x = 'warning' /* Silence again validation checks for strings until the end of the test. */;
SELECT EXPLODE(x) FROM x WHERE x = 'dummy_test_idx';
ALTER INDEX x SET x = 10 /* ALTER INDEX .. SET */;
ALTER INDEX x SET x = TRUE;
ALTER INDEX x SET x = 3.2;
ALTER INDEX x SET x = 'val2';
ALTER INDEX x SET x = NULL;
ALTER INDEX x SET x = 'one';
ALTER INDEX x SET x = 'three';
SELECT EXPLODE(x) FROM x WHERE x = 'dummy_test_idx';
/* ALTER INDEX .. RESET */ ALTER INDEX dummy_test_idx RESET (option_int);
ALTER INDEX dummy_test_idx RESET (option_bool);
ALTER INDEX dummy_test_idx RESET (option_real);
ALTER INDEX dummy_test_idx RESET (option_enum);
ALTER INDEX dummy_test_idx RESET (option_string_val);
ALTER INDEX dummy_test_idx RESET (option_string_null);
SELECT EXPLODE(x) FROM x WHERE x = 'dummy_test_idx';
ALTER INDEX x SET x = 3.3 /* Cross-type checks for reloption values */ /* Integer */;
ALTER INDEX x SET x = TRUE /* ok */;
ALTER INDEX x SET x = 'val3' /* error */;
/* error */ SELECT EXPLODE(x) FROM x WHERE x = 'dummy_test_idx';
ALTER INDEX dummy_test_idx RESET (option_int);
ALTER INDEX x SET x = 4 /* Boolean */;
ALTER INDEX x SET x = 1 /* error */;
ALTER INDEX x SET x = 3.4 /* ok, as true */;
ALTER INDEX x SET x = 'val4' /* error */;
/* error */ SELECT EXPLODE(x) FROM x WHERE x = 'dummy_test_idx';
ALTER INDEX dummy_test_idx RESET (option_bool);
ALTER INDEX x SET x = 4 /* Float */;
ALTER INDEX x SET x = TRUE /* ok */;
ALTER INDEX x SET x = 'val5' /* error */;
/* error */ SELECT EXPLODE(x) FROM x WHERE x = 'dummy_test_idx';
ALTER INDEX dummy_test_idx RESET (option_real);
ALTER INDEX x SET x = 'one' /* Enum */;
ALTER INDEX x SET x = 0 /* ok */;
ALTER INDEX x SET x = TRUE /* error */;
ALTER INDEX x SET x = 'three' /* error */;
/* error */ SELECT EXPLODE(x) FROM x WHERE x = 'dummy_test_idx';
ALTER INDEX dummy_test_idx RESET (option_enum);
ALTER INDEX x SET x = 4 /* String */;
ALTER INDEX x SET x = 3.5 /* ok */;
ALTER INDEX x SET x = TRUE /* ok */;
/* ok, as "true" */ SELECT EXPLODE(x) FROM x WHERE x = 'dummy_test_idx';
ALTER INDEX dummy_test_idx RESET (option_string_val);
DROP INDEX x;
/* Test for facilities of security label */ CREATE EXTENSION dummy_seclabel;
SET x = 'warning' /* initial setups */;
DROP ROLE IF EXISTS regress_dummy_seclabel_user1;
DROP ROLE IF EXISTS regress_dummy_seclabel_user2;
DROP ROLE IF EXISTS regress_dummy_seclabel_user3;
RESET client_min_messages;
CREATE USER regress_dummy_seclabel_user1 WITH CREATEROLE;
CREATE USER regress_dummy_seclabel_user2;
CREATE USER regress_dummy_seclabel_user3;
CREATE TABLE x (x INT, x TEXT);
CREATE TABLE x (x INT, x TEXT);
CREATE VIEW x AS SELECT * FROM x;
CREATE FUNCTION x() RETURNS INT LANGUAGE sql AS $$SELECT 4$$;
CREATE DOMAIN dummy_seclabel_domain AS text;
ALTER TABLE dummy_seclabel_tbl1 OWNER TO regress_dummy_seclabel_user1;
ALTER TABLE dummy_seclabel_tbl2 OWNER TO regress_dummy_seclabel_user2;
GRANT regress_dummy_seclabel_user2, regress_dummy_seclabel_user3   TO regress_dummy_seclabel_user1 WITH ADMIN TRUE, INHERIT FALSE, SET FALSE;
/* Test of SECURITY LABEL statement with a plugin */ SET SESSION AUTHORIZATION regress_dummy_seclabel_user1;
/* fail (not found) */ SET SESSION AUTHORIZATION regress_dummy_seclabel_user2;
/* OK */ /* Test for shared database object */ SET SESSION AUTHORIZATION regress_dummy_seclabel_user1;
/* fail (not found) */ SET SESSION AUTHORIZATION regress_dummy_seclabel_user2;
/* fail (not privileged) */ RESET SESSION AUTHORIZATION;
/* Test for various types of object */ RESET SESSION AUTHORIZATION;
/* OK */ CREATE SCHEMA x.x;
SET x = error /* OK */;
CREATE PUBLICATION dummy_pub;
CREATE SUBSCRIPTION dummy_sub CONNECTION '' PUBLICATION foo WITH (connect = false, slot_name = NONE);
RESET client_min_messages;
SELECT x, x, x, x FROM x ORDER BY x NULLS LAST, x NULLS LAST;
COMMIT;
CREATE EVENT TRIGGER always_start ON ddl_command_start EXECUTE PROCEDURE event_trigger_test();
CREATE EVENT TRIGGER always_end ON ddl_command_end EXECUTE PROCEDURE event_trigger_test();
CREATE EVENT TRIGGER always_drop ON sql_drop EXECUTE PROCEDURE event_trigger_test();
CREATE EVENT TRIGGER always_rewrite ON table_rewrite EXECUTE PROCEDURE event_trigger_test();
/* clean up */ DROP EVENT TRIGGER always_start, always_end, always_drop, always_rewrite;
DROP VIEW x;
DROP SUBSCRIPTION dummy_sub;
DROP PUBLICATION dummy_pub;
DROP ROLE regress_dummy_seclabel_user1;
DROP ROLE regress_dummy_seclabel_user2;
DROP ROLE regress_dummy_seclabel_user3;
/* The test uses a GIN index over int[].  The table contains arrays */ /* with integers from 1 to :next_i.  Each integer occurs exactly once, */ /* no gaps or duplicates, although the index does contain some */ /* duplicate elements because some of the inserting transactions are */ /* rolled back during the test. The exact contents of the table depend */ /* on the physical layout of the index, which in turn depends at least */ /* on the block size, so instead of check for the exact contents, we */ /* check those invariants.  :next_i psql variable is maintained at all */ /* times to hold the last inserted integer + 1. */ /* This uses injection points to cause errors that leave some page */ /* splits in "incomplete" state */ create extension injection_points;
/* Make all injection points local to this process, for concurrency. */ SELECT INJECTION_POINTS_SET_LOCAL();
SET x = off /* Use the index for all the queries */;
/* Print a NOTICE whenever an incomplete split gets fixed */ SELECT INJECTION_POINTS_ATTACH('gin-finish-incomplete-split', 'notice');
/* First create the test table and some helper functions */ CREATE TABLE x (x ARRAY<INT>) WITH (autovacuum_enabled=off);
CREATE INDEX ON x USING gin(x NULLS LAST) WITH (fastupdate=off);
/* Creates an array with all integers from $1 (inclusive) $2 (exclusive) */ CREATE FUNCTION x(x, x) RETURNS ARRAY<INT> LANGUAGE sql IMMUTABLE AS $$   select array_agg(g) from generate_series($1, $2 - 1) g $$;
COMMIT;
BEGIN -- Insert arrays with 'step' elements each, until an error occurs.   i := 0;
x;
COMMIT;
x := x + 1;
if i = 10000 then       raise 'no error on inserts after % iterations', i;
x AS x;
COMMIT;
x AS x;
x AS x;
BEGIN -- Perform a scan over the trailing part of the index, where the   -- possible incomplete splits are. (We don't check the whole table,   -- because that'd be pretty slow.)   c := 0;
if elem >= next_i - 200 then         c := c + 1;
if c <> 200 then     raise 'unexpected count % ', c;
x AS x;
COMMIT;
/* Test incomplete leaf split */ SELECT INJECTION_POINTS_ATTACH('gin-leave-leaf-split-incomplete', 'error');
/* Verify that a scan works even though there's an incomplete split */ SELECT VERIFY(:next_i);
/* Test incomplete internal page split */ SELECT INJECTION_POINTS_ATTACH('gin-leave-internal-split-incomplete', 'error');
/* Verify that a scan works even though there's an incomplete split */ SELECT VERIFY(:next_i);
SELECT INJECTION_POINTS_DETACH('gin-finish-incomplete-split');
/* injection_points_set_local() */ /* Trigger switch to link any future injection points attached to the */ /* current process, useful to make SQL tests concurrently-safe. */ CREATE FUNCTION injection_points_set_local() RETURNS void AS 'MODULE_PATHNAME', 'injection_points_set_local' LANGUAGE C STRICT PARALLEL UNSAFE;
/* injection_points_stats_drop() */ /* Drop all statistics of injection points. */ CREATE FUNCTION injection_points_stats_drop() RETURNS void AS 'MODULE_PATHNAME', 'injection_points_stats_drop' LANGUAGE C STRICT;
/* regress_injection.c functions */ CREATE FUNCTION removable_cutoff(rel regclass) RETURNS xid8 AS 'MODULE_PATHNAME' LANGUAGE C CALLED ON NULL INPUT;
/* Test for hash aggregation */ CREATE EXTENSION injection_points;
SELECT INJECTION_POINTS_SET_LOCAL();
SELECT INJECTION_POINTS_ATTACH('hash-aggregate-enter-spill-mode', 'notice');
SELECT INJECTION_POINTS_ATTACH('hash-aggregate-process-batch', 'notice');
/* force partition fan-out to 1 */ SELECT INJECTION_POINTS_ATTACH('hash-aggregate-single-partition', 'notice');
/* force spilling after 1000 groups */ SELECT INJECTION_POINTS_ATTACH('hash-aggregate-spill-1000', 'notice');
CREATE TABLE x (x INT);
INSERT INTO x SELECT x FROM x AS x;
SET x = 0;
SET x = 0;
SET x = FALSE;
SET x = '4MB';
SELECT COUNT(*) FROM (SELECT DISTINCT x FROM x) AS x;
DROP TABLE x;
DROP EXTENSION injection_points;
CREATE EXTENSION injection_points;
SELECT INJECTION_POINTS_ATTACH('TestInjectionBooh', 'booh');
SELECT INJECTION_POINTS_ATTACH('TestInjectionError', 'error');
SELECT INJECTION_POINTS_ATTACH('TestInjectionLog', 'notice');
SELECT INJECTION_POINTS_ATTACH('TestInjectionLog2', 'notice');
SELECT INJECTION_POINTS_RUN('TestInjectionBooh');
/* nothing */ SELECT INJECTION_POINTS_RUN('TestInjectionLog2');
/* notice */ SELECT INJECTION_POINTS_RUN('TestInjectionLog');
/* notice */ SELECT INJECTION_POINTS_RUN('TestInjectionError');
/* notice */ SELECT INJECTION_POINTS_RUN('TestInjectionLog');
/* notice */ SELECT INJECTION_POINTS_RUN('TestInjectionError');
/* error */ /* Remove one entry and check the remaining entries. */ SELECT INJECTION_POINTS_DETACH('TestInjectionError');
/* ok */ SELECT INJECTION_POINTS_RUN('TestInjectionLog');
/* notice */ SELECT INJECTION_POINTS_RUN('TestInjectionError');
/* nothing */ /* More entries removed, letting TestInjectionLog2 to check the same */ /* callback used in more than one point. */ SELECT INJECTION_POINTS_DETACH('TestInjectionLog');
/* ok */ SELECT INJECTION_POINTS_RUN('TestInjectionLog');
/* nothing */ SELECT INJECTION_POINTS_RUN('TestInjectionError');
/* nothing */ SELECT INJECTION_POINTS_RUN('TestInjectionLog2');
/* notice */ SELECT INJECTION_POINTS_DETACH('TestInjectionLog');
/* fails */ SELECT INJECTION_POINTS_RUN('TestInjectionLog2');
/* notice */ SELECT INJECTION_POINTS_DETACH('TestInjectionLog2');
/* Loading */ SELECT INJECTION_POINTS_CACHED('TestInjectionLogLoad');
/* nothing in cache */ SELECT INJECTION_POINTS_LOAD('TestInjectionLogLoad');
/* nothing */ SELECT INJECTION_POINTS_ATTACH('TestInjectionLogLoad', 'notice');
SELECT INJECTION_POINTS_LOAD('TestInjectionLogLoad');
/* nothing happens */ SELECT INJECTION_POINTS_CACHED('TestInjectionLogLoad');
/* runs from cache */ SELECT INJECTION_POINTS_RUN('TestInjectionLogLoad');
/* runs from cache */ SELECT INJECTION_POINTS_DETACH('TestInjectionLogLoad');
/* Runtime conditions */ SELECT INJECTION_POINTS_ATTACH('TestConditionError', 'error');
/* Any follow-up injection point attached will be local to this process. */ SELECT INJECTION_POINTS_SET_LOCAL();
SELECT INJECTION_POINTS_ATTACH('TestConditionLocal1', 'error');
SELECT INJECTION_POINTS_ATTACH('TestConditionLocal2', 'notice');
SELECT INJECTION_POINTS_RUN('TestConditionLocal1');
/* error */ SELECT INJECTION_POINTS_RUN('TestConditionLocal2');
SELECT INJECTION_POINTS_RUN('TestConditionLocal1');
/* nothing */ SELECT INJECTION_POINTS_RUN('TestConditionLocal2');
/* nothing */ SELECT INJECTION_POINTS_RUN('TestConditionError');
/* error */ SELECT INJECTION_POINTS_DETACH('TestConditionError');
/* Attaching injection points that use the same name as one defined locally */ /* previously should work. */ SELECT INJECTION_POINTS_ATTACH('TestConditionLocal1', 'error');
SELECT INJECTION_POINTS_DETACH('TestConditionLocal1');
DROP EXTENSION injection_points;
DROP FUNCTION x;
/* Tests for REINDEX CONCURRENTLY */ CREATE EXTENSION injection_points;
/* Check safety of indexes with predicates and expressions. */ SELECT INJECTION_POINTS_SET_LOCAL();
SELECT INJECTION_POINTS_ATTACH('reindex-conc-index-safe', 'notice');
SELECT INJECTION_POINTS_ATTACH('reindex-conc-index-not-safe', 'notice');
CREATE SCHEMA x.x;
CREATE TABLE x.x (x INT PRIMARY KEY, x TIMESTAMP);
CREATE UNIQUE INDEX x ON x.x(x NULLS LAST);
CREATE UNIQUE INDEX x ON x.x(ABS(x) NULLS LAST);
CREATE UNIQUE INDEX x ON x.x(x NULLS LAST) WHERE x % 2 = 0;
CREATE UNIQUE INDEX x ON x.x(ABS(x) NULLS LAST) WHERE x % 2 = 0;
REINDEX INDEX CONCURRENTLY reindex_inj.ind_simple;
REINDEX INDEX CONCURRENTLY reindex_inj.ind_expr;
REINDEX INDEX CONCURRENTLY reindex_inj.ind_pred;
REINDEX INDEX CONCURRENTLY reindex_inj.ind_expr_pred;
/* Cleanup */ SELECT INJECTION_POINTS_DETACH('reindex-conc-index-safe');
SELECT INJECTION_POINTS_DETACH('reindex-conc-index-not-safe');
DROP TABLE x.x;
DROP SCHEMA x.x;
DROP EXTENSION injection_points;
CREATE TRUSTED LANGUAGE plsample   HANDLER plsample_call_handler;
ALTER LANGUAGE plsample OWNER TO @extowner@;
COMMENT ON LANGUAGE plsample IS 'PL/Sample procedural language';
CREATE EXTENSION plsample;
/* Create and test some dummy functions */ CREATE FUNCTION x(x DECIMAL, x TEXT, x ARRAY<INT>) RETURNS TEXT LANGUAGE plsample AS $$   Example of source with text result. $$;
SELECT PLSAMPLE_RESULT_TEXT(1.23, 'abc', '{4, 5, 6}');
CREATE FUNCTION x(x ARRAY<TEXT>) RETURNS VOID LANGUAGE plsample AS $$   Example of source with void result. $$;
SELECT PLSAMPLE_RESULT_VOID('{foo, bar, hoge}');
CREATE FUNCTION x() RETURNS trigger LANGUAGE plsample AS $$ if TD_event == "INSERT"     return TD_NEW elseif TD_event == "UPDATE"     return TD_NEW else     return "OK" end $$;
CREATE TABLE x (x INT, x TEXT);
CREATE TRIGGER my_trigger_func BEFORE INSERT OR UPDATE ON my_table        FOR EACH ROW EXECUTE FUNCTION my_trigger_func();
CREATE TRIGGER my_trigger_func2 AFTER INSERT OR UPDATE ON my_table        FOR EACH ROW EXECUTE FUNCTION my_trigger_func(8);
INSERT INTO x (x, x) VALUES (1, 'first');
UPDATE x SET x = 'first, modified once' WHERE x = 1;
CREATE FUNCTION spgist_name_choose(internal, internal) RETURNS void IMMUTABLE PARALLEL SAFE STRICT AS 'MODULE_PATHNAME' LANGUAGE C;
CREATE FUNCTION spgist_name_inner_consistent(internal, internal) RETURNS void IMMUTABLE PARALLEL SAFE STRICT AS 'MODULE_PATHNAME' LANGUAGE C;
CREATE FUNCTION spgist_name_leaf_consistent(internal, internal) RETURNS boolean IMMUTABLE PARALLEL SAFE STRICT AS 'MODULE_PATHNAME' LANGUAGE C;
CREATE FUNCTION spgist_name_compress(name) RETURNS text IMMUTABLE PARALLEL SAFE STRICT AS 'MODULE_PATHNAME' LANGUAGE C;
CREATE OPERATOR CLASS name_ops DEFAULT FOR TYPE name USING spgist AS 	OPERATOR	1	< , 	OPERATOR	2	<= , 	OPERATOR	3	= , 	OPERATOR	4	>= , 	OPERATOR	5	> , 	FUNCTION	1	spgist_name_config(internal, internal), 	FUNCTION	2	spgist_name_choose(internal, internal), 	FUNCTION	3	spg_text_picksplit(internal, internal), 	FUNCTION	4	spgist_name_inner_consistent(internal, internal), 	FUNCTION	5	spgist_name_leaf_consistent(internal, internal), 	FUNCTION	6	spgist_name_compress(name), 	STORAGE text;
/* Also test old-style where the STORAGE clause is disallowed */ CREATE OPERATOR CLASS name_ops_old FOR TYPE name USING spgist AS 	OPERATOR	1	< , 	OPERATOR	2	<= , 	OPERATOR	3	= , 	OPERATOR	4	>= , 	OPERATOR	5	> , 	FUNCTION	1	spgist_name_config(internal, internal), 	FUNCTION	2	spgist_name_choose(internal, internal), 	FUNCTION	3	spg_text_picksplit(internal, internal), 	FUNCTION	4	spgist_name_inner_consistent(internal, internal), 	FUNCTION	5	spgist_name_leaf_consistent(internal, internal), 	FUNCTION	6	spgist_name_compress(name);
create extension spgist_name_ops;
SELECT x, AMVALIDATE(x.x) FROM x AS x JOIN x AS x ON x.x = x WHERE x = 'spgist' AND x = 'name_ops';
/* warning expected here */ SELECT x, AMVALIDATE(x.x) FROM x AS x JOIN x AS x ON x.x = x WHERE x = 'spgist' AND x = 'name_ops_old';
CREATE TABLE x (x NAME, x INT, x TEXT);
CREATE INDEX ON x USING spgist(x NULLS LAST) INCLUDE (x, x);
VACUUM analyze t;
EXPLAIN (costs off) select * from t   where f1 > 'binary_upgrade_set_n' and f1 < 'binary_upgrade_set_p'   order by 1;
SELECT * FROM x WHERE x > 'binary_upgrade_set_n' AND x < 'binary_upgrade_set_p' ORDER BY 1 NULLS LAST;
CREATE INDEX ON x USING spgist(x x NULLS LAST) INCLUDE (x, x);
SELECT * FROM x WHERE x > 'binary_upgrade_set_n' AND x < 'binary_upgrade_set_p' ORDER BY 1 NULLS LAST;
CREATE EXTENSION test_bloomfilter;
/* See README for explanation of arguments: */ SELECT TEST_BLOOMFILTER(power => 23, nelements => 838861, seed => -1, tests => 1);
CREATE EXTENSION test_copy_callbacks;
CREATE TABLE x.x (x INT, x INT, x INT);
INSERT INTO x.x VALUES (1, 2, 3), (12, 34, 56), (123, 456, 789);
SELECT TEST_COPY_TO_CALLBACK(CAST('public.test' AS REGCLASS));
CREATE FUNCTION x(x) RETURNS TEXT IMMUTABLE STRICT LANGUAGE C AS 'MODULE_PATHNAME';
/* ALTER_FUNCTION */ ALTER FUNCTION plpgsql_function_trigger_1 ()    SET SCHEMA foo;
ALTER FUNCTION foo.plpgsql_function_trigger_1()   COST 10;
CREATE ROLE regress_alter_function_role;
ALTER FUNCTION plpgsql_function_trigger_2()   OWNER TO regress_alter_function_role;
DROP OWNED BY regress_alter_function_role;
DROP ROLE regress_alter_function_role;
/* ALTER_SEQUENCE */ ALTER SEQUENCE fkey_table_seq   MINVALUE 10   START 20   CACHE 1   NO CYCLE;
ALTER SEQUENCE fkey_table_seq   RENAME TO fkey_table_seq_renamed;
ALTER SEQUENCE fkey_table_seq_renamed   SET SCHEMA foo;
CREATE TABLE x (x INT);
ALTER TABLE x SET x = 50;
ALTER TABLE parent RESET (fillfactor);
ALTER TABLE x SET;
ALTER TABLE x SET;
CREATE INDEX x ON x(x NULLS LAST);
ALTER TABLE parent CLUSTER ON parent_index;
DROP INDEX x;
CREATE TABLE x INHERITS (x);
CREATE TABLE x INHERITS (x);
ALTER TABLE x ADD COLUMN x SERIAL;
ALTER TABLE x RENAME COLUMN x TO x;
ALTER TABLE ONLY x ADD CONSTRAINT x CHECK (x > 0) /* Constraint, no recursion */;
ALTER TABLE x ADD CONSTRAINT x CHECK (x > 0) /* Constraint, with recursion */;
CREATE TABLE x (x INT) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (1) TO (100);
CREATE TABLE x (x INT);
ALTER TABLE part ATTACH PARTITION part2 FOR VALUES FROM (101) to (200);
ALTER TABLE part DETACH PARTITION part2;
DROP TABLE x;
ALTER TABLE x ADD PRIMARY KEY (x NULLS LAST);
ALTER TABLE x ALTER COLUMN x SET NOT NULL;
ALTER TABLE x ALTER COLUMN x DROP NOT NULL;
ALTER TABLE x ALTER COLUMN x SET NOT NULL;
ALTER TABLE parent ALTER COLUMN a ADD GENERATED ALWAYS AS IDENTITY;
ALTER TABLE x ALTER COLUMN x DROP DEFAULT, SET GENERATED BY DEFAULT;
ALTER TABLE parent ALTER COLUMN a DROP IDENTITY;
ALTER TABLE x ALTER COLUMN x DROP DEFAULT, SET STATISTICS 100;
ALTER TABLE x ALTER COLUMN x DROP DEFAULT, SET STORAGE PLAIN;
ALTER TABLE parent ENABLE ROW LEVEL SECURITY;
ALTER TABLE parent NO FORCE ROW LEVEL SECURITY;
ALTER TABLE parent FORCE ROW LEVEL SECURITY;
ALTER TABLE parent DISABLE ROW LEVEL SECURITY;
CREATE STATISTICS parent_stat (dependencies) ON a, c FROM parent;
ALTER TABLE x ALTER COLUMN x SET DATA TYPE DECIMAL;
ALTER TABLE x ALTER COLUMN x SET DEFAULT 0;
CREATE TABLE x (x INT AS CAST(x AS INT) * 2, x TEXT);
ALTER TABLE tbl ALTER COLUMN a DROP EXPRESSION;
ALTER TABLE x ALTER COLUMN x DROP DEFAULT, SET COMPRESSION pglz;
CREATE TYPE comptype AS (r float8);
CREATE DOMAIN dcomptype AS comptype;
ALTER DOMAIN dcomptype ADD CONSTRAINT c1 check ((value).r > 0);
ALTER TYPE comptype ALTER ATTRIBUTE r TYPE bigint;
/* ALTER TEXT SEARCH CONFIGURATION */ CREATE TEXT SEARCH CONFIGURATION en (copy=english);
ALTER TEXT SEARCH CONFIGURATION en   ALTER MAPPING FOR host, email, url, sfloat WITH simple;
/* - */ /* - ALTER_TYPE_ENUM */ /* - */ ALTER TYPE enum_test ADD VALUE 'zzz' AFTER 'baz';
ALTER TYPE enum_test ADD VALUE 'aaa' BEFORE 'foo';
COMMENT ON SCHEMA x IS 'This is schema foo' /* COMMENT_ON */;
COMMENT ON TYPE enum_test IS 'ENUM test';
COMMENT ON TYPE int2range  IS 'RANGE test';
COMMENT ON DOMAIN japanese_postal_code IS 'DOMAIN test';
COMMENT ON SEQUENCE x IS 'SEQUENCE test';
COMMENT ON TABLE x IS 'This table should contain all native datatypes';
COMMENT ON VIEW x IS 'This is a view';
COMMENT ON FUNCTION x() IS 'FUNCTION test';
COMMENT ON TRIGGER trigger_1 ON datatype_table IS 'TRIGGER test';
COMMENT ON RULE rule_1 ON datatype_table IS 'RULE test';
/* - */ /* - CREATE_CONVERSION */ /* - */ /* Simple test should suffice for this */ CREATE CONVERSION myconv FOR 'LATIN1' TO 'UTF8' FROM iso8859_1_to_utf8;
/* - */ /* - CREATE_DOMAIN */ /* - */ CREATE DOMAIN domainvarchar VARCHAR(5);
CREATE DOMAIN japanese_postal_code AS TEXT CHECK(    VALUE ~ '^\d{3}$' OR VALUE ~ '^\d{3}-\d{4}$' );
/* - */ /* - CREATE_EXTENSION */ /* - */ CREATE EXTENSION pg_stat_statements;
/* - */ /* - CREATE_RULE */ /* - */ /* - Note: views' ON SELECT rules are tested elsewhere. */ /* - */ CREATE RULE rule_1 AS   ON INSERT   TO datatype_table   DO NOTHING;
CREATE RULE rule_2 AS   ON UPDATE   TO datatype_table   DO INSERT INTO unlogged_table (id) VALUES(NEW.id);
CREATE RULE rule_3 AS   ON DELETE   TO datatype_table   DO ALSO NOTHING;
CREATE RULE rule_3 AS   ON DELETE   TO like_datatype_table   WHERE id < 100   DO ALSO NOTHING;
/* CREATE_SCHEMA */ CREATE SCHEMA x.x;
CREATE SCHEMA IF NOT EXISTS x.x;
CREATE SCHEMA x.x;
/* Will not be created, and will not be handled by the */ /* event trigger */ CREATE SCHEMA IF NOT EXISTS x.x;
CREATE SCHEMA element_test   CREATE TABLE foo (id int)   CREATE VIEW bar AS SELECT * FROM foo;
/* CREATE_SEQUENCE */ CREATE SEQUENCE x START WITH 10 INCREMENT BY 1 MINVALUE 0 MAXVALUE 1000000 CACHE 10 CYCLE;
/* CREATE_TABLE */ /* Datatypes */ CREATE TABLE x (x SERIAL, x BIGSERIAL, x SMALLSERIAL, x VARBINARY, x SMALLINT, x INT, x BIGINT, x CHAR(1), x VARCHAR(10), x TEXT, x BOOLEAN, x INET, x CIDR, x MACADDR, x DECIMAL(1, 0), x FLOAT, x DOUBLE(1), x DOUBLE, x MONEY, x TSQUERY, x TSVECTOR, x DATE, x TIME, x TIMETZ, x TIMESTAMP, x TIMESTAMPTZ, x INTERVAL, x BIT, x BIT(4), x VARBIT, x VARBIT(4), x BOX, x CIRCLE, x LSEG, x PATH, x POINT, x POLYGON, x JSON, x XML, x UUID, x pg_snapshot, x ENUM_TEST, x japanese_postal_code, x int2range, PRIMARY KEY (x NULLS LAST), UNIQUE (x));
/* Typed table */ CREATE TABLE employees OF employee_type (     PRIMARY KEY (name),     salary WITH OPTIONS DEFAULT 1000 );
/* Inheritance */ CREATE TABLE x (x INT NOT NULL PRIMARY KEY, x TEXT, x INT, x point);
CREATE TABLE x (x INT, x NAME) INHERITS (x);
CREATE TABLE x (x DOUBLE) INHERITS (x);
CREATE TABLE x (x INT) INHERITS (x, x);
/* Storage parameters */ CREATE TABLE x (x INT) WITH (fillfactor=10, autovacuum_enabled=FALSE);
/* LIKE */ CREATE TABLE x (LIKE x EXCLUDING ALL);
CREATE TABLE x (LIKE x INCLUDING DEFAULTS INCLUDING INDEXES INCLUDING STORAGE);
/* Volatile table types */ CREATE UNLOGGED TABLE x (x INT PRIMARY KEY);
CREATE TEMPORARY TABLE x (x INT PRIMARY KEY);
CREATE TEMPORARY TABLE x (x INT PRIMARY KEY) ON COMMIT DELETE ROWS;
CREATE TEMP TABLE temp_table_commit_drop (     id INT PRIMARY KEY ) ON COMMIT DROP;
DROP TRANSFORM FOR int LANGUAGE SQL;
COMMIT;
CREATE TRIGGER trigger_1   BEFORE INSERT OR UPDATE   ON datatype_table   FOR EACH ROW   EXECUTE PROCEDURE plpgsql_function_trigger_1();
/* - */ /* - CREATE_TYPE */ /* - */ CREATE FUNCTION x(x) RETURNS text_w_default LANGUAGE internal STABLE STRICT AS 'textin';
CREATE FUNCTION x(x) RETURNS CSTRING LANGUAGE internal STABLE STRICT AS 'textout';
CREATE TYPE employee_type AS (name TEXT, salary NUMERIC);
CREATE TYPE enum_test AS ENUM ('foo', 'bar', 'baz');
CREATE TYPE int2range AS RANGE (   SUBTYPE = int2 );
/* CREATE_VIEW */ CREATE VIEW x AS SELECT CAST('foo' AS TEXT) AS x;
CREATE OR REPLACE VIEW x AS SELECT CAST('bar' AS TEXT) AS x;
CREATE VIEW x AS SELECT * FROM x;
CREATE RECURSIVE VIEW nums_1_100 (n) AS     VALUES (1) UNION ALL     SELECT n+1 FROM nums_1_100 WHERE n < 100;
/* ALTER DEFAULT PRIVILEGES */ ALTER DEFAULT PRIVILEGES IN SCHEMA public   REVOKE ALL PRIVILEGES ON TABLES FROM public;
/* Materialized views */ CREATE MATERIALIZED VIEW ddl_deparse_mv AS   SELECT * FROM datatype_table LIMIT 1 WITH NO DATA;
REFRESH MATERIALIZED VIEW ddl_deparse_mv;
/* copied from equivclass.sql */ create type int8alias1;
CREATE FUNCTION x(x) RETURNS int8alias1 STRICT IMMUTABLE LANGUAGE internal AS 'int8in';
CREATE FUNCTION x(x) RETURNS CSTRING STRICT IMMUTABLE LANGUAGE internal AS 'int8out';
create type int8alias1 (     input = int8alias1in,     output = int8alias1out,     like = int8 );
create type int8alias2;
CREATE FUNCTION x(x) RETURNS int8alias2 STRICT IMMUTABLE LANGUAGE internal AS 'int8in';
CREATE FUNCTION x(x) RETURNS CSTRING STRICT IMMUTABLE LANGUAGE internal AS 'int8out';
create type int8alias2 (     input = int8alias2in,     output = int8alias2out,     like = int8 );
create cast (int8 as int8alias1) without function;
create cast (int8 as int8alias2) without function;
create cast (int8alias1 as int8) without function;
create cast (int8alias2 as int8) without function;
CREATE FUNCTION x(x, x) RETURNS BOOLEAN STRICT IMMUTABLE LANGUAGE internal AS 'int8eq';
alter operator family integer_ops using btree add   operator 3 = (int8alias1, int8alias1);
/* copied from alter_table.sql */ create type ctype as (f1 int, f2 text);
CREATE FUNCTION x(x, x) RETURNS BOOLEAN LANGUAGE sql AS 'select $1.f1 is not distinct from $2.f1 and $1.f2 is not distinct from $2.f2';
create operator =(procedure = same, leftarg  = ctype, rightarg = ctype);
create operator class ctype_hash_ops   default for type ctype using hash as   operator 1 =(ctype, ctype);
CREATE EXTENSION test_ddl_deparse;
x AS x;
x AS x;
x AS x;
x AS x;
BEGIN FOR r IN SELECT * FROM pg_event_trigger_ddl_commands() 	LOOP 		-- verify that tags match 		tag = public.get_command_tag(r.command);
IF tag <> r.command_tag THEN 			RAISE NOTICE 'tag % doesn''t match %', tag, r.command_tag;
x /* log the operation */ = x.get_command_type(x.x);
IF cmdtype <> 'grant' THEN 			RAISE NOTICE 'DDL test: type %, tag %', cmdtype, tag;
IF cmdtype = 'alter table' THEN 			FOR r2 IN SELECT * 						FROM public.get_altertable_subcmdinfo(r.command) 			LOOP 				RAISE NOTICE '  subcommand: type % desc %', r2.cmdtype, r2.objdesc;
COMMIT;
CREATE EVENT TRIGGER test_ddl_deparse ON ddl_command_end EXECUTE PROCEDURE test_ddl_deparse();
CREATE FUNCTION x() RETURNS pg_catalog.void LANGUAGE C AS 'MODULE_PATHNAME';
CREATE EXTENSION test_dsa;
SELECT TEST_DSA_BASIC();
SELECT TEST_DSA_RESOWNERS();
CREATE FUNCTION x() RETURNS INT LANGUAGE C AS 'MODULE_PATHNAME';
CREATE EXTENSION test_dsm_registry;
SELECT SET_VAL_IN_SHMEM(1236);
ALTER TABLE x RENAME TO x, TO x;
UPDATE x SET x = 0;
grant usage on schema @extschema@ to public;
DROP TABLE x;
alter extension test_ext7 add sequence old_table1_col1_seq;
/* ordinary member tables with serial columns */ CREATE TABLE x (x SERIAL PRIMARY KEY);
CREATE TABLE x (x SERIAL PRIMARY KEY);
CREATE FUNCTIN my_erroneous_func(int) RETURNS int LANGUAGE SQL AS $$ SELECT $1 + 1 $$;
CREATE FUNCTION x(x) RETURNS INT LANGUAGE SQL AS $$ SELECT $1 + 1 $$;
CREATE FUNCTION x(x) RETURNS INT LANGUAGE SQL AS $$ SELECT $1 + , 1 $$;
CREATE FUNCTION x(x) RETURNS INT LANGUAGE SQL AS $$ SELECT $1 + 1 $$;
/* use it in regular and temporary tables and functions */ CREATE TABLE x (x posint);
CREATE TEMPORARY TABLE x (x posint);
CREATE FUNCTION x(x) RETURNS BOOLEAN LANGUAGE sql AS 'select ($1 % 2) = 0';
CREATE FUNCTION x.x(x) RETURNS BOOLEAN LANGUAGE sql AS 'select ($1 % 2) = 0';
CREATE TABLE x (x FLOAT, x FLOAT);
create type somecomposite as (f1 float8, f2 float8);
CREATE MATERIALIZED VIEW IF NOT EXISTS x AS SELECT 42 AS x;
CREATE SERVER IF NOT EXISTS ext_cine_srv FOREIGN DATA WRAPPER ext_cine_fdw;
CREATE SCHEMA IF NOT EXISTS x.x;
CREATE SEQUENCE IF NOT EXISTS x;
CREATE TABLE IF NOT EXISTS x (x INT);
CREATE TABLE IF NOT EXISTS x AS SELECT 42 AS x;
/* just to verify the script ran */ CREATE TABLE x (x INT);
CREATE MATERIALIZED VIEW IF NOT EXISTS x AS SELECT 42 AS x;
CREATE FOREIGN DATA WRAPPER ext_cine_fdw;
CREATE SERVER IF NOT EXISTS ext_cine_srv FOREIGN DATA WRAPPER ext_cine_fdw;
CREATE SCHEMA IF NOT EXISTS x.x;
CREATE SEQUENCE IF NOT EXISTS x;
CREATE TABLE IF NOT EXISTS x (x INT);
CREATE TABLE IF NOT EXISTS x AS SELECT 42 AS x;
CREATE OR REPLACE VIEW x AS SELECT CAST('ext_cor_view: from extension' AS TEXT) AS x;
/* These are for testing replacement of a shell type/operator, which works */ /* enough like an implicit OR REPLACE to be important to check. */ CREATE TYPE test_ext_type AS ENUM('x', 'y');
CREATE OPERATOR <<@@ ( PROCEDURE = pt_contained_poly,   LEFTARG = point, RIGHTARG = polygon );
ALTER TABLE x DROP COLUMN x;
CREATE EVENT TRIGGER table_rewrite_trg   ON table_rewrite   EXECUTE PROCEDURE _evt_table_rewrite_fnct();
COMMIT;
CREATE FUNCTION dep_req3b() RETURNS text LANGUAGE SQL IMMUTABLE PARALLEL SAFE AS $$ SELECT @extschema:test_ext_req_schema2@.dep_req2() || ' req3b' $$;
CREATE FUNCTION x(x) RETURNS TEXT AS BEGIN ATOMIC   SELECT f3 FROM ess_table WHERE f1 = $1;
COMMIT;
CREATE TYPE ess_range_type AS RANGE (subtype = text);
CREATE TYPE ess_composite_type AS (f1 int, f2 ess_range_type);
/* test ALTER THING name DEPENDS ON EXTENSION */ /* Common setup for all tests */ CREATE TABLE x (x TEXT);
COPY INTO x FROM x;
x AS x;
COMMIT;
/* make sure we have the right dependencies on the extension */ SELECT x, x.* FROM x, x AS x WHERE x = CAST('pg_extension' AS REGCLASS) AND x = (SELECT x FROM x WHERE x = 'test_ext5') ORDER BY x NULLS LAST;
DROP EXTENSION test_ext5;
/* anything still depending on the table? */ SELECT x, x.* FROM x.x, x AS x WHERE x = CAST('pg_class' AS REGCLASS) AND x = CAST('test_ext.a' AS REGCLASS) AND NOT x IN ('i', 'a');
DROP SCHEMA x.x CASCADE;
/* should fail, require cascade */ DROP TABLE x.x CASCADE;
/* anything still depending on the extension?  Should be only function b() */ SELECT x, x.* FROM x.x, x AS x WHERE x = CAST('pg_extension' AS REGCLASS) AND x = (SELECT x FROM x WHERE x = 'test_ext5');
DROP EXTENSION test_ext5;
DROP SCHEMA x.x CASCADE;
DROP TRIGGER c ON a;
DROP FUNCTION x;
DROP MATERIALIZED VIEW x;
DROP INDEX x;
SELECT x, x.* FROM x.x, x AS x WHERE (x = CAST('pg_extension' AS REGCLASS) AND x = (SELECT x FROM x WHERE x = 'test_ext5')) OR (x = CAST('pg_class' AS REGCLASS) AND x = CAST('test_ext.a' AS REGCLASS)) AND NOT x IN ('i', 'a');
DROP TABLE x;
RESET search_path;
DROP SCHEMA x.x CASCADE;
ALTER FUNCTION b() NO DEPENDS ON EXTENSION test_ext5;
ALTER TRIGGER c ON a NO DEPENDS ON EXTENSION test_ext5;
ALTER MATERIALIZED VIEW d NO DEPENDS ON EXTENSION test_ext5;
ALTER INDEX e NO DEPENDS ON EXTENSION test_ext5;
DROP EXTENSION test_ext5;
DROP TRIGGER c ON a;
DROP FUNCTION x;
DROP MATERIALIZED VIEW x;
DROP INDEX x;
DROP SCHEMA x.x CASCADE;
CREATE SCHEMA x.x;
/* test some errors */ CREATE EXTENSION test_ext1;
CREATE EXTENSION test_ext1 SCHEMA test_ext1;
CREATE EXTENSION test_ext1 SCHEMA test_ext;
CREATE EXTENSION test_ext1 SCHEMA has$dollar;
/* finally success */ CREATE EXTENSION test_ext1 SCHEMA has$dollar CASCADE;
SELECT x, x, x, x FROM x AS x, x AS x WHERE x LIKE 'test_ext%' AND x.x = x.x ORDER BY 1 NULLS LAST;
CREATE EXTENSION test_ext_cyclic1 CASCADE;
DROP SCHEMA x.x CASCADE;
CREATE SCHEMA x.x;
CREATE EXTENSION test_ext6;
DROP EXTENSION test_ext6;
CREATE EXTENSION test_ext6;
/* test dropping of member tables that own extensions: */ /* this table will be absorbed into test_ext7 */ CREATE TABLE x (x SERIAL PRIMARY KEY);
create extension test_ext7;
alter extension test_ext7 update to '2.2bad';
/* test handling of temp objects created by extensions */ create extension test_ext8;
/* \dx+ would expose a variable pg_temp_nn schema name, so we can't use it here */ SELECT REGEXP_REPLACE(PG_DESCRIBE_OBJECT(x, x, x), 'pg_temp_\d+', 'pg_temp', 'g') AS "x" FROM x WHERE x = CAST('pg_extension' AS REGCLASS) AND x = 'e' AND x = (SELECT x FROM x WHERE x = 'test_ext8') ORDER BY 1 NULLS LAST;
/* Should be possible to drop and recreate this extension */ drop extension test_ext8;
create extension test_ext8;
SELECT REGEXP_REPLACE(PG_DESCRIBE_OBJECT(x, x, x), 'pg_temp_\d+', 'pg_temp', 'g') AS "x" FROM x WHERE x = CAST('pg_extension' AS REGCLASS) AND x = 'e' AND x = (SELECT x FROM x WHERE x = 'test_ext8') ORDER BY 1 NULLS LAST;
BEGIN while (select count(*) from pg_stat_activity where pid = '     :'oldpid'   ') > 0 loop c := c + 1;
/* check handling of types as extension members */ create extension test_ext9;
/* First enforce presence of temporary schema. */ CREATE TEMPORARY TABLE x;
x AS x;
BEGIN SELECT INTO tmpschema pg_my_temp_schema()::regnamespace;
EXECUTE query;
COMMIT;
BEGIN;
SELECT CREATE_EXTENSION_WITH_TEMP_SCHEMA();
PREPARE TRANSACTION 'twophase_extension';
/* Clean up */ DROP TABLE x;
DROP FUNCTION x;
RESET client_min_messages;
ALTER EXTENSION test_ext_evttrig UPDATE TO '2.0';
DROP EXTENSION test_ext_evttrig;
/* check that too. */ CREATE FUNCTION x() RETURNS TEXT LANGUAGE sql AS $$ SELECT 'ext_cor_func: original'::text $$;
CREATE EXTENSION test_ext_cor;
/* fail */ SELECT EXT_COR_FUNC();
DROP FUNCTION x;
CREATE VIEW x AS SELECT CAST('ext_cor_view: original' AS TEXT) AS x;
CREATE EXTENSION test_ext_cor;
/* fail */ SELECT EXT_COR_FUNC();
SELECT * FROM x;
DROP VIEW x;
CREATE TYPE test_ext_type;
CREATE EXTENSION test_ext_cor;
/* fail */ DROP TYPE test_ext_type;
/* this makes a shell "point <<@@ polygon" operator too */ CREATE OPERATOR @@>> ( PROCEDURE = poly_contain_pt,   LEFTARG = polygon, RIGHTARG = point,   COMMUTATOR = <<@@ );
CREATE EXTENSION test_ext_cor;
/* fail */ DROP OPERATOR <<@@ (point, polygon);
CREATE EXTENSION test_ext_cor;
/* now it should work */ SELECT EXT_COR_FUNC();
SELECT * FROM x;
SELECT CAST('x' AS test_ext_type);
CREATE EXTENSION test_ext_cine;
/* fail */ DROP COLLATION ext_cine_coll;
CREATE MATERIALIZED VIEW x AS SELECT 11 AS x;
CREATE EXTENSION test_ext_cine;
/* fail */ DROP MATERIALIZED VIEW x;
CREATE FOREIGN DATA WRAPPER dummy;
CREATE SERVER ext_cine_srv FOREIGN DATA WRAPPER dummy;
CREATE EXTENSION test_ext_cine;
/* fail */ DROP SERVER ext_cine_srv;
CREATE SCHEMA x.x;
CREATE EXTENSION test_ext_cine;
/* fail */ DROP SCHEMA x.x;
CREATE SEQUENCE x;
CREATE EXTENSION test_ext_cine;
/* fail */ DROP SEQUENCE x;
CREATE TABLE x (x INT);
CREATE EXTENSION test_ext_cine;
/* fail */ DROP TABLE x;
CREATE TABLE x AS SELECT 42 AS x;
CREATE EXTENSION test_ext_cine;
/* fail */ DROP TABLE x;
CREATE EXTENSION test_ext_cine;
CREATE EXTENSION test_ext_extschema SCHEMA has$dollar;
CREATE EXTENSION test_ext_extschema SCHEMA "has space";
/* Test basic SET SCHEMA handling. */ CREATE SCHEMA x.x;
CREATE SCHEMA x.x;
CREATE EXTENSION test_ext_set_schema SCHEMA s1;
ALTER EXTENSION test_ext_set_schema SET SCHEMA s2;
CREATE SCHEMA x.x;
CREATE SCHEMA x.x;
CREATE EXTENSION test_ext_req_schema1 SCHEMA test_func_dep1;
ALTER FUNCTION test_func_dep1.dep_req1() SET SCHEMA test_func_dep2;
SELECT PG_DESCRIBE_OBJECT(x, x, x) AS x, PG_DESCRIBE_OBJECT(x, x, x) AS x, x FROM x WHERE x = CAST('pg_extension' AS REGCLASS) AND x = (SELECT x FROM x WHERE x = 'test_ext_req_schema1') ORDER BY 1 NULLS LAST, 2 NULLS LAST;
/* fails, as function dep_req1 is not in the same schema as the extension. */ ALTER EXTENSION test_ext_req_schema1 SET SCHEMA test_func_dep3;
/* Move back the function, and the extension can be moved. */ ALTER FUNCTION test_func_dep2.dep_req1() SET SCHEMA test_func_dep1;
ALTER EXTENSION test_ext_req_schema1 SET SCHEMA test_func_dep3;
SELECT PG_DESCRIBE_OBJECT(x, x, x) AS x, PG_DESCRIBE_OBJECT(x, x, x) AS x, x FROM x WHERE x = CAST('pg_extension' AS REGCLASS) AND x = (SELECT x FROM x WHERE x = 'test_ext_req_schema1') ORDER BY 1 NULLS LAST, 2 NULLS LAST;
DROP EXTENSION test_ext_req_schema1 CASCADE;
DROP SCHEMA x.x;
DROP SCHEMA x.x;
DROP SCHEMA x.x;
/* Test @extschema:extname@ syntax and no_relocate option */ CREATE EXTENSION test_ext_req_schema1 SCHEMA has$dollar;
CREATE EXTENSION test_ext_req_schema3 CASCADE;
DROP EXTENSION test_ext_req_schema1;
CREATE SCHEMA x.x;
CREATE EXTENSION test_ext_req_schema1 SCHEMA test_s_dep;
CREATE EXTENSION test_ext_req_schema3 CASCADE;
SELECT x.dep_req1();
SELECT DEP_REQ2();
SELECT DEP_REQ3();
SELECT DEP_REQ3B();
CREATE SCHEMA x.x;
ALTER EXTENSION test_ext_req_schema1 SET SCHEMA test_s_dep2;
/* fails */ ALTER EXTENSION test_ext_req_schema2 SET SCHEMA test_s_dep;
/* allowed */ SELECT x.dep_req1();
SELECT x.dep_req2();
SELECT DEP_REQ3();
SELECT DEP_REQ3B();
/* fails */ DROP EXTENSION test_ext_req_schema3;
ALTER EXTENSION test_ext_req_schema1 SET SCHEMA test_s_dep2;
/* now ok */ SELECT x.dep_req1();
SELECT x.dep_req2();
DROP EXTENSION test_ext_req_schema1 CASCADE;
CREATE EXTENSION test_ginpostinglist;
/* All the logic is in the test_ginpostinglist() function. It will throw */ /* an error if something fails. */ SELECT TEST_GINPOSTINGLIST();
CREATE EXTENSION test_integerset;
/* All the logic is in the test_integerset() function. It will throw */ /* an error if something fails. */ SELECT TEST_INTEGERSET();
CREATE FUNCTION x() RETURNS pg_catalog.void LANGUAGE C AS 'MODULE_PATHNAME';
CREATE FUNCTION x() RETURNS pg_catalog.void LANGUAGE C AS 'MODULE_PATHNAME';
CREATE EXTENSION test_lfind;
/* These tests don't produce any interesting output.  We're checking that */ /* the operations complete without crashing or hanging and that none of their */ /* internal sanity tests fail. */ SELECT TEST_LFIND8();
SELECT TEST_LFIND8_LE();
SELECT TEST_LFIND32();
SET x = 0 /* OAT checks for ALTER TABLE */ /* This test script fails if debug_discard_caches is enabled, because cache */ /* flushes cause extra calls of the OAT hook in recomputeNamespacePath, */ /* resulting in more NOTICE messages than are in the expected output. */;
LOAD 'test_oat_hooks';
SET x.x = TRUE;
CREATE SCHEMA x.x;
CREATE TABLE x.x (x INT, x TEXT);
CREATE RULE test_oat_notify AS   ON UPDATE TO test_oat_schema.test_oat_tab   DO ALSO NOTIFY test_oat_tab;
COMMIT;
CREATE TRIGGER test_oat_trigger BEFORE INSERT ON test_oat_schema.test_oat_tab   FOR EACH STATEMENT EXECUTE FUNCTION test_oat_schema.test_trigger();
/* RLS */ ALTER TABLE test_oat_schema.test_oat_tab ENABLE ROW LEVEL SECURITY;
ALTER TABLE test_oat_schema.test_oat_tab DISABLE ROW LEVEL SECURITY;
ALTER TABLE test_oat_schema.test_oat_tab FORCE ROW LEVEL SECURITY;
ALTER TABLE test_oat_schema.test_oat_tab NO FORCE ROW LEVEL SECURITY;
/* Rules */ ALTER TABLE test_oat_schema.test_oat_tab DISABLE RULE test_oat_notify;
ALTER TABLE test_oat_schema.test_oat_tab ENABLE RULE test_oat_notify;
/* Triggers */ ALTER TABLE test_oat_schema.test_oat_tab DISABLE TRIGGER test_oat_trigger;
ALTER TABLE test_oat_schema.test_oat_tab ENABLE TRIGGER test_oat_trigger;
DROP TABLE x.x;
SET x = 0 /* This test script fails if debug_discard_caches is enabled, because cache */ /* flushes cause extra calls of the OAT hook in recomputeNamespacePath, */ /* resulting in more NOTICE messages than are in the expected output. */;
/* Creating privileges on a placeholder GUC should create entries in the */ /* pg_parameter_acl catalog which conservatively grant no privileges to public. */ CREATE ROLE regress_role_joe;
GRANT SET ON PARAMETER test_oat_hooks.user_var1 TO regress_role_joe;
GRANT SET ON PARAMETER test_oat_hooks.super_var1 TO regress_role_joe;
/* SET commands fire both the ProcessUtility_hook and the */ /* object_access_hook_str.  Since the auditing GUC starts out false, we miss the */ /* initial "attempting" audit message from the ProcessUtility_hook, but we */ /* should thereafter see the audit messages. */ LOAD 'test_oat_hooks';
SET x.x = TRUE;
/* Creating privileges on an existent custom GUC should create precisely the */ /* right privileges, not overly conservative ones. */ GRANT SET ON PARAMETER test_oat_hooks.user_var2 TO regress_role_joe;
GRANT SET ON PARAMETER test_oat_hooks.super_var2 TO regress_role_joe;
/* Granting multiple privileges on a parameter should be reported correctly to */ /* the OAT hook, but beware that WITH GRANT OPTION is not represented. */ GRANT SET, ALTER SYSTEM ON PARAMETER none.such TO regress_role_joe;
GRANT SET, ALTER SYSTEM ON PARAMETER another.bogus TO regress_role_joe WITH GRANT OPTION;
/* Check when the hooks fire relative to dependency based abort of a drop */ DROP ROLE regress_role_joe;
/* Check the behavior of the hooks relative to do-nothing grants and revokes */ GRANT SET ON PARAMETER maintenance_work_mem TO PUBLIC;
REVOKE SET ON PARAMETER maintenance_work_mem FROM PUBLIC;
REVOKE ALTER SYSTEM ON PARAMETER maintenance_work_mem FROM PUBLIC;
/* Check the behavior of the hooks relative to unrecognized parameters */ GRANT ALL ON PARAMETER "none.such" TO PUBLIC;
/* Check relative to an operation that causes the catalog entry to be deleted */ REVOKE ALL ON PARAMETER "none.such" FROM PUBLIC;
/* Create objects for use in the test */ CREATE USER regress_test_user;
CREATE TABLE x (x TEXT);
CREATE INDEX x ON x(x NULLS LAST);
GRANT SELECT ON TABLE x TO x;
GRANT EXECUTE ON FUNCTION x TO x;
/* Do a few things as superuser */ SELECT * FROM x;
SELECT REGRESS_TEST_FUNC('arg');
SET x = 8192;
RESET work_mem;
ALTER SYSTEM SET work_mem = 8192;
ALTER SYSTEM RESET work_mem;
/* Do those same things as non-superuser */ SET SESSION AUTHORIZATION regress_test_user;
SELECT * FROM x;
SELECT REGRESS_TEST_FUNC('arg');
SET x = 8192;
RESET work_mem;
ALTER SYSTEM SET work_mem = 8192;
ALTER SYSTEM RESET work_mem;
SET x.x = TRUE;
SET x.x = TRUE;
ALTER SYSTEM SET test_oat_hooks.user_var1 = true;
ALTER SYSTEM SET test_oat_hooks.super_var1 = true;
SET x.x = TRUE;
SET x.x = TRUE;
ALTER SYSTEM SET test_oat_hooks.user_var2 = true;
ALTER SYSTEM SET test_oat_hooks.super_var2 = true;
RESET SESSION AUTHORIZATION;
SET x.x = TRUE /* Turn off non-superuser permissions */;
SET x.x = TRUE;
SET x.x = TRUE;
SET x.x = TRUE;
SET x.x = TRUE;
/* Try again as non-superuser with permissions denied */ SET SESSION AUTHORIZATION regress_test_user;
SELECT * FROM x;
SELECT REGRESS_TEST_FUNC('arg');
SET x = 8192;
RESET work_mem;
ALTER SYSTEM SET work_mem = 8192;
ALTER SYSTEM RESET work_mem;
/* try labelled drops */ RESET SESSION AUTHORIZATION;
DROP INDEX CONCURRENTLY x;
SET x.x = FALSE /* Clean up */;
DROP ROLE regress_role_joe;
/* fails */ REVOKE ALL PRIVILEGES ON PARAMETER 	none.such, another.bogus, 	test_oat_hooks.user_var1, test_oat_hooks.super_var1, 	test_oat_hooks.user_var2, test_oat_hooks.super_var2 	FROM regress_role_joe;
DROP ROLE regress_role_joe;
DROP ROLE regress_test_user;
CREATE FUNCTION x(x, x, x) RETURNS internal LANGUAGE C STRICT AS 'MODULE_PATHNAME';
CREATE FUNCTION x(x) RETURNS void LANGUAGE C STRICT AS 'MODULE_PATHNAME';
CREATE FUNCTION x(x) RETURNS internal LANGUAGE C STRICT AS 'MODULE_PATHNAME';
CREATE TEXT SEARCH PARSER testparser (     START    = testprs_start,     GETTOKEN = testprs_getlexeme,     END      = testprs_end,     HEADLINE = pg_catalog.prsd_headline,     LEXTYPES = testprs_lextype );
CREATE EXTENSION test_parser;
/* make test configuration using parser */ CREATE TEXT SEARCH CONFIGURATION testcfg (PARSER = testparser);
ALTER TEXT SEARCH CONFIGURATION testcfg ADD MAPPING FOR word WITH simple;
/* ts_parse */ SELECT * FROM x;
SELECT TO_TSVECTOR('testcfg', 'That''s my first own parser');
SELECT TO_TSQUERY('testcfg', 'star');
SELECT TS_HEADLINE('testcfg', 'Supernovae stars are the brightest phenomena in galaxies', TO_TSQUERY('testcfg', 'stars'));
CREATE SEQUENCE x;
CREATE SEQUENCE x;
SELECT x.pg_extension_config_dump('regress_seq_dumpable', '');
GRANT SELECT ON SEQUENCE x TO x;
CREATE TABLE x (x INT CHECK (x > 0));
SELECT x.pg_extension_config_dump('regress_table_dumpable', '');
GRANT SELECT ON x TO x;
CREATE SCHEMA x.x;
GRANT USAGE ON x TO x;
GRANT SELECT ON x TO x;
GRANT SELECT(x) ON x TO x;
GRANT SELECT(x) ON x TO x;
REVOKE SELECT(col2) ON regress_pg_dump_table FROM regress_dump_test_role;
CREATE FUNCTION x() RETURNS INT LANGUAGE SQL AS 'SELECT 1';
GRANT ALL ON FUNCTION x TO x WITH GRANT OPTION;
CREATE SEQUENCE x;
GRANT ALL ON SEQUENCE x TO x WITH GRANT OPTION;
REVOKE GRANT OPTION FOR SELECT ON SEQUENCE wgo_then_regular 	FROM pg_signal_backend;
CREATE ACCESS METHOD regress_test_am TYPE INDEX HANDLER bthandler;
/* Create a set of objects that are part of the schema created by */ /* this extension. */ CREATE TABLE x.x (x INT, x INT CHECK (x > 0));
GRANT SELECT ON x.x TO x;
CREATE SEQUENCE x.x;
GRANT USAGE ON x.x TO x;
CREATE TYPE regress_pg_dump_schema.test_type AS (col1 int);
GRANT USAGE ON TYPE regress_pg_dump_schema.test_type TO regress_dump_test_role;
GRANT EXECUTE ON FUNCTION x.x TO x;
CREATE AGGREGATE regress_pg_dump_schema.test_agg(int2) (SFUNC = int2_sum, STYPE = int8);
GRANT EXECUTE ON FUNCTION x.x TO x;
CREATE ROLE regress_dump_test_role;
CREATE EXTENSION test_pg_dump;
ALTER EXTENSION test_pg_dump ADD DATABASE postgres;
/* error */ CREATE TABLE x (x INT, x TEXT);
ALTER TABLE x DROP COLUMN x;
/* to exercise dropped-col cases */ CREATE VIEW x AS SELECT * FROM x;
CREATE MATERIALIZED VIEW x AS SELECT * FROM x;
CREATE SCHEMA x.x;
CREATE TYPE test_pg_dump_e1 AS ENUM ('abc', 'def');
CREATE AGGREGATE newavg (    sfunc = int4_avg_accum, basetype = int4, stype = _int8,    finalfunc = int8_avg,    initcond1 = '{0,0}' );
CREATE ACCESS METHOD gist2 TYPE INDEX HANDLER gisthandler;
CREATE TYPE casttesttype;
CREATE FUNCTION x(x) RETURNS casttesttype LANGUAGE internal STRICT IMMUTABLE AS 'textin';
CREATE FUNCTION x(x) RETURNS CSTRING LANGUAGE internal STRICT IMMUTABLE AS 'textout';
CREATE TYPE casttesttype (    internallength = variable,    input = casttesttype_in,    output = casttesttype_out,    alignment = int4 );
CREATE CAST (text AS casttesttype) WITHOUT FUNCTION;
CREATE FOREIGN DATA WRAPPER dummy;
CREATE SERVER s0 FOREIGN DATA WRAPPER dummy;
CREATE FOREIGN TABLE ft1 (         c1 integer OPTIONS ("param 1" 'val1') NOT NULL,         c2 text OPTIONS (param2 'val2', param3 'val3') CHECK (c2 <> ''),         c3 date,         CHECK (c3 BETWEEN '1994-01-01'::date AND '1994-01-31'::date) ) SERVER s0 OPTIONS (delimiter ',', quote '"', "be quoted" 'value');
REVOKE EXECUTE ON FUNCTION test_pg_dump(int) FROM PUBLIC;
GRANT EXECUTE ON FUNCTION x TO x;
GRANT SELECT(x) ON x TO x;
GRANT SELECT ON x TO x;
GRANT USAGE ON FOREIGN DATA WRAPPER dummy TO regress_dump_test_role;
GRANT USAGE ON FOREIGN SERVER s0 TO regress_dump_test_role;
GRANT SELECT(x) ON x TO x;
GRANT SELECT ON x TO x;
GRANT UPDATE ON x TO x;
GRANT USAGE ON SCHEMA x TO x;
GRANT USAGE ON TYPE test_pg_dump_e1 TO regress_dump_test_role;
/* Substitute for current user's name to keep test output consistent */ SELECT x.x, CASE WHEN CAST(CAST(x.x AS REGROLE) AS NAME) = QUOTE_IDENT(CURRENT_USER()) THEN 'postgres' ELSE CAST(CAST(x.x AS REGROLE) AS NAME) END, CASE WHEN CAST(CAST(x.x AS REGROLE) AS NAME) = QUOTE_IDENT(CURRENT_USER()) THEN 'postgres' ELSE CAST(CAST(x.x AS REGROLE) AS NAME) END, x.x, x.x FROM (SELECT PG_DESCRIBE_OBJECT(x, x, x) COLLATE "x" AS x, x FROM x WHERE x = 'e' ORDER BY 1 NULLS LAST) AS x, x AS x;
SELECT PG_DESCRIBE_OBJECT(x, x, x) COLLATE "x" AS x, PG_DESCRIBE_OBJECT(x, x, 0) AS x, x FROM x JOIN x AS x ON x = x.x WHERE x.x = CURRENT_DATABASE() ORDER BY 1 NULLS LAST, 3 NULLS LAST;
ALTER EXTENSION test_pg_dump ADD ACCESS METHOD gist2;
ALTER EXTENSION test_pg_dump ADD AGGREGATE newavg(int4);
ALTER EXTENSION test_pg_dump ADD CAST (text AS casttesttype);
ALTER EXTENSION test_pg_dump ADD FOREIGN DATA WRAPPER dummy;
ALTER EXTENSION test_pg_dump ADD FOREIGN TABLE ft1;
ALTER EXTENSION test_pg_dump ADD MATERIALIZED VIEW test_pg_dump_mv1;
ALTER EXTENSION test_pg_dump ADD OPERATOR ==== (int, int);
ALTER EXTENSION test_pg_dump ADD SCHEMA test_pg_dump_s1;
ALTER EXTENSION test_pg_dump ADD SERVER s0;
ALTER EXTENSION test_pg_dump ADD FUNCTION test_pg_dump(int);
ALTER EXTENSION test_pg_dump ADD TABLE test_pg_dump_t1;
ALTER EXTENSION test_pg_dump ADD TYPE test_pg_dump_e1;
ALTER EXTENSION test_pg_dump ADD VIEW test_pg_dump_v1;
REVOKE SELECT (c1) ON test_pg_dump_t1 FROM regress_dump_test_role;
REVOKE SELECT ON test_pg_dump_v1 FROM regress_dump_test_role;
REVOKE USAGE ON FOREIGN DATA WRAPPER dummy FROM regress_dump_test_role;
ALTER EXTENSION test_pg_dump DROP ACCESS METHOD gist2;
ALTER EXTENSION test_pg_dump DROP AGGREGATE newavg(int4);
ALTER EXTENSION test_pg_dump DROP CAST (text AS casttesttype);
ALTER EXTENSION test_pg_dump DROP FOREIGN DATA WRAPPER dummy;
ALTER EXTENSION test_pg_dump DROP FOREIGN TABLE ft1;
ALTER EXTENSION test_pg_dump DROP FUNCTION test_pg_dump(int);
ALTER EXTENSION test_pg_dump DROP MATERIALIZED VIEW test_pg_dump_mv1;
ALTER EXTENSION test_pg_dump DROP OPERATOR ==== (int, int);
ALTER EXTENSION test_pg_dump DROP SCHEMA test_pg_dump_s1;
ALTER EXTENSION test_pg_dump DROP SERVER s0;
ALTER EXTENSION test_pg_dump DROP TABLE test_pg_dump_t1;
ALTER EXTENSION test_pg_dump DROP TYPE test_pg_dump_e1;
ALTER EXTENSION test_pg_dump DROP VIEW test_pg_dump_v1;
DROP OWNED BY regress_dump_test_role RESTRICT;
/* Substitute for current user's name to keep test output consistent */ SELECT x.x, CASE WHEN CAST(CAST(x.x AS REGROLE) AS NAME) = QUOTE_IDENT(CURRENT_USER()) THEN 'postgres' ELSE CAST(CAST(x.x AS REGROLE) AS NAME) END, CASE WHEN CAST(CAST(x.x AS REGROLE) AS NAME) = QUOTE_IDENT(CURRENT_USER()) THEN 'postgres' ELSE CAST(CAST(x.x AS REGROLE) AS NAME) END, x.x, x.x FROM (SELECT PG_DESCRIBE_OBJECT(x, x, x) COLLATE "x" AS x, x FROM x WHERE x = 'e' ORDER BY 1 NULLS LAST) AS x, x AS x;
SELECT PG_DESCRIBE_OBJECT(x, x, x) COLLATE "x" AS x, PG_DESCRIBE_OBJECT(x, x, 0) AS x, x FROM x JOIN x AS x ON x = x.x WHERE x.x = CURRENT_DATABASE() ORDER BY 1 NULLS LAST, 3 NULLS LAST;
DROP ROLE regress_dump_test_role;
DROP EXTENSION test_pg_dump;
/* shouldn't be anything left in pg_init_privs */ SELECT * FROM x WHERE x = 'e';
CREATE ROLE regress_dump_test_role;
CREATE ROLE regress_dump_test_super SUPERUSER;
SET ROLE regress_dump_test_super;
CREATE EXTENSION test_pg_dump;
RESET ROLE;
/* Substitute for current user's name to keep test output consistent */ SELECT x.x, CASE WHEN CAST(CAST(x.x AS REGROLE) AS NAME) = QUOTE_IDENT(CURRENT_USER()) THEN 'postgres' ELSE CAST(CAST(x.x AS REGROLE) AS NAME) END, CASE WHEN CAST(CAST(x.x AS REGROLE) AS NAME) = QUOTE_IDENT(CURRENT_USER()) THEN 'postgres' ELSE CAST(CAST(x.x AS REGROLE) AS NAME) END, x.x, x.x FROM (SELECT PG_DESCRIBE_OBJECT(x, x, x) COLLATE "x" AS x, x FROM x WHERE x = 'e' ORDER BY 1 NULLS LAST) AS x, x AS x;
SELECT PG_DESCRIBE_OBJECT(x, x, x) COLLATE "x" AS x, PG_DESCRIBE_OBJECT(x, x, 0) AS x, x FROM x JOIN x AS x ON x = x.x WHERE x.x = CURRENT_DATABASE() ORDER BY 1 NULLS LAST, 2 NULLS LAST, 3 NULLS LAST;
/* Substitute for current user's name to keep test output consistent */ SELECT x.x, CASE WHEN CAST(CAST(x.x AS REGROLE) AS NAME) = QUOTE_IDENT(CURRENT_USER()) THEN 'postgres' ELSE CAST(CAST(x.x AS REGROLE) AS NAME) END, CASE WHEN CAST(CAST(x.x AS REGROLE) AS NAME) = QUOTE_IDENT(CURRENT_USER()) THEN 'postgres' ELSE CAST(CAST(x.x AS REGROLE) AS NAME) END, x.x, x.x FROM (SELECT PG_DESCRIBE_OBJECT(x, x, x) COLLATE "x" AS x, x FROM x WHERE x = 'e' ORDER BY 1 NULLS LAST) AS x, x AS x;
SELECT PG_DESCRIBE_OBJECT(x, x, x) COLLATE "x" AS x, PG_DESCRIBE_OBJECT(x, x, 0) AS x, x FROM x JOIN x AS x ON x = x.x WHERE x.x = CURRENT_DATABASE() ORDER BY 1 NULLS LAST, 2 NULLS LAST, 3 NULLS LAST;
DROP OWNED BY regress_dump_test_role RESTRICT;
/* Substitute for current user's name to keep test output consistent */ SELECT x.x, CASE WHEN CAST(CAST(x.x AS REGROLE) AS NAME) = QUOTE_IDENT(CURRENT_USER()) THEN 'postgres' ELSE CAST(CAST(x.x AS REGROLE) AS NAME) END, CASE WHEN CAST(CAST(x.x AS REGROLE) AS NAME) = QUOTE_IDENT(CURRENT_USER()) THEN 'postgres' ELSE CAST(CAST(x.x AS REGROLE) AS NAME) END, x.x, x.x FROM (SELECT PG_DESCRIBE_OBJECT(x, x, x) COLLATE "x" AS x, x FROM x WHERE x = 'e' ORDER BY 1 NULLS LAST) AS x, x AS x;
SELECT PG_DESCRIBE_OBJECT(x, x, x) COLLATE "x" AS x, PG_DESCRIBE_OBJECT(x, x, 0) AS x, x FROM x JOIN x AS x ON x = x.x WHERE x.x = CURRENT_DATABASE() ORDER BY 1 NULLS LAST, 2 NULLS LAST, 3 NULLS LAST;
DROP ROLE regress_dump_test_super;
DROP ROLE regress_dump_test_role;
CREATE EXTENSION test_predtest;
/* all combinations of two integers 0..9, plus null */ CREATE TABLE x AS SELECT CASE x % 11 WHEN 10 THEN NULL ELSE x % 11 END AS x, CASE (x / 11) % 11 WHEN 10 THEN NULL ELSE (x / 11) % 11 END AS x FROM x AS x;
x AS x;
x AS x;
/* Basic proof rules for single boolean variables */ SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
/* Assorted not-so-trivial refutation rules */ SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
/* Tests involving AND/OR constructs */ SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
/* Tests using btree operator knowledge */ SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
/* Cases using ScalarArrayOpExpr */ SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
/* In these tests, we want to prevent predtest.c from breaking down the */ /* ScalarArrayOpExpr into an AND/OR tree, so as to exercise the logic */ /* that handles ScalarArrayOpExpr directly.  We use opaque_array() if */ /* possible, otherwise an array longer than MAX_SAOP_ARRAY_SIZE. */ /* ScalarArrayOpExpr implies scalar IS NOT NULL */ SELECT * FROM x;
/* but for ALL, we have to be able to prove the array nonempty */ SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
/* check empty-array cases */ SELECT * FROM x;
SELECT * FROM x;
/* same thing under a strict function doesn't prove it */ SELECT * FROM x;
/* ScalarArrayOpExpr refutes scalar IS NULL */ SELECT * FROM x;
/* but for ALL, we have to be able to prove the array nonempty */ SELECT * FROM x;
SELECT * FROM x;
/* check empty-array cases */ SELECT * FROM x;
SELECT * FROM x;
/* same thing under a strict function doesn't prove it */ SELECT * FROM x;
/* Also, nullness of the scalar weakly refutes a SAOP */ SELECT * FROM x;
/* as does nullness of the array */ SELECT * FROM x;
/* ... unless we need to prove array empty */ SELECT * FROM x;
CREATE EXTENSION test_radixtree;
/* All the logic is in the test_radixtree() function. It will throw */ /* an error if something fails. */ SELECT TEST_RADIXTREE();
CREATE EXTENSION test_rbtree;
/* These tests don't produce any interesting output.  We're checking that */ /* the operations complete without crashing or hanging and that none of their */ /* internal sanity tests fail. */ SELECT TEST_RB_TREE(10000);
/* This file is based on tests/reg.test from the Tcl distribution, */ /* which is marked */ /* # Copyright (c) 1998, 1999 Henry Spencer.  All rights reserved. */ /* The full copyright notice can be found in src/backend/regex/COPYRIGHT. */ /* Most commented lines below are copied from reg.test.  Each */ /* test case is followed by an equivalent test using test_regex(). */ create extension test_regex;
SET x = on;
/* # support functions and preliminary misc. */ /* # This is sensitive to changes in message wording, but we really have to */ /* # test the code->message expansion at least once. */ /* ::tcltest::test reg-0.1 "regexp error reporting" { */ /*     list [catch {regexp (*) ign} msg] $msg */ /* } {1 {couldn't compile regular expression pattern: quantifier operand invalid}} */ SELECT * FROM x;
/* doing 1 "basic sanity checks" */ /* expectMatch	1.1 &		abc	abc		abc */ SELECT * FROM x;
SELECT * FROM x;
/* expectNomatch	1.2 &		abc	def */ SELECT * FROM x;
SELECT * FROM x;
/* expectMatch	1.3 &		abc	xyabxabce	abc */ SELECT * FROM x;
SELECT * FROM x;
/* doing 2 "invalid option combinations" */ /* expectError	2.1 qe		a	INVARG */ SELECT * FROM x;
/* expectError	2.2 qa		a	INVARG */ SELECT * FROM x;
/* expectError	2.3 qx		a	INVARG */ SELECT * FROM x;
/* expectError	2.4 qn		a	INVARG */ SELECT * FROM x;
/* expectError	2.5 ba		a	INVARG */ SELECT * FROM x;
/* doing 3 "basic syntax" */ /* expectIndices	3.1 &NS		""	a	{0 -1} */ SELECT * FROM x;
SELECT * FROM x;
/* expectMatch	3.2 NS		a|	a	a */ SELECT * FROM x;
/* expectMatch	3.3 -		a|b	a	a */ SELECT * FROM x;
/* expectMatch	3.4 -		a|b	b	b */ SELECT * FROM x;
/* expectMatch	3.5 NS		a||b	b	b */ SELECT * FROM x;
/* expectMatch	3.6 &		ab	ab	ab */ SELECT * FROM x;
SELECT * FROM x;
/* doing 4 "parentheses" */ /* expectMatch	4.1  -		(a)e		ae	ae	a */ SELECT * FROM x;
/* expectMatch	4.2  oPR	(.)\1e		abeaae	aae	{} */ SELECT * FROM x;
/* expectMatch	4.3  b		{\(a\)b}	ab	ab	a */ SELECT * FROM x;
/* expectMatch	4.4  -		a((b)c)		abc	abc	bc	b */ SELECT * FROM x;
/* expectMatch	4.5  -		a(b)(c)		abc	abc	b	c */ SELECT * FROM x;
/* expectError	4.6  -		a(b		EPAREN */ SELECT * FROM x;
/* expectError	4.7  b		{a\(b}		EPAREN */ SELECT * FROM x;
/* # sigh, we blew it on the specs here... someday this will be fixed in POSIX, */ /* #  but meanwhile, it's fixed in AREs */ /* expectMatch	4.8  eU		a)b		a)b	a)b */ SELECT * FROM x;
/* expectError	4.9  -		a)b		EPAREN */ SELECT * FROM x;
/* expectError	4.10 b		{a\)b}		EPAREN */ SELECT * FROM x;
/* expectMatch	4.11 P		a(?:b)c		abc	abc */ SELECT * FROM x;
/* expectError	4.12 e		a(?:b)c		BADRPT */ SELECT * FROM x;
/* expectIndices	4.13 S		a()b		ab	{0 1}	{1 0} */ SELECT * FROM x;
/* expectMatch	4.14 SP		a(?:)b		ab	ab */ SELECT * FROM x;
/* expectIndices	4.15 S		a(|b)c		ac	{0 1}	{1 0} */ SELECT * FROM x;
/* expectMatch	4.16 S		a(b|)c		abc	abc	b */ SELECT * FROM x;
/* doing 5 "simple one-char matching" */ /* # general case of brackets done later */ /* expectMatch	5.1 &		a.b		axb	axb */ SELECT * FROM x;
SELECT * FROM x;
/* expectNomatch	5.2 &n		"a.b"		"a\nb" */ SELECT * FROM x;
SELECT * FROM x;
/* expectMatch	5.3 &		{a[bc]d}	abd	abd */ SELECT * FROM x;
SELECT * FROM x;
/* expectMatch	5.4 &		{a[bc]d}	acd	acd */ SELECT * FROM x;
SELECT * FROM x;
/* expectNomatch	5.5 &		{a[bc]d}	aed */ SELECT * FROM x;
SELECT * FROM x;
/* expectNomatch	5.6 &		{a[^bc]d}	abd */ SELECT * FROM x;
SELECT * FROM x;
/* expectMatch	5.7 &		{a[^bc]d}	aed	aed */ SELECT * FROM x;
SELECT * FROM x;
/* expectNomatch	5.8 &p		"a\[^bc]d"	"a\nd" */ SELECT * FROM x;
SELECT * FROM x;
/* doing 6 "context-dependent syntax" */ /* # plus odds and ends */ /* expectError	6.1  -		*	BADRPT */ SELECT * FROM x;
/* expectMatch	6.2  b		*	*	* */ SELECT * FROM x;
/* expectMatch	6.3  b		{\(*\)}	*	*	* */ SELECT * FROM x;
/* expectError	6.4  -		(*)	BADRPT */ SELECT * FROM x;
/* expectMatch	6.5  b		^*	*	* */ SELECT * FROM x;
/* expectError	6.6  -		^*	BADRPT */ SELECT * FROM x;
/* expectNomatch	6.7  &		^b	^b */ SELECT * FROM x;
SELECT * FROM x;
/* expectMatch	6.8  b		x^	x^	x^ */ SELECT * FROM x;
/* expectNomatch	6.9  I		x^	x */ SELECT * FROM x;
/* expectMatch	6.10 n		"\n^"	"x\nb"	"\n" */ SELECT * FROM x;
/* expectNomatch	6.11 bS		{\(^b\)} ^b */ SELECT * FROM x;
/* expectMatch	6.12 -		(^b)	b	b	b */ SELECT * FROM x;
/* expectMatch	6.13 &		{x$}	x	x */ SELECT * FROM x;
SELECT * FROM x;
/* expectMatch	6.14 bS		{\(x$\)} x	x	x */ SELECT * FROM x;
/* expectMatch	6.15 -		{(x$)}	x	x	x */ SELECT * FROM x;
/* expectMatch	6.16 b		{x$y}	"x\$y"	"x\$y" */ SELECT * FROM x;
/* expectNomatch	6.17 I		{x$y}	xy */ SELECT * FROM x;
/* expectMatch	6.18 n		"x\$\n"	"x\n"	"x\n" */ SELECT * FROM x;
/* expectError	6.19 -		+	BADRPT */ SELECT * FROM x;
/* expectError	6.20 -		?	BADRPT */ SELECT * FROM x;
/* These two are not yet incorporated in Tcl, cf */ /* https://core.tcl-lang.org/tcl/tktview?name=5ea71fdcd3291c38 */ /* expectError	6.21 -		{x(\w)(?=(\1))}	ESUBREG */ SELECT * FROM x;
/* expectMatch	6.22 HP		{x(?=((foo)))}	xfoo	x */ SELECT * FROM x;
/* doing 7 "simple quantifiers" */ /* expectMatch	7.1  &N		a*	aa	aa */ SELECT * FROM x;
SELECT * FROM x;
/* expectIndices	7.2  &N		a*	b	{0 -1} */ SELECT * FROM x;
SELECT * FROM x;
/* expectMatch	7.3  -		a+	aa	aa */ SELECT * FROM x;
/* expectMatch	7.4  -		a?b	ab	ab */ SELECT * FROM x;
/* expectMatch	7.5  -		a?b	b	b */ SELECT * FROM x;
/* expectError	7.6  -		**	BADRPT */ SELECT * FROM x;
/* expectMatch	7.7  bN		**	***	*** */ SELECT * FROM x;
/* expectError	7.8  &		a**	BADRPT */ SELECT * FROM x;
SELECT * FROM x;
/* expectError	7.9  &		a**b	BADRPT */ SELECT * FROM x;
SELECT * FROM x;
/* expectError	7.10 &		***	BADRPT */ SELECT * FROM x;
SELECT * FROM x;
/* expectError	7.11 -		a++	BADRPT */ SELECT * FROM x;
/* expectError	7.12 -		a?+	BADRPT */ SELECT * FROM x;
/* expectError	7.13 -		a?*	BADRPT */ SELECT * FROM x;
/* expectError	7.14 -		a+*	BADRPT */ SELECT * FROM x;
/* expectError	7.15 -		a*+	BADRPT */ SELECT * FROM x;
SELECT * FROM x;
/* doing 8 "braces" */ /* expectMatch	8.1  NQ		"a{0,1}"	""	"" */ SELECT * FROM x;
/* expectMatch	8.2  NQ		"a{0,1}"	ac	a */ SELECT * FROM x;
/* expectError	8.3  -		"a{1,0}"	BADBR */ SELECT * FROM x;
/* expectError	8.4  -		"a{1,2,3}"	BADBR */ SELECT * FROM x;
/* expectError	8.5  -		"a{257}"	BADBR */ SELECT * FROM x;
/* expectError	8.6  -		"a{1000}"	BADBR */ SELECT * FROM x;
/* expectError	8.7  -		"a{1"		EBRACE */ SELECT * FROM x;
/* expectError	8.8  -		"a{1n}"		BADBR */ SELECT * FROM x;
/* expectMatch	8.9  BS		"a{b"		"a\{b"	"a\{b" */ SELECT * FROM x;
/* expectMatch	8.10 BS		"a{"		"a\{"	"a\{" */ SELECT * FROM x;
/* expectMatch	8.11 bQ		"a\\{0,1\\}b"	cb	b */ SELECT * FROM x;
/* expectError	8.12 b		"a\\{0,1"	EBRACE */ SELECT * FROM x;
/* expectError	8.13 -		"a{0,1\\"	BADBR */ SELECT * FROM x;
/* expectMatch	8.14 Q		"a{0}b"		ab	b */ SELECT * FROM x;
/* expectMatch	8.15 Q		"a{0,0}b"	ab	b */ SELECT * FROM x;
/* expectMatch	8.16 Q		"a{0,1}b"	ab	ab */ SELECT * FROM x;
/* expectMatch	8.17 Q		"a{0,2}b"	b	b */ SELECT * FROM x;
/* expectMatch	8.18 Q		"a{0,2}b"	aab	aab */ SELECT * FROM x;
/* expectMatch	8.19 Q		"a{0,}b"	aab	aab */ SELECT * FROM x;
/* expectMatch	8.20 Q		"a{1,1}b"	aab	ab */ SELECT * FROM x;
/* expectMatch	8.21 Q		"a{1,3}b"	aaaab	aaab */ SELECT * FROM x;
/* expectNomatch	8.22 Q		"a{1,3}b"	b */ SELECT * FROM x;
/* expectMatch	8.23 Q		"a{1,}b"	aab	aab */ SELECT * FROM x;
/* expectNomatch	8.24 Q		"a{2,3}b"	ab */ SELECT * FROM x;
/* expectMatch	8.25 Q		"a{2,3}b"	aaaab	aaab */ SELECT * FROM x;
/* expectNomatch	8.26 Q		"a{2,}b"	ab */ SELECT * FROM x;
/* expectMatch	8.27 Q		"a{2,}b"	aaaab	aaaab */ SELECT * FROM x;
/* doing 9 "brackets" */ /* expectMatch	9.1  &		{a[bc]}		ac	ac */ SELECT * FROM x;
SELECT * FROM x;
/* expectMatch	9.2  &		{a[-]}		a-	a- */ SELECT * FROM x;
SELECT * FROM x;
/* expectMatch	9.3  &		{a[[.-.]]}	a-	a- */ SELECT * FROM x;
SELECT * FROM x;
/* expectMatch	9.4  &L		{a[[.zero.]]}	a0	a0 */ SELECT * FROM x;
SELECT * FROM x;
/* expectMatch	9.5  &LM	{a[[.zero.]-9]}	a2	a2 */ SELECT * FROM x;
SELECT * FROM x;
/* expectMatch	9.6  &M		{a[0-[.9.]]}	a2	a2 */ SELECT * FROM x;
SELECT * FROM x;
/* expectMatch	9.7  &+L	{a[[=x=]]}	ax	ax */ SELECT * FROM x;
SELECT * FROM x;
/* expectMatch	9.8  &+L	{a[[=x=]]}	ay	ay */ SELECT * FROM x;
SELECT * FROM x;
/* expectNomatch	9.9  &+L	{a[[=x=]]}	az */ SELECT * FROM x;
SELECT * FROM x;
/* expectMatch	9.9b  &iL	{a[[=Y=]]}	ay	ay */ SELECT * FROM x;
SELECT * FROM x;
/* expectNomatch	9.9c  &L	{a[[=Y=]]}	ay */ SELECT * FROM x;
SELECT * FROM x;
/* expectError	9.10 &		{a[0-[=x=]]}	ERANGE */ SELECT * FROM x;
SELECT * FROM x;
/* expectMatch	9.11 &L		{a[[:digit:]]}	a0	a0 */ SELECT * FROM x;
SELECT * FROM x;
/* expectError	9.12 &		{a[[:woopsie:]]}	ECTYPE */ SELECT * FROM x;
SELECT * FROM x;
/* expectNomatch	9.13 &L		{a[[:digit:]]}	ab */ SELECT * FROM x;
SELECT * FROM x;
/* expectError	9.14 &		{a[0-[:digit:]]}	ERANGE */ SELECT * FROM x;
SELECT * FROM x;
/* expectMatch	9.15 &LP	{[[:<:]]a}	a	a */ SELECT * FROM x;
SELECT * FROM x;
/* expectMatch	9.16 &LP	{a[[:>:]]}	a	a */ SELECT * FROM x;
SELECT * FROM x;
/* expectError	9.17 &		{a[[..]]b}	ECOLLATE */ SELECT * FROM x;
SELECT * FROM x;
/* expectError	9.18 &		{a[[==]]b}	ECOLLATE */ SELECT * FROM x;
SELECT * FROM x;
/* expectError	9.19 &		{a[[::]]b}	ECTYPE */ SELECT * FROM x;
SELECT * FROM x;
/* expectError	9.20 &		{a[[.a}		EBRACK */ SELECT * FROM x;
SELECT * FROM x;
/* expectError	9.21 &		{a[[=a}		EBRACK */ SELECT * FROM x;
SELECT * FROM x;
/* expectError	9.22 &		{a[[:a}		EBRACK */ SELECT * FROM x;
SELECT * FROM x;
/* expectError	9.23 &		{a[}		EBRACK */ SELECT * FROM x;
SELECT * FROM x;
/* expectError	9.24 &		{a[b}		EBRACK */ SELECT * FROM x;
SELECT * FROM x;
/* expectError	9.25 &		{a[b-}		EBRACK */ SELECT * FROM x;
SELECT * FROM x;
/* expectError	9.26 &		{a[b-c}		EBRACK */ SELECT * FROM x;
SELECT * FROM x;
/* expectMatch	9.27 &M		{a[b-c]}	ab	ab */ SELECT * FROM x;
SELECT * FROM x;
/* expectMatch	9.28 &		{a[b-b]}	ab	ab */ SELECT * FROM x;
SELECT * FROM x;
/* expectMatch	9.29 &M		{a[1-2]}	a2	a2 */ SELECT * FROM x;
SELECT * FROM x;
/* expectError	9.30 &		{a[c-b]}	ERANGE */ SELECT * FROM x;
SELECT * FROM x;
/* expectError	9.31 &		{a[a-b-c]}	ERANGE */ SELECT * FROM x;
SELECT * FROM x;
/* expectMatch	9.32 &M		{a[--?]b}	a?b	a?b */ SELECT * FROM x;
SELECT * FROM x;
/* expectMatch	9.33 &		{a[---]b}	a-b	a-b */ SELECT * FROM x;
SELECT * FROM x;
/* expectMatch	9.34 &		{a[]b]c}	a]c	a]c */ SELECT * FROM x;
SELECT * FROM x;
/* expectMatch	9.35 EP		{a[\]]b}	a]b	a]b */ SELECT * FROM x;
/* expectNomatch	9.36 bE		{a[\]]b}	a]b */ SELECT * FROM x;
/* expectMatch	9.37 bE		{a[\]]b}	"a\\]b"	"a\\]b" */ SELECT * FROM x;
/* expectMatch	9.38 eE		{a[\]]b}	"a\\]b"	"a\\]b" */ SELECT * FROM x;
/* expectMatch	9.39 EP		{a[\\]b}	"a\\b"	"a\\b" */ SELECT * FROM x;
/* expectMatch	9.40 eE		{a[\\]b}	"a\\b"	"a\\b" */ SELECT * FROM x;
/* expectMatch	9.41 bE		{a[\\]b}	"a\\b"	"a\\b" */ SELECT * FROM x;
/* expectError	9.42 -		{a[\Z]b}	EESCAPE */ SELECT * FROM x;
/* expectMatch	9.43 &		{a[[b]c}	"a\[c"	"a\[c" */ SELECT * FROM x;
SELECT * FROM x;
/* This only works in UTF8 encoding, so it's moved to test_regex_utf8.sql: */ /* expectMatch	9.44 EMP*	{a[\u00fe-\u0507][\u00ff-\u0300]b} \ */ /* 	"a\u0102\u02ffb"	"a\u0102\u02ffb" */ /* doing 10 "anchors and newlines" */ /* expectMatch	10.1  &		^a	a	a */ SELECT * FROM x;
SELECT * FROM x;
/* expectNomatch	10.2  &^	^a	a */ SELECT * FROM x;
SELECT * FROM x;
/* expectIndices	10.3  &N	^	a	{0 -1} */ SELECT * FROM x;
SELECT * FROM x;
/* expectIndices	10.4  &		{a$}	aba	{2 2} */ SELECT * FROM x;
SELECT * FROM x;
/* expectNomatch	10.5  {&$}	{a$}	a */ SELECT * FROM x;
SELECT * FROM x;
/* expectIndices	10.6  &N	{$}	ab	{2 1} */ SELECT * FROM x;
SELECT * FROM x;
/* expectMatch	10.7  &n	^a	a	a */ SELECT * FROM x;
SELECT * FROM x;
/* expectMatch	10.8  &n	"^a"	"b\na"	"a" */ SELECT * FROM x;
SELECT * FROM x;
/* expectIndices	10.9  &w	"^a"	"a\na"	{0 0} */ SELECT * FROM x;
SELECT * FROM x;
/* expectIndices	10.10 &n^	"^a"	"a\na"	{2 2} */ SELECT * FROM x;
SELECT * FROM x;
/* expectMatch	10.11 &n	{a$}	a	a */ SELECT * FROM x;
SELECT * FROM x;
/* expectMatch	10.12 &n	"a\$"	"a\nb"	"a" */ SELECT * FROM x;
SELECT * FROM x;
/* expectIndices	10.13 &n	"a\$"	"a\na"	{0 0} */ SELECT * FROM x;
SELECT * FROM x;
/* expectIndices	10.14 N		^^	a	{0 -1} */ SELECT * FROM x;
/* expectMatch	10.15 b		^^	^	^ */ SELECT * FROM x;
/* expectIndices	10.16 N		{$$}	a	{1 0} */ SELECT * FROM x;
/* expectMatch	10.17 b		{$$}	"\$"	"\$" */ SELECT * FROM x;
/* expectMatch	10.18 &N	{^$}	""	"" */ SELECT * FROM x;
SELECT * FROM x;
/* expectNomatch	10.19 &N	{^$}	a */ SELECT * FROM x;
SELECT * FROM x;
/* expectIndices	10.20 &nN	"^\$"	a\n\nb	{2 1} */ SELECT * FROM x;
SELECT * FROM x;
/* expectMatch	10.21 N		{$^}	""	"" */ SELECT * FROM x;
/* expectMatch	10.22 b		{$^}	"\$^"	"\$^" */ SELECT * FROM x;
/* expectMatch	10.23 P		{\Aa}	a	a */ SELECT * FROM x;
/* expectMatch	10.24 ^P	{\Aa}	a	a */ SELECT * FROM x;
/* expectNomatch	10.25 ^nP	{\Aa}	"b\na" */ SELECT * FROM x;
/* expectMatch	10.26 P		{a\Z}	a	a */ SELECT * FROM x;
/* expectMatch	10.27 \$P	{a\Z}	a	a */ SELECT * FROM x;
/* expectNomatch	10.28 \$nP	{a\Z}	"a\nb" */ SELECT * FROM x;
/* expectError	10.29 -		^*	BADRPT */ SELECT * FROM x;
/* expectError	10.30 -		{$*}	BADRPT */ SELECT * FROM x;
/* expectError	10.31 -		{\A*}	BADRPT */ SELECT * FROM x;
/* expectError	10.32 -		{\Z*}	BADRPT */ SELECT * FROM x;
/* doing 11 "boundary constraints" */ /* expectMatch	11.1  &LP	{[[:<:]]a}	a	a */ SELECT * FROM x;
SELECT * FROM x;
/* expectMatch	11.2  &LP	{[[:<:]]a}	-a	a */ SELECT * FROM x;
SELECT * FROM x;
/* expectNomatch	11.3  &LP	{[[:<:]]a}	ba */ SELECT * FROM x;
SELECT * FROM x;
/* expectMatch	11.4  &LP	{a[[:>:]]}	a	a */ SELECT * FROM x;
SELECT * FROM x;
/* expectMatch	11.5  &LP	{a[[:>:]]}	a-	a */ SELECT * FROM x;
SELECT * FROM x;
/* expectNomatch	11.6  &LP	{a[[:>:]]}	ab */ SELECT * FROM x;
SELECT * FROM x;
/* expectMatch	11.7  bLP	{\<a}		a	a */ SELECT * FROM x;
/* expectNomatch	11.8  bLP	{\<a}		ba */ SELECT * FROM x;
/* expectMatch	11.9  bLP	{a\>}		a	a */ SELECT * FROM x;
/* expectNomatch	11.10 bLP	{a\>}		ab */ SELECT * FROM x;
/* expectMatch	11.11 LP	{\ya}		a	a */ SELECT * FROM x;
/* expectNomatch	11.12 LP	{\ya}		ba */ SELECT * FROM x;
/* expectMatch	11.13 LP	{a\y}		a	a */ SELECT * FROM x;
/* expectNomatch	11.14 LP	{a\y}		ab */ SELECT * FROM x;
/* expectMatch	11.15 LP	{a\Y}		ab	a */ SELECT * FROM x;
/* expectNomatch	11.16 LP	{a\Y}		a- */ SELECT * FROM x;
/* expectNomatch	11.17 LP	{a\Y}		a */ SELECT * FROM x;
/* expectNomatch	11.18 LP	{-\Y}		-a */ SELECT * FROM x;
/* expectMatch	11.19 LP	{-\Y}		-%	- */ SELECT * FROM x;
/* expectNomatch	11.20 LP	{\Y-}		a- */ SELECT * FROM x;
/* expectError	11.21 -		{[[:<:]]*}	BADRPT */ SELECT * FROM x;
/* expectError	11.22 -		{[[:>:]]*}	BADRPT */ SELECT * FROM x;
/* expectError	11.23 b		{\<*}		BADRPT */ SELECT * FROM x;
/* expectError	11.24 b		{\>*}		BADRPT */ SELECT * FROM x;
/* expectError	11.25 -		{\y*}		BADRPT */ SELECT * FROM x;
/* expectError	11.26 -		{\Y*}		BADRPT */ SELECT * FROM x;
/* expectMatch	11.27 LP	{\ma}		a	a */ SELECT * FROM x;
/* expectNomatch	11.28 LP	{\ma}		ba */ SELECT * FROM x;
/* expectMatch	11.29 LP	{a\M}		a	a */ SELECT * FROM x;
/* expectNomatch	11.30 LP	{a\M}		ab */ SELECT * FROM x;
/* expectNomatch	11.31 ILP	{\Ma}		a */ SELECT * FROM x;
/* expectNomatch	11.32 ILP	{a\m}		a */ SELECT * FROM x;
/* doing 12 "character classes" */ /* expectMatch	12.1  LP	{a\db}		a0b	a0b */ SELECT * FROM x;
/* expectNomatch	12.2  LP	{a\db}		axb */ SELECT * FROM x;
/* expectNomatch	12.3  LP	{a\Db}		a0b */ SELECT * FROM x;
/* expectMatch	12.4  LP	{a\Db}		axb	axb */ SELECT * FROM x;
/* expectMatch	12.5  LP	"a\\sb"		"a b"	"a b" */ SELECT * FROM x;
/* expectMatch	12.6  LP	"a\\sb"		"a\tb"	"a\tb" */ SELECT * FROM x;
/* expectMatch	12.7  LP	"a\\sb"		"a\nb"	"a\nb" */ SELECT * FROM x;
/* expectNomatch	12.8  LP	{a\sb}		axb */ SELECT * FROM x;
/* expectMatch	12.9  LP	{a\Sb}		axb	axb */ SELECT * FROM x;
/* expectNomatch	12.10 LP	"a\\Sb"		"a b" */ SELECT * FROM x;
/* expectMatch	12.11 LP	{a\wb}		axb	axb */ SELECT * FROM x;
/* expectNomatch	12.12 LP	{a\wb}		a-b */ SELECT * FROM x;
/* expectNomatch	12.13 LP	{a\Wb}		axb */ SELECT * FROM x;
/* expectMatch	12.14 LP	{a\Wb}		a-b	a-b */ SELECT * FROM x;
/* expectMatch	12.15 LP	{\y\w+z\y}	adze-guz	guz */ SELECT * FROM x;
/* expectMatch	12.16 LPE	{a[\d]b}	a1b	a1b */ SELECT * FROM x;
/* expectMatch	12.17 LPE	"a\[\\s]b"	"a b"	"a b" */ SELECT * FROM x;
/* expectMatch	12.18 LPE	{a[\w]b}	axb	axb */ SELECT * FROM x;
/* these should be invalid */ SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
/* test complemented char classes within brackets */ SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
/* bug #18708: */ SELECT * FROM x;
SELECT * FROM x;
/* check char classes' handling of newlines */ SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
/* doing 13 "escapes" */ /* expectError	13.1  &		"a\\"		EESCAPE */ SELECT * FROM x;
SELECT * FROM x;
/* expectMatch	13.2  -		{a\<b}		a<b	a<b */ SELECT * FROM x;
/* expectMatch	13.3  e		{a\<b}		a<b	a<b */ SELECT * FROM x;
/* expectMatch	13.4  bAS	{a\wb}		awb	awb */ SELECT * FROM x;
/* expectMatch	13.5  eAS	{a\wb}		awb	awb */ SELECT * FROM x;
/* expectMatch	13.6  PL	"a\\ab"		"a\007b"	"a\007b" */ SELECT * FROM x;
/* expectMatch	13.7  P		"a\\bb"		"a\bb"	"a\bb" */ SELECT * FROM x;
/* expectMatch	13.8  P		{a\Bb}		"a\\b"	"a\\b" */ SELECT * FROM x;
/* expectMatch	13.9  MP	"a\\chb"	"a\bb"	"a\bb" */ SELECT * FROM x;
/* expectMatch	13.10 MP	"a\\cHb"	"a\bb"	"a\bb" */ SELECT * FROM x;
/* expectMatch	13.11 LMP	"a\\e"		"a\033"	"a\033" */ SELECT * FROM x;
/* expectMatch	13.12 P		"a\\fb"		"a\fb"	"a\fb" */ SELECT * FROM x;
/* expectMatch	13.13 P		"a\\nb"		"a\nb"	"a\nb" */ SELECT * FROM x;
/* expectMatch	13.14 P		"a\\rb"		"a\rb"	"a\rb" */ SELECT * FROM x;
/* expectMatch	13.15 P		"a\\tb"		"a\tb"	"a\tb" */ SELECT * FROM x;
/* expectMatch	13.16 P		"a\\u0008x"	"a\bx"	"a\bx" */ SELECT * FROM x;
/* expectMatch	13.17 P		{a\u008x}	"a\bx"	"a\bx" */ /* Tcl has relaxed their code to allow 1-4 hex digits, but Postgres hasn't */ SELECT * FROM x;
/* expectMatch	13.18 P		"a\\u00088x"	"a\b8x"	"a\b8x" */ SELECT * FROM x;
/* expectMatch	13.19 P		"a\\U00000008x"	"a\bx"	"a\bx" */ SELECT * FROM x;
/* expectMatch	13.20 P		{a\U0000008x}	"a\bx"	"a\bx" */ /* Tcl has relaxed their code to allow 1-8 hex digits, but Postgres hasn't */ SELECT * FROM x;
/* expectMatch	13.21 P		"a\\vb"		"a\vb"	"a\vb" */ SELECT * FROM x;
/* expectMatch	13.22 MP	"a\\x08x"	"a\bx"	"a\bx" */ SELECT * FROM x;
/* expectError	13.23 -		{a\xq}		EESCAPE */ SELECT * FROM x;
/* expectMatch	13.24 MP	"a\\x08x"	"a\bx"	"a\bx" */ SELECT * FROM x;
/* expectError	13.25 -		{a\z}		EESCAPE */ SELECT * FROM x;
/* expectMatch	13.26 MP	"a\\010b"	"a\bb"	"a\bb" */ SELECT * FROM x;
/* These only work in UTF8 encoding, so they're moved to test_regex_utf8.sql: */ /* expectMatch	13.27 P		"a\\U00001234x"	"a\u1234x"	"a\u1234x" */ /* expectMatch	13.28 P		{a\U00001234x}	"a\u1234x"	"a\u1234x" */ /* expectMatch	13.29 P		"a\\U0001234x"	"a\u1234x"	"a\u1234x" */ /* expectMatch	13.30 P		{a\U0001234x}	"a\u1234x"	"a\u1234x" */ /* expectMatch	13.31 P		"a\\U000012345x"	"a\u12345x"	"a\u12345x" */ /* expectMatch	13.32 P		{a\U000012345x}	"a\u12345x"	"a\u12345x" */ /* expectMatch	13.33 P		"a\\U1000000x"	"a\ufffd0x"	"a\ufffd0x" */ /* expectMatch	13.34 P		{a\U1000000x}	"a\ufffd0x"	"a\ufffd0x" */ /* doing 14 "back references" */ /* # ugh */ /* expectMatch	14.1  RP	{a(b*)c\1}	abbcbb	abbcbb	bb */ SELECT * FROM x;
/* expectMatch	14.2  RP	{a(b*)c\1}	ac	ac	"" */ SELECT * FROM x;
/* expectNomatch	14.3  RP	{a(b*)c\1}	abbcb */ SELECT * FROM x;
/* expectMatch	14.4  RP	{a(b*)\1}	abbcbb	abb	b */ SELECT * FROM x;
/* expectMatch	14.5  RP	{a(b|bb)\1}	abbcbb	abb	b */ SELECT * FROM x;
/* expectMatch	14.6  RP	{a([bc])\1}	abb	abb	b */ SELECT * FROM x;
/* expectNomatch	14.7  RP	{a([bc])\1}	abc */ SELECT * FROM x;
/* expectMatch	14.8  RP	{a([bc])\1}	abcabb	abb	b */ SELECT * FROM x;
/* expectNomatch	14.9  RP	{a([bc])*\1}	abc */ SELECT * FROM x;
/* expectNomatch	14.10 RP	{a([bc])\1}	abB */ SELECT * FROM x;
/* expectMatch	14.11 iRP	{a([bc])\1}	abB	abB	b */ SELECT * FROM x;
/* expectMatch	14.12 RP	{a([bc])\1+}	abbb	abbb	b */ SELECT * FROM x;
/* expectMatch	14.13 QRP	"a(\[bc])\\1{3,4}"	abbbb	abbbb	b */ SELECT * FROM x;
/* expectNomatch	14.14 QRP	"a(\[bc])\\1{3,4}"	abbb */ SELECT * FROM x;
/* expectMatch	14.15 RP	{a([bc])\1*}	abbb	abbb	b */ SELECT * FROM x;
/* expectMatch	14.16 RP	{a([bc])\1*}	ab	ab	b */ SELECT * FROM x;
/* expectMatch	14.17 RP	{a([bc])(\1*)}	ab	ab	b	"" */ SELECT * FROM x;
/* expectError	14.18 -		{a((b)\1)}	ESUBREG */ SELECT * FROM x;
/* expectError	14.19 -		{a(b)c\2}	ESUBREG */ SELECT * FROM x;
/* expectMatch	14.20 bR	{a\(b*\)c\1}	abbcbb	abbcbb	bb */ SELECT * FROM x;
/* expectMatch	14.21 RP	{^([bc])\1*$}	bbb	bbb	b */ SELECT * FROM x;
/* expectMatch	14.22 RP	{^([bc])\1*$}	ccc	ccc	c */ SELECT * FROM x;
/* expectNomatch	14.23 RP	{^([bc])\1*$}	bcb */ SELECT * FROM x;
/* expectMatch	14.24 LRP	{^(\w+)( \1)+$}	{abc abc abc} {abc abc abc} abc { abc} */ SELECT * FROM x;
/* expectNomatch	14.25 LRP	{^(\w+)( \1)+$}	{abc abd abc} */ SELECT * FROM x;
/* expectNomatch	14.26 LRP	{^(\w+)( \1)+$}	{abc abc abd} */ SELECT * FROM x;
/* expectMatch	14.27 RP	{^(.+)( \1)+$}	{abc abc abc} {abc abc abc} abc { abc} */ SELECT * FROM x;
/* expectNomatch	14.28 RP	{^(.+)( \1)+$}	{abc abd abc} */ SELECT * FROM x;
/* expectNomatch	14.29 RP	{^(.+)( \1)+$}	{abc abc abd} */ SELECT * FROM x;
/* expectNomatch	14.30 RP	{^(.)\1|\1.}	{abcdef} */ SELECT * FROM x;
/* expectNomatch	14.31 RP	{^((.)\2|..)\2}	{abadef} */ SELECT * FROM x;
/* back reference only matches the string, not any constraints */ SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
/* exercise oversize-regmatch_t-array paths in regexec() */ /* (that case is not reachable via test_regex, sadly) */ SELECT SUBSTRING('fffoooooooooooooooooooooooooooooooo', '^(.)\1(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)');
SELECT REGEXP_SPLIT_TO_ARRAY('abcxxxdefyyyghi', '((.))(\1\2)');
/* doing 15 "octal escapes vs back references" */ /* # initial zero is always octal */ /* expectMatch	15.1  MP	"a\\010b"	"a\bb"	"a\bb" */ SELECT * FROM x;
/* expectMatch	15.2  MP	"a\\0070b"	"a\0070b"	"a\0070b" */ SELECT * FROM x;
/* expectMatch	15.3  MP	"a\\07b"	"a\007b"	"a\007b" */ SELECT * FROM x;
/* expectMatch	15.4  MP	"a(b)(b)(b)(b)(b)(b)(b)(b)(b)(b)\\07c" \ */ /* 	"abbbbbbbbbb\007c" abbbbbbbbbb\007c b b b b b b b b b b */ SELECT * FROM x;
/* # a single digit is always a backref */ /* expectError	15.5  -		{a\7b}	ESUBREG */ SELECT * FROM x;
/* # otherwise it's a backref only if within range (barf!) */ /* expectMatch	15.6  MP	"a\\10b"	"a\bb"	"a\bb" */ SELECT * FROM x;
/* expectMatch	15.7  MP	{a\101b}	aAb	aAb */ SELECT * FROM x;
/* expectMatch	15.8  RP	{a(b)(b)(b)(b)(b)(b)(b)(b)(b)(b)\10c} \ */ /* 	"abbbbbbbbbbbc" abbbbbbbbbbbc b b b b b b b b b b */ SELECT * FROM x;
/* # but we're fussy about border cases -- guys who want octal should use the zero */ /* expectError	15.9  -	{a((((((((((b\10))))))))))c}	ESUBREG */ SELECT * FROM x;
/* # BREs don't have octal, EREs don't have backrefs */ /* expectMatch	15.10 MP	"a\\12b"	"a\nb"	"a\nb" */ SELECT * FROM x;
/* expectError	15.11 b		{a\12b}		ESUBREG */ SELECT * FROM x;
/* expectMatch	15.12 eAS	{a\12b}		a12b	a12b */ SELECT * FROM x;
/* expectMatch	15.13 MP	{a\701b}	a\u00381b	a\u00381b */ SELECT * FROM x;
/* doing 16 "expanded syntax" */ /* expectMatch	16.1 xP		"a b c"		"abc"	"abc" */ SELECT * FROM x;
/* expectMatch	16.2 xP		"a b #oops\nc\td"	"abcd"	"abcd" */ SELECT * FROM x;
/* expectMatch	16.3 x		"a\\ b\\\tc"	"a b\tc"	"a b\tc" */ SELECT * FROM x;
/* expectMatch	16.4 xP		"a b\\#c"	"ab#c"	"ab#c" */ SELECT * FROM x;
/* expectMatch	16.5 xP		"a b\[c d]e"	"ab e"	"ab e" */ SELECT * FROM x;
/* expectMatch	16.6 xP		"a b\[c#d]e"	"ab#e"	"ab#e" */ SELECT * FROM x;
/* expectMatch	16.7 xP		"a b\[c#d]e"	"abde"	"abde" */ SELECT * FROM x;
/* expectMatch	16.8 xSPB	"ab{ d"		"ab\{d"	"ab\{d" */ SELECT * FROM x;
/* expectMatch	16.9 xPQ	"ab{ 1 , 2 }c"	"abc"	"abc" */ SELECT * FROM x;
/* doing 17 "misc syntax" */ /* expectMatch	17.1 P	a(?#comment)b	ab	ab */ SELECT * FROM x;
/* doing 18 "unmatchable REs" */ /* expectNomatch	18.1 I	a^b		ab */ SELECT * FROM x;
/* doing 19 "case independence" */ /* expectMatch	19.1 &i		ab		Ab	Ab */ SELECT * FROM x;
SELECT * FROM x;
/* expectMatch	19.2 &i		{a[bc]}		aC	aC */ SELECT * FROM x;
SELECT * FROM x;
/* expectNomatch	19.3 &i		{a[^bc]}	aB */ SELECT * FROM x;
SELECT * FROM x;
/* expectMatch	19.4 &iM	{a[b-d]}	aC	aC */ SELECT * FROM x;
SELECT * FROM x;
/* expectNomatch	19.5 &iM	{a[^b-d]}	aC */ SELECT * FROM x;
SELECT * FROM x;
/* expectMatch	19.6 &iM	{a[B-Z]}	aC	aC */ SELECT * FROM x;
SELECT * FROM x;
/* expectNomatch	19.7 &iM	{a[^B-Z]}	aC */ SELECT * FROM x;
SELECT * FROM x;
/* doing 20 "directors and embedded options" */ /* expectError	20.1  &		***?		BADPAT */ SELECT * FROM x;
SELECT * FROM x;
/* expectMatch	20.2  q		***?		***?	***? */ SELECT * FROM x;
/* expectMatch	20.3  &P	***=a*b		a*b	a*b */ SELECT * FROM x;
SELECT * FROM x;
/* expectMatch	20.4  q		***=a*b		***=a*b	***=a*b */ SELECT * FROM x;
/* expectMatch	20.5  bLP	{***:\w+}	ab	ab */ SELECT * FROM x;
/* expectMatch	20.6  eLP	{***:\w+}	ab	ab */ SELECT * FROM x;
/* expectError	20.7  &		***:***=a*b	BADRPT */ SELECT * FROM x;
SELECT * FROM x;
/* expectMatch	20.8  &P	***:(?b)a+b	a+b	a+b */ SELECT * FROM x;
SELECT * FROM x;
/* expectMatch	20.9  P		(?b)a+b		a+b	a+b */ SELECT * FROM x;
/* expectError	20.10 e		{(?b)\w+}	BADRPT */ SELECT * FROM x;
/* expectMatch	20.11 bAS	{(?b)\w+}	(?b)w+	(?b)w+ */ SELECT * FROM x;
/* expectMatch	20.12 iP	(?c)a		a	a */ SELECT * FROM x;
/* expectNomatch	20.13 iP	(?c)a		A */ SELECT * FROM x;
/* expectMatch	20.14 APS	{(?e)\W+}	WW	WW */ SELECT * FROM x;
/* expectMatch	20.15 P		(?i)a+		Aa	Aa */ SELECT * FROM x;
/* expectNomatch	20.16 P		"(?m)a.b"	"a\nb" */ SELECT * FROM x;
/* expectMatch	20.17 P		"(?m)^b"	"a\nb"	"b" */ SELECT * FROM x;
/* expectNomatch	20.18 P		"(?n)a.b"	"a\nb" */ SELECT * FROM x;
/* expectMatch	20.19 P		"(?n)^b"	"a\nb"	"b" */ SELECT * FROM x;
/* expectNomatch	20.20 P		"(?p)a.b"	"a\nb" */ SELECT * FROM x;
/* expectNomatch	20.21 P		"(?p)^b"	"a\nb" */ SELECT * FROM x;
/* expectMatch	20.22 P		(?q)a+b		a+b	a+b */ SELECT * FROM x;
/* expectMatch	20.23 nP	"(?s)a.b"	"a\nb"	"a\nb" */ SELECT * FROM x;
/* expectMatch	20.24 xP	"(?t)a b"	"a b"	"a b" */ SELECT * FROM x;
/* expectMatch	20.25 P		"(?w)a.b"	"a\nb"	"a\nb" */ SELECT * FROM x;
/* expectMatch	20.26 P		"(?w)^b"	"a\nb"	"b" */ SELECT * FROM x;
/* expectMatch	20.27 P		"(?x)a b"	"ab"	"ab" */ SELECT * FROM x;
/* expectError	20.28 -		(?z)ab		BADOPT */ SELECT * FROM x;
/* expectMatch	20.29 P		(?ici)a+	Aa	Aa */ SELECT * FROM x;
/* expectError	20.30 P		(?i)(?q)a+	BADRPT */ SELECT * FROM x;
/* expectMatch	20.31 P		(?q)(?i)a+	(?i)a+	(?i)a+ */ SELECT * FROM x;
/* expectMatch	20.32 P		(?qe)a+		a	a */ SELECT * FROM x;
/* expectMatch	20.33 xP	"(?q)a b"	"a b"	"a b" */ SELECT * FROM x;
/* expectMatch	20.34 P		"(?qx)a b"	"a b"	"a b" */ SELECT * FROM x;
/* expectMatch	20.35 P		(?qi)ab		Ab	Ab */ SELECT * FROM x;
/* doing 21 "capturing" */ /* expectMatch	21.1  -		a(b)c		abc	abc	b */ SELECT * FROM x;
/* expectMatch	21.2  P		a(?:b)c		xabc	abc */ SELECT * FROM x;
/* expectMatch	21.3  -		a((b))c		xabcy	abc	b	b */ SELECT * FROM x;
/* expectMatch	21.4  P		a(?:(b))c	abcy	abc	b */ SELECT * FROM x;
/* expectMatch	21.5  P		a((?:b))c	abc	abc	b */ SELECT * FROM x;
/* expectMatch	21.6  P		a(?:(?:b))c	abc	abc */ SELECT * FROM x;
/* expectIndices	21.7  Q		"a(b){0}c"	ac	{0 1}	{-1 -1} */ SELECT * FROM x;
/* expectMatch	21.8  -		a(b)c(d)e	abcde	abcde	b	d */ SELECT * FROM x;
/* expectMatch	21.9  -		(b)c(d)e	bcde	bcde	b	d */ SELECT * FROM x;
/* expectMatch	21.10 -		a(b)(d)e	abde	abde	b	d */ SELECT * FROM x;
/* expectMatch	21.11 -		a(b)c(d)	abcd	abcd	b	d */ SELECT * FROM x;
/* expectMatch	21.12 -		(ab)(cd)	xabcdy	abcd	ab	cd */ SELECT * FROM x;
/* expectMatch	21.13 -		a(b)?c		xabcy	abc	b */ SELECT * FROM x;
/* expectIndices	21.14 -		a(b)?c		xacy	{1 2}	{-1 -1} */ SELECT * FROM x;
/* expectMatch	21.15 -		a(b)?c(d)?e	xabcdey	abcde	b	d */ SELECT * FROM x;
/* expectIndices	21.16 -		a(b)?c(d)?e	xacdey	{1 4}	{-1 -1}	{3 3} */ SELECT * FROM x;
/* expectIndices	21.17 -		a(b)?c(d)?e	xabcey	{1 4}	{2 2}	{-1 -1} */ SELECT * FROM x;
/* expectIndices	21.18 -		a(b)?c(d)?e	xacey	{1 3}	{-1 -1}	{-1 -1} */ SELECT * FROM x;
/* expectMatch	21.19 -		a(b)*c		xabcy	abc	b */ SELECT * FROM x;
/* expectIndices	21.20 -		a(b)*c		xabbbcy	{1 5}	{4 4} */ SELECT * FROM x;
/* expectIndices	21.21 -		a(b)*c		xacy	{1 2}	{-1 -1} */ SELECT * FROM x;
/* expectMatch	21.22 -		a(b*)c		xabbbcy	abbbc	bbb */ SELECT * FROM x;
/* expectMatch	21.23 -		a(b*)c		xacy	ac	"" */ SELECT * FROM x;
/* expectNomatch	21.24 -		a(b)+c		xacy */ SELECT * FROM x;
/* expectMatch	21.25 -		a(b)+c		xabcy	abc	b */ SELECT * FROM x;
/* expectIndices	21.26 -		a(b)+c		xabbbcy	{1 5}	{4 4} */ SELECT * FROM x;
/* expectMatch	21.27 -		a(b+)c		xabbbcy	abbbc	bbb */ SELECT * FROM x;
/* expectIndices	21.28 Q		"a(b){2,3}c"	xabbbcy	{1 5}	{4 4} */ SELECT * FROM x;
/* expectIndices	21.29 Q		"a(b){2,3}c"	xabbcy	{1 4}	{3 3} */ SELECT * FROM x;
/* expectNomatch	21.30 Q		"a(b){2,3}c"	xabcy */ SELECT * FROM x;
/* expectMatch	21.31 LP	"\\y(\\w+)\\y"	"-- abc-"	"abc"	"abc" */ SELECT * FROM x;
/* expectMatch	21.32 -		a((b|c)d+)+	abacdbd	acdbd	bd	b */ SELECT * FROM x;
/* expectMatch	21.33 N		(.*).*		abc	abc	abc */ SELECT * FROM x;
/* expectMatch	21.34 N		(a*)*		bc	""	"" */ SELECT * FROM x;
/* expectMatch	21.35 M		{ TO (([a-z0-9._]+|"([^"]+|"")+")+)}	{asd TO foo}	{ TO foo} foo o {} */ SELECT * FROM x;
/* expectMatch	21.36 RPQ	((.))(\2){0}	xy	x	x	x	{} */ SELECT * FROM x;
/* expectMatch	21.37 RP	((.))(\2)	xyy	yy	y	y	y */ SELECT * FROM x;
/* expectMatch	21.38 oRP	((.))(\2)	xyy	yy	{}	{}	{} */ SELECT * FROM x;
/* expectNomatch	21.39 PQR	{(.){0}(\1)}	xxx */ SELECT * FROM x;
/* expectNomatch	21.40 PQR	{((.)){0}(\2)}	xxx */ SELECT * FROM x;
/* expectMatch	21.41 NPQR	{((.)){0}(\2){0}}	xyz	{}	{}	{}	{} */ SELECT * FROM x;
/* doing 23 "lookahead constraints" */ /* expectMatch	23.1 HP		a(?=b)b*	ab	ab */ SELECT * FROM x;
/* expectNomatch	23.2 HP		a(?=b)b*	a */ SELECT * FROM x;
/* expectMatch	23.3 HP		a(?=b)b*(?=c)c*	abc	abc */ SELECT * FROM x;
/* expectNomatch	23.4 HP		a(?=b)b*(?=c)c*	ab */ SELECT * FROM x;
/* expectNomatch	23.5 HP		a(?!b)b*	ab */ SELECT * FROM x;
/* expectMatch	23.6 HP		a(?!b)b*	a	a */ SELECT * FROM x;
/* expectMatch	23.7 HP		(?=b)b		b	b */ SELECT * FROM x;
/* expectNomatch	23.8 HP		(?=b)b		a */ SELECT * FROM x;
/* expectMatch	23.9 HP		...(?!.)	abcde	cde */ SELECT * FROM x;
/* expectNomatch	23.10 HP	...(?=.)	abc */ SELECT * FROM x;
/* Postgres addition: lookbehind constraints */ /* expectMatch	23.11 HPN		(?<=a)b*	ab	b */ SELECT * FROM x;
/* expectNomatch	23.12 HPN		(?<=a)b*	b */ SELECT * FROM x;
/* expectMatch	23.13 HP		(?<=a)b*(?<=b)c*	abc	bc */ SELECT * FROM x;
/* expectNomatch	23.14 HP		(?<=a)b*(?<=b)c*	ac */ SELECT * FROM x;
/* expectNomatch	23.15 IHP		a(?<!a)b*	ab */ SELECT * FROM x;
/* expectMatch	23.16 HP		a(?<!b)b*	a	a */ SELECT * FROM x;
/* expectMatch	23.17 HP		(?<=b)b		bb	b */ SELECT * FROM x;
/* expectNomatch	23.18 HP		(?<=b)b		b */ SELECT * FROM x;
/* expectMatch	23.19 HP		(?<=.)..	abcde	bc */ SELECT * FROM x;
/* expectMatch	23.20 HP		(?<=..)a*	aaabb	a */ SELECT * FROM x;
/* expectMatch	23.21 HP		(?<=..)b*	aaabb	{} */ /* Note: empty match here is correct, it matches after the first 2 characters */ SELECT * FROM x;
/* expectMatch	23.22 HP		(?<=..)b+	aaabb	bb */ SELECT * FROM x;
/* doing 24 "non-greedy quantifiers" */ /* expectMatch	24.1  PT	ab+?		abb	ab */ SELECT * FROM x;
/* expectMatch	24.2  PT	ab+?c		abbc	abbc */ SELECT * FROM x;
/* expectMatch	24.3  PT	ab*?		abb	a */ SELECT * FROM x;
/* expectMatch	24.4  PT	ab*?c		abbc	abbc */ SELECT * FROM x;
/* expectMatch	24.5  PT	ab??		ab	a */ SELECT * FROM x;
/* expectMatch	24.6  PT	ab??c		abc	abc */ SELECT * FROM x;
/* expectMatch	24.7  PQT	"ab{2,4}?"	abbbb	abb */ SELECT * FROM x;
/* expectMatch	24.8  PQT	"ab{2,4}?c"	abbbbc	abbbbc */ SELECT * FROM x;
/* expectMatch	24.9  -		3z*		123zzzz456	3zzzz */ SELECT * FROM x;
/* expectMatch	24.10 PT	3z*?		123zzzz456	3 */ SELECT * FROM x;
/* expectMatch	24.11 -		z*4		123zzzz456	zzzz4 */ SELECT * FROM x;
/* expectMatch	24.12 PT	z*?4		123zzzz456	zzzz4 */ SELECT * FROM x;
/* expectMatch	24.13 PT	{^([^/]+?)(?:/([^/]+?))(?:/([^/]+?))?$}	{foo/bar/baz}	{foo/bar/baz} {foo} {bar} {baz} */ SELECT * FROM x;
/* expectMatch	24.14 PRT	{^(.+?)(?:/(.+?))(?:/(.+?)\3)?$}	{foo/bar/baz/quux}	{foo/bar/baz/quux}	{foo}	{bar/baz/quux}	{} */ SELECT * FROM x;
/* doing 25 "mixed quantifiers" */ /* # this is very incomplete as yet */ /* # should include | */ /* expectMatch	25.1 PNT	{^(.*?)(a*)$}	"xyza"	xyza	xyz	a */ SELECT * FROM x;
/* expectMatch	25.2 PNT	{^(.*?)(a*)$}	"xyzaa"	xyzaa	xyz	aa */ SELECT * FROM x;
/* expectMatch	25.3 PNT	{^(.*?)(a*)$}	"xyz"	xyz	xyz	"" */ SELECT * FROM x;
/* doing 26 "tricky cases" */ /* # attempts to trick the matcher into accepting a short match */ /* expectMatch	26.1 -		(week|wee)(night|knights) \ */ /* 	"weeknights" weeknights wee knights */ SELECT * FROM x;
/* expectMatch	26.2 RP		{a(bc*).*\1}	abccbccb abccbccb	b */ SELECT * FROM x;
/* expectMatch	26.3 -		{a(b.[bc]*)+}	abcbd	abcbd	bd */ SELECT * FROM x;
/* doing 27 "implementation misc." */ /* # duplicate arcs are suppressed */ /* expectMatch	27.1 P		a(?:b|b)c	abc	abc */ SELECT * FROM x;
/* # make color/subcolor relationship go back and forth */ /* expectMatch	27.2 &		{[ab][ab][ab]}	aba	aba */ SELECT * FROM x;
SELECT * FROM x;
/* expectMatch	27.3 &		{[ab][ab][ab][ab][ab][ab][ab]} \ */ /* 	"abababa" abababa */ SELECT * FROM x;
SELECT * FROM x;
/* doing 28 "boundary busters etc." */ /* # color-descriptor allocation changes at 10 */ /* expectMatch	28.1 &		abcdefghijkl	"abcdefghijkl"	abcdefghijkl */ SELECT * FROM x;
SELECT * FROM x;
/* # so does arc allocation */ /* expectMatch	28.2 P		a(?:b|c|d|e|f|g|h|i|j|k|l|m)n	"agn"	agn */ SELECT * FROM x;
/* # subexpression tracking also at 10 */ /* expectMatch	28.3 -		a(((((((((((((b)))))))))))))c \ */ /* 	"abc" abc b b b b b b b b b b b b b */ SELECT * FROM x;
/* # state-set handling changes slightly at unsigned size (might be 64...) */ /* # (also stresses arc allocation) */ /* expectMatch	28.4  Q		"ab{1,100}c"	abbc	abbc */ SELECT * FROM x;
/* expectMatch	28.5  Q		"ab{1,100}c" \ */ /* 	"abbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbc" \ */ /* 	abbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbc */ SELECT * FROM x;
/* expectMatch	28.6  Q		"ab{1,100}c" \ */ /* 	"abbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbc"\ */ /* 	abbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbc */ SELECT * FROM x;
/* # force small cache and bust it, several ways */ /* expectMatch	28.7  LP	{\w+abcdefgh}	xyzabcdefgh	xyzabcdefgh */ SELECT * FROM x;
/* expectMatch	28.8  %LP	{\w+abcdefgh}	xyzabcdefgh	xyzabcdefgh */ SELECT * FROM x;
/* expectMatch	28.9  %LP	{\w+abcdefghijklmnopqrst} \ */ /* 	"xyzabcdefghijklmnopqrst" xyzabcdefghijklmnopqrst */ SELECT * FROM x;
/* expectIndices	28.10 %LP	{\w+(abcdefgh)?} xyz	{0 2}	{-1 -1} */ SELECT * FROM x;
/* expectIndices	28.11 %LP	{\w+(abcdefgh)?} xyzabcdefg	{0 9}	{-1 -1} */ SELECT * FROM x;
/* expectIndices	28.12 %LP	{\w+(abcdefghijklmnopqrst)?} \ */ /* 	"xyzabcdefghijklmnopqrs" {0 21} {-1 -1} */ SELECT * FROM x;
/* doing 29 "incomplete matches" */ /* expectPartial		29.1  t		def	abc	{3 2}	"" */ SELECT * FROM x;
/* expectPartial		29.2  t		bcd	abc	{1 2}	"" */ SELECT * FROM x;
/* expectPartial		29.3  t		abc	abab	{0 3}	"" */ SELECT * FROM x;
/* expectPartial		29.4  t		abc	abdab	{3 4}	"" */ SELECT * FROM x;
/* expectIndices		29.5  t		abc	abc	{0 2}	{0 2} */ SELECT * FROM x;
/* expectIndices		29.6  t		abc	xyabc	{2 4}	{2 4} */ SELECT * FROM x;
/* expectPartial		29.7  t		abc+	xyab	{2 3}	"" */ SELECT * FROM x;
/* expectIndices		29.8  t		abc+	xyabc	{2 4}	{2 4} */ SELECT * FROM x;
/* knownBug expectIndices	29.9  t		abc+	xyabcd	{2 4}	{6 5} */ SELECT * FROM x;
/* expectIndices		29.10 t		abc+	xyabcdd	{2 4}	{7 6} */ SELECT * FROM x;
/* expectPartial		29.11 tPT	abc+?	xyab	{2 3}	"" */ SELECT * FROM x;
/* # the retain numbers in these two may look wrong, but they aren't */ /* expectIndices		29.12 tPT	abc+?	xyabc	{2 4}	{5 4} */ SELECT * FROM x;
/* expectIndices		29.13 tPT	abc+?	xyabcc	{2 4}	{6 5} */ SELECT * FROM x;
/* expectIndices		29.14 tPT	abc+?	xyabcd	{2 4}	{6 5} */ SELECT * FROM x;
/* expectIndices		29.15 tPT	abc+?	xyabcdd	{2 4}	{7 6} */ SELECT * FROM x;
/* expectIndices		29.16 t		abcd|bc	xyabc	{3 4}	{2 4} */ SELECT * FROM x;
/* expectPartial		29.17 tn	.*k	"xx\nyyy"	{3 5}	"" */ SELECT * FROM x;
/* doing 30 "misc. oddities and old bugs" */ /* expectError	30.1 &		***	BADRPT */ SELECT * FROM x;
SELECT * FROM x;
/* expectMatch	30.2 N		a?b*	abb	abb */ SELECT * FROM x;
/* expectMatch	30.3 N		a?b*	bb	bb */ SELECT * FROM x;
/* expectMatch	30.4 &		a*b	aab	aab */ SELECT * FROM x;
SELECT * FROM x;
/* expectMatch	30.5 &		^a*b	aaaab	aaaab */ SELECT * FROM x;
SELECT * FROM x;
/* expectMatch	30.6 &M		{[0-6][1-2][0-3][0-6][1-6][0-6]} \ */ /* 	"010010" 010010 */ SELECT * FROM x;
SELECT * FROM x;
/* # temporary REG_BOSONLY kludge */ /* expectMatch	30.7 s		abc	abcd	abc */ SELECT * FROM x;
/* expectNomatch	30.8 s		abc	xabcd */ SELECT * FROM x;
/* # back to normal stuff */ /* expectMatch	30.9 HLP	{(?n)^(?![t#])\S+} \ */ /* 	"tk\n\n#\n#\nit0"	it0 */ SELECT * FROM x;
/* # Now for tests *not* written by Henry Spencer */ /* # Tests resulting from bugs reported by users */ /* test reg-31.1 {[[:xdigit:]] behaves correctly when followed by [[:space:]]} { */ /*     set str {2:::DebugWin32} */ /*     set re {([[:xdigit:]])([[:space:]]*)} */ /*     list [regexp $re $str match xdigit spaces] $match $xdigit $spaces */ /*     # Code used to produce {1 2:::DebugWin32 2 :::DebugWin32} !!! */ /* } {1 2 2 {}} */ SELECT * FROM x;
/* test reg-32.1 {canmatch functionality -- at end} testregexp { */ /*     set pat {blah} */ /*     set line "asd asd" */ /*     # can match at the final d, if '%' follows */ /*     set res [testregexp -xflags -- c $pat $line resvar] */ /*     lappend res $resvar */ /* } {0 7} */ SELECT * FROM x;
/* test reg-32.2 {canmatch functionality -- at end} testregexp { */ /*     set pat {s%$} */ /*     set line "asd asd" */ /*     # can only match after the end of the string */ /*     set res [testregexp -xflags -- c $pat $line resvar] */ /*     lappend res $resvar */ /* } {0 7} */ SELECT * FROM x;
/* test reg-32.3 {canmatch functionality -- not last char} testregexp { */ /*     set pat {[^d]%$} */ /*     set line "asd asd" */ /*     # can only match after the end of the string */ /*     set res [testregexp -xflags -- c $pat $line resvar] */ /*     lappend res $resvar */ /* } {0 7} */ SELECT * FROM x;
/* test reg-32.3.1 {canmatch functionality -- no match} testregexp { */ /*     set pat {\Zx} */ /*     set line "asd asd" */ /*     # can match the last char, if followed by x */ /*     set res [testregexp -xflags -- c $pat $line resvar] */ /*     lappend res $resvar */ /* } {0 -1} */ SELECT * FROM x;
/* test reg-32.4 {canmatch functionality -- last char} {knownBug testregexp} { */ /*     set pat {.x} */ /*     set line "asd asd" */ /*     # can match the last char, if followed by x */ /*     set res [testregexp -xflags -- c $pat $line resvar] */ /*     lappend res $resvar */ /* } {0 6} */ SELECT * FROM x;
/* test reg-32.4.1 {canmatch functionality -- last char} {knownBug testregexp} { */ /*     set pat {.x$} */ /*     set line "asd asd" */ /*     # can match the last char, if followed by x */ /*     set res [testregexp -xflags -- c $pat $line resvar] */ /*     lappend res $resvar */ /* } {0 6} */ SELECT * FROM x;
/* test reg-32.5 {canmatch functionality -- last char} {knownBug testregexp} { */ /*     set pat {.[^d]x$} */ /*     set line "asd asd" */ /*     # can match the last char, if followed by not-d and x. */ /*     set res [testregexp -xflags -- c $pat $line resvar] */ /*     lappend res $resvar */ /* } {0 6} */ SELECT * FROM x;
/* test reg-32.6 {canmatch functionality -- last char} {knownBug testregexp} { */ /*     set pat {[^a]%[^\r\n]*$} */ /*     set line "asd asd" */ /*     # can match at the final d, if '%' follows */ /*     set res [testregexp -xflags -- c $pat $line resvar] */ /*     lappend res $resvar */ /* } {0 6} */ SELECT * FROM x;
/* test reg-32.7 {canmatch functionality -- last char} {knownBug testregexp} { */ /*     set pat {[^a]%$} */ /*     set line "asd asd" */ /*     # can match at the final d, if '%' follows */ /*     set res [testregexp -xflags -- c $pat $line resvar] */ /*     lappend res $resvar */ /* } {0 6} */ SELECT * FROM x;
/* test reg-32.8 {canmatch functionality -- last char} {knownBug testregexp} { */ /*     set pat {[^x]%$} */ /*     set line "asd asd" */ /*     # can match at the final d, if '%' follows */ /*     set res [testregexp -xflags -- c $pat $line resvar] */ /*     lappend res $resvar */ /* } {0 6} */ SELECT * FROM x;
/* test reg-32.9 {canmatch functionality -- more complex case} {knownBug testregexp} { */ /*     set pat {((\B\B|\Bh+line)[ \t]*|[^\B]%[^\r\n]*)$} */ /*     set line "asd asd" */ /*     # can match at the final d, if '%' follows */ /*     set res [testregexp -xflags -- c $pat $line resvar] */ /*     lappend res $resvar */ /* } {0 6} */ SELECT * FROM x;
/* # Tests reg-33.*: Checks for bug fixes */ /* test reg-33.1 {Bug 230589} { */ /*     regexp {[ ]*(^|[^%])%V} "*%V2" m s */ /* } 1 */ SELECT * FROM x;
/* test reg-33.2 {Bug 504785} { */ /*     regexp -inline {([^_.]*)([^.]*)\.(..)(.).*} bbcos_001_c01.q1la */ /* } {bbcos_001_c01.q1la bbcos _001_c01 q1 l} */ SELECT * FROM x;
/* test reg-33.3 {Bug 505048} { */ /*     regexp {\A\s*[^<]*\s*<([^>]+)>} a<a> */ /* } 1 */ SELECT * FROM x;
/* test reg-33.4 {Bug 505048} { */ /*     regexp {\A\s*([^b]*)b} ab */ /* } 1 */ SELECT * FROM x;
/* test reg-33.5 {Bug 505048} { */ /*     regexp {\A\s*[^b]*(b)} ab */ /* } 1 */ SELECT * FROM x;
/* test reg-33.6 {Bug 505048} { */ /*     regexp {\A(\s*)[^b]*(b)} ab */ /* } 1 */ SELECT * FROM x;
/* test reg-33.7 {Bug 505048} { */ /*     regexp {\A\s*[^b]*b} ab */ /* } 1 */ SELECT * FROM x;
/* test reg-33.8 {Bug 505048} { */ /*     regexp -inline {\A\s*[^b]*b} ab */ /* } ab */ SELECT * FROM x;
/* test reg-33.9 {Bug 505048} { */ /*     regexp -indices -inline {\A\s*[^b]*b} ab */ /* } {{0 1}} */ SELECT * FROM x;
/* test reg-33.10 {Bug 840258} -body { */ /*     regsub {(^|\n)+\.*b} \n.b {} tmp */ /* } -cleanup { */ /*     unset tmp */ /* } -result 1 */ SELECT * FROM x;
/* test reg-33.11 {Bug 840258} -body { */ /*     regsub {(^|[\n\r]+)\.*\?<.*?(\n|\r)+} \ */ /* 	    "TQ\r\n.?<5000267>Test already stopped\r\n" {} tmp */ /* } -cleanup { */ /*     unset tmp */ /* } -result 1 */ SELECT * FROM x;
/* test reg-33.12 {Bug 1810264 - bad read} { */ /*     regexp {\3161573148} {\3161573148} */ /* } 0 */ SELECT * FROM x;
/* test reg-33.13 {Bug 1810264 - infinite loop} { */ /*     regexp {($|^)*} {x} */ /* } 1 */ SELECT * FROM x;
/* test reg-33.15.1 {Bug 3603557 - an "in the wild" RE} { */ /*     lindex [regexp -expanded -about { */ /* 	^TETRA_MODE_CMD				# Message Type */ /* 	([[:blank:]]+)				# Pad */ /* 	(ETS_1_1|ETS_1_2|ETS_2_2)		# SystemCode */ /* 	([[:blank:]]+)				# Pad */ /* 	(CONTINUOUS|CARRIER|MCCH|TRAFFIC)	# SharingMode */ /* 	([[:blank:]]+)				# Pad */ /* 	([[:digit:]]{1,2})			# ColourCode */ /* 	([[:blank:]]+)				# Pad */ /* 	(1|2|3|4|6|9|12|18)			# TSReservedFrames */ /* 	([[:blank:]]+)				# Pad */ /* 	(PASS|TRUE|FAIL|FALSE)			# UPlaneDTX */ /* 	([[:blank:]]+)				# Pad */ /* 	(PASS|TRUE|FAIL|FALSE)			# Frame18Extension */ /* 	([[:blank:]]+)				# Pad */ /* 	([[:digit:]]{1,4})			# MCC */ /* 	([[:blank:]]+)				# Pad */ /* 	([[:digit:]]{1,5})			# MNC */ /* 	([[:blank:]]+)				# Pad */ /* 	(BOTH|BCAST|ENQRY|NONE)			# NbrCellBcast */ /* 	([[:blank:]]+)				# Pad */ /* 	(UNKNOWN|LOW|MEDIUM|HIGH)		# CellServiceLevel */ /* 	([[:blank:]]+)				# Pad */ /* 	(PASS|TRUE|FAIL|FALSE)			# LateEntryInfo */ /* 	([[:blank:]]+)				# Pad */ /* 	(300|400)				# FrequencyBand */ /* 	([[:blank:]]+)				# Pad */ /* 	(NORMAL|REVERSE)			# ReverseOperation */ /* 	([[:blank:]]+)				# Pad */ /* 	(NONE|\+6\.25|\-6\.25|\+12\.5)		# Offset */ /* 	([[:blank:]]+)				# Pad */ /* 	(10)					# DuplexSpacing */ /* 	([[:blank:]]+)				# Pad */ /* 	([[:digit:]]{1,4})			# MainCarrierNr */ /* 	([[:blank:]]+)				# Pad */ /* 	(0|1|2|3)				# NrCSCCH */ /* 	([[:blank:]]+)				# Pad */ /* 	(15|20|25|30|35|40|45)			# MSTxPwrMax */ /* 	([[:blank:]]+)				# Pad */ /* 	(\-125|\-120|\-115|\-110|\-105|\-100|\-95|\-90|\-85|\-80|\-75|\-70|\-65|\-60|\-55|\-50) */ /* 						# RxLevAccessMin */ /* 	([[:blank:]]+)				# Pad */ /* 	(\-53|\-51|\-49|\-47|\-45|\-43|\-41|\-39|\-37|\-35|\-33|\-31|\-29|\-27|\-25|\-23) */ /* 						# AccessParameter */ /* 	([[:blank:]]+)				# Pad */ /* 	(DISABLE|[[:digit:]]{3,4})		# RadioDLTimeout */ /* 	([[:blank:]]+)				# Pad */ /* 	(\-[[:digit:]]{2,3})			# RSSIThreshold */ /* 	([[:blank:]]+)				# Pad */ /* 	([[:digit:]]{1,5})			# CCKIdSCKVerNr */ /* 	([[:blank:]]+)				# Pad */ /* 	([[:digit:]]{1,5})			# LocationArea */ /* 	([[:blank:]]+)				# Pad */ /* 	([(1|0)]{16})				# SubscriberClass */ /* 	([[:blank:]]+)				# Pad */ /* 	([(1|0)]{12})				# BSServiceDetails */ /* 	([[:blank:]]+)				# Pad */ /* 	(RANDOMIZE|IMMEDIATE|[[:digit:]]{1,2})	# IMM */ /* 	([[:blank:]]+)				# Pad */ /* 	([[:digit:]]{1,2})			# WT */ /* 	([[:blank:]]+)				# Pad */ /* 	([[:digit:]]{1,2})			# Nu */ /* 	([[:blank:]]+)				# Pad */ /* 	([0-1])					# FrameLngFctr */ /* 	([[:blank:]]+)				# Pad */ /* 	([[:digit:]]{1,2})			# TSPtr */ /* 	([[:blank:]]+)				# Pad */ /* 	([0-7])					# MinPriority */ /* 	([[:blank:]]+)				# Pad */ /* 	(PASS|TRUE|FAIL|FALSE)			# ExtdSrvcsEnabled */ /* 	([[:blank:]]+)				# Pad */ /* 	(.*)					# ConditionalFields */ /*     }] 0 */ /* } 68 */ SELECT * FROM x;
/* test reg-33.16.1 {Bug [8d2c0da36d]- another "in the wild" RE} { */ /*     lindex [regexp -about "^MRK:client1: =1339 14HKelly Talisman 10011000 (\[0-9\]* \[0-9\]* \[0-9\]* \[0-9\]* \[0-9\]* \[0-9\]* \[0-9\]* \[0-9\]* \[0-9\]*) \[0-9\]* \[0-9\]* \[0-9\]* \[0-9\]* \[0-9\]* \[0-9\]* \[0-9\]* \[0-9\]* \[0-9\]* 8 0 8 0 0 0 77 77 1 1 2 0 11 { 1 3 8 \[0-9\]* \[0-9\]* \[0-9\]* \[0-9\]* \[0-9\]* \[0-9\]* \[0-9\]* \[0-9\]* \[0-9\]* 00000000 1 13HC6 My Creator 2 3 8 \[0-9\]* \[0-9\]* \[0-9\]* \[0-9\]* \[0-9\]* \[0-9\]* \[0-9\]* \[0-9\]* \[0-9\]* 00000000 1 31HC7 Slightly offensive name, huh 3 8 8 \[0-9\]* \[0-9\]* \[0-9\]* \[0-9\]* \[0-9\]* \[0-9\]* \[0-9\]* \[0-9\]* \[0-9\]* 00000000 1 23HE-mail:kelly@hotbox.com 4 9 8 \[0-9\]* \[0-9\]* \[0-9\]* \[0-9\]* \[0-9\]* \[0-9\]* \[0-9\]* \[0-9\]* \[0-9\]* 00000000 1 17Hcompface must die 5 10 8 \[0-9\]* \[0-9\]* \[0-9\]* \[0-9\]* \[0-9\]* \[0-9\]* \[0-9\]* \[0-9\]* \[0-9\]* 00000000 0 3HAir 6 12 8 \[0-9\]* \[0-9\]* \[0-9\]* \[0-9\]* \[0-9\]* \[0-9\]* \[0-9\]* \[0-9\]* \[0-9\]* 00000000 1 14HPGP public key 7 13 8 \[0-9\]* \[0-9\]* \[0-9\]* \[0-9\]* \[0-9\]* \[0-9\]* \[0-9\]* \[0-9\]* \[0-9\]* 00000000 1 16Hkelly@hotbox.com 8 30 8 \[0-9\]* \[0-9\]* \[0-9\]* \[0-9\]* \[0-9\]* \[0-9\]* \[0-9\]* \[0-9\]* \[0-9\]* 00000000 0 12H2 text/plain 9 30 8 \[0-9\]* \[0-9\]* \[0-9\]* \[0-9\]* \[0-9\]* \[0-9\]* \[0-9\]* \[0-9\]* \[0-9\]* 00000000 0 13H2 x-kom/basic 10 33 8 \[0-9\]* \[0-9\]* \[0-9\]* \[0-9\]* \[0-9\]* \[0-9\]* \[0-9\]* \[0-9\]* \[0-9\]* 00000000 1 1H0 11 14 8 \[0-9\]* \[0-9\]* \[0-9\]* \[0-9\]* \[0-9\]* \[0-9\]* \[0-9\]* \[0-9\]* \[0-9\]* 00000000 1 1H3 }\r?"] 0 */ /* } 1 */ SELECT * FROM x;
/* test reg-33.15 {constraint fixes} { */ /*     regexp {(^)+^} x */ /* } 1 */ SELECT * FROM x;
/* test reg-33.16 {constraint fixes} { */ /*     regexp {($^)+} x */ /* } 0 */ SELECT * FROM x;
/* test reg-33.17 {constraint fixes} { */ /*     regexp {(^$)*} x */ /* } 1 */ SELECT * FROM x;
/* test reg-33.18 {constraint fixes} { */ /*     regexp {(^(?!aa))+} {aa bb cc} */ /* } 0 */ SELECT * FROM x;
/* test reg-33.19 {constraint fixes} { */ /*     regexp {(^(?!aa)(?!bb)(?!cc))+} {aa x} */ /* } 0 */ SELECT * FROM x;
/* test reg-33.20 {constraint fixes} { */ /*     regexp {(^(?!aa)(?!bb)(?!cc))+} {bb x} */ /* } 0 */ SELECT * FROM x;
/* test reg-33.21 {constraint fixes} { */ /*     regexp {(^(?!aa)(?!bb)(?!cc))+} {cc x} */ /* } 0 */ SELECT * FROM x;
/* test reg-33.22 {constraint fixes} { */ /*     regexp {(^(?!aa)(?!bb)(?!cc))+} {dd x} */ /* } 1 */ SELECT * FROM x;
/* test reg-33.23 {} { */ /*     regexp {abcd(\m)+xyz} x */ /* } 0 */ SELECT * FROM x;
/* test reg-33.24 {} { */ /*     regexp {abcd(\m)+xyz} a */ /* } 0 */ SELECT * FROM x;
/* test reg-33.25 {} { */ /*     regexp {^abcd*(((((^(a c(e?d)a+|)+|)+|)+|)+|a)+|)} x */ /* } 0 */ SELECT * FROM x;
/* test reg-33.26 {} { */ /*     regexp {a^(^)bcd*xy(((((($a+|)+|)+|)+$|)+|)+|)^$} x */ /* } 0 */ SELECT * FROM x;
/* test reg-33.27 {} { */ /*     regexp {xyz(\Y\Y)+} x */ /* } 0 */ SELECT * FROM x;
/* test reg-33.28 {} { */ /*     regexp {x|(?:\M)+} x */ /* } 1 */ SELECT * FROM x;
/* test reg-33.29 {} { */ /*     # This is near the limits of the RE engine */ /*     regexp [string repeat x*y*z* 480] x */ /* } 1 */ /* The runtime cost of this seems out of proportion to the value, */ /* so for Postgres purposes reduce the repeat to 200x */ SELECT * FROM x;
/* test reg-33.30 {Bug 1080042} { */ /*     regexp {(\Y)+} foo */ /* } 1 */ SELECT * FROM x;
/* and now, tests not from either Spencer or the Tcl project */ /* These cases exercise additional code paths in pushfwd()/push()/combine() */ SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
/* you may need to make them longer if you change BULK_ARC_OP_USE_SORT() */ SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SET x = on;
/* Run the Tcl test cases that require Unicode */ /* expectMatch	9.44 EMP*	{a[\u00fe-\u0507][\u00ff-\u0300]b} \ */ /* 	"a\u0102\u02ffb"	"a\u0102\u02ffb" */ SELECT * FROM x;
/* expectMatch	13.27 P		"a\\U00001234x"	"a\u1234x"	"a\u1234x" */ SELECT * FROM x;
/* expectMatch	13.28 P		{a\U00001234x}	"a\u1234x"	"a\u1234x" */ SELECT * FROM x;
/* expectMatch	13.29 P		"a\\U0001234x"	"a\u1234x"	"a\u1234x" */ /* Tcl has relaxed their code to allow 1-8 hex digits, but Postgres hasn't */ SELECT * FROM x;
/* expectMatch	13.30 P		{a\U0001234x}	"a\u1234x"	"a\u1234x" */ /* Tcl has relaxed their code to allow 1-8 hex digits, but Postgres hasn't */ SELECT * FROM x;
/* expectMatch	13.31 P		"a\\U000012345x"	"a\u12345x"	"a\u12345x" */ SELECT * FROM x;
/* expectMatch	13.32 P		{a\U000012345x}	"a\u12345x"	"a\u12345x" */ SELECT * FROM x;
/* expectMatch	13.33 P		"a\\U1000000x"	"a\ufffd0x"	"a\ufffd0x" */ /* Tcl allows this as a standalone character, but Postgres doesn't */ SELECT * FROM x;
/* expectMatch	13.34 P		{a\U1000000x}	"a\ufffd0x"	"a\ufffd0x" */ /* Tcl allows this as a standalone character, but Postgres doesn't */ SELECT * FROM x;
/* Additional tests, not derived from Tcl */ /* Exercise logic around high character ranges a bit more */ SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
/* systematically test char classes */ SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
CREATE FUNCTION x() RETURNS pg_catalog.void LANGUAGE C AS 'MODULE_PATHNAME';
CREATE FUNCTION x() RETURNS pg_catalog.void LANGUAGE C AS 'MODULE_PATHNAME';
CREATE FUNCTION x() RETURNS pg_catalog.void LANGUAGE C AS 'MODULE_PATHNAME';
CREATE FUNCTION x(x pg_catalog.int4, x pg_catalog.int4, x pg_catalog.int4, x pg_catalog.int4, x pg_catalog.int4) RETURNS pg_catalog.void LANGUAGE C AS 'MODULE_PATHNAME';
CREATE EXTENSION test_resowner;
/* This is small enough that everything fits in the small array */ SELECT TEST_RESOWNER_PRIORITIES(2, 3);
/* Same test with more resources, to exercise the hash table */ SELECT TEST_RESOWNER_PRIORITIES(2, 32);
/* Basic test with lots more resources, to test extending the hash table */ SELECT TEST_RESOWNER_MANY(3 /* # of different resource kinds */, 100000 /* before-locks resources to remember */, 500 /* before-locks resources to forget */, 100000 /* after-locks resources to remember */, 500 /* after-locks resources to forget */);
/* Test resource leak warning */ SELECT TEST_RESOWNER_LEAK();
SET x = 'warning' /* Negative tests, using a resource owner after release-phase has started. */;
/* order between ERROR and NOTICE varies */ SELECT TEST_RESOWNER_REMEMBER_BETWEEN_PHASES();
SELECT TEST_RESOWNER_FORGET_BETWEEN_PHASES();
RESET client_min_messages;
LOAD 'test_rls_hooks';
CREATE TABLE x (x NAME, x NAME, x INT);
/* initial test data */ INSERT INTO x VALUES ('regress_r1', 'regress_s1', 4);
INSERT INTO x VALUES ('regress_r2', 'regress_s2', 5);
INSERT INTO x VALUES ('regress_r3', 'regress_s3', 6);
CREATE TABLE x (x NAME, x NAME, x INT);
/* At least one permissive policy must exist, otherwise */ /* the default deny policy will be applied.  For */ /* testing the only-restrictive-policies from the hook, */ /* create a simple 'allow all' policy. */ CREATE POLICY p1 ON rls_test_restrictive USING (true);
/* initial test data */ INSERT INTO x VALUES ('regress_r1', 'regress_s1', 1);
INSERT INTO x VALUES ('regress_r2', 'regress_s2', 2);
INSERT INTO x VALUES ('regress_r3', 'regress_s3', 3);
CREATE TABLE x (x NAME, x NAME, x INT);
/* initial test data */ INSERT INTO x VALUES ('regress_r1', 'regress_s1', 7);
INSERT INTO x VALUES ('regress_r2', 'regress_s2', 8);
INSERT INTO x VALUES ('regress_r3', 'regress_s3', 9);
ALTER TABLE rls_test_permissive ENABLE ROW LEVEL SECURITY;
ALTER TABLE rls_test_restrictive ENABLE ROW LEVEL SECURITY;
ALTER TABLE rls_test_both ENABLE ROW LEVEL SECURITY;
CREATE ROLE regress_r1;
CREATE ROLE regress_s1;
GRANT SELECT, INSERT ON x TO x;
GRANT SELECT, INSERT ON x TO x;
GRANT SELECT, INSERT ON x TO x;
GRANT SELECT, INSERT ON x TO x;
GRANT SELECT, INSERT ON x TO x;
GRANT SELECT, INSERT ON x TO x;
SET ROLE regress_r1;
/* With only the hook's policies, permissive */ /* hook's policy is current_user = username */ EXPLAIN (costs off) SELECT * FROM rls_test_permissive;
SELECT * FROM x;
/* success */ INSERT INTO x VALUES ('regress_r1', 'regress_s1', 10);
/* failure */ INSERT INTO x VALUES ('regress_r4', 'regress_s4', 10);
SET ROLE regress_s1;
/* With only the hook's policies, restrictive */ /* hook's policy is current_user = supervisor */ EXPLAIN (costs off) SELECT * FROM rls_test_restrictive;
SELECT * FROM x;
/* success */ INSERT INTO x VALUES ('regress_r1', 'regress_s1', 10);
/* failure */ INSERT INTO x VALUES ('regress_r4', 'regress_s4', 10);
SET ROLE regress_s1;
/* With only the hook's policies, both */ /* permissive hook's policy is current_user = username */ /* restrictive hook's policy is current_user = superuser */ /* combined with AND, results in nothing being allowed */ EXPLAIN (costs off) SELECT * FROM rls_test_both;
SELECT * FROM x;
/* failure */ INSERT INTO x VALUES ('regress_r1', 'regress_s1', 10);
/* failure */ INSERT INTO x VALUES ('regress_r4', 'regress_s1', 10);
/* failure */ INSERT INTO x VALUES ('regress_r4', 'regress_s4', 10);
RESET ROLE;
/* Create "internal" policies, to check that the policies from */ /* the hooks are combined correctly. */ CREATE POLICY p1 ON rls_test_permissive USING (data % 2 = 0);
/* Remove the original allow-all policy */ DROP POLICY p1 ON rls_test_restrictive;
CREATE POLICY p1 ON rls_test_restrictive USING (data % 2 = 0);
CREATE POLICY p1 ON rls_test_both USING (data % 2 = 0);
SET ROLE regress_r1;
/* With both internal and hook policies, permissive */ EXPLAIN (costs off) SELECT * FROM rls_test_permissive;
SELECT * FROM x;
/* success */ INSERT INTO x VALUES ('regress_r1', 'regress_s1', 7);
/* success */ INSERT INTO x VALUES ('regress_r3', 'regress_s3', 10);
/* failure */ INSERT INTO x VALUES ('regress_r4', 'regress_s4', 7);
SET ROLE regress_s1;
/* With both internal and hook policies, restrictive */ EXPLAIN (costs off) SELECT * FROM rls_test_restrictive;
SELECT * FROM x;
/* success */ INSERT INTO x VALUES ('regress_r1', 'regress_s1', 8);
/* failure */ INSERT INTO x VALUES ('regress_r3', 'regress_s3', 10);
/* failure */ INSERT INTO x VALUES ('regress_r1', 'regress_s1', 7);
/* failure */ INSERT INTO x VALUES ('regress_r4', 'regress_s4', 7);
/* With both internal and hook policies, both permissive */ /* and restrictive hook policies */ EXPLAIN (costs off) SELECT * FROM rls_test_both;
SELECT * FROM x;
/* success */ INSERT INTO x VALUES ('regress_r1', 'regress_s1', 8);
/* failure */ INSERT INTO x VALUES ('regress_r3', 'regress_s3', 10);
/* failure */ INSERT INTO x VALUES ('regress_r1', 'regress_s1', 7);
/* failure */ INSERT INTO x VALUES ('regress_r4', 'regress_s4', 7);
RESET ROLE;
DROP TABLE x;
DROP TABLE x;
DROP TABLE x;
DROP ROLE regress_r1;
DROP ROLE regress_s1;
CREATE FUNCTION x(x pg_catalog.int8, x pg_catalog.text, x pg_catalog.int4 DEFAULT 1, x pg_catalog.int4 DEFAULT 1, x pg_catalog.bool DEFAULT TRUE) RETURNS pg_catalog.void STRICT LANGUAGE C AS 'MODULE_PATHNAME';
CREATE EXTENSION test_shm_mq;
/* These tests don't produce any interesting output.  We're checking that */ /* the operations complete without crashing or hanging and that none of their */ /* internal sanity tests fail. */ SELECT TEST_SHM_MQ(1024, '', 2000, 1);
SELECT TEST_SHM_MQ(1024, 'a', 2001, 1);
SELECT TEST_SHM_MQ(32768, (SELECT GROUP_CONCAT(CHR(32 + CAST((RAND() * 95) AS INT)), '') FROM x), 10000, 1);
SELECT TEST_SHM_MQ(100, (SELECT GROUP_CONCAT(CHR(32 + CAST((RAND() * 95) AS INT)), '') FROM x), 10000, 1);
SELECT TEST_SHM_MQ_PIPELINED(16384, (SELECT GROUP_CONCAT(CHR(32 + CAST((RAND() * 95) AS INT)), '') FROM x), 200, 3);
CREATE OR REPLACE FUNCTION test_slru_page_writeall() RETURNS VOID   AS 'MODULE_PATHNAME', 'test_slru_page_writeall' LANGUAGE C;
CREATE OR REPLACE FUNCTION test_slru_page_sync(bigint) RETURNS VOID   AS 'MODULE_PATHNAME', 'test_slru_page_sync' LANGUAGE C;
CREATE OR REPLACE FUNCTION test_slru_page_read(bigint, bool DEFAULT true) RETURNS text   AS 'MODULE_PATHNAME', 'test_slru_page_read' LANGUAGE C;
CREATE OR REPLACE FUNCTION test_slru_page_readonly(bigint) RETURNS text   AS 'MODULE_PATHNAME', 'test_slru_page_readonly' LANGUAGE C;
CREATE OR REPLACE FUNCTION test_slru_page_exists(bigint) RETURNS bool   AS 'MODULE_PATHNAME', 'test_slru_page_exists' LANGUAGE C;
CREATE OR REPLACE FUNCTION test_slru_page_delete(bigint) RETURNS VOID   AS 'MODULE_PATHNAME', 'test_slru_page_delete' LANGUAGE C;
CREATE OR REPLACE FUNCTION test_slru_page_truncate(bigint) RETURNS VOID   AS 'MODULE_PATHNAME', 'test_slru_page_truncate' LANGUAGE C;
CREATE OR REPLACE FUNCTION test_slru_delete_all() RETURNS VOID   AS 'MODULE_PATHNAME', 'test_slru_delete_all' LANGUAGE C;
CREATE OR REPLACE FUNCTION test_create_multixact() RETURNS xid   AS 'MODULE_PATHNAME', 'test_create_multixact' LANGUAGE C;
CREATE OR REPLACE FUNCTION test_read_multixact(xid) RETURNS VOID   AS 'MODULE_PATHNAME', 'test_read_multixact'LANGUAGE C;
CREATE EXTENSION test_slru;
SELECT TEST_SLRU_PAGE_EXISTS(12345);
SELECT TEST_SLRU_PAGE_WRITE(12345, 'Test SLRU');
SELECT TEST_SLRU_PAGE_READ(12345);
SELECT TEST_SLRU_PAGE_EXISTS(12345);
/* 48 extra pages */ SELECT COUNT(TEST_SLRU_PAGE_WRITE(x, 'Test SLRU')) FROM x AS x;
/* Reading page in buffer for read and write */ SELECT TEST_SLRU_PAGE_READ(12377, TRUE);
/* Reading page in buffer for read-only */ SELECT TEST_SLRU_PAGE_READONLY(12377);
/* Reading page not in buffer with read-only */ SELECT TEST_SLRU_PAGE_READONLY(12346);
/* Write all the pages in buffers */ SELECT TEST_SLRU_PAGE_WRITEALL();
/* Flush the last page written out. */ SELECT TEST_SLRU_PAGE_SYNC(12393);
SELECT TEST_SLRU_PAGE_EXISTS(12393);
/* Segment deletion */ SELECT TEST_SLRU_PAGE_DELETE(12393);
SELECT TEST_SLRU_PAGE_EXISTS(12393);
/* Page truncation */ SELECT TEST_SLRU_PAGE_EXISTS(12377);
SELECT TEST_SLRU_PAGE_TRUNCATE(12377);
SELECT TEST_SLRU_PAGE_EXISTS(12377);
/* Full deletion */ SELECT TEST_SLRU_DELETE_ALL();
SELECT TEST_SLRU_PAGE_EXISTS(12345);
SELECT TEST_SLRU_PAGE_EXISTS(12377);
SELECT TEST_SLRU_PAGE_EXISTS(12393);
/* Test 64-bit pages */ SELECT TEST_SLRU_PAGE_EXISTS(320254236426240);
SELECT TEST_SLRU_PAGE_WRITE(320254236426240, 'Test SLRU 64-bit');
SELECT TEST_SLRU_PAGE_READ(320254236426240);
SELECT TEST_SLRU_PAGE_EXISTS(320254236426240);
/* 48 extra pages */ SELECT COUNT(TEST_SLRU_PAGE_WRITE(x, 'Test SLRU 64-bit')) FROM x AS x;
/* Reading page in buffer for read and write */ SELECT TEST_SLRU_PAGE_READ(320254236426272, TRUE);
/* Reading page in buffer for read-only */ SELECT TEST_SLRU_PAGE_READONLY(320254236426272);
/* Reading page not in buffer with read-only */ SELECT TEST_SLRU_PAGE_READONLY(320254236426241);
/* Write all the pages in buffers */ SELECT TEST_SLRU_PAGE_WRITEALL();
/* Flush the last page written out. */ SELECT TEST_SLRU_PAGE_SYNC(320254236426288);
SELECT TEST_SLRU_PAGE_EXISTS(320254236426288);
/* Segment deletion */ SELECT TEST_SLRU_PAGE_DELETE(320254236426288);
SELECT TEST_SLRU_PAGE_EXISTS(320254236426288);
/* Page truncation */ SELECT TEST_SLRU_PAGE_EXISTS(320254236426272);
SELECT TEST_SLRU_PAGE_TRUNCATE(320254236426272);
SELECT TEST_SLRU_PAGE_EXISTS(320254236426272);
/* Full deletion */ SELECT TEST_SLRU_DELETE_ALL();
SELECT TEST_SLRU_PAGE_EXISTS(320254236426240);
SELECT TEST_SLRU_PAGE_EXISTS(320254236426272);
SELECT TEST_SLRU_PAGE_EXISTS(320254236426288);
DROP EXTENSION test_slru;
CREATE FUNCTION do_set_block_offsets( blkno bigint, offsets int2[]) RETURNS bigint STRICT PARALLEL UNSAFE AS 'MODULE_PATHNAME' LANGUAGE C;
CREATE FUNCTION check_set_block_offsets() RETURNS void STRICT PARALLEL UNSAFE AS 'MODULE_PATHNAME' LANGUAGE C;
CREATE FUNCTION test_is_full() RETURNS bool STRICT PARALLEL UNSAFE AS 'MODULE_PATHNAME' LANGUAGE C;
CREATE FUNCTION test_destroy() RETURNS void STRICT PARALLEL UNSAFE AS 'MODULE_PATHNAME' LANGUAGE C;
CREATE EXTENSION test_tidstore;
/* To hide the output of do_set_block_offsets() */ CREATE TEMPORARY TABLE x (x BIGINT);
/* Test on empty tidstore. */ SELECT TEST_IS_FULL();
SELECT CHECK_SET_BLOCK_OFFSETS();
/* Add TIDs. */ INSERT INTO x (x) SELECT DO_SET_BLOCK_OFFSETS(x, CAST(ARRAY_AGG(x) AS ARRAY<SMALLINT>)) FROM (VALUES (0), (1), (:maxblkno / 2), (:maxblkno - 1), (:maxblkno)) AS x, (VALUES (1), (2), (:maxoffset / 2), (:maxoffset - 1), (:maxoffset)) AS x GROUP BY x;
/* Test offsets embedded in the bitmap header. */ SELECT DO_SET_BLOCK_OFFSETS(501, CAST(ARRAY(GREATEST(CAST((RAND() * :maxoffset) AS INT), 1)) AS ARRAY<SMALLINT>));
SELECT DO_SET_BLOCK_OFFSETS(502, CAST(ARRAY_AGG(DISTINCT GREATEST(CAST((RAND() * :maxoffset) AS INT), 1)) AS ARRAY<SMALLINT>)) FROM x;
/* Add enough TIDs to cause the store to appear "full", compared */ /* to the allocated memory it started out with. This is easier */ /* with memory contexts in local memory. */ INSERT INTO x (x) SELECT DO_SET_BLOCK_OFFSETS(x, CAST(ARRAY(1, 31, 32, 63, 64, 200) AS ARRAY<SMALLINT>)) FROM x AS x;
/* Zero offset not allowed */ SELECT DO_SET_BLOCK_OFFSETS(1, CAST(ARRAY(0) AS ARRAY<SMALLINT>));
/* Check TIDs we've added to the store. */ SELECT CHECK_SET_BLOCK_OFFSETS();
SELECT TEST_IS_FULL();
/* Re-create the TID store for randommized tests. */ SELECT TEST_DESTROY();
/* Test replacements crossing RT_CHILDPTR_IS_VALUE in both directions */ SELECT TEST_CREATE(FALSE);
SELECT DO_SET_BLOCK_OFFSETS(1, CAST(ARRAY(1) AS ARRAY<SMALLINT>));
SELECT CHECK_SET_BLOCK_OFFSETS();
SELECT DO_SET_BLOCK_OFFSETS(1, CAST(ARRAY(1, 2) AS ARRAY<SMALLINT>));
SELECT CHECK_SET_BLOCK_OFFSETS();
SELECT DO_SET_BLOCK_OFFSETS(1, CAST(ARRAY(1, 2, 3) AS ARRAY<SMALLINT>));
SELECT CHECK_SET_BLOCK_OFFSETS();
SELECT DO_SET_BLOCK_OFFSETS(1, CAST(ARRAY(1, 2, 3, 4) AS ARRAY<SMALLINT>));
SELECT CHECK_SET_BLOCK_OFFSETS();
SELECT DO_SET_BLOCK_OFFSETS(1, CAST(ARRAY(1, 2, 3, 4, 100) AS ARRAY<SMALLINT>));
SELECT CHECK_SET_BLOCK_OFFSETS();
SELECT DO_SET_BLOCK_OFFSETS(1, CAST(ARRAY(1, 2, 3, 4) AS ARRAY<SMALLINT>));
SELECT CHECK_SET_BLOCK_OFFSETS();
SELECT DO_SET_BLOCK_OFFSETS(1, CAST(ARRAY(1, 2, 3) AS ARRAY<SMALLINT>));
SELECT CHECK_SET_BLOCK_OFFSETS();
SELECT DO_SET_BLOCK_OFFSETS(1, CAST(ARRAY(1, 2) AS ARRAY<SMALLINT>));
SELECT CHECK_SET_BLOCK_OFFSETS();
SELECT DO_SET_BLOCK_OFFSETS(1, CAST(ARRAY(1) AS ARRAY<SMALLINT>));
SELECT CHECK_SET_BLOCK_OFFSETS();
SELECT TEST_DESTROY();
/* Use shared memory this time. We can't do that in test_radixtree.sql, */ /* because unused static functions would raise warnings there. */ SELECT TEST_CREATE(TRUE);
/* Test offsets embedded in the bitmap header. */ SELECT DO_SET_BLOCK_OFFSETS(501, CAST(ARRAY(GREATEST(CAST((RAND() * :maxoffset) AS INT), 1)) AS ARRAY<SMALLINT>));
SELECT DO_SET_BLOCK_OFFSETS(502, CAST(ARRAY_AGG(DISTINCT GREATEST(CAST((RAND() * :maxoffset) AS INT), 1)) AS ARRAY<SMALLINT>)) FROM x;
/* Random TIDs test. The offset numbers are randomized and must be */ /* unique and ordered. */ INSERT INTO x (x) SELECT DO_SET_BLOCK_OFFSETS(x, CAST(ARRAY_AGG(DISTINCT GREATEST(CAST((RAND() * :maxoffset) AS INT), 1)) AS ARRAY<SMALLINT>)) FROM x AS x, x AS x GROUP BY x;
/* Check TIDs we've added to the store. */ SELECT CHECK_SET_BLOCK_OFFSETS();
/* cleanup */ SELECT TEST_DESTROY();
DROP TABLE x;
/* This test checks that lookup_type_cache() can correctly handle an */ /* interruption.  We use the injection point to simulate an error but note */ /* that a similar situation could happen due to user query interruption. */ /* Despite the interruption, a map entry from the relation oid to type cache */ /* entry should be created.  This is validated by subsequent modification of */ /* the table schema, then type casts which use new schema implying */ /* successful type cache invalidation by relation oid. */ CREATE EXTENSION injection_points;
/* Make all injection points local to this process, for concurrency. */ SELECT INJECTION_POINTS_SET_LOCAL();
CREATE TABLE x (x INT);
SELECT INJECTION_POINTS_ATTACH('typecache-before-rel-type-cache-insert', 'error');
SELECT CAST('(1)' AS t);
SELECT INJECTION_POINTS_DETACH('typecache-before-rel-type-cache-insert');
ALTER TABLE x ADD COLUMN x INT;
SELECT CAST('(1,2)' AS t);
/* Tests for things affected by allow_system_table_mods */ /* We run the same set of commands once with allow_system_table_mods */ /* off and then again with on. */ /* The "on" tests should where possible be wrapped in BEGIN/ROLLBACK */ /* blocks so as to not leave a mess around. */ CREATE USER regress_user_ast;
SET x = off;
/* create new table in pg_catalog */ CREATE TABLE x.x (x INT);
/* anyarray column */ CREATE TABLE x (x INT, x anyarray);
/* index on system catalog */ ALTER TABLE pg_namespace ADD CONSTRAINT foo UNIQUE USING INDEX pg_namespace_nspname_index;
/* write to system catalog table as superuser */ /* (allowed even without allow_system_table_mods) */ INSERT INTO x (x, x, x, x) VALUES (0, 0, 0, 'foo');
GRANT INSERT ON x TO x /* write to system catalog table as normal user */;
SET ROLE regress_user_ast;
INSERT INTO x (x, x, x, x) VALUES (0, 0, 1, 'foo');
RESET ROLE;
/* policy on system catalog */ CREATE POLICY foo ON pg_description FOR SELECT USING (description NOT LIKE 'secret%');
/* reserved schema name */ CREATE SCHEMA x.x;
/* drop system table */ DROP TABLE x;
TRUNCATE TABLE x /* truncate of system table */;
ALTER TABLE x RENAME COLUMN x TO x /* rename column of system table */;
ALTER TABLE x ALTER COLUMN x SET NOT NULL /* ATSimplePermissions() */;
ALTER TABLE x ALTER COLUMN x DROP DEFAULT, SET STATISTICS -1 /* SET STATISTICS */;
/* foreign key referencing catalog */ CREATE TABLE x (x OID, x OID, x INT, FOREIGN KEY (x, x, x) REFERENCES x);
/* RangeVarCallbackOwnsRelation() */ CREATE INDEX x ON x(x NULLS LAST);
ALTER TABLE x RENAME TO x /* RangeVarCallbackForAlterRelation() */;
ALTER TABLE pg_description SET SCHEMA public;
/* reserved tablespace name */ CREATE TABLESPACE pg_foo LOCATION '/no/such/location';
CREATE TRIGGER t1 BEFORE INSERT ON pg_description EXECUTE FUNCTION tf1();
ALTER TRIGGER t1 ON pg_description RENAME TO t2;
/* rules */ CREATE RULE r1 AS ON INSERT TO pg_description DO INSTEAD NOTHING;
ALTER RULE r1 ON pg_description RENAME TO r2;
SET x = on /* now make one to test dropping: */;
CREATE RULE r2 AS ON INSERT TO pg_description DO INSTEAD NOTHING;
RESET allow_system_table_mods;
DROP RULE r2 ON pg_description;
SET x = on /* cleanup: */;
DROP RULE r2 ON pg_description;
RESET allow_system_table_mods;
ALTER TABLE x.x SET x = '90' /* Reloptions on TOAST tables */;
SET x = on;
/* create new table in pg_catalog */ BEGIN;
CREATE TABLE x.x (x INT);
ROLLBACK;
/* anyarray column */ BEGIN;
CREATE TABLE x (x INT, x anyarray);
ROLLBACK;
/* index on system catalog */ BEGIN;
ALTER TABLE pg_namespace ADD CONSTRAINT foo UNIQUE USING INDEX pg_namespace_nspname_index;
ROLLBACK;
/* write to system catalog table as superuser */ BEGIN;
INSERT INTO x (x, x, x, x) VALUES (0, 0, 2, 'foo');
ROLLBACK;
/* write to system catalog table as normal user */ /* (not allowed) */ SET ROLE regress_user_ast;
INSERT INTO x (x, x, x, x) VALUES (0, 0, 3, 'foo');
RESET ROLE;
/* policy on system catalog */ BEGIN;
CREATE POLICY foo ON pg_description FOR SELECT USING (description NOT LIKE 'secret%');
ROLLBACK;
/* reserved schema name */ BEGIN;
CREATE SCHEMA x.x;
ROLLBACK;
/* drop system table */ /* (This will fail anyway because it's pinned.) */ BEGIN;
DROP TABLE x;
ROLLBACK;
/* truncate of system table */ BEGIN;
TRUNCATE TABLE x;
ROLLBACK;
/* rename column of system table */ BEGIN;
ALTER TABLE x RENAME COLUMN x TO x;
ROLLBACK;
/* ATSimplePermissions() */ BEGIN;
ALTER TABLE x ALTER COLUMN x SET NOT NULL;
ROLLBACK;
/* SET STATISTICS */ BEGIN;
ALTER TABLE x ALTER COLUMN x DROP DEFAULT, SET STATISTICS -1;
ROLLBACK;
/* foreign key referencing catalog */ BEGIN;
CREATE TABLE x (x OID, x OID, x INT, FOREIGN KEY (x, x, x) REFERENCES x);
ROLLBACK;
/* RangeVarCallbackOwnsRelation() */ BEGIN;
CREATE INDEX x ON x(x NULLS LAST);
ROLLBACK;
/* RangeVarCallbackForAlterRelation() */ BEGIN;
ALTER TABLE x RENAME TO x;
ROLLBACK;
BEGIN;
ALTER TABLE pg_description SET SCHEMA public;
ROLLBACK;
SET x = error /* reserved tablespace name */;
/* disable ENFORCE_REGRESSION_TEST_NAME_RESTRICTIONS warning */ CREATE TABLESPACE pg_foo LOCATION '/no/such/location';
RESET client_min_messages;
/* triggers */ CREATE TRIGGER t1 BEFORE INSERT ON pg_description EXECUTE FUNCTION tf1();
ALTER TRIGGER t1 ON pg_description RENAME TO t2;
DROP TRIGGER t2 ON pg_description;
/* rules */ CREATE RULE r1 AS ON INSERT TO pg_description DO INSTEAD NOTHING;
ALTER RULE r1 ON pg_description RENAME TO r2;
DROP RULE r2 ON pg_description;
ALTER TABLE x.x SET x = '90' /* Reloptions on TOAST tables */;
/* cleanup */ REVOKE ALL ON pg_description FROM regress_user_ast;
DROP USER regress_user_ast;
DROP FUNCTION x;
/* Tests for privileges on GUCs. */ /* This is unsafe because changes will affect other databases in the cluster. */ /* Test with a superuser role. */ CREATE ROLE regress_admin SUPERUSER;
/* Perform operations as user 'regress_admin'. */ SET SESSION AUTHORIZATION regress_admin;
SET x = OFF /* PGC_BACKEND */;
/* fail, cannot be set after connection start */ RESET ignore_system_indexes;
/* fail, cannot be set after connection start */ ALTER SYSTEM SET ignore_system_indexes = OFF;
/* ok */ ALTER SYSTEM RESET ignore_system_indexes;
SET x = 50 /* ok */ /* PGC_INTERNAL */;
/* fail, cannot be changed */ RESET block_size;
/* fail, cannot be changed */ ALTER SYSTEM SET block_size = 50;
/* fail, cannot be changed */ ALTER SYSTEM RESET block_size;
SET x = 1000050000 /* fail, cannot be changed */ /* PGC_POSTMASTER */;
/* fail, requires restart */ RESET autovacuum_freeze_max_age;
/* fail, requires restart */ ALTER SYSTEM SET autovacuum_freeze_max_age = 1000050000;
/* ok */ ALTER SYSTEM RESET autovacuum_freeze_max_age;
/* ok */ ALTER SYSTEM SET config_file = '/usr/local/data/postgresql.conf';
/* fail, cannot be changed */ ALTER SYSTEM RESET config_file;
SET x = OFF /* fail, cannot be changed */ /* PGC_SIGHUP */;
/* fail, requires reload */ RESET autovacuum;
/* fail, requires reload */ ALTER SYSTEM SET autovacuum = OFF;
/* ok */ ALTER SYSTEM RESET autovacuum;
SET x = 'C' /* ok */ /* PGC_SUSET */;
/* ok */ RESET lc_messages;
/* ok */ ALTER SYSTEM SET lc_messages = 'C';
/* ok */ ALTER SYSTEM RESET lc_messages;
SET x = OFF /* ok */ /* PGC_SU_BACKEND */;
/* fail, cannot be set after connection start */ RESET jit_debugging_support;
/* fail, cannot be set after connection start */ ALTER SYSTEM SET jit_debugging_support = OFF;
/* ok */ ALTER SYSTEM RESET jit_debugging_support;
SET x = 'ISO, MDY' /* ok */ /* PGC_USERSET */;
/* ok */ RESET DateStyle;
/* ok */ ALTER SYSTEM SET DateStyle = 'ISO, MDY';
/* ok */ ALTER SYSTEM RESET DateStyle;
/* ok */ ALTER SYSTEM SET ssl_renegotiation_limit = 0;
/* fail, cannot be changed */ ALTER SYSTEM RESET ssl_renegotiation_limit;
/* fail, cannot be changed */ /* Finished testing superuser */ /* Create non-superuser with privileges to configure host resource usage */ CREATE ROLE regress_host_resource_admin NOSUPERUSER;
/* Revoke privileges not yet granted */ REVOKE SET, ALTER SYSTEM ON PARAMETER work_mem FROM regress_host_resource_admin;
REVOKE SET, ALTER SYSTEM ON PARAMETER zero_damaged_pages FROM regress_host_resource_admin;
/* Check the new role does not yet have privileges on parameters */ SELECT HAS_PARAMETER_PRIVILEGE('regress_host_resource_admin', 'work_mem', 'SET, ALTER SYSTEM');
SELECT HAS_PARAMETER_PRIVILEGE('regress_host_resource_admin', 'work_mem', 'SET');
SELECT HAS_PARAMETER_PRIVILEGE('regress_host_resource_admin', 'work_mem', 'ALTER SYSTEM');
/* Check inappropriate and nonsense privilege types */ SELECT HAS_PARAMETER_PRIVILEGE('regress_host_resource_admin', 'work_mem', 'SELECT, UPDATE, CREATE');
SELECT HAS_PARAMETER_PRIVILEGE('regress_host_resource_admin', 'work_mem', 'USAGE');
SELECT HAS_PARAMETER_PRIVILEGE('regress_host_resource_admin', 'work_mem', 'WHATEVER');
/* Revoke, grant, and revoke again a SUSET parameter not yet granted */ SELECT HAS_PARAMETER_PRIVILEGE('regress_host_resource_admin', 'zero_damaged_pages', 'SET');
SELECT HAS_PARAMETER_PRIVILEGE('regress_host_resource_admin', 'zero_damaged_pages', 'ALTER SYSTEM');
REVOKE SET ON PARAMETER zero_damaged_pages FROM regress_host_resource_admin;
SELECT HAS_PARAMETER_PRIVILEGE('regress_host_resource_admin', 'zero_damaged_pages', 'SET');
SELECT HAS_PARAMETER_PRIVILEGE('regress_host_resource_admin', 'zero_damaged_pages', 'ALTER SYSTEM');
GRANT SET ON PARAMETER zero_damaged_pages TO regress_host_resource_admin;
SELECT HAS_PARAMETER_PRIVILEGE('regress_host_resource_admin', 'zero_damaged_pages', 'SET');
SELECT HAS_PARAMETER_PRIVILEGE('regress_host_resource_admin', 'zero_damaged_pages', 'ALTER SYSTEM');
REVOKE SET ON PARAMETER zero_damaged_pages FROM regress_host_resource_admin;
SELECT HAS_PARAMETER_PRIVILEGE('regress_host_resource_admin', 'zero_damaged_pages', 'SET');
SELECT HAS_PARAMETER_PRIVILEGE('regress_host_resource_admin', 'zero_damaged_pages', 'ALTER SYSTEM');
/* Revoke, grant, and revoke again a USERSET parameter not yet granted */ SELECT HAS_PARAMETER_PRIVILEGE('regress_host_resource_admin', 'work_mem', 'SET');
SELECT HAS_PARAMETER_PRIVILEGE('regress_host_resource_admin', 'work_mem', 'ALTER SYSTEM');
REVOKE SET ON PARAMETER work_mem FROM regress_host_resource_admin;
SELECT HAS_PARAMETER_PRIVILEGE('regress_host_resource_admin', 'work_mem', 'SET');
SELECT HAS_PARAMETER_PRIVILEGE('regress_host_resource_admin', 'work_mem', 'ALTER SYSTEM');
GRANT SET ON PARAMETER work_mem TO regress_host_resource_admin;
SELECT HAS_PARAMETER_PRIVILEGE('regress_host_resource_admin', 'work_mem', 'SET');
SELECT HAS_PARAMETER_PRIVILEGE('regress_host_resource_admin', 'work_mem', 'ALTER SYSTEM');
REVOKE SET ON PARAMETER work_mem FROM regress_host_resource_admin;
SELECT HAS_PARAMETER_PRIVILEGE('regress_host_resource_admin', 'work_mem', 'SET');
SELECT HAS_PARAMETER_PRIVILEGE('regress_host_resource_admin', 'work_mem', 'ALTER SYSTEM');
/* Revoke privileges from a non-existent custom GUC.  This should not create */ /* entries in the catalog. */ REVOKE ALL ON PARAMETER "none.such" FROM regress_host_resource_admin;
SELECT 1 FROM x WHERE x = 'none.such';
/* Grant and then revoke privileges on the non-existent custom GUC.  Check that */ /* a do-nothing entry is not left in the catalogs after the revoke. */ GRANT ALL ON PARAMETER none.such TO regress_host_resource_admin;
SELECT 1 FROM x WHERE x = 'none.such';
REVOKE ALL ON PARAMETER "None.Such" FROM regress_host_resource_admin;
SELECT 1 FROM x WHERE x = 'none.such';
/* Superuser should be able to ALTER SYSTEM SET a non-existent custom GUC. */ ALTER SYSTEM SET none.such = 'whiz bang';
/* None of the above should have created a placeholder GUC for none.such. */ SHOW none.such;
/* error */ /* However, if we reload ... */ SELECT PG_RELOAD_CONF();
/* then it should be there. */ SHOW none.such;
/* Can't grant on a non-existent core GUC. */ GRANT ALL ON PARAMETER no_such_guc TO regress_host_resource_admin;
/* fail */ /* Initially there are no privileges and no catalog entry for this GUC. */ SELECT HAS_PARAMETER_PRIVILEGE('regress_host_resource_admin', 'enable_material', 'SET');
SELECT HAS_PARAMETER_PRIVILEGE('regress_host_resource_admin', 'enable_material', 'ALTER SYSTEM');
SELECT HAS_PARAMETER_PRIVILEGE('regress_host_resource_admin', 'enable_material', 'SET, ALTER SYSTEM');
SELECT 1 FROM x WHERE x = 'enable_material';
/* GRANT SET creates an entry: */ GRANT SET ON PARAMETER enable_material TO PUBLIC;
SELECT HAS_PARAMETER_PRIVILEGE('regress_host_resource_admin', 'enable_material', 'SET');
SELECT HAS_PARAMETER_PRIVILEGE('regress_host_resource_admin', 'enable_material', 'ALTER SYSTEM');
SELECT HAS_PARAMETER_PRIVILEGE('regress_host_resource_admin', 'enable_material', 'SET, ALTER SYSTEM');
SELECT 1 FROM x WHERE x = 'enable_material';
/* Now grant ALTER SYSTEM: */ GRANT ALL ON PARAMETER enable_material TO PUBLIC;
SELECT HAS_PARAMETER_PRIVILEGE('regress_host_resource_admin', 'enable_material', 'SET');
SELECT HAS_PARAMETER_PRIVILEGE('regress_host_resource_admin', 'enable_material', 'ALTER SYSTEM');
SELECT HAS_PARAMETER_PRIVILEGE('regress_host_resource_admin', 'enable_material', 'SET, ALTER SYSTEM');
SELECT 1 FROM x WHERE x = 'enable_material';
/* REVOKE ALTER SYSTEM brings us back to just the SET privilege: */ REVOKE ALTER SYSTEM ON PARAMETER enable_material FROM PUBLIC;
SELECT HAS_PARAMETER_PRIVILEGE('regress_host_resource_admin', 'enable_material', 'SET');
SELECT HAS_PARAMETER_PRIVILEGE('regress_host_resource_admin', 'enable_material', 'ALTER SYSTEM');
SELECT HAS_PARAMETER_PRIVILEGE('regress_host_resource_admin', 'enable_material', 'SET, ALTER SYSTEM');
SELECT 1 FROM x WHERE x = 'enable_material';
/* And this should remove the entry altogether: */ REVOKE SET ON PARAMETER enable_material FROM PUBLIC;
SELECT 1 FROM x WHERE x = 'enable_material';
/* Grant privileges on parameters to the new non-superuser role */ GRANT SET, ALTER SYSTEM ON PARAMETER     autovacuum_work_mem, hash_mem_multiplier, max_stack_depth,     shared_buffers, temp_file_limit, work_mem TO regress_host_resource_admin;
/* Check the new role now has privileges on parameters */ SELECT HAS_PARAMETER_PRIVILEGE('regress_host_resource_admin', 'work_mem', 'SET, ALTER SYSTEM');
SELECT HAS_PARAMETER_PRIVILEGE('regress_host_resource_admin', 'work_mem', 'SET');
SELECT HAS_PARAMETER_PRIVILEGE('regress_host_resource_admin', 'work_mem', 'ALTER SYSTEM');
SELECT HAS_PARAMETER_PRIVILEGE('regress_host_resource_admin', 'work_mem', 'SET WITH GRANT OPTION, ALTER SYSTEM WITH GRANT OPTION');
/* Check again the inappropriate and nonsense privilege types.  The prior */ /* similar check was performed before any entry for work_mem existed. */ SELECT HAS_PARAMETER_PRIVILEGE('regress_host_resource_admin', 'work_mem', 'SELECT, UPDATE, CREATE');
SELECT HAS_PARAMETER_PRIVILEGE('regress_host_resource_admin', 'work_mem', 'USAGE');
SELECT HAS_PARAMETER_PRIVILEGE('regress_host_resource_admin', 'work_mem', 'WHATEVER');
SELECT HAS_PARAMETER_PRIVILEGE('regress_host_resource_admin', 'work_mem', 'WHATEVER WITH GRANT OPTION');
/* Check other function signatures */ SELECT HAS_PARAMETER_PRIVILEGE((SELECT x FROM x.x WHERE x = 'regress_host_resource_admin'), 'max_stack_depth', 'SET');
SELECT HAS_PARAMETER_PRIVILEGE('hash_mem_multiplier', 'set');
/* Check object identity functions */ SELECT PG_DESCRIBE_OBJECT(x, x, 0) FROM x WHERE x = 'work_mem';
SELECT PG_IDENTIFY_OBJECT(x, x, 0) FROM x WHERE x = 'work_mem';
SELECT PG_IDENTIFY_OBJECT_AS_ADDRESS(x, x, 0) FROM x WHERE x = 'work_mem';
SELECT CAST(x AS REGCLASS), (SELECT x FROM x WHERE x = x.x) AS x, x FROM x AS x;
/* Make a per-role setting that regress_host_resource_admin can't change */ ALTER ROLE regress_host_resource_admin SET lc_messages = 'C';
/* Perform some operations as user 'regress_host_resource_admin' */ SET SESSION AUTHORIZATION regress_host_resource_admin;
ALTER SYSTEM SET autovacuum_work_mem = 32;
/* ok, privileges have been granted */ ALTER SYSTEM SET ignore_system_indexes = OFF;
/* fail, insufficient privileges */ ALTER SYSTEM RESET autovacuum_multixact_freeze_max_age;
SET x = 'llvmjit' /* fail, insufficient privileges */;
/* fail, insufficient privileges */ SELECT SET_CONFIG('jit_provider', 'llvmjit', TRUE);
/* fail, insufficient privileges */ ALTER SYSTEM SET shared_buffers = 50;
/* ok */ ALTER SYSTEM RESET shared_buffers;
SET x = 50 /* ok */;
/* cannot be changed now */ ALTER SYSTEM RESET temp_file_limit;
SET x = 'Europe/Helsinki' /* ok */;
/* ok */ RESET TimeZone;
SET x = '100kB' /* ok */;
/* ok, privileges have been granted */ RESET max_stack_depth;
/* ok, privileges have been granted */ ALTER SYSTEM SET max_stack_depth = '100kB';
/* ok, privileges have been granted */ ALTER SYSTEM RESET max_stack_depth;
SET x = 'C' /* ok, privileges have been granted */;
/* fail, insufficient privileges */ RESET lc_messages;
/* fail, insufficient privileges */ ALTER SYSTEM SET lc_messages = 'C';
/* fail, insufficient privileges */ ALTER SYSTEM RESET lc_messages;
/* fail, insufficient privileges */ SELECT SET_CONFIG('temp_buffers', '8192', FALSE);
/* ok */ ALTER SYSTEM RESET autovacuum_work_mem;
/* ok, privileges have been granted */ ALTER SYSTEM RESET ALL;
/* fail, insufficient privileges */ ALTER SYSTEM SET none.such2 = 'whiz bang';
/* fail, not superuser */ ALTER ROLE regress_host_resource_admin SET lc_messages = 'POSIX';
/* fail */ ALTER ROLE regress_host_resource_admin SET max_stack_depth = '1MB';
/* ok */ SELECT x FROM x WHERE x = CAST('regress_host_resource_admin' AS REGROLE);
ALTER ROLE regress_host_resource_admin RESET max_stack_depth;
/* ok */ SELECT x FROM x WHERE x = CAST('regress_host_resource_admin' AS REGROLE);
ALTER ROLE regress_host_resource_admin SET max_stack_depth = '1MB';
/* ok */ SELECT x FROM x WHERE x = CAST('regress_host_resource_admin' AS REGROLE);
ALTER ROLE regress_host_resource_admin RESET ALL;
/* doesn't reset lc_messages */ SELECT x FROM x WHERE x = CAST('regress_host_resource_admin' AS REGROLE);
/* Check dropping/revoking behavior */ SET SESSION AUTHORIZATION regress_admin;
DROP ROLE regress_host_resource_admin;
/* fail, privileges remain */ /* Use "revoke" to remove the privileges and allow the role to be dropped */ REVOKE SET, ALTER SYSTEM ON PARAMETER     autovacuum_work_mem, hash_mem_multiplier, max_stack_depth,     shared_buffers, temp_file_limit, work_mem FROM regress_host_resource_admin;
DROP ROLE regress_host_resource_admin;
/* ok */ /* Try that again, but use "drop owned by" instead of "revoke" */ CREATE ROLE regress_host_resource_admin NOSUPERUSER;
SET SESSION AUTHORIZATION regress_host_resource_admin;
ALTER SYSTEM SET autovacuum_work_mem = 32;
/* fail, privileges not yet granted */ SET SESSION AUTHORIZATION regress_admin;
GRANT SET, ALTER SYSTEM ON PARAMETER     autovacuum_work_mem, hash_mem_multiplier, max_stack_depth,     shared_buffers, temp_file_limit, work_mem TO regress_host_resource_admin;
DROP ROLE regress_host_resource_admin;
/* fail, privileges remain */ DROP OWNED BY regress_host_resource_admin RESTRICT;
/* cascade should not be needed */ SET SESSION AUTHORIZATION regress_host_resource_admin;
ALTER SYSTEM SET autovacuum_work_mem = 32;
/* fail, "drop owned" has dropped privileges */ SET SESSION AUTHORIZATION regress_admin;
DROP ROLE regress_host_resource_admin;
/* ok */ /* Check that "reassign owned" doesn't affect privileges */ CREATE ROLE regress_host_resource_admin NOSUPERUSER;
CREATE ROLE regress_host_resource_newadmin NOSUPERUSER;
GRANT SET, ALTER SYSTEM ON PARAMETER     autovacuum_work_mem, hash_mem_multiplier, max_stack_depth,     shared_buffers, temp_file_limit, work_mem TO regress_host_resource_admin;
SET SESSION AUTHORIZATION regress_host_resource_admin;
ALTER SYSTEM SET autovacuum_work_mem = 32;
/* ok, "reassign owned" did not change privileges */ ALTER SYSTEM RESET autovacuum_work_mem;
/* ok */ SET SESSION AUTHORIZATION regress_admin;
DROP ROLE regress_host_resource_admin;
/* fail, privileges remain */ DROP ROLE regress_host_resource_newadmin;
/* ok, nothing was transferred */ /* Use "drop owned by" so we can drop the role */ DROP OWNED BY regress_host_resource_admin;
/* ok */ DROP ROLE regress_host_resource_admin;
/* ok */ /* Clean up */ RESET SESSION AUTHORIZATION;
DROP ROLE regress_admin;
SET x = ERROR /* We test creation and use of these role names to ensure that the server */ /* correctly distinguishes role keywords from quoted names that look like */ /* those keywords.  In a test environment, creation of these roles may */ /* provoke warnings, so hide the warnings by raising client_min_messages. */;
CREATE ROLE "Public";
CREATE ROLE "None";
CREATE ROLE "current_role";
CREATE ROLE "current_user";
CREATE ROLE "session_user";
CREATE ROLE "user";
RESET client_min_messages;
CREATE ROLE current_user;
/* error */ CREATE ROLE current_role;
/* error */ CREATE ROLE session_user;
/* error */ CREATE ROLE user;
/* error */ CREATE ROLE all;
/* error */ CREATE ROLE public;
/* error */ CREATE ROLE "public";
/* error */ CREATE ROLE none;
/* error */ CREATE ROLE "none";
/* error */ CREATE ROLE pg_abc;
/* error */ CREATE ROLE "pg_abc";
/* error */ CREATE ROLE pg_abcdef;
/* error */ CREATE ROLE "pg_abcdef";
/* error */ CREATE ROLE regress_testrol0 SUPERUSER LOGIN;
CREATE ROLE regress_testrolx SUPERUSER LOGIN;
CREATE ROLE regress_testrol2 SUPERUSER;
CREATE ROLE regress_testrol1 SUPERUSER LOGIN IN ROLE regress_testrol2;
SET ROLE regress_testrol2;
/*  ALTER ROLE */ BEGIN;
SELECT * FROM x;
ALTER ROLE CURRENT_ROLE WITH REPLICATION;
SELECT * FROM x;
ALTER ROLE "current_role" WITH REPLICATION;
SELECT * FROM x;
ALTER ROLE CURRENT_ROLE WITH NOREPLICATION;
ALTER ROLE CURRENT_USER WITH REPLICATION;
SELECT * FROM x;
ALTER ROLE "current_user" WITH REPLICATION;
SELECT * FROM x;
ALTER ROLE SESSION_USER WITH REPLICATION;
SELECT * FROM x;
ALTER ROLE "session_user" WITH REPLICATION;
SELECT * FROM x;
ALTER USER "Public" WITH REPLICATION;
ALTER USER "None" WITH REPLICATION;
SELECT * FROM x;
ALTER USER regress_testrol1 WITH NOREPLICATION;
ALTER USER regress_testrol2 WITH NOREPLICATION;
SELECT * FROM x;
ROLLBACK;
ALTER ROLE USER WITH LOGIN;
/* error */ ALTER ROLE ALL WITH REPLICATION;
/* error */ ALTER ROLE SESSION_ROLE WITH NOREPLICATION;
/* error */ ALTER ROLE PUBLIC WITH NOREPLICATION;
/* error */ ALTER ROLE "public" WITH NOREPLICATION;
/* error */ ALTER ROLE NONE WITH NOREPLICATION;
/* error */ ALTER ROLE "none" WITH NOREPLICATION;
/* error */ ALTER ROLE nonexistent WITH NOREPLICATION;
/* error */ /*  ALTER USER */ BEGIN;
SELECT * FROM x;
ALTER USER CURRENT_ROLE WITH REPLICATION;
SELECT * FROM x;
ALTER USER "current_role" WITH REPLICATION;
SELECT * FROM x;
ALTER USER CURRENT_ROLE WITH NOREPLICATION;
ALTER USER CURRENT_USER WITH REPLICATION;
SELECT * FROM x;
ALTER USER "current_user" WITH REPLICATION;
SELECT * FROM x;
ALTER USER SESSION_USER WITH REPLICATION;
SELECT * FROM x;
ALTER USER "session_user" WITH REPLICATION;
SELECT * FROM x;
ALTER USER "Public" WITH REPLICATION;
ALTER USER "None" WITH REPLICATION;
SELECT * FROM x;
ALTER USER regress_testrol1 WITH NOREPLICATION;
ALTER USER regress_testrol2 WITH NOREPLICATION;
SELECT * FROM x;
ROLLBACK;
ALTER USER USER WITH LOGIN;
/* error */ ALTER USER ALL WITH REPLICATION;
/* error */ ALTER USER SESSION_ROLE WITH NOREPLICATION;
/* error */ ALTER USER PUBLIC WITH NOREPLICATION;
/* error */ ALTER USER "public" WITH NOREPLICATION;
/* error */ ALTER USER NONE WITH NOREPLICATION;
/* error */ ALTER USER "none" WITH NOREPLICATION;
/* error */ ALTER USER nonexistent WITH NOREPLICATION;
/* error */ /*  ALTER ROLE SET/RESET */ SELECT * FROM x;
ALTER ROLE CURRENT_ROLE SET application_name to 'BAZ';
ALTER ROLE CURRENT_USER SET application_name to 'FOO';
ALTER ROLE SESSION_USER SET application_name to 'BAR';
ALTER ROLE "current_user" SET application_name to 'FOOFOO';
ALTER ROLE "Public" SET application_name to 'BARBAR';
ALTER ROLE ALL SET application_name to 'SLAP';
SELECT * FROM x;
ALTER ROLE regress_testrol1 SET application_name to 'SLAM';
SELECT * FROM x;
ALTER ROLE CURRENT_ROLE RESET application_name;
ALTER ROLE CURRENT_USER RESET application_name;
ALTER ROLE SESSION_USER RESET application_name;
ALTER ROLE "current_user" RESET application_name;
ALTER ROLE "Public" RESET application_name;
ALTER ROLE ALL RESET application_name;
SELECT * FROM x;
ALTER ROLE USER SET application_name to 'BOOM';
/* error */ ALTER ROLE PUBLIC SET application_name to 'BOMB';
/* error */ ALTER ROLE nonexistent SET application_name to 'BOMB';
/* error */ /*  ALTER USER SET/RESET */ SELECT * FROM x;
ALTER USER CURRENT_ROLE SET application_name to 'BAZ';
ALTER USER CURRENT_USER SET application_name to 'FOO';
ALTER USER SESSION_USER SET application_name to 'BAR';
ALTER USER "current_user" SET application_name to 'FOOFOO';
ALTER USER "Public" SET application_name to 'BARBAR';
ALTER USER ALL SET application_name to 'SLAP';
SELECT * FROM x;
ALTER USER regress_testrol1 SET application_name to 'SLAM';
SELECT * FROM x;
ALTER USER CURRENT_ROLE RESET application_name;
ALTER USER CURRENT_USER RESET application_name;
ALTER USER SESSION_USER RESET application_name;
ALTER USER "current_user" RESET application_name;
ALTER USER "Public" RESET application_name;
ALTER USER ALL RESET application_name;
SELECT * FROM x;
ALTER USER USER SET application_name to 'BOOM';
/* error */ ALTER USER PUBLIC SET application_name to 'BOMB';
/* error */ ALTER USER NONE SET application_name to 'BOMB';
/* error */ ALTER USER nonexistent SET application_name to 'BOMB';
/* error */ /* CREATE SCHEMA */ CREATE SCHEMA newschema1 AUTHORIZATION CURRENT_USER;
CREATE SCHEMA newschema2 AUTHORIZATION "current_user";
CREATE SCHEMA newschema3 AUTHORIZATION CURRENT_ROLE;
CREATE SCHEMA newschema4 AUTHORIZATION SESSION_USER;
CREATE SCHEMA newschema5 AUTHORIZATION regress_testrolx;
CREATE SCHEMA newschema6 AUTHORIZATION "Public";
CREATE SCHEMA newschemax AUTHORIZATION USER;
/* error */ CREATE SCHEMA newschemax AUTHORIZATION PUBLIC;
/* error */ CREATE SCHEMA newschemax AUTHORIZATION "public";
/* error */ CREATE SCHEMA newschemax AUTHORIZATION NONE;
/* error */ CREATE SCHEMA newschemax AUTHORIZATION nonexistent;
/* error */ SELECT x.x, x.x FROM x AS x JOIN x AS x ON (x.x = x.x) WHERE x.x LIKE 'newschema_' ORDER BY 1 NULLS LAST;
CREATE SCHEMA IF NOT EXISTS newschema1 AUTHORIZATION CURRENT_USER;
CREATE SCHEMA IF NOT EXISTS newschema2 AUTHORIZATION "current_user";
CREATE SCHEMA IF NOT EXISTS newschema3 AUTHORIZATION CURRENT_ROLE;
CREATE SCHEMA IF NOT EXISTS newschema4 AUTHORIZATION SESSION_USER;
CREATE SCHEMA IF NOT EXISTS newschema5 AUTHORIZATION regress_testrolx;
CREATE SCHEMA IF NOT EXISTS newschema6 AUTHORIZATION "Public";
CREATE SCHEMA IF NOT EXISTS newschemax AUTHORIZATION USER;
/* error */ CREATE SCHEMA IF NOT EXISTS newschemax AUTHORIZATION PUBLIC;
/* error */ CREATE SCHEMA IF NOT EXISTS newschemax AUTHORIZATION "public";
/* error */ CREATE SCHEMA IF NOT EXISTS newschemax AUTHORIZATION NONE;
/* error */ CREATE SCHEMA IF NOT EXISTS newschemax AUTHORIZATION nonexistent;
/* error */ SELECT x.x, x.x FROM x AS x JOIN x AS x ON (x.x = x.x) WHERE x.x LIKE 'newschema_' ORDER BY 1 NULLS LAST;
CREATE TABLE x (x INT);
CREATE TABLE x (x INT);
CREATE TABLE x (x INT);
CREATE TABLE x (x INT);
CREATE TABLE x (x INT);
CREATE TABLE x (x INT);
CREATE TABLE x (x INT);
SET ROLE regress_testrol2;
ALTER TABLE testtab1 OWNER TO CURRENT_USER;
ALTER TABLE testtab2 OWNER TO "current_user";
ALTER TABLE testtab3 OWNER TO CURRENT_ROLE;
ALTER TABLE testtab4 OWNER TO SESSION_USER;
ALTER TABLE testtab5 OWNER TO regress_testrolx;
ALTER TABLE testtab6 OWNER TO "Public";
ALTER TABLE testtab7 OWNER TO USER;
/* error */ ALTER TABLE testtab7 OWNER TO PUBLIC;
/* error */ ALTER TABLE testtab7 OWNER TO "public";
/* error */ ALTER TABLE testtab7 OWNER TO nonexistent;
/* error */ SELECT x.x, x.x FROM x AS x JOIN x AS x ON (x.x = x.x) WHERE x LIKE 'testtab_' ORDER BY 1 NULLS LAST;
CREATE AGGREGATE testagg1(int2) (SFUNC = int2_sum, STYPE = int8);
CREATE AGGREGATE testagg2(int2) (SFUNC = int2_sum, STYPE = int8);
CREATE AGGREGATE testagg3(int2) (SFUNC = int2_sum, STYPE = int8);
CREATE AGGREGATE testagg4(int2) (SFUNC = int2_sum, STYPE = int8);
CREATE AGGREGATE testagg5(int2) (SFUNC = int2_sum, STYPE = int8);
CREATE AGGREGATE testagg6(int2) (SFUNC = int2_sum, STYPE = int8);
CREATE AGGREGATE testagg7(int2) (SFUNC = int2_sum, STYPE = int8);
CREATE AGGREGATE testagg8(int2) (SFUNC = int2_sum, STYPE = int8);
CREATE AGGREGATE testagg9(int2) (SFUNC = int2_sum, STYPE = int8);
CREATE AGGREGATE testagga(int2) (SFUNC = int2_sum, STYPE = int8);
SET ROLE regress_testrol2;
ALTER AGGREGATE testagg1(int2) OWNER TO CURRENT_USER;
ALTER AGGREGATE testagg2(int2) OWNER TO "current_user";
ALTER AGGREGATE testagg3(int2) OWNER TO CURRENT_ROLE;
ALTER AGGREGATE testagg4(int2) OWNER TO SESSION_USER;
ALTER AGGREGATE testagg5(int2) OWNER TO regress_testrolx;
ALTER AGGREGATE testagg6(int2) OWNER TO "Public";
ALTER AGGREGATE testagg6(int2) OWNER TO USER;
/* error */ ALTER AGGREGATE testagg6(int2) OWNER TO PUBLIC;
/* error */ ALTER AGGREGATE testagg6(int2) OWNER TO "public";
/* error */ ALTER AGGREGATE testagg6(int2) OWNER TO nonexistent;
/* error */ SELECT x.x, x.x FROM x AS x JOIN x AS x ON (x.x = x.x) WHERE x LIKE 'testagg_' ORDER BY 1 NULLS LAST;
/* CREATE USER MAPPING */ CREATE FOREIGN DATA WRAPPER test_wrapper;
CREATE SERVER sv1 FOREIGN DATA WRAPPER test_wrapper;
CREATE SERVER sv2 FOREIGN DATA WRAPPER test_wrapper;
CREATE SERVER sv3 FOREIGN DATA WRAPPER test_wrapper;
CREATE SERVER sv4 FOREIGN DATA WRAPPER test_wrapper;
CREATE SERVER sv5 FOREIGN DATA WRAPPER test_wrapper;
CREATE SERVER sv6 FOREIGN DATA WRAPPER test_wrapper;
CREATE SERVER sv7 FOREIGN DATA WRAPPER test_wrapper;
CREATE SERVER sv8 FOREIGN DATA WRAPPER test_wrapper;
CREATE SERVER sv9 FOREIGN DATA WRAPPER test_wrapper;
CREATE SERVER sv10 FOREIGN DATA WRAPPER test_wrapper;
CREATE USER MAPPING FOR CURRENT_USER SERVER sv1 OPTIONS (user 'CURRENT_USER');
CREATE USER MAPPING FOR "current_user" SERVER sv2 OPTIONS (user '"current_user"');
CREATE USER MAPPING FOR CURRENT_ROLE SERVER sv3 OPTIONS (user 'CURRENT_ROLE');
CREATE USER MAPPING FOR USER SERVER sv4 OPTIONS (user 'USER');
CREATE USER MAPPING FOR "user" SERVER sv5 OPTIONS (user '"USER"');
CREATE USER MAPPING FOR SESSION_USER SERVER sv6 OPTIONS (user 'SESSION_USER');
CREATE USER MAPPING FOR PUBLIC SERVER sv7 OPTIONS (user 'PUBLIC');
CREATE USER MAPPING FOR "Public" SERVER sv8 OPTIONS (user '"Public"');
CREATE USER MAPPING FOR regress_testrolx SERVER sv9 OPTIONS (user 'regress_testrolx');
CREATE USER MAPPING FOR nonexistent SERVER sv10 OPTIONS (user 'nonexistent');
SELECT * FROM x;
/* ALTER USER MAPPING */ ALTER USER MAPPING FOR CURRENT_USER SERVER sv1  OPTIONS (SET user 'CURRENT_USER_alt');
ALTER USER MAPPING FOR "current_user" SERVER sv2  OPTIONS (SET user '"current_user"_alt');
ALTER USER MAPPING FOR CURRENT_ROLE SERVER sv3  OPTIONS (SET user 'CURRENT_ROLE_alt');
ALTER USER MAPPING FOR USER SERVER sv4  OPTIONS (SET user 'USER_alt');
ALTER USER MAPPING FOR "user" SERVER sv5  OPTIONS (SET user '"user"_alt');
ALTER USER MAPPING FOR SESSION_USER SERVER sv6  OPTIONS (SET user 'SESSION_USER_alt');
ALTER USER MAPPING FOR PUBLIC SERVER sv7  OPTIONS (SET user 'public_alt');
ALTER USER MAPPING FOR "Public" SERVER sv8  OPTIONS (SET user '"Public"_alt');
ALTER USER MAPPING FOR regress_testrolx SERVER sv9  OPTIONS (SET user 'regress_testrolx_alt');
ALTER USER MAPPING FOR nonexistent SERVER sv10  OPTIONS (SET user 'nonexistent_alt');
/* error */ SELECT * FROM x;
/* DROP USER MAPPING */ DROP USER MAPPING FOR CURRENT_USER SERVER sv1;
DROP USER MAPPING FOR "current_user" SERVER sv2;
DROP USER MAPPING FOR CURRENT_ROLE SERVER sv3;
DROP USER MAPPING FOR USER SERVER sv4;
DROP USER MAPPING FOR "user" SERVER sv5;
DROP USER MAPPING FOR SESSION_USER SERVER sv6;
DROP USER MAPPING FOR PUBLIC SERVER sv7;
DROP USER MAPPING FOR "Public" SERVER sv8;
DROP USER MAPPING FOR regress_testrolx SERVER sv9;
DROP USER MAPPING FOR nonexistent SERVER sv10;
/* error */ SELECT * FROM x;
CREATE USER MAPPING FOR CURRENT_USER SERVER sv1 OPTIONS (user 'CURRENT_USER');
CREATE USER MAPPING FOR "current_user" SERVER sv2 OPTIONS (user '"current_user"');
CREATE USER MAPPING FOR CURRENT_ROLE SERVER sv3 OPTIONS (user 'CURRENT_ROLE');
CREATE USER MAPPING FOR USER SERVER sv4 OPTIONS (user 'USER');
CREATE USER MAPPING FOR "user" SERVER sv5 OPTIONS (user '"USER"');
CREATE USER MAPPING FOR SESSION_USER SERVER sv6 OPTIONS (user 'SESSION_USER');
CREATE USER MAPPING FOR PUBLIC SERVER sv7 OPTIONS (user 'PUBLIC');
CREATE USER MAPPING FOR "Public" SERVER sv8 OPTIONS (user '"Public"');
CREATE USER MAPPING FOR regress_testrolx SERVER sv9 OPTIONS (user 'regress_testrolx');
SELECT * FROM x;
/* DROP USER MAPPING IF EXISTS */ DROP USER MAPPING IF EXISTS FOR CURRENT_USER SERVER sv1;
SELECT * FROM x;
DROP USER MAPPING IF EXISTS FOR "current_user" SERVER sv2;
SELECT * FROM x;
DROP USER MAPPING IF EXISTS FOR CURRENT_USER SERVER sv3;
SELECT * FROM x;
DROP USER MAPPING IF EXISTS FOR USER SERVER sv4;
SELECT * FROM x;
DROP USER MAPPING IF EXISTS FOR "user" SERVER sv5;
SELECT * FROM x;
DROP USER MAPPING IF EXISTS FOR SESSION_USER SERVER sv6;
SELECT * FROM x;
DROP USER MAPPING IF EXISTS FOR PUBLIC SERVER sv7;
SELECT * FROM x;
DROP USER MAPPING IF EXISTS FOR "Public" SERVER sv8;
SELECT * FROM x;
DROP USER MAPPING IF EXISTS FOR regress_testrolx SERVER sv9;
SELECT * FROM x;
DROP USER MAPPING IF EXISTS FOR nonexistent SERVER sv10;
/* error */ /* GRANT/REVOKE */ GRANT regress_testrol0 TO pg_signal_backend;
/* success */ SET ROLE pg_signal_backend;
/* success */ RESET ROLE;
CREATE SCHEMA test_roles_schema AUTHORIZATION pg_signal_backend;
/* success */ SET ROLE regress_testrol2;
UPDATE x SET x = NULL WHERE x LIKE 'testagg_';
SELECT x, x FROM x WHERE x LIKE 'testagg_';
REVOKE ALL PRIVILEGES ON FUNCTION testagg1(int2) FROM PUBLIC;
REVOKE ALL PRIVILEGES ON FUNCTION testagg2(int2) FROM PUBLIC;
REVOKE ALL PRIVILEGES ON FUNCTION testagg3(int2) FROM PUBLIC;
REVOKE ALL PRIVILEGES ON FUNCTION testagg4(int2) FROM PUBLIC;
REVOKE ALL PRIVILEGES ON FUNCTION testagg5(int2) FROM PUBLIC;
REVOKE ALL PRIVILEGES ON FUNCTION testagg6(int2) FROM PUBLIC;
REVOKE ALL PRIVILEGES ON FUNCTION testagg7(int2) FROM PUBLIC;
REVOKE ALL PRIVILEGES ON FUNCTION testagg8(int2) FROM PUBLIC;
GRANT ALL PRIVILEGES ON FUNCTION x TO x;
GRANT ALL PRIVILEGES ON FUNCTION x TO x;
GRANT ALL PRIVILEGES ON FUNCTION x TO "x";
GRANT ALL PRIVILEGES ON FUNCTION x TO x;
GRANT ALL PRIVILEGES ON FUNCTION x TO x;
GRANT ALL PRIVILEGES ON FUNCTION x TO "x";
GRANT ALL PRIVILEGES ON FUNCTION x TO x;
GRANT ALL PRIVILEGES ON FUNCTION x TO "x";
GRANT ALL PRIVILEGES ON FUNCTION x TO x, x, x;
SELECT x, x FROM x WHERE x LIKE 'testagg_';
GRANT ALL PRIVILEGES ON FUNCTION x TO x;
GRANT ALL PRIVILEGES ON FUNCTION x TO x /* error */;
GRANT ALL PRIVILEGES ON FUNCTION x TO "x" /* error */;
/* error */ SELECT x, x FROM x WHERE x LIKE 'testagg_';
REVOKE ALL PRIVILEGES ON FUNCTION testagg1(int2) FROM PUBLIC;
REVOKE ALL PRIVILEGES ON FUNCTION testagg2(int2) FROM CURRENT_USER;
REVOKE ALL PRIVILEGES ON FUNCTION testagg3(int2) FROM "current_user";
REVOKE ALL PRIVILEGES ON FUNCTION testagg4(int2) FROM CURRENT_ROLE;
REVOKE ALL PRIVILEGES ON FUNCTION testagg5(int2) FROM SESSION_USER;
REVOKE ALL PRIVILEGES ON FUNCTION testagg6(int2) FROM "Public";
REVOKE ALL PRIVILEGES ON FUNCTION testagg7(int2) FROM regress_testrolx;
REVOKE ALL PRIVILEGES ON FUNCTION testagg8(int2) FROM "public";
REVOKE ALL PRIVILEGES ON FUNCTION testagg9(int2)  FROM current_user, public, regress_testrolx;
SELECT x, x FROM x WHERE x LIKE 'testagg_';
REVOKE ALL PRIVILEGES ON FUNCTION testagga(int2) FROM USER;
/* error */ REVOKE ALL PRIVILEGES ON FUNCTION testagga(int2) FROM NONE;
/* error */ REVOKE ALL PRIVILEGES ON FUNCTION testagga(int2) FROM "none";
/* error */ SELECT x, x FROM x WHERE x LIKE 'testagg_';
/* DEFAULT MONITORING ROLES */ CREATE ROLE regress_role_haspriv;
CREATE ROLE regress_role_nopriv;
/* pg_read_all_stats */ GRANT pg_read_all_stats TO regress_role_haspriv;
SET SESSION AUTHORIZATION regress_role_haspriv;
/* returns true with role member of pg_read_all_stats */ SELECT COUNT(*) = 0 AS x FROM x WHERE x = '<insufficient privilege>';
SET SESSION AUTHORIZATION regress_role_nopriv;
/* returns false with role not member of pg_read_all_stats */ SELECT COUNT(*) = 0 AS x FROM x WHERE x = '<insufficient privilege>';
RESET SESSION AUTHORIZATION;
REVOKE pg_read_all_stats FROM regress_role_haspriv;
/* pg_read_all_settings */ GRANT pg_read_all_settings TO regress_role_haspriv;
BEGIN;
SET LOCAL x = 'path-to-preload-libraries' /* A GUC using GUC_SUPERUSER_ONLY is useful for negative tests. */;
SET SESSION AUTHORIZATION regress_role_haspriv;
/* passes with role member of pg_read_all_settings */ SHOW session_preload_libraries;
SET SESSION AUTHORIZATION regress_role_nopriv;
/* fails with role not member of pg_read_all_settings */ SHOW session_preload_libraries;
RESET SESSION AUTHORIZATION;
ROLLBACK;
REVOKE pg_read_all_settings FROM regress_role_haspriv;
DROP OWNED BY regress_testrol0, "Public", "current_role", "current_user", regress_testrol1, regress_testrol2, regress_testrolx CASCADE;
DROP ROLE regress_testrol0, regress_testrol1, regress_testrol2, regress_testrolx;
DROP ROLE "Public", "None", "current_role", "current_user", "session_user", "user";
DROP ROLE regress_role_haspriv, regress_role_nopriv;
/* This is borderline unsafe in that an additional login-capable user exists */ /* during the test run.  Under installcheck, a too-permissive pg_hba.conf */ /* might allow unwanted logins as regress_authenticated_user_ssa. */ /* Setup catalog state. */ ALTER USER regress_authenticated_user_db_ssa superuser;
ALTER USER regress_authenticated_user_ssa superuser;
CREATE ROLE regress_session_user;
CREATE ROLE regress_current_user;
GRANT regress_current_user TO regress_authenticated_user_db_sr;
GRANT regress_current_user TO regress_authenticated_user_sr;
GRANT regress_session_user TO regress_authenticated_user_db_ssa;
GRANT regress_session_user TO regress_authenticated_user_ssa;
x;
ALTER ROLE regress_authenticated_user_ssa 	SET session_authorization = regress_session_user;
ALTER ROLE regress_authenticated_user_sr SET ROLE = regress_current_user;
/* We document "The DEFAULT and RESET forms reset the session and current user */ /* identifiers to be the originally authenticated user name."  If we let */ /* session_authorization in setconfig have an effect, we'll need to decide */ /* whether to make RESET differ from DEFAULT. */ RESET SESSION AUTHORIZATION;
SELECT CURRENT_USER(), x;
EXECUTE format( 		'ALTER DATABASE %I SET role = regress_current_user', current_catalog);
x;
SET ROLE NONE;
x;
RESET SESSION AUTHORIZATION;
DROP USER regress_session_user;
DROP USER regress_current_user;
CREATE FUNCTION consume_xids_until(targetxid xid8) RETURNS xid8 VOLATILE PARALLEL UNSAFE STRICT AS 'MODULE_PATHNAME' LANGUAGE C;
SELECT PG_ADVISORY_XACT_LOCK(1), PG_ADVISORY_XACT_LOCK_SHARED(2), PG_ADVISORY_XACT_LOCK(1, 1), PG_ADVISORY_XACT_LOCK_SHARED(2, 2);
SELECT x, x, x, x, x, x FROM x WHERE x = 'advisory' AND x = :datoid ORDER BY x NULLS LAST, x NULLS LAST, x NULLS LAST;
/* pg_advisory_unlock_all() shouldn't release xact locks */ SELECT PG_ADVISORY_UNLOCK_ALL();
SELECT COUNT(*) FROM x WHERE x = 'advisory' AND x = :datoid;
/* can't unlock xact locks */ SELECT PG_ADVISORY_UNLOCK(1), PG_ADVISORY_UNLOCK_SHARED(2), PG_ADVISORY_UNLOCK(1, 1), PG_ADVISORY_UNLOCK_SHARED(2, 2);
COMMIT /* automatically release xact locks at commit */ /* automatically release xact locks at commit */;
SELECT COUNT(*) FROM x WHERE x = 'advisory' AND x = :datoid;
BEGIN;
/* holding both session and xact locks on the same objects, xact first */ SELECT PG_ADVISORY_XACT_LOCK(1), PG_ADVISORY_XACT_LOCK_SHARED(2), PG_ADVISORY_XACT_LOCK(1, 1), PG_ADVISORY_XACT_LOCK_SHARED(2, 2);
SELECT x, x, x, x, x, x FROM x WHERE x = 'advisory' AND x = :datoid ORDER BY x NULLS LAST, x NULLS LAST, x NULLS LAST;
SELECT PG_ADVISORY_LOCK(1), PG_ADVISORY_LOCK_SHARED(2), PG_ADVISORY_LOCK(1, 1), PG_ADVISORY_LOCK_SHARED(2, 2);
ROLLBACK;
SELECT x, x, x, x, x, x FROM x WHERE x = 'advisory' AND x = :datoid ORDER BY x NULLS LAST, x NULLS LAST, x NULLS LAST;
/* unlocking session locks */ SELECT PG_ADVISORY_UNLOCK(1), PG_ADVISORY_UNLOCK(1), PG_ADVISORY_UNLOCK_SHARED(2), PG_ADVISORY_UNLOCK_SHARED(2), PG_ADVISORY_UNLOCK(1, 1), PG_ADVISORY_UNLOCK(1, 1), PG_ADVISORY_UNLOCK_SHARED(2, 2), PG_ADVISORY_UNLOCK_SHARED(2, 2);
SELECT COUNT(*) FROM x WHERE x = 'advisory' AND x = :datoid;
BEGIN;
/* holding both session and xact locks on the same objects, session first */ SELECT PG_ADVISORY_LOCK(1), PG_ADVISORY_LOCK_SHARED(2), PG_ADVISORY_LOCK(1, 1), PG_ADVISORY_LOCK_SHARED(2, 2);
SELECT x, x, x, x, x, x FROM x WHERE x = 'advisory' AND x = :datoid ORDER BY x NULLS LAST, x NULLS LAST, x NULLS LAST;
SELECT PG_ADVISORY_XACT_LOCK(1), PG_ADVISORY_XACT_LOCK_SHARED(2), PG_ADVISORY_XACT_LOCK(1, 1), PG_ADVISORY_XACT_LOCK_SHARED(2, 2);
ROLLBACK;
SELECT x, x, x, x, x, x FROM x WHERE x = 'advisory' AND x = :datoid ORDER BY x NULLS LAST, x NULLS LAST, x NULLS LAST;
/* releasing all session locks */ SELECT PG_ADVISORY_UNLOCK_ALL();
SELECT COUNT(*) FROM x WHERE x = 'advisory' AND x = :datoid;
BEGIN;
/* grabbing txn locks multiple times */ SELECT PG_ADVISORY_XACT_LOCK(1), PG_ADVISORY_XACT_LOCK(1), PG_ADVISORY_XACT_LOCK_SHARED(2), PG_ADVISORY_XACT_LOCK_SHARED(2), PG_ADVISORY_XACT_LOCK(1, 1), PG_ADVISORY_XACT_LOCK(1, 1), PG_ADVISORY_XACT_LOCK_SHARED(2, 2), PG_ADVISORY_XACT_LOCK_SHARED(2, 2);
SELECT x, x, x, x, x, x FROM x WHERE x = 'advisory' AND x = :datoid ORDER BY x NULLS LAST, x NULLS LAST, x NULLS LAST;
COMMIT;
SELECT COUNT(*) FROM x WHERE x = 'advisory' AND x = :datoid;
/* grabbing session locks multiple times */ SELECT PG_ADVISORY_LOCK(1), PG_ADVISORY_LOCK(1), PG_ADVISORY_LOCK_SHARED(2), PG_ADVISORY_LOCK_SHARED(2), PG_ADVISORY_LOCK(1, 1), PG_ADVISORY_LOCK(1, 1), PG_ADVISORY_LOCK_SHARED(2, 2), PG_ADVISORY_LOCK_SHARED(2, 2);
SELECT x, x, x, x, x, x FROM x WHERE x = 'advisory' AND x = :datoid ORDER BY x NULLS LAST, x NULLS LAST, x NULLS LAST;
SELECT PG_ADVISORY_UNLOCK(1), PG_ADVISORY_UNLOCK(1), PG_ADVISORY_UNLOCK_SHARED(2), PG_ADVISORY_UNLOCK_SHARED(2), PG_ADVISORY_UNLOCK(1, 1), PG_ADVISORY_UNLOCK(1, 1), PG_ADVISORY_UNLOCK_SHARED(2, 2), PG_ADVISORY_UNLOCK_SHARED(2, 2);
SELECT COUNT(*) FROM x WHERE x = 'advisory' AND x = :datoid;
/* .. and releasing them all at once */ SELECT PG_ADVISORY_LOCK(1), PG_ADVISORY_LOCK(1), PG_ADVISORY_LOCK_SHARED(2), PG_ADVISORY_LOCK_SHARED(2), PG_ADVISORY_LOCK(1, 1), PG_ADVISORY_LOCK(1, 1), PG_ADVISORY_LOCK_SHARED(2, 2), PG_ADVISORY_LOCK_SHARED(2, 2);
SELECT x, x, x, x, x, x FROM x WHERE x = 'advisory' AND x = :datoid ORDER BY x NULLS LAST, x NULLS LAST, x NULLS LAST;
SELECT PG_ADVISORY_UNLOCK_ALL();
SELECT COUNT(*) FROM x WHERE x = 'advisory' AND x = :datoid;
/* prepare some test data */ CREATE TABLE x (x SMALLINT, x FLOAT);
ANALYZE x;
SELECT AVG(x) AS x FROM x;
SELECT AVG(x) AS x FROM x WHERE x < 100;
SELECT ANY_VALUE(x) FROM (VALUES (1), (2), (3)) AS x;
SELECT ANY_VALUE(x) FROM (VALUES (NULL)) AS x;
SELECT ANY_VALUE(x) FROM (VALUES (NULL), (1), (2)) AS x;
SELECT ANY_VALUE(x) FROM (VALUES (ARRAY('hello', 'world'))) AS x;
/* In 7.1, avg(float4) is computed using float8 arithmetic. */ /* Round the result to 3 digits to avoid platform-specific results. */ SELECT CAST(AVG(x) AS DECIMAL(10, 3)) AS x FROM x;
SELECT AVG(x) AS x FROM ONLY x;
SELECT SUM(x) AS x FROM x;
SELECT SUM(x) AS x FROM x;
SELECT SUM(x) AS x FROM x;
SELECT SUM(x) AS x FROM ONLY x;
SELECT MAX(x) AS x FROM x;
SELECT MAX(x) AS x FROM x;
SELECT MAX(x.x) AS x FROM x;
SELECT MAX(x.x) AS x FROM x;
SELECT STDDEV_POP(x) FROM x;
SELECT STDDEV_SAMP(x) FROM x;
SELECT VARIANCE_POP(x) FROM x;
SELECT VARIANCE(x) FROM x;
SELECT STDDEV_POP(CAST(x AS DECIMAL)) FROM x;
SELECT STDDEV_SAMP(CAST(x AS DECIMAL)) FROM x;
SELECT VARIANCE_POP(CAST(x AS DECIMAL)) FROM x;
SELECT VARIANCE(CAST(x AS DECIMAL)) FROM x;
/* population variance is defined for a single tuple, sample variance */ /* is not */ SELECT VARIANCE_POP(CAST(1.0 AS DOUBLE)), VARIANCE(CAST(2.0 AS DOUBLE));
SELECT STDDEV_POP(CAST(3.0 AS DOUBLE)), STDDEV_SAMP(CAST(4.0 AS DOUBLE));
SELECT VARIANCE_POP(CAST('inf' AS DOUBLE)), VARIANCE(CAST('inf' AS DOUBLE));
SELECT STDDEV_POP(CAST('inf' AS DOUBLE)), STDDEV_SAMP(CAST('inf' AS DOUBLE));
SELECT VARIANCE_POP(CAST('nan' AS DOUBLE)), VARIANCE(CAST('nan' AS DOUBLE));
SELECT STDDEV_POP(CAST('nan' AS DOUBLE)), STDDEV_SAMP(CAST('nan' AS DOUBLE));
SELECT VARIANCE_POP(CAST(1.0 AS FLOAT)), VARIANCE(CAST(2.0 AS FLOAT));
SELECT STDDEV_POP(CAST(3.0 AS FLOAT)), STDDEV_SAMP(CAST(4.0 AS FLOAT));
SELECT VARIANCE_POP(CAST('inf' AS FLOAT)), VARIANCE(CAST('inf' AS FLOAT));
SELECT STDDEV_POP(CAST('inf' AS FLOAT)), STDDEV_SAMP(CAST('inf' AS FLOAT));
SELECT VARIANCE_POP(CAST('nan' AS FLOAT)), VARIANCE(CAST('nan' AS FLOAT));
SELECT STDDEV_POP(CAST('nan' AS FLOAT)), STDDEV_SAMP(CAST('nan' AS FLOAT));
SELECT VARIANCE_POP(CAST(1.0 AS DECIMAL)), VARIANCE(CAST(2.0 AS DECIMAL));
SELECT STDDEV_POP(CAST(3.0 AS DECIMAL)), STDDEV_SAMP(CAST(4.0 AS DECIMAL));
SELECT VARIANCE_POP(CAST('inf' AS DECIMAL)), VARIANCE(CAST('inf' AS DECIMAL));
SELECT STDDEV_POP(CAST('inf' AS DECIMAL)), STDDEV_SAMP(CAST('inf' AS DECIMAL));
SELECT VARIANCE_POP(CAST('nan' AS DECIMAL)), VARIANCE(CAST('nan' AS DECIMAL));
SELECT STDDEV_POP(CAST('nan' AS DECIMAL)), STDDEV_SAMP(CAST('nan' AS DECIMAL));
/* verify correct results for min(record) and max(record) aggregates */ SELECT MAX(ROW(x, x)) FROM x;
SELECT MAX(ROW(x, x)) FROM x;
SELECT MIN(ROW(x, x)) FROM x;
SELECT MIN(ROW(x, x)) FROM x;
/* verify correct results for null and NaN inputs */ SELECT SUM(CAST(NULL AS INT)) FROM x;
SELECT SUM(CAST(NULL AS BIGINT)) FROM x;
SELECT SUM(CAST(NULL AS DECIMAL)) FROM x;
SELECT SUM(CAST(NULL AS DOUBLE)) FROM x;
SELECT AVG(CAST(NULL AS INT)) FROM x;
SELECT AVG(CAST(NULL AS BIGINT)) FROM x;
SELECT AVG(CAST(NULL AS DECIMAL)) FROM x;
SELECT AVG(CAST(NULL AS DOUBLE)) FROM x;
SELECT SUM(CAST('NaN' AS DECIMAL)) FROM x;
SELECT AVG(CAST('NaN' AS DECIMAL)) FROM x;
/* verify correct results for infinite inputs */ SELECT SUM(CAST(x AS DOUBLE)), AVG(CAST(x AS DOUBLE)), VARIANCE_POP(CAST(x AS DOUBLE)) FROM (VALUES ('1'), ('infinity')) AS x;
SELECT SUM(CAST(x AS DOUBLE)), AVG(CAST(x AS DOUBLE)), VARIANCE_POP(CAST(x AS DOUBLE)) FROM (VALUES ('infinity'), ('1')) AS x;
SELECT SUM(CAST(x AS DOUBLE)), AVG(CAST(x AS DOUBLE)), VARIANCE_POP(CAST(x AS DOUBLE)) FROM (VALUES ('infinity'), ('infinity')) AS x;
SELECT SUM(CAST(x AS DOUBLE)), AVG(CAST(x AS DOUBLE)), VARIANCE_POP(CAST(x AS DOUBLE)) FROM (VALUES ('-infinity'), ('infinity')) AS x;
SELECT SUM(CAST(x AS DOUBLE)), AVG(CAST(x AS DOUBLE)), VARIANCE_POP(CAST(x AS DOUBLE)) FROM (VALUES ('-infinity'), ('-infinity')) AS x;
SELECT SUM(CAST(x AS DECIMAL)), AVG(CAST(x AS DECIMAL)), VARIANCE_POP(CAST(x AS DECIMAL)) FROM (VALUES ('1'), ('infinity')) AS x;
SELECT SUM(CAST(x AS DECIMAL)), AVG(CAST(x AS DECIMAL)), VARIANCE_POP(CAST(x AS DECIMAL)) FROM (VALUES ('infinity'), ('1')) AS x;
SELECT SUM(CAST(x AS DECIMAL)), AVG(CAST(x AS DECIMAL)), VARIANCE_POP(CAST(x AS DECIMAL)) FROM (VALUES ('infinity'), ('infinity')) AS x;
SELECT SUM(CAST(x AS DECIMAL)), AVG(CAST(x AS DECIMAL)), VARIANCE_POP(CAST(x AS DECIMAL)) FROM (VALUES ('-infinity'), ('infinity')) AS x;
SELECT SUM(CAST(x AS DECIMAL)), AVG(CAST(x AS DECIMAL)), VARIANCE_POP(CAST(x AS DECIMAL)) FROM (VALUES ('-infinity'), ('-infinity')) AS x;
/* test accuracy with a large input offset */ SELECT AVG(CAST(x AS DOUBLE)), VARIANCE_POP(CAST(x AS DOUBLE)) FROM (VALUES (100000003), (100000004), (100000006), (100000007)) AS x;
SELECT AVG(CAST(x AS DOUBLE)), VARIANCE_POP(CAST(x AS DOUBLE)) FROM (VALUES (7000000000005), (7000000000007)) AS x;
/* SQL2003 binary aggregates */ SELECT REGR_COUNT(x, x) FROM x;
SELECT REGR_SXX(x, x) FROM x;
SELECT REGR_SYY(x, x) FROM x;
SELECT REGR_SXY(x, x) FROM x;
SELECT REGR_AVGX(x, x), REGR_AVGY(x, x) FROM x;
SELECT REGR_R2(x, x) FROM x;
SELECT REGR_SLOPE(x, x), REGR_INTERCEPT(x, x) FROM x;
SELECT COVAR_POP(x, x), COVAR_SAMP(x, x) FROM x;
SELECT CORR(x, x) FROM x;
/* check single-tuple behavior */ SELECT COVAR_POP(CAST(1 AS DOUBLE), CAST(2 AS DOUBLE)), COVAR_SAMP(CAST(3 AS DOUBLE), CAST(4 AS DOUBLE));
SELECT COVAR_POP(CAST(1 AS DOUBLE), CAST('inf' AS DOUBLE)), COVAR_SAMP(CAST(3 AS DOUBLE), CAST('inf' AS DOUBLE));
SELECT COVAR_POP(CAST(1 AS DOUBLE), CAST('nan' AS DOUBLE)), COVAR_SAMP(CAST(3 AS DOUBLE), CAST('nan' AS DOUBLE));
/* test accum and combine functions directly */ CREATE TABLE x (x DOUBLE, x DOUBLE);
INSERT INTO x VALUES (10, 150), (20, 250), (30, 350), (80, 540), (100, 200);
SELECT COUNT(*), SUM(x), REGR_SXX(x, x), SUM(x), REGR_SYY(x, x), REGR_SXY(x, x) FROM x WHERE x IN (10, 20, 30, 80);
SELECT COUNT(*), SUM(x), REGR_SXX(x, x), SUM(x), REGR_SYY(x, x), REGR_SXY(x, x) FROM x;
SELECT FLOAT8_ACCUM(CAST('{4,140,2900}' AS ARRAY<DOUBLE>), 100);
SELECT FLOAT8_REGR_ACCUM(CAST('{4,140,2900,1290,83075,15050}' AS ARRAY<DOUBLE>), 200, 100);
SELECT COUNT(*), SUM(x), REGR_SXX(x, x), SUM(x), REGR_SYY(x, x), REGR_SXY(x, x) FROM x WHERE x IN (10, 20, 30);
SELECT COUNT(*), SUM(x), REGR_SXX(x, x), SUM(x), REGR_SYY(x, x), REGR_SXY(x, x) FROM x WHERE x IN (80, 100);
SELECT FLOAT8_COMBINE(CAST('{3,60,200}' AS ARRAY<DOUBLE>), CAST('{0,0,0}' AS ARRAY<DOUBLE>));
SELECT FLOAT8_COMBINE(CAST('{0,0,0}' AS ARRAY<DOUBLE>), CAST('{2,180,200}' AS ARRAY<DOUBLE>));
SELECT FLOAT8_COMBINE(CAST('{3,60,200}' AS ARRAY<DOUBLE>), CAST('{2,180,200}' AS ARRAY<DOUBLE>));
SELECT FLOAT8_REGR_COMBINE(CAST('{3,60,200,750,20000,2000}' AS ARRAY<DOUBLE>), CAST('{0,0,0,0,0,0}' AS ARRAY<DOUBLE>));
SELECT FLOAT8_REGR_COMBINE(CAST('{0,0,0,0,0,0}' AS ARRAY<DOUBLE>), CAST('{2,180,200,740,57800,-3400}' AS ARRAY<DOUBLE>));
SELECT FLOAT8_REGR_COMBINE(CAST('{3,60,200,750,20000,2000}' AS ARRAY<DOUBLE>), CAST('{2,180,200,740,57800,-3400}' AS ARRAY<DOUBLE>));
DROP TABLE x;
/* test count, distinct */ SELECT COUNT(x) AS x FROM x;
SELECT COUNT(DISTINCT x) AS x FROM x;
SELECT x, COUNT(*), SUM(x) FROM x GROUP BY x ORDER BY x NULLS LAST;
SELECT x, COUNT(x), SUM(DISTINCT x) FROM x GROUP BY x ORDER BY x NULLS LAST;
/* user-defined aggregates */ SELECT NEWAVG(x) AS x FROM x;
SELECT NEWSUM(x) AS x FROM x;
SELECT NEWCNT(x) AS x FROM x;
SELECT NEWCNT(*) AS x FROM x;
SELECT OLDCNT(*) AS x FROM x;
SELECT SUM2(x, x) FROM x;
/* test for outer-level aggregates */ /* this should work */ SELECT x, SUM(DISTINCT x) FROM x AS x GROUP BY x HAVING EXISTS(SELECT 1 FROM x AS x WHERE SUM(DISTINCT x.x) = x.x);
/* this should fail because subquery has an agg of its own in WHERE */ SELECT x, SUM(DISTINCT x) FROM x AS x GROUP BY x HAVING EXISTS(SELECT 1 FROM x AS x WHERE SUM(DISTINCT x.x + x.x) = x.x);
/* Test handling of sublinks within outer-level aggregates. */ /* Per bug report from Daniel Grace. */ SELECT (SELECT MAX((SELECT x.x FROM x AS x WHERE x.x = x.x))) FROM x AS x;
/* Test handling of Params within aggregate arguments in hashed aggregation. */ /* Per bug report from Jeevan Chalke. */ EXPLAIN (verbose, costs off) select s1, s2, sm from generate_series(1, 3) s1,      lateral (select s2, sum(s1 + s2) sm               from generate_series(1, 3) s2 group by s2) ss order by 1, 2;
SELECT x, x, x FROM x AS x, LATERAL (SELECT x, SUM(x + x) AS x FROM x AS x GROUP BY x) AS x ORDER BY 1 NULLS LAST, 2 NULLS LAST;
EXPLAIN (verbose, costs off) select array(select sum(x+y) s             from generate_series(1,3) y group by y order by s)   from generate_series(1,3) x;
SELECT ARRAY(SELECT SUM(x + x) AS x FROM x AS x GROUP BY x ORDER BY x NULLS LAST) FROM x AS x;
/* test for bitwise integer aggregates */ CREATE TEMPORARY TABLE x (x SMALLINT, x INT, x BIGINT, x INT, x SMALLINT, x BIT(4));
/* empty case */ SELECT BIT_AND(x) AS "x", BIT_OR(x) AS "x", BIT_XOR(x) AS "x" FROM x;
COPY INTO x FROM x WITH (NULL 'null');
/* test boolean aggregates */ /* first test all possible transition and final states */ SELECT BOOLAND_STATEFUNC(NULL, NULL) /* boolean and transitions */ /* null because strict */ IS NULL AS "x", BOOLAND_STATEFUNC(TRUE, NULL) IS NULL AS "x", BOOLAND_STATEFUNC(FALSE, NULL) IS NULL AS "x", BOOLAND_STATEFUNC(NULL, TRUE) IS NULL AS "x", BOOLAND_STATEFUNC(NULL, FALSE) IS NULL AS "x", BOOLAND_STATEFUNC(TRUE, TRUE) AS "x" /* and actual computations */, NOT BOOLAND_STATEFUNC(TRUE, FALSE) AS "x", NOT BOOLAND_STATEFUNC(FALSE, TRUE) AS "x", NOT BOOLAND_STATEFUNC(FALSE, FALSE) AS "x";
SELECT BOOLOR_STATEFUNC(NULL, NULL) /* boolean or transitions */ /* null because strict */ IS NULL AS "x", BOOLOR_STATEFUNC(TRUE, NULL) IS NULL AS "x", BOOLOR_STATEFUNC(FALSE, NULL) IS NULL AS "x", BOOLOR_STATEFUNC(NULL, TRUE) IS NULL AS "x", BOOLOR_STATEFUNC(NULL, FALSE) IS NULL AS "x", BOOLOR_STATEFUNC(TRUE, TRUE) AS "x" /* actual computations */, BOOLOR_STATEFUNC(TRUE, FALSE) AS "x", BOOLOR_STATEFUNC(FALSE, TRUE) AS "x", NOT BOOLOR_STATEFUNC(FALSE, FALSE) AS "x";
CREATE TEMPORARY TABLE x (x BOOLEAN, x BOOLEAN, x BOOLEAN, x BOOLEAN);
/* empty case */ SELECT LOGICAL_AND(x) AS "x", LOGICAL_OR(x) AS "x" FROM x;
COPY INTO x FROM x WITH (NULL 'null');
SELECT EVERY(x) AS "x", EVERY(x) AS "x", EVERY(x) AS "x", EVERY(x) AS "x", EVERY(NOT x) AS "x", EVERY(NOT x) AS "x" FROM x;
SELECT LOGICAL_OR(x) AS "x", LOGICAL_OR(x) AS "x", LOGICAL_OR(x) AS "x", LOGICAL_OR(x) AS "x", LOGICAL_OR(NOT x) AS "x", LOGICAL_OR(NOT x) AS "x" FROM x;
/* Test cases that should be optimized into indexscans instead of */ /* the generic aggregate implementation. */ /* Basic cases */ EXPLAIN (costs off)   select min(unique1) from tenk1;
SELECT MIN(x) FROM x;
EXPLAIN (costs off)   select max(unique1) from tenk1;
SELECT MAX(x) FROM x;
EXPLAIN (costs off)   select max(unique1) from tenk1 where unique1 < 42;
SELECT MAX(x) FROM x WHERE x < 42;
EXPLAIN (costs off)   select max(unique1) from tenk1 where unique1 > 42;
SELECT MAX(x) FROM x WHERE x > 42;
/* the planner may choose a generic aggregate here if parallel query is */ /* enabled, since that plan will be parallel safe and the "optimized" */ /* plan, which has almost identical cost, will not be.  we want to test */ /* the optimized plan, so temporarily disable parallel query. */ BEGIN;
SET LOCAL x = 0;
EXPLAIN (costs off)   select max(unique1) from tenk1 where unique1 > 42000;
SELECT MAX(x) FROM x WHERE x > 42000;
ROLLBACK;
/* multi-column index (uses tenk1_thous_tenthous) */ EXPLAIN (costs off)   select max(tenthous) from tenk1 where thousand = 33;
SELECT MAX(x) FROM x WHERE x = 33;
EXPLAIN (costs off)   select min(tenthous) from tenk1 where thousand = 33;
SELECT MIN(x) FROM x WHERE x = 33;
/* check parameter propagation into an indexscan subquery */ EXPLAIN (costs off)   select f1, (select min(unique1) from tenk1 where unique1 > f1) AS gt     from int4_tbl;
SELECT x, (SELECT MIN(x) FROM x WHERE x > x) AS x FROM x;
/* check some cases that were handled incorrectly in 8.3.0 */ EXPLAIN (costs off)   select distinct max(unique2) from tenk1;
SELECT DISTINCT MAX(x) FROM x;
EXPLAIN (costs off)   select max(unique2) from tenk1 order by 1;
SELECT MAX(x) FROM x ORDER BY 1 NULLS LAST;
EXPLAIN (costs off)   select max(unique2) from tenk1 order by max(unique2);
SELECT MAX(x) FROM x ORDER BY MAX(x) NULLS LAST;
EXPLAIN (costs off)   select max(unique2) from tenk1 order by max(unique2)+1;
SELECT MAX(x) FROM x ORDER BY MAX(x) + 1 NULLS LAST;
EXPLAIN (costs off)   select max(unique2), generate_series(1,3) as g from tenk1 order by g desc;
SELECT MAX(x), UNNEST(GENERATE_SERIES(1, 3)) AS x FROM x ORDER BY x DESC NULLS FIRST;
/* interesting corner case: constant gets optimized into a seqscan */ EXPLAIN (costs off)   select max(100) from tenk1;
SELECT MAX(100) FROM x;
/* try it on an inheritance tree */ CREATE TABLE x (x INT);
CREATE TABLE x INHERITS (x);
CREATE TABLE x INHERITS (x);
CREATE TABLE x INHERITS (x);
CREATE INDEX x ON x(x NULLS LAST);
CREATE INDEX x ON x(x NULLS LAST);
CREATE INDEX x ON x(x DESC NULLS FIRST);
CREATE INDEX x ON x(x NULLS LAST) WHERE NOT x IS NULL;
INSERT INTO x VALUES (11), (12);
INSERT INTO x VALUES (13), (14);
INSERT INTO x VALUES (15), (16);
INSERT INTO x VALUES (17), (18);
EXPLAIN (costs off)   select min(f1), max(f1) from minmaxtest;
SELECT MIN(x), MAX(x) FROM x;
/* DISTINCT doesn't do anything useful here, but it shouldn't fail */ EXPLAIN (costs off)   select distinct min(f1), max(f1) from minmaxtest;
SELECT DISTINCT MIN(x), MAX(x) FROM x;
DROP TABLE x CASCADE;
/* DISTINCT can also trigger wrong answers with hash aggregation (bug #18465) */ BEGIN;
SET LOCAL x = off;
EXPLAIN (costs off)   select f1, (select distinct min(t1.f1) from int4_tbl t1 where t1.f1 = t0.f1)   from int4_tbl t0;
SELECT x, (SELECT DISTINCT MIN(x.x) FROM x AS x WHERE x.x = x.x) FROM x AS x;
ROLLBACK;
/* check for correct detection of nested-aggregate errors */ SELECT MAX(MIN(x)) FROM x;
SELECT (SELECT MAX(MIN(x)) FROM x) FROM x;
SELECT AVG((SELECT AVG(x.x ORDER BY (SELECT AVG(x.x) FROM x AS x) NULLS LAST) FROM x AS x)) FROM x AS x;
/* Test removal of redundant GROUP BY columns */ CREATE TEMPORARY TABLE x (x INT, x INT, x INT, x INT, PRIMARY KEY (x NULLS LAST, x NULLS LAST));
CREATE TEMPORARY TABLE x (x INT, x INT, x INT, PRIMARY KEY (x NULLS LAST, x NULLS LAST));
CREATE TEMPORARY TABLE x (x INT, x INT, x INT, PRIMARY KEY (x NULLS LAST, x NULLS LAST) DEFERRABLE);
/* Non-primary-key columns can be removed from GROUP BY */ EXPLAIN (costs off) select * from t1 group by a,b,c,d;
/* No removal can happen if the complete PK is not present in GROUP BY */ EXPLAIN (costs off) select a,c from t1 group by a,c,d;
/* Test removal across multiple relations */ EXPLAIN (costs off) select * from t1 inner join t2 on t1.a = t2.x and t1.b = t2.y group by t1.a,t1.b,t1.c,t1.d,t2.x,t2.y,t2.z;
/* Test case where t1 can be optimized but not t2 */ EXPLAIN (costs off) select t1.*,t2.x,t2.z from t1 inner join t2 on t1.a = t2.x and t1.b = t2.y group by t1.a,t1.b,t1.c,t1.d,t2.x,t2.z;
/* Cannot optimize when PK is deferrable */ EXPLAIN (costs off) select * from t3 group by a,b,c;
CREATE TEMPORARY TABLE x INHERITS (x);
/* Ensure we don't remove any columns when t1 has a child table */ EXPLAIN (costs off) select * from t1 group by a,b,c,d;
/* Okay to remove columns if we're only querying the parent. */ EXPLAIN (costs off) select * from only t1 group by a,b,c,d;
CREATE TEMPORARY TABLE x (x INT, x INT, x INT, x INT, PRIMARY KEY (x NULLS LAST, x NULLS LAST)) WITH (PARTITIONED_BY=LIST(x));
CREATE TEMPORARY TABLE x PARTITION OF x FOR VALUES IN (1);
CREATE TEMPORARY TABLE x PARTITION OF x FOR VALUES IN (2);
/* Ensure we can remove non-PK columns for partitioned tables. */ EXPLAIN (costs off) select * from p_t1 group by a,b,c,d;
CREATE UNIQUE INDEX x ON x(x NULLS LAST);
/* Ensure we don't remove any columns from the GROUP BY for a unique */ /* index on a NULLable column. */ EXPLAIN (costs off) select y,z from t2 group by y,z;
ALTER TABLE x ALTER COLUMN x SET NOT NULL /* Make the column NOT NULL and ensure we remove the redundant column */;
EXPLAIN (costs off) select y,z from t2 group by y,z;
/* When there are multiple supporting unique indexes and the GROUP BY contains */ /* columns to cover all of those, ensure we pick the index with the least */ /* number of columns so that we can remove more columns from the GROUP BY. */ EXPLAIN (costs off) select x,y,z from t2 group by x,y,z;
/* As above but try ordering the columns differently to ensure we get the */ /* same result. */ EXPLAIN (costs off) select x,y,z from t2 group by z,x,y;
/* Ensure we don't use a partial index as proof of functional dependency */ DROP INDEX x;
CREATE INDEX x ON x(x NULLS LAST) WHERE x > 0;
EXPLAIN (costs off) select y,z from t2 group by y,z;
/* A unique index defined as NULLS NOT DISTINCT does not need a supporting NOT */ /* NULL constraint on the indexed columns.  Ensure the redundant columns are */ /* removed from the GROUP BY for such a table. */ DROP INDEX x;
ALTER TABLE x ALTER COLUMN x DROP NOT NULL;
create unique index t2_z_uidx on t2(z) nulls not distinct;
EXPLAIN (costs off) select y,z from t2 group by y,z;
DROP TABLE x CASCADE;
DROP TABLE x;
DROP TABLE x;
DROP TABLE x;
/* Test GROUP BY matching of join columns that are type-coerced due to USING */ CREATE TEMPORARY TABLE x (x INT, x INT);
CREATE TEMPORARY TABLE x (x BIGINT, x OID);
SELECT x FROM x LEFT JOIN x USING (x) GROUP BY x;
SELECT x FROM x LEFT JOIN x USING (x) GROUP BY x.x;
SELECT x.x FROM x LEFT JOIN x USING (x) GROUP BY x.x;
/* only this one should fail: */ SELECT x.x FROM x LEFT JOIN x USING (x) GROUP BY x;
/* check case where we have to inject nullingrels into coerced join alias */ SELECT x, COUNT(*) FROM x AS x LEFT JOIN (x LEFT JOIN x USING (x)) ON (x = 0) GROUP BY x;
/* same, for a RelabelType coercion */ SELECT x, COUNT(*) FROM x AS x LEFT JOIN (x LEFT JOIN x USING (x)) ON (x = 0) GROUP BY x;
/* Test planner's selection of pathkeys for ORDER BY aggregates */ /* Ensure we order by four.  This suits the most aggregate functions. */ EXPLAIN (costs off) select sum(two order by two),max(four order by four), min(four order by four) from tenk1;
/* Ensure we order by two.  It's a tie between ordering by two and four but */ /* we tiebreak on the aggregate's position. */ EXPLAIN (costs off) select   sum(two order by two), max(four order by four),   min(four order by four), max(two order by two) from tenk1;
/* Similar to above, but tiebreak on ordering by four */ EXPLAIN (costs off) select   max(four order by four), sum(two order by two),   min(four order by four), max(two order by two) from tenk1;
/* Ensure this one orders by ten since there are 3 aggregates that require ten */ /* vs two that suit two and four. */ EXPLAIN (costs off) select   max(four order by four), sum(two order by two),   min(four order by four), max(two order by two),   sum(ten order by ten), min(ten order by ten), max(ten order by ten) from tenk1;
/* Try a case involving a GROUP BY clause where the GROUP BY column is also */ /* part of an aggregate's ORDER BY clause.  We want a sort order that works */ /* for the GROUP BY along with the first and the last aggregate. */ EXPLAIN (costs off) select   sum(unique1 order by ten, two), sum(unique1 order by four),   sum(unique1 order by two, four) from tenk1 group by ten;
/* Ensure that we never choose to provide presorted input to an Aggref with */ /* a volatile function in the ORDER BY / DISTINCT clause.  We want to ensure */ /* these sorts are performed individually rather than at the query level. */ EXPLAIN (costs off) select   sum(unique1 order by two), sum(unique1 order by four),   sum(unique1 order by four, two), sum(unique1 order by two, random()),   sum(unique1 order by two, random(), random() + 1) from tenk1 group by ten;
/* Ensure consecutive NULLs are properly treated as distinct from each other */ SELECT ARRAY_AGG(DISTINCT x) FROM (SELECT NULL AS x FROM x);
SET x = off /* Ensure no ordering is requested when enable_presorted_aggregate is off */;
EXPLAIN (costs off) select sum(two order by two) from tenk1;
RESET enable_presorted_aggregate;
/* Test combinations of DISTINCT and/or ORDER BY */ SELECT ARRAY_AGG(x ORDER BY x NULLS LAST) FROM (VALUES (1, 4), (2, 3), (3, 1), (4, 2)) AS x;
SELECT ARRAY_AGG(x ORDER BY x NULLS LAST) FROM (VALUES (1, 4), (2, 3), (3, 1), (4, 2)) AS x;
SELECT ARRAY_AGG(x ORDER BY x DESC NULLS FIRST) FROM (VALUES (1, 4), (2, 3), (3, 1), (4, 2)) AS x;
SELECT ARRAY_AGG(x ORDER BY x DESC NULLS FIRST) FROM (VALUES (1, 4), (2, 3), (3, 1), (4, 2)) AS x;
SELECT ARRAY_AGG(DISTINCT x) FROM (VALUES (1), (2), (1), (3), (NULL), (2)) AS x;
SELECT ARRAY_AGG(DISTINCT x ORDER BY x NULLS LAST) FROM (VALUES (1), (2), (1), (3), (NULL), (2)) AS x;
SELECT ARRAY_AGG(DISTINCT x ORDER BY x DESC NULLS FIRST) FROM (VALUES (1), (2), (1), (3), (NULL), (2)) AS x;
SELECT ARRAY_AGG(DISTINCT x ORDER BY x DESC) FROM (VALUES (1), (2), (1), (3), (NULL), (2)) AS x;
/* multi-arg aggs, strict/nonstrict, distinct/order by */ SELECT AGGFSTR(x, x, x) FROM (VALUES (1, 3, 'foo'), (0, NULL, NULL), (2, 2, 'bar'), (3, 1, 'baz')) AS x;
SELECT AGGFNS(x, x, x) FROM (VALUES (1, 3, 'foo'), (0, NULL, NULL), (2, 2, 'bar'), (3, 1, 'baz')) AS x;
SELECT AGGFSTR(DISTINCT x, x, x) FROM (VALUES (1, 3, 'foo'), (0, NULL, NULL), (2, 2, 'bar'), (3, 1, 'baz')) AS x, x AS x;
SELECT AGGFNS(DISTINCT x, x, x) FROM (VALUES (1, 3, 'foo'), (0, NULL, NULL), (2, 2, 'bar'), (3, 1, 'baz')) AS x, x AS x;
SELECT AGGFSTR(DISTINCT x, x, x ORDER BY x NULLS LAST) FROM (VALUES (1, 3, 'foo'), (0, NULL, NULL), (2, 2, 'bar'), (3, 1, 'baz')) AS x, x AS x;
SELECT AGGFNS(DISTINCT x, x, x ORDER BY x NULLS LAST) FROM (VALUES (1, 3, 'foo'), (0, NULL, NULL), (2, 2, 'bar'), (3, 1, 'baz')) AS x, x AS x;
SELECT AGGFNS(DISTINCT x, x, x ORDER BY x NULLS LAST) FROM (VALUES (1, 3, 'foo'), (0, NULL, NULL), (2, 2, 'bar'), (3, 1, 'baz')) AS x, x AS x;
/* test a more complex permutation that has previous caused issues */ SELECT GROUP_CONCAT(DISTINCT 'a', ','), SUM((SELECT SUM(1) FROM (VALUES (1)) AS x WHERE x.x = x.x)) FROM UNNEST(ARRAY(1)) AS x;
/* check node I/O via view creation and usage, also deparsing logic */ CREATE VIEW x AS SELECT AGGFNS(x, x, x) FROM (VALUES (1, 3, 'foo'), (0, NULL, NULL), (2, 2, 'bar'), (3, 1, 'baz')) AS x;
SELECT * FROM x;
SELECT PG_GET_VIEWDEF(CAST('agg_view1' AS REGCLASS));
CREATE OR REPLACE VIEW x AS SELECT AGGFNS(DISTINCT x, x, x) FROM (VALUES (1, 3, 'foo'), (0, NULL, NULL), (2, 2, 'bar'), (3, 1, 'baz')) AS x, x AS x;
SELECT * FROM x;
SELECT PG_GET_VIEWDEF(CAST('agg_view1' AS REGCLASS));
CREATE OR REPLACE VIEW x AS SELECT AGGFNS(DISTINCT x, x, x ORDER BY x NULLS LAST) FROM (VALUES (1, 3, 'foo'), (0, NULL, NULL), (2, 2, 'bar'), (3, 1, 'baz')) AS x, x AS x;
SELECT * FROM x;
SELECT PG_GET_VIEWDEF(CAST('agg_view1' AS REGCLASS));
CREATE OR REPLACE VIEW x AS SELECT AGGFNS(x, x, x ORDER BY x + 1 NULLS LAST) FROM (VALUES (1, 3, 'foo'), (0, NULL, NULL), (2, 2, 'bar'), (3, 1, 'baz')) AS x;
SELECT * FROM x;
SELECT PG_GET_VIEWDEF(CAST('agg_view1' AS REGCLASS));
CREATE OR REPLACE VIEW x AS SELECT AGGFNS(x, x, x ORDER BY x NULLS LAST) FROM (VALUES (1, 3, 'foo'), (0, NULL, NULL), (2, 2, 'bar'), (3, 1, 'baz')) AS x;
SELECT * FROM x;
SELECT PG_GET_VIEWDEF(CAST('agg_view1' AS REGCLASS));
SELECT * FROM x;
SELECT PG_GET_VIEWDEF(CAST('agg_view1' AS REGCLASS));
SELECT * FROM x;
SELECT PG_GET_VIEWDEF(CAST('agg_view1' AS REGCLASS));
DROP VIEW x;
/* incorrect DISTINCT usage errors */ SELECT AGGFNS(DISTINCT x, x, x ORDER BY x NULLS LAST) FROM (VALUES (1, 1, 'foo')) AS x, x AS x;
SELECT AGGFNS(DISTINCT x, x, x ORDER BY x NULLS LAST, x + 1 NULLS LAST) FROM (VALUES (1, 1, 'foo')) AS x, x AS x;
SELECT AGGFNS(DISTINCT x, x, x ORDER BY x NULLS LAST, x NULLS LAST, x NULLS LAST, x NULLS LAST) FROM (VALUES (1, 1, 'foo')) AS x, x AS x;
SELECT AGGFNS(DISTINCT x, x, x ORDER BY x NULLS LAST, x NULLS LAST) FROM (VALUES (1, 1, 'foo')) AS x, x AS x;
/* string_agg tests */ SELECT GROUP_CONCAT(x, ',') FROM (VALUES ('aaaa'), ('bbbb'), ('cccc')) AS x;
SELECT GROUP_CONCAT(x, ',') FROM (VALUES ('aaaa'), (NULL), ('bbbb'), ('cccc')) AS x;
SELECT GROUP_CONCAT(x, 'AB') FROM (VALUES (NULL), (NULL), ('bbbb'), ('cccc')) AS x;
SELECT GROUP_CONCAT(x, ',') FROM (VALUES (NULL), (NULL)) AS x;
/* check some implicit casting cases, as per bug #5564 */ SELECT GROUP_CONCAT(DISTINCT x, ',' ORDER BY x NULLS LAST) FROM x;
/* ok */ SELECT GROUP_CONCAT(DISTINCT CAST(x AS TEXT), ',' ORDER BY x NULLS LAST) FROM x;
/* not ok */ SELECT GROUP_CONCAT(DISTINCT x, ',' ORDER BY CAST(x AS TEXT) NULLS LAST) FROM x;
/* not ok */ SELECT GROUP_CONCAT(DISTINCT CAST(x AS TEXT), ',' ORDER BY CAST(x AS TEXT) NULLS LAST) FROM x;
/* ok */ /* string_agg, min, max bytea tests */ CREATE TABLE x (x VARBINARY);
SELECT GROUP_CONCAT(x, '') FROM x;
INSERT INTO x VALUES (DECODE('ff', 'hex'));
SELECT GROUP_CONCAT(x, '') FROM x;
INSERT INTO x VALUES (DECODE('aa', 'hex'));
SELECT GROUP_CONCAT(x, '') FROM x;
SELECT GROUP_CONCAT(x, NULL) FROM x;
SELECT GROUP_CONCAT(x, DECODE('ee', 'hex')) FROM x;
SELECT MIN(x) FROM x;
SELECT MAX(x) FROM x;
INSERT INTO x VALUES (DECODE('ffff', 'hex'));
INSERT INTO x VALUES (DECODE('aaaa', 'hex'));
SELECT MIN(x) FROM x;
SELECT MAX(x) FROM x;
DROP TABLE x;
/* Test parallel string_agg and array_agg */ CREATE TABLE x (x INT, x INT) WITH (autovacuum_enabled=off);
INSERT INTO x SELECT (CASE x % 4 WHEN 1 THEN NULL ELSE x END), x % 10 FROM x AS x;
SET x = 0;
SET x = 0;
SET x = 0;
SET x = 0;
SET x = 'escape';
SET x = 2;
/* create a view as we otherwise have to repeat this query a few times. */ CREATE VIEW x AS SELECT x, MIN(x) AS x, MAX(x) AS x, COUNT(DISTINCT x) AS x, MIN(x) AS x, MAX(x) AS x, COUNT(DISTINCT x) AS x, MIN(x) AS x, MAX(x) AS x, COUNT(DISTINCT x) AS x, MIN(x) AS x, MAX(x) AS x, COUNT(DISTINCT x) AS x FROM (SELECT x, CAST(EXPLODE(REGEXP_SPLIT_TO_ARRAY(x.x, ',')) AS INT) AS x, EXPLODE(REGEXP_SPLIT_TO_ARRAY(CAST(x.x AS TEXT), ',')) AS x, EXPLODE(x.x) AS x, EXPLODE(x.x) AS x FROM (SELECT x, GROUP_CONCAT(CAST(x AS TEXT), ',') AS x, GROUP_CONCAT(CAST(CAST(x AS TEXT) AS VARBINARY), ',') AS x, ARRAY_AGG(x) AS x, ARRAY_AGG(ARRAY(x)) AS x FROM x GROUP BY x) AS x) AS x GROUP BY x;
/* Ensure results are correct. */ SELECT * FROM x ORDER BY x NULLS LAST;
/* Ensure parallel aggregation is actually being used. */ EXPLAIN (costs off) select * from v_pagg_test order by y;
SET x = 0 /* Ensure results are the same without parallel aggregation. */;
SELECT * FROM x ORDER BY x NULLS LAST;
SET x = 2 /* Check that we don't fail on anonymous record types. */;
EXPLAIN (costs off) select array_dims(array_agg(s)) from (select * from pagg_test) s;
SELECT ARRAY_DIMS(ARRAY_AGG(x)) FROM (SELECT * FROM x) AS x;
/* Clean up */ RESET max_parallel_workers_per_gather;
RESET bytea_output;
RESET min_parallel_table_scan_size;
RESET parallel_leader_participation;
RESET parallel_tuple_cost;
RESET parallel_setup_cost;
DROP VIEW x;
DROP TABLE x;
/* FILTER tests */ SELECT MIN(x) FILTER(WHERE x > 100) FROM x;
SELECT SUM(1 / x) FILTER(WHERE x > 0) FROM x;
SELECT x, SUM(DISTINCT x) FILTER(WHERE REGEXP_LIKE(CAST(x AS TEXT), '123')) FROM x AS x GROUP BY x;
SELECT x, SUM(DISTINCT x) FILTER(WHERE x > 10) FROM x AS x GROUP BY x HAVING EXISTS(SELECT 1 FROM x AS x WHERE SUM(DISTINCT x.x) = x.x);
SELECT MAX(x COLLATE "x") FILTER(WHERE (x COLLATE "x") > '0') FROM (VALUES ('a', 'b')) AS x;
SELECT ANY_VALUE(x) FILTER(WHERE x > 2) FROM (VALUES (1), (2), (3)) AS x;
/* outer reference in FILTER (PostgreSQL extension) */ SELECT (SELECT COUNT(*) FROM (VALUES (1)) AS x) FROM (VALUES (2), (3)) AS x;
/* inner query is aggregation query */ SELECT (SELECT COUNT(*) FILTER(WHERE x <> 0) FROM (VALUES (1)) AS x) FROM (VALUES (2), (3)) AS x;
/* outer query is aggregation query */ SELECT (SELECT COUNT(x) FILTER(WHERE x <> 0) FROM (VALUES (1)) AS x) FROM (VALUES (2), (3)) AS x;
/* inner query is aggregation query */ SELECT (SELECT MAX((SELECT x.x FROM x AS x WHERE x.x = x.x)) FILTER(WHERE x.x < 10)) FROM x AS x;
/* outer query is aggregation query */ /* subquery in FILTER clause (PostgreSQL extension) */ SELECT SUM(x) FILTER(WHERE x IN (SELECT x FROM x WHERE x < 100)) FROM x;
/* check handling of bare boolean Var in FILTER */ SELECT MAX(0) FILTER(WHERE x) FROM x;
SELECT (SELECT MAX(0) FILTER(WHERE x)) FROM x;
/* check for correct detection of nested-aggregate errors in FILTER */ SELECT MAX(x) FILTER(WHERE SUM(x) > 0) FROM x;
SELECT (SELECT MAX(x) FILTER(WHERE SUM(x) > 0) FROM x) FROM x;
SELECT MAX(x) FILTER(WHERE LOGICAL_OR(x > 0)) FROM x;
SELECT (SELECT MAX(x) FILTER(WHERE LOGICAL_OR(x > 0)) FROM x) FROM x;
/* ordered-set aggregates */ SELECT x, PERCENTILE_CONT(x) WITHIN GROUP (ORDER BY CAST(x AS DOUBLE) NULLS LAST) FROM x AS x, (VALUES (CAST(0 AS DOUBLE)), (0.1), (0.25), (0.4), (0.5), (0.6), (0.75), (0.9), (1)) AS x GROUP BY x ORDER BY x NULLS LAST;
SELECT x, PERCENTILE_CONT(x ORDER BY x NULLS LAST) WITHIN GROUP (ORDER BY x NULLS LAST) /* error */ FROM x AS x, (VALUES (CAST(0 AS DOUBLE)), (0.1), (0.25), (0.4), (0.5), (0.6), (0.75), (0.9), (1)) AS x GROUP BY x ORDER BY x NULLS LAST;
SELECT x, PERCENTILE_CONT(x, x) /* error */ FROM x AS x, (VALUES (CAST(0 AS DOUBLE)), (0.1), (0.25), (0.4), (0.5), (0.6), (0.75), (0.9), (1)) AS x GROUP BY x ORDER BY x NULLS LAST;
SELECT PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY x NULLS LAST) FROM x;
SELECT PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY x NULLS LAST), SUM(x) FROM x;
SELECT PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY x NULLS LAST) FROM x;
SELECT PERCENTILE_DISC(0.5) WITHIN GROUP (ORDER BY x NULLS LAST) FROM x;
SELECT RANK(3) WITHIN GROUP (ORDER BY x NULLS LAST) FROM (VALUES (1), (1), (2), (2), (3), (3), (4)) AS x;
SELECT CUME_DIST(3) WITHIN GROUP (ORDER BY x NULLS LAST) FROM (VALUES (1), (1), (2), (2), (3), (3), (4)) AS x;
SELECT PERCENT_RANK(3) WITHIN GROUP (ORDER BY x NULLS LAST) FROM (VALUES (1), (1), (2), (2), (3), (3), (4), (5)) AS x;
SELECT DENSE_RANK(3) WITHIN GROUP (ORDER BY x NULLS LAST) FROM (VALUES (1), (1), (2), (2), (3), (3), (4)) AS x;
SELECT PERCENTILE_DISC(ARRAY(0, 0.1, 0.25, 0.5, 0.75, 0.9, 1)) WITHIN GROUP (ORDER BY x NULLS LAST) FROM x;
SELECT PERCENTILE_CONT(ARRAY(0, 0.25, 0.5, 0.75, 1)) WITHIN GROUP (ORDER BY x NULLS LAST) FROM x;
SELECT PERCENTILE_DISC(ARRAY(ARRAY(NULL, 1, 0.5), ARRAY(0.75, 0.25, NULL))) WITHIN GROUP (ORDER BY x NULLS LAST) FROM x;
SELECT PERCENTILE_CONT(ARRAY(0, 1, 0.25, 0.75, 0.5, 1, 0.3, 0.32, 0.35, 0.38, 0.4)) WITHIN GROUP (ORDER BY x NULLS LAST) FROM x AS x;
SELECT x, MODE() WITHIN GROUP (ORDER BY x NULLS LAST) FROM x GROUP BY x;
SELECT PERCENTILE_DISC(ARRAY(0.25, 0.5, 0.75)) WITHIN GROUP (ORDER BY x NULLS LAST) FROM UNNEST(CAST('{fred,jim,fred,jack,jill,fred,jill,jim,jim,sheila,jim,sheila}' AS ARRAY<TEXT>)) AS x;
/* check collation propagates up in suitable cases: */ SELECT PG_COLLATION_FOR(PERCENTILE_DISC(1) WITHIN GROUP (ORDER BY x COLLATE "x" NULLS LAST)) FROM (VALUES ('fred'), ('jim')) AS x;
/* ordered-set aggs created with CREATE AGGREGATE */ SELECT TEST_RANK(3) WITHIN GROUP (ORDER BY x NULLS LAST) FROM (VALUES (1), (1), (2), (2), (3), (3), (4)) AS x;
SELECT TEST_PERCENTILE_DISC(0.5) WITHIN GROUP (ORDER BY x NULLS LAST) FROM x;
/* ordered-set aggs can't use ungrouped vars in direct args: */ SELECT RANK(x) WITHIN GROUP (ORDER BY x NULLS LAST) FROM x AS x;
/* outer-level agg can't use a grouped arg of a lower level, either: */ SELECT ARRAY(SELECT PERCENTILE_DISC(x) WITHIN GROUP (ORDER BY x NULLS LAST) FROM (VALUES (0.3), (0.7)) AS x GROUP BY x) FROM x AS x;
/* agg in the direct args is a grouping violation, too: */ SELECT RANK(SUM(x)) WITHIN GROUP (ORDER BY x NULLS LAST) FROM x AS x;
/* hypothetical-set type unification and argument-count failures: */ SELECT RANK(3) WITHIN GROUP (ORDER BY x NULLS LAST) FROM (VALUES ('fred'), ('jim')) AS x;
SELECT RANK(3) WITHIN GROUP (ORDER BY x NULLS LAST, x NULLS LAST) FROM x;
SELECT RANK('fred') WITHIN GROUP (ORDER BY x NULLS LAST) FROM x AS x;
SELECT RANK(CAST('adam' AS TEXT) COLLATE "x") WITHIN GROUP (ORDER BY x COLLATE "x" NULLS LAST) FROM (VALUES ('fred'), ('jim')) AS x;
/* hypothetical-set type unification successes: */ SELECT RANK(CAST('adam' AS VARCHAR)) WITHIN GROUP (ORDER BY x NULLS LAST) FROM (VALUES ('fred'), ('jim')) AS x;
SELECT RANK('3') WITHIN GROUP (ORDER BY x NULLS LAST) FROM x AS x;
/* divide by zero check */ SELECT PERCENT_RANK(0) WITHIN GROUP (ORDER BY x NULLS LAST) FROM x AS x;
/* deparse and multiple features: */ CREATE VIEW x AS SELECT x, PERCENTILE_DISC(0.5) WITHIN GROUP (ORDER BY x NULLS LAST) AS x, PERCENTILE_DISC(0.5) WITHIN GROUP (ORDER BY x NULLS LAST) FILTER(WHERE x = 1) AS x, RANK(5, 'AZZZZ', 50) WITHIN GROUP (ORDER BY x NULLS LAST, x DESC NULLS FIRST, x NULLS LAST) FROM x GROUP BY x ORDER BY x NULLS LAST;
SELECT PG_GET_VIEWDEF('aggordview1');
SELECT * FROM x ORDER BY x NULLS LAST;
DROP VIEW x;
/* variadic aggregates */ SELECT LEAST_AGG(x, x) FROM x;
SELECT CLEAST_AGG(x, x) FROM x;
SELECT CLEAST_AGG(4.5, x) FROM x;
/* test aggregates with common transition functions share the same states */ BEGIN work;
create type avg_state as (total bigint, count bigint);
BEGIN raise notice 'avg_transfn called with %', n;
if state is null then 		if n is not null then 			new_state.total := n;
x.x := 1;
x AS x;
x AS x;
x.x := x.x + 1;
x AS x;
x AS x;
create aggregate my_avg(int4) (    stype = avg_state,    sfunc = avg_transfn,    finalfunc = avg_finalfn );
create aggregate my_sum(int4) (    stype = avg_state,    sfunc = avg_transfn,    finalfunc = sum_finalfn );
/* aggregate state should be shared as aggs are the same. */ SELECT MY_AVG(x), MY_AVG(x) FROM (VALUES (1), (3)) AS x;
/* aggregate state should be shared as transfn is the same for both aggs. */ SELECT MY_AVG(x), MY_SUM(x) FROM (VALUES (1), (3)) AS x;
/* same as previous one, but with DISTINCT, which requires sorting the input. */ SELECT MY_AVG(DISTINCT x), MY_SUM(DISTINCT x) FROM (VALUES (1), (3), (1)) AS x;
/* shouldn't share states due to the distinctness not matching. */ SELECT MY_AVG(DISTINCT x), MY_SUM(x) FROM (VALUES (1), (3)) AS x;
/* shouldn't share states due to the filter clause not matching. */ SELECT MY_AVG(x) FILTER(WHERE x > 1), MY_SUM(x) FROM (VALUES (1), (3)) AS x;
/* this should not share the state due to different input columns. */ SELECT MY_AVG(x), MY_SUM(x) FROM (VALUES (1, 2), (3, 4)) AS x;
/* exercise cases where OSAs share state */ SELECT PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY x NULLS LAST), PERCENTILE_DISC(0.5) WITHIN GROUP (ORDER BY x NULLS LAST) FROM (VALUES (CAST(1 AS DOUBLE)), (3), (5), (7)) AS x;
SELECT PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY x NULLS LAST), PERCENTILE_DISC(0.5) WITHIN GROUP (ORDER BY x NULLS LAST) FROM (VALUES (CAST(1 AS DOUBLE)), (3), (5), (7)) AS x;
/* these can't share state currently */ SELECT RANK(4) WITHIN GROUP (ORDER BY x NULLS LAST), DENSE_RANK(4) WITHIN GROUP (ORDER BY x NULLS LAST) FROM (VALUES (1), (3), (5), (7)) AS x;
/* test that aggs with the same sfunc and initcond share the same agg state */ create aggregate my_sum_init(int4) (    stype = avg_state,    sfunc = avg_transfn,    finalfunc = sum_finalfn,    initcond = '(10,0)' );
create aggregate my_avg_init(int4) (    stype = avg_state,    sfunc = avg_transfn,    finalfunc = avg_finalfn,    initcond = '(10,0)' );
create aggregate my_avg_init2(int4) (    stype = avg_state,    sfunc = avg_transfn,    finalfunc = avg_finalfn,    initcond = '(4,0)' );
/* state should be shared if INITCONDs are matching */ SELECT MY_SUM_INIT(x), MY_AVG_INIT(x) FROM (VALUES (1), (3)) AS x;
/* Varying INITCONDs should cause the states not to be shared. */ SELECT MY_SUM_INIT(x), MY_AVG_INIT2(x) FROM (VALUES (1), (3)) AS x;
ROLLBACK;
/* test aggregate state sharing to ensure it works if one aggregate has a */ /* finalfn and the other one has none. */ BEGIN work;
BEGIN raise notice 'sum_transfn called with %', n;
if state is null then 		if n is not null then 			new_state := n;
x AS x;
x AS x;
x AS x;
x AS x;
create aggregate my_sum(int4) (    stype = int4,    sfunc = sum_transfn );
create aggregate my_half_sum(int4) (    stype = int4,    sfunc = sum_transfn,    finalfunc = halfsum_finalfn );
/* Agg state should be shared even though my_sum has no finalfn */ SELECT MY_SUM(x), MY_HALF_SUM(x) FROM (VALUES (1), (2), (3), (4)) AS x;
ROLLBACK;
/* test that the aggregate transition logic correctly handles */ /* transition / combine functions returning NULL */ /* First test the case of a normal transition function returning NULL */ BEGIN;
x AS x;
x;
CREATE AGGREGATE balk(int4) (     SFUNC = balkifnull(int8, int4),     STYPE = int8,     PARALLEL = SAFE,     INITCOND = '0' );
SELECT BALK(x) FROM x;
ROLLBACK;
/* GROUP BY optimization by reordering GROUP BY clauses */ CREATE TABLE x AS SELECT x % 10 AS x, x % 10 AS x, 'abc' || x % 10 AS x, x AS x FROM x AS x;
CREATE INDEX x ON x(x NULLS LAST, x NULLS LAST);
ANALYZE x;
SET x = off;
SET x = off;
/* Utilize the ordering of index scan to avoid a Sort operation */ EXPLAIN (COSTS OFF) SELECT count(*) FROM btg GROUP BY y, x;
/* Engage incremental sort */ EXPLAIN (COSTS OFF) SELECT count(*) FROM btg GROUP BY z, y, w, x;
/* Utilize the ordering of subquery scan to avoid a Sort operation */ EXPLAIN (COSTS OFF) SELECT count(*) FROM (SELECT * FROM btg ORDER BY x, y, w, z) AS q1 GROUP BY w, x, z, y;
SET x = off /* Utilize the ordering of merge join to avoid a Sort operation */;
SET x = off;
EXPLAIN (COSTS OFF) SELECT count(*)   FROM btg t1 JOIN btg t2 ON t1.w = t2.w AND t1.x = t2.x AND t1.z = t2.z   GROUP BY t1.w, t1.z, t1.x;
RESET enable_nestloop;
RESET enable_hashjoin;
/* Should work with and without GROUP-BY optimization */ EXPLAIN (COSTS OFF) SELECT count(*) FROM btg GROUP BY w, x, z, y ORDER BY y, x, z, w;
/* Utilize incremental sort to make the ORDER BY rule a bit cheaper */ EXPLAIN (COSTS OFF) SELECT count(*) FROM btg GROUP BY w, x, y, z ORDER BY x*x, z;
/* Test the case where the number of incoming subtree path keys is more than */ /* the number of grouping keys. */ CREATE INDEX x ON x(x NULLS LAST, x NULLS LAST, x NULLS LAST);
EXPLAIN (VERBOSE, COSTS OFF) SELECT y, x, array_agg(distinct w)   FROM btg WHERE y < 0 GROUP BY x, y;
/* Ensure that we do not select the aggregate pathkeys instead of the grouping */ /* pathkeys */ CREATE TABLE x AS SELECT x % 10 AS x, x % 2 AS x, x % 2 AS x, 2 AS x, x % 10 AS x FROM x AS x;
ANALYZE x;
SET x = off;
SET x = off;
EXPLAIN (COSTS OFF) SELECT avg(c1.f ORDER BY c1.x, c1.y) FROM group_agg_pk c1 JOIN group_agg_pk c2 ON c1.x = c2.x GROUP BY c1.w, c1.z;
SELECT AVG(x.x ORDER BY x.x NULLS LAST, x.x NULLS LAST) FROM x AS x JOIN x AS x ON x.x = x.x GROUP BY x.x, x.x;
/* Pathkeys, built in a subtree, can be used to optimize GROUP-BY clause */ /* ordering.  Also, here we check that it doesn't depend on the initial clause */ /* order in the GROUP-BY list. */ EXPLAIN (COSTS OFF) SELECT c1.y,c1.x FROM group_agg_pk c1   JOIN group_agg_pk c2   ON c1.x = c2.x GROUP BY c1.y,c1.x,c2.x;
EXPLAIN (COSTS OFF) SELECT c1.y,c1.x FROM group_agg_pk c1   JOIN group_agg_pk c2   ON c1.x = c2.x GROUP BY c1.y,c2.x,c1.x;
RESET enable_nestloop;
RESET enable_hashjoin;
DROP TABLE x;
/* Test the case where the ordering of the scan matches the ordering within the */ /* aggregate but cannot be found in the group-by list */ CREATE TABLE x (x INT PRIMARY KEY, x INT);
CREATE UNIQUE INDEX x ON x(x NULLS LAST);
INSERT INTO x SELECT x, x FROM x AS x;
ANALYZE x;
EXPLAIN (COSTS OFF) SELECT array_agg(c1 ORDER BY c2),c2 FROM agg_sort_order WHERE c2 < 100 GROUP BY c1 ORDER BY 2;
DROP TABLE x CASCADE;
DROP TABLE x;
RESET enable_hashagg;
RESET enable_seqscan;
/* Secondly test the case of a parallel aggregate combiner function */ /* returning NULL. For that use normal transition function, but a */ /* combiner function returning NULL. */ BEGIN;
x AS x;
x;
CREATE AGGREGATE balk(int4) (     SFUNC = int4_sum(int8, int4),     STYPE = int8,     COMBINEFUNC = balkifnull(int8, int8),     PARALLEL = SAFE,     INITCOND = '0' );
ALTER TABLE x SET x = 4 /* force use of parallelism */;
SET LOCAL x = 0;
SET LOCAL x = 4;
EXPLAIN (COSTS OFF) SELECT balk(hundred) FROM tenk1;
SELECT BALK(x) FROM x;
ROLLBACK;
/* test multiple usage of an aggregate whose finalfn returns a R/W datum */ BEGIN;
COMMIT;
BEGIN -- assignment is essential for this test, it expands the array to R/W     res := array_fill(x[1], ARRAY[4]);
x AS x;
COMMIT;
CREATE AGGREGATE rwagg(anyarray) (     STYPE = anyarray,     SFUNC = rwagg_sfunc,     FINALFUNC = rwagg_finalfunc );
x AS x;
COMMIT;
SELECT EATARRAY(RWAGG(ARRAY(CAST(1.0 AS FLOAT)))), EATARRAY(RWAGG(ARRAY(CAST(1.0 AS FLOAT))));
ROLLBACK;
/* test coverage for aggregate combine/serial/deserial functions */ BEGIN;
SET x = 0;
SET x = 0;
SET x = 0;
SET x = 4;
SET x = off;
SET x = off;
/* variance(int4) covers numeric_poly_combine */ /* sum(int8) covers int8_avg_combine */ /* regr_count(float8, float8) covers int8inc_float8_float8 and aggregates with > 1 arg */ EXPLAIN (COSTS OFF, VERBOSE) SELECT variance(unique1::int4), sum(unique1::int8), regr_count(unique1::float8, unique1::float8) FROM (SELECT * FROM tenk1       UNION ALL SELECT * FROM tenk1       UNION ALL SELECT * FROM tenk1       UNION ALL SELECT * FROM tenk1) u;
SELECT VARIANCE(CAST(x AS INT)), SUM(CAST(x AS BIGINT)), REGR_COUNT(CAST(x AS DOUBLE), CAST(x AS DOUBLE)) FROM (SELECT * FROM x UNION ALL SELECT * FROM x UNION ALL SELECT * FROM x UNION ALL SELECT * FROM x) AS x;
/* variance(int8) covers numeric_combine */ /* avg(numeric) covers numeric_avg_combine */ EXPLAIN (COSTS OFF, VERBOSE) SELECT variance(unique1::int8), avg(unique1::numeric) FROM (SELECT * FROM tenk1       UNION ALL SELECT * FROM tenk1       UNION ALL SELECT * FROM tenk1       UNION ALL SELECT * FROM tenk1) u;
SELECT VARIANCE(CAST(x AS BIGINT)), AVG(CAST(x AS DECIMAL)) FROM (SELECT * FROM x UNION ALL SELECT * FROM x UNION ALL SELECT * FROM x UNION ALL SELECT * FROM x) AS x;
ROLLBACK;
/* test coverage for dense_rank */ SELECT DENSE_RANK(x) WITHIN GROUP (ORDER BY x NULLS LAST) FROM (VALUES (1), (1), (2), (2), (3), (3)) AS x GROUP BY (x) ORDER BY 1 NULLS LAST;
/* Ensure that the STRICT checks for aggregates does not take NULLness */ /* of ORDER BY columns into account. See bug report around */ /* 2a505161-2727-2473-7c46-591ed108ac52@email.cz */ SELECT MIN(x ORDER BY x NULLS LAST) FROM (VALUES (1, NULL)) AS x;
SELECT MIN(x ORDER BY x NULLS LAST) FROM (VALUES (1, 2)) AS x;
/* check collation-sensitive matching between grouping expressions */ SELECT x || 'a', CASE x || 'a' WHEN 'aa' THEN 1 ELSE 0 END, COUNT(*) FROM UNNEST(ARRAY('a', 'b')) AS x GROUP BY x || 'a' ORDER BY 1 NULLS LAST;
SELECT x || 'a', CASE WHEN x || 'a' = 'aa' THEN 1 ELSE 0 END, COUNT(*) FROM UNNEST(ARRAY('a', 'b')) AS x GROUP BY x || 'a' ORDER BY 1 NULLS LAST;
SET x = off /* Make sure that generation of HashAggregate for uniqification purposes */ /* does not lead to array overflow due to unexpected duplicate hash keys */ /* see CAFeeJoKKu0u+A_A9R9316djW-YW3-+Gtgvy3ju655qRHR3jtdA@mail.gmail.com */;
EXPLAIN (costs off)   select 1 from tenk1    where (hundred, thousand) in (select twothousand, twothousand from onek);
RESET enable_memoize;
SET x = FALSE /* Hash Aggregation Spill tests */;
SET x = '64kB';
SELECT x, COUNT(*), SUM(x) FROM x GROUP BY x HAVING SUM(x) > 4975 ORDER BY SUM(x) NULLS LAST;
SET x = default;
SET x = default;
SET x = '64kB' /* Compare results between plans using sorting and plans using hash */ /* aggregation. Force spilling in both cases by setting work_mem low. */;
CREATE TABLE x AS SELECT x FROM x AS x;
ANALYZE x;
CREATE TABLE x AS SELECT x FROM x AS x;
ANALYZE x;
SET x = FALSE /* Produce results with sorting. */;
SET x = 0;
EXPLAIN (costs off) select g%10000 as c1, sum(g::numeric) as c2, count(*) as c3   from agg_data_20k group by g%10000;
CREATE TABLE x AS SELECT x % 10000 AS x, SUM(CAST(x AS DECIMAL)) AS x, COUNT(*) AS x FROM x GROUP BY x % 10000;
CREATE TABLE x AS SELECT * FROM (VALUES (100), (300), (500)) AS x, LATERAL (SELECT CAST((x / 2) AS DECIMAL) AS x, ARRAY_AGG(CAST(x AS DECIMAL)) AS x, COUNT(*) AS x FROM x WHERE x < x.x GROUP BY x / 2) AS x;
SET x = default;
CREATE TABLE x AS SELECT CAST((x / 2) AS DECIMAL) AS x, SUM(CAST(7 AS INT)) AS x, COUNT(*) AS x FROM x GROUP BY x / 2;
CREATE TABLE x AS SELECT CAST((x / 2) AS DECIMAL) AS x, ARRAY_AGG(CAST(x AS DECIMAL)) AS x, COUNT(*) AS x FROM x GROUP BY x / 2;
SET x = TRUE /* Produce results with hash aggregation */;
SET x = FALSE;
SET x = 0;
EXPLAIN (costs off) select g%10000 as c1, sum(g::numeric) as c2, count(*) as c3   from agg_data_20k group by g%10000;
CREATE TABLE x AS SELECT x % 10000 AS x, SUM(CAST(x AS DECIMAL)) AS x, COUNT(*) AS x FROM x GROUP BY x % 10000;
CREATE TABLE x AS SELECT * FROM (VALUES (100), (300), (500)) AS x, LATERAL (SELECT CAST((x / 2) AS DECIMAL) AS x, ARRAY_AGG(CAST(x AS DECIMAL)) AS x, COUNT(*) AS x FROM x WHERE x < x.x GROUP BY x / 2) AS x;
SET x = default;
CREATE TABLE x AS SELECT CAST((x / 2) AS DECIMAL) AS x, SUM(CAST(7 AS INT)) AS x, COUNT(*) AS x FROM x GROUP BY x / 2;
CREATE TABLE x AS SELECT CAST((x / 2) AS DECIMAL) AS x, ARRAY_AGG(CAST(x AS DECIMAL)) AS x, COUNT(*) AS x FROM x GROUP BY x / 2;
SET x = TRUE;
SET x = default;
(SELECT * FROM x EXCEPT SELECT * FROM x) /* Compare group aggregation results to hash aggregation results */ UNION ALL (SELECT * FROM x EXCEPT SELECT * FROM x);
(SELECT * FROM x EXCEPT SELECT * FROM x) UNION ALL (SELECT * FROM x EXCEPT SELECT * FROM x);
(SELECT * FROM x EXCEPT SELECT * FROM x) UNION ALL (SELECT * FROM x EXCEPT SELECT * FROM x);
(SELECT * FROM x EXCEPT SELECT * FROM x) UNION ALL (SELECT * FROM x EXCEPT SELECT * FROM x);
DROP TABLE x;
DROP TABLE x;
DROP TABLE x;
DROP TABLE x;
DROP TABLE x;
DROP TABLE x;
DROP TABLE x;
DROP TABLE x;
SET x = 'warning' /* Clean up in case a prior regression run failed */;
DROP ROLE IF EXISTS regress_alter_generic_user1;
DROP ROLE IF EXISTS regress_alter_generic_user2;
DROP ROLE IF EXISTS regress_alter_generic_user3;
RESET client_min_messages;
CREATE USER regress_alter_generic_user3;
CREATE USER regress_alter_generic_user2;
CREATE USER regress_alter_generic_user1 IN ROLE regress_alter_generic_user3;
CREATE SCHEMA x.x;
CREATE SCHEMA x.x;
GRANT ALL ON SCHEMA alt_nsp1, alt_nsp2 TO public;
SET search_path = alt_nsp1, public;
/* Function and Aggregate */ SET SESSION AUTHORIZATION regress_alter_generic_user1;
CREATE FUNCTION x(x) RETURNS INT LANGUAGE sql AS 'SELECT $1 + 1';
CREATE FUNCTION x(x) RETURNS INT LANGUAGE sql AS 'SELECT $1 - 1';
CREATE AGGREGATE alt_agg1 (   sfunc1 = int4pl, basetype = int4, stype1 = int4, initcond = 0 );
CREATE AGGREGATE alt_agg2 (   sfunc1 = int4mi, basetype = int4, stype1 = int4, initcond = 0 );
ALTER AGGREGATE alt_func1(int) RENAME TO alt_func3;
/* failed (not aggregate) */ ALTER AGGREGATE alt_func1(int) OWNER TO regress_alter_generic_user3;
/* failed (not aggregate) */ ALTER AGGREGATE alt_func1(int) SET SCHEMA alt_nsp2;
/* failed (not aggregate) */ ALTER FUNCTION alt_func1(int) RENAME TO alt_func2;
/* failed (name conflict) */ ALTER FUNCTION alt_func1(int) RENAME TO alt_func3;
/* OK */ ALTER FUNCTION alt_func2(int) OWNER TO regress_alter_generic_user2;
/* failed (no role membership) */ ALTER FUNCTION alt_func2(int) OWNER TO regress_alter_generic_user3;
/* OK */ ALTER FUNCTION alt_func2(int) SET SCHEMA alt_nsp1;
/* OK, already there */ ALTER FUNCTION alt_func2(int) SET SCHEMA alt_nsp2;
/* OK */ ALTER AGGREGATE alt_agg1(int) RENAME TO alt_agg2;
/* failed (name conflict) */ ALTER AGGREGATE alt_agg1(int) RENAME TO alt_agg3;
/* OK */ ALTER AGGREGATE alt_agg2(int) OWNER TO regress_alter_generic_user2;
/* failed (no role membership) */ ALTER AGGREGATE alt_agg2(int) OWNER TO regress_alter_generic_user3;
/* OK */ ALTER AGGREGATE alt_agg2(int) SET SCHEMA alt_nsp2;
/* OK */ SET SESSION AUTHORIZATION regress_alter_generic_user2;
CREATE FUNCTION x(x) RETURNS INT LANGUAGE sql AS 'SELECT $1 + 2';
CREATE FUNCTION x(x) RETURNS INT LANGUAGE sql AS 'SELECT $1 - 2';
CREATE AGGREGATE alt_agg1 (   sfunc1 = int4pl, basetype = int4, stype1 = int4, initcond = 100 );
CREATE AGGREGATE alt_agg2 (   sfunc1 = int4mi, basetype = int4, stype1 = int4, initcond = -100 );
ALTER FUNCTION alt_func3(int) RENAME TO alt_func4;
/* failed (not owner) */ ALTER FUNCTION alt_func1(int) RENAME TO alt_func4;
/* OK */ ALTER FUNCTION alt_func3(int) OWNER TO regress_alter_generic_user2;
/* failed (not owner) */ ALTER FUNCTION alt_func2(int) OWNER TO regress_alter_generic_user3;
/* failed (no role membership) */ ALTER FUNCTION alt_func3(int) SET SCHEMA alt_nsp2;
/* failed (not owner) */ ALTER FUNCTION alt_func2(int) SET SCHEMA alt_nsp2;
/* failed (name conflicts) */ ALTER AGGREGATE alt_agg3(int) RENAME TO alt_agg4;
/* failed (not owner) */ ALTER AGGREGATE alt_agg1(int) RENAME TO alt_agg4;
/* OK */ ALTER AGGREGATE alt_agg3(int) OWNER TO regress_alter_generic_user2;
/* failed (not owner) */ ALTER AGGREGATE alt_agg2(int) OWNER TO regress_alter_generic_user3;
/* failed (no role membership) */ ALTER AGGREGATE alt_agg3(int) SET SCHEMA alt_nsp2;
/* failed (not owner) */ ALTER AGGREGATE alt_agg2(int) SET SCHEMA alt_nsp2;
/* failed (name conflict) */ RESET SESSION AUTHORIZATION;
SELECT x.x, x, CAST(x AS REGTYPE), x, x.x FROM x AS x, x AS x, x AS x WHERE x.x = x.x AND x.x = x.x AND x.x IN ('alt_nsp1', 'alt_nsp2') ORDER BY x NULLS LAST, x NULLS LAST;
/* We would test collations here, but it's not possible because the error */ /* messages tend to be nonportable. */ /* Conversion */ SET SESSION AUTHORIZATION regress_alter_generic_user1;
CREATE CONVERSION alt_conv1 FOR 'LATIN1' TO 'UTF8' FROM iso8859_1_to_utf8;
CREATE CONVERSION alt_conv2 FOR 'LATIN1' TO 'UTF8' FROM iso8859_1_to_utf8;
ALTER CONVERSION alt_conv1 RENAME TO alt_conv2;
/* failed (name conflict) */ ALTER CONVERSION alt_conv1 RENAME TO alt_conv3;
/* OK */ ALTER CONVERSION alt_conv2 OWNER TO regress_alter_generic_user2;
/* failed (no role membership) */ ALTER CONVERSION alt_conv2 OWNER TO regress_alter_generic_user3;
/* OK */ ALTER CONVERSION alt_conv2 SET SCHEMA alt_nsp2;
/* OK */ SET SESSION AUTHORIZATION regress_alter_generic_user2;
CREATE CONVERSION alt_conv1 FOR 'LATIN1' TO 'UTF8' FROM iso8859_1_to_utf8;
CREATE CONVERSION alt_conv2 FOR 'LATIN1' TO 'UTF8' FROM iso8859_1_to_utf8;
ALTER CONVERSION alt_conv3 RENAME TO alt_conv4;
/* failed (not owner) */ ALTER CONVERSION alt_conv1 RENAME TO alt_conv4;
/* OK */ ALTER CONVERSION alt_conv3 OWNER TO regress_alter_generic_user2;
/* failed (not owner) */ ALTER CONVERSION alt_conv2 OWNER TO regress_alter_generic_user3;
/* failed (no role membership) */ ALTER CONVERSION alt_conv3 SET SCHEMA alt_nsp2;
/* failed (not owner) */ ALTER CONVERSION alt_conv2 SET SCHEMA alt_nsp2;
/* failed (name conflict) */ RESET SESSION AUTHORIZATION;
SELECT x.x, x.x, x.x FROM x AS x, x AS x, x AS x WHERE x.x = x.x AND x.x = x.x AND x.x IN ('alt_nsp1', 'alt_nsp2') ORDER BY x NULLS LAST, x NULLS LAST;
/* Foreign Data Wrapper and Foreign Server */ CREATE FOREIGN DATA WRAPPER alt_fdw1;
CREATE FOREIGN DATA WRAPPER alt_fdw2;
CREATE SERVER alt_fserv1 FOREIGN DATA WRAPPER alt_fdw1;
CREATE SERVER alt_fserv2 FOREIGN DATA WRAPPER alt_fdw2;
ALTER FOREIGN DATA WRAPPER alt_fdw1 RENAME TO alt_fdw2;
/* failed (name conflict) */ ALTER FOREIGN DATA WRAPPER alt_fdw1 RENAME TO alt_fdw3;
/* OK */ ALTER SERVER alt_fserv1 RENAME TO alt_fserv2;
/* failed (name conflict) */ ALTER SERVER alt_fserv1 RENAME TO alt_fserv3;
/* OK */ SELECT x FROM x WHERE x LIKE 'alt_fdw%';
SELECT x FROM x WHERE x LIKE 'alt_fserv%';
/* Procedural Language */ CREATE LANGUAGE alt_lang1 HANDLER plpgsql_call_handler;
CREATE LANGUAGE alt_lang2 HANDLER plpgsql_call_handler;
ALTER LANGUAGE alt_lang1 OWNER TO regress_alter_generic_user1;
/* OK */ ALTER LANGUAGE alt_lang2 OWNER TO regress_alter_generic_user2;
/* OK */ SET SESSION AUTHORIZATION regress_alter_generic_user1;
ALTER LANGUAGE alt_lang1 RENAME TO alt_lang2;
/* failed (name conflict) */ ALTER LANGUAGE alt_lang2 RENAME TO alt_lang3;
/* failed (not owner) */ ALTER LANGUAGE alt_lang1 RENAME TO alt_lang3;
/* OK */ ALTER LANGUAGE alt_lang2 OWNER TO regress_alter_generic_user3;
/* failed (not owner) */ ALTER LANGUAGE alt_lang3 OWNER TO regress_alter_generic_user2;
/* failed (no role membership) */ ALTER LANGUAGE alt_lang3 OWNER TO regress_alter_generic_user3;
/* OK */ RESET SESSION AUTHORIZATION;
SELECT x, x.x FROM x AS x, x AS x WHERE x.x = x.x AND x.x LIKE 'alt_lang%' ORDER BY x NULLS LAST;
/* Operator */ SET SESSION AUTHORIZATION regress_alter_generic_user1;
CREATE OPERATOR @-@ ( leftarg = int4, rightarg = int4, procedure = int4mi );
CREATE OPERATOR @+@ ( leftarg = int4, rightarg = int4, procedure = int4pl );
ALTER OPERATOR @+@(int4, int4) OWNER TO regress_alter_generic_user2;
/* failed (no role membership) */ ALTER OPERATOR @+@(int4, int4) OWNER TO regress_alter_generic_user3;
/* OK */ ALTER OPERATOR @-@(int4, int4) SET SCHEMA alt_nsp2;
/* OK */ SET SESSION AUTHORIZATION regress_alter_generic_user2;
CREATE OPERATOR @-@ ( leftarg = int4, rightarg = int4, procedure = int4mi );
ALTER OPERATOR @+@(int4, int4) OWNER TO regress_alter_generic_user2;
/* failed (not owner) */ ALTER OPERATOR @-@(int4, int4) OWNER TO regress_alter_generic_user3;
/* failed (no role membership) */ ALTER OPERATOR @+@(int4, int4) SET SCHEMA alt_nsp2;
/* failed (name conflict) */ RESET SESSION AUTHORIZATION;
SELECT x.x, x, x.x, CAST(x AS REGTYPE), CAST(x AS REGTYPE), CAST(x AS REGPROC) FROM x AS x, x AS x, x AS x WHERE x.x = x.x AND x.x = x.x AND x.x IN ('alt_nsp1', 'alt_nsp2') ORDER BY x NULLS LAST, x NULLS LAST;
/* OpFamily and OpClass */ CREATE OPERATOR FAMILY alt_opf1 USING hash;
CREATE OPERATOR FAMILY alt_opf2 USING hash;
ALTER OPERATOR FAMILY alt_opf1 USING hash OWNER TO regress_alter_generic_user1;
ALTER OPERATOR FAMILY alt_opf2 USING hash OWNER TO regress_alter_generic_user1;
CREATE OPERATOR CLASS alt_opc1 FOR TYPE uuid USING hash AS STORAGE uuid;
CREATE OPERATOR CLASS alt_opc2 FOR TYPE uuid USING hash AS STORAGE uuid;
ALTER OPERATOR CLASS alt_opc1 USING hash OWNER TO regress_alter_generic_user1;
ALTER OPERATOR CLASS alt_opc2 USING hash OWNER TO regress_alter_generic_user1;
SET SESSION AUTHORIZATION regress_alter_generic_user1;
ALTER OPERATOR FAMILY alt_opf1 USING hash RENAME TO alt_opf2;
/* failed (name conflict) */ ALTER OPERATOR FAMILY alt_opf1 USING hash RENAME TO alt_opf3;
/* OK */ ALTER OPERATOR FAMILY alt_opf2 USING hash OWNER TO regress_alter_generic_user2;
/* failed (no role membership) */ ALTER OPERATOR FAMILY alt_opf2 USING hash OWNER TO regress_alter_generic_user3;
/* OK */ ALTER OPERATOR FAMILY alt_opf2 USING hash SET SCHEMA alt_nsp2;
/* OK */ ALTER OPERATOR CLASS alt_opc1 USING hash RENAME TO alt_opc2;
/* failed (name conflict) */ ALTER OPERATOR CLASS alt_opc1 USING hash RENAME TO alt_opc3;
/* OK */ ALTER OPERATOR CLASS alt_opc2 USING hash OWNER TO regress_alter_generic_user2;
/* failed (no role membership) */ ALTER OPERATOR CLASS alt_opc2 USING hash OWNER TO regress_alter_generic_user3;
/* OK */ ALTER OPERATOR CLASS alt_opc2 USING hash SET SCHEMA alt_nsp2;
/* OK */ RESET SESSION AUTHORIZATION;
CREATE OPERATOR FAMILY alt_opf1 USING hash;
CREATE OPERATOR FAMILY alt_opf2 USING hash;
ALTER OPERATOR FAMILY alt_opf1 USING hash OWNER TO regress_alter_generic_user2;
ALTER OPERATOR FAMILY alt_opf2 USING hash OWNER TO regress_alter_generic_user2;
CREATE OPERATOR CLASS alt_opc1 FOR TYPE macaddr USING hash AS STORAGE macaddr;
CREATE OPERATOR CLASS alt_opc2 FOR TYPE macaddr USING hash AS STORAGE macaddr;
ALTER OPERATOR CLASS alt_opc1 USING hash OWNER TO regress_alter_generic_user2;
ALTER OPERATOR CLASS alt_opc2 USING hash OWNER TO regress_alter_generic_user2;
SET SESSION AUTHORIZATION regress_alter_generic_user2;
ALTER OPERATOR FAMILY alt_opf3 USING hash RENAME TO alt_opf4;
/* failed (not owner) */ ALTER OPERATOR FAMILY alt_opf1 USING hash RENAME TO alt_opf4;
/* OK */ ALTER OPERATOR FAMILY alt_opf3 USING hash OWNER TO regress_alter_generic_user2;
/* failed (not owner) */ ALTER OPERATOR FAMILY alt_opf2 USING hash OWNER TO regress_alter_generic_user3;
/* failed (no role membership) */ ALTER OPERATOR FAMILY alt_opf3 USING hash SET SCHEMA alt_nsp2;
/* failed (not owner) */ ALTER OPERATOR FAMILY alt_opf2 USING hash SET SCHEMA alt_nsp2;
/* failed (name conflict) */ ALTER OPERATOR CLASS alt_opc3 USING hash RENAME TO alt_opc4;
/* failed (not owner) */ ALTER OPERATOR CLASS alt_opc1 USING hash RENAME TO alt_opc4;
/* OK */ ALTER OPERATOR CLASS alt_opc3 USING hash OWNER TO regress_alter_generic_user2;
/* failed (not owner) */ ALTER OPERATOR CLASS alt_opc2 USING hash OWNER TO regress_alter_generic_user3;
/* failed (no role membership) */ ALTER OPERATOR CLASS alt_opc3 USING hash SET SCHEMA alt_nsp2;
/* failed (not owner) */ ALTER OPERATOR CLASS alt_opc2 USING hash SET SCHEMA alt_nsp2;
/* failed (name conflict) */ RESET SESSION AUTHORIZATION;
SELECT x, x, x, x FROM x AS x, x AS x, x AS x, x AS x WHERE x.x = x.x AND x.x = x.x AND x.x = x.x AND x.x IN ('alt_nsp1', 'alt_nsp2') AND NOT x LIKE 'alt_opc%' ORDER BY x NULLS LAST, x NULLS LAST;
SELECT x, x, x, x FROM x AS x, x AS x, x AS x, x AS x WHERE x.x = x.x AND x.x = x.x AND x.x = x.x AND x.x IN ('alt_nsp1', 'alt_nsp2') ORDER BY x NULLS LAST, x NULLS LAST;
BEGIN /* ALTER OPERATOR FAMILY ... ADD/DROP */ /* Should work. Textbook case of CREATE / ALTER ADD / ALTER DROP / DROP */ /* ALTER OPERATOR FAMILY ... ADD/DROP */ /* Should work. Textbook case of CREATE / ALTER ADD / ALTER DROP / DROP */;
CREATE OPERATOR FAMILY alt_opf4 USING btree;
ALTER OPERATOR FAMILY alt_opf4 USING btree ADD   -- int4 vs int2   OPERATOR 1 < (int4, int2) ,   OPERATOR 2 <= (int4, int2) ,   OPERATOR 3 = (int4, int2) ,   OPERATOR 4 >= (int4, int2) ,   OPERATOR 5 > (int4, int2) ,   FUNCTION 1 btint42cmp(int4, int2);
ALTER OPERATOR FAMILY alt_opf4 USING btree DROP   -- int4 vs int2   OPERATOR 1 (int4, int2) ,   OPERATOR 2 (int4, int2) ,   OPERATOR 3 (int4, int2) ,   OPERATOR 4 (int4, int2) ,   OPERATOR 5 (int4, int2) ,   FUNCTION 1 (int4, int2);
DROP OPERATOR FAMILY alt_opf4 USING btree;
ROLLBACK;
/* Should fail. Invalid values for ALTER OPERATOR FAMILY .. ADD / DROP */ CREATE OPERATOR FAMILY alt_opf4 USING btree;
ALTER OPERATOR FAMILY alt_opf4 USING invalid_index_method ADD  OPERATOR 1 < (int4, int2);
/* invalid indexing_method */ ALTER OPERATOR FAMILY alt_opf4 USING btree ADD OPERATOR 6 < (int4, int2);
/* operator number should be between 1 and 5 */ ALTER OPERATOR FAMILY alt_opf4 USING btree ADD OPERATOR 0 < (int4, int2);
/* operator number should be between 1 and 5 */ ALTER OPERATOR FAMILY alt_opf4 USING btree ADD OPERATOR 1 <;
/* operator without argument types */ ALTER OPERATOR FAMILY alt_opf4 USING btree ADD FUNCTION 0 btint42cmp(int4, int2);
/* invalid options parsing function */ ALTER OPERATOR FAMILY alt_opf4 USING btree ADD FUNCTION 6 btint42cmp(int4, int2);
/* function number should be between 1 and 5 */ ALTER OPERATOR FAMILY alt_opf4 USING btree ADD STORAGE invalid_storage;
/* Ensure STORAGE is not a part of ALTER OPERATOR FAMILY */ DROP OPERATOR FAMILY alt_opf4 USING btree;
BEGIN /* Should fail. Need to be SUPERUSER to do ALTER OPERATOR FAMILY .. ADD / DROP */ /* Should fail. Need to be SUPERUSER to do ALTER OPERATOR FAMILY .. ADD / DROP */;
CREATE ROLE regress_alter_generic_user5 NOSUPERUSER;
CREATE OPERATOR FAMILY alt_opf5 USING btree;
SET ROLE regress_alter_generic_user5;
ALTER OPERATOR FAMILY alt_opf5 USING btree ADD OPERATOR 1 < (int4, int2), FUNCTION 1 btint42cmp(int4, int2);
RESET ROLE;
DROP OPERATOR FAMILY alt_opf5 USING btree;
ROLLBACK;
BEGIN /* Should fail. Need rights to namespace for ALTER OPERATOR FAMILY .. ADD / DROP */ /* Should fail. Need rights to namespace for ALTER OPERATOR FAMILY .. ADD / DROP */;
CREATE ROLE regress_alter_generic_user6;
CREATE SCHEMA x.x;
REVOKE ALL ON SCHEMA alt_nsp6 FROM regress_alter_generic_user6;
CREATE OPERATOR FAMILY alt_nsp6.alt_opf6 USING btree;
SET ROLE regress_alter_generic_user6;
ALTER OPERATOR FAMILY alt_nsp6.alt_opf6 USING btree ADD OPERATOR 1 < (int4, int2);
ROLLBACK;
/* Should fail. Only two arguments required for ALTER OPERATOR FAMILY ... DROP OPERATOR */ CREATE OPERATOR FAMILY alt_opf7 USING btree;
ALTER OPERATOR FAMILY alt_opf7 USING btree ADD OPERATOR 1 < (int4, int2);
ALTER OPERATOR FAMILY alt_opf7 USING btree DROP OPERATOR 1 (int4, int2, int8);
DROP OPERATOR FAMILY alt_opf7 USING btree;
/* Should work. During ALTER OPERATOR FAMILY ... DROP OPERATOR */ /* when left type is the same as right type, a DROP with only one argument type should work */ CREATE OPERATOR FAMILY alt_opf8 USING btree;
ALTER OPERATOR FAMILY alt_opf8 USING btree ADD OPERATOR 1 < (int4, int4);
DROP OPERATOR FAMILY alt_opf8 USING btree;
/* Should work. Textbook case of ALTER OPERATOR FAMILY ... ADD OPERATOR with FOR ORDER BY */ CREATE OPERATOR FAMILY alt_opf9 USING gist;
ALTER OPERATOR FAMILY alt_opf9 USING gist ADD OPERATOR 1 < (int4, int4) FOR ORDER BY float_ops;
DROP OPERATOR FAMILY alt_opf9 USING gist;
/* Should fail. Ensure correct ordering methods in ALTER OPERATOR FAMILY ... ADD OPERATOR .. FOR ORDER BY */ CREATE OPERATOR FAMILY alt_opf10 USING btree;
ALTER OPERATOR FAMILY alt_opf10 USING btree ADD OPERATOR 1 < (int4, int4) FOR ORDER BY float_ops;
DROP OPERATOR FAMILY alt_opf10 USING btree;
/* Should work. Textbook case of ALTER OPERATOR FAMILY ... ADD OPERATOR with FOR ORDER BY */ CREATE OPERATOR FAMILY alt_opf11 USING gist;
ALTER OPERATOR FAMILY alt_opf11 USING gist ADD OPERATOR 1 < (int4, int4) FOR ORDER BY float_ops;
ALTER OPERATOR FAMILY alt_opf11 USING gist DROP OPERATOR 1 (int4, int4);
DROP OPERATOR FAMILY alt_opf11 USING gist;
BEGIN /* Should fail. btree comparison functions should return INTEGER in ALTER OPERATOR FAMILY ... ADD FUNCTION */ /* Should fail. btree comparison functions should return INTEGER in ALTER OPERATOR FAMILY ... ADD FUNCTION */;
CREATE OPERATOR FAMILY alt_opf12 USING btree;
ALTER OPERATOR FAMILY alt_opf12 USING btree ADD FUNCTION 1 fn_opf12(int4, int2);
DROP OPERATOR FAMILY alt_opf12 USING btree;
ROLLBACK;
BEGIN /* Should fail. hash comparison functions should return INTEGER in ALTER OPERATOR FAMILY ... ADD FUNCTION */ /* Should fail. hash comparison functions should return INTEGER in ALTER OPERATOR FAMILY ... ADD FUNCTION */;
CREATE OPERATOR FAMILY alt_opf13 USING hash;
ALTER OPERATOR FAMILY alt_opf13 USING hash ADD FUNCTION 1 fn_opf13(int4);
DROP OPERATOR FAMILY alt_opf13 USING hash;
ROLLBACK;
BEGIN /* Should fail. btree comparison functions should have two arguments in ALTER OPERATOR FAMILY ... ADD FUNCTION */ /* Should fail. btree comparison functions should have two arguments in ALTER OPERATOR FAMILY ... ADD FUNCTION */;
CREATE OPERATOR FAMILY alt_opf14 USING btree;
ALTER OPERATOR FAMILY alt_opf14 USING btree ADD FUNCTION 1 fn_opf14(int4);
DROP OPERATOR FAMILY alt_opf14 USING btree;
ROLLBACK;
BEGIN /* Should fail. hash comparison functions should have one argument in ALTER OPERATOR FAMILY ... ADD FUNCTION */ /* Should fail. hash comparison functions should have one argument in ALTER OPERATOR FAMILY ... ADD FUNCTION */;
CREATE OPERATOR FAMILY alt_opf15 USING hash;
ALTER OPERATOR FAMILY alt_opf15 USING hash ADD FUNCTION 1 fn_opf15(int4, int2);
DROP OPERATOR FAMILY alt_opf15 USING hash;
ROLLBACK;
/* Should fail. In gist throw an error when giving different data types for function argument */ /* without defining left / right type in ALTER OPERATOR FAMILY ... ADD FUNCTION */ CREATE OPERATOR FAMILY alt_opf16 USING gist;
ALTER OPERATOR FAMILY alt_opf16 USING gist ADD FUNCTION 1 btint42cmp(int4, int2);
DROP OPERATOR FAMILY alt_opf16 USING gist;
/* Should fail. duplicate operator number / function number in ALTER OPERATOR FAMILY ... ADD FUNCTION */ CREATE OPERATOR FAMILY alt_opf17 USING btree;
ALTER OPERATOR FAMILY alt_opf17 USING btree ADD OPERATOR 1 < (int4, int4), OPERATOR 1 < (int4, int4);
/* operator # appears twice in same statement */ ALTER OPERATOR FAMILY alt_opf17 USING btree ADD OPERATOR 1 < (int4, int4);
/* operator 1 requested first-time */ ALTER OPERATOR FAMILY alt_opf17 USING btree ADD OPERATOR 1 < (int4, int4);
/* operator 1 requested again in separate statement */ ALTER OPERATOR FAMILY alt_opf17 USING btree ADD   OPERATOR 1 < (int4, int2) ,   OPERATOR 2 <= (int4, int2) ,   OPERATOR 3 = (int4, int2) ,   OPERATOR 4 >= (int4, int2) ,   OPERATOR 5 > (int4, int2) ,   FUNCTION 1 btint42cmp(int4, int2) ,   FUNCTION 1 btint42cmp(int4, int2);
/* procedure 1 appears twice in same statement */ ALTER OPERATOR FAMILY alt_opf17 USING btree ADD   OPERATOR 1 < (int4, int2) ,   OPERATOR 2 <= (int4, int2) ,   OPERATOR 3 = (int4, int2) ,   OPERATOR 4 >= (int4, int2) ,   OPERATOR 5 > (int4, int2) ,   FUNCTION 1 btint42cmp(int4, int2);
/* procedure 1 appears first time */ ALTER OPERATOR FAMILY alt_opf17 USING btree ADD   OPERATOR 1 < (int4, int2) ,   OPERATOR 2 <= (int4, int2) ,   OPERATOR 3 = (int4, int2) ,   OPERATOR 4 >= (int4, int2) ,   OPERATOR 5 > (int4, int2) ,   FUNCTION 1 btint42cmp(int4, int2);
/* procedure 1 requested again in separate statement */ DROP OPERATOR FAMILY alt_opf17 USING btree;
/* Should fail. Ensure that DROP requests for missing OPERATOR / FUNCTIONS */ /* return appropriate message in ALTER OPERATOR FAMILY ... DROP OPERATOR / FUNCTION */ CREATE OPERATOR FAMILY alt_opf18 USING btree;
ALTER OPERATOR FAMILY alt_opf18 USING btree DROP OPERATOR 1 (int4, int4);
ALTER OPERATOR FAMILY alt_opf18 USING btree ADD   OPERATOR 1 < (int4, int2) ,   OPERATOR 2 <= (int4, int2) ,   OPERATOR 3 = (int4, int2) ,   OPERATOR 4 >= (int4, int2) ,   OPERATOR 5 > (int4, int2) ,   FUNCTION 1 btint42cmp(int4, int2);
/* Should fail. Not allowed to have cross-type equalimage function. */ ALTER OPERATOR FAMILY alt_opf18 USING btree   ADD FUNCTION 4 (int4, int2) btequalimage(oid);
ALTER OPERATOR FAMILY alt_opf18 USING btree DROP FUNCTION 2 (int4, int4);
DROP OPERATOR FAMILY alt_opf18 USING btree;
/* Should fail. Invalid opclass options function (#5) specifications. */ CREATE OPERATOR FAMILY alt_opf19 USING btree;
ALTER OPERATOR FAMILY alt_opf19 USING btree ADD FUNCTION 5 test_opclass_options_func(internal, text[], bool);
ALTER OPERATOR FAMILY alt_opf19 USING btree ADD FUNCTION 5 (int4) btint42cmp(int4, int2);
ALTER OPERATOR FAMILY alt_opf19 USING btree ADD FUNCTION 5 (int4, int2) btint42cmp(int4, int2);
ALTER OPERATOR FAMILY alt_opf19 USING btree ADD FUNCTION 5 (int4) test_opclass_options_func(internal);
/* Ok */ ALTER OPERATOR FAMILY alt_opf19 USING btree DROP FUNCTION 5 (int4, int4);
DROP OPERATOR FAMILY alt_opf19 USING btree;
/* Statistics */ SET SESSION AUTHORIZATION regress_alter_generic_user1;
CREATE TABLE x (x INT, x INT);
CREATE STATISTICS alt_stat1 ON a, b FROM alt_regress_1;
CREATE STATISTICS alt_stat2 ON a, b FROM alt_regress_1;
ALTER STATISTICS alt_stat1 RENAME TO alt_stat2;
/* failed (name conflict) */ ALTER STATISTICS alt_stat1 RENAME TO alt_stat3;
/* OK */ ALTER STATISTICS alt_stat2 OWNER TO regress_alter_generic_user2;
/* failed (no role membership) */ ALTER STATISTICS alt_stat2 OWNER TO regress_alter_generic_user3;
/* OK */ ALTER STATISTICS alt_stat2 SET SCHEMA alt_nsp2;
/* OK */ SET SESSION AUTHORIZATION regress_alter_generic_user2;
CREATE TABLE x (x INT, x INT);
CREATE STATISTICS alt_stat1 ON a, b FROM alt_regress_2;
CREATE STATISTICS alt_stat2 ON a, b FROM alt_regress_2;
ALTER STATISTICS alt_stat3 RENAME TO alt_stat4;
/* failed (not owner) */ ALTER STATISTICS alt_stat1 RENAME TO alt_stat4;
/* OK */ ALTER STATISTICS alt_stat3 OWNER TO regress_alter_generic_user2;
/* failed (not owner) */ ALTER STATISTICS alt_stat2 OWNER TO regress_alter_generic_user3;
/* failed (no role membership) */ ALTER STATISTICS alt_stat3 SET SCHEMA alt_nsp2;
/* failed (not owner) */ ALTER STATISTICS alt_stat2 SET SCHEMA alt_nsp2;
/* failed (name conflict) */ RESET SESSION AUTHORIZATION;
SELECT x, x, x FROM x AS x, x AS x, x AS x WHERE x.x = x.x AND x.x = x.x AND x.x IN ('alt_nsp1', 'alt_nsp2') ORDER BY x NULLS LAST, x NULLS LAST;
/* Text Search Dictionary */ SET SESSION AUTHORIZATION regress_alter_generic_user1;
CREATE TEXT SEARCH DICTIONARY alt_ts_dict1 (template=simple);
CREATE TEXT SEARCH DICTIONARY alt_ts_dict2 (template=simple);
ALTER TEXT SEARCH DICTIONARY alt_ts_dict1 RENAME TO alt_ts_dict2;
/* failed (name conflict) */ ALTER TEXT SEARCH DICTIONARY alt_ts_dict1 RENAME TO alt_ts_dict3;
/* OK */ ALTER TEXT SEARCH DICTIONARY alt_ts_dict2 OWNER TO regress_alter_generic_user2;
/* failed (no role membership) */ ALTER TEXT SEARCH DICTIONARY alt_ts_dict2 OWNER TO regress_alter_generic_user3;
/* OK */ ALTER TEXT SEARCH DICTIONARY alt_ts_dict2 SET SCHEMA alt_nsp2;
/* OK */ SET SESSION AUTHORIZATION regress_alter_generic_user2;
CREATE TEXT SEARCH DICTIONARY alt_ts_dict1 (template=simple);
CREATE TEXT SEARCH DICTIONARY alt_ts_dict2 (template=simple);
ALTER TEXT SEARCH DICTIONARY alt_ts_dict3 RENAME TO alt_ts_dict4;
/* failed (not owner) */ ALTER TEXT SEARCH DICTIONARY alt_ts_dict1 RENAME TO alt_ts_dict4;
/* OK */ ALTER TEXT SEARCH DICTIONARY alt_ts_dict3 OWNER TO regress_alter_generic_user2;
/* failed (not owner) */ ALTER TEXT SEARCH DICTIONARY alt_ts_dict2 OWNER TO regress_alter_generic_user3;
/* failed (no role membership) */ ALTER TEXT SEARCH DICTIONARY alt_ts_dict3 SET SCHEMA alt_nsp2;
/* failed (not owner) */ ALTER TEXT SEARCH DICTIONARY alt_ts_dict2 SET SCHEMA alt_nsp2;
/* failed (name conflict) */ RESET SESSION AUTHORIZATION;
SELECT x, x, x FROM x AS x, x AS x, x AS x WHERE x.x = x.x AND x.x = x.x AND x.x IN ('alt_nsp1', 'alt_nsp2') ORDER BY x NULLS LAST, x NULLS LAST;
/* Text Search Configuration */ SET SESSION AUTHORIZATION regress_alter_generic_user1;
CREATE TEXT SEARCH CONFIGURATION alt_ts_conf1 (copy=english);
CREATE TEXT SEARCH CONFIGURATION alt_ts_conf2 (copy=english);
ALTER TEXT SEARCH CONFIGURATION alt_ts_conf1 RENAME TO alt_ts_conf2;
/* failed (name conflict) */ ALTER TEXT SEARCH CONFIGURATION alt_ts_conf1 RENAME TO alt_ts_conf3;
/* OK */ ALTER TEXT SEARCH CONFIGURATION alt_ts_conf2 OWNER TO regress_alter_generic_user2;
/* failed (no role membership) */ ALTER TEXT SEARCH CONFIGURATION alt_ts_conf2 OWNER TO regress_alter_generic_user3;
/* OK */ ALTER TEXT SEARCH CONFIGURATION alt_ts_conf2 SET SCHEMA alt_nsp2;
/* OK */ SET SESSION AUTHORIZATION regress_alter_generic_user2;
CREATE TEXT SEARCH CONFIGURATION alt_ts_conf1 (copy=english);
CREATE TEXT SEARCH CONFIGURATION alt_ts_conf2 (copy=english);
ALTER TEXT SEARCH CONFIGURATION alt_ts_conf3 RENAME TO alt_ts_conf4;
/* failed (not owner) */ ALTER TEXT SEARCH CONFIGURATION alt_ts_conf1 RENAME TO alt_ts_conf4;
/* OK */ ALTER TEXT SEARCH CONFIGURATION alt_ts_conf3 OWNER TO regress_alter_generic_user2;
/* failed (not owner) */ ALTER TEXT SEARCH CONFIGURATION alt_ts_conf2 OWNER TO regress_alter_generic_user3;
/* failed (no role membership) */ ALTER TEXT SEARCH CONFIGURATION alt_ts_conf3 SET SCHEMA alt_nsp2;
/* failed (not owner) */ ALTER TEXT SEARCH CONFIGURATION alt_ts_conf2 SET SCHEMA alt_nsp2;
/* failed (name conflict) */ RESET SESSION AUTHORIZATION;
SELECT x, x, x FROM x AS x, x AS x, x AS x WHERE x.x = x.x AND x.x = x.x AND x.x IN ('alt_nsp1', 'alt_nsp2') ORDER BY x NULLS LAST, x NULLS LAST;
/* Text Search Template */ CREATE TEXT SEARCH TEMPLATE alt_ts_temp1 (lexize=dsimple_lexize);
CREATE TEXT SEARCH TEMPLATE alt_ts_temp2 (lexize=dsimple_lexize);
ALTER TEXT SEARCH TEMPLATE alt_ts_temp1 RENAME TO alt_ts_temp2;
/* failed (name conflict) */ ALTER TEXT SEARCH TEMPLATE alt_ts_temp1 RENAME TO alt_ts_temp3;
/* OK */ ALTER TEXT SEARCH TEMPLATE alt_ts_temp2 SET SCHEMA alt_nsp2;
/* OK */ CREATE TEXT SEARCH TEMPLATE alt_ts_temp2 (lexize=dsimple_lexize);
ALTER TEXT SEARCH TEMPLATE alt_ts_temp2 SET SCHEMA alt_nsp2;
/* failed (name conflict) */ /* invalid: non-lowercase quoted identifiers */ CREATE TEXT SEARCH TEMPLATE tstemp_case ("Init" = init_function);
SELECT x, x FROM x AS x, x AS x WHERE x.x = x.x AND x LIKE 'alt_nsp%' ORDER BY x NULLS LAST, x NULLS LAST;
/* Text Search Parser */ CREATE TEXT SEARCH PARSER alt_ts_prs1     (start = prsd_start, gettoken = prsd_nexttoken, end = prsd_end, lextypes = prsd_lextype);
CREATE TEXT SEARCH PARSER alt_ts_prs2     (start = prsd_start, gettoken = prsd_nexttoken, end = prsd_end, lextypes = prsd_lextype);
ALTER TEXT SEARCH PARSER alt_ts_prs1 RENAME TO alt_ts_prs2;
/* failed (name conflict) */ ALTER TEXT SEARCH PARSER alt_ts_prs1 RENAME TO alt_ts_prs3;
/* OK */ ALTER TEXT SEARCH PARSER alt_ts_prs2 SET SCHEMA alt_nsp2;
/* OK */ CREATE TEXT SEARCH PARSER alt_ts_prs2     (start = prsd_start, gettoken = prsd_nexttoken, end = prsd_end, lextypes = prsd_lextype);
ALTER TEXT SEARCH PARSER alt_ts_prs2 SET SCHEMA alt_nsp2;
/* failed (name conflict) */ /* invalid: non-lowercase quoted identifiers */ CREATE TEXT SEARCH PARSER tspars_case ("Start" = start_function);
SELECT x, x FROM x AS x, x AS x WHERE x.x = x.x AND x LIKE 'alt_nsp%' ORDER BY x NULLS LAST, x NULLS LAST;
/* - */ /* - Cleanup resources */ /* - */ DROP FOREIGN DATA WRAPPER alt_fdw2 CASCADE;
DROP FOREIGN DATA WRAPPER alt_fdw3 CASCADE;
DROP LANGUAGE alt_lang2 CASCADE;
DROP LANGUAGE alt_lang3 CASCADE;
DROP SCHEMA x.x CASCADE;
DROP SCHEMA x.x CASCADE;
DROP USER regress_alter_generic_user1;
DROP USER regress_alter_generic_user2;
DROP USER regress_alter_generic_user3;
CREATE FUNCTION x(x, x, x, x) RETURNS DOUBLE LANGUAGE internal STABLE STRICT AS 'contsel';
SELECT PG_DESCRIBE_OBJECT(x, x, x) AS x, x FROM x WHERE x = CAST('pg_operator' AS REGCLASS) AND x = CAST('===(bool,bool)' AS REGOPERATOR) ORDER BY 1 NULLS LAST;
/* Test resetting and setting restrict and join attributes. */ ALTER OPERATOR === (boolean, boolean) SET (RESTRICT = NONE);
ALTER OPERATOR === (boolean, boolean) SET (JOIN = NONE);
SELECT x, x FROM x WHERE x = '===' AND x = CAST('boolean' AS REGTYPE) AND x = CAST('boolean' AS REGTYPE);
SELECT PG_DESCRIBE_OBJECT(x, x, x) AS x, x FROM x WHERE x = CAST('pg_operator' AS REGCLASS) AND x = CAST('===(bool,bool)' AS REGOPERATOR) ORDER BY 1 NULLS LAST;
ALTER OPERATOR === (boolean, boolean) SET (RESTRICT = contsel);
ALTER OPERATOR === (boolean, boolean) SET (JOIN = contjoinsel);
SELECT x, x FROM x WHERE x = '===' AND x = CAST('boolean' AS REGTYPE) AND x = CAST('boolean' AS REGTYPE);
SELECT PG_DESCRIBE_OBJECT(x, x, x) AS x, x FROM x WHERE x = CAST('pg_operator' AS REGCLASS) AND x = CAST('===(bool,bool)' AS REGOPERATOR) ORDER BY 1 NULLS LAST;
ALTER OPERATOR === (boolean, boolean) SET (RESTRICT = NONE, JOIN = NONE);
SELECT x, x FROM x WHERE x = '===' AND x = CAST('boolean' AS REGTYPE) AND x = CAST('boolean' AS REGTYPE);
SELECT PG_DESCRIBE_OBJECT(x, x, x) AS x, x FROM x WHERE x = CAST('pg_operator' AS REGCLASS) AND x = CAST('===(bool,bool)' AS REGOPERATOR) ORDER BY 1 NULLS LAST;
ALTER OPERATOR === (boolean, boolean) SET (RESTRICT = customcontsel, JOIN = contjoinsel);
SELECT x, x FROM x WHERE x = '===' AND x = CAST('boolean' AS REGTYPE) AND x = CAST('boolean' AS REGTYPE);
SELECT PG_DESCRIBE_OBJECT(x, x, x) AS x, x FROM x WHERE x = CAST('pg_operator' AS REGCLASS) AND x = CAST('===(bool,bool)' AS REGOPERATOR) ORDER BY 1 NULLS LAST;
/* Test invalid options. */ ALTER OPERATOR === (boolean, boolean) SET (RESTRICT = non_existent_func);
ALTER OPERATOR === (boolean, boolean) SET (JOIN = non_existent_func);
/* invalid: non-lowercase quoted identifiers */ ALTER OPERATOR & (bit, bit) SET ("Restrict" = _int_contsel, "Join" = _int_contjoinsel);
/* Test permission check. Must be owner to ALTER OPERATOR. */ CREATE USER regress_alter_op_user;
SET SESSION AUTHORIZATION regress_alter_op_user;
ALTER OPERATOR === (boolean, boolean) SET (RESTRICT = NONE);
RESET SESSION AUTHORIZATION;
/* negator */ CREATE OPERATOR !==== (     LEFTARG = boolean,     RIGHTARG = real,     PROCEDURE = alter_op_test_fn_bool_real );
/* No-op setting already false hashes and merges to false works */ ALTER OPERATOR === (boolean, real) SET (MERGES = false);
ALTER OPERATOR === (boolean, real) SET (HASHES = false);
/* Test setting merges and hashes */ ALTER OPERATOR === (boolean, real) SET (MERGES);
ALTER OPERATOR === (boolean, real) SET (HASHES);
SELECT x, x FROM x WHERE x = '===' AND x = CAST('boolean' AS REGTYPE) AND x = CAST('real' AS REGTYPE);
/* Test setting commutator */ ALTER OPERATOR === (boolean, real) SET (COMMUTATOR = ====);
/* Check that oprcom has been set on both the operator and commutator, */ /* that they reference each other, and that the operator used is the existing */ /* one we created and not a new shell operator. */ SELECT x.x AS x, x.x AS x, x.x AS x FROM x AS x INNER JOIN x AS x ON (x.x = x.x AND x.x = x.x) WHERE x.x = '===' AND x.x = CAST('boolean' AS REGTYPE) AND x.x = CAST('real' AS REGTYPE);
/* Cannot set self as negator */ ALTER OPERATOR === (boolean, real) SET (NEGATOR = ===);
/* Test setting negator */ ALTER OPERATOR === (boolean, real) SET (NEGATOR = !====);
/* Check that oprnegate has been set on both the operator and negator, */ /* that they reference each other, and that the operator used is the existing */ /* one we created and not a new shell operator. */ SELECT x.x AS x, x.x AS x, x.x AS x FROM x AS x INNER JOIN x AS x ON (x.x = x.x AND x.x = x.x) WHERE x.x = '===' AND x.x = CAST('boolean' AS REGTYPE) AND x.x = CAST('real' AS REGTYPE);
/* Test that no-op set succeeds */ ALTER OPERATOR === (boolean, real) SET (NEGATOR = !====);
ALTER OPERATOR === (boolean, real) SET (COMMUTATOR = ====);
ALTER OPERATOR === (boolean, real) SET (MERGES);
ALTER OPERATOR === (boolean, real) SET (HASHES);
/* Check that the final state of the operator is as we expect */ SELECT x, x, PG_DESCRIBE_OBJECT(CAST('pg_operator' AS REGCLASS), x, 0) AS x, PG_DESCRIBE_OBJECT(CAST('pg_operator' AS REGCLASS), x, 0) AS x FROM x WHERE x = '===' AND x = CAST('boolean' AS REGTYPE) AND x = CAST('real' AS REGTYPE);
/* Cannot change commutator, negator, merges, and hashes when already set */ CREATE OPERATOR @= (     LEFTARG = real,     RIGHTARG = boolean,     PROCEDURE = alter_op_test_fn_real_bool );
CREATE OPERATOR @!= (     LEFTARG = boolean,     RIGHTARG = real,     PROCEDURE = alter_op_test_fn_bool_real );
ALTER OPERATOR === (boolean, real) SET (COMMUTATOR = @=);
ALTER OPERATOR === (boolean, real) SET (NEGATOR = @!=);
ALTER OPERATOR === (boolean, real) SET (MERGES = false);
ALTER OPERATOR === (boolean, real) SET (HASHES = false);
/* Cannot set an operator that already has a commutator as the commutator */ ALTER OPERATOR @=(real, boolean) SET (COMMUTATOR = ===);
/* Cannot set an operator that already has a negator as the negator */ ALTER OPERATOR @!=(boolean, real) SET (NEGATOR = ===);
/* Check no changes made */ SELECT x, x, PG_DESCRIBE_OBJECT(CAST('pg_operator' AS REGCLASS), x, 0) AS x, PG_DESCRIBE_OBJECT(CAST('pg_operator' AS REGCLASS), x, 0) AS x FROM x WHERE x = '===' AND x = CAST('boolean' AS REGTYPE) AND x = CAST('real' AS REGTYPE);
/* Clean up */ DROP USER regress_alter_op_user;
DROP OPERATOR === (boolean, boolean);
DROP OPERATOR === (boolean, real);
DROP OPERATOR ==== (real, boolean);
DROP OPERATOR !==== (boolean, real);
DROP OPERATOR @= (real, boolean);
DROP OPERATOR @!= (boolean, real);
DROP FUNCTION x (internal, OID, internal, INT);
DROP FUNCTION x (BOOLEAN, BOOLEAN);
DROP FUNCTION x (BOOLEAN, FLOAT);
DROP FUNCTION x (FLOAT, BOOLEAN);
SET x = 'warning' /* ALTER_TABLE */ /* Clean up in case a prior regression run failed */;
DROP ROLE IF EXISTS regress_alter_table_user1;
RESET client_min_messages;
CREATE USER regress_alter_table_user1;
/* add attribute */ CREATE TABLE x (x INT);
COMMENT ON TABLE x IS 'table comment';
COMMENT ON TABLE x IS 'table comment';
ALTER TABLE x ADD COLUMN x INT;
ALTER TABLE x ADD COLUMN x INT DEFAULT 3 /* fails */;
ALTER TABLE x ADD COLUMN x NAME;
ALTER TABLE x ADD COLUMN x TEXT;
ALTER TABLE x ADD COLUMN x DOUBLE;
ALTER TABLE x ADD COLUMN x FLOAT;
ALTER TABLE x ADD COLUMN x SMALLINT;
ALTER TABLE x ADD COLUMN x polygon;
ALTER TABLE x ADD COLUMN x CHAR;
ALTER TABLE x ADD COLUMN x INT;
ALTER TABLE x ADD COLUMN x tid;
ALTER TABLE x ADD COLUMN x xid;
ALTER TABLE x ADD COLUMN x oidvector;
ALTER TABLE x ADD COLUMN x BOOLEAN;
ALTER TABLE x ADD COLUMN x point;
ALTER TABLE x ADD COLUMN x lseg;
ALTER TABLE x ADD COLUMN x path;
ALTER TABLE x ADD COLUMN x box;
ALTER TABLE x ADD COLUMN x TIMESTAMP;
ALTER TABLE x ADD COLUMN x INTERVAL;
ALTER TABLE x ADD COLUMN x ARRAY<DOUBLE>;
ALTER TABLE x ADD COLUMN x ARRAY<FLOAT>;
ALTER TABLE x ADD COLUMN x ARRAY<SMALLINT>;
INSERT INTO x (x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x) VALUES (4, 'name', 'text', 4.1, 4.1, 2, '(4.1,4.1,3.1,3.1)', 'c', 314159, '(1,1)', '512', '1 2 3 4 5 6 7 8', TRUE, '(1.1,1.1)', '(4.1,4.1,3.1,3.1)', '(0,2,4.1,4.1,3.1,3.1)', '(4.1,4.1,3.1,3.1)', 'epoch', '01:00:10', '{1.0,2.0,3.0,4.0}', '{1.0,2.0,3.0,4.0}', '{1,2,3,4}');
SELECT * FROM x;
DROP TABLE x;
/* the wolf bug - schema mods caused inconsistent row descriptors */ CREATE TABLE x (x INT);
ALTER TABLE x ADD COLUMN x INT;
ALTER TABLE x ADD COLUMN x NAME;
ALTER TABLE x ADD COLUMN x TEXT;
ALTER TABLE x ADD COLUMN x DOUBLE;
ALTER TABLE x ADD COLUMN x FLOAT;
ALTER TABLE x ADD COLUMN x SMALLINT;
ALTER TABLE x ADD COLUMN x polygon;
ALTER TABLE x ADD COLUMN x CHAR;
ALTER TABLE x ADD COLUMN x INT;
ALTER TABLE x ADD COLUMN x tid;
ALTER TABLE x ADD COLUMN x xid;
ALTER TABLE x ADD COLUMN x oidvector;
ALTER TABLE x ADD COLUMN x BOOLEAN;
ALTER TABLE x ADD COLUMN x point;
ALTER TABLE x ADD COLUMN x lseg;
ALTER TABLE x ADD COLUMN x path;
ALTER TABLE x ADD COLUMN x box;
ALTER TABLE x ADD COLUMN x TIMESTAMP;
ALTER TABLE x ADD COLUMN x INTERVAL;
ALTER TABLE x ADD COLUMN x ARRAY<DOUBLE>;
ALTER TABLE x ADD COLUMN x ARRAY<FLOAT>;
ALTER TABLE x ADD COLUMN x ARRAY<SMALLINT>;
INSERT INTO x (x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x) VALUES (4, 'name', 'text', 4.1, 4.1, 2, '(4.1,4.1,3.1,3.1)', 'c', 314159, '(1,1)', '512', '1 2 3 4 5 6 7 8', TRUE, '(1.1,1.1)', '(4.1,4.1,3.1,3.1)', '(0,2,4.1,4.1,3.1,3.1)', '(4.1,4.1,3.1,3.1)', 'epoch', '01:00:10', '{1.0,2.0,3.0,4.0}', '{1.0,2.0,3.0,4.0}', '{1,2,3,4}');
SELECT * FROM x;
CREATE INDEX x ON x(x NULLS LAST, (x + x) NULLS LAST, x NULLS LAST);
ALTER INDEX x ALTER COLUMN 0 DROP DEFAULT, SET STATISTICS 1000;
ALTER INDEX x ALTER COLUMN 1 DROP DEFAULT, SET STATISTICS 1000;
ALTER INDEX x ALTER COLUMN 2 DROP DEFAULT, SET STATISTICS 1000;
ALTER INDEX x ALTER COLUMN 4 DROP DEFAULT, SET STATISTICS 1000;
ALTER INDEX x ALTER COLUMN 2 DROP DEFAULT, SET STATISTICS -1;
DROP TABLE x;
/* rename - check on both non-temp and temp tables */ CREATE TABLE x (x INT);
CREATE TEMPORARY TABLE x (x INT);
ALTER TABLE x RENAME TO x;
SELECT * FROM x;
SELECT * FROM x;
ALTER TABLE x RENAME TO x;
SELECT * FROM x;
/* should fail */ SELECT * FROM x;
SELECT * FROM x;
DROP TABLE x;
DROP TABLE x;
/* check rename of partitioned tables and indexes also */ CREATE TABLE x (x INT PRIMARY KEY) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (0) TO (100);
ALTER INDEX x RENAME TO x;
ALTER INDEX x RENAME TO x;
ALTER TABLE x RENAME TO x;
ALTER TABLE x RENAME TO x;
SET ROLE regress_alter_table_user1;
ALTER INDEX x RENAME TO x;
ALTER INDEX x RENAME TO x;
ALTER TABLE x RENAME TO x;
ALTER TABLE x RENAME TO x;
RESET ROLE;
DROP TABLE x;
/* check renaming to a table's array type's autogenerated name */ /* (the array type's name should get out of the way) */ CREATE TABLE x (x INT);
CREATE TABLE x (x INT);
SELECT x FROM x WHERE x = CAST('attmp_array[]' AS REGTYPE);
SELECT x FROM x WHERE x = CAST('attmp_array2[]' AS REGTYPE);
ALTER TABLE x RENAME TO x;
SELECT x FROM x WHERE x = CAST('attmp_array[]' AS REGTYPE);
SELECT x FROM x WHERE x = CAST('_attmp_array[]' AS REGTYPE);
DROP TABLE x;
DROP TABLE x;
/* renaming to table's own array type's name is an interesting corner case */ CREATE TABLE x (x INT);
SELECT x FROM x WHERE x = CAST('attmp_array[]' AS REGTYPE);
ALTER TABLE x RENAME TO x;
SELECT x FROM x WHERE x = CAST('_attmp_array[]' AS REGTYPE);
DROP TABLE x;
ALTER INDEX IF EXISTS x RENAME TO x /* ALTER TABLE ... RENAME on non-table relations */ /* renaming indexes (FIXME: this should probably test the index's functionality) */;
ALTER INDEX IF EXISTS x RENAME TO x;
ALTER INDEX x RENAME TO x;
ALTER INDEX x RENAME TO x;
SET ROLE regress_alter_table_user1;
ALTER INDEX x RENAME TO x;
/* permission denied */ RESET ROLE;
/* rename statements with mismatching statement and object types */ CREATE TABLE x (x INT);
CREATE INDEX x ON x(x NULLS LAST);
CREATE TABLE x (x INT) WITH (PARTITIONED_BY=LIST(x));
CREATE INDEX x ON x(x NULLS LAST);
BEGIN;
ALTER INDEX x RENAME TO x;
ALTER INDEX x RENAME TO x;
SELECT CAST(x AS REGCLASS), x FROM x WHERE x = PG_BACKEND_PID() AND x = 'relation' AND CAST(CAST(x AS REGCLASS) AS TEXT) LIKE 'alter\_idx%' ORDER BY CAST(CAST(x AS REGCLASS) AS TEXT) COLLATE "x" NULLS LAST;
COMMIT;
BEGIN;
ALTER INDEX x RENAME TO x;
ALTER INDEX x RENAME TO x;
SELECT CAST(x AS REGCLASS), x FROM x WHERE x = PG_BACKEND_PID() AND x = 'relation' AND CAST(CAST(x AS REGCLASS) AS TEXT) LIKE 'alter\_idx%' ORDER BY CAST(CAST(x AS REGCLASS) AS TEXT) COLLATE "x" NULLS LAST;
COMMIT;
BEGIN;
ALTER TABLE x RENAME TO x;
ALTER TABLE x RENAME TO x;
SELECT CAST(x AS REGCLASS), x FROM x WHERE x = PG_BACKEND_PID() AND x = 'relation' AND CAST(CAST(x AS REGCLASS) AS TEXT) LIKE 'alter\_idx%' ORDER BY CAST(CAST(x AS REGCLASS) AS TEXT) COLLATE "x" NULLS LAST;
COMMIT;
DROP TABLE x;
/* renaming views */ CREATE VIEW x (x) AS SELECT x FROM x;
ALTER TABLE x RENAME TO x;
SET ROLE regress_alter_table_user1;
ALTER VIEW x RENAME TO x;
/* permission denied */ RESET ROLE;
SET x = off /* hack to ensure we get an indexscan here */;
SET x = off;
/* 5 values, sorted */ SELECT x FROM x WHERE x < 5;
RESET enable_seqscan;
RESET enable_bitmapscan;
DROP VIEW x;
ALTER TABLE x RENAME TO x /* toast-like relation name */;
ALTER TABLE x RENAME TO x;
ALTER TABLE x ADD CONSTRAINT x UNIQUE (x) /* renaming index should rename constraint as well */;
ALTER INDEX x RENAME TO x;
ALTER TABLE x DROP CONSTRAINT x;
ALTER TABLE x ADD CONSTRAINT x CHECK (x >= 0) /* renaming constraint */;
ALTER TABLE onek RENAME CONSTRAINT onek_check_constraint TO onek_check_constraint_foo;
ALTER TABLE x DROP CONSTRAINT x;
ALTER TABLE x ADD CONSTRAINT x UNIQUE (x) /* renaming constraint should rename index as well */;
DROP INDEX x;
/* to see whether it's there */ ALTER TABLE onek RENAME CONSTRAINT onek_unique1_constraint TO onek_unique1_constraint_foo;
DROP INDEX x;
ALTER TABLE x DROP CONSTRAINT x /* to see whether it's there */;
/* renaming constraints vs. inheritance */ CREATE TABLE x (x INT CONSTRAINT x CHECK (x > 0), x INT, x INT);
/* fail */ ALTER TABLE ONLY constraint_rename_test RENAME CONSTRAINT con1 TO con1foo;
/* fail */ ALTER TABLE constraint_rename_test RENAME CONSTRAINT con1 TO con1foo;
ALTER TABLE ONLY constraint_rename_test RENAME CONSTRAINT con2 TO con2foo;
/* ok */ ALTER TABLE constraint_rename_test RENAME CONSTRAINT con2foo TO con2bar;
ALTER TABLE constraint_rename_test RENAME CONSTRAINT con3 TO con3foo;
DROP TABLE x;
ALTER TABLE IF EXISTS constraint_not_exist RENAME CONSTRAINT con3 TO con3foo;
ALTER TABLE IF EXISTS x ADD CONSTRAINT x UNIQUE (x) /* ok */;
/* renaming constraints with cache reset of target relation */ CREATE TABLE x (x INT, CONSTRAINT x CHECK (x > 0), PRIMARY KEY (x NULLS LAST));
ALTER TABLE constraint_rename_cache   RENAME CONSTRAINT chk_a TO chk_a_new;
ALTER TABLE constraint_rename_cache   RENAME CONSTRAINT constraint_rename_cache_pkey TO constraint_rename_pkey_new;
CREATE TABLE x (LIKE x INCLUDING ALL);
DROP TABLE x;
/* FOREIGN KEY CONSTRAINT adding TEST */ CREATE TABLE x (x INT PRIMARY KEY);
CREATE TABLE x (x INT, x INT);
CREATE TABLE x (x INT, x INT, UNIQUE (x, x));
CREATE TABLE x (x INT, x INT);
/* Insert rows into attmp2 (pktable) */ INSERT INTO x VALUES (1);
INSERT INTO x VALUES (2);
INSERT INTO x VALUES (3);
INSERT INTO x VALUES (4);
/* Insert rows into attmp3 */ INSERT INTO x VALUES (1, 10);
INSERT INTO x VALUES (1, 20);
INSERT INTO x VALUES (5, 50);
ALTER TABLE x ADD CONSTRAINT x FOREIGN KEY (x) REFERENCES x MATCH FULL /* Try (and fail) to add constraint due to invalid source columns */;
ALTER TABLE x ADD CONSTRAINT x FOREIGN KEY (x) REFERENCES x (x) MATCH FULL /* Try (and fail) to add constraint due to invalid destination columns explicitly given */;
ALTER TABLE x ADD CONSTRAINT x FOREIGN KEY (x) REFERENCES x MATCH FULL /* Try (and fail) to add constraint due to invalid data */;
/* Delete failing row */ DELETE FROM x WHERE x = 5;
ALTER TABLE x ADD CONSTRAINT x FOREIGN KEY (x) REFERENCES x MATCH FULL /* Try (and succeed) */;
ALTER TABLE x DROP CONSTRAINT x;
INSERT INTO x VALUES (5, 50);
ALTER TABLE x ADD CONSTRAINT x FOREIGN KEY (x) REFERENCES x MATCH FULL NOT VALID /* Try NOT VALID and then VALIDATE CONSTRAINT, but fails. Delete failure then re-validate */;
ALTER TABLE attmp3 validate constraint attmpconstr;
/* Delete failing row */ DELETE FROM x WHERE x = 5;
/* Try (and succeed) and repeat to show it works on already valid constraint */ ALTER TABLE attmp3 validate constraint attmpconstr;
ALTER TABLE attmp3 validate constraint attmpconstr;
ALTER TABLE x ADD CONSTRAINT x CHECK (x > 10) /* Try a non-verified CHECK constraint */;
ALTER TABLE x ADD CONSTRAINT x CHECK (x > 10) NOT VALID /* fail */;
/* succeeds */ ALTER TABLE attmp3 ADD CONSTRAINT b_greater_than_ten_not_enforced CHECK (b > 10) NOT ENFORCED;
/* succeeds */ ALTER TABLE attmp3 VALIDATE CONSTRAINT b_greater_than_ten;
/* fails */ DELETE FROM x WHERE NOT x > 10;
ALTER TABLE attmp3 VALIDATE CONSTRAINT b_greater_than_ten;
/* succeeds */ ALTER TABLE attmp3 VALIDATE CONSTRAINT b_greater_than_ten;
/* succeeds */ ALTER TABLE attmp3 VALIDATE CONSTRAINT b_greater_than_ten_not_enforced;
/* fail */ /* Test inherited NOT VALID CHECK constraints */ SELECT * FROM x;
CREATE TABLE x INHERITS (x);
CREATE TABLE x INHERITS (x);
INSERT INTO x VALUES (6, 30), (7, 16);
ALTER TABLE x ADD CONSTRAINT x CHECK (x <= 20) NOT VALID;
ALTER TABLE attmp3 VALIDATE CONSTRAINT b_le_20;
/* fails */ DELETE FROM x WHERE x > 20;
ALTER TABLE attmp3 VALIDATE CONSTRAINT b_le_20;
x AS @1;
COMMIT;
INSERT INTO x VALUES (8, 18);
ALTER TABLE x ADD CONSTRAINT x CHECK (x = BOO(x));
ALTER TABLE x ADD CONSTRAINT x CHECK (x = BOO(x)) NOT VALID;
ALTER TABLE attmp3 VALIDATE CONSTRAINT identity;
/* A NO INHERIT constraint should not be looked for in children during VALIDATE CONSTRAINT */ CREATE TABLE x (x INT);
CREATE TABLE x INHERITS (x);
INSERT INTO x VALUES (1);
INSERT INTO x VALUES (1);
alter table parent_noinh_convalid add constraint check_a_is_2 check (a = 2) no inherit not valid;
/* fail, because of the row in parent */ alter table parent_noinh_convalid validate constraint check_a_is_2;
DELETE FROM ONLY x;
/* ok (parent itself contains no violating rows) */ alter table parent_noinh_convalid validate constraint check_a_is_2;
SELECT x FROM x WHERE x = CAST('parent_noinh_convalid' AS REGCLASS) AND x = 'check_a_is_2';
ALTER TABLE x ADD CONSTRAINT x FOREIGN KEY (x) REFERENCES x (x) MATCH FULL /* Try (and fail) to create constraint from attmp5(a) to attmp4(a) - unique constraint on */ /* attmp4 is a,b */;
DROP TABLE x;
DROP TABLE x;
DROP TABLE x;
DROP TABLE x;
DROP TABLE x;
DROP TABLE x;
SET x = 'partition' /* NOT VALID with plan invalidation -- ensure we don't use a constraint for */ /* exclusion until validated */;
CREATE TABLE x INHERITS (x);
EXPLAIN (costs off) select * from nv_parent where d between '2011-08-01' and '2011-08-31';
CREATE TABLE x (CHECK (x BETWEEN CAST('2009-01-01' AS DATE) AND CAST('2009-12-31' AS DATE))) INHERITS (x);
EXPLAIN (costs off) select * from nv_parent where d between '2011-08-01'::date and '2011-08-31'::date;
EXPLAIN (costs off) select * from nv_parent where d between '2009-08-01'::date and '2009-08-31'::date;
/* after validation, the constraint should be used */ alter table nv_child_2011 VALIDATE CONSTRAINT nv_child_2011_d_check;
EXPLAIN (costs off) select * from nv_parent where d between '2009-08-01'::date and '2009-08-31'::date;
INSERT INTO x VALUES (42);
CREATE TEMPORARY TABLE x (x INET);
ALTER TABLE x ADD FOREIGN KEY (x) REFERENCES x /* This next should fail, because int=inet does not exist */;
ALTER TABLE x ADD FOREIGN KEY (x) REFERENCES x (x) /* This should also fail for the same reason, but here we */ /* give the column name */;
DROP TABLE x;
/* This should succeed, even though they are different types, */ /* because int=int8 exists and is a member of the integer opfamily */ CREATE TEMPORARY TABLE x (x BIGINT);
ALTER TABLE x ADD FOREIGN KEY (x) REFERENCES x;
/* Check it actually works */ INSERT INTO x VALUES (42);
/* should succeed */ INSERT INTO x VALUES (43);
/* should fail */ DROP TABLE x;
/* This should fail, because we'd have to cast numeric to int which is */ /* not an implicit coercion (or use numeric=numeric, but that's not part */ /* of the integer opfamily) */ CREATE TEMPORARY TABLE x (x DECIMAL);
ALTER TABLE x ADD FOREIGN KEY (x) REFERENCES x;
DROP TABLE x;
DROP TABLE x;
/* On the other hand, this should work because int implicitly promotes to */ /* numeric, and we allow promotion on the FK side */ CREATE TEMPORARY TABLE x (x DECIMAL PRIMARY KEY);
INSERT INTO x VALUES (42);
CREATE TEMPORARY TABLE x (x INT);
ALTER TABLE x ADD FOREIGN KEY (x) REFERENCES x;
/* Check it actually works */ INSERT INTO x VALUES (42);
/* should succeed */ INSERT INTO x VALUES (43);
/* should fail */ DROP TABLE x;
DROP TABLE x;
CREATE TEMPORARY TABLE x (x INT, x INET, PRIMARY KEY (x NULLS LAST, x NULLS LAST));
/* This should fail, because we just chose really odd types */ CREATE TEMPORARY TABLE x (x cidr, x TIMESTAMP);
ALTER TABLE x ADD FOREIGN KEY (x, x) REFERENCES x;
DROP TABLE x;
/* Again, so should this... */ CREATE TEMPORARY TABLE x (x cidr, x TIMESTAMP);
ALTER TABLE x ADD FOREIGN KEY (x, x) REFERENCES x (x, x);
DROP TABLE x;
/* This fails because we mixed up the column ordering */ CREATE TEMPORARY TABLE x (x INT, x INET);
ALTER TABLE x ADD FOREIGN KEY (x, x) REFERENCES x (x, x);
ALTER TABLE x ADD FOREIGN KEY (x, x) REFERENCES x (x, x) /* As does this... */;
DROP TABLE x;
DROP TABLE x;
/* Test that ALTER CONSTRAINT updates trigger deferrability properly */ CREATE TEMPORARY TABLE x (x INT PRIMARY KEY);
CREATE TEMPORARY TABLE x (x INT);
ALTER TABLE FKTABLE ADD CONSTRAINT fknd FOREIGN KEY(ftest1) REFERENCES pktable   ON DELETE CASCADE ON UPDATE NO ACTION NOT DEFERRABLE;
ALTER TABLE x ADD CONSTRAINT x FOREIGN KEY (x) REFERENCES x ON DELETE CASCADE ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE x ADD CONSTRAINT x FOREIGN KEY (x) REFERENCES x ON DELETE CASCADE ON UPDATE NO ACTION DEFERRABLE INITIALLY IMMEDIATE;
ALTER TABLE x ADD CONSTRAINT x FOREIGN KEY (x) REFERENCES x ON DELETE CASCADE ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE FKTABLE ALTER CONSTRAINT fknd2 NOT DEFERRABLE;
ALTER TABLE FKTABLE ADD CONSTRAINT fkdd2 FOREIGN KEY(ftest1) REFERENCES pktable   ON DELETE CASCADE ON UPDATE NO ACTION NOT DEFERRABLE;
ALTER TABLE FKTABLE ALTER CONSTRAINT fkdd2 DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE FKTABLE ADD CONSTRAINT fkdi2 FOREIGN KEY(ftest1) REFERENCES pktable   ON DELETE CASCADE ON UPDATE NO ACTION NOT DEFERRABLE;
ALTER TABLE FKTABLE ALTER CONSTRAINT fkdi2 DEFERRABLE INITIALLY IMMEDIATE;
SELECT x, CAST(x AS REGPROC), x, x, x FROM x JOIN x AS x ON x.x = x WHERE x = CAST('pktable' AS REGCLASS) ORDER BY 1 NULLS LAST, 2 NULLS LAST, 3 NULLS LAST;
SELECT x, CAST(x AS REGPROC), x, x, x FROM x JOIN x AS x ON x.x = x WHERE x = CAST('fktable' AS REGCLASS) ORDER BY 1 NULLS LAST, 2 NULLS LAST, 3 NULLS LAST;
/* temp tables should go away by themselves, need not drop them. */ /* test check constraint adding */ CREATE TABLE x (x INT);
ALTER TABLE x ADD CONSTRAINT x CHECK (x > 3) /* add a check constraint */;
/* should fail */ INSERT INTO x (x) VALUES (2);
/* should succeed */ INSERT INTO x (x) VALUES (4);
DROP TABLE x;
/* let's do one where the check fails when added */ CREATE TABLE x (x INT);
/* insert a soon to be failing row */ INSERT INTO x (x) VALUES (2);
ALTER TABLE x ADD CONSTRAINT x CHECK (x > 3) /* add a check constraint (fails) */;
INSERT INTO x (x) VALUES (4);
DROP TABLE x;
/* let's do one where the check fails because the column doesn't exist */ CREATE TABLE x (x INT);
ALTER TABLE x ADD CONSTRAINT x CHECK (x > 3) /* add a check constraint (fails) */;
DROP TABLE x;
/* something a little more complicated */ CREATE TABLE x (x INT, x INT, x INT);
ALTER TABLE x ADD CONSTRAINT x CHECK (x + x < x * 4) /* add a check constraint (fails) */;
/* should fail */ INSERT INTO x (x, x, x) VALUES (4, 4, 2);
/* should succeed */ INSERT INTO x (x, x, x) VALUES (4, 4, 5);
DROP TABLE x;
/* lets do some naming tests */ CREATE TABLE x (x INT CHECK (x > 3), x INT);
ALTER TABLE x CHECK(x > x);
/* should fail for $2 */ INSERT INTO x (x, x) VALUES (3, 4);
DROP TABLE x;
/* inheritance related tests */ CREATE TABLE x (x INT);
CREATE TABLE x (x INT);
CREATE TABLE x (x INT) INHERITS (x, x);
ALTER TABLE x ADD CONSTRAINT x CHECK (x > 0);
/* fail and then succeed on atacc2 */ INSERT INTO x (x) VALUES (-3);
INSERT INTO x (x) VALUES (3);
/* fail and then succeed on atacc3 */ INSERT INTO x (x) VALUES (-3);
INSERT INTO x (x) VALUES (3);
DROP TABLE x;
DROP TABLE x;
DROP TABLE x;
/* same things with one created with INHERIT */ CREATE TABLE x (x INT);
CREATE TABLE x (x INT);
CREATE TABLE x (x INT) INHERITS (x, x);
alter table atacc3 no inherit atacc2;
/* fail */ alter table atacc3 no inherit atacc2;
/* make sure it really isn't a child */ INSERT INTO x (x) VALUES (3);
SELECT x FROM x;
ALTER TABLE x ADD CONSTRAINT x CHECK (x > 0) /* fail due to missing constraint */;
alter table atacc3 inherit atacc2;
ALTER TABLE x RENAME TO x, TO x /* fail due to missing column */;
alter table atacc3 inherit atacc2;
ALTER TABLE x ADD COLUMN x BOOLEAN /* fail due to mismatched data type */;
alter table atacc3 inherit atacc2;
ALTER TABLE x drop test2;
ALTER TABLE x ADD COLUMN x INT /* succeed */;
UPDATE x SET x = 4 WHERE x IS NULL;
ALTER TABLE x ADD CONSTRAINT x CHECK (x > 0);
alter table atacc3 inherit atacc2;
/* fail due to duplicates and circular inheritance */ alter table atacc3 inherit atacc2;
alter table atacc2 inherit atacc3;
alter table atacc2 inherit atacc2;
/* test that we really are a child now (should see 4 not 3 and cascade should go through) */ SELECT x FROM x;
DROP TABLE x CASCADE;
DROP TABLE x;
/* adding only to a parent is allowed as of 9.2 */ CREATE TABLE x (x INT);
CREATE TABLE x (x INT) INHERITS (x);
/* ok: */ alter table atacc1 add constraint foo check (test>0) no inherit;
/* check constraint is not there on child */ INSERT INTO x (x) VALUES (-3);
/* check constraint is there on parent */ INSERT INTO x (x) VALUES (-3);
INSERT INTO x (x) VALUES (3);
/* fail, violating row: */ alter table atacc2 add constraint foo check (test>0) no inherit;
DROP TABLE x;
DROP TABLE x;
/* test unique constraint adding */ CREATE TABLE x (x INT);
ALTER TABLE x ADD CONSTRAINT x UNIQUE (x) /* add a unique constraint */;
/* insert first value */ INSERT INTO x (x) VALUES (2);
/* should fail */ INSERT INTO x (x) VALUES (2);
/* should succeed */ INSERT INTO x (x) VALUES (4);
ALTER TABLE x ALTER COLUMN x SET DATA TYPE INT USING 0 /* try to create duplicates via alter table using - should fail */;
DROP TABLE x;
/* let's do one where the unique constraint fails when added */ CREATE TABLE x (x INT);
/* insert soon to be failing rows */ INSERT INTO x (x) VALUES (2);
INSERT INTO x (x) VALUES (2);
ALTER TABLE x ADD CONSTRAINT x UNIQUE (x) /* add a unique constraint (fails) */;
INSERT INTO x (x) VALUES (3);
DROP TABLE x;
/* let's do one where the unique constraint fails */ /* because the column doesn't exist */ CREATE TABLE x (x INT);
ALTER TABLE x ADD CONSTRAINT x UNIQUE (x) /* add a unique constraint (fails) */;
DROP TABLE x;
/* something a little more complicated */ CREATE TABLE x (x INT, x INT);
ALTER TABLE x ADD CONSTRAINT x UNIQUE (x, x) /* add a unique constraint */;
/* insert initial value */ INSERT INTO x (x, x) VALUES (4, 4);
/* should fail */ INSERT INTO x (x, x) VALUES (4, 4);
/* should all succeed */ INSERT INTO x (x, x) VALUES (4, 5);
INSERT INTO x (x, x) VALUES (5, 4);
INSERT INTO x (x, x) VALUES (5, 5);
DROP TABLE x;
/* lets do some naming tests */ CREATE TABLE x (x INT, x INT, UNIQUE (x));
ALTER TABLE x ADD UNIQUE (x);
/* should fail for @@ second one @@ */ INSERT INTO x (x, x) VALUES (3, 3);
INSERT INTO x (x, x) VALUES (2, 3);
DROP TABLE x;
/* test primary key constraint adding */ CREATE TABLE x (x SERIAL, x INT);
ALTER TABLE x ADD CONSTRAINT x PRIMARY KEY (x NULLS LAST) /* add a primary key constraint */;
/* insert first value */ INSERT INTO x (x) VALUES (2);
/* should fail */ INSERT INTO x (x) VALUES (2);
/* should succeed */ INSERT INTO x (x) VALUES (4);
/* inserting NULL should fail */ INSERT INTO x (x) VALUES (NULL);
ALTER TABLE x ADD CONSTRAINT x PRIMARY KEY (x NULLS LAST) /* try adding a second primary key (should fail) */;
/* drop first primary key constraint */ alter table atacc1 drop constraint atacc_test1 restrict;
ALTER TABLE x ADD CONSTRAINT x PRIMARY KEY (x NULLS LAST) /* try adding a primary key on oid (should succeed) */;
DROP TABLE x;
/* let's do one where the primary key constraint fails when added */ CREATE TABLE x (x INT);
/* insert soon to be failing rows */ INSERT INTO x (x) VALUES (2);
INSERT INTO x (x) VALUES (2);
ALTER TABLE x ADD CONSTRAINT x PRIMARY KEY (x NULLS LAST) /* add a primary key (fails) */;
INSERT INTO x (x) VALUES (3);
DROP TABLE x;
/* let's do another one where the primary key constraint fails when added */ CREATE TABLE x (x INT);
/* insert soon to be failing row */ INSERT INTO x (x) VALUES (NULL);
ALTER TABLE x ADD CONSTRAINT x PRIMARY KEY (x NULLS LAST) /* add a primary key (fails) */;
INSERT INTO x (x) VALUES (3);
DROP TABLE x;
/* let's do one where the primary key constraint fails */ /* because the column doesn't exist */ CREATE TABLE x (x INT);
ALTER TABLE x ADD CONSTRAINT x PRIMARY KEY (x NULLS LAST) /* add a primary key constraint (fails) */;
DROP TABLE x;
/* adding a new column as primary key to a non-empty table. */ /* should fail unless the column has a non-null default value. */ CREATE TABLE x (x INT);
INSERT INTO x (x) VALUES (0);
ALTER TABLE x ADD COLUMN x INT PRIMARY KEY /* add a primary key column without a default (fails). */;
ALTER TABLE x ADD COLUMN x INT DEFAULT 0 PRIMARY KEY /* now add a primary key column with a default (succeeds). */;
DROP TABLE x;
/* this combination used to have order-of-execution problems (bug #15580) */ CREATE TABLE x (x INT);
INSERT INTO x VALUES (1);
ALTER TABLE x ADD COLUMN x DOUBLE NOT NULL DEFAULT RAND(), ADD COLUMN PRIMARY KEY(x);
DROP TABLE x;
/* additionally, we've seen issues with foreign key validation not being */ /* properly delayed until after a table rewrite.  Check that works ok. */ CREATE TABLE x (x INT PRIMARY KEY);
ALTER TABLE x ADD CONSTRAINT x FOREIGN KEY (x) REFERENCES x (x) NOT VALID;
alter table atacc1 validate constraint atacc1_fkey, alter a type bigint;
DROP TABLE x;
/* we've also seen issues with check constraints being validated at the wrong */ /* time when there's a pending table rewrite. */ CREATE TABLE x (x BIGINT, x INT);
INSERT INTO x VALUES (1, 1);
ALTER TABLE x ADD CONSTRAINT x CHECK (x = 1) NOT VALID;
alter table atacc1 validate constraint atacc1_chk, alter a type int;
DROP TABLE x;
/* same as above, but ensure the constraint violation is detected */ CREATE TABLE x (x BIGINT, x INT);
INSERT INTO x VALUES (1, 2);
ALTER TABLE x ADD CONSTRAINT x CHECK (x = 1) NOT VALID;
alter table atacc1 validate constraint atacc1_chk, alter a type int;
DROP TABLE x;
/* something a little more complicated */ CREATE TABLE x (x INT, x INT);
ALTER TABLE x ADD CONSTRAINT x PRIMARY KEY (x NULLS LAST, x NULLS LAST) /* add a primary key constraint */;
ALTER TABLE x ADD CONSTRAINT x PRIMARY KEY (x NULLS LAST) /* try adding a second primary key - should fail */;
/* insert initial value */ INSERT INTO x (x, x) VALUES (4, 4);
/* should fail */ INSERT INTO x (x, x) VALUES (4, 4);
INSERT INTO x (x, x) VALUES (NULL, 3);
INSERT INTO x (x, x) VALUES (3, NULL);
INSERT INTO x (x, x) VALUES (NULL, NULL);
/* should all succeed */ INSERT INTO x (x, x) VALUES (4, 5);
INSERT INTO x (x, x) VALUES (5, 4);
INSERT INTO x (x, x) VALUES (5, 5);
DROP TABLE x;
/* lets do some naming tests */ CREATE TABLE x (x INT, x INT, PRIMARY KEY (x NULLS LAST));
/* only first should succeed */ INSERT INTO x (x, x) VALUES (3, 3);
INSERT INTO x (x, x) VALUES (2, 3);
INSERT INTO x (x, x) VALUES (1, NULL);
DROP TABLE x;
ALTER TABLE x ALTER COLUMN x DROP NOT NULL /* alter table / alter column [set/drop] not null tests */ /* try altering system catalogs, should fail */;
ALTER TABLE x ALTER COLUMN x SET NOT NULL;
ALTER TABLE x ALTER COLUMN x SET NOT NULL /* try altering non-existent table, should fail */;
ALTER TABLE x ALTER COLUMN x DROP NOT NULL;
/* test setting columns to null and not null and vice versa */ /* test checking for null values and primary key */ CREATE TABLE x (x INT NOT NULL);
ALTER TABLE x ADD CONSTRAINT "x" PRIMARY KEY (x NULLS LAST);
ALTER TABLE x ALTER COLUMN x DROP NOT NULL;
ALTER TABLE x ALTER COLUMN x SET NOT NULL;
DELETE FROM x;
ALTER TABLE x ALTER COLUMN x SET NOT NULL;
ALTER TABLE x ALTER COLUMN x SET NOT NULL /* try altering a non-existent column, should fail */;
ALTER TABLE x ALTER COLUMN x DROP NOT NULL;
/* try creating a view and altering that, should fail */ CREATE VIEW x AS SELECT * FROM x;
ALTER TABLE x ALTER COLUMN x DROP NOT NULL;
ALTER TABLE x ALTER COLUMN x SET NOT NULL;
DROP VIEW x;
DROP TABLE x;
/* set not null verified by constraints */ CREATE TABLE x (x INT, x INT);
INSERT INTO x VALUES (NULL, 1);
ALTER TABLE x ADD CONSTRAINT x CHECK (NOT x IS NULL OR x < 10) /* constraint not cover all values, should fail */;
ALTER TABLE x ALTER COLUMN x SET NOT NULL;
ALTER TABLE x DROP CONSTRAINT x;
ALTER TABLE x ADD CONSTRAINT x CHECK (NOT x IS NULL) NOT VALID /* not valid constraint, should fail */;
ALTER TABLE x ALTER COLUMN x SET NOT NULL;
ALTER TABLE x DROP CONSTRAINT x;
/* with valid constraint */ UPDATE x SET x = 1;
ALTER TABLE x ADD CONSTRAINT x CHECK (NOT x IS NULL);
ALTER TABLE x ALTER COLUMN x SET NOT NULL;
DELETE FROM x;
INSERT INTO x VALUES (2, NULL);
ALTER TABLE x ALTER COLUMN x DROP NOT NULL;
/* test multiple set not null at same time */ /* test_a checked by atacc1_constr_a_valid, test_b should fail by table scan */ alter table atacc1 alter test_a set not null, alter test_b set not null;
/* commands order has no importance */ alter table atacc1 alter test_b set not null, alter test_a set not null;
/* valid one by table scan, one by check constraints */ UPDATE x SET x = 1;
alter table atacc1 alter test_b set not null, alter test_a set not null;
alter table atacc1 alter test_a drop not null, alter test_b drop not null;
ALTER TABLE x ADD CONSTRAINT x CHECK (NOT x IS NULL) /* both column has check constraints */;
alter table atacc1 alter test_b set not null, alter test_a set not null;
DROP TABLE x;
/* test inheritance */ CREATE TABLE x (x INT);
CREATE TABLE x (x VARCHAR(255)) INHERITS (x);
ALTER TABLE x ALTER COLUMN x SET NOT NULL;
INSERT INTO x VALUES (NULL);
INSERT INTO x (x, x) VALUES (NULL, 'foo');
ALTER TABLE x ALTER COLUMN x DROP NOT NULL;
INSERT INTO x VALUES (NULL);
INSERT INTO x (x, x) VALUES (NULL, 'foo');
ALTER TABLE ONLY x ALTER COLUMN x SET NOT NULL;
ALTER TABLE x ALTER COLUMN x SET NOT NULL;
DROP TABLE x;
DROP TABLE x;
/* test setting and removing default values */ CREATE TABLE x (x INT DEFAULT 5, x TEXT DEFAULT 'initial_default');
ALTER TABLE x ALTER COLUMN x DROP DEFAULT;
ALTER TABLE x ALTER COLUMN x DROP DEFAULT;
ALTER TABLE x ALTER COLUMN x SET DEFAULT 10;
ALTER TABLE x ALTER COLUMN x SET DEFAULT 'new_default';
SELECT * FROM x;
ALTER TABLE x ALTER COLUMN x SET DEFAULT 'wrong_datatype' /* set defaults to an incorrect type: this should fail */;
ALTER TABLE x ALTER COLUMN x SET DEFAULT 20;
ALTER TABLE x ALTER COLUMN x SET DEFAULT 30 /* set defaults on a non-existent column: this should fail */;
/* set defaults on views: we need to create a view, add a rule */ /* to allow insertions into it, and then alter the view to add */ /* a default */ CREATE VIEW x AS SELECT * FROM x;
create rule def_view_test_ins as 	on insert to def_view_test 	do instead insert into def_test select new.*;
ALTER TABLE x ALTER COLUMN x SET DEFAULT 45;
ALTER TABLE x ALTER COLUMN x SET DEFAULT 'view_default';
SELECT * FROM x;
drop rule def_view_test_ins on def_view_test;
DROP VIEW x;
DROP TABLE x;
ALTER TABLE x DROP COLUMN x /* alter table / drop column tests */ /* try altering system catalogs, should fail */;
ALTER TABLE x DROP COLUMN x /* try altering non-existent table, should fail */;
/* test dropping columns */ CREATE TABLE x (x INT NOT NULL, x INT, x INT NOT NULL, x INT);
INSERT INTO x VALUES (1, 2, 3, 4);
ALTER TABLE x drop a;
ALTER TABLE x drop a;
/* SELECTs */ SELECT * FROM x;
SELECT * FROM x ORDER BY x NULLS LAST;
SELECT * FROM x ORDER BY "x" NULLS LAST;
SELECT * FROM x GROUP BY x;
SELECT * FROM x GROUP BY "x";
SELECT x.* FROM x;
SELECT x FROM x;
SELECT x.x FROM x;
SELECT x, x, x FROM x;
SELECT x, x, x, x FROM x;
SELECT * FROM x WHERE x = 1;
SELECT "x" FROM x;
SELECT x."x" FROM x;
SELECT "x", x, x, x FROM x;
SELECT * FROM x WHERE "x" = 1;
/* UPDATEs */ UPDATE x SET x = 3;
UPDATE x SET x = 2 WHERE x = 3;
UPDATE x SET "x" = 3;
UPDATE x SET x = 2 WHERE "x" = 3;
/* INSERTs */ INSERT INTO x VALUES (10, 11, 12, 13);
INSERT INTO x VALUES (DEFAULT, 11, 12, 13);
INSERT INTO x VALUES (11, 12, 13);
INSERT INTO x (x) VALUES (10);
INSERT INTO x (x) VALUES (DEFAULT);
INSERT INTO x (x, x, x, x) VALUES (10, 11, 12, 13);
INSERT INTO x (x, x, x, x) VALUES (DEFAULT, 11, 12, 13);
INSERT INTO x (x, x, x) VALUES (11, 12, 13);
INSERT INTO x ("x") VALUES (10);
INSERT INTO x ("x") VALUES (DEFAULT);
INSERT INTO x ("x", x, x, x) VALUES (10, 11, 12, 13);
INSERT INTO x ("x", x, x, x) VALUES (DEFAULT, 11, 12, 13);
/* DELETEs */ DELETE FROM x WHERE x = 3;
DELETE FROM x WHERE "x" = 3;
DELETE FROM x;
ALTER TABLE x drop bar /* try dropping a non-existent column, should fail */;
ALTER TABLE x SET  /* try removing an oid column, should succeed (as it's nonexistent) */;
/* try adding an oid column, should fail (not supported) */ alter table atacc1 SET WITH OIDS;
ALTER TABLE x drop xmin /* try dropping the xmin column, should fail */;
/* try creating a view and altering that, should fail */ CREATE VIEW x AS SELECT * FROM x;
SELECT * FROM x;
ALTER TABLE x drop d;
DROP VIEW x;
ANALYZE x /* test some commands to make sure they fail on the dropped column */;
ANALYZE x;
VACUUM analyze atacc1(a);
VACUUM analyze atacc1("........pg.dropped.1........");
COMMENT ON column x.x IS 'testing';
COMMENT ON column x."x" IS 'testing';
ALTER TABLE x ALTER COLUMN x DROP DEFAULT, set storage plain;
ALTER TABLE x ALTER COLUMN "x" DROP DEFAULT, set storage plain;
ALTER TABLE x ALTER COLUMN x DROP DEFAULT, set statistics 0;
ALTER TABLE x ALTER COLUMN "x" DROP DEFAULT, set statistics 0;
ALTER TABLE x ALTER COLUMN x SET DEFAULT 3;
ALTER TABLE x ALTER COLUMN "x" SET DEFAULT 3;
ALTER TABLE x ALTER COLUMN x DROP DEFAULT;
ALTER TABLE x ALTER COLUMN "x" DROP DEFAULT;
ALTER TABLE x ALTER COLUMN x SET NOT NULL;
ALTER TABLE x ALTER COLUMN "x" SET NOT NULL;
ALTER TABLE x ALTER COLUMN x DROP NOT NULL;
ALTER TABLE x ALTER COLUMN "x" DROP NOT NULL;
ALTER TABLE x RENAME TO x, TO x;
ALTER TABLE x RENAME TO x, TO x;
ALTER TABLE x ADD PRIMARY KEY (x NULLS LAST);
ALTER TABLE x ADD PRIMARY KEY ("x" NULLS LAST);
ALTER TABLE x ADD UNIQUE (x);
ALTER TABLE x ADD UNIQUE ("x");
ALTER TABLE x CHECK(x > 3);
ALTER TABLE x CHECK("x" > 3);
CREATE TABLE x (x INT UNIQUE);
ALTER TABLE x ADD FOREIGN KEY (x) REFERENCES x (x);
ALTER TABLE x ADD FOREIGN KEY ("x") REFERENCES x (x);
ALTER TABLE x ADD FOREIGN KEY (x) REFERENCES x (x);
ALTER TABLE x ADD FOREIGN KEY (x) REFERENCES x ("x");
DROP TABLE x;
CREATE INDEX "x" ON x(x NULLS LAST);
CREATE INDEX "x" ON x("x" NULLS LAST);
/* test create as and select into */ INSERT INTO x VALUES (21, 22, 23);
CREATE TABLE x AS SELECT * FROM x;
SELECT * FROM x;
DROP TABLE x;
CREATE TABLE x AS SELECT * FROM x;
SELECT * FROM x;
DROP TABLE x;
ALTER TABLE x drop c /* try dropping all columns */;
ALTER TABLE x drop d;
ALTER TABLE x drop b;
SELECT * FROM x;
DROP TABLE x;
/* test constraint error reporting in presence of dropped columns */ CREATE TABLE x (x SERIAL PRIMARY KEY, x INT CHECK (x < 10));
INSERT INTO x (x) VALUES (100);
ALTER TABLE x DROP COLUMN x;
ALTER TABLE x ADD COLUMN x INT CHECK (x < 10);
INSERT INTO x (x) VALUES (100);
INSERT INTO x (x, x) VALUES (NULL, 0);
DROP TABLE x;
/* test inheritance */ CREATE TABLE x (x INT, x INT, x INT);
INSERT INTO x VALUES (1, 2, 3);
ALTER TABLE x drop a;
CREATE TABLE x (x VARCHAR(255)) INHERITS (x);
INSERT INTO x VALUES (12, 13, 'testing');
SELECT * FROM x;
SELECT * FROM x;
ALTER TABLE x drop c;
SELECT * FROM x;
SELECT * FROM x;
DROP TABLE x;
DROP TABLE x;
/* check error cases for inheritance column merging */ CREATE TABLE x (x DOUBLE, x DECIMAL(10, 4), x TEXT COLLATE "x");
CREATE TABLE x (x FLOAT) INHERITS (x);
/* fail */ CREATE TABLE x (x DECIMAL(10, 7)) INHERITS (x);
/* fail */ CREATE TABLE x (x TEXT COLLATE "x") INHERITS (x);
/* fail */ CREATE TABLE x (x DOUBLE, x DECIMAL(10, 4)) INHERITS (x);
DROP TABLE x;
DROP TABLE x;
/* test copy in/out */ CREATE TABLE x (x INT, x INT, x INT);
INSERT INTO x VALUES (1, 2, 3);
ALTER TABLE x drop a;
COPY INTO x TO x;
COPY INTO x (x) TO x;
COPY INTO x ("x") TO x;
COPY INTO x FROM x;
COPY INTO x FROM x;
COPY INTO x (x) FROM x;
COPY INTO x ("x") FROM x;
COPY INTO x (x, x) FROM x;
DROP TABLE x;
/* test inheritance */ CREATE TABLE x (x INT, x INT, x INT);
CREATE TABLE x (x INT) INHERITS (x);
CREATE TABLE x (x INT) INHERITS (x);
ALTER TABLE x DROP COLUMN x /* these two should fail */;
ALTER TABLE ONLY x DROP COLUMN x;
ALTER TABLE ONLY x DROP COLUMN x /* these three should work */;
ALTER TABLE x DROP COLUMN x;
ALTER TABLE x DROP COLUMN x;
CREATE TABLE x (x INT);
CREATE TABLE x (x INT) INHERITS (x);
CREATE TABLE x (x INT) INHERITS (x);
ALTER TABLE x RENAME COLUMN x TO x /* these three should fail */;
ALTER TABLE ONLY x RENAME COLUMN x TO x;
ALTER TABLE ONLY x RENAME COLUMN x TO x;
ALTER TABLE x RENAME COLUMN x TO x /* these should work */;
ALTER TABLE x RENAME COLUMN x TO x;
ALTER TABLE IF EXISTS x RENAME COLUMN x TO x /* these should work */;
ALTER TABLE IF EXISTS x RENAME COLUMN x TO x;
ALTER TABLE x ADD COLUMN x INT /* this should work */;
ALTER TABLE ONLY x ADD COLUMN x INT /* this should fail */;
/* Test corner cases in dropping of inherited columns */ CREATE TABLE x (x INT, x INT);
CREATE TABLE x (x INT NOT NULL) INHERITS (x);
ALTER TABLE x DROP COLUMN x /* should be rejected since c1.f1 is inherited */;
ALTER TABLE x DROP COLUMN x /* should work */;
/* c1.f1 is still there, but no longer inherited */ SELECT x FROM x;
ALTER TABLE x DROP COLUMN x;
SELECT x FROM x;
DROP TABLE x CASCADE;
CREATE TABLE x (x INT, x INT);
CREATE TABLE x INHERITS (x);
ALTER TABLE x DROP COLUMN x /* should be rejected since c1.f1 is inherited */;
ALTER TABLE x DROP COLUMN x;
/* c1.f1 is dropped now, since there is no local definition for it */ SELECT x FROM x;
DROP TABLE x CASCADE;
CREATE TABLE x (x INT, x INT);
CREATE TABLE x INHERITS (x);
ALTER TABLE x DROP COLUMN x /* should be rejected since c1.f1 is inherited */;
ALTER TABLE ONLY x DROP COLUMN x;
ALTER TABLE x DROP COLUMN x /* c1.f1 is NOT dropped, but must now be considered non-inherited */;
DROP TABLE x CASCADE;
CREATE TABLE x (x INT, x INT);
CREATE TABLE x (x INT NOT NULL) INHERITS (x);
ALTER TABLE x DROP COLUMN x /* should be rejected since c1.f1 is inherited */;
ALTER TABLE ONLY x DROP COLUMN x;
ALTER TABLE x DROP COLUMN x /* c1.f1 is still there, but no longer inherited */;
DROP TABLE x CASCADE;
CREATE TABLE x (x INT, x TEXT);
CREATE TABLE x (x INT, x TEXT, x INT);
CREATE TABLE x (x INT) INHERITS (x, x);
CREATE TABLE x INHERITS (x);
SELECT x, x, x, x FROM x JOIN x ON (x.x = x.x) WHERE x IN ('p1', 'p2', 'c1', 'gc1') AND x > 0 AND NOT x ORDER BY x NULLS LAST, x NULLS LAST;
ALTER TABLE ONLY x DROP COLUMN x /* should work */;
ALTER TABLE x DROP COLUMN x /* should work. Now c1.name is local and inhcount is 0. */;
ALTER TABLE x DROP COLUMN x /* should be rejected since its inherited */;
ALTER TABLE x DROP COLUMN x /* should work, and drop gc1.name along */;
ALTER TABLE x DROP COLUMN x /* should fail: column does not exist */;
ALTER TABLE x DROP COLUMN x /* should work and drop the attribute in all tables */;
/* IF EXISTS test */ CREATE TABLE x;
ALTER TABLE x DROP COLUMN x;
ALTER TABLE x DROP COLUMN IF EXISTS x /* fail */;
/* succeed */ SELECT x, x, x, x FROM x JOIN x ON (x.x = x.x) WHERE x IN ('p1', 'p2', 'c1', 'gc1') AND x > 0 AND NOT x ORDER BY x NULLS LAST, x NULLS LAST;
/* test attinhcount tracking with merged columns */ CREATE TABLE x;
CREATE TABLE x (x TEXT) INHERITS (x);
CREATE TABLE x INHERITS (x);
ALTER TABLE x ADD COLUMN x TEXT;
SELECT CAST(x AS REGCLASS), x, x, x FROM x WHERE x > 0 AND CAST(x AS REGCLASS) IN ('depth0', 'depth1', 'depth2') ORDER BY CAST(CAST(x AS REGCLASS) AS TEXT) NULLS LAST, x NULLS LAST;
/* test renumbering of child-table columns in inherited operations */ CREATE TABLE x (x INT);
CREATE TABLE x (x TEXT, x INT) INHERITS (x);
ALTER TABLE x ADD COLUMN x INT CHECK (x > 0);
ALTER TABLE x ADD COLUMN x TEXT;
INSERT INTO x VALUES (1, 2, 'abc');
INSERT INTO x VALUES (11, 'xyz', 33, 0);
/* should fail */ INSERT INTO x VALUES (11, 'xyz', 33, 22);
SELECT * FROM x;
UPDATE x SET x = x + 1, x = UPPER(x);
SELECT * FROM x;
DROP TABLE x CASCADE;
/* test that operations with a dropped column do not try to reference */ /* its datatype */ create domain mytype as text;
CREATE TEMPORARY TABLE x (x TEXT, x mytype, x TEXT);
INSERT INTO x VALUES ('bb', 'cc', 'dd');
SELECT * FROM x;
drop domain mytype cascade;
SELECT * FROM x;
INSERT INTO x VALUES ('qq', 'rr');
SELECT * FROM x;
UPDATE x SET x = 'zz';
SELECT * FROM x;
SELECT x, MAX(x) FROM x GROUP BY x;
ALTER TABLE x ALTER COLUMN x SET DATA TYPE INT /* Simple tests for alter table column type */;
ALTER TABLE x ALTER COLUMN x SET DATA TYPE VARCHAR(10) /* fails */;
CREATE TABLE x (x serial8, x BOOLEAN, CONSTRAINT x CHECK (x <= 3));
INSERT INTO x (x, x) VALUES (DEFAULT, TRUE);
INSERT INTO x (x, x) VALUES (DEFAULT, FALSE);
SELECT * FROM x;
ALTER TABLE x ALTER COLUMN x SET DATA TYPE BOOLEAN;
ALTER TABLE x ALTER COLUMN x SET DATA TYPE BOOLEAN USING CAST(x AS INT) /* fails */;
ALTER TABLE x ALTER COLUMN x SET DATA TYPE INT /* fails */;
SELECT * FROM x;
INSERT INTO x (x, x) VALUES (45, NULL);
/* fails */ INSERT INTO x (x, x) VALUES (DEFAULT, NULL);
SELECT * FROM x;
ALTER TABLE x ALTER COLUMN x SET DATA TYPE TEXT USING CASE WHEN x IS TRUE THEN 'IT WAS TRUE' WHEN x IS FALSE THEN 'IT WAS FALSE' ELSE 'IT WAS NULL!' END;
SELECT * FROM x;
ALTER TABLE x ALTER COLUMN x SET DATA TYPE BOOLEAN USING CASE WHEN x % 2 = 0 THEN TRUE ELSE FALSE END;
ALTER TABLE x ALTER COLUMN x DROP DEFAULT /* fails */;
ALTER TABLE x ALTER COLUMN x SET DATA TYPE BOOLEAN USING CASE WHEN x % 2 = 0 THEN TRUE ELSE FALSE END;
ALTER TABLE x DROP CONSTRAINT x /* fails */;
ALTER TABLE x DROP CONSTRAINT x;
ALTER TABLE x DROP CONSTRAINT IF EXISTS x /* fails */;
ALTER TABLE x ALTER COLUMN x SET DATA TYPE BOOLEAN USING CASE WHEN x % 2 = 0 THEN TRUE ELSE FALSE END /* succeeds */;
SELECT * FROM x;
DROP TABLE x;
/* Test index handling in alter table column type (cf. bugs #15835, #15865) */ CREATE TABLE x (x INT PRIMARY KEY, x INT UNIQUE, x INT, x INT, x INT);
ALTER TABLE x ADD UNIQUE (x, x);
CREATE INDEX ON x(x NULLS LAST, x NULLS LAST);
CREATE UNIQUE INDEX ON x(x NULLS LAST);
alter table anothertab   alter column f2 type bigint,   alter column f3 type bigint,   alter column f4 type bigint;
ALTER TABLE x ALTER COLUMN x SET DATA TYPE BIGINT;
/* test that USING expressions are parsed before column alter type / drop steps */ CREATE TABLE x (x INT, x TEXT, x TEXT);
INSERT INTO x VALUES (1, 'one', 'uno');
INSERT INTO x VALUES (2, 'two', 'due');
INSERT INTO x VALUES (3, 'three', 'tre');
SELECT * FROM x;
alter table another   alter f1 type text using f2 || ' and ' || f3 || ' more',   alter f2 type bigint using f1 * 10,   drop column f3;
SELECT * FROM x;
DROP TABLE x;
/* Create an index that skips WAL, then perform a SET DATA TYPE that skips */ /* rewriting the index. */ BEGIN;
CREATE TABLE x (x VARCHAR(10) PRIMARY KEY);
ALTER TABLE x ALTER COLUMN x SET DATA TYPE VARCHAR(20);
COMMIT;
/* We disallow changing table's row type if it's used for storage */ CREATE TABLE x (x INT, x TEXT);
CREATE TABLE x (x INT, x at_tab1);
ALTER TABLE x ALTER COLUMN x SET DATA TYPE VARCHAR;
/* fails */ DROP TABLE x;
/* Use of row type in an expression is defended differently */ CREATE TABLE x (x INT, x TEXT, CHECK (CAST((x, x) AS at_tab1) = CAST((1, '42') AS at_tab1)));
ALTER TABLE x ALTER COLUMN x SET DATA TYPE VARCHAR;
/* allowed, but ... */ INSERT INTO x VALUES (1, '42');
/* Check it for a partitioned table, too */ CREATE TABLE x (x INT, x TEXT) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x (x INT, x at_tab1);
ALTER TABLE x ALTER COLUMN x SET DATA TYPE VARCHAR;
/* Alter column type that's part of a partitioned index */ CREATE TABLE x (x INT, x TEXT) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (0) TO (1000);
INSERT INTO x VALUES (512, '0.123');
CREATE TABLE x (x TEXT, x INT);
INSERT INTO x VALUES ('1.234', 1024);
CREATE INDEX ON x(x NULLS LAST);
CREATE INDEX ON x(x NULLS LAST);
/* Alter column type when no table rewrite is required */ /* Also check that comments are preserved */ CREATE TABLE x (x INT, x VARCHAR(64), UNIQUE (x, x)) WITH (PARTITIONED_BY=HASH(x));
COMMENT ON index x IS 'parent index';
CREATE TABLE x PARTITION OF x FOR VALUES WITH (MODULUS 2, REMAINDER 0);
COMMENT ON index x IS 'child 0 index';
CREATE TABLE x PARTITION OF x FOR VALUES WITH (MODULUS 2, REMAINDER 1);
COMMENT ON index x IS 'child 1 index';
INSERT INTO x VALUES (1, 'foo');
INSERT INTO x VALUES (3, 'bar');
CREATE TEMPORARY TABLE x AS SELECT x, x AS x, x AS x FROM x WHERE x LIKE 'at_partitioned%';
SELECT x, x.x = x AS x, CASE x WHEN 0 THEN 'none' WHEN x.x THEN 'own' WHEN x THEN 'orig' ELSE 'OTHER' END AS x, OBJ_DESCRIPTION(x.x, 'pg_class') AS x FROM x AS x LEFT JOIN x USING (x) WHERE x LIKE 'at_partitioned%' ORDER BY x NULLS LAST;
SELECT x, OBJ_DESCRIPTION(x, 'pg_constraint') AS x FROM x WHERE x LIKE 'at_partitioned%' ORDER BY x NULLS LAST;
ALTER TABLE x ALTER COLUMN x SET DATA TYPE VARCHAR(127);
SELECT x, x.x = x AS x, CASE x WHEN 0 THEN 'none' WHEN x.x THEN 'own' WHEN x THEN 'orig' ELSE 'OTHER' END AS x, OBJ_DESCRIPTION(x.x, 'pg_class') AS x FROM x AS x LEFT JOIN x USING (x) WHERE x LIKE 'at_partitioned%' ORDER BY x NULLS LAST;
SELECT x, OBJ_DESCRIPTION(x, 'pg_constraint') AS x FROM x WHERE x LIKE 'at_partitioned%' ORDER BY x NULLS LAST;
/* Don't remove this DROP, it exposes bug #15672 */ DROP TABLE x;
/* disallow recursive containment of row types */ CREATE TEMPORARY TABLE x (x INT);
ALTER TABLE x ADD COLUMN x recur1;
ALTER TABLE x ADD COLUMN x ARRAY<recur1> /* fails */;
/* fails */ create domain array_of_recur1 as recur1[];
ALTER TABLE x ADD COLUMN x array_of_recur1;
/* fails */ CREATE TEMPORARY TABLE x (x INT, x recur1);
ALTER TABLE x ADD COLUMN x recur2;
ALTER TABLE x ADD COLUMN x INT /* fails */;
ALTER TABLE x ALTER COLUMN x SET DATA TYPE recur2;
SELECT x <> 0 AS x FROM x WHERE x = CAST('test_storage' AS REGCLASS);
ALTER TABLE x ALTER COLUMN x DROP DEFAULT, set storage plain;
SELECT x <> 0 AS x FROM x WHERE x = CAST('test_storage' AS REGCLASS);
ALTER TABLE x ALTER COLUMN x DROP DEFAULT, set storage default;
/* re-add TOAST table */ SELECT x <> 0 AS x FROM x WHERE x = CAST('test_storage' AS REGCLASS);
/* test that SET STORAGE propagates to index correctly */ CREATE INDEX x ON x(x NULLS LAST, x NULLS LAST);
ALTER TABLE x ALTER COLUMN x DROP DEFAULT, set storage external;
CREATE TABLE x INHERITS (x);
ALTER TABLE x ALTER COLUMN x SET DATA TYPE DECIMAL;
/* also try noinherit, local, and local+inherited cases */ ALTER TABLE test_inh_check ADD CONSTRAINT bnoinherit CHECK (b > 100) NO INHERIT;
ALTER TABLE x ADD CONSTRAINT x CHECK (x < 1000);
ALTER TABLE x ADD CONSTRAINT x CHECK (x > 1);
ALTER TABLE x ADD CONSTRAINT x CHECK (x > 1);
ALTER TABLE x ALTER COLUMN x SET DATA TYPE DECIMAL;
/* ALTER COLUMN TYPE with different schema in children */ /* Bug at https://postgr.es/m/20170102225618.GA10071@telsasoft.com */ CREATE TABLE x (x INT);
CREATE TABLE x (x SMALLINT) INHERITS (x);
ALTER TABLE x ADD COLUMN x INT;
INSERT INTO x VALUES (1, 2, 3);
ALTER TABLE x ALTER COLUMN x SET DATA TYPE BIGINT USING CAST(x AS BIGINT);
CREATE TABLE x (x SMALLINT, x INT, x BIGINT);
CREATE TABLE x (x INT, x BIGINT, x SMALLINT);
CREATE TABLE x (x BIGINT, x SMALLINT, x INT);
CREATE TABLE x (x SMALLINT, x INT, x BIGINT);
ALTER TABLE test_type_diff2_c1 INHERIT test_type_diff2;
ALTER TABLE test_type_diff2_c2 INHERIT test_type_diff2;
ALTER TABLE test_type_diff2_c3 INHERIT test_type_diff2;
INSERT INTO x VALUES (1, 2, 3);
INSERT INTO x VALUES (4, 5, 6);
INSERT INTO x VALUES (7, 8, 9);
ALTER TABLE x ALTER COLUMN x SET DATA TYPE BIGINT USING CAST(x AS BIGINT);
ALTER TABLE x ALTER COLUMN x SET DATA TYPE INT USING (PG_COLUMN_SIZE(x)) /* whole-row references are disallowed */;
/* check for rollback of ANALYZE corrupting table property flags (bug #11638) */ CREATE TABLE x (x INT PRIMARY KEY, x TEXT);
CREATE TABLE x (x INT REFERENCES x, x TEXT);
BEGIN;
ALTER TABLE x DROP CONSTRAINT x;
ANALYZE x;
ROLLBACK;
/* check column addition within a view (bug #14876) */ CREATE TABLE x (x INT, x TEXT);
INSERT INTO x VALUES (23, 'skidoo');
CREATE VIEW x AS SELECT * FROM x AS x;
CREATE VIEW x AS SELECT *, TO_JSON(x) AS x FROM x AS x;
SELECT * FROM x;
CREATE OR REPLACE VIEW x AS SELECT *, 2 + 2 AS x FROM x AS x;
SELECT * FROM x;
DROP VIEW x;
DROP VIEW x;
DROP TABLE x;
/* related case (bug #17811) */ BEGIN;
CREATE TEMPORARY TABLE x AS SELECT * FROM x;
CREATE TEMPORARY VIEW x AS SELECT CAST(1 AS BIGINT) AS x;
CREATE TEMPORARY VIEW x AS SELECT * FROM x;
CREATE OR REPLACE TEMPORARY VIEW x WITH (security_barrier=TRUE) AS SELECT * FROM x;
CREATE TEMPORARY TABLE x (x BIGINT, x BIGINT);
create rule v1_upd_rule as on update to v1   do also insert into log values (new.*);
UPDATE x SET x = x + 1 WHERE x = 123;
SELECT * FROM x;
SELECT * FROM x;
ROLLBACK;
BEGIN v_relfilenode := relfilenode FROM pg_class WHERE oid = p_tablename;
EXECUTE p_ddl;
COMMIT;
CREATE TABLE x (x TEXT);
INSERT INTO x VALUES ('something');
INSERT INTO x VALUES (NULL);
/* cleanup */ DROP FUNCTION x (REGCLASS, TEXT);
DROP TABLE x;
/* lock levels */ drop type lockmodes;
create type lockmodes as enum (  'SIReadLock' ,'AccessShareLock' ,'RowShareLock' ,'RowExclusiveLock' ,'ShareUpdateExclusiveLock' ,'ShareLock' ,'ShareRowExclusiveLock' ,'ExclusiveLock' ,'AccessExclusiveLock' );
DROP VIEW x;
CREATE OR REPLACE VIEW x AS SELECT CASE WHEN x.x LIKE 'pg_toast%' THEN 'pg_toast' ELSE x.x END, MAX(CAST(x AS lockmodes)) AS x FROM x AS x JOIN x AS x ON x.x = x.x WHERE x = (SELECT x FROM x WHERE x = CAST(PG_CURRENT_XACT_ID() AS xid)) AND x = 'relation' AND x <> (SELECT x FROM x WHERE x = 'pg_catalog') AND x.x <> 'my_locks' GROUP BY x.x;
CREATE TABLE x (x INT PRIMARY KEY, x TEXT);
INSERT INTO x VALUES (1, 'foo');
CREATE TABLE x (x INT PRIMARY KEY, x INT);
INSERT INTO x VALUES (1, 1);
BEGIN;
ALTER TABLE x ALTER COLUMN x DROP DEFAULT, set statistics 150;
SELECT * FROM x ORDER BY 1 NULLS LAST;
ROLLBACK;
BEGIN;
alter table alterlock cluster on alterlock_pkey;
SELECT * FROM x ORDER BY 1 NULLS LAST;
COMMIT;
BEGIN;
ALTER TABLE x SET;
SELECT * FROM x ORDER BY 1 NULLS LAST;
COMMIT;
BEGIN;
ALTER TABLE x SET x = 100;
SELECT * FROM x ORDER BY 1 NULLS LAST;
COMMIT;
BEGIN;
alter table alterlock reset (fillfactor);
SELECT * FROM x ORDER BY 1 NULLS LAST;
COMMIT;
BEGIN;
ALTER TABLE x SET x.x = x;
SELECT * FROM x ORDER BY 1 NULLS LAST;
COMMIT;
BEGIN;
ALTER TABLE x SET x = x;
SELECT * FROM x ORDER BY 1 NULLS LAST;
COMMIT;
BEGIN;
ALTER TABLE x ALTER COLUMN x DROP DEFAULT, set (n_distinct = 1);
SELECT * FROM x ORDER BY 1 NULLS LAST;
ROLLBACK;
/* test that mixing options with different lock levels works as expected */ BEGIN;
ALTER TABLE x SET x = x, x = 80;
SELECT * FROM x ORDER BY 1 NULLS LAST;
COMMIT;
BEGIN;
ALTER TABLE x ALTER COLUMN x DROP DEFAULT, set storage extended;
SELECT * FROM x ORDER BY 1 NULLS LAST;
ROLLBACK;
BEGIN;
ALTER TABLE x ALTER COLUMN x SET DEFAULT 'x';
SELECT * FROM x ORDER BY 1 NULLS LAST;
ROLLBACK;
BEGIN;
create trigger ttdummy 	before delete or update on alterlock 	for each row 	execute procedure 	ttdummy (1, 1);
SELECT * FROM x ORDER BY 1 NULLS LAST;
ROLLBACK;
BEGIN;
SELECT * FROM x ORDER BY 1 NULLS LAST;
ALTER TABLE x ADD FOREIGN KEY (x) REFERENCES x (x);
SELECT * FROM x ORDER BY 1 NULLS LAST;
ROLLBACK;
BEGIN;
ALTER TABLE x ADD CONSTRAINT x FOREIGN KEY (x) REFERENCES x (x) NOT VALID;
SELECT * FROM x ORDER BY 1 NULLS LAST;
COMMIT;
BEGIN;
alter table alterlock2 validate constraint alterlock2nv;
SELECT * FROM x ORDER BY 1 NULLS LAST;
ROLLBACK;
CREATE OR REPLACE VIEW x AS SELECT CASE WHEN x.x LIKE 'pg_toast%' THEN 'pg_toast' ELSE x.x END, MAX(CAST(x AS lockmodes)) AS x FROM x AS x JOIN x AS x ON x.x = x.x WHERE x = (SELECT x FROM x WHERE x = CAST(PG_CURRENT_XACT_ID() AS xid)) AND x = 'relation' AND x <> (SELECT x FROM x WHERE x = 'pg_catalog') AND x.x = 'my_locks' GROUP BY x.x;
ALTER TABLE x SET x = FALSE /* raise exception */;
ALTER VIEW x SET x = FALSE;
alter table my_locks reset (autovacuum_enabled);
alter view my_locks reset (autovacuum_enabled);
BEGIN;
ALTER VIEW x SET x = x;
SELECT * FROM x ORDER BY 1 NULLS LAST;
alter view my_locks reset (security_barrier);
ROLLBACK;
/* this test intentionally applies the ALTER TABLE command against a view, but */ /* uses a view option so we expect this to succeed. This form of SQL is */ /* accepted for historical reasons, as shown in the docs for ALTER VIEW */ BEGIN;
ALTER TABLE x SET x = x;
SELECT * FROM x ORDER BY 1 NULLS LAST;
alter table my_locks reset (security_barrier);
ROLLBACK;
/* cleanup */ DROP TABLE x;
DROP TABLE x;
DROP VIEW x;
drop type lockmodes;
SELECT TEST_STRICT(NULL);
alter function test_strict(text) called on null input;
SELECT TEST_STRICT(NULL);
SELECT NON_STRICT(NULL);
alter function non_strict(text) returns null on null input;
SELECT NON_STRICT(NULL);
/* alter object set schema */ CREATE SCHEMA x.x;
CREATE SCHEMA x.x;
CREATE TABLE x.x (x SERIAL PRIMARY KEY, x INT CHECK (x > 0));
CREATE VIEW x.x AS SELECT * FROM x.x;
CREATE FUNCTION x.x(x) RETURNS INT LANGUAGE sql AS 'select $1+1';
create domain alter1.posint integer check (value > 0);
create type alter1.ctype as (f1 int, f2 text);
create operator alter1.=(procedure = alter1.same, leftarg  = alter1.ctype, rightarg = alter1.ctype);
create operator class alter1.ctype_hash_ops default for type alter1.ctype using hash as   operator 1 alter1.=(alter1.ctype, alter1.ctype);
create conversion alter1.latin1_to_utf8 for 'latin1' to 'utf8' from iso8859_1_to_utf8;
create text search parser alter1.prs(start = prsd_start, gettoken = prsd_nexttoken, end = prsd_end, lextypes = prsd_lextype);
create text search configuration alter1.cfg(parser = alter1.prs);
create text search template alter1.tmpl(init = dsimple_init, lexize = dsimple_lexize);
create text search dictionary alter1.dict(template = alter1.tmpl);
INSERT INTO x.x (x) VALUES (11);
INSERT INTO x.x (x) VALUES (12);
alter table alter1.t1 set schema alter1;
/* no-op, same schema */ alter table alter1.t1 set schema alter2;
alter table alter1.v1 set schema alter2;
alter function alter1.plus1(int) set schema alter2;
alter domain alter1.posint set schema alter2;
alter operator class alter1.ctype_hash_ops using hash set schema alter2;
alter operator family alter1.ctype_hash_ops using hash set schema alter2;
alter operator alter1.=(alter1.ctype, alter1.ctype) set schema alter2;
alter function alter1.same(alter1.ctype, alter1.ctype) set schema alter2;
alter type alter1.ctype set schema alter1;
/* no-op, same schema */ alter type alter1.ctype set schema alter2;
alter conversion alter1.latin1_to_utf8 set schema alter2;
alter text search parser alter1.prs set schema alter2;
alter text search configuration alter1.cfg set schema alter2;
alter text search template alter1.tmpl set schema alter2;
alter text search dictionary alter1.dict set schema alter2;
/* this should succeed because nothing is left in alter1 */ DROP SCHEMA x.x;
INSERT INTO x.x (x) VALUES (13);
INSERT INTO x.x (x) VALUES (14);
SELECT * FROM x.x;
SELECT * FROM x.x;
SELECT x.plus1(41);
/* clean up */ DROP SCHEMA x.x CASCADE;
/* composite types */ CREATE TYPE test_type AS (a int);
/* fails */ ALTER TYPE test_type ADD ATTRIBUTE b text;
/* fails */ ALTER TYPE test_type ALTER ATTRIBUTE b SET DATA TYPE varchar;
/* fails */ ALTER TYPE test_type DROP ATTRIBUTE IF EXISTS c;
ALTER TYPE test_type DROP ATTRIBUTE a, ADD ATTRIBUTE d boolean;
ALTER TYPE test_type RENAME ATTRIBUTE d TO dd;
CREATE TYPE test_type1 AS (a int, b text);
CREATE TABLE x (x INT, x test_type1);
ALTER TYPE test_type1 ALTER ATTRIBUTE b TYPE varchar;
/* fails */ DROP TABLE x;
CREATE TABLE x (x INT, x TEXT);
CREATE INDEX x ON x((CAST(ROW(x, x) AS test_type1)) NULLS LAST);
ALTER TYPE test_type1 ALTER ATTRIBUTE b TYPE varchar;
/* fails */ DROP TABLE x;
DROP TYPE test_type1;
CREATE TYPE test_type2 AS (a int, b text);
CREATE TABLE test_tbl2 OF test_type2;
CREATE TABLE x INHERITS (x);
/* fails */ ALTER TYPE test_type2 ADD ATTRIBUTE c text CASCADE;
/* fails */ ALTER TYPE test_type2 ALTER ATTRIBUTE b TYPE varchar CASCADE;
/* fails */ ALTER TYPE test_type2 DROP ATTRIBUTE b CASCADE;
/* fails */ ALTER TYPE test_type2 RENAME ATTRIBUTE a TO aa CASCADE;
DROP TYPE test_type2;
CREATE TYPE test_typex AS (a int, b text);
CREATE TABLE x (x INT, x test_typex CHECK ((x).x > 0));
ALTER TYPE test_typex DROP ATTRIBUTE a;
/* fails */ ALTER TYPE test_typex DROP ATTRIBUTE a CASCADE;
DROP TYPE test_typex;
/* This test isn't that interesting on its own, but the purpose is to leave */ /* behind a table to test pg_upgrade with. The table has a composite type */ /* column in it, and the composite type has a dropped attribute. */ CREATE TYPE test_type3 AS (a int);
CREATE TABLE x (x) AS SELECT CAST('(1)' AS test_type3);
ALTER TYPE test_type3 DROP ATTRIBUTE a, ADD ATTRIBUTE b int;
CREATE TYPE test_type_empty AS ();
DROP TYPE test_type_empty;
/* typed tables: OF / NOT OF */ CREATE TYPE tt_t0 AS (z inet, x int, y numeric(8,2));
ALTER TYPE tt_t0 DROP ATTRIBUTE z;
CREATE TABLE x (x INT NOT NULL, x DECIMAL(8, 2));
/* OK */ CREATE TABLE x (x INT, x BIGINT);
/* wrong base type */ CREATE TABLE x (x INT, x DECIMAL(9, 2));
/* wrong typmod */ CREATE TABLE x (x DECIMAL(8, 2), x INT);
/* wrong column order */ CREATE TABLE x (x INT);
/* too few columns */ CREATE TABLE x (x INT, x DECIMAL(8, 2), x INT);
/* too few columns */ CREATE TABLE x INHERITS (x);
/* can't have a parent */ CREATE TABLE x (x INT, x TEXT, x DECIMAL(8, 2));
ALTER TABLE x DROP q;
/* OK */ ALTER TABLE tt0 OF tt_t0;
ALTER TABLE tt1 OF tt_t0;
ALTER TABLE tt2 OF tt_t0;
ALTER TABLE tt3 OF tt_t0;
ALTER TABLE tt4 OF tt_t0;
ALTER TABLE tt5 OF tt_t0;
ALTER TABLE tt6 OF tt_t0;
ALTER TABLE tt7 OF tt_t0;
CREATE TYPE tt_t1 AS (x int, y numeric(8,2));
ALTER TABLE tt7 OF tt_t1;
/* reassign an already-typed table */ ALTER TABLE tt7 NOT OF;
CREATE TABLE x INHERITS (x);
ALTER TABLE ONLY x DROP CONSTRAINT x;
/* should fail */ INSERT INTO x (x) VALUES (NULL);
DROP TABLE x CASCADE;
ALTER TABLE IF EXISTS x ADD COLUMN x INT /* IF EXISTS test */;
ALTER TABLE IF EXISTS x ADD CONSTRAINT x PRIMARY KEY (x NULLS LAST);
ALTER TABLE IF EXISTS x CHECK(x BETWEEN 0 AND 10);
ALTER TABLE IF EXISTS x ALTER COLUMN x SET DEFAULT 0;
ALTER TABLE IF EXISTS x RENAME COLUMN x TO x;
ALTER TABLE IF EXISTS tt8 SET SCHEMA alter2;
CREATE TABLE x (x INT);
CREATE SCHEMA x.x;
ALTER TABLE IF EXISTS x ADD COLUMN x INT;
ALTER TABLE IF EXISTS x ADD CONSTRAINT x PRIMARY KEY (x NULLS LAST);
ALTER TABLE IF EXISTS x CHECK(x BETWEEN 0 AND 10);
ALTER TABLE IF EXISTS x ALTER COLUMN x SET DEFAULT 0;
ALTER TABLE IF EXISTS x RENAME COLUMN x TO x;
ALTER TABLE IF EXISTS tt8 SET SCHEMA alter2;
DROP SCHEMA x.x;
/* Check conflicts between index and CHECK constraint names */ CREATE TABLE x (x INT);
ALTER TABLE x CHECK(x > 1);
ALTER TABLE x CHECK(x > 2);
ALTER TABLE x ADD CONSTRAINT x CHECK (x > 3) /* picks nonconflicting name */;
ALTER TABLE x ADD CONSTRAINT x CHECK (x > 4);
ALTER TABLE x ADD UNIQUE (x) /* fail, dup name */;
ALTER TABLE x ADD UNIQUE (x);
ALTER TABLE x ADD CONSTRAINT x UNIQUE (x) /* picks nonconflicting name */;
ALTER TABLE x ADD CONSTRAINT x UNIQUE (x) /* fail, dup name */;
ALTER TABLE x ADD CONSTRAINT x CHECK (x > 5) /* fail, dup name */;
ALTER TABLE x ADD CONSTRAINT x CHECK (x > 6) /* fail, dup name */;
ALTER TABLE x ADD UNIQUE (x);
CREATE INDEX x ON x(x NULLS LAST);
COMMENT ON COLUMN x.x IS 'Column ''id'' on comment_test';
COMMENT ON INDEX x IS 'Simple index on comment_test';
COMMENT ON INDEX x IS 'Index backing the PRIMARY KEY of comment_test';
SELECT COL_DESCRIPTION(CAST('comment_test' AS REGCLASS), 1) AS x;
SELECT CAST(CAST(x AS REGCLASS) AS TEXT) AS x, OBJ_DESCRIPTION(x, 'pg_class') AS x FROM x WHERE x = CAST('comment_test' AS REGCLASS) ORDER BY 1 NULLS LAST, 2 NULLS LAST;
SELECT x AS x, OBJ_DESCRIPTION(x, 'pg_constraint') AS x FROM x WHERE x = CAST('comment_test' AS REGCLASS) ORDER BY 1 NULLS LAST, 2 NULLS LAST;
ALTER TABLE x ALTER COLUMN x SET DATA TYPE INT /* Change the datatype of all the columns. ALTER TABLE is optimized to not */ /* rebuild an index if the new data type is binary compatible with the old */ /* one. Check do a dummy ALTER TABLE that doesn't change the datatype */ /* first, to test that no-op codepath, and another one that does. */;
ALTER TABLE x ALTER COLUMN x SET DATA TYPE TEXT;
ALTER TABLE x ALTER COLUMN x SET DATA TYPE INT;
ALTER TABLE x ALTER COLUMN x SET DATA TYPE TEXT;
ALTER TABLE x ALTER COLUMN x SET DATA TYPE INT;
ALTER TABLE x ALTER COLUMN x SET DATA TYPE BIGINT;
ALTER TABLE x ALTER COLUMN x SET DATA TYPE x /* Some error cases. */;
ALTER TABLE x ALTER COLUMN x SET DATA TYPE x;
ALTER TABLE x ALTER COLUMN x SET DATA TYPE INT COLLATE "x";
/* Check that the comments are intact. */ SELECT COL_DESCRIPTION(CAST('comment_test' AS REGCLASS), 1) AS x;
SELECT CAST(CAST(x AS REGCLASS) AS TEXT) AS x, OBJ_DESCRIPTION(x, 'pg_class') AS x FROM x WHERE x = CAST('comment_test' AS REGCLASS) ORDER BY 1 NULLS LAST, 2 NULLS LAST;
SELECT x AS x, OBJ_DESCRIPTION(x, 'pg_constraint') AS x FROM x WHERE x = CAST('comment_test' AS REGCLASS) ORDER BY 1 NULLS LAST, 2 NULLS LAST;
/* Check compatibility for foreign keys and comments. This is done */ /* separately as rebuilding the column type of the parent leads */ /* to an error and would reduce the test scope. */ CREATE TABLE x (x TEXT CONSTRAINT x REFERENCES x);
CREATE INDEX x ON x(x NULLS LAST);
COMMENT ON COLUMN x.x IS 'Column ''id'' on comment_test_child';
COMMENT ON INDEX x IS 'Index backing the FOREIGN KEY of comment_test_child';
ALTER TABLE x ALTER COLUMN x SET DATA TYPE TEXT /* Change column type of parent */;
ALTER TABLE x ALTER COLUMN x SET DATA TYPE INT USING CAST(x AS INT);
/* Comments should be intact */ SELECT COL_DESCRIPTION(CAST('comment_test_child' AS REGCLASS), 1) AS x;
SELECT CAST(CAST(x AS REGCLASS) AS TEXT) AS x, OBJ_DESCRIPTION(x, 'pg_class') AS x FROM x WHERE x = CAST('comment_test_child' AS REGCLASS) ORDER BY 1 NULLS LAST, 2 NULLS LAST;
SELECT x AS x, OBJ_DESCRIPTION(x, 'pg_constraint') AS x FROM x WHERE x = CAST('comment_test_child' AS REGCLASS) ORDER BY 1 NULLS LAST, 2 NULLS LAST;
/* Check that we map relation oids to filenodes and back correctly.  Only */ /* display bad mappings so the test output doesn't change all the time.  A */ /* filenode function call can return NULL for a relation dropped concurrently */ /* with the call's surrounding query, so ignore a NULL mapped_oid for */ /* relations that no longer exist after all calls finish. */ CREATE TEMPORARY TABLE x AS SELECT x, x, x, x, x FROM x, x AS x WHERE x IN ('r', 'i', 'S', 't', 'm') AND x IS DISTINCT FROM x;
SELECT x.* FROM x AS x LEFT JOIN x AS x ON x.x = x.x WHERE NOT x.x IS NULL OR NOT x.x IS NULL;
/* Checks on creating and manipulation of user defined relations in */ /* pg_catalog. */ SHOW allow_system_table_mods;
/* disallowed because of search_path issues with pg_dump */ CREATE TABLE x.x;
/* instead create in public first, move to catalog */ CREATE TABLE x (x SERIAL PRIMARY KEY, x TEXT);
ALTER TABLE new_system_table SET SCHEMA pg_catalog;
ALTER TABLE new_system_table SET SCHEMA public;
ALTER TABLE new_system_table SET SCHEMA pg_catalog;
/* will be ignored -- already there: */ ALTER TABLE new_system_table SET SCHEMA pg_catalog;
ALTER TABLE x RENAME TO x;
CREATE INDEX x ON x(x NULLS LAST);
INSERT INTO x (x) VALUES ('somedata'), ('otherdata');
UPDATE x SET x = -x;
DELETE FROM x WHERE x = 'somedata';
TRUNCATE TABLE x;
ALTER TABLE x DROP CONSTRAINT x;
ALTER TABLE x DROP COLUMN x;
DROP TABLE x;
/* set logged */ CREATE UNLOGGED TABLE x (x SERIAL PRIMARY KEY, x TEXT);
/* has sequence, toast */ /* check relpersistence of an unlogged table */ SELECT x, x, x FROM x WHERE REGEXP_LIKE(x, '^unlogged1') UNION ALL SELECT x.x || ' toast table', x.x, x.x FROM x AS x JOIN x AS x ON x.x = x.x WHERE REGEXP_LIKE(x.x, '^unlogged1') UNION ALL SELECT x.x || ' toast index', x.x, x.x FROM x AS x JOIN x AS x ON x.x = x.x JOIN x AS x ON x.x = x.x JOIN x AS x ON x.x = x.x WHERE REGEXP_LIKE(x.x, '^unlogged1') ORDER BY x NULLS LAST;
CREATE UNLOGGED TABLE x (x SERIAL PRIMARY KEY, x INT REFERENCES x);
/* foreign key */ CREATE UNLOGGED TABLE x (x SERIAL PRIMARY KEY, x INT REFERENCES x);
ALTER TABLE x SET  /* self-referencing foreign key */;
ALTER TABLE x SET  /* skip self-referencing foreign key */;
ALTER TABLE x SET  /* fails because a foreign key to an unlogged table exists */;
/* check relpersistence of an unlogged table after changing to permanent */ SELECT x, x, x FROM x WHERE REGEXP_LIKE(x, '^unlogged1') UNION ALL SELECT x.x || ' toast table', x.x, x.x FROM x AS x JOIN x AS x ON x.x = x.x WHERE REGEXP_LIKE(x.x, '^unlogged1') UNION ALL SELECT x.x || ' toast index', x.x, x.x FROM x AS x JOIN x AS x ON x.x = x.x JOIN x AS x ON x.x = x.x JOIN x AS x ON x.x = x.x WHERE REGEXP_LIKE(x.x, '^unlogged1') ORDER BY x NULLS LAST;
ALTER TABLE x SET;
/* silently do nothing */ DROP TABLE x;
DROP TABLE x;
DROP TABLE x;
/* set unlogged */ CREATE TABLE x (x SERIAL PRIMARY KEY, x TEXT);
/* has sequence, toast */ /* check relpersistence of a permanent table */ SELECT x, x, x FROM x WHERE REGEXP_LIKE(x, '^logged1') UNION ALL SELECT x.x || ' toast table', x.x, x.x FROM x AS x JOIN x AS x ON x.x = x.x WHERE REGEXP_LIKE(x.x, '^logged1') UNION ALL SELECT x.x || ' toast index', x.x, x.x FROM x AS x JOIN x AS x ON x.x = x.x JOIN x AS x ON x.x = x.x JOIN x AS x ON x.x = x.x WHERE REGEXP_LIKE(x.x, '^logged1') ORDER BY x NULLS LAST;
CREATE TABLE x (x SERIAL PRIMARY KEY, x INT REFERENCES x);
/* foreign key */ CREATE TABLE x (x SERIAL PRIMARY KEY, x INT REFERENCES x);
ALTER TABLE x SET  /* self-referencing foreign key */;
ALTER TABLE x SET  /* fails because a foreign key from a permanent table exists */;
ALTER TABLE x SET  /* skip self-referencing foreign key */;
ALTER TABLE x SET;
/* check relpersistence of a permanent table after changing to unlogged */ SELECT x, x, x FROM x WHERE REGEXP_LIKE(x, '^logged1') UNION ALL SELECT x.x || ' toast table', x.x, x.x FROM x AS x JOIN x AS x ON x.x = x.x WHERE REGEXP_LIKE(x.x, '^logged1') UNION ALL SELECT x.x || ' toast index', x.x, x.x FROM x AS x JOIN x AS x ON x.x = x.x JOIN x AS x ON x.x = x.x JOIN x AS x ON x.x = x.x WHERE REGEXP_LIKE(x.x, '^logged1') ORDER BY x NULLS LAST;
ALTER TABLE x SET;
/* silently do nothing */ DROP TABLE x;
DROP TABLE x;
DROP TABLE x;
/* test ADD COLUMN IF NOT EXISTS */ CREATE TABLE x (x INT);
ALTER TABLE ONLY x ADD COLUMN x INT /* fail because c2 already exists */;
ALTER TABLE ONLY x ADD COLUMN IF NOT EXISTS x INT /* skipping because c2 already exists */;
INSERT INTO x VALUES (42), (43);
CREATE UNIQUE INDEX x ON x(x NULLS LAST);
ALTER TABLE ataddindex   ADD PRIMARY KEY USING INDEX ataddindexi0,   ALTER f1 TYPE BIGINT;
CREATE TABLE x (x VARCHAR(10));
INSERT INTO x (x) VALUES ('foo'), ('a');
ALTER TABLE ataddindex   ALTER f1 SET DATA TYPE TEXT,   ADD EXCLUDE ((f1 LIKE 'a') WITH =);
CREATE TABLE x (x INT, x INT);
ALTER TABLE ataddindex   ADD PRIMARY KEY (id),   ADD FOREIGN KEY (ref_id) REFERENCES ataddindex;
CREATE TABLE x (x INT, x INT);
ALTER TABLE ataddindex   ADD UNIQUE (id),   ADD FOREIGN KEY (ref_id) REFERENCES ataddindex (id);
CREATE TABLE x;
ALTER TABLE atnotnull1   ADD COLUMN a INT,   ALTER a SET NOT NULL;
ALTER TABLE x ADD COLUMN x INT, ADD COLUMN PRIMARY KEY(x);
ALTER TABLE x DROP COLUMN x;
ALTER TABLE x ALTER COLUMN x SET DATA TYPE CHAR(5);
ALTER TABLE x DROP COLUMN x;
ALTER TABLE x ALTER COLUMN x SET DATA TYPE CHAR(5);
ALTER TABLE x SET x = 100 /* specifying storage parameters for partitioned tables is not supported */;
/* partitioned table cannot participate in regular inheritance */ CREATE TABLE x (x INT, x INT);
ALTER TABLE partitioned INHERIT nonpartitioned;
ALTER TABLE nonpartitioned INHERIT partitioned;
/* cannot add NO INHERIT constraint to partitioned tables */ ALTER TABLE partitioned ADD CONSTRAINT chk_a CHECK (a > 0) NO INHERIT;
/* ATTACH PARTITION */ /* check that target table is partitioned */ CREATE TABLE x (x INT);
CREATE TABLE x (LIKE x);
ALTER TABLE unparted ATTACH PARTITION fail_part FOR VALUES IN ('a');
/* check that partition bound is compatible */ CREATE TABLE x (x INT NOT NULL, x CHAR(2) COLLATE "x", CONSTRAINT x CHECK (x > 0)) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x (LIKE x);
ALTER TABLE list_parted ATTACH PARTITION fail_part FOR VALUES FROM (1) TO (10);
DROP TABLE x;
/* check that the table being attached exists */ ALTER TABLE list_parted ATTACH PARTITION nonexistent FOR VALUES IN (1);
/* check ownership of the source table */ CREATE ROLE regress_test_me;
CREATE ROLE regress_test_not_me;
CREATE TABLE x (LIKE x);
ALTER TABLE not_owned_by_me OWNER TO regress_test_not_me;
SET SESSION AUTHORIZATION regress_test_me;
CREATE TABLE x (x INT) WITH (PARTITIONED_BY=LIST(x));
ALTER TABLE owned_by_me ATTACH PARTITION not_owned_by_me FOR VALUES IN (1);
RESET SESSION AUTHORIZATION;
DROP ROLE regress_test_not_me;
DROP ROLE regress_test_me;
/* check that the table being attached is not part of regular inheritance */ CREATE TABLE x (LIKE x);
CREATE TABLE x INHERITS (x);
ALTER TABLE list_parted ATTACH PARTITION child FOR VALUES IN (1);
ALTER TABLE list_parted ATTACH PARTITION parent FOR VALUES IN (1);
DROP TABLE x;
ALTER TABLE x ADD CONSTRAINT x CHECK (x > 0) /* now it should work, with a little tweak */;
ALTER TABLE list_parted ATTACH PARTITION parent FOR VALUES IN (1);
/* test insert/update, per bug #18550 */ INSERT INTO x VALUES (1);
UPDATE x SET x = 2 WHERE x = 1;
DROP TABLE x CASCADE;
/* check any TEMP-ness */ CREATE TEMPORARY TABLE x (x INT) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x (x INT);
ALTER TABLE temp_parted ATTACH PARTITION perm_part FOR VALUES IN (1);
/* check that the table being attached is not a typed table */ CREATE TYPE mytype AS (a int);
CREATE TABLE fail_part OF mytype;
ALTER TABLE list_parted ATTACH PARTITION fail_part FOR VALUES IN (1);
DROP TYPE mytype CASCADE;
/* check that the table being attached has only columns present in the parent */ CREATE TABLE x (LIKE x, x INT);
ALTER TABLE list_parted ATTACH PARTITION fail_part FOR VALUES IN (1);
DROP TABLE x;
/* check that the table being attached has every column of the parent */ CREATE TABLE x (x INT NOT NULL);
ALTER TABLE list_parted ATTACH PARTITION fail_part FOR VALUES IN (1);
DROP TABLE x;
/* check that columns match in type, collation and NOT NULL status */ CREATE TABLE x (x CHAR(3), x INT NOT NULL);
ALTER TABLE list_parted ATTACH PARTITION fail_part FOR VALUES IN (1);
ALTER TABLE x ALTER COLUMN x SET DATA TYPE CHAR(2) COLLATE "x";
ALTER TABLE list_parted ATTACH PARTITION fail_part FOR VALUES IN (1);
DROP TABLE x;
/* check that the table being attached has all constraints of the parent */ CREATE TABLE x (x CHAR(2) COLLATE "x", x INT NOT NULL);
ALTER TABLE list_parted ATTACH PARTITION fail_part FOR VALUES IN (1);
ALTER TABLE x ADD CONSTRAINT x CHECK (x >= 0) /* check that the constraint matches in definition with parent's constraint */;
ALTER TABLE list_parted ATTACH PARTITION fail_part FOR VALUES IN (1);
DROP TABLE x;
/* check the attributes and constraints after partition is attached */ CREATE TABLE x (x INT NOT NULL, x CHAR(2) COLLATE "x", CONSTRAINT x CHECK (x > 0));
ALTER TABLE list_parted ATTACH PARTITION part_1 FOR VALUES IN (1);
/* attislocal and conislocal are always false for merged attributes and constraints respectively. */ SELECT x, x FROM x WHERE x = CAST('part_1' AS REGCLASS) AND x > 0;
SELECT x, x FROM x WHERE x = CAST('part_1' AS REGCLASS) AND x = 'check_a';
ALTER TABLE list_parted ATTACH PARTITION part_fail FOR VALUES IN (2);
DROP TABLE x;
/* check that the new partition won't overlap with an existing partition */ CREATE TABLE x (LIKE x INCLUDING CONSTRAINTS);
ALTER TABLE list_parted ATTACH PARTITION fail_part FOR VALUES IN (1);
DROP TABLE x;
/* check that an existing table can be attached as a default partition */ CREATE TABLE x (LIKE x INCLUDING CONSTRAINTS);
ALTER TABLE list_parted ATTACH PARTITION def_part DEFAULT;
/* check attaching default partition fails if a default partition already */ /* exists */ CREATE TABLE x (LIKE x INCLUDING CONSTRAINTS);
ALTER TABLE list_parted ATTACH PARTITION fail_def_part DEFAULT;
/* check validation when attaching list partitions */ CREATE TABLE x (x INT, x CHAR) WITH (PARTITIONED_BY=LIST(x));
/* check that violating rows are correctly reported */ CREATE TABLE x (LIKE x);
INSERT INTO x VALUES (3, 'a');
ALTER TABLE list_parted2 ATTACH PARTITION part_2 FOR VALUES IN (2);
/* should be ok after deleting the bad row */ DELETE FROM x;
ALTER TABLE list_parted2 ATTACH PARTITION part_2 FOR VALUES IN (2);
/* check partition cannot be attached if default has some row for its values */ CREATE TABLE x PARTITION OF x DEFAULT;
INSERT INTO x VALUES (11, 'z');
CREATE TABLE x (LIKE x);
ALTER TABLE list_parted2 ATTACH PARTITION part_3 FOR VALUES IN (11);
/* should be ok after deleting the bad row */ DELETE FROM x WHERE x = 11;
ALTER TABLE list_parted2 ATTACH PARTITION part_3 FOR VALUES IN (11);
/* adding constraints that describe the desired partition constraint */ /* (or more restrictive) will help skip the validation scan */ CREATE TABLE x (LIKE x, CONSTRAINT x CHECK (x IN (3)));
ALTER TABLE list_parted2 ATTACH PARTITION part_3_4 FOR VALUES IN (3, 4);
/* adding a NOT NULL constraint will cause the scan to be skipped */ ALTER TABLE list_parted2 DETACH PARTITION part_3_4;
ALTER TABLE x ALTER COLUMN x SET NOT NULL;
ALTER TABLE list_parted2 ATTACH PARTITION part_3_4 FOR VALUES IN (3, 4);
ALTER TABLE x ADD CONSTRAINT x CHECK (x IN (5, 6)) /* check if default partition scan skipped */;
CREATE TABLE x PARTITION OF x FOR VALUES IN (55, 66);
/* check validation when attaching range partitions */ CREATE TABLE x (x INT, x INT) WITH (PARTITIONED_BY=RANGE(x, x));
/* check that violating rows are correctly reported */ CREATE TABLE x (x INT NOT NULL CHECK (x = 1), x INT NOT NULL CHECK (x >= 1 AND x <= 10));
INSERT INTO x VALUES (1, 10);
/* Remember the TO bound is exclusive */ ALTER TABLE range_parted ATTACH PARTITION part1 FOR VALUES FROM (1, 1) TO (1, 10);
/* should be ok after deleting the bad row */ DELETE FROM x;
ALTER TABLE range_parted ATTACH PARTITION part1 FOR VALUES FROM (1, 1) TO (1, 10);
/* adding constraints that describe the desired partition constraint */ /* (or more restrictive) will help skip the validation scan */ CREATE TABLE x (x INT NOT NULL CHECK (x = 1), x INT NOT NULL CHECK (x >= 10 AND x < 18));
ALTER TABLE range_parted ATTACH PARTITION part2 FOR VALUES FROM (1, 10) TO (1, 20);
/* Create default partition */ CREATE TABLE x PARTITION OF x DEFAULT;
/* Only one default partition is allowed, hence, following should give error */ CREATE TABLE x (LIKE x INCLUDING CONSTRAINTS);
ALTER TABLE range_parted ATTACH PARTITION partr_def2 DEFAULT;
/* Overlapping partitions cannot be attached, hence, following should give error */ INSERT INTO x VALUES (2, 10);
CREATE TABLE x (LIKE x);
ALTER TABLE range_parted ATTACH partition part3 FOR VALUES FROM (2, 10) TO (2, 20);
/* Attaching partitions should be successful when there are no overlapping rows */ ALTER TABLE range_parted ATTACH partition part3 FOR VALUES FROM (3, 10) TO (3, 20);
/* check that leaf partitions are scanned when attaching a partitioned */ /* table */ CREATE TABLE x (LIKE x) WITH (PARTITIONED_BY=LIST(x));
/* check that violating rows are correctly reported */ CREATE TABLE x PARTITION OF x FOR VALUES IN ('a');
INSERT INTO x (x, x) VALUES (6, 'a');
ALTER TABLE list_parted2 ATTACH PARTITION part_5 FOR VALUES IN (5);
/* delete the faulting row and also add a constraint to skip the scan */ DELETE FROM x WHERE NOT x IN (3);
ALTER TABLE x ADD CONSTRAINT x CHECK (NOT x IS NULL AND x = 5);
ALTER TABLE list_parted2 ATTACH PARTITION part_5 FOR VALUES IN (5);
ALTER TABLE list_parted2 DETACH PARTITION part_5;
ALTER TABLE x DROP CONSTRAINT x;
/* scan should again be skipped, even though NOT NULL is now a column property */ ALTER TABLE part_5 ADD CONSTRAINT check_a CHECK (a IN (5)), ALTER a SET NOT NULL;
ALTER TABLE list_parted2 ATTACH PARTITION part_5 FOR VALUES IN (5);
/* Check the case where attnos of the partitioning columns in the table being */ /* attached differs from the parent.  It should not affect the constraint- */ /* checking logic that allows to skip the scan. */ CREATE TABLE x (x INT, LIKE x, CONSTRAINT x CHECK (NOT x IS NULL AND x = 6));
ALTER TABLE x DROP c;
ALTER TABLE list_parted2 ATTACH PARTITION part_6 FOR VALUES IN (6);
/* Similar to above, but the table being attached is a partitioned table */ /* whose partition has still different attnos for the root partitioning */ /* columns. */ CREATE TABLE x (LIKE x, CONSTRAINT x CHECK (NOT x IS NULL AND x = 7)) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x (x INT, x INT, x INT, LIKE x /* 'a' will have attnum = 4 */, CONSTRAINT x CHECK (x IS NULL OR x = 'a'), CONSTRAINT x CHECK (NOT x IS NULL AND x = 7));
ALTER TABLE x DROP c, DROP d, DROP e;
ALTER TABLE part_7 ATTACH PARTITION part_7_a_null FOR VALUES IN ('a', null);
ALTER TABLE list_parted2 ATTACH PARTITION part_7 FOR VALUES IN (7);
/* Same example, but check this time that the constraint correctly detects */ /* violating rows */ ALTER TABLE list_parted2 DETACH PARTITION part_7;
ALTER TABLE x DROP CONSTRAINT x;
/* thusly, scan won't be skipped */ INSERT INTO x (x, x) VALUES (8, NULL), (9, 'a');
SELECT CAST(x AS REGCLASS), x, x FROM x ORDER BY x NULLS LAST;
ALTER TABLE list_parted2 ATTACH PARTITION part_7 FOR VALUES IN (7);
ALTER TABLE x DROP CONSTRAINT x /* check that leaf partitions of default partition are scanned when */ /* attaching a partitioned table. */;
CREATE TABLE x PARTITION OF x DEFAULT WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN (5);
INSERT INTO x VALUES (5, 'y');
CREATE TABLE x (LIKE x);
ALTER TABLE part_5 ATTACH PARTITION part5_p1 FOR VALUES IN ('y');
/* should be ok after deleting the bad row */ DELETE FROM x WHERE x = 'y';
ALTER TABLE part_5 ATTACH PARTITION part5_p1 FOR VALUES IN ('y');
/* check that the table being attached is not already a partition */ ALTER TABLE list_parted2 ATTACH PARTITION part_2 FOR VALUES IN (2);
/* check that circular inheritance is not allowed */ ALTER TABLE part_5 ATTACH PARTITION list_parted2 FOR VALUES IN ('b');
ALTER TABLE list_parted2 ATTACH PARTITION list_parted2 FOR VALUES IN (0);
/* If a partitioned table being created or an existing table being attached */ /* as a partition does not have a constraint that would allow validation scan */ /* to be skipped, but an individual partition does, then the partition's */ /* validation scan is skipped. */ CREATE TABLE x (x INT, x TEXT) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x DEFAULT WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x (CONSTRAINT x CHECK (NOT x IS NULL AND x = 1)) FOR VALUES IN ('b');
CREATE TABLE x (x INT, x TEXT);
ALTER TABLE quuux ATTACH PARTITION quuux1 FOR VALUES IN (1);
/* validate! */ CREATE TABLE x (x INT, x TEXT);
ALTER TABLE quuux ATTACH PARTITION quuux2 FOR VALUES IN (2);
/* should validate for quuux1, but not for quuux2 */ CREATE TABLE x PARTITION OF x FOR VALUES IN (1);
CREATE TABLE x PARTITION OF x FOR VALUES IN (2);
DROP TABLE x;
CREATE TABLE x PARTITION OF x FOR VALUES WITH (MODULUS 4, REMAINDER 0);
CREATE TABLE x (LIKE x);
ALTER TABLE hash_parted ATTACH PARTITION fail_part FOR VALUES WITH (MODULUS 8, REMAINDER 4);
ALTER TABLE hash_parted ATTACH PARTITION fail_part FOR VALUES WITH (MODULUS 8, REMAINDER 0);
DROP TABLE x;
/* check validation when attaching hash partitions */ /* check that violating rows are correctly reported */ CREATE TABLE x (LIKE x);
INSERT INTO x VALUES (3, 0);
ALTER TABLE hash_parted ATTACH PARTITION hpart_2 FOR VALUES WITH (MODULUS 4, REMAINDER 1);
/* should be ok after deleting the bad row */ DELETE FROM x;
ALTER TABLE hash_parted ATTACH PARTITION hpart_2 FOR VALUES WITH (MODULUS 4, REMAINDER 1);
/* check that leaf partitions are scanned when attaching a partitioned */ /* table */ CREATE TABLE x (LIKE x) WITH (PARTITIONED_BY=LIST(x));
/* check that violating rows are correctly reported */ CREATE TABLE x PARTITION OF x FOR VALUES IN ('1', '2', '3');
INSERT INTO x (x, x) VALUES (7, 1);
ALTER TABLE hash_parted ATTACH PARTITION hpart_5 FOR VALUES WITH (MODULUS 4, REMAINDER 2);
/* should be ok after deleting the bad row */ DELETE FROM x;
ALTER TABLE hash_parted ATTACH PARTITION hpart_5 FOR VALUES WITH (MODULUS 4, REMAINDER 2);
/* check that the table being attach is with valid modulus and remainder value */ CREATE TABLE x (LIKE x);
ALTER TABLE hash_parted ATTACH PARTITION fail_part FOR VALUES WITH (MODULUS 0, REMAINDER 1);
ALTER TABLE hash_parted ATTACH PARTITION fail_part FOR VALUES WITH (MODULUS 8, REMAINDER 8);
ALTER TABLE hash_parted ATTACH PARTITION fail_part FOR VALUES WITH (MODULUS 3, REMAINDER 2);
DROP TABLE x;
/* DETACH PARTITION */ /* check that the table is partitioned at all */ CREATE TABLE x (x INT);
ALTER TABLE regular_table DETACH PARTITION any_name;
ALTER TABLE regular_table DETACH PARTITION any_name CONCURRENTLY;
ALTER TABLE regular_table DETACH PARTITION any_name FINALIZE;
DROP TABLE x;
/* check that the partition being detached exists at all */ ALTER TABLE list_parted2 DETACH PARTITION part_4;
ALTER TABLE hash_parted DETACH PARTITION hpart_4;
/* check that the partition being detached is actually a partition of the parent */ CREATE TABLE x (x INT);
ALTER TABLE list_parted2 DETACH PARTITION not_a_part;
ALTER TABLE list_parted2 DETACH PARTITION part_1;
ALTER TABLE hash_parted DETACH PARTITION not_a_part;
DROP TABLE x;
/* check that, after being detached, attinhcount/coninhcount is dropped to 0 and */ /* attislocal/conislocal is set to true */ ALTER TABLE list_parted2 DETACH PARTITION part_3_4;
SELECT x, x FROM x WHERE x = CAST('part_3_4' AS REGCLASS) AND x > 0;
SELECT x, x FROM x WHERE x = CAST('part_3_4' AS REGCLASS) AND x = 'check_a';
DROP TABLE x;
/* check that a detached partition is not dropped on dropping a partitioned table */ CREATE TABLE x (x INT) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (0) TO (100);
ALTER TABLE range_parted2 DETACH PARTITION part_rp;
DROP TABLE x;
SELECT * FROM x;
DROP TABLE x;
/* concurrent detach */ CREATE TABLE x (x INT) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (0) TO (100);
BEGIN;
/* doesn't work in a partition block */ ALTER TABLE range_parted2 DETACH PARTITION part_rp CONCURRENTLY;
COMMIT;
CREATE TABLE x PARTITION OF x DEFAULT;
/* doesn't work if there's a default partition */ ALTER TABLE range_parted2 DETACH PARTITION part_rp CONCURRENTLY;
/* doesn't work for the default partition */ ALTER TABLE range_parted2 DETACH PARTITION part_rpd CONCURRENTLY;
DROP TABLE x;
/* works fine */ ALTER TABLE range_parted2 DETACH PARTITION part_rp CONCURRENTLY;
ALTER TABLE range_parted2 DETACH PARTITION part_rp100 CONCURRENTLY;
ALTER TABLE ONLY x ADD COLUMN x INT /* Check ALTER TABLE commands for partitioned tables and partitions */ /* cannot add/drop column to/from *only* the parent */;
ALTER TABLE ONLY x DROP COLUMN x;
ALTER TABLE x ADD COLUMN x TEXT /* cannot add a column to partition or drop an inherited one */;
ALTER TABLE x DROP COLUMN x;
ALTER TABLE x RENAME COLUMN x TO x /* Nor rename, alter type */;
ALTER TABLE x ALTER COLUMN x SET DATA TYPE TEXT;
ALTER TABLE ONLY x ALTER COLUMN x SET NOT NULL /* cannot add NOT NULL or check constraints to *only* the parent, when */ /* partitions exist */;
ALTER TABLE ONLY x ADD CONSTRAINT x CHECK (x <> 'zz');
ALTER TABLE x ALTER COLUMN x SET NOT NULL /* dropping them is ok though */;
ALTER TABLE ONLY x ALTER COLUMN x DROP NOT NULL;
ALTER TABLE x ADD CONSTRAINT x CHECK (x <> 'zz');
ALTER TABLE ONLY x DROP CONSTRAINT x;
ALTER TABLE ONLY x ALTER COLUMN x SET NOT NULL;
ALTER TABLE ONLY x ADD CONSTRAINT x CHECK (x > 0);
DROP TABLE x;
/* cannot drop inherited NOT NULL or check constraints from partition */ ALTER TABLE list_parted2 ALTER b SET NOT NULL, ADD CONSTRAINT check_a2 CHECK (a > 0);
ALTER TABLE x ALTER COLUMN x DROP NOT NULL;
ALTER TABLE x DROP CONSTRAINT x;
/* can't drop NOT NULL from under an invalid PK */ CREATE TABLE x (x INT NOT NULL) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN (1);
ALTER TABLE ONLY x ADD PRIMARY KEY (x NULLS LAST);
ALTER TABLE ONLY x DROP CONSTRAINT x;
/* Doesn't make sense to add NO INHERIT constraints on partitioned tables */ ALTER TABLE list_parted2 add constraint check_b2 check (b <> 'zz') NO INHERIT;
/* check that a partition cannot participate in regular inheritance */ CREATE TABLE x INHERITS (x);
CREATE TABLE x (LIKE x);
ALTER TABLE inh_test INHERIT part_2;
ALTER TABLE part_2 INHERIT inh_test;
ALTER TABLE x DROP COLUMN x;
ALTER TABLE x ALTER COLUMN x SET DATA TYPE TEXT;
ALTER TABLE x DROP COLUMN x /* dropping non-partition key columns should be allowed on the parent table. */;
SELECT * FROM x;
DROP TABLE x;
DROP TABLE x;
/* more tests for certain multi-level partitioning scenarios */ CREATE TABLE x (x INT, x INT) WITH (PARTITIONED_BY=RANGE(x, x));
CREATE TABLE x (x INT, x INT NOT NULL) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x (LIKE x);
ALTER TABLE x drop a;
ALTER TABLE x ADD COLUMN x INT;
ALTER TABLE x drop a;
ALTER TABLE x ADD COLUMN x INT NOT NULL;
/* attnum for key attribute 'a' is different in p, p1, and p11 */ SELECT CAST(x AS REGCLASS), x, x FROM x WHERE x = 'a' AND (x = CAST('p' AS REGCLASS) OR x = CAST('p1' AS REGCLASS) OR x = CAST('p11' AS REGCLASS)) ORDER BY CAST(CAST(x AS REGCLASS) AS TEXT) NULLS LAST;
alter table p1 attach partition p11 for values from (2) to (5);
INSERT INTO x (x, x) VALUES (2, 3);
/* check that partition validation scan correctly detects violating rows */ alter table p attach partition p1 for values from (1, 2) to (1, 10);
/* cleanup */ DROP TABLE x;
DROP TABLE x;
/* validate constraint on partitioned tables should only scan leaf partitions */ CREATE TABLE x (x INT) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN (0, 1);
ALTER TABLE x ADD CONSTRAINT x CHECK (x > 0) NOT VALID;
alter table parted_validate_test validate constraint parted_validate_test_chka;
DROP TABLE x;
/* test alter column options */ CREATE TABLE x (x INT);
INSERT INTO x VALUES (1);
ALTER TABLE x ALTER COLUMN x DROP DEFAULT, SET (n_distinct = 1, n_distinct_inherited = 2);
ALTER TABLE attmp ALTER COLUMN i RESET (n_distinct_inherited);
ANALYZE x;
DROP TABLE x;
DROP USER regress_alter_table_user1;
/* check that violating rows are correctly reported when attaching as the */ /* default partition */ CREATE TABLE x (x INT) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN (1);
CREATE TABLE x (x INT, x INT);
ALTER TABLE x drop b;
INSERT INTO x VALUES (1), (2);
/* error because its constraint as the default partition would be violated */ /* by the row containing 1 */ alter table defpart_attach_test attach partition defpart_attach_test_d default;
DELETE FROM x WHERE x = 1;
ALTER TABLE x CHECK(x > 1);
/* should be attached successfully and without needing to be scanned */ alter table defpart_attach_test attach partition defpart_attach_test_d default;
/* check that attaching a partition correctly reports any rows in the default */ /* partition that should not be there for the new partition to be attached */ /* successfully */ CREATE TABLE x (LIKE x);
alter table defpart_attach_test attach partition defpart_attach_test_2 for values in (2);
DROP TABLE x;
/* check combinations of temporary and permanent relations when attaching */ /* partitions. */ CREATE TABLE x (x INT) WITH (PARTITIONED_BY=LIST(x));
CREATE TEMPORARY TABLE x (x INT) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x (x INT);
CREATE TEMPORARY TABLE x (x INT);
alter table temp_part_parent attach partition perm_part_child default;
/* error */ alter table perm_part_parent attach partition temp_part_child default;
/* error */ alter table temp_part_parent attach partition temp_part_child default;
/* ok */ DROP TABLE x CASCADE;
DROP TABLE x CASCADE;
/* check that attaching partitions to a table while it is being used is */ /* prevented */ CREATE TABLE x (x INT) WITH (PARTITIONED_BY=LIST(x));
EXECUTE 'alter table tab_part_attach attach partition tab_part_attach_1 for values in (1)';
x AS x;
create trigger trig_part_attach before insert on tab_part_attach   for each statement execute procedure func_part_attach();
INSERT INTO x VALUES (1);
DROP TABLE x;
DROP FUNCTION x;
create operator class at_test_sql_partop for type int4 using btree as     operator 1 < (int4, int4), operator 2 <= (int4, int4),     operator 3 = (int4, int4), operator 4 >= (int4, int4),     operator 5 > (int4, int4), function 1 at_test_sql_partop(int4, int4);
CREATE TABLE x (x INT);
alter table at_test_sql_partop attach partition at_test_sql_partop_1 for values from (0) to (10);
DROP TABLE x;
drop operator class at_test_sql_partop using btree;
DROP FUNCTION x;
/* Test case for bug #16242 */ /* We create a parent and child where the child has missing */ /* non-null attribute values, and arrange to pass them through */ /* tuple conversion from the child to the parent tupdesc */ CREATE TABLE x (x INT, x INT NOT NULL DEFAULT 1) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x (x INT);
INSERT INTO x VALUES (1);
ALTER TABLE x ADD COLUMN x INT NOT NULL DEFAULT 1;
/* (at this point bar2 contains tuple with natts=1) */ alter table bar1 attach partition bar2 default;
/* this works: */ SELECT * FROM x;
BEGIN for r in select * from old loop       raise info 'a=%, b=%', r.a, r.b;
x AS x;
COMMIT;
create trigger xtrig   after update on bar1   referencing old table as old   for each statement execute procedure xtrig();
UPDATE x SET x = x + 1;
/* End test case for bug #16242 */ /* Test case for bug #17409 */ CREATE TABLE x (x INT CONSTRAINT x PRIMARY KEY);
CREATE TABLE x (x INT REFERENCES x (x));
ALTER TABLE x ALTER COLUMN x SET DATA TYPE BIGINT;
ALTER TABLE x ALTER COLUMN x SET DATA TYPE BIGINT;
CREATE TABLE x (x INT CONSTRAINT x PRIMARY KEY);
alter table attbl replica identity using index pk_attbl;
CREATE TABLE x (x INT REFERENCES x (x));
ALTER TABLE x ALTER COLUMN x SET DATA TYPE BIGINT;
ALTER TABLE x ALTER COLUMN x SET DATA TYPE BIGINT;
/* End test case for bug #17409 */ /* Test that ALTER TABLE rewrite preserves a clustered index */ /* for normal indexes and indexes on constraints. */ CREATE TABLE x (x INT);
ALTER TABLE x ADD PRIMARY KEY (x NULLS LAST);
CREATE INDEX x ON x(x NULLS LAST);
alter table alttype_cluster cluster on alttype_cluster_ind;
/* Normal index remains clustered. */ SELECT CAST(x AS REGCLASS), x FROM x WHERE x = CAST('alttype_cluster' AS REGCLASS) ORDER BY CAST(CAST(x AS REGCLASS) AS TEXT) NULLS LAST;
ALTER TABLE x ALTER COLUMN x SET DATA TYPE BIGINT;
SELECT CAST(x AS REGCLASS), x FROM x WHERE x = CAST('alttype_cluster' AS REGCLASS) ORDER BY CAST(CAST(x AS REGCLASS) AS TEXT) NULLS LAST;
/* Constraint index remains clustered. */ alter table alttype_cluster cluster on alttype_cluster_pkey;
SELECT CAST(x AS REGCLASS), x FROM x WHERE x = CAST('alttype_cluster' AS REGCLASS) ORDER BY CAST(CAST(x AS REGCLASS) AS TEXT) NULLS LAST;
ALTER TABLE x ALTER COLUMN x SET DATA TYPE INT;
SELECT CAST(x AS REGCLASS), x FROM x WHERE x = CAST('alttype_cluster' AS REGCLASS) ORDER BY CAST(CAST(x AS REGCLASS) AS TEXT) NULLS LAST;
DROP TABLE x;
/* Check that attaching or detaching a partitioned partition correctly leads */ /* to its partitions' constraint being updated to reflect the parent's */ /* newly added/removed constraint */ CREATE TABLE x (x INT, x INT) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x (x INT, x INT) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN (1);
/* insert a row directly into the leaf partition so that its partition */ /* constraint is built and stored in the relcache */ INSERT INTO x VALUES (1, 1);
/* the following better invalidate the partition constraint of the leaf */ /* partition too... */ alter table target_parted attach partition attach_parted for values in (1);
/* ...such that the following insert fails */ INSERT INTO x VALUES (2, 1);
/* ...and doesn't when the partition is detached along with its own partition */ alter table target_parted detach partition attach_parted;
INSERT INTO x VALUES (2, 1);
/* Test altering table having publication */ CREATE SCHEMA x.x;
CREATE SCHEMA x.x;
CREATE TABLE x.x (x INT);
SET x = 'ERROR';
create publication pub1 for table alter1.t1, tables in schema alter2;
RESET client_min_messages;
alter table alter1.t1 set schema alter2;
DROP SCHEMA x.x CASCADE;
DROP SCHEMA x.x CASCADE;
/* Test index AM property-reporting functions */ SELECT x, PG_INDEXAM_HAS_PROPERTY(x.x, x) AS "x", PG_INDEX_HAS_PROPERTY(CAST('onek_hundred' AS REGCLASS), x) AS "x", PG_INDEX_COLUMN_HAS_PROPERTY(CAST('onek_hundred' AS REGCLASS), 1, x) AS "x" FROM x AS x, UNNEST(CAST(ARRAY('asc', 'desc', 'nulls_first', 'nulls_last', 'orderable', 'distance_orderable', 'returnable', 'search_array', 'search_nulls', 'clusterable', 'index_scan', 'bitmap_scan', 'backward_scan', 'can_order', 'can_unique', 'can_multi_col', 'can_exclude', 'can_include', 'bogus') AS ARRAY<TEXT>)) WITH ORDINALITY AS x(x) WHERE x.x = 'btree' ORDER BY x NULLS LAST;
SELECT x, PG_INDEXAM_HAS_PROPERTY(x.x, x) AS "x", PG_INDEX_HAS_PROPERTY(CAST('gcircleind' AS REGCLASS), x) AS "x", PG_INDEX_COLUMN_HAS_PROPERTY(CAST('gcircleind' AS REGCLASS), 1, x) AS "x" FROM x AS x, UNNEST(CAST(ARRAY('asc', 'desc', 'nulls_first', 'nulls_last', 'orderable', 'distance_orderable', 'returnable', 'search_array', 'search_nulls', 'clusterable', 'index_scan', 'bitmap_scan', 'backward_scan', 'can_order', 'can_unique', 'can_multi_col', 'can_exclude', 'can_include', 'bogus') AS ARRAY<TEXT>)) WITH ORDINALITY AS x(x) WHERE x.x = 'gist' ORDER BY x NULLS LAST;
SELECT x, PG_INDEX_COLUMN_HAS_PROPERTY(CAST('onek_hundred' AS REGCLASS), 1, x) AS x, PG_INDEX_COLUMN_HAS_PROPERTY(CAST('hash_i4_index' AS REGCLASS), 1, x) AS x, PG_INDEX_COLUMN_HAS_PROPERTY(CAST('gcircleind' AS REGCLASS), 1, x) AS x, PG_INDEX_COLUMN_HAS_PROPERTY(CAST('sp_radix_ind' AS REGCLASS), 1, x) AS x, PG_INDEX_COLUMN_HAS_PROPERTY(CAST('sp_quad_ind' AS REGCLASS), 1, x) AS x, PG_INDEX_COLUMN_HAS_PROPERTY(CAST('botharrayidx' AS REGCLASS), 1, x) AS x, PG_INDEX_COLUMN_HAS_PROPERTY(CAST('brinidx' AS REGCLASS), 1, x) AS x FROM UNNEST(CAST(ARRAY('asc', 'desc', 'nulls_first', 'nulls_last', 'orderable', 'distance_orderable', 'returnable', 'search_array', 'search_nulls', 'bogus') AS ARRAY<TEXT>)) WITH ORDINALITY AS x(x) ORDER BY x NULLS LAST;
SELECT x, PG_INDEX_HAS_PROPERTY(CAST('onek_hundred' AS REGCLASS), x) AS x, PG_INDEX_HAS_PROPERTY(CAST('hash_i4_index' AS REGCLASS), x) AS x, PG_INDEX_HAS_PROPERTY(CAST('gcircleind' AS REGCLASS), x) AS x, PG_INDEX_HAS_PROPERTY(CAST('sp_radix_ind' AS REGCLASS), x) AS x, PG_INDEX_HAS_PROPERTY(CAST('botharrayidx' AS REGCLASS), x) AS x, PG_INDEX_HAS_PROPERTY(CAST('brinidx' AS REGCLASS), x) AS x FROM UNNEST(CAST(ARRAY('clusterable', 'index_scan', 'bitmap_scan', 'backward_scan', 'bogus') AS ARRAY<TEXT>)) WITH ORDINALITY AS x(x) ORDER BY x NULLS LAST;
SELECT x, x, PG_INDEXAM_HAS_PROPERTY(x.x, x) AS x FROM x AS x, UNNEST(CAST(ARRAY('can_order', 'can_unique', 'can_multi_col', 'can_exclude', 'can_include', 'bogus') AS ARRAY<TEXT>)) WITH ORDINALITY AS x(x) WHERE x = 'i' ORDER BY x NULLS LAST, x NULLS LAST;
/* additional checks for pg_index_column_has_property */ CREATE TEMPORARY TABLE x (x INT, x INT, x INT, x INT);
CREATE INDEX x ON x(x DESC NULLS FIRST, x ASC NULLS LAST, x, x NULLS LAST);
SELECT x, x, PG_INDEX_COLUMN_HAS_PROPERTY(x, x, x) FROM (VALUES (CAST('fooindex' AS REGCLASS))) AS x, (VALUES (1, 'orderable'), (2, 'asc'), (3, 'desc'), (4, 'nulls_first'), (5, 'nulls_last'), (6, 'bogus')) AS x, x AS x ORDER BY x NULLS LAST, x NULLS LAST;
CREATE INDEX x ON x(x NULLS LAST) INCLUDE (x, x);
SELECT x, x, PG_INDEX_COLUMN_HAS_PROPERTY(x, x, x) FROM (VALUES (CAST('foocover' AS REGCLASS))) AS x, (VALUES (1, 'orderable'), (2, 'asc'), (3, 'desc'), (4, 'nulls_first'), (5, 'nulls_last'), (6, 'distance_orderable'), (7, 'returnable'), (8, 'bogus')) AS x, x AS x ORDER BY x NULLS LAST, x NULLS LAST;
CREATE TABLE x (x INT, x ARRAY<INT>, x ARRAY<TEXT>);
ANALYZE x;
UPDATE x SET x[-1] = '1.1';
UPDATE x SET x[0] = '2.2';
INSERT INTO x (x) VALUES ('{"too long"}');
/* error, type mismatch */ SELECT * FROM x;
SELECT x.x[0], x.x[0][0][0], x.x[0], x.x[0][0], x.x[-1] FROM x;
SELECT x[0], x[0][0][0], x[0], x[0][0], x[-1] FROM x;
SELECT x[1 : 3], x[1 : 1][1 : 2][1 : 2], x[1 : 2], x[1 : 1][1 : 2] FROM x;
SELECT ARRAY_NDIMS(x) AS x, ARRAY_NDIMS(x) AS x, ARRAY_NDIMS(x) AS x FROM x;
SELECT ARRAY_DIMS(x) AS x, ARRAY_DIMS(x) AS x, ARRAY_DIMS(x) AS x FROM x;
/* returns nothing */ SELECT * FROM x WHERE x[0] < 5 AND x = CAST('{"foobar"}' AS _name);
UPDATE x SET x[1 : 2] = '{16,25}' WHERE NOT x = CAST('{}' AS _int2);
UPDATE x SET x[1 : 1][1 : 1][1 : 2] = '{113, 117}', x[1 : 1][1 : 2][2 : 2] = '{142, 147}' WHERE ARRAY_DIMS(x) = '[1:1][1:2][1:2]';
UPDATE x SET x[2 : 2] = '{"new_word"}' WHERE NOT ARRAY_DIMS(x) IS NULL;
SELECT x, x, x FROM x;
SELECT x[1 : 3], x[1 : 1][1 : 2][1 : 2], x[1 : 2], x[1 : 1][2 : 2] FROM x;
SELECT x[1 : 1][1][1], x[1 : 1][1] FROM x;
INSERT INTO x (x) VALUES ('{1,null,3}');
SELECT x FROM x;
UPDATE x SET x[3] = NULL WHERE x[1] IS NULL;
SELECT x FROM x WHERE x[1] IS NULL;
DELETE FROM x WHERE x[1] IS NULL AND x IS NULL;
SELECT x, x, x FROM x;
/* test non-error-throwing API */ SELECT PG_INPUT_IS_VALID('{1,2,3}', 'integer[]');
SELECT PG_INPUT_IS_VALID('{1,2', 'integer[]');
SELECT PG_INPUT_IS_VALID('{1,zed}', 'integer[]');
SELECT * FROM x;
/* test mixed slice/scalar subscripting */ SELECT CAST('{{1,2,3},{4,5,6},{7,8,9}}' AS ARRAY<INT>);
SELECT (CAST('{{1,2,3},{4,5,6},{7,8,9}}' AS ARRAY<INT>))[1 : 2][1];
SELECT CAST('[0:2][0:2]={{1,2,3},{4,5,6},{7,8,9}}' AS ARRAY<INT>);
SELECT (CAST('[0:2][0:2]={{1,2,3},{4,5,6},{7,8,9}}' AS ARRAY<INT>))[1 : 2][1];
/* check subscription corner cases */ /* More subscripts than MAXDIM (6) */ SELECT (CAST('{}' AS ARRAY<INT>))[0][2][2][3][4][5][6];
/* NULL index yields NULL when selecting */ SELECT (CAST('{{{1},{2},{3}},{{4},{5},{6}}}' AS ARRAY<INT>))[0][NULL][0];
SELECT (CAST('{{{1},{2},{3}},{{4},{5},{6}}}' AS ARRAY<INT>))[0][NULL : 1][1];
SELECT (CAST('{{{1},{2},{3}},{{4},{5},{6}}}' AS ARRAY<INT>))[0][1 : NULL][1];
/* NULL index in assignment is an error */ UPDATE x SET x[NULL] = '{"can''t assign"}' WHERE NOT ARRAY_DIMS(x) IS NULL;
UPDATE x SET x[NULL : 1] = '{"can''t assign"}' WHERE NOT ARRAY_DIMS(x) IS NULL;
UPDATE x SET x[1 : NULL] = '{"can''t assign"}' WHERE NOT ARRAY_DIMS(x) IS NULL;
/* Un-subscriptable type */ SELECT (CURRENT_TIMESTAMP())[1];
/* test slices with empty lower and/or upper index */ CREATE TEMPORARY TABLE x (x ARRAY<SMALLINT>, x ARRAY<ARRAY<SMALLINT>>);
INSERT INTO x VALUES ('{1,2,3,4,5}', '{{1,2,3}, {4,5,6}, {7,8,9}}');
INSERT INTO x VALUES ('[0:4]={1,2,3,4,5}', '[0:2][0:2]={{1,2,3}, {4,5,6}, {7,8,9}}');
SELECT * FROM x;
SELECT x[ : 3], x[ : 2][ : 2] FROM x;
SELECT x[2 : ], x[2 : ][2 : ] FROM x;
SELECT x[ : ], x[ : ] FROM x;
/* updates */ UPDATE x SET x[ : 3] = '{11, 12, 13}', x[ : 2][ : 2] = '{{11,12}, {14,15}}' WHERE ARRAY_LOWER(x, 1) = 1;
SELECT * FROM x;
UPDATE x SET x[3 : ] = '{23, 24, 25}', x[2 : ][2 : ] = '{{25,26}, {28,29}}';
SELECT * FROM x;
UPDATE x SET x[ : ] = '{11, 12, 13, 14, 15}';
SELECT * FROM x;
UPDATE x SET x[ : ] = '{23, 24, 25}';
/* fail, too small */ INSERT INTO x VALUES (NULL, NULL);
UPDATE x SET x[ : ] = '{11, 12, 13, 14, 15}';
/* fail, no good with null */ /* we want to work with a point_tbl that includes a null */ CREATE TEMPORARY TABLE x AS SELECT * FROM x.x;
INSERT INTO x (x) VALUES (NULL);
/* check with fixed-length-array type, such as point */ SELECT x[0 : 1] FROM x;
SELECT x[0 : ] FROM x;
SELECT x[ : 1] FROM x;
SELECT x[ : ] FROM x;
/* subscript assignments to fixed-width result in NULL if previous value is NULL */ UPDATE x SET x[-1] = 10 WHERE x IS NULL RETURNING *;
/* NULL assignments get ignored */ UPDATE x SET x[-1] = NULL WHERE CAST(x AS TEXT) = CAST(CAST('(10,10)' AS point) AS TEXT) RETURNING *;
/* but non-NULL subscript assignments work */ UPDATE x SET x[-1] = -10, x[0] = -10 WHERE CAST(x AS TEXT) = CAST(CAST('(10,10)' AS point) AS TEXT) RETURNING *;
/* but not to expand the range */ UPDATE x SET x[2] = 10 WHERE CAST(x AS TEXT) = CAST(CAST('(-10,-10)' AS point) AS TEXT) RETURNING *;
/* test array extension */ CREATE TEMPORARY TABLE x (x ARRAY<INT>, x ARRAY<TEXT>);
INSERT INTO x VALUES (ARRAY(1, 2, NULL, 4), ARRAY('one', 'two', NULL, 'four'));
SELECT * FROM x;
UPDATE x SET x[1] = 22, x[1] = 'twenty-two';
SELECT * FROM x;
UPDATE x SET x[4] = 5, x[4] = 'five';
SELECT * FROM x;
UPDATE x SET x[7] = 8, x[7] = 'eight';
SELECT * FROM x;
UPDATE x SET x[-1] = 0, x[-1] = 'zero';
SELECT * FROM x;
UPDATE x SET x[-4] = -3, x[-4] = 'minus-three';
SELECT * FROM x;
UPDATE x SET x[0 : 2] = ARRAY(10, 11, 12), x[0 : 2] = ARRAY('ten', 'eleven', 'twelve');
SELECT * FROM x;
UPDATE x SET x[8 : 10] = ARRAY(18, NULL, 20), x[8 : 10] = ARRAY('p18', NULL, 'p20');
SELECT * FROM x;
UPDATE x SET x[11 : 12] = ARRAY(NULL, 22), x[11 : 12] = ARRAY(NULL, 'p22');
SELECT * FROM x;
UPDATE x SET x[15 : 16] = ARRAY(NULL, 26), x[15 : 16] = ARRAY(NULL, 'p26');
SELECT * FROM x;
UPDATE x SET x[-5 : -3] = ARRAY(-15, -14, -13), x[-5 : -3] = ARRAY('m15', 'm14', 'm13');
SELECT * FROM x;
UPDATE x SET x[-7 : -6] = ARRAY(-17, NULL), x[-7 : -6] = ARRAY('m17', NULL);
SELECT * FROM x;
UPDATE x SET x[-12 : -10] = ARRAY(-22, NULL, -20), x[-12 : -10] = ARRAY('m22', NULL, 'm20');
SELECT * FROM x;
DELETE FROM x;
INSERT INTO x VALUES (ARRAY(1, 2, NULL, 4), ARRAY('one', 'two', NULL, 'four'));
SELECT * FROM x;
UPDATE x SET x[0 : 5] = ARRAY(0, 1, 2, NULL, 4, 5), x[0 : 5] = ARRAY('z', 'p1', 'p2', NULL, 'p4', 'p5');
SELECT * FROM x;
/* array expressions and operators */ /* table creation and INSERTs */ CREATE TEMPORARY TABLE x (x ARRAY<INT>[4], x ARRAY<DOUBLE>, x ARRAY<DECIMAL>, x ARRAY<TEXT>, x ARRAY<TIMESTAMP>);
INSERT INTO x VALUES (ARRAY(ARRAY(ARRAY(113, 142), ARRAY(1, 147))), CAST(ARRAY(1.1, 1.2, 1.3) AS ARRAY<DOUBLE>), ARRAY(1.1, 1.2, 1.3), ARRAY(ARRAY(ARRAY('aaa', 'aab'), ARRAY('aba', 'abb'), ARRAY('aca', 'acb')), ARRAY(ARRAY('baa', 'bab'), ARRAY('bba', 'bbb'), ARRAY('bca', 'bcb'))), CAST(ARRAY('19620326', '19931223', '19970117') AS ARRAY<TIMESTAMP>));
/* some more test data */ CREATE TEMPORARY TABLE x (x INT, x TEXT, x DOUBLE);
INSERT INTO x VALUES (1, 'cat1', 1.21);
INSERT INTO x VALUES (2, 'cat1', 1.24);
INSERT INTO x VALUES (3, 'cat1', 1.18);
INSERT INTO x VALUES (4, 'cat1', 1.26);
INSERT INTO x VALUES (5, 'cat1', 1.15);
INSERT INTO x VALUES (6, 'cat2', 1.15);
INSERT INTO x VALUES (7, 'cat2', 1.26);
INSERT INTO x VALUES (8, 'cat2', 1.32);
INSERT INTO x VALUES (9, 'cat2', 1.30);
CREATE TEMPORARY TABLE x (x INT, x TEXT, x INT);
INSERT INTO x VALUES (1, 'cat1', 21);
INSERT INTO x VALUES (2, 'cat1', 24);
INSERT INTO x VALUES (3, 'cat1', 18);
INSERT INTO x VALUES (4, 'cat1', 26);
INSERT INTO x VALUES (5, 'cat1', 15);
INSERT INTO x VALUES (6, 'cat2', 15);
INSERT INTO x VALUES (7, 'cat2', 26);
INSERT INTO x VALUES (8, 'cat2', 32);
INSERT INTO x VALUES (9, 'cat2', 30);
/* expressions */ SELECT x.x[0][2][0] AS "x", x.x[1][1][0] AS "x" FROM (SELECT ARRAY(ARRAY(ARRAY(111, 112), ARRAY(121, 122), ARRAY(131, 132)), ARRAY(ARRAY(211, 212), ARRAY(221, 122), ARRAY(231, 232))) AS x) AS x;
SELECT ARRAY(ARRAY(ARRAY(ARRAY(ARRAY(ARRAY('hello'), ARRAY('world'))))));
SELECT ARRAY(ARRAY('hello'), ARRAY('world'));
SELECT ARRAY(SELECT x FROM x ORDER BY x NULLS LAST) AS "x";
/* with nulls */ SELECT CAST('{1,null,3}' AS ARRAY<INT>);
SELECT ARRAY(1, NULL, 3);
/* functions */ SELECT ARRAY_APPEND(ARRAY(42), 6) AS "x";
SELECT ARRAY_PREPEND(6, ARRAY(42)) AS "x";
SELECT ARRAY_CONCAT(ARRAY(1, 2), ARRAY(3, 4)) AS "x";
SELECT ARRAY_CONCAT(ARRAY(1, 2), ARRAY(ARRAY(3, 4), ARRAY(5, 6))) AS "x";
SELECT ARRAY_CONCAT(ARRAY(ARRAY(3, 4), ARRAY(5, 6)), ARRAY(1, 2)) AS "x";
SELECT ARRAY_POSITION(ARRAY(1, 2, 3, 4, 5), 4);
SELECT ARRAY_POSITION(ARRAY(5, 3, 4, 2, 1), 4);
SELECT ARRAY_POSITION(ARRAY(ARRAY(1, 2), ARRAY(3, 4)), 3);
SELECT ARRAY_POSITION(ARRAY('sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat'), 'mon');
SELECT ARRAY_POSITION(ARRAY('sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat'), 'sat');
SELECT ARRAY_POSITION(ARRAY('sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat'), NULL);
SELECT ARRAY_POSITION(ARRAY('sun', 'mon', 'tue', 'wed', 'thu', NULL, 'fri', 'sat'), NULL);
SELECT ARRAY_POSITION(ARRAY('sun', 'mon', 'tue', 'wed', 'thu', NULL, 'fri', 'sat'), 'sat');
SELECT ARRAY_POSITIONS(NULL, 10);
SELECT ARRAY_POSITIONS(NULL, CAST(NULL AS INT));
SELECT ARRAY_POSITIONS(ARRAY(1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6), 4);
SELECT ARRAY_POSITIONS(ARRAY(ARRAY(1, 2), ARRAY(3, 4)), 4);
SELECT ARRAY_POSITIONS(ARRAY(1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6), NULL);
SELECT ARRAY_POSITIONS(ARRAY(1, 2, 3, NULL, 5, 6, 1, 2, 3, NULL, 5, 6), NULL);
SELECT ARRAY_LENGTH(ARRAY_POSITIONS(ARRAY(SELECT CAST('AAAAAAAAAAAAAAAAAAAAAAAAA' AS TEXT) || x % 10 FROM x AS x), 'AAAAAAAAAAAAAAAAAAAAAAAAA5'));
BEGIN o := array_position(a, 2);
x := ARRAY_POSITION(x, 2, x + 1);
SELECT ARRAY_POSITION(CAST('[2:4]={1,2,3}' AS ARRAY<INT>), 1);
SELECT ARRAY_POSITIONS(CAST('[2:4]={1,2,3}' AS ARRAY<INT>), 1);
SELECT ARRAY_POSITION(x, (1, 1)), ARRAY_POSITIONS(x, (1, 1)) FROM (VALUES (ARRAY((0, 0), (1, 1))), (ARRAY((1, 1)))) AS x;
/* operators */ SELECT x FROM x WHERE x = ARRAY(ARRAY(ARRAY(113, 142), ARRAY(1, 147)));
SELECT NOT ARRAY(1.1, 1.2, 1.3) = ARRAY(1.1, 1.2, 1.3) AS "x";
SELECT ARRAY(1, 2) || 3 AS "x";
SELECT 0 || ARRAY(1, 2) AS "x";
SELECT ARRAY(1, 2) || ARRAY(3, 4) AS "x";
SELECT ARRAY(ARRAY(ARRAY('hello', 'world'))) || ARRAY(ARRAY(ARRAY('happy', 'birthday'))) AS "x";
SELECT ARRAY(ARRAY(1, 2), ARRAY(3, 4)) || ARRAY(5, 6) AS "x";
SELECT ARRAY(0, 0) || ARRAY(1, 1) || ARRAY(2, 2) AS "x";
SELECT 0 || ARRAY(1, 2) || 3 AS "x";
SELECT ARRAY(1.1) || ARRAY(2, 3, 4);
SELECT ARRAY_AGG(x) || ARRAY_AGG(x) FROM (VALUES (ROW(1, 2)), (ROW(3, 4))) AS x;
SELECT ROW(1, 2) || ARRAY_AGG(x) FROM (VALUES (ROW(3, 4)), (ROW(5, 6))) AS x;
SELECT * FROM x WHERE x @> '{32}' ORDER BY x NULLS LAST;
SELECT * FROM x WHERE x && '{32}' ORDER BY x NULLS LAST;
SELECT * FROM x WHERE x @> '{17}' ORDER BY x NULLS LAST;
SELECT * FROM x WHERE x && '{17}' ORDER BY x NULLS LAST;
SELECT * FROM x WHERE x @> '{32,17}' ORDER BY x NULLS LAST;
SELECT * FROM x WHERE x && '{32,17}' ORDER BY x NULLS LAST;
SELECT * FROM x WHERE '{38,34,32,89}' @> x ORDER BY x NULLS LAST;
SELECT * FROM x WHERE x = '{}' ORDER BY x NULLS LAST;
SELECT * FROM x WHERE x @> '{}' ORDER BY x NULLS LAST;
SELECT * FROM x WHERE x && '{}' ORDER BY x NULLS LAST;
SELECT * FROM x WHERE '{}' @> x ORDER BY x NULLS LAST;
SELECT * FROM x WHERE x = '{NULL}' ORDER BY x NULLS LAST;
SELECT * FROM x WHERE x @> '{NULL}' ORDER BY x NULLS LAST;
SELECT * FROM x WHERE x && '{NULL}' ORDER BY x NULLS LAST;
SELECT * FROM x WHERE '{NULL}' @> x ORDER BY x NULLS LAST;
SELECT * FROM x WHERE x @> '{AAAAAAAA72908}' ORDER BY x NULLS LAST;
SELECT * FROM x WHERE x && '{AAAAAAAA72908}' ORDER BY x NULLS LAST;
SELECT * FROM x WHERE x @> '{AAAAAAAAAA646}' ORDER BY x NULLS LAST;
SELECT * FROM x WHERE x && '{AAAAAAAAAA646}' ORDER BY x NULLS LAST;
SELECT * FROM x WHERE x @> '{AAAAAAAA72908,AAAAAAAAAA646}' ORDER BY x NULLS LAST;
SELECT * FROM x WHERE x && '{AAAAAAAA72908,AAAAAAAAAA646}' ORDER BY x NULLS LAST;
SELECT * FROM x WHERE '{AAAAAAAA72908,AAAAAAAAAAAAAAAAAAA17075,AA88409,AAAAAAAAAAAAAAAAAA36842,AAAAAAA48038,AAAAAAAAAAAAAA10611}' @> x ORDER BY x NULLS LAST;
SELECT * FROM x WHERE x = '{}' ORDER BY x NULLS LAST;
SELECT * FROM x WHERE x @> '{}' ORDER BY x NULLS LAST;
SELECT * FROM x WHERE x && '{}' ORDER BY x NULLS LAST;
SELECT * FROM x WHERE '{}' @> x ORDER BY x NULLS LAST;
/* array casts */ SELECT CAST(CAST(CAST(ARRAY(1, 2, 3) AS ARRAY<TEXT>) AS ARRAY<INT>) AS ARRAY<DOUBLE>) AS "x";
SELECT PG_TYPEOF(CAST(CAST(CAST(ARRAY(1, 2, 3) AS ARRAY<TEXT>) AS ARRAY<INT>) AS ARRAY<DOUBLE>)) AS "x";
SELECT CAST(CAST(ARRAY(ARRAY('a', 'bc'), ARRAY('def', 'hijk')) AS ARRAY<TEXT>) AS ARRAY<VARCHAR>) AS "x";
SELECT PG_TYPEOF(CAST(CAST(ARRAY(ARRAY('a', 'bc'), ARRAY('def', 'hijk')) AS ARRAY<TEXT>) AS ARRAY<VARCHAR>)) AS "x";
SELECT CAST(ARRAY(ARRAY(ARRAY(ARRAY(ARRAY(ARRAY('a', 'bb', 'ccc')))))) AS ARRAY<TEXT>) AS "x";
SELECT CAST(CAST(NULL AS ARRAY<TEXT>) AS ARRAY<INT>) AS "x";
/* scalar op any/all (array) */ SELECT 33 = ANY('{1,2,3}');
SELECT 33 = ANY('{1,2,33}');
SELECT 33 = ALL('{1,2,33}');
SELECT 33 >= ALL('{1,2,33}');
/* boundary cases */ SELECT CAST(NULL AS INT) >= ALL('{1,2,33}');
SELECT CAST(NULL AS INT) >= ALL('{}');
SELECT CAST(NULL AS INT) >= ANY('{}');
/* cross-datatype */ SELECT 33.4 = ANY(ARRAY(1, 2, 3));
SELECT 33.4 > ALL(ARRAY(1, 2, 3));
/* errors */ SELECT 33 * ANY('{1,2,3}');
SELECT 33 * ANY(44);
/* nulls */ SELECT 33 = ANY(CAST(NULL AS ARRAY<INT>));
SELECT CAST(NULL AS INT) = ANY('{1,2,3}');
SELECT 33 = ANY('{1,null,3}');
SELECT 33 = ANY('{1,null,33}');
SELECT 33 = ALL(CAST(NULL AS ARRAY<INT>));
SELECT CAST(NULL AS INT) = ALL('{1,2,3}');
SELECT 33 = ALL('{1,null,3}');
SELECT 33 = ALL('{33,null,33}');
/* nulls later in the bitmap */ SELECT -1 <> ALL(ARRAY(SELECT NULLIF(x.x, 900) FROM x AS x));
/* test indexes on arrays */ CREATE TEMPORARY TABLE x (x ARRAY<INT> UNIQUE);
INSERT INTO x VALUES ('{1,2,3}');
INSERT INTO x VALUES ('{1,2}');
/* failure expected: */ INSERT INTO x VALUES ('{1,2,3}');
INSERT INTO x VALUES ('{2,3,4}');
INSERT INTO x VALUES ('{1,5,3}');
INSERT INTO x VALUES ('{1,2,10}');
SET x = off;
SET x = off;
SELECT * FROM x WHERE x > '{1,2,3}' AND x <= '{1,5,3}';
SELECT * FROM x WHERE x >= '{1,2,3}' AND x < '{1,5,3}';
/* test ON CONFLICT DO UPDATE with arrays */ CREATE TEMPORARY TABLE x (x INT PRIMARY KEY, x ARRAY<INT>);
INSERT INTO x VALUES (1, '{1,2,3}');
INSERT INTO x VALUES (1, '{3,4,5}') ON CONFLICT(x) DO UPDATE SET x[0] = x.x[0], x[2] = x.x[2] RETURNING x, x;
/* note: if above selects don't produce the expected tuple order, */ /* then you didn't get an indexscan plan, and something is busted. */ RESET enable_seqscan;
RESET enable_bitmapscan;
UPDATE x SET x[2147483646] = 42 WHERE x = 10;
UPDATE x SET x[2147483646 : 2147483647] = ARRAY(4, 2) WHERE x = 10;
BEGIN a := '[-2147483648:-2147483647]={1,2}'::int[];
x[2147483646] := 42;
/* t */ SELECT 'foo' LIKE ANY(ARRAY('%a', '%b'));
/* f */ SELECT 'foo' LIKE ALL(ARRAY('f%', '%o'));
/* t */ SELECT 'foo' LIKE ALL(ARRAY('f%', '%b'));
/* f */ SELECT NOT 'foo' LIKE ANY(ARRAY('%a', '%b'));
/* t */ SELECT NOT 'foo' LIKE ALL(ARRAY('%a', '%o'));
/* f */ SELECT 'foo' ILIKE ANY(ARRAY('%A', '%O'));
/* t */ SELECT 'foo' ILIKE ALL(ARRAY('F%', '%O'));
/* t */ /* General array parser tests */ /* none of the following should be accepted */ SELECT CAST('{{1,{2}},{2,3}}' AS ARRAY<TEXT>);
SELECT CAST({{1,2},\\{2,3}} AS ARRAY<TEXT>);
SELECT CAST('{"a"b}' AS ARRAY<TEXT>);
SELECT CAST('{a"b"}' AS ARRAY<TEXT>);
SELECT CAST('{"a""b"}' AS ARRAY<TEXT>);
SELECT CAST('{{"1 2" x},{3}}' AS ARRAY<TEXT>);
SELECT CAST('{{"1 2"} x,{3}}' AS ARRAY<TEXT>);
SELECT CAST('{}}' AS ARRAY<TEXT>);
SELECT CAST('{ }}' AS ARRAY<TEXT>);
SELECT CAST('}{' AS ARRAY<TEXT>);
SELECT CAST('{foo{}}' AS ARRAY<TEXT>);
SELECT CAST('{"foo"{}}' AS ARRAY<TEXT>);
SELECT CAST('{foo,,bar}' AS ARRAY<TEXT>);
SELECT CAST('{{1},{{2}}}' AS ARRAY<TEXT>);
SELECT CAST('{{{1}},{2}}' AS ARRAY<TEXT>);
SELECT CAST('{{},{{}}}' AS ARRAY<TEXT>);
SELECT CAST('{{{}},{}}' AS ARRAY<TEXT>);
SELECT CAST('{{1},{}}' AS ARRAY<TEXT>);
SELECT CAST('{{},{1}}' AS ARRAY<TEXT>);
SELECT CAST('[1:0]={}' AS ARRAY<INT>);
SELECT CAST('[2147483646:2147483647]={1,2}' AS ARRAY<INT>);
SELECT CAST('[1:-1]={}' AS ARRAY<INT>);
SELECT CAST('[2]={1}' AS ARRAY<INT>);
SELECT CAST('[1:]={1}' AS ARRAY<INT>);
SELECT CAST('[:1]={1}' AS ARRAY<INT>);
SELECT ARRAY();
SELECT CAST('{{1,},{1},}' AS ARRAY<TEXT>);
SELECT CAST('{{1,},{1}}' AS ARRAY<TEXT>);
SELECT CAST('{{1,}}' AS ARRAY<TEXT>);
SELECT CAST('{1,}' AS ARRAY<TEXT>);
SELECT CAST('[21474836488:21474836489]={1,2}' AS ARRAY<INT>);
SELECT CAST('[-2147483649:-2147483648]={1,2}' AS ARRAY<INT>);
/* none of the above should be accepted */ /* all of the following should be accepted */ SELECT CAST('{}' AS ARRAY<TEXT>);
SELECT CAST('{{},{}}' AS ARRAY<TEXT>);
SELECT CAST('{{{1,2,3,4},{2,3,4,5}},{{3,4,5,6},{4,5,6,7}}}' AS ARRAY<TEXT>);
SELECT CAST('{null,n\ull,"null"}' AS ARRAY<TEXT>);
SELECT CAST('{ ab\c , "ab\"c" }' AS ARRAY<TEXT>);
SELECT CAST('{0 second  ,0 second}' AS ARRAY<INTERVAL>);
SELECT CAST('{ { "," } , { 3 } }' AS ARRAY<TEXT>);
SELECT CAST('  {   {  "  0 second  "   ,  0 second  }   }' AS ARRAY<TEXT>);
SELECT CAST('{            0 second,            @ 1 hour @ 42 minutes @ 20 seconds          }' AS ARRAY<INTERVAL>);
SELECT CAST(ARRAY() AS ARRAY<TEXT>);
SELECT CAST('[2]={1,7}' AS ARRAY<INT>);
SELECT CAST('[0:1]={1.1,2.2}' AS ARRAY<DOUBLE>);
SELECT CAST('[2147483646:2147483646]={1}' AS ARRAY<INT>);
SELECT CAST('[-2147483648:-2147483647]={1,2}' AS ARRAY<INT>);
/* all of the above should be accepted */ /* tests for array aggregates */ CREATE TEMPORARY TABLE x (x ARRAY<INT>, x ARRAY<ARRAY<TEXT>>, x ARRAY<DOUBLE>);
INSERT INTO x (x, x, x) VALUES ('{1,2,3,4}', '{{grey,red},{blue,blue}}', '{1.6, 0.0}');
INSERT INTO x (x, x, x) VALUES ('{1,2,3}', '{{grey,red},{grey,blue}}', '{1.6}');
SELECT MAX(x), MIN(x), MAX(x), MIN(x), MAX(x), MIN(x) FROM x;
INSERT INTO x (x, x, x) VALUES ('{3,3,2,4,5,6}', '{{white,yellow},{pink,orange}}', '{2.1,3.3,1.8,1.7,1.6}');
SELECT MAX(x), MIN(x), MAX(x), MIN(x), MAX(x), MIN(x) FROM x;
INSERT INTO x (x, x, x) VALUES ('{2}', '{{black,red},{green,orange}}', '{1.6,2.2,2.6,0.4}');
SELECT MAX(x), MIN(x), MAX(x), MIN(x), MAX(x), MIN(x) FROM x;
INSERT INTO x (x, x, x) VALUES ('{4,2,6,7,8,1}', '{{red},{black},{purple},{blue},{blue}}', NULL);
SELECT MAX(x), MIN(x), MAX(x), MIN(x), MAX(x), MIN(x) FROM x;
INSERT INTO x (x, x, x) VALUES ('{}', '{{pink,white,blue,red,grey,orange}}', '{2.1,1.87,1.4,2.2}');
SELECT MAX(x), MIN(x), MAX(x), MIN(x), MAX(x), MIN(x) FROM x;
/* A few simple tests for arrays of composite types */ create type comptype as (f1 int, f2 text);
CREATE TABLE x (x comptype, x ARRAY<comptype>);
/* XXX would like to not have to specify row() construct types here ... */ INSERT INTO x VALUES (ROW(1, 'foo'), ARRAY(CAST(ROW(2, 'bar') AS comptype), CAST(ROW(3, 'baz') AS comptype)));
/* check that implicitly named array type _comptype isn't a problem */ create type _comptype as enum('fooey');
SELECT * FROM x;
SELECT x[1].x FROM x;
drop type _comptype;
DROP TABLE x;
drop type comptype;
SELECT * FROM x;
SELECT * FROM x;
DROP FUNCTION x (anyarray);
DROP FUNCTION x (anyarray);
SELECT ARRAY_FILL(CAST(NULL AS INT), ARRAY(3, 3), ARRAY(2, 2));
SELECT ARRAY_FILL(CAST(NULL AS INT), ARRAY(3, 3));
SELECT ARRAY_FILL(CAST(NULL AS TEXT), ARRAY(3, 3), ARRAY(2, 2));
SELECT ARRAY_FILL(CAST(NULL AS TEXT), ARRAY(3, 3));
SELECT ARRAY_FILL(7, ARRAY(3, 3), ARRAY(2, 2));
SELECT ARRAY_FILL(7, ARRAY(3, 3));
SELECT ARRAY_FILL(CAST('juhu' AS TEXT), ARRAY(3, 3), ARRAY(2, 2));
SELECT ARRAY_FILL(CAST('juhu' AS TEXT), ARRAY(3, 3));
SELECT x, x = '{}' AS x, ARRAY_DIMS(x) FROM (SELECT ARRAY_FILL(42, ARRAY(0)) AS x) AS x;
SELECT x, x = '{}' AS x, ARRAY_DIMS(x) FROM (SELECT ARRAY_FILL(42, '{}') AS x) AS x;
SELECT x, x = '{}' AS x, ARRAY_DIMS(x) FROM (SELECT ARRAY_FILL(42, '{}', '{}') AS x) AS x;
/* raise exception */ SELECT ARRAY_FILL(1, NULL, ARRAY(2, 2));
SELECT ARRAY_FILL(1, ARRAY(2, 2), NULL);
SELECT ARRAY_FILL(1, ARRAY(2, 2), '{}');
SELECT ARRAY_FILL(1, ARRAY(3, 3), ARRAY(1, 1, 1));
SELECT ARRAY_FILL(1, ARRAY(1, 2, NULL));
SELECT ARRAY_FILL(1, ARRAY(ARRAY(1, 2), ARRAY(3, 4)));
SELECT STRING_TO_ARRAY('1|2|3', '|');
SELECT STRING_TO_ARRAY('1|2|3|', '|');
SELECT STRING_TO_ARRAY('1||2|3||', '||');
SELECT STRING_TO_ARRAY('1|2|3', '');
SELECT STRING_TO_ARRAY('', '|');
SELECT STRING_TO_ARRAY('1|2|3', NULL);
SELECT STRING_TO_ARRAY(NULL, '|') IS NULL;
SELECT STRING_TO_ARRAY('abc', '');
SELECT STRING_TO_ARRAY('abc', '', 'abc');
SELECT STRING_TO_ARRAY('abc', ',');
SELECT STRING_TO_ARRAY('abc', ',', 'abc');
SELECT STRING_TO_ARRAY('1,2,3,4,,6', ',');
SELECT STRING_TO_ARRAY('1,2,3,4,,6', ',', '');
SELECT STRING_TO_ARRAY('1,2,3,4,*,6', ',', '*');
SELECT x, x IS NULL AS "x" FROM x AS x;
SELECT x, x IS NULL AS "x" FROM x AS x;
SELECT x, x IS NULL AS "x" FROM x AS x;
SELECT x, x IS NULL AS "x" FROM x AS x;
SELECT x, x IS NULL AS "x" FROM x AS x;
SELECT x, x IS NULL AS "x" FROM x AS x;
SELECT x, x IS NULL AS "x" FROM x AS x;
SELECT x, x IS NULL AS "x" FROM x AS x;
SELECT x, x IS NULL AS "x" FROM x AS x;
SELECT x, x IS NULL AS "x" FROM x AS x;
SELECT x, x IS NULL AS "x" FROM x AS x;
SELECT x, x IS NULL AS "x" FROM x AS x;
SELECT x, x IS NULL AS "x" FROM x AS x;
SELECT x, x IS NULL AS "x" FROM x AS x;
SELECT ARRAY_TO_STRING(CAST(NULL AS ARRAY<INT>), ',') IS NULL;
SELECT ARRAY_TO_STRING(CAST('{}' AS ARRAY<INT>), ',');
SELECT ARRAY_TO_STRING(ARRAY(1, 2, 3, 4, NULL, 6), ',');
SELECT ARRAY_TO_STRING(ARRAY(1, 2, 3, 4, NULL, 6), ',', '*');
SELECT ARRAY_TO_STRING(ARRAY(1, 2, 3, 4, NULL, 6), NULL);
SELECT ARRAY_TO_STRING(ARRAY(1, 2, 3, 4, NULL, 6), ',', NULL);
SELECT ARRAY_TO_STRING(STRING_TO_ARRAY('1|2|3', '|'), '|');
SELECT ARRAY_LENGTH(ARRAY(1, 2, 3));
SELECT ARRAY_LENGTH(ARRAY(ARRAY(1, 2, 3), ARRAY(4, 5, 6)));
SELECT ARRAY_LENGTH(ARRAY(ARRAY(1, 2, 3), ARRAY(4, 5, 6)));
SELECT ARRAY_LENGTH(ARRAY(ARRAY(1, 2, 3), ARRAY(4, 5, 6)));
SELECT ARRAY_LENGTH(ARRAY(ARRAY(1, 2, 3), ARRAY(4, 5, 6)));
SELECT CARDINALITY(CAST(NULL AS ARRAY<INT>));
SELECT CARDINALITY(CAST('{}' AS ARRAY<INT>));
SELECT CARDINALITY(ARRAY(1, 2, 3));
SELECT CARDINALITY(CAST('[2:4]={5,6,7}' AS ARRAY<INT>));
SELECT CARDINALITY(CAST('{{1,2}}' AS ARRAY<INT>));
SELECT CARDINALITY(CAST('{{1,2},{3,4},{5,6}}' AS ARRAY<INT>));
SELECT CARDINALITY(CAST('{{{1,9},{5,6}},{{2,3},{3,4}}}' AS ARRAY<INT>));
/* array_agg(anynonarray) */ SELECT ARRAY_AGG(x) FROM (SELECT x FROM x WHERE x < 15 ORDER BY x NULLS LAST) AS x;
SELECT ARRAY_AGG(x) FROM (SELECT x FROM x WHERE x < 15 ORDER BY x NULLS LAST) AS x;
SELECT ARRAY_AGG(NULLIF(x, 4)) FROM (SELECT x FROM x WHERE x < 15 ORDER BY x NULLS LAST) AS x;
SELECT ARRAY_AGG(x) FROM x WHERE x < -15;
/* array_agg(anyarray) */ SELECT ARRAY_AGG(x) FROM (VALUES (CAST('{1,2}' AS ARRAY<INT>)), (CAST('{3,4}' AS ARRAY<INT>))) AS x;
SELECT ARRAY_AGG(DISTINCT x ORDER BY x DESC NULLS FIRST) FROM (SELECT ARRAY(x / 2) FROM x AS x) AS x;
SELECT ARRAY_AGG(x) FROM (SELECT ARRAY_AGG(ARRAY(x, x + 1, x - 1)) FROM x AS x) AS x;
SELECT ARRAY_AGG(ARRAY(x + 1.2, x + 1.3, x + 1.4)) FROM x AS x;
SELECT ARRAY_AGG(ARRAY('Hello', CAST(x AS TEXT))) FROM x AS x;
SELECT ARRAY_AGG(ARRAY(x, NULLIF(x, 3), x + 1)) FROM x AS x;
/* errors */ SELECT ARRAY_AGG(CAST('{}' AS ARRAY<INT>)) FROM x;
SELECT ARRAY_AGG(CAST(NULL AS ARRAY<INT>)) FROM x;
SELECT ARRAY_AGG(x) FROM (VALUES (CAST('{1,2}' AS ARRAY<INT>)), (CAST('{3}' AS ARRAY<INT>))) AS x;
SELECT EXPLODE(ARRAY(1, 2, 3));
SELECT * FROM UNNEST(ARRAY(1, 2, 3));
SELECT EXPLODE(CAST(ARRAY(1, 2, 3, 4.5) AS ARRAY<DOUBLE>));
SELECT EXPLODE(CAST(ARRAY(1, 2, 3, 4.5) AS ARRAY<DECIMAL>));
SELECT EXPLODE(ARRAY(1, 2, 3, NULL, 4, NULL, NULL, 5, 6));
SELECT EXPLODE(CAST(ARRAY(1, 2, 3, NULL, 4, NULL, NULL, 5, 6) AS ARRAY<TEXT>));
SELECT ABS(EXPLODE(ARRAY(1, 2, NULL, -3)));
SELECT ARRAY_REMOVE(ARRAY(1, 2, 2, 3), 2);
SELECT ARRAY_REMOVE(ARRAY(1, 2, 2, 3), 5);
SELECT ARRAY_REMOVE(ARRAY(1, NULL, NULL, 3), NULL);
SELECT ARRAY_REMOVE(ARRAY('A', 'CC', 'D', 'C', 'RR'), 'RR');
SELECT ARRAY_REMOVE(ARRAY(1.0, 2.1, 3.3), 1);
SELECT ARRAY_REMOVE('{{1,2,2},{1,4,3}}', 2);
/* not allowed */ SELECT ARRAY_REMOVE(ARRAY('X', 'X', 'X'), 'X') = '{}';
SELECT ARRAY_REPLACE(ARRAY(1, 2, 5, 4), 5, 3);
SELECT ARRAY_REPLACE(ARRAY(1, 2, 5, 4), 5, NULL);
SELECT ARRAY_REPLACE(ARRAY(1, 2, NULL, 4, NULL), NULL, 5);
SELECT ARRAY_REPLACE(ARRAY('A', 'B', 'DD', 'B'), 'B', 'CC');
SELECT ARRAY_REPLACE(ARRAY(1, NULL, 3), NULL, NULL);
SELECT ARRAY_REPLACE(ARRAY('AB', NULL, 'CDE'), NULL, '12');
/* array(select array-value ...) */ SELECT ARRAY(SELECT ARRAY(x, x / 2) FROM x AS x);
SELECT ARRAY(SELECT ARRAY('Hello', CAST(x AS TEXT)) FROM x AS x);
/* int2vector and oidvector should be treated as scalar types for this purpose */ SELECT PG_TYPEOF(ARRAY(SELECT CAST('11 22 33' AS int2vector) FROM x));
SELECT ARRAY(SELECT CAST('11 22 33' AS int2vector) FROM x);
SELECT EXPLODE(ARRAY(SELECT CAST('11 22 33' AS int2vector) FROM x));
SELECT PG_TYPEOF(ARRAY(SELECT CAST('11 22 33' AS oidvector) FROM x));
SELECT ARRAY(SELECT CAST('11 22 33' AS oidvector) FROM x);
SELECT EXPLODE(ARRAY(SELECT CAST('11 22 33' AS oidvector) FROM x));
/* array[] should do the same */ SELECT PG_TYPEOF(ARRAY(CAST('11 22 33' AS int2vector)));
SELECT ARRAY(CAST('11 22 33' AS int2vector));
SELECT PG_TYPEOF(EXPLODE(ARRAY(CAST('11 22 33' AS int2vector))));
SELECT EXPLODE(ARRAY(CAST('11 22 33' AS int2vector)));
SELECT PG_TYPEOF(EXPLODE(CAST('11 22 33' AS int2vector)));
SELECT EXPLODE(CAST('11 22 33' AS int2vector));
SELECT PG_TYPEOF(ARRAY(CAST('11 22 33' AS oidvector)));
SELECT ARRAY(CAST('11 22 33' AS oidvector));
SELECT PG_TYPEOF(EXPLODE(ARRAY(CAST('11 22 33' AS oidvector))));
SELECT EXPLODE(ARRAY(CAST('11 22 33' AS oidvector)));
SELECT PG_TYPEOF(EXPLODE(CAST('11 22 33' AS oidvector)));
SELECT EXPLODE(CAST('11 22 33' AS oidvector));
/* Insert/update on a column that is array of composite */ CREATE TEMPORARY TABLE x (x ARRAY<int8_tbl>);
SELECT * FROM x;
UPDATE x SET x[4].x = 43;
SELECT * FROM x;
/* Check that arrays of composites are safely detoasted when needed */ CREATE TEMPORARY TABLE x (x TEXT);
INSERT INTO x SELECT GROUP_CONCAT(CAST(RAND() AS TEXT), '') FROM x;
create type textandtext as (c1 text, c2 text);
CREATE TEMPORARY TABLE x (x ARRAY<textandtext>);
INSERT INTO x SELECT ARRAY(CAST(ROW(x, x) AS textandtext)) FROM x;
SELECT LENGTH(FIPSHASH((x[0]).x)) FROM x;
DELETE FROM x;
SELECT LENGTH(FIPSHASH((x[0]).x)) FROM x;
TRUNCATE TABLE x;
DROP TABLE x;
SELECT LENGTH(FIPSHASH((x[0]).x)) FROM x;
DROP TABLE x;
drop type textandtext;
/* Tests for polymorphic-array form of width_bucket() */ /* this exercises the varwidth and float8 code paths */ SELECT x, WIDTH_BUCKET(CAST(x AS DECIMAL), CAST(ARRAY(1, 3, 5, 10.0) AS ARRAY<DECIMAL>)) AS x, WIDTH_BUCKET(CAST(x AS DECIMAL), CAST(ARRAY(0, 5.5, 9.99) AS ARRAY<DECIMAL>)) AS x, WIDTH_BUCKET(CAST(x AS DECIMAL), CAST(ARRAY(-6, -5, 2.0) AS ARRAY<DECIMAL>)) AS x, WIDTH_BUCKET(CAST(x AS DOUBLE), CAST(ARRAY(1, 3, 5, 10.0) AS ARRAY<DOUBLE>)) AS x, WIDTH_BUCKET(CAST(x AS DOUBLE), CAST(ARRAY(0, 5.5, 9.99) AS ARRAY<DOUBLE>)) AS x, WIDTH_BUCKET(CAST(x AS DOUBLE), CAST(ARRAY(-6, -5, 2.0) AS ARRAY<DOUBLE>)) AS x FROM (VALUES (-5.2), (-0.0000000001), (0.000000000001), (1), (1.99999999999999), (2), (2.00000000000001), (3), (4), (4.5), (5), (5.5), (6), (7), (8), (9), (9.99999999999999), (10), (10.0000000000001)) AS x;
/* ensure float8 path handles NaN properly */ SELECT x, WIDTH_BUCKET(x, CAST(ARRAY(1, 3, 9, 'NaN', 'NaN') AS ARRAY<DOUBLE>)) AS x FROM (VALUES (-CAST(5.2 AS DOUBLE)), (CAST(4 AS DOUBLE)), (CAST(77 AS DOUBLE)), (CAST('NaN' AS DOUBLE))) AS x;
/* these exercise the generic fixed-width code path */ SELECT x, WIDTH_BUCKET(x, ARRAY(1, 3, 5, 10)) AS x FROM x AS x;
SELECT WIDTH_BUCKET(CURRENT_TIMESTAMP(), CAST(ARRAY('yesterday', 'today', 'tomorrow') AS ARRAY<TIMESTAMPTZ>));
/* corner cases */ SELECT WIDTH_BUCKET(5, ARRAY(3));
SELECT WIDTH_BUCKET(5, '{}');
/* error cases */ SELECT WIDTH_BUCKET(CAST('5' AS TEXT), CAST(ARRAY(3, 4) AS ARRAY<INT>));
SELECT WIDTH_BUCKET(5, ARRAY(3, 4, NULL));
SELECT WIDTH_BUCKET(5, ARRAY(ARRAY(1, 2), ARRAY(3, 4)));
/* trim_array */ SELECT x, TRIM_ARRAY(x, 2) FROM (VALUES (CAST('{1,2,3,4,5,6}' AS ARRAY<BIGINT>)), ('{1,2}'), ('[10:16]={1,2,3,4,5,6,7}'), ('[-15:-10]={1,2,3,4,5,6}'), ('{{1,10},{2,20},{3,30},{4,40}}')) AS x;
SELECT TRIM_ARRAY(ARRAY(1, 2, 3), -1);
/* fail */ SELECT TRIM_ARRAY(ARRAY(1, 2, 3), 10);
/* fail */ SELECT TRIM_ARRAY(CAST(ARRAY() AS ARRAY<INT>), 1);
/* fail */ /* array_shuffle */ SELECT '{1,2,3,4,5,6}' @> ARRAY_SHUFFLE(CAST('{1,2,3,4,5,6}' AS ARRAY<INT>));
SELECT ARRAY_SHUFFLE(CAST('{1,2,3,4,5,6}' AS ARRAY<INT>)) @> '{1,2,3,4,5,6}';
SELECT ARRAY_DIMS(ARRAY_SHUFFLE(CAST('[-1:2][2:3]={{1,2},{3,NULL},{5,6},{7,8}}' AS ARRAY<INT>)));
SELECT ARRAY_DIMS(ARRAY_SHUFFLE(CAST('{{{1,2},{3,NULL}},{{5,6},{7,8}},{{9,10},{11,12}}}' AS ARRAY<INT>)));
/* array_sample */ SELECT '{1,2,3,4,5,6}' @> ARRAY_SAMPLE(CAST('{1,2,3,4,5,6}' AS ARRAY<INT>), 3);
SELECT ARRAY_LENGTH(ARRAY_SAMPLE(CAST('{1,2,3,4,5,6}' AS ARRAY<INT>), 3));
SELECT ARRAY_DIMS(ARRAY_SAMPLE(CAST('[-1:2][2:3]={{1,2},{3,NULL},{5,6},{7,8}}' AS ARRAY<INT>), 3));
SELECT ARRAY_DIMS(ARRAY_SAMPLE(CAST('{{{1,2},{3,NULL}},{{5,6},{7,8}},{{9,10},{11,12}}}' AS ARRAY<INT>), 2));
SELECT ARRAY_SAMPLE(CAST('{1,2,3,4,5,6}' AS ARRAY<INT>), -1);
/* fail */ SELECT ARRAY_SAMPLE(CAST('{1,2,3,4,5,6}' AS ARRAY<INT>), 7);
/* fail */ /* array_reverse */ SELECT ARRAY_REVERSE(CAST('{}' AS ARRAY<INT>));
SELECT ARRAY_REVERSE(CAST('{1}' AS ARRAY<INT>));
SELECT ARRAY_REVERSE(CAST('{1,2}' AS ARRAY<INT>));
SELECT ARRAY_REVERSE(CAST('{1,2,3,NULL,4,5,6}' AS ARRAY<INT>));
SELECT ARRAY_REVERSE(CAST('{{1,2},{3,4},{5,6},{7,8}}' AS ARRAY<INT>));
/* ASYNC */ /* Should work. Send a valid message via a valid channel name */ SELECT PG_NOTIFY('notify_async1', 'sample message1');
SELECT PG_NOTIFY('notify_async1', '');
SELECT PG_NOTIFY('notify_async1', NULL);
/* Should fail. Send a valid message via an invalid channel name */ SELECT PG_NOTIFY('', 'sample message1');
SELECT PG_NOTIFY(NULL, 'sample message1');
SELECT PG_NOTIFY('notify_async_channel_name_too_long______________________________', 'sample_message1');
x AS x /* Should work. Valid NOTIFY/LISTEN/UNLISTEN commands */;
x AS x;
x AS x;
/* Should return zero while there are no pending notifications. */ /* src/test/isolation/specs/async-notify.spec tests for actual usage. */ SELECT PG_NOTIFICATION_QUEUE_USAGE();
/* BIT types */ /* Build tables for testing */ CREATE TABLE x (x BIT(11));
INSERT INTO x VALUES (2);
/* too short */ INSERT INTO x VALUES (0);
INSERT INTO x VALUES (1728);
INSERT INTO x VALUES (682);
INSERT INTO x VALUES (2810);
SELECT * FROM x;
INSERT INTO x VALUES (0);
INSERT INTO x VALUES (21);
INSERT INTO x VALUES (682);
INSERT INTO x VALUES (2810);
SELECT * FROM x;
/* Literals with syntax errors */ SELECT 0;
SELECT 0;
SELECT 0;
SELECT 0;
/* Concatenation */ SELECT x, x, (x || x) AS x FROM x, x ORDER BY 3 NULLS LAST;
/* Length */ SELECT x, LENGTH(x) AS x FROM x;
SELECT x, LENGTH(x) AS x FROM x;
/* Substring */ SELECT x, SUBSTRING(x, 2, 4) AS x, SUBSTRING(x, 7, 13) AS x, SUBSTRING(x, 6) AS x FROM x;
SELECT x, SUBSTRING(x, 2, 4) AS x, SUBSTRING(x, 7, 13) AS x, SUBSTRING(x, 6) AS x FROM x;
/* test overflow cases */ SELECT SUBSTRING(CAST('01010101' AS BIT(8)), 2, 2147483646) AS "x";
SELECT SUBSTRING(CAST('01010101' AS BIT(8)), -10, 2147483646) AS "x";
SELECT SUBSTRING(CAST('01010101' AS BIT(8)), -10, -2147483646) AS "x";
SELECT SUBSTRING(CAST('01010101' AS varbit), 2, 2147483646) AS "x";
SELECT SUBSTRING(CAST('01010101' AS varbit), -10, 2147483646) AS "x";
SELECT SUBSTRING(CAST('01010101' AS varbit), -10, -2147483646) AS "x";
/* - Bit operations */ DROP TABLE x;
COPY INTO x FROM x;
SELECT x, x, x < x AS "x", x <= x AS "x", x = x AS "x", x >= x AS "x", x > x AS "x", x <> x AS "x" FROM x;
SELECT x, x << 4 AS "x", x, x >> 2 AS "x" FROM x;
DROP TABLE x;
/* - Bit operations */ DROP TABLE x;
CREATE TABLE x (x BIT(16), x BIT(16));
COPY INTO x FROM x;
SELECT x, x, x < x AS "x", x <= x AS "x", x = x AS "x", x >= x AS "x", x > x AS "x", x <> x AS "x" FROM x;
SELECT x, x << 4 AS "x", x, x >> 2 AS "x" FROM x;
DROP TABLE x;
/* The following should fail */ SELECT 1 & 2;
SELECT 7 | 3;
SELECT 2 ^ 29;
/* More position tests, checking all the boundary cases */ SELECT STR_POSITION(5, 10);
/* 0 */ SELECT STR_POSITION(10, 10);
/* 5 */ SELECT STR_POSITION(5, 10);
/* 0 */ SELECT STR_POSITION(10, 10);
/* 0 */ SELECT STR_POSITION(46808, 45);
/* 3 */ SELECT STR_POSITION(5850, 182);
/* 3 */ SELECT STR_POSITION(5851, 5851);
/* 3 */ SELECT STR_POSITION(5851, 5851);
/* 5 */ SELECT STR_POSITION(235, 235);
/* 1 */ SELECT STR_POSITION(235, 235);
/* 2 */ SELECT STR_POSITION(235, 235);
/* 4 */ SELECT STR_POSITION(235, 235);
/* 6 */ SELECT STR_POSITION(470, 470);
/* 1 */ SELECT STR_POSITION(470, 470);
/* 2 */ SELECT STR_POSITION(470, 470);
/* 4 */ SELECT STR_POSITION(470, 470);
/* 6 */ SELECT STR_POSITION(235, 470);
/* 0 */ SELECT STR_POSITION(235, 470);
/* 0 */ SELECT STR_POSITION(235, 470);
/* 0 */ SELECT STR_POSITION(235, 470);
/* 0 */ SELECT STR_POSITION(470, 470);
/* 1 */ SELECT STR_POSITION(470, 470);
/* 2 */ SELECT STR_POSITION(470, 470);
/* 4 */ SELECT STR_POSITION(470, 470);
/* 6 */ SELECT STR_POSITION(60395, 470);
/* 0 */ SELECT STR_POSITION(60395, 470);
/* 0 */ SELECT STR_POSITION(60395, 470);
/* 0 */ SELECT STR_POSITION(60395, 470);
/* 0 */ SELECT STR_POSITION(120790, 470);
/* 14 */ SELECT STR_POSITION(120790, 470);
/* 15 */ SELECT STR_POSITION(120790, 470);
/* 17 */ SELECT STR_POSITION(120790, 470);
/* 19 */ SELECT STR_POSITION(120790, 120790);
/* 1 */ SELECT STR_POSITION(120790, 120790);
/* 2 */ SELECT STR_POSITION(120790, 120790);
/* 0 */ /* Shifting */ CREATE TABLE x (x BIT(16));
INSERT INTO x VALUES (55296);
INSERT INTO x SELECT x >> 1 FROM x;
INSERT INTO x SELECT x >> 2 FROM x;
INSERT INTO x SELECT x >> 4 FROM x;
INSERT INTO x SELECT x >> 8 FROM x;
SELECT STR_POSITION(x, 13), STR_POSITION(x, 27), x FROM x;
SELECT x, x >> 1 AS x, x << 1 AS x FROM x;
SELECT x, x >> 8 AS x, x << 8 AS x FROM x;
SELECT CAST(x AS BIT(15)), CAST(x AS BIT(15)) >> 1 AS x, CAST(x AS BIT(15)) << 1 AS x FROM x;
SELECT CAST(x AS BIT(15)), CAST(x AS BIT(15)) >> 8 AS x, CAST(x AS BIT(15)) << 8 AS x FROM x;
INSERT INTO x VALUES (27);
SELECT STR_POSITION(x, 13), STR_POSITION(x, 27), x FROM x;
SELECT x, x >> 1 AS x, x << 1 AS x FROM x;
SELECT x, x >> 8 AS x, x << 8 AS x FROM x;
DROP TABLE x;
DROP TABLE x;
/* Get/Set bit */ SELECT GET_BIT(2756, 10);
SELECT SET_BIT(22052, 15, 1);
SELECT SET_BIT(22052, 16, 1);
/* fail */ /* Overlay */ SELECT OVERLAY(348 PLACING '001' FROM 2 FOR 3);
SELECT OVERLAY(348 PLACING '101' FROM 6);
SELECT OVERLAY(348 PLACING '001' FROM 11);
SELECT OVERLAY(348 PLACING '001' FROM 20);
/* bit_count */ SELECT BIT_COUNT(CAST(348 AS BIT(10)));
SELECT BIT_COUNT(CAST(1023 AS BIT(10)));
SELECT BIT_COUNT(CAST(REPEAT('0', 100) AS BIT(100)));
SELECT BIT_COUNT(CAST(REPEAT('1', 100) AS BIT(100)));
SELECT BIT_COUNT(CAST(REPEAT('01', 500) AS BIT(1000)));
SELECT BIT_COUNT(CAST(REPEAT('10101', 200) AS BIT(1000)));
x AS x;
/* test non-error-throwing API for some core types */ SELECT PG_INPUT_IS_VALID('01010001', 'bit(10)');
SELECT * FROM x;
SELECT PG_INPUT_IS_VALID('01010Z01', 'bit(8)');
SELECT * FROM x;
SELECT PG_INPUT_IS_VALID('x01010Z01', 'bit(32)');
SELECT * FROM x;
SELECT PG_INPUT_IS_VALID('01010Z01', 'varbit');
SELECT * FROM x;
SELECT PG_INPUT_IS_VALID('x01010Z01', 'varbit');
SELECT * FROM x;
/* Test bitmap AND and OR */ /* Generate enough data that we can test the lossy bitmaps. */ /* There's 55 tuples per page in the table. 53 is just */ /* below 55, so that an index scan with qual a = constant */ /* will return at least one hit per page. 59 is just above */ /* 55, so that an index scan with qual b = constant will return */ /* hits on most but not all pages. 53 and 59 are prime, so that */ /* there's a maximum number of a,b combinations in the table. */ /* That allows us to test all the different combinations of */ /* lossy and non-lossy pages with the minimum amount of data */ CREATE TABLE x (x INT, x INT, x TEXT);
INSERT INTO x SELECT (x % 53), (x % 59), 'foooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo' FROM x AS x;
CREATE INDEX x ON x(x NULLS LAST);
CREATE INDEX x ON x(x NULLS LAST);
SET x = FALSE /* We want to use bitmapscans. With default settings, the planner currently */ /* chooses a bitmap scan for the queries below anyway, but let's make sure. */;
SET x = FALSE;
SET x = 64 /* Lower work_mem to trigger use of lossy bitmaps */;
/* Test bitmap-and. */ SELECT COUNT(*) FROM x WHERE x = 1 AND x = 1;
/* Test bitmap-or. */ SELECT COUNT(*) FROM x WHERE x = 1 OR x = 1;
/* clean up */ DROP TABLE x;
/* BOOLEAN */ /* sanity check - if this fails go insane! */ SELECT 1 AS x;
/* ******************testing built-in type bool******************** */ /* check bool input syntax */ SELECT TRUE AS x;
SELECT FALSE AS x;
SELECT CAST('t' AS BOOLEAN) AS x;
SELECT CAST('   f           ' AS BOOLEAN) AS x;
SELECT CAST('true' AS BOOLEAN) AS x;
SELECT CAST('test' AS BOOLEAN) AS x;
SELECT CAST('false' AS BOOLEAN) AS x;
SELECT CAST('foo' AS BOOLEAN) AS x;
SELECT CAST('y' AS BOOLEAN) AS x;
SELECT CAST('yes' AS BOOLEAN) AS x;
SELECT CAST('yeah' AS BOOLEAN) AS x;
SELECT CAST('n' AS BOOLEAN) AS x;
SELECT CAST('no' AS BOOLEAN) AS x;
SELECT CAST('nay' AS BOOLEAN) AS x;
SELECT CAST('on' AS BOOLEAN) AS x;
SELECT CAST('off' AS BOOLEAN) AS x;
SELECT CAST('of' AS BOOLEAN) AS x;
SELECT CAST('o' AS BOOLEAN) AS x;
SELECT CAST('on_' AS BOOLEAN) AS x;
SELECT CAST('off_' AS BOOLEAN) AS x;
SELECT CAST('1' AS BOOLEAN) AS x;
SELECT CAST('11' AS BOOLEAN) AS x;
SELECT CAST('0' AS BOOLEAN) AS x;
SELECT CAST('000' AS BOOLEAN) AS x;
SELECT CAST('' AS BOOLEAN) AS x;
/* Also try it with non-error-throwing API */ SELECT PG_INPUT_IS_VALID('true', 'bool');
SELECT PG_INPUT_IS_VALID('asdf', 'bool');
SELECT * FROM x;
/* and, or, not in qualifications */ SELECT CAST('t' AS BOOLEAN) OR CAST('f' AS BOOLEAN) AS x;
SELECT CAST('t' AS BOOLEAN) AND CAST('f' AS BOOLEAN) AS x;
SELECT NOT CAST('f' AS BOOLEAN) AS x;
SELECT CAST('t' AS BOOLEAN) = CAST('f' AS BOOLEAN) AS x;
SELECT CAST('t' AS BOOLEAN) <> CAST('f' AS BOOLEAN) AS x;
SELECT CAST('t' AS BOOLEAN) > CAST('f' AS BOOLEAN) AS x;
SELECT CAST('t' AS BOOLEAN) >= CAST('f' AS BOOLEAN) AS x;
SELECT CAST('f' AS BOOLEAN) < CAST('t' AS BOOLEAN) AS x;
SELECT CAST('f' AS BOOLEAN) <= CAST('t' AS BOOLEAN) AS x;
/* explicit casts to/from text */ SELECT CAST(CAST('TrUe' AS TEXT) AS BOOLEAN) AS x, CAST(CAST('fAlse' AS TEXT) AS BOOLEAN) AS x;
SELECT CAST(CAST('    true   ' AS TEXT) AS BOOLEAN) AS x, CAST(CAST('     FALSE' AS TEXT) AS BOOLEAN) AS x;
SELECT CAST(CAST(TRUE AS BOOLEAN) AS TEXT) AS x, CAST(CAST(FALSE AS BOOLEAN) AS TEXT) AS x;
SELECT CAST(CAST('  tru e ' AS TEXT) AS BOOLEAN) AS x;
/* error */ SELECT CAST(CAST('' AS TEXT) AS BOOLEAN) AS x;
/* error */ CREATE TABLE x (x BOOLEAN);
INSERT INTO x (x) VALUES (CAST('t' AS BOOLEAN));
INSERT INTO x (x) VALUES (CAST('True' AS BOOLEAN));
INSERT INTO x (x) VALUES (CAST('true' AS BOOLEAN));
/* BOOLTBL1 should be full of true's at this point */ SELECT x.* FROM x;
SELECT x.* FROM x WHERE x = CAST('true' AS BOOLEAN);
SELECT x.* FROM x WHERE x <> CAST('false' AS BOOLEAN);
SELECT x.* FROM x WHERE BOOLEQ(CAST('false' AS BOOLEAN), x);
INSERT INTO x (x) VALUES (CAST('f' AS BOOLEAN));
SELECT x.* FROM x WHERE x = CAST('false' AS BOOLEAN);
CREATE TABLE x (x BOOLEAN);
INSERT INTO x (x) VALUES (CAST('f' AS BOOLEAN));
INSERT INTO x (x) VALUES (CAST('false' AS BOOLEAN));
INSERT INTO x (x) VALUES (CAST('False' AS BOOLEAN));
INSERT INTO x (x) VALUES (CAST('FALSE' AS BOOLEAN));
/* This is now an invalid expression */ /* For pre-v6.3 this evaluated to false - thomas 1997-10-23 */ INSERT INTO x (x) VALUES (CAST('XXX' AS BOOLEAN));
/* BOOLTBL2 should be full of false's at this point */ SELECT x.* FROM x;
SELECT x.*, x.* FROM x, x WHERE x.x <> x.x;
SELECT x.*, x.* FROM x, x WHERE BOOLNE(x.x, x.x);
SELECT x.*, x.* FROM x, x WHERE x.x = x.x AND x.x = CAST('false' AS BOOLEAN);
SELECT x.*, x.* FROM x, x WHERE x.x = x.x OR x.x = CAST('true' AS BOOLEAN) ORDER BY x.x NULLS LAST, x.x NULLS LAST;
/* SQL syntax */ /* Try all combinations to ensure that we get nothing when we expect nothing */ /* - thomas 2000-01-04 */ SELECT x FROM x WHERE x IS TRUE;
SELECT x FROM x WHERE NOT x IS FALSE;
SELECT x FROM x WHERE x IS FALSE;
SELECT x FROM x WHERE NOT x IS TRUE;
SELECT x FROM x WHERE x IS TRUE;
SELECT x FROM x WHERE NOT x IS FALSE;
SELECT x FROM x WHERE x IS FALSE;
SELECT x FROM x WHERE NOT x IS TRUE;
/* Tests for BooleanTest */ CREATE TABLE x (x TEXT, x BOOLEAN, x INT);
INSERT INTO x (x, x, x) VALUES ('true', TRUE, 1);
INSERT INTO x (x, x, x) VALUES ('false', FALSE, 2);
INSERT INTO x (x, x, x) VALUES ('null', NULL, 3);
/* Test to make sure short-circuiting and NULL handling is */ /* correct. Use a table as source to prevent constant simplification */ /* from interfering. */ CREATE TABLE x (x BOOLEAN, x BOOLEAN, x BOOLEAN);
INSERT INTO x VALUES (FALSE, TRUE, NULL);
SELECT x AND x AND x FROM x;
SELECT x AND x AND x FROM x;
SELECT x AND x AND x FROM x;
SELECT x AND x AND x FROM x;
SELECT x AND x AND x FROM x;
/* OR expression need to return null if there's any nulls and none */ /* of the value is true */ SELECT x OR x OR x FROM x;
SELECT x OR x OR x FROM x;
SELECT x OR x OR x FROM x;
SELECT x OR x OR x FROM x;
SELECT x OR x OR x FROM x;
SELECT x OR x OR x FROM x;
/* Casts */ SELECT CAST(0 AS BOOLEAN);
SELECT CAST(1 AS BOOLEAN);
SELECT CAST(2 AS BOOLEAN);
/* Clean up */ /* Many tables are retained by the regression test, but these do not seem */ /*  particularly useful so just get rid of them for now. */ /*  - thomas 1997-11-30 */ DROP TABLE x;
DROP TABLE x;
DROP TABLE x;
DROP TABLE x;
/* BOX */ /* box logic */ /*	     o */ /* 3	  o--|X */ /*	  |  o| */ /* 2	+-+-+ | */ /*	| | | | */ /* 1	| o-+-o */ /*	|   | */ /* 0	+---+ */ /*	0 1 2 3 */ /* boxes are specified by two points, given by four floats x1,y1,x2,y2 */ CREATE TABLE x (x box);
INSERT INTO x (x) VALUES ('(2.0,2.0,0.0,0.0)');
INSERT INTO x (x) VALUES ('(1.0,1.0,3.0,3.0)');
INSERT INTO x (x) VALUES ('((-8, 2), (-2, -10))');
/* degenerate cases where the box is a line or a point */ /* note that lines and points boxes all have zero area */ INSERT INTO x (x) VALUES ('(2.5, 2.5, 2.5,3.5)');
INSERT INTO x (x) VALUES ('(3.0, 3.0,3.0,3.0)');
/* badly formatted box inputs */ INSERT INTO x (x) VALUES ('(2.3, 4.5)');
INSERT INTO x (x) VALUES ('[1, 2, 3, 4)');
INSERT INTO x (x) VALUES ('(1, 2, 3, 4]');
INSERT INTO x (x) VALUES ('(1, 2, 3, 4) x');
INSERT INTO x (x) VALUES ('asdfasdf(ad');
SELECT * FROM x;
SELECT x.*, AREA(x.x) AS x FROM x AS x;
/* center of box, left unary operator */ SELECT MATCH() AGAINST((x.x)) AS x FROM x AS x;
SELECT HEIGHT(x), WIDTH(x) FROM x;
/* Test the SP-GiST index */ CREATE TEMPORARY TABLE x (x box);
INSERT INTO x SELECT BOX(POINT(x, x), POINT(x * 2, x * 2)) FROM x AS x;
CREATE INDEX x ON x USING spgist(x NULLS LAST);
INSERT INTO x VALUES (NULL), ('(0,0)(0,100)'), ('(-3,4.3333333333)(40,1)'), ('(0,100)(0,infinity)'), ('(-infinity,0)(0,infinity)'), ('(-infinity,-infinity)(infinity,infinity)');
SET x = FALSE;
SELECT * FROM x WHERE x << '(10,20),(30,40)';
EXPLAIN (COSTS OFF) SELECT * FROM box_temp WHERE f1 << '(10,20),(30,40)';
EXPLAIN (COSTS OFF) SELECT * FROM box_temp WHERE f1 &< '(10,4.333334),(5,100)';
SELECT * FROM x WHERE x && '(15,20),(25,30)';
EXPLAIN (COSTS OFF) SELECT * FROM box_temp WHERE f1 && '(15,20),(25,30)';
EXPLAIN (COSTS OFF) SELECT * FROM box_temp WHERE f1 &> '(40,30),(45,50)';
SELECT * FROM x WHERE x >> '(30,40),(40,30)';
EXPLAIN (COSTS OFF) SELECT * FROM box_temp WHERE f1 >> '(30,40),(40,30)';
EXPLAIN (COSTS OFF) SELECT * FROM box_temp WHERE f1 <<| '(10,4.33334),(5,100)';
EXPLAIN (COSTS OFF) SELECT * FROM box_temp WHERE f1 &<| '(10,4.3333334),(5,1)';
EXPLAIN (COSTS OFF) SELECT * FROM box_temp WHERE f1 |&> '(49.99,49.99),(49.99,49.99)';
EXPLAIN (COSTS OFF) SELECT * FROM box_temp WHERE f1 |>> '(37,38),(39,40)';
SELECT * FROM x WHERE x @> '(10,11),(15,16)';
EXPLAIN (COSTS OFF) SELECT * FROM box_temp WHERE f1 @> '(10,11),(15,15)';
SELECT * FROM x WHERE '(10,15),(30,35)' @> x;
EXPLAIN (COSTS OFF) SELECT * FROM box_temp WHERE f1 <@ '(10,15),(30,35)';
EXPLAIN (COSTS OFF) SELECT * FROM box_temp WHERE f1 ~= '(20,20),(40,40)';
RESET enable_seqscan;
DROP INDEX x;
/* Test the SP-GiST index on the larger volume of data */ CREATE TABLE x (x INT, x box);
INSERT INTO x SELECT (x - 1) * 100 + x, BOX(POINT(x * 10, x * 10), POINT(x * 10 + 5, x * 10 + 5)) FROM x AS x, x AS x;
/* insert repeating data to test allTheSame */ INSERT INTO x SELECT x, '((200, 300),(210, 310))' FROM x AS x;
INSERT INTO x VALUES (11001, NULL), (11002, NULL), (11003, '((-infinity,-infinity),(infinity,infinity))'), (11004, '((-infinity,100),(-infinity,500))'), (11005, '((-infinity,-infinity),(700,infinity))');
CREATE INDEX x ON x USING spgist(x NULLS LAST);
SET x = ON /* get reference results for ORDER BY distance from seq scan */;
SET x = OFF;
SET x = OFF;
SET x = OFF;
SET x = ON;
SET x = ON;
SET x = ON /* test ORDER BY distance */;
SET x = OFF;
EXPLAIN (COSTS OFF) SELECT rank() OVER (ORDER BY b <-> point '123,456') n, b <-> point '123,456' dist, id FROM quad_box_tbl;
SELECT * FROM x AS x FULL JOIN x AS x ON x.x = x.x AND x.x = x.x AND (x.x = x.x OR x.x IS NULL AND x.x IS NULL) WHERE x.x IS NULL OR x.x IS NULL;
EXPLAIN (COSTS OFF) SELECT rank() OVER (ORDER BY b <-> point '123,456') n, b <-> point '123,456' dist, id FROM quad_box_tbl WHERE b <@ box '((200,300),(500,600))';
SELECT * FROM x AS x FULL JOIN x AS x ON x.x = x.x AND x.x = x.x AND (x.x = x.x OR x.x IS NULL AND x.x IS NULL) WHERE x.x IS NULL OR x.x IS NULL;
RESET enable_seqscan;
RESET enable_indexscan;
RESET enable_bitmapscan;
/* test non-error-throwing API for some core types */ SELECT PG_INPUT_IS_VALID('200', 'box');
SELECT * FROM x;
SELECT PG_INPUT_IS_VALID('((200,300),(500, xyz))', 'box');
SELECT * FROM x;
CREATE INDEX x ON x USING brin(x NULLS LAST, x NULLS LAST, x NULLS LAST, x NULLS LAST, x NULLS LAST, x NULLS LAST, x NULLS LAST, x NULLS LAST, x NULLS LAST, x NULLS LAST, x NULLS LAST, x NULLS LAST, x x NULLS LAST, x x NULLS LAST, x x NULLS LAST, x x NULLS LAST, x NULLS LAST, x NULLS LAST, x NULLS LAST, x NULLS LAST, x NULLS LAST, x NULLS LAST, x NULLS LAST, x NULLS LAST, x NULLS LAST, x NULLS LAST, x NULLS LAST, x NULLS LAST, x NULLS LAST, x NULLS LAST) WITH (pages_per_range=1);
CREATE TABLE x (x NAME, x TEXT, x ARRAY<TEXT>, x ARRAY<TEXT>, x ARRAY<INT>, CHECK (CARDINALITY(x) = CARDINALITY(x)), CHECK (CARDINALITY(x) = CARDINALITY(x)));
INSERT INTO x VALUES ('byteacol', 'bytea', '{>, >=, =, <=, <}', '{AAAAAA, AAAAAA, BNAAAABNAAAABNAAAABNAAAABNAAAABNAAAABNAAAABNAAAA, ZZZZZZ, ZZZZZZ}', '{100, 100, 1, 100, 100}'), ('charcol', '"char"', '{>, >=, =, <=, <}', '{A, A, M, Z, Z}', '{97, 100, 6, 100, 98}'), ('namecol', 'name', '{>, >=, =, <=, <}', '{AAAAAA, AAAAAA, MAAAAA, ZZAAAA, ZZAAAA}', '{100, 100, 2, 100, 100}'), ('int2col', 'int2', '{>, >=, =, <=, <}', '{0, 0, 800, 999, 999}', '{100, 100, 1, 100, 100}'), ('int2col', 'int4', '{>, >=, =, <=, <}', '{0, 0, 800, 999, 1999}', '{100, 100, 1, 100, 100}'), ('int2col', 'int8', '{>, >=, =, <=, <}', '{0, 0, 800, 999, 1428427143}', '{100, 100, 1, 100, 100}'), ('int4col', 'int2', '{>, >=, =, <=, <}', '{0, 0, 800, 1999, 1999}', '{100, 100, 1, 100, 100}'), ('int4col', 'int4', '{>, >=, =, <=, <}', '{0, 0, 800, 1999, 1999}', '{100, 100, 1, 100, 100}'), ('int4col', 'int8', '{>, >=, =, <=, <}', '{0, 0, 800, 1999, 1428427143}', '{100, 100, 1, 100, 100}'), ('int8col', 'int2', '{>, >=}', '{0, 0}', '{100, 100}'), ('int8col', 'int4', '{>, >=}', '{0, 0}', '{100, 100}'), ('int8col', 'int8', '{>, >=, =, <=, <}', '{0, 0, 1257141600, 1428427143, 1428427143}', '{100, 100, 1, 100, 100}'), ('textcol', 'text', '{>, >=, =, <=, <}', '{ABABAB, ABABAB, BNAAAABNAAAABNAAAABNAAAABNAAAABNAAAABNAAAABNAAAA, ZZAAAA, ZZAAAA}', '{100, 100, 1, 100, 100}'), ('oidcol', 'oid', '{>, >=, =, <=, <}', '{0, 0, 8800, 9999, 9999}', '{100, 100, 1, 100, 100}'), ('tidcol', 'tid', '{>, >=, =, <=, <}', '{"(0,0)", "(0,0)", "(8800,0)", "(9999,19)", "(9999,19)"}', '{100, 100, 1, 100, 100}'), ('float4col', 'float4', '{>, >=, =, <=, <}', '{0.0103093, 0.0103093, 1, 1, 1}', '{100, 100, 4, 100, 96}'), ('float4col', 'float8', '{>, >=, =, <=, <}', '{0.0103093, 0.0103093, 1, 1, 1}', '{100, 100, 4, 100, 96}'), ('float8col', 'float4', '{>, >=, =, <=, <}', '{0, 0, 0, 1.98, 1.98}', '{99, 100, 1, 100, 100}'), ('float8col', 'float8', '{>, >=, =, <=, <}', '{0, 0, 0, 1.98, 1.98}', '{99, 100, 1, 100, 100}'), ('macaddrcol', 'macaddr', '{>, >=, =, <=, <}', '{00:00:01:00:00:00, 00:00:01:00:00:00, 2c:00:2d:00:16:00, ff:fe:00:00:00:00, ff:fe:00:00:00:00}', '{99, 100, 2, 100, 100}'), ('inetcol', 'inet', '{&&, =, <, <=, >, >=, >>=, >>, <<=, <<}', '{10/8, 10.2.14.231/24, 255.255.255.255, 255.255.255.255, 0.0.0.0, 0.0.0.0, 10.2.14.231/24, 10.2.14.231/25, 10.2.14.231/8, 0/0}', '{100, 1, 100, 100, 125, 125, 2, 2, 100, 100}'), ('inetcol', 'inet', '{&&, >>=, <<=, =}', '{fe80::6e40:8ff:fea9:a673/32, fe80::6e40:8ff:fea9:8c46, fe80::6e40:8ff:fea9:a673/32, fe80::6e40:8ff:fea9:8c46}', '{25, 1, 25, 1}'), ('inetcol', 'cidr', '{&&, <, <=, >, >=, >>=, >>, <<=, <<}', '{10/8, 255.255.255.255, 255.255.255.255, 0.0.0.0, 0.0.0.0, 10.2.14/24, 10.2.14/25, 10/8, 0/0}', '{100, 100, 100, 125, 125, 2, 2, 100, 100}'), ('inetcol', 'cidr', '{&&, >>=, <<=, =}', '{fe80::/32, fe80::6e40:8ff:fea9:8c46, fe80::/32, fe80::6e40:8ff:fea9:8c46}', '{25, 1, 25, 1}'), ('cidrcol', 'inet', '{&&, =, <, <=, >, >=, >>=, >>, <<=, <<}', '{10/8, 10.2.14/24, 255.255.255.255, 255.255.255.255, 0.0.0.0, 0.0.0.0, 10.2.14.231/24, 10.2.14.231/25, 10.2.14.231/8, 0/0}', '{100, 2, 100, 100, 125, 125, 2, 2, 100, 100}'), ('cidrcol', 'inet', '{&&, >>=, <<=, =}', '{fe80::6e40:8ff:fea9:a673/32, fe80::6e40:8ff:fea9:8c46, fe80::6e40:8ff:fea9:a673/32, fe80::6e40:8ff:fea9:8c46}', '{25, 1, 25, 1}'), ('cidrcol', 'cidr', '{&&, =, <, <=, >, >=, >>=, >>, <<=, <<}', '{10/8, 10.2.14/24, 255.255.255.255, 255.255.255.255, 0.0.0.0, 0.0.0.0, 10.2.14/24, 10.2.14/25, 10/8, 0/0}', '{100, 2, 100, 100, 125, 125, 2, 2, 100, 100}'), ('cidrcol', 'cidr', '{&&, >>=, <<=, =}', '{fe80::/32, fe80::6e40:8ff:fea9:8c46, fe80::/32, fe80::6e40:8ff:fea9:8c46}', '{25, 1, 25, 1}'), ('bpcharcol', 'bpchar', '{>, >=, =, <=, <}', '{A, A, W, Z, Z}', '{97, 100, 6, 100, 98}'), ('datecol', 'date', '{>, >=, =, <=, <}', '{1995-08-15, 1995-08-15, 2009-12-01, 2022-12-30, 2022-12-30}', '{100, 100, 1, 100, 100}'), ('timecol', 'time', '{>, >=, =, <=, <}', '{01:20:30, 01:20:30, 02:28:57, 06:28:31.5, 06:28:31.5}', '{100, 100, 1, 100, 100}'), ('timestampcol', 'timestamp', '{>, >=, =, <=, <}', '{1942-07-23 03:05:09, 1942-07-23 03:05:09, 1964-03-24 19:26:45, 1984-01-20 22:42:21, 1984-01-20 22:42:21}', '{100, 100, 1, 100, 100}'), ('timestampcol', 'timestamptz', '{>, >=, =, <=, <}', '{1942-07-23 03:05:09, 1942-07-23 03:05:09, 1964-03-24 19:26:45, 1984-01-20 22:42:21, 1984-01-20 22:42:21}', '{100, 100, 1, 100, 100}'), ('timestamptzcol', 'timestamptz', '{>, >=, =, <=, <}', '{1972-10-10 03:00:00-04, 1972-10-10 03:00:00-04, 1972-10-19 09:00:00-07, 1972-11-20 19:00:00-03, 1972-11-20 19:00:00-03}', '{100, 100, 1, 100, 100}'), ('intervalcol', 'interval', '{>, >=, =, <=, <}', '{00:00:00, 00:00:00, 1 mons 13 days 12:24, 2 mons 23 days 07:48:00, 1 year}', '{100, 100, 1, 100, 100}'), ('timetzcol', 'timetz', '{>, >=, =, <=, <}', '{01:30:20+02, 01:30:20+02, 01:35:50+02, 23:55:05+02, 23:55:05+02}', '{99, 100, 2, 100, 100}'), ('bitcol', 'bit(10)', '{>, >=, =, <=, <}', '{0000000010, 0000000010, 0011011110, 1111111000, 1111111000}', '{100, 100, 1, 100, 100}'), ('varbitcol', 'varbit(16)', '{>, >=, =, <=, <}', '{0000000000000100, 0000000000000100, 0001010001100110, 1111111111111000, 1111111111111000}', '{100, 100, 1, 100, 100}'), ('numericcol', 'numeric', '{>, >=, =, <=, <}', '{0.00, 0.01, 2268164.347826086956521739130434782609, 99470151.9, 99470151.9}', '{100, 100, 1, 100, 100}'), ('uuidcol', 'uuid', '{>, >=, =, <=, <}', '{00040004-0004-0004-0004-000400040004, 00040004-0004-0004-0004-000400040004, 52225222-5222-5222-5222-522252225222, 99989998-9998-9998-9998-999899989998, 99989998-9998-9998-9998-999899989998}', '{100, 100, 1, 100, 100}'), ('int4rangecol', 'int4range', '{<<, &<, &&, &>, >>, @>, <@, =, <, <=, >, >=}', '{"[10000,)","[10000,)","(,]","[3,4)","[36,44)","(1500,1501]","[3,4)","[222,1222)","[36,44)","[43,1043)","[367,4466)","[519,)"}', '{53, 53, 53, 53, 50, 22, 72, 1, 74, 75, 34, 21}'), ('int4rangecol', 'int4range', '{@>, <@, =, <=, >, >=}', '{empty, empty, empty, empty, empty, empty}', '{125, 72, 72, 72, 53, 125}'), ('int4rangecol', 'int4', '{@>}', '{1500}', '{22}'), ('lsncol', 'pg_lsn', '{>, >=, =, <=, <, IS, IS NOT}', '{0/1200, 0/1200, 44/455222, 198/1999799, 198/1999799, NULL, NULL}', '{100, 100, 1, 100, 100, 25, 100}'), ('boxcol', 'point', '{@>}', '{"(500,43)"}', '{11}'), ('boxcol', 'box', '{<<, &<, &&, &>, >>, <<|, &<|, |&>, |>>, @>, <@, ~=}', '{"((1000,2000),(3000,4000))","((1,2),(3000,4000))","((1,2),(3000,4000))","((1,2),(3000,4000))","((1,2),(3,4))","((1000,2000),(3000,4000))","((1,2000),(3,4000))","((1000,2),(3000,4))","((1,2),(3,4))","((1,2),(300,400))","((1,2),(3000,4000))","((222,1222),(44,45))"}', '{100, 100, 100, 99, 96, 100, 100, 99, 96, 1, 99, 1}');
x AS x;
x AS x;
x AS x;
x AS x;
x AS x;
BEGIN FOR r IN SELECT colname, oper, typ, value[ordinality], matches[ordinality] FROM brinopers, unnest(op) WITH ORDINALITY AS oper LOOP  		-- prepare the condition 		IF r.value IS NULL THEN 			cond := format('%I %s %L', r.colname, r.oper, r.value);
SET x = 0 /* run the query using the brin index */;
SET x = 1;
x := FALSE;
IF NOT plan_ok THEN 			RAISE WARNING 'did not get bitmap indexscan plan for %', r;
EXECUTE format($y$SELECT array_agg(ctid) FROM brintest WHERE %s $y$, cond) 			INTO idx_ctids;
SET x = 1 /* run the query using a seqscan */;
SET x = 0;
x := FALSE;
IF NOT plan_ok THEN 			RAISE WARNING 'did not get seqscan plan for %', r;
EXECUTE format($y$SELECT array_agg(ctid) FROM brintest WHERE %s $y$, cond) 			INTO ss_ctids;
x := ARRAY_LENGTH(x);
IF NOT (count = array_length(ss_ctids, 1) AND 				idx_ctids @> ss_ctids AND 				idx_ctids <@ ss_ctids) THEN 			-- report the results of each scan to make the differences obvious 			RAISE WARNING 'something not right in %: count %', r, count;
SET x = 1;
SET x = 0;
SET x = 0;
SET x = 1;
IF count != r.matches THEN RAISE WARNING 'unexpected number of results % for %', count, r;
COMMIT;
RESET enable_seqscan;
RESET enable_bitmapscan;
SELECT BRIN_DESUMMARIZE_RANGE('brinidx', 0);
VACUUM brintest;
/* force a summarization cycle in brinidx */ UPDATE x SET x = x * x;
UPDATE x SET x = '' WHERE NOT x IS NULL;
/* Tests for brin_summarize_new_values */ SELECT BRIN_SUMMARIZE_NEW_VALUES('brintest');
/* error, not an index */ SELECT BRIN_SUMMARIZE_NEW_VALUES('tenk1_unique1');
/* error, not a BRIN index */ SELECT BRIN_SUMMARIZE_NEW_VALUES('brinidx');
/* ok, no change expected */ /* Tests for brin_desummarize_range */ SELECT BRIN_DESUMMARIZE_RANGE('brinidx', -1);
/* error, invalid range */ SELECT BRIN_DESUMMARIZE_RANGE('brinidx', 0);
SELECT BRIN_DESUMMARIZE_RANGE('brinidx', 0);
SELECT BRIN_DESUMMARIZE_RANGE('brinidx', 100000000);
/* Test brin_summarize_range */ CREATE TABLE x (x INT) WITH (fillfactor=10, autovacuum_enabled=FALSE);
CREATE INDEX x ON x USING brin(x NULLS LAST) WITH (pages_per_range=2);
BEGIN LOOP     INSERT INTO brin_summarize VALUES (1) RETURNING ctid INTO curtid;
COMMIT;
/* summarize one range */ SELECT BRIN_SUMMARIZE_RANGE('brin_summarize_idx', 0);
/* nothing: already summarized */ SELECT BRIN_SUMMARIZE_RANGE('brin_summarize_idx', 1);
/* summarize one range */ SELECT BRIN_SUMMARIZE_RANGE('brin_summarize_idx', 2);
/* nothing: page doesn't exist in table */ SELECT BRIN_SUMMARIZE_RANGE('brin_summarize_idx', 4294967295);
/* invalid block number values */ SELECT BRIN_SUMMARIZE_RANGE('brin_summarize_idx', -1);
SELECT BRIN_SUMMARIZE_RANGE('brin_summarize_idx', 4294967296);
/* test value merging in add_value */ CREATE TABLE x (x NUMRANGE);
CREATE INDEX x ON x USING brin(x NULLS LAST);
INSERT INTO x VALUES ('empty');
INSERT INTO x VALUES (NUMRANGE(0, POWER(2, CAST(1000 AS DECIMAL))));
INSERT INTO x VALUES ('(-1, 0)');
SELECT BRIN_DESUMMARIZE_RANGE('brinidx', 0);
SELECT BRIN_SUMMARIZE_RANGE('brinidx', 0);
DROP TABLE x;
/* test brin cost estimates behave sanely based on correlation of values */ CREATE TABLE x (x INT, x INT);
INSERT INTO x SELECT x / 100, x % 100 FROM x AS x;
CREATE INDEX x ON x USING brin(x NULLS LAST) WITH (pages_per_range=2);
CREATE INDEX x ON x USING brin(x NULLS LAST) WITH (pages_per_range=2);
VACUUM ANALYZE brin_test;
/* Ensure brin index is used when columns are perfectly correlated */ EXPLAIN (COSTS OFF) SELECT * FROM brin_test WHERE a = 1;
/* Ensure brin index is not used when values are not correlated */ EXPLAIN (COSTS OFF) SELECT * FROM brin_test WHERE b = 1;
/* make sure data are properly de-toasted in BRIN index */ CREATE TABLE x (x TEXT, x TEXT, x TEXT, x TEXT);
/* long random strings (~2000 chars each, so ~6kB for min/max on two */ /* columns) to trigger toasting */ WITH x AS (SELECT GROUP_CONCAT(FIPSHASH(CAST(x AS TEXT)), '') AS x FROM x AS x) INSERT INTO x SELECT x, x, x, x FROM x;
CREATE INDEX x ON x USING brin(x NULLS LAST, x NULLS LAST);
DELETE FROM x;
/* We need to wait a bit for all transactions to complete, so that the */ /* vacuum actually removes the TOAST rows. Creating an index concurrently */ /* is a one way to achieve that, because it does exactly such wait. */ CREATE INDEX CONCURRENTLY x ON x(x NULLS LAST);
DROP INDEX x;
/* vacuum the table, to discard TOAST data */ VACUUM brintest_3;
/* retry insert with a different random-looking (but deterministic) value */ /* the value is different, and so should replace either min or max in the */ /* brin summary */ WITH x AS (SELECT GROUP_CONCAT(FIPSHASH(CAST((-x) AS TEXT)), '') AS x FROM x AS x) INSERT INTO x SELECT x, x, x, x FROM x;
SET x = off /* now try some queries, accessing the brin index */;
EXPLAIN (COSTS OFF) SELECT * FROM brintest_3 WHERE b < '0';
SELECT * FROM x WHERE x < '0';
DROP TABLE x;
RESET enable_seqscan;
/* test parallel build with immutable function. */ CREATE TABLE x (x INT);
CREATE FUNCTION x() RETURNS INT LANGUAGE sql IMMUTABLE AS RETURN 0;
BEGIN;
SET LOCAL x = 0;
SET LOCAL x = 4;
CREATE INDEX x ON x USING brin(BRINTEST_FUNC() NULLS LAST);
COMMIT;
DROP TABLE x;
DROP FUNCTION x;
/* test an unlogged table, mostly to get coverage of brinbuildempty */ CREATE UNLOGGED TABLE x (x NUMRANGE);
CREATE INDEX x ON x USING brin(x NULLS LAST);
INSERT INTO x VALUES (NUMRANGE(0, POWER(2, CAST(1000 AS DECIMAL))));
DROP TABLE x;
/* test that the insert optimization works if no rows end up inserted */ CREATE TABLE x (x INT);
INSERT INTO x VALUES (1);
CREATE INDEX x ON x USING brin(x NULLS LAST);
UPDATE x SET x = x;
REINDEX INDEX CONCURRENTLY brin_insert_optimization_idx;
DROP TABLE x;
CREATE TABLE x (x VARBINARY, x CHAR, x NAME, x BIGINT, x SMALLINT, x INT, x TEXT, x OID, x FLOAT, x DOUBLE, x macaddr, x INET, x cidr, x CHAR, x DATE, x TIME, x TIMESTAMP, x TIMESTAMPTZ, x INTERVAL, x TIMETZ, x DECIMAL, x UUID, x pg_lsn) WITH (fillfactor=10);
/* test bloom specific index options */ /* ndistinct must be >= -1.0 */ CREATE INDEX x ON x USING brin(x x NULLS LAST);
/* false_positive_rate must be between 0.0001 and 0.25 */ CREATE INDEX x ON x USING brin(x x NULLS LAST);
CREATE INDEX x ON x USING brin(x x NULLS LAST);
CREATE INDEX x ON x USING brin(x x NULLS LAST, x x NULLS LAST, x x NULLS LAST, x x NULLS LAST, x x NULLS LAST, x x NULLS LAST, x x NULLS LAST, x x NULLS LAST, x x NULLS LAST, x x NULLS LAST, x x NULLS LAST, x x NULLS LAST, x x NULLS LAST, x x NULLS LAST, x x NULLS LAST, x x NULLS LAST, x x NULLS LAST, x x NULLS LAST, x x NULLS LAST, x x NULLS LAST, x x NULLS LAST, x x NULLS LAST, x x NULLS LAST) WITH (pages_per_range=1);
CREATE TABLE x (x NAME, x TEXT, x ARRAY<TEXT>, x ARRAY<TEXT>, x ARRAY<INT>, CHECK (CARDINALITY(x) = CARDINALITY(x)), CHECK (CARDINALITY(x) = CARDINALITY(x)));
INSERT INTO x VALUES ('byteacol', 'bytea', '{=}', '{BNAAAABNAAAABNAAAABNAAAABNAAAABNAAAABNAAAABNAAAA}', '{1}'), ('charcol', '"char"', '{=}', '{M}', '{6}'), ('namecol', 'name', '{=}', '{MAAAAA}', '{2}'), ('int2col', 'int2', '{=}', '{800}', '{1}'), ('int4col', 'int4', '{=}', '{800}', '{1}'), ('int8col', 'int8', '{=}', '{1257141600}', '{1}'), ('textcol', 'text', '{=}', '{BNAAAABNAAAABNAAAABNAAAABNAAAABNAAAABNAAAABNAAAA}', '{1}'), ('oidcol', 'oid', '{=}', '{8800}', '{1}'), ('float4col', 'float4', '{=}', '{1}', '{4}'), ('float8col', 'float8', '{=}', '{0}', '{1}'), ('macaddrcol', 'macaddr', '{=}', '{2c:00:2d:00:16:00}', '{2}'), ('inetcol', 'inet', '{=}', '{10.2.14.231/24}', '{1}'), ('inetcol', 'cidr', '{=}', '{fe80::6e40:8ff:fea9:8c46}', '{1}'), ('cidrcol', 'inet', '{=}', '{10.2.14/24}', '{2}'), ('cidrcol', 'inet', '{=}', '{fe80::6e40:8ff:fea9:8c46}', '{1}'), ('cidrcol', 'cidr', '{=}', '{10.2.14/24}', '{2}'), ('cidrcol', 'cidr', '{=}', '{fe80::6e40:8ff:fea9:8c46}', '{1}'), ('bpcharcol', 'bpchar', '{=}', '{W}', '{6}'), ('datecol', 'date', '{=}', '{2009-12-01}', '{1}'), ('timecol', 'time', '{=}', '{02:28:57}', '{1}'), ('timestampcol', 'timestamp', '{=}', '{1964-03-24 19:26:45}', '{1}'), ('timestamptzcol', 'timestamptz', '{=}', '{1972-10-19 09:00:00-07}', '{1}'), ('intervalcol', 'interval', '{=}', '{1 mons 13 days 12:24}', '{1}'), ('timetzcol', 'timetz', '{=}', '{01:35:50+02}', '{2}'), ('numericcol', 'numeric', '{=}', '{2268164.347826086956521739130434782609}', '{1}'), ('uuidcol', 'uuid', '{=}', '{52225222-5222-5222-5222-522252225222}', '{1}'), ('lsncol', 'pg_lsn', '{=, IS, IS NOT}', '{44/455222, NULL, NULL}', '{1, 25, 100}');
x AS x;
x AS x;
x AS x;
x AS x;
x AS x;
BEGIN FOR r IN SELECT colname, oper, typ, value[ordinality], matches[ordinality] FROM brinopers_bloom, unnest(op) WITH ORDINALITY AS oper LOOP  		-- prepare the condition 		IF r.value IS NULL THEN 			cond := format('%I %s %L', r.colname, r.oper, r.value);
SET x = 0 /* run the query using the brin index */;
SET x = 1;
x := FALSE;
IF NOT plan_ok THEN 			RAISE WARNING 'did not get bitmap indexscan plan for %', r;
EXECUTE format($y$SELECT array_agg(ctid) FROM brintest_bloom WHERE %s $y$, cond) 			INTO idx_ctids;
SET x = 1 /* run the query using a seqscan */;
SET x = 0;
x := FALSE;
IF NOT plan_ok THEN 			RAISE WARNING 'did not get seqscan plan for %', r;
EXECUTE format($y$SELECT array_agg(ctid) FROM brintest_bloom WHERE %s $y$, cond) 			INTO ss_ctids;
x := ARRAY_LENGTH(x);
IF NOT (count = array_length(ss_ctids, 1) AND 				idx_ctids @> ss_ctids AND 				idx_ctids <@ ss_ctids) THEN 			-- report the results of each scan to make the differences obvious 			RAISE WARNING 'something not right in %: count %', r, count;
SET x = 1;
SET x = 0;
SET x = 0;
SET x = 1;
IF count != r.matches THEN RAISE WARNING 'unexpected number of results % for %', count, r;
COMMIT;
RESET enable_seqscan;
RESET enable_bitmapscan;
SELECT BRIN_DESUMMARIZE_RANGE('brinidx_bloom', 0);
VACUUM brintest_bloom;
/* force a summarization cycle in brinidx */ UPDATE x SET x = x * x;
UPDATE x SET x = '' WHERE NOT x IS NULL;
/* Tests for brin_summarize_new_values */ SELECT BRIN_SUMMARIZE_NEW_VALUES('brintest_bloom');
/* error, not an index */ SELECT BRIN_SUMMARIZE_NEW_VALUES('tenk1_unique1');
/* error, not a BRIN index */ SELECT BRIN_SUMMARIZE_NEW_VALUES('brinidx_bloom');
/* ok, no change expected */ /* Tests for brin_desummarize_range */ SELECT BRIN_DESUMMARIZE_RANGE('brinidx_bloom', -1);
/* error, invalid range */ SELECT BRIN_DESUMMARIZE_RANGE('brinidx_bloom', 0);
SELECT BRIN_DESUMMARIZE_RANGE('brinidx_bloom', 0);
SELECT BRIN_DESUMMARIZE_RANGE('brinidx_bloom', 100000000);
/* Test brin_summarize_range */ CREATE TABLE x (x INT) WITH (fillfactor=10, autovacuum_enabled=FALSE);
CREATE INDEX x ON x USING brin(x NULLS LAST) WITH (pages_per_range=2);
BEGIN LOOP     INSERT INTO brin_summarize_bloom VALUES (1) RETURNING ctid INTO curtid;
COMMIT;
/* summarize one range */ SELECT BRIN_SUMMARIZE_RANGE('brin_summarize_bloom_idx', 0);
/* nothing: already summarized */ SELECT BRIN_SUMMARIZE_RANGE('brin_summarize_bloom_idx', 1);
/* summarize one range */ SELECT BRIN_SUMMARIZE_RANGE('brin_summarize_bloom_idx', 2);
/* nothing: page doesn't exist in table */ SELECT BRIN_SUMMARIZE_RANGE('brin_summarize_bloom_idx', 4294967295);
/* invalid block number values */ SELECT BRIN_SUMMARIZE_RANGE('brin_summarize_bloom_idx', -1);
SELECT BRIN_SUMMARIZE_RANGE('brin_summarize_bloom_idx', 4294967296);
/* test brin cost estimates behave sanely based on correlation of values */ CREATE TABLE x (x INT, x INT);
INSERT INTO x SELECT x / 100, x % 100 FROM x AS x;
CREATE INDEX x ON x USING brin(x NULLS LAST) WITH (pages_per_range=2);
CREATE INDEX x ON x USING brin(x NULLS LAST) WITH (pages_per_range=2);
VACUUM ANALYZE brin_test_bloom;
/* Ensure brin index is used when columns are perfectly correlated */ EXPLAIN (COSTS OFF) SELECT * FROM brin_test_bloom WHERE a = 1;
/* Ensure brin index is not used when values are not correlated */ EXPLAIN (COSTS OFF) SELECT * FROM brin_test_bloom WHERE b = 1;
CREATE TABLE x (x BIGINT, x SMALLINT, x INT, x OID, x tid, x FLOAT, x DOUBLE, x macaddr, x macaddr8, x INET, x cidr, x DATE, x TIME, x TIMESTAMP, x TIMESTAMPTZ, x INTERVAL, x TIMETZ, x DECIMAL, x UUID, x pg_lsn) WITH (fillfactor=10);
/* test minmax-multi specific index options */ /* number of values must be >= 16 */ CREATE INDEX x ON x USING brin(x x NULLS LAST);
/* number of values must be <= 256 */ CREATE INDEX x ON x USING brin(x x NULLS LAST);
/* first create an index with a single page range, to force compaction */ /* due to exceeding the number of values per summary */ CREATE INDEX x ON x USING brin(x x NULLS LAST, x x NULLS LAST, x x NULLS LAST, x x NULLS LAST, x x NULLS LAST, x x NULLS LAST, x x NULLS LAST, x x NULLS LAST, x x NULLS LAST, x x NULLS LAST, x x NULLS LAST, x x NULLS LAST, x x NULLS LAST, x x NULLS LAST, x x NULLS LAST, x x NULLS LAST, x x NULLS LAST, x x NULLS LAST, x x NULLS LAST, x x NULLS LAST);
DROP INDEX x;
CREATE INDEX x ON x USING brin(x x NULLS LAST, x x NULLS LAST, x x NULLS LAST, x x NULLS LAST, x x NULLS LAST, x x NULLS LAST, x x NULLS LAST, x x NULLS LAST, x x NULLS LAST, x x NULLS LAST, x x NULLS LAST, x x NULLS LAST, x x NULLS LAST, x x NULLS LAST, x x NULLS LAST, x x NULLS LAST, x x NULLS LAST, x x NULLS LAST, x x NULLS LAST, x x NULLS LAST) WITH (pages_per_range=1);
CREATE TABLE x (x NAME, x TEXT, x ARRAY<TEXT>, x ARRAY<TEXT>, x ARRAY<INT>, CHECK (CARDINALITY(x) = CARDINALITY(x)), CHECK (CARDINALITY(x) = CARDINALITY(x)));
INSERT INTO x VALUES ('int2col', 'int2', '{>, >=, =, <=, <}', '{0, 0, 800, 999, 999}', '{100, 100, 1, 100, 100}'), ('int2col', 'int4', '{>, >=, =, <=, <}', '{0, 0, 800, 999, 1999}', '{100, 100, 1, 100, 100}'), ('int2col', 'int8', '{>, >=, =, <=, <}', '{0, 0, 800, 999, 1428427143}', '{100, 100, 1, 100, 100}'), ('int4col', 'int2', '{>, >=, =, <=, <}', '{0, 0, 800, 1999, 1999}', '{100, 100, 1, 100, 100}'), ('int4col', 'int4', '{>, >=, =, <=, <}', '{0, 0, 800, 1999, 1999}', '{100, 100, 1, 100, 100}'), ('int4col', 'int8', '{>, >=, =, <=, <}', '{0, 0, 800, 1999, 1428427143}', '{100, 100, 1, 100, 100}'), ('int8col', 'int2', '{>, >=}', '{0, 0}', '{100, 100}'), ('int8col', 'int4', '{>, >=}', '{0, 0}', '{100, 100}'), ('int8col', 'int8', '{>, >=, =, <=, <}', '{0, 0, 1257141600, 1428427143, 1428427143}', '{100, 100, 1, 100, 100}'), ('oidcol', 'oid', '{>, >=, =, <=, <}', '{0, 0, 8800, 9999, 9999}', '{100, 100, 1, 100, 100}'), ('tidcol', 'tid', '{>, >=, =, <=, <}', '{"(0,0)", "(0,0)", "(8800,0)", "(9999,19)", "(9999,19)"}', '{100, 100, 1, 100, 100}'), ('float4col', 'float4', '{>, >=, =, <=, <}', '{0.0103093, 0.0103093, 1, 1, 1}', '{100, 100, 4, 100, 96}'), ('float4col', 'float8', '{>, >=, =, <=, <}', '{0.0103093, 0.0103093, 1, 1, 1}', '{100, 100, 4, 100, 96}'), ('float8col', 'float4', '{>, >=, =, <=, <}', '{0, 0, 0, 1.98, 1.98}', '{99, 100, 1, 100, 100}'), ('float8col', 'float8', '{>, >=, =, <=, <}', '{0, 0, 0, 1.98, 1.98}', '{99, 100, 1, 100, 100}'), ('macaddrcol', 'macaddr', '{>, >=, =, <=, <}', '{00:00:01:00:00:00, 00:00:01:00:00:00, 2c:00:2d:00:16:00, ff:fe:00:00:00:00, ff:fe:00:00:00:00}', '{99, 100, 2, 100, 100}'), ('macaddr8col', 'macaddr8', '{>, >=, =, <=, <}', '{b1:d1:0e:7b:af:a4:42:12, d9:35:91:bd:f7:86:0e:1e, 72:8f:20:6c:2a:01:bf:57, 23:e8:46:63:86:07:ad:cb, 13:16:8e:6a:2e:6c:84:b4}', '{31, 17, 1, 11, 4}'), ('inetcol', 'inet', '{=, <, <=, >, >=}', '{10.2.14.231/24, 255.255.255.255, 255.255.255.255, 0.0.0.0, 0.0.0.0}', '{1, 100, 100, 125, 125}'), ('inetcol', 'cidr', '{<, <=, >, >=}', '{255.255.255.255, 255.255.255.255, 0.0.0.0, 0.0.0.0}', '{100, 100, 125, 125}'), ('cidrcol', 'inet', '{=, <, <=, >, >=}', '{10.2.14/24, 255.255.255.255, 255.255.255.255, 0.0.0.0, 0.0.0.0}', '{2, 100, 100, 125, 125}'), ('cidrcol', 'cidr', '{=, <, <=, >, >=}', '{10.2.14/24, 255.255.255.255, 255.255.255.255, 0.0.0.0, 0.0.0.0}', '{2, 100, 100, 125, 125}'), ('datecol', 'date', '{>, >=, =, <=, <}', '{1995-08-15, 1995-08-15, 2009-12-01, 2022-12-30, 2022-12-30}', '{100, 100, 1, 100, 100}'), ('timecol', 'time', '{>, >=, =, <=, <}', '{01:20:30, 01:20:30, 02:28:57, 06:28:31.5, 06:28:31.5}', '{100, 100, 1, 100, 100}'), ('timestampcol', 'timestamp', '{>, >=, =, <=, <}', '{1942-07-23 03:05:09, 1942-07-23 03:05:09, 1964-03-24 19:26:45, 1984-01-20 22:42:21, 1984-01-20 22:42:21}', '{100, 100, 1, 100, 100}'), ('timestampcol', 'timestamptz', '{>, >=, =, <=, <}', '{1942-07-23 03:05:09, 1942-07-23 03:05:09, 1964-03-24 19:26:45, 1984-01-20 22:42:21, 1984-01-20 22:42:21}', '{100, 100, 1, 100, 100}'), ('timestamptzcol', 'timestamptz', '{>, >=, =, <=, <}', '{1972-10-10 03:00:00-04, 1972-10-10 03:00:00-04, 1972-10-19 09:00:00-07, 1972-11-20 19:00:00-03, 1972-11-20 19:00:00-03}', '{100, 100, 1, 100, 100}'), ('intervalcol', 'interval', '{>, >=, =, <=, <}', '{00:00:00, 00:00:00, 1 mons 13 days 12:24, 2 mons 23 days 07:48:00, 1 year}', '{100, 100, 1, 100, 100}'), ('timetzcol', 'timetz', '{>, >=, =, <=, <}', '{01:30:20+02, 01:30:20+02, 01:35:50+02, 23:55:05+02, 23:55:05+02}', '{99, 100, 2, 100, 100}'), ('numericcol', 'numeric', '{>, >=, =, <=, <}', '{0.00, 0.01, 2268164.347826086956521739130434782609, 99470151.9, 99470151.9}', '{100, 100, 1, 100, 100}'), ('uuidcol', 'uuid', '{>, >=, =, <=, <}', '{00040004-0004-0004-0004-000400040004, 00040004-0004-0004-0004-000400040004, 52225222-5222-5222-5222-522252225222, 99989998-9998-9998-9998-999899989998, 99989998-9998-9998-9998-999899989998}', '{100, 100, 1, 100, 100}'), ('lsncol', 'pg_lsn', '{>, >=, =, <=, <, IS, IS NOT}', '{0/1200, 0/1200, 44/455222, 198/1999799, 198/1999799, NULL, NULL}', '{100, 100, 1, 100, 100, 25, 100}');
x AS x;
x AS x;
x AS x;
x AS x;
x AS x;
BEGIN FOR r IN SELECT colname, oper, typ, value[ordinality], matches[ordinality] FROM brinopers_multi, unnest(op) WITH ORDINALITY AS oper LOOP  		-- prepare the condition 		IF r.value IS NULL THEN 			cond := format('%I %s %L', r.colname, r.oper, r.value);
SET x = 0 /* run the query using the brin index */;
SET x = 1;
x := FALSE;
IF NOT plan_ok THEN 			RAISE WARNING 'did not get bitmap indexscan plan for %', r;
EXECUTE format($y$SELECT array_agg(ctid) FROM brintest_multi WHERE %s $y$, cond) 			INTO idx_ctids;
SET x = 1 /* run the query using a seqscan */;
SET x = 0;
x := FALSE;
IF NOT plan_ok THEN 			RAISE WARNING 'did not get seqscan plan for %', r;
EXECUTE format($y$SELECT array_agg(ctid) FROM brintest_multi WHERE %s $y$, cond) 			INTO ss_ctids;
x := ARRAY_LENGTH(x);
IF NOT (count = array_length(ss_ctids, 1) AND 				idx_ctids @> ss_ctids AND 				idx_ctids <@ ss_ctids) THEN 			-- report the results of each scan to make the differences obvious 			RAISE WARNING 'something not right in %: count %', r, count;
SET x = 1;
SET x = 0;
SET x = 0;
SET x = 1;
IF count != r.matches THEN RAISE WARNING 'unexpected number of results % for %', count, r;
COMMIT;
RESET enable_seqscan;
RESET enable_bitmapscan;
SELECT BRIN_DESUMMARIZE_RANGE('brinidx_multi', 0);
VACUUM brintest_multi;
/* force a summarization cycle in brinidx */ /* Try inserting a values with NaN, to test distance calculation. */ INSERT INTO x.x (x) VALUES (CAST('nan' AS FLOAT));
INSERT INTO x.x (x) VALUES (CAST('nan' AS FLOAT));
UPDATE x SET x = x * x;
/* Test handling of inet netmasks with inet_minmax_multi_ops */ CREATE TABLE x (x INET);
CREATE INDEX ON x USING brin(x x NULLS LAST);
INSERT INTO x VALUES ('127.0.0.1/0');
INSERT INTO x VALUES ('0.0.0.0/12');
DROP TABLE x;
/* Tests for brin_summarize_new_values */ SELECT BRIN_SUMMARIZE_NEW_VALUES('brintest_multi');
/* error, not an index */ SELECT BRIN_SUMMARIZE_NEW_VALUES('tenk1_unique1');
/* error, not a BRIN index */ SELECT BRIN_SUMMARIZE_NEW_VALUES('brinidx_multi');
/* ok, no change expected */ /* Tests for brin_desummarize_range */ SELECT BRIN_DESUMMARIZE_RANGE('brinidx_multi', -1);
/* error, invalid range */ SELECT BRIN_DESUMMARIZE_RANGE('brinidx_multi', 0);
SELECT BRIN_DESUMMARIZE_RANGE('brinidx_multi', 0);
SELECT BRIN_DESUMMARIZE_RANGE('brinidx_multi', 100000000);
/* test building an index with many values, to force compaction of the buffer */ CREATE TABLE x (x INT);
INSERT INTO x SELECT x FROM x AS x;
CREATE INDEX x ON x USING brin(x x NULLS LAST);
DROP TABLE x;
/* Test brin_summarize_range */ CREATE TABLE x (x INT) WITH (fillfactor=10, autovacuum_enabled=FALSE);
CREATE INDEX x ON x USING brin(x NULLS LAST) WITH (pages_per_range=2);
BEGIN LOOP     INSERT INTO brin_summarize_multi VALUES (1) RETURNING ctid INTO curtid;
COMMIT;
/* summarize one range */ SELECT BRIN_SUMMARIZE_RANGE('brin_summarize_multi_idx', 0);
/* nothing: already summarized */ SELECT BRIN_SUMMARIZE_RANGE('brin_summarize_multi_idx', 1);
/* summarize one range */ SELECT BRIN_SUMMARIZE_RANGE('brin_summarize_multi_idx', 2);
/* nothing: page doesn't exist in table */ SELECT BRIN_SUMMARIZE_RANGE('brin_summarize_multi_idx', 4294967295);
/* invalid block number values */ SELECT BRIN_SUMMARIZE_RANGE('brin_summarize_multi_idx', -1);
SELECT BRIN_SUMMARIZE_RANGE('brin_summarize_multi_idx', 4294967296);
/* test brin cost estimates behave sanely based on correlation of values */ CREATE TABLE x (x INT, x INT);
INSERT INTO x SELECT x / 100, x % 100 FROM x AS x;
CREATE INDEX x ON x USING brin(x NULLS LAST) WITH (pages_per_range=2);
CREATE INDEX x ON x USING brin(x NULLS LAST) WITH (pages_per_range=2);
VACUUM ANALYZE brin_test_multi;
/* Ensure brin index is used when columns are perfectly correlated */ EXPLAIN (COSTS OFF) SELECT * FROM brin_test_multi WHERE a = 1;
/* Ensure brin index is not used when values are not correlated */ EXPLAIN (COSTS OFF) SELECT * FROM brin_test_multi WHERE b = 1;
/* do some inequality tests */ CREATE TABLE x (x INT, x BIGINT) WITH (fillfactor=10);
INSERT INTO x SELECT x / 5 + (911 * x + 483) % 25, x / 10 + (751 * x + 221) % 41 FROM x AS x;
CREATE INDEX x ON x USING brin(x x NULLS LAST) WITH (pages_per_range=5);
CREATE INDEX x ON x USING brin(x x NULLS LAST) WITH (pages_per_range=5);
SET x = off;
/* int: less than */ SELECT COUNT(*) FROM x WHERE x < 37;
SELECT COUNT(*) FROM x WHERE x < 113;
SELECT COUNT(*) FROM x WHERE x <= 177;
SELECT COUNT(*) FROM x WHERE x <= 25;
/* int: greater than */ SELECT COUNT(*) FROM x WHERE x > 120;
SELECT COUNT(*) FROM x WHERE x >= 180;
SELECT COUNT(*) FROM x WHERE x > 71;
SELECT COUNT(*) FROM x WHERE x >= 63;
/* int: equals */ SELECT COUNT(*) FROM x WHERE x = 207;
SELECT COUNT(*) FROM x WHERE x = 177;
/* bigint: less than */ SELECT COUNT(*) FROM x WHERE x < 73;
SELECT COUNT(*) FROM x WHERE x <= 47;
SELECT COUNT(*) FROM x WHERE x < 199;
SELECT COUNT(*) FROM x WHERE x <= 150;
/* bigint: greater than */ SELECT COUNT(*) FROM x WHERE x > 93;
SELECT COUNT(*) FROM x WHERE x > 37;
SELECT COUNT(*) FROM x WHERE x >= 215;
SELECT COUNT(*) FROM x WHERE x > 201;
/* bigint: equals */ SELECT COUNT(*) FROM x WHERE x = 88;
SELECT COUNT(*) FROM x WHERE x = 103;
TRUNCATE TABLE x /* now do the same, but insert the rows with the indexes already created */ /* so that we don't use the "build callback" and instead use the regular */ /* approach of adding rows into existing ranges */;
INSERT INTO x SELECT x / 5 + (911 * x + 483) % 25, x / 10 + (751 * x + 221) % 41 FROM x AS x;
/* int: less than */ SELECT COUNT(*) FROM x WHERE x < 37;
SELECT COUNT(*) FROM x WHERE x < 113;
SELECT COUNT(*) FROM x WHERE x <= 177;
SELECT COUNT(*) FROM x WHERE x <= 25;
/* int: greater than */ SELECT COUNT(*) FROM x WHERE x > 120;
SELECT COUNT(*) FROM x WHERE x >= 180;
SELECT COUNT(*) FROM x WHERE x > 71;
SELECT COUNT(*) FROM x WHERE x >= 63;
/* int: equals */ SELECT COUNT(*) FROM x WHERE x = 207;
SELECT COUNT(*) FROM x WHERE x = 177;
/* bigint: less than */ SELECT COUNT(*) FROM x WHERE x < 73;
SELECT COUNT(*) FROM x WHERE x <= 47;
SELECT COUNT(*) FROM x WHERE x < 199;
SELECT COUNT(*) FROM x WHERE x <= 150;
/* bigint: greater than */ SELECT COUNT(*) FROM x WHERE x > 93;
SELECT COUNT(*) FROM x WHERE x > 37;
SELECT COUNT(*) FROM x WHERE x >= 215;
SELECT COUNT(*) FROM x WHERE x > 201;
/* bigint: equals */ SELECT COUNT(*) FROM x WHERE x = 88;
SELECT COUNT(*) FROM x WHERE x = 103;
DROP TABLE x;
RESET enable_seqscan;
/* do some inequality tests for varlena data types */ CREATE TABLE x (x UUID) WITH (fillfactor=10);
INSERT INTO x SELECT CAST(x AS UUID) FROM (SELECT ROW_NUMBER() OVER (ORDER BY x NULLS LAST) AS x, x FROM (SELECT FIPSHASH(CAST((x / 13) AS TEXT)) AS x FROM x AS x) AS x) AS x ORDER BY x + 25 * RAND() NULLS LAST;
CREATE INDEX x ON x USING brin(x x NULLS LAST) WITH (pages_per_range=5);
SET x = off;
SELECT COUNT(*) FROM x WHERE x < '3d914f93-48c9-cc0f-f8a7-9716700b9fcd';
SELECT COUNT(*) FROM x WHERE x > '3d914f93-48c9-cc0f-f8a7-9716700b9fcd';
SELECT COUNT(*) FROM x WHERE x <= 'f369cb89-fc62-7e66-8987-007d121ed1ea';
SELECT COUNT(*) FROM x WHERE x >= 'aea92132-c4cb-eb26-3e6a-c2bf6c183b5d';
SELECT COUNT(*) FROM x WHERE x = '5feceb66-ffc8-6f38-d952-786c6d696c79';
SELECT COUNT(*) FROM x WHERE x = '86e50149-6586-6131-2a9e-0b35558d84f6';
TRUNCATE TABLE x /* now do the same, but insert the rows with the indexes already created */ /* so that we don't use the "build callback" and instead use the regular */ /* approach of adding rows into existing ranges */;
INSERT INTO x SELECT CAST(x AS UUID) FROM (SELECT ROW_NUMBER() OVER (ORDER BY x NULLS LAST) AS x, x FROM (SELECT FIPSHASH(CAST((x / 13) AS TEXT)) AS x FROM x AS x) AS x) AS x ORDER BY x + 25 * RAND() NULLS LAST;
SELECT COUNT(*) FROM x WHERE x < '3d914f93-48c9-cc0f-f8a7-9716700b9fcd';
SELECT COUNT(*) FROM x WHERE x > '3d914f93-48c9-cc0f-f8a7-9716700b9fcd';
SELECT COUNT(*) FROM x WHERE x <= 'f369cb89-fc62-7e66-8987-007d121ed1ea';
SELECT COUNT(*) FROM x WHERE x >= 'aea92132-c4cb-eb26-3e6a-c2bf6c183b5d';
SELECT COUNT(*) FROM x WHERE x = '5feceb66-ffc8-6f38-d952-786c6d696c79';
SELECT COUNT(*) FROM x WHERE x = '86e50149-6586-6131-2a9e-0b35558d84f6';
DROP TABLE x;
RESET enable_seqscan;
/* test overflows during CREATE INDEX with extreme timestamp values */ CREATE TABLE x (x TIMESTAMPTZ);
SET x = iso;
/* values close to timestamp minimum */ INSERT INTO x SELECT CAST('4713-01-01 00:00:01 BC' AS TIMESTAMPTZ) + CAST((x || ' seconds') AS INTERVAL) FROM x AS x;
/* values close to timestamp maximum */ INSERT INTO x SELECT CAST('294276-12-01 00:00:01' AS TIMESTAMPTZ) + CAST((x || ' seconds') AS INTERVAL) FROM x AS x;
CREATE INDEX ON x USING brin(x x NULLS LAST) WITH (pages_per_range=1);
DROP TABLE x;
/* test overflows during CREATE INDEX with extreme date values */ CREATE TABLE x (x DATE);
/* insert values close to date minimum */ INSERT INTO x SELECT CAST('4713-01-01 BC' AS DATE) + x FROM x AS x;
/* insert values close to date minimum */ INSERT INTO x SELECT CAST('5874897-12-01' AS DATE) + x FROM x AS x;
CREATE INDEX ON x USING brin(x x NULLS LAST) WITH (pages_per_range=1);
SET x = off;
/* make sure the ranges were built correctly and 2023-01-01 eliminates all */ EXPLAIN (ANALYZE, TIMING OFF, COSTS OFF, SUMMARY OFF, BUFFERS OFF) SELECT * FROM brin_date_test WHERE a = '2023-01-01'::date;
DROP TABLE x;
RESET enable_seqscan;
/* test handling of infinite timestamp values */ CREATE TABLE x (x TIMESTAMP);
INSERT INTO x VALUES ('-infinity'), ('infinity');
INSERT INTO x SELECT x FROM x AS x;
CREATE INDEX ON x USING brin(x x NULLS LAST) WITH (pages_per_range=1);
SET x = off;
EXPLAIN (ANALYZE, TIMING OFF, COSTS OFF, SUMMARY OFF, BUFFERS OFF) SELECT * FROM brin_timestamp_test WHERE a = '2023-01-01'::timestamp;
EXPLAIN (ANALYZE, TIMING OFF, COSTS OFF, SUMMARY OFF, BUFFERS OFF) SELECT * FROM brin_timestamp_test WHERE a = '1900-01-01'::timestamp;
DROP TABLE x;
RESET enable_seqscan;
/* test handling of infinite date values */ CREATE TABLE x (x DATE);
INSERT INTO x VALUES ('-infinity'), ('infinity');
INSERT INTO x SELECT CAST('2000-01-01' AS DATE) + x FROM x AS x;
CREATE INDEX ON x USING brin(x x NULLS LAST) WITH (pages_per_range=1);
SET x = off;
EXPLAIN (ANALYZE, TIMING OFF, COSTS OFF, SUMMARY OFF, BUFFERS OFF) SELECT * FROM brin_date_test WHERE a = '2023-01-01'::date;
EXPLAIN (ANALYZE, TIMING OFF, COSTS OFF, SUMMARY OFF, BUFFERS OFF) SELECT * FROM brin_date_test WHERE a = '1900-01-01'::date;
DROP TABLE x;
RESET enable_seqscan;
RESET datestyle;
/* test handling of overflow for interval values */ CREATE TABLE x (x INTERVAL);
INSERT INTO x SELECT CAST((x || ' years') AS INTERVAL) FROM x AS x;
INSERT INTO x SELECT CAST((x || ' years') AS INTERVAL) FROM x AS x;
CREATE INDEX ON x USING brin(x x NULLS LAST) WITH (pages_per_range=1);
SET x = off;
EXPLAIN (ANALYZE, TIMING OFF, COSTS OFF, SUMMARY OFF, BUFFERS OFF) SELECT * FROM brin_interval_test WHERE a = '-30 years'::interval;
EXPLAIN (ANALYZE, TIMING OFF, COSTS OFF, SUMMARY OFF, BUFFERS OFF) SELECT * FROM brin_interval_test WHERE a = '30 years'::interval;
DROP TABLE x;
RESET enable_seqscan;
/* test handling of infinite interval values */ CREATE TABLE x (x INTERVAL);
INSERT INTO x VALUES ('-infinity'), ('infinity');
INSERT INTO x SELECT CAST((x || ' days') AS INTERVAL) FROM x AS x;
CREATE INDEX ON x USING brin(x x NULLS LAST) WITH (pages_per_range=1);
SET x = off;
EXPLAIN (ANALYZE, TIMING OFF, COSTS OFF, SUMMARY OFF, BUFFERS OFF) SELECT * FROM brin_interval_test WHERE a = '-30 years'::interval;
EXPLAIN (ANALYZE, TIMING OFF, COSTS OFF, SUMMARY OFF, BUFFERS OFF) SELECT * FROM brin_interval_test WHERE a = '30 years'::interval;
DROP TABLE x;
RESET enable_seqscan;
RESET datestyle;
CREATE TABLE x (x NAME, x INT);
CREATE TABLE x (x TEXT, x INT);
CREATE TABLE x (x DOUBLE, x INT);
ANALYZE x;
ANALYZE x;
ANALYZE x;
ANALYZE x;
/* BTREE ascending/descending cases */ /* we load int4/text from pure descending data (each key is a new */ /* low key) and name/f8 from pure ascending data (each key is a new */ /* high key).  we had a bug where new low keys would sometimes be */ /* "lost". */ CREATE INDEX x ON x USING btree(x x NULLS LAST);
CREATE INDEX x ON x USING btree(x x NULLS LAST);
CREATE INDEX x ON x USING btree(x x NULLS LAST);
CREATE INDEX x ON x USING btree(x x NULLS LAST);
/* test retrieval of min/max keys for each index */ SELECT x.* FROM x AS x WHERE x.x < 1;
SELECT x.* FROM x AS x WHERE x.x >= 9999;
SELECT x.* FROM x AS x WHERE x.x = 4500;
SELECT x.* FROM x AS x WHERE x.x < CAST('1' AS NAME);
SELECT x.* FROM x AS x WHERE x.x >= CAST('9999' AS NAME);
SELECT x.* FROM x AS x WHERE x.x = CAST('4500' AS NAME);
SELECT x.* FROM x AS x WHERE x.x < CAST('1' AS TEXT);
SELECT x.* FROM x AS x WHERE x.x >= CAST('9999' AS TEXT);
SELECT x.* FROM x AS x WHERE x.x = CAST('4500' AS TEXT);
SELECT x.* FROM x AS x WHERE x.x < CAST('1' AS DOUBLE);
SELECT x.* FROM x AS x WHERE x.x >= CAST('9999' AS DOUBLE);
SELECT x.* FROM x AS x WHERE x.x = CAST('4500' AS DOUBLE);
/* Add coverage of RowCompare quals whose row omits a column ("proargtypes") */ /* that's after the first column, but before the final column.  The scan's */ /* initial positioning strategy must become >= here (it's not the > strategy, */ /* since the absence of "proargtypes" makes that tighter constraint unsafe). */ EXPLAIN (costs off) SELECT proname, proargtypes, pronamespace    FROM pg_proc    WHERE (proname, pronamespace) > ('abs', 0) ORDER BY proname, proargtypes, pronamespace LIMIT 1;
SELECT x, x, x FROM x WHERE (x, x) > ('abs', 0) ORDER BY x NULLS LAST, x NULLS LAST, x NULLS LAST LIMIT 1;
/* Similar to the previous test case, but this time it's a backwards scan */ /* using a < RowCompare.  Must use the <= strategy (and not the < strategy). */ EXPLAIN (costs off) SELECT proname, proargtypes, pronamespace    FROM pg_proc    WHERE (proname, pronamespace) < ('abs', 1_000_000) ORDER BY proname DESC, proargtypes DESC, pronamespace DESC LIMIT 1;
SELECT x, x, x FROM x WHERE (x, x) < ('abs', 1 AS x) ORDER BY x DESC NULLS FIRST, x DESC NULLS FIRST, x DESC NULLS FIRST LIMIT 1;
/* Add coverage for RowCompare quals whose rhs row has a NULL that ends scan */ EXPLAIN (costs off) SELECT proname, proargtypes, pronamespace    FROM pg_proc    WHERE proname = 'abs' AND (proname, proargtypes) < ('abs', NULL) ORDER BY proname, proargtypes, pronamespace;
SELECT x, x, x FROM x WHERE x = 'abs' AND (x, x) < ('abs', NULL) ORDER BY x NULLS LAST, x NULLS LAST, x NULLS LAST;
/* Add coverage for backwards scan RowCompare quals whose rhs row has a NULL */ /* that ends scan */ EXPLAIN (costs off) SELECT proname, proargtypes, pronamespace    FROM pg_proc    WHERE proname = 'abs' AND (proname, proargtypes) > ('abs', NULL) ORDER BY proname DESC, proargtypes DESC, pronamespace DESC;
SELECT x, x, x FROM x WHERE x = 'abs' AND (x, x) > ('abs', NULL) ORDER BY x DESC NULLS FIRST, x DESC NULLS FIRST, x DESC NULLS FIRST;
/* Add coverage for recheck of > key following array advancement on previous */ /* (left sibling) page that used a high key whose attribute value corresponding */ /* to the > key was -inf (due to being truncated when the high key was created). */ /* XXX This relies on the assumption that tenk1_thous_tenthous has a truncated */ /* high key "(183, -inf)" on the first page that we'll scan.  The test will only */ /* provide useful coverage when the default 8K BLCKSZ is in use. */ EXPLAIN (costs off) SELECT thousand, tenthous   FROM tenk1   WHERE thousand IN (182, 183) AND tenthous > 7550;
SELECT x, x FROM x WHERE x IN (182, 183) AND x > 7550;
SET x = FALSE /* Add coverage for optimization of backwards scan index descents */ /* Here we expect _bt_search to descend straight to a leaf page containing a */ /* non-pivot tuple with the value '47', which comes last (after 11 similar */ /* non-pivot tuples).  Query execution should only need to visit a single */ /* leaf page here. */ /* Test case relies on tenk1_hundred index having a leaf page whose high key */ /* is '(48, -inf)'.  We use a low cardinality index to make our test case less */ /* sensitive to implementation details that may change in the future. */;
SET x = TRUE;
SET x = FALSE;
EXPLAIN (costs off) select hundred, twenty from tenk1 where hundred < 48 order by hundred desc limit 1;
SELECT x, x FROM x WHERE x < 48 ORDER BY x DESC NULLS FIRST LIMIT 1;
/* This variant of the query need only return a single tuple located to the immediate */ /* right of the '(48, -inf)' high key.  It also only needs to scan one single */ /* leaf page (the right sibling of the page scanned by the last test case): */ EXPLAIN (costs off) select hundred, twenty from tenk1 where hundred <= 48 order by hundred desc limit 1;
SELECT x, x FROM x WHERE x <= 48 ORDER BY x DESC NULLS FIRST LIMIT 1;
/* Add coverage for ScalarArrayOp btree quals with pivot tuple constants */ EXPLAIN (costs off) select distinct hundred from tenk1 where hundred in (47, 48, 72, 82);
SELECT DISTINCT x FROM x WHERE x IN (47, 48, 72, 82);
EXPLAIN (costs off) select distinct hundred from tenk1 where hundred in (47, 48, 72, 82) order by hundred desc;
SELECT DISTINCT x FROM x WHERE x IN (47, 48, 72, 82) ORDER BY x DESC NULLS FIRST;
EXPLAIN (costs off) select thousand from tenk1 where thousand in (364, 366,380) and tenthous = 200000;
SELECT x FROM x WHERE x IN (364, 366, 380) AND x = 200000;
SET x = FALSE /* Check correct optimization of LIKE (special index operator support) */ /* for both indexscan and bitmapscan cases */;
SET x = TRUE;
SET x = FALSE;
EXPLAIN (costs off) select proname from pg_proc where proname like E'RI\\_FKey%del' order by 1;
SELECT x FROM x WHERE x LIKE RI\\_FKey%del ORDER BY 1 NULLS LAST;
EXPLAIN (costs off) select proname from pg_proc where proname ilike '00%foo' order by 1;
SELECT x FROM x WHERE x ILIKE '00%foo' ORDER BY 1 NULLS LAST;
EXPLAIN (costs off) select proname from pg_proc where proname ilike 'ri%foo' order by 1;
SET x = FALSE;
SET x = TRUE;
EXPLAIN (costs off) select proname from pg_proc where proname like E'RI\\_FKey%del' order by 1;
SELECT x FROM x WHERE x LIKE RI\\_FKey%del ORDER BY 1 NULLS LAST;
EXPLAIN (costs off) select proname from pg_proc where proname ilike '00%foo' order by 1;
SELECT x FROM x WHERE x ILIKE '00%foo' ORDER BY 1 NULLS LAST;
EXPLAIN (costs off) select proname from pg_proc where proname ilike 'ri%foo' order by 1;
RESET enable_seqscan;
RESET enable_indexscan;
RESET enable_bitmapscan;
/* Also check LIKE optimization with binary-compatible cases */ CREATE TEMPORARY TABLE x (x TEXT COLLATE "x");
CREATE INDEX ON x(x x NULLS LAST) WITH (deduplicate_items=on);
INSERT INTO x VALUES ('foo'), ('fool'), ('bar'), ('quux');
/* doesn't match index: */ EXPLAIN (costs off) select * from btree_bpchar where f1 like 'foo';
SELECT * FROM x WHERE x LIKE 'foo';
EXPLAIN (costs off) select * from btree_bpchar where f1 like 'foo%';
SELECT * FROM x WHERE x LIKE 'foo%';
/* these do match the index: */ EXPLAIN (costs off) select * from btree_bpchar where f1::bpchar like 'foo';
SELECT * FROM x WHERE CAST(x AS BPCHAR) LIKE 'foo';
EXPLAIN (costs off) select * from btree_bpchar where f1::bpchar like 'foo%';
SELECT * FROM x WHERE CAST(x AS BPCHAR) LIKE 'foo%';
/* get test coverage for "single value" deduplication strategy: */ INSERT INTO x SELECT 'foo' FROM x;
/* Perform unique checking, with and without the use of deduplication */ CREATE TABLE x (x INT) WITH (autovacuum_enabled=FALSE);
CREATE UNIQUE INDEX x ON x(x NULLS LAST) WITH (deduplicate_items=on);
CREATE UNIQUE INDEX x ON x(x NULLS LAST) WITH (deduplicate_items=off);
INSERT INTO x SELECT 1;
x;
/* Exercise the LP_DEAD-bit-set tuple deletion code with a posting list tuple. */ /* The implementation prefers deleting existing items to merging any duplicate */ /* tuples into a posting list, so we need an explicit test to make sure we get */ /* coverage (note that this test also assumes BLCKSZ is 8192 or less): */ DROP INDEX x;
DELETE FROM x WHERE x = 1;
INSERT INTO x SELECT x FROM x AS x;
/* Test B-tree fast path (cache rightmost leaf page) optimization. */ /* First create a tree that's at least three levels deep (i.e. has one level */ /* between the root and leaf levels). The text inserted is long.  It won't be */ /* TOAST compressed because we use plain storage in the table.  Only a few */ /* index tuples fit on each internal page, allowing us to get a tall tree with */ /* few pages.  (A tall tree is required to trigger caching.) */ /* The text column must be the leading column in the index, since suffix */ /* truncation would otherwise truncate tuples on internal pages, leaving us */ /* with a short tree. */ CREATE TABLE x (x INT, x TEXT);
ALTER TABLE x ALTER COLUMN x DROP DEFAULT, set storage plain;
CREATE INDEX x ON x(x NULLS LAST, x NULLS LAST) WITH (fillfactor=10);
INSERT INTO x SELECT x, REPEAT('x', 250) FROM x AS x;
/* Test for multilevel page deletion */ CREATE TABLE x (x BIGINT, x BIGINT, x BIGINT, x BIGINT);
INSERT INTO x SELECT x, 1, 2, 3 FROM x AS x;
ALTER TABLE x ADD PRIMARY KEY (x NULLS LAST, x NULLS LAST, x NULLS LAST, x NULLS LAST);
/* Delete most entries, and vacuum, deleting internal pages and creating "fast */ /* root" */ DELETE FROM x WHERE x < 79990;
VACUUM delete_test_table;
/* Test B-tree insertion with a metapage update (XLOG_BTREE_INSERT_META */ /* WAL record type). This happens when a "fast root" page is split.  This */ /* also creates coverage for nbtree FSM page recycling. */ /* The vacuum above should've turned the leaf page into a fast root. We just */ /* need to insert some rows to cause the fast root page to split. */ INSERT INTO x SELECT x, 1, 2, 3 FROM x AS x;
/* Test unsupported btree opclass parameters */ CREATE INDEX ON x(x x NULLS LAST);
/* test parallel build with immutable function. */ CREATE TABLE x (x INT);
CREATE FUNCTION x() RETURNS INT LANGUAGE sql IMMUTABLE AS RETURN 0;
BEGIN;
SET LOCAL x = 0;
SET LOCAL x = 4;
CREATE INDEX x ON x USING btree(BTREE_TEST_FUNC() NULLS LAST);
COMMIT;
DROP TABLE x;
DROP FUNCTION x;
/* Test case of ALTER INDEX with abuse of column names for indexes. */ /* This grammar is not officially supported, but the parser allows it. */ CREATE INDEX x ON x(x NULLS LAST);
ALTER INDEX x ALTER COLUMN x DROP DEFAULT, SET (n_distinct=100);
DROP INDEX x;
/* Partitioned index */ CREATE TABLE x (x INT) WITH (PARTITIONED_BY=RANGE(x));
CREATE INDEX x ON x(x NULLS LAST);
ALTER INDEX x ALTER COLUMN x DROP DEFAULT, SET (n_distinct=100);
DROP TABLE x;
/* CASE */ /* Test the case statement */ CREATE TABLE x (x INT, x DOUBLE);
CREATE TABLE x (x INT, x INT);
INSERT INTO x VALUES (1, 10.1);
INSERT INTO x VALUES (2, 20.2);
INSERT INTO x VALUES (3, -30.3);
INSERT INTO x VALUES (4, NULL);
INSERT INTO x VALUES (1, -1);
INSERT INTO x VALUES (2, -2);
INSERT INTO x VALUES (3, -3);
INSERT INTO x VALUES (2, -4);
INSERT INTO x VALUES (1, NULL);
INSERT INTO x VALUES (NULL, -6);
/* Simplest examples without tables */ SELECT '3' AS "x", CASE WHEN 1 < 2 THEN 3 END AS "x";
SELECT '<NULL>' AS "x", CASE WHEN 1 > 2 THEN 3 END AS "x";
SELECT '3' AS "x", CASE WHEN 1 < 2 THEN 3 ELSE 4 END AS "x";
SELECT '4' AS "x", CASE WHEN 1 > 2 THEN 3 ELSE 4 END AS "x";
SELECT '6' AS "x", CASE WHEN 1 > 2 THEN 3 WHEN 4 < 5 THEN 6 ELSE 7 END AS "x";
SELECT '7' AS "x", CASE WHEN RAND() < 0 THEN 1 END AS "x";
/* Constant-expression folding shouldn't evaluate unreachable subexpressions */ SELECT CASE WHEN 1 = 0 THEN 1 / 0 WHEN 1 = 1 THEN 1 ELSE 2 / 0 END;
SELECT CASE 1 WHEN 0 THEN 1 / 0 WHEN 1 THEN 1 ELSE 2 / 0 END;
/* However we do not currently suppress folding of potentially */ /* reachable subexpressions */ SELECT CASE WHEN x > 100 THEN 1 / 0 ELSE 0 END FROM x;
/* Test for cases involving untyped literals in test expression */ SELECT CASE 'a' WHEN 'a' THEN 1 ELSE 2 END;
/* Examples of targets involving tables */ SELECT CASE WHEN x >= 3 THEN x END AS "x" FROM x;
SELECT CASE WHEN x >= 3 THEN (x + x) ELSE x END AS "x" FROM x;
SELECT x AS "x", CASE WHEN (x < 0) THEN 'small' WHEN (x = 0) THEN 'zero' WHEN (x = 1) THEN 'one' WHEN (x = 2) THEN 'two' ELSE 'big' END AS "x" FROM x;
SELECT CASE WHEN ((x < 0) OR (x < 0)) THEN 'small' WHEN ((x = 0) OR (x = 0)) THEN 'zero' WHEN ((x = 1) OR (x = 1)) THEN 'one' WHEN ((x = 2) OR (x = 2)) THEN 'two' ELSE 'big' END AS "x" FROM x;
/* Examples of qualifications involving tables */ /* NULLIF() and COALESCE() */ /* Shorthand forms for typical CASE constructs */ /*  defined in the SQL standard. */ SELECT * FROM x WHERE COALESCE(x, x) = 4;
SELECT * FROM x WHERE NULLIF(x, x) = 2;
SELECT COALESCE(x.x, x.x, x.x) FROM x AS x, x AS x;
SELECT * FROM x AS x, x AS x WHERE COALESCE(x.x, x.x, x.x) = 2;
SELECT NULLIF(x.x, x.x) AS "x", NULLIF(x.x, 4) AS "x" FROM x AS x, x AS x;
SELECT * FROM x AS x, x AS x WHERE COALESCE(x, x.x) = 2;
/* Tests for constant subexpression simplification */ EXPLAIN (costs off) SELECT * FROM CASE_TBL WHERE NULLIF(1, 2) = 2;
EXPLAIN (costs off) SELECT * FROM CASE_TBL WHERE NULLIF(1, 1) IS NOT NULL;
EXPLAIN (costs off) SELECT * FROM CASE_TBL WHERE NULLIF(1, null) = 2;
/* Examples of updates involving tables */ UPDATE x SET x = CASE WHEN x >= 3 THEN (-x) ELSE (2 * x) END;
SELECT * FROM x;
UPDATE x SET x = CASE WHEN x >= 2 THEN (2 * x) ELSE (3 * x) END;
SELECT * FROM x;
UPDATE x SET x = CASE WHEN x.x >= 2 THEN (2 * x) ELSE (3 * x) END FROM x AS x WHERE x = -x.x;
SELECT * FROM x;
/* Nested CASE expressions */ /* This test exercises a bug caused by aliasing econtext->caseValue_isNull */ /* with the isNull argument of the inner CASE's CaseExpr evaluation.  After */ /* evaluating the vol(null) expression in the inner CASE's second WHEN-clause, */ /* the isNull flag for the case test value incorrectly became true, causing */ /* the third WHEN-clause not to match.  The volatile function calls are needed */ /* to prevent constant-folding in the planner, which would hide the bug. */ /* Wrap this in a single transaction so the transient '=' operator doesn't */ /* cause problems in concurrent sessions */ BEGIN;
SELECT CASE (CASE VOL('bar') WHEN 'foo' THEN 'it was foo!' WHEN VOL(NULL) THEN 'null input' WHEN 'bar' THEN 'it was bar!' END) WHEN 'it was foo!' THEN 'foo recognized' WHEN 'it was bar!' THEN 'bar recognized' ELSE 'unrecognized' END;
/* In this case, we can't inline the SQL function without confusing things. */ CREATE DOMAIN foodomain AS text;
CREATE FUNCTION x(x, x) RETURNS BOOLEAN LANGUAGE sql AS 'SELECT CASE $2::text WHEN $1::text THEN true ELSE false END';
CREATE OPERATOR = (procedure = inline_eq,                    leftarg = foodomain, rightarg = foodomain);
SELECT CASE VOLFOO('bar') WHEN CAST('foo' AS foodomain) THEN 'is foo' ELSE 'is not foo' END;
ROLLBACK;
/* Test multiple evaluation of a CASE arg that is a read/write object (#14472) */ /* Wrap this in a single transaction so the transient '=' operator doesn't */ /* cause problems in concurrent sessions */ BEGIN;
CREATE DOMAIN arrdomain AS int[];
BEGIN x := array[$1,$2];
x AS x;
CREATE OPERATOR = (procedure = ad_eq,                    leftarg = arrdomain, rightarg = arrdomain);
SELECT CASE MAKE_AD(1, 2) WHEN CAST(ARRAY(2, 4) AS arrdomain) THEN 'wrong' WHEN CAST(ARRAY(2, 5) AS arrdomain) THEN 'still wrong' WHEN CAST(ARRAY(1, 2) AS arrdomain) THEN 'right' END;
/* While we're here, also test handling of a NULLIF arg that is a read/write */ /* object (bug #18722) */ SELECT NULLIF(MAKE_AD(1, 2), CAST(ARRAY(2, 3) AS arrdomain));
ROLLBACK;
/* Test interaction of CASE with ArrayCoerceExpr (bug #15471) */ BEGIN;
CREATE TYPE casetestenum AS ENUM ('e', 'f', 'g');
SELECT CASE CAST('foo' AS TEXT) WHEN 'foo' THEN ARRAY('a', 'b', 'c', 'd') || CAST(ENUM_RANGE(CAST(NULL AS casetestenum)) AS ARRAY<TEXT>) ELSE ARRAY('x', 'y') END;
ROLLBACK;
/* Clean up */ DROP TABLE x;
DROP TABLE x;
/* CHAR */ /* Per SQL standard, CHAR means character(1), that is a varlena type */ /* with a constraint restricting it to one character (not byte) */ SELECT CAST('c' AS CHAR) = CAST('c' AS CHAR) AS x;
/* Build a table for testing */ /* (This temporarily hides the table created in test_setup.sql) */ CREATE TEMPORARY TABLE x (x CHAR);
INSERT INTO x (x) VALUES ('a');
INSERT INTO x (x) VALUES ('A');
/* any of the following three input formats are acceptable */ INSERT INTO x (x) VALUES ('1');
INSERT INTO x (x) VALUES (2);
INSERT INTO x (x) VALUES ('3');
/* zero-length char */ INSERT INTO x (x) VALUES ('');
/* try char's of greater than 1 length */ INSERT INTO x (x) VALUES ('cd');
INSERT INTO x (x) VALUES ('c     ');
SELECT * FROM x;
SELECT x.* FROM x AS x WHERE x.x <> 'a';
SELECT x.* FROM x AS x WHERE x.x = 'a';
SELECT x.* FROM x AS x WHERE x.x < 'a';
SELECT x.* FROM x AS x WHERE x.x <= 'a';
SELECT x.* FROM x AS x WHERE x.x > 'a';
SELECT x.* FROM x AS x WHERE x.x >= 'a';
DROP TABLE x;
/* Now test longer arrays of char */ /* This char_tbl was already created and filled in test_setup.sql. */ /* Here we just try to insert bad values. */ INSERT INTO x (x) VALUES ('abcde');
SELECT * FROM x;
/* Also try it with non-error-throwing API */ SELECT PG_INPUT_IS_VALID('abcd  ', 'char(4)');
SELECT PG_INPUT_IS_VALID('abcde', 'char(4)');
SELECT * FROM x;
/* Also test "char", which is an ad-hoc one-byte type.  It can only */ /* really store ASCII characters, but we allow high-bit-set characters */ /* to be accessed via bytea-like escapes. */ SELECT CAST('a' AS CHAR);
SELECT CAST('\101' AS CHAR);
SELECT CAST('\377' AS CHAR);
SELECT CAST(CAST('a' AS CHAR) AS TEXT);
SELECT CAST(CAST('\377' AS CHAR) AS TEXT);
SELECT CAST(CAST('\000' AS CHAR) AS TEXT);
SELECT CAST(CAST('a' AS TEXT) AS CHAR);
SELECT CAST(CAST('\377' AS TEXT) AS CHAR);
SELECT CAST(CAST('' AS TEXT) AS CHAR);
SET x = -1 /* CIRCLE */ /* Back off displayed precision a little bit to reduce platform-to-platform */ /* variation in results. */;
CREATE TABLE x (x circle);
INSERT INTO x VALUES ('<(5,1),3>');
INSERT INTO x VALUES ('((1,2),100)');
INSERT INTO x VALUES (' 1 , 3 , 5 ');
INSERT INTO x VALUES (' ( ( 1 , 2 ) , 3 ) ');
INSERT INTO x VALUES (' ( 100 , 200 ) , 10 ');
INSERT INTO x VALUES (' < ( 100 , 1 ) , 115 > ');
INSERT INTO x VALUES ('<(3,5),0>');
/* Zero radius */ INSERT INTO x VALUES ('<(3,5),NaN>');
/* NaN radius */ /* bad values */ INSERT INTO x VALUES ('<(-100,0),-100>');
INSERT INTO x VALUES ('<(100,200),10');
INSERT INTO x VALUES ('<(100,200),10> x');
INSERT INTO x VALUES ('1abc,3,5');
INSERT INTO x VALUES ('(3,(1,2),3)');
SELECT * FROM x;
SELECT CENTER(x) AS x FROM x;
SELECT RADIUS(x) AS x FROM x;
SELECT DIAMETER(x) AS x FROM x;
SELECT x FROM x WHERE RADIUS(x) < 5;
SELECT x FROM x WHERE DIAMETER(x) >= 10;
SELECT x.x AS x, x.x AS x, (x.x <-> x.x) AS x FROM x AS x, x AS x WHERE (x.x < x.x) AND ((x.x <-> x.x) > 0) ORDER BY x NULLS LAST, AREA(x.x) NULLS LAST, AREA(x.x) NULLS LAST;
/*  CLUSTER */ CREATE TABLE x (x SERIAL PRIMARY KEY, x INT);
CREATE TABLE x (x SERIAL PRIMARY KEY, x INT, x TEXT, x TEXT, CONSTRAINT x FOREIGN KEY (x) REFERENCES x);
CREATE INDEX x ON x(x NULLS LAST);
CREATE INDEX x ON x(x NULLS LAST);
CREATE INDEX x ON x(x NULLS LAST, x NULLS LAST);
CREATE INDEX x ON x(x NULLS LAST, x NULLS LAST);
INSERT INTO x (x) VALUES (0);
INSERT INTO x (x) SELECT x FROM x;
INSERT INTO x (x) SELECT x FROM x;
INSERT INTO x (x) SELECT x FROM x;
INSERT INTO x (x) SELECT x FROM x;
INSERT INTO x (x) SELECT x FROM x;
CREATE TABLE x INHERITS (x);
INSERT INTO x (x, x) VALUES (11, 'once');
INSERT INTO x (x, x) VALUES (10, 'diez');
INSERT INTO x (x, x) VALUES (31, 'treinta y uno');
INSERT INTO x (x, x) VALUES (22, 'veintidos');
INSERT INTO x (x, x) VALUES (3, 'tres');
INSERT INTO x (x, x) VALUES (20, 'veinte');
INSERT INTO x (x, x) VALUES (23, 'veintitres');
INSERT INTO x (x, x) VALUES (21, 'veintiuno');
INSERT INTO x (x, x) VALUES (4, 'cuatro');
INSERT INTO x (x, x) VALUES (14, 'catorce');
INSERT INTO x (x, x) VALUES (2, 'dos');
INSERT INTO x (x, x) VALUES (18, 'dieciocho');
INSERT INTO x (x, x) VALUES (27, 'veintisiete');
INSERT INTO x (x, x) VALUES (25, 'veinticinco');
INSERT INTO x (x, x) VALUES (13, 'trece');
INSERT INTO x (x, x) VALUES (28, 'veintiocho');
INSERT INTO x (x, x) VALUES (32, 'treinta y dos');
INSERT INTO x (x, x) VALUES (5, 'cinco');
INSERT INTO x (x, x) VALUES (29, 'veintinueve');
INSERT INTO x (x, x) VALUES (1, 'uno');
INSERT INTO x (x, x) VALUES (24, 'veinticuatro');
INSERT INTO x (x, x) VALUES (30, 'treinta');
INSERT INTO x (x, x) VALUES (12, 'doce');
INSERT INTO x (x, x) VALUES (17, 'diecisiete');
INSERT INTO x (x, x) VALUES (9, 'nueve');
INSERT INTO x (x, x) VALUES (19, 'diecinueve');
INSERT INTO x (x, x) VALUES (26, 'veintiseis');
INSERT INTO x (x, x) VALUES (15, 'quince');
INSERT INTO x (x, x) VALUES (7, 'siete');
INSERT INTO x (x, x) VALUES (16, 'dieciseis');
INSERT INTO x (x, x) VALUES (8, 'ocho');
/* This entry is needed to test that TOASTED values are copied correctly. */ INSERT INTO x (x, x, x) VALUES (6, 'seis', REPEAT('xyzzy', 100000));
SELECT x, x, x, SUBSTRING(x, 1, 30), LENGTH(x) FROM x;
SELECT x, x, x, SUBSTRING(x, 1, 30), LENGTH(x) FROM x ORDER BY x NULLS LAST;
SELECT x, x, x, SUBSTRING(x, 1, 30), LENGTH(x) FROM x ORDER BY x NULLS LAST;
SELECT x, x, x, SUBSTRING(x, 1, 30), LENGTH(x) FROM x ORDER BY x NULLS LAST;
/* Verify that inheritance link still works */ INSERT INTO x VALUES (0, 100, 'in child table');
SELECT x, x, x, SUBSTRING(x, 1, 30), LENGTH(x) FROM x;
/* Verify that foreign key link still works */ INSERT INTO x (x, x) VALUES (1111, 'this should fail');
SELECT x FROM x WHERE x = CAST('clstr_tst' AS REGCLASS) ORDER BY 1 NULLS LAST;
SELECT x, x, EXISTS(SELECT 1 FROM x WHERE x = x.x) AS x FROM x AS x WHERE x LIKE 'clstr_tst%' ORDER BY x NULLS LAST;
/* Verify that indisclustered is correctly set */ SELECT x.x FROM x, x, x AS x WHERE x.x = x AND x = x.x AND x.x = 'clstr_tst' AND x;
/* Try changing indisclustered */ ALTER TABLE clstr_tst CLUSTER ON clstr_tst_b_c;
SELECT x.x FROM x, x, x AS x WHERE x.x = x AND x = x.x AND x.x = 'clstr_tst' AND x;
ALTER TABLE x SET  /* Try turning off all clustering */;
SELECT x.x FROM x, x, x AS x WHERE x.x = x AND x = x.x AND x.x = 'clstr_tst' AND x;
/* Verify that clustering all tables does in fact cluster the right ones */ CREATE USER regress_clstr_user;
CREATE TABLE x (x INT PRIMARY KEY);
CREATE TABLE x (x INT PRIMARY KEY);
CREATE TABLE x (x INT PRIMARY KEY);
ALTER TABLE clstr_1 OWNER TO regress_clstr_user;
ALTER TABLE clstr_3 OWNER TO regress_clstr_user;
GRANT SELECT ON x TO x;
INSERT INTO x VALUES (2);
INSERT INTO x VALUES (1);
INSERT INTO x VALUES (2);
INSERT INTO x VALUES (1);
INSERT INTO x VALUES (2);
INSERT INTO x VALUES (1);
x AS x /* "CLUSTER <tablename>" on a table that hasn't been clustered */;
SELECT * FROM x UNION ALL SELECT * FROM x UNION ALL SELECT * FROM x;
/* revert to the original state */ DELETE FROM x;
DELETE FROM x;
DELETE FROM x;
INSERT INTO x VALUES (2);
INSERT INTO x VALUES (1);
INSERT INTO x VALUES (2);
INSERT INTO x VALUES (1);
INSERT INTO x VALUES (2);
INSERT INTO x VALUES (1);
/* this user can only cluster clstr_1 and clstr_3, but the latter */ /* has not been clustered */ SET SESSION AUTHORIZATION regress_clstr_user;
SET x = ERROR;
x /* order of "skipping" warnings may vary */;
RESET client_min_messages;
SELECT * FROM x UNION ALL SELECT * FROM x UNION ALL SELECT * FROM x;
/* cluster a single table using the indisclustered bit previously set */ DELETE FROM x;
INSERT INTO x VALUES (2);
INSERT INTO x VALUES (1);
x AS x;
SELECT * FROM x;
/* Test MVCC-safety of cluster. There isn't much we can do to verify the */ /* results with a single backend... */ CREATE TABLE x (x INT PRIMARY KEY);
INSERT INTO x VALUES (10);
INSERT INTO x VALUES (20);
INSERT INTO x VALUES (30);
INSERT INTO x VALUES (40);
INSERT INTO x VALUES (50);
/* Use a transaction so that updates are not committed when CLUSTER sees 'em */ BEGIN;
/* Test update where the old row version is found first in the scan */ UPDATE x SET x = 100 WHERE x = 10;
/* Test update where the new row version is found first in the scan */ UPDATE x SET x = 35 WHERE x = 40;
/* Test longer update chain */ UPDATE x SET x = 60 WHERE x = 50;
UPDATE x SET x = 70 WHERE x = 60;
UPDATE x SET x = 80 WHERE x = 70;
SELECT * FROM x;
SELECT * FROM x;
COMMIT;
SELECT * FROM x;
/* check that temp tables can be clustered */ CREATE TEMPORARY TABLE x (x INT PRIMARY KEY, x TEXT);
INSERT INTO x VALUES (2, 'two'), (1, 'one');
SELECT * FROM x;
DROP TABLE x;
RESET SESSION AUTHORIZATION;
/* check clustering an empty table */ DROP TABLE x;
CREATE TABLE x (x INT PRIMARY KEY);
x AS x;
/* Check that partitioned tables can be clustered */ CREATE TABLE x (x INT) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (1) TO (10) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (1) TO (5);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (5) TO (10) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (10) TO (20);
CREATE TABLE x PARTITION OF x DEFAULT WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x DEFAULT;
/* fails */ DROP INDEX x;
CREATE INDEX x ON x(x NULLS LAST);
/* Check that clustering sets new relfilenodes: */ CREATE TEMPORARY TABLE x AS SELECT x, x, x, x FROM x AS x JOIN x AS x ON x.x = x.x;
CREATE TEMPORARY TABLE x AS SELECT x, x, x, x FROM x AS x JOIN x AS x ON x.x = x.x;
SELECT x, x.x, x.x, x.x = x.x FROM x AS x JOIN x AS x USING (x) ORDER BY x COLLATE "x" NULLS LAST;
ALTER TABLE x SET;
ALTER TABLE clstrpart CLUSTER ON clstrpart_idx;
DROP TABLE x;
/* Ownership of partitions is checked */ CREATE TABLE x (x INT UNIQUE) WITH (PARTITIONED_BY=LIST(x));
CREATE INDEX x ON x(x NULLS LAST);
CREATE TABLE x PARTITION OF x FOR VALUES IN (1);
CREATE ROLE regress_ptnowner;
CREATE TABLE x PARTITION OF x FOR VALUES IN (2);
ALTER TABLE ptnowner1 OWNER TO regress_ptnowner;
SET SESSION AUTHORIZATION regress_ptnowner;
RESET SESSION AUTHORIZATION;
ALTER TABLE ptnowner OWNER TO regress_ptnowner;
CREATE TEMPORARY TABLE x AS SELECT x, x, x FROM x AS x JOIN x AS x ON x.x = x.x;
SET SESSION AUTHORIZATION regress_ptnowner;
RESET SESSION AUTHORIZATION;
SELECT x.x, x.x = x.x FROM x AS x JOIN x AS x USING (x) ORDER BY x.x COLLATE "x" NULLS LAST;
DROP TABLE x;
DROP ROLE regress_ptnowner;
/* Test CLUSTER with external tuplesorting */ CREATE TABLE x AS SELECT * FROM x;
CREATE INDEX x ON x(x NULLS LAST, x NULLS LAST, x NULLS LAST);
SET x = off /* ensure we don't use the index in CLUSTER nor the checking SELECTs */;
SET x = '1MB' /* Use external sort: */;
SELECT * FROM (SELECT x, LAG(x) OVER () AS x, x, LAG(x) OVER () AS x, x, LAG(x) OVER () AS x FROM x) AS x WHERE ROW(x, x, x) <= ROW(x, x, x);
RESET enable_indexscan;
RESET maintenance_work_mem;
/* test CLUSTER on expression index */ CREATE TABLE x (x SERIAL PRIMARY KEY, x INT, x TEXT COLLATE "x");
INSERT INTO x (x, x) SELECT x.x % 42, 'prefix' || x.x FROM x AS x;
CREATE INDEX x ON x((-x) NULLS LAST, x NULLS LAST);
CREATE INDEX x ON x((UPPER(x)) NULLS LAST);
/* verify indexes work before cluster */ BEGIN;
SET LOCAL x = FALSE;
EXPLAIN (COSTS OFF) SELECT * FROM clstr_expression WHERE upper(b) = 'PREFIX3';
SELECT * FROM x WHERE UPPER(x) = 'PREFIX3';
EXPLAIN (COSTS OFF) SELECT * FROM clstr_expression WHERE -a = -3 ORDER BY -a, b;
SELECT * FROM x WHERE -x = -3 ORDER BY -x NULLS LAST, x NULLS LAST;
COMMIT;
WITH x AS (SELECT x, LAG(x) OVER (ORDER BY x NULLS LAST) AS x, x FROM x) SELECT * FROM x WHERE x < x;
BEGIN;
SET LOCAL x = FALSE;
EXPLAIN (COSTS OFF) SELECT * FROM clstr_expression WHERE upper(b) = 'PREFIX3';
SELECT * FROM x WHERE UPPER(x) = 'PREFIX3';
EXPLAIN (COSTS OFF) SELECT * FROM clstr_expression WHERE -a = -3 ORDER BY -a, b;
SELECT * FROM x WHERE -x = -3 ORDER BY -x NULLS LAST, x NULLS LAST;
COMMIT;
WITH x AS (SELECT x, LAG(x) OVER (ORDER BY x NULLS LAST) AS x, x FROM x) SELECT * FROM x WHERE UPPER(x) > UPPER(x);
BEGIN;
SET LOCAL x = FALSE;
EXPLAIN (COSTS OFF) SELECT * FROM clstr_expression WHERE upper(b) = 'PREFIX3';
SELECT * FROM x WHERE UPPER(x) = 'PREFIX3';
EXPLAIN (COSTS OFF) SELECT * FROM clstr_expression WHERE -a = -3 ORDER BY -a, b;
SELECT * FROM x WHERE -x = -3 ORDER BY -x NULLS LAST, x NULLS LAST;
COMMIT;
/* clean up */ DROP TABLE x;
DROP TABLE x;
DROP TABLE x;
DROP TABLE x;
DROP TABLE x;
DROP TABLE x;
DROP USER regress_clstr_user;
CREATE SCHEMA x.x;
SET x = collate_tests;
CREATE TABLE x (x INT, x TEXT COLLATE "x" NOT NULL);
CREATE TABLE x (x INT, x TEXT COLLATE "x");
CREATE TABLE x (x INT COLLATE "x", x TEXT);
CREATE TABLE x (LIKE x);
CREATE TABLE x (x INT, x TEXT COLLATE "x");
INSERT INTO x VALUES (1, 'abc'), (2, 'äbc'), (3, 'bbc'), (4, 'ABC');
INSERT INTO x SELECT * FROM x;
INSERT INTO x SELECT * FROM x;
SELECT * FROM x WHERE x >= 'bbc';
SELECT * FROM x WHERE x >= 'bbc';
SELECT * FROM x WHERE x >= 'bbc';
SELECT * FROM x WHERE x >= 'BBC';
SELECT * FROM x WHERE x COLLATE "x" >= 'bbc';
SELECT * FROM x WHERE x >= 'bbc' COLLATE "x";
SELECT * FROM x WHERE x COLLATE "x" >= 'bbc' COLLATE "x";
SELECT * FROM x WHERE x COLLATE "x" >= 'bbc' COLLATE "x";
CREATE DOMAIN testdomain_sv AS text COLLATE "sv-x-icu";
CREATE DOMAIN testdomain_i AS int COLLATE "sv-x-icu";
/* fails */ CREATE TABLE x (x INT, x testdomain_sv);
INSERT INTO x SELECT * FROM x;
SELECT x, x FROM x ORDER BY x NULLS LAST;
CREATE TABLE x (x INT, x testdomain_sv COLLATE "x");
INSERT INTO x SELECT * FROM x;
SELECT x, x FROM x ORDER BY x NULLS LAST;
SELECT x, x FROM x ORDER BY x NULLS LAST;
SELECT x, x FROM x ORDER BY x NULLS LAST;
SELECT x, x FROM x ORDER BY x NULLS LAST;
SELECT x, x FROM x ORDER BY x COLLATE "x" NULLS LAST;
/* star expansion */ SELECT * FROM x ORDER BY x NULLS LAST;
SELECT * FROM x ORDER BY x NULLS LAST;
SELECT * FROM x ORDER BY x NULLS LAST;
/* constant expression folding */ SELECT 'bbc' COLLATE "x" > 'äbc' COLLATE "x" AS "x";
SELECT 'bbc' COLLATE "x" > 'äbc' COLLATE "x" AS "x";
/* upper/lower */ CREATE TABLE x (x INT, x TEXT COLLATE "x", x TEXT COLLATE "x");
INSERT INTO x VALUES (1, 'hij', 'hij'), (2, 'HIJ', 'HIJ');
SELECT x, LOWER(x), LOWER(x), UPPER(x), UPPER(x), INITCAP(x), INITCAP(x) FROM x;
SELECT x, LOWER(x COLLATE "x"), LOWER(x COLLATE "x") FROM x;
SELECT x, x, x FROM x ORDER BY LOWER(x) NULLS LAST, x NULLS LAST;
SELECT LOWER('AbCd 123 #$% ıiIİ ẞ ß Ǆǅǆ Σσς' COLLATE "x");
SELECT CASEFOLD('AbCd 123 #$% ıiIİ ẞ ß Ǆǅǆ Σσς' COLLATE "x");
SELECT LOWER('AbCd 123 #$% ıiIİ ẞ ß Ǆǅǆ Σσς' COLLATE "x");
SELECT CASEFOLD('AbCd 123 #$% ıiIİ ẞ ß Ǆǅǆ Σσς' COLLATE "x");
/* LIKE/ILIKE */ SELECT * FROM x WHERE x LIKE 'abc';
SELECT * FROM x WHERE x LIKE 'abc%';
SELECT * FROM x WHERE x LIKE '%bc%';
SELECT * FROM x WHERE x ILIKE 'abc';
SELECT * FROM x WHERE x ILIKE 'abc%';
SELECT * FROM x WHERE x ILIKE '%bc%';
SELECT 'Türkiye' COLLATE "x" ILIKE '%KI%' AS "x";
SELECT 'Türkiye' COLLATE "x" ILIKE '%KI%' AS "x";
SELECT 'bıt' ILIKE 'BIT' COLLATE "x" AS "x";
SELECT 'bıt' ILIKE 'BIT' COLLATE "x" AS "x";
/* The following actually exercises the selectivity estimation for ILIKE. */ SELECT x FROM x WHERE x ILIKE 'abc%';
/* regular expressions */ SELECT * FROM x WHERE REGEXP_LIKE(x, '^abc$');
SELECT * FROM x WHERE REGEXP_LIKE(x, '^abc');
SELECT * FROM x WHERE REGEXP_LIKE(x, 'bc');
SELECT * FROM x WHERE REGEXP_I_LIKE(x, '^abc$');
SELECT * FROM x WHERE REGEXP_I_LIKE(x, '^abc');
SELECT * FROM x WHERE REGEXP_I_LIKE(x, 'bc');
CREATE TABLE x (x INT, x TEXT COLLATE "x");
SELECT x, REGEXP_LIKE(x, '^[[:alpha:]]+$') AS x, REGEXP_LIKE(x, '^[[:upper:]]+$') AS x, REGEXP_LIKE(x, '^[[:lower:]]+$') AS x, REGEXP_LIKE(x, '^[[:digit:]]+$') AS x, REGEXP_LIKE(x, '^[[:alnum:]]+$') AS x, REGEXP_LIKE(x, '^[[:graph:]]+$') AS x, REGEXP_LIKE(x, '^[[:print:]]+$') AS x, REGEXP_LIKE(x, '^[[:punct:]]+$') AS x, REGEXP_LIKE(x, '^[[:space:]]+$') AS x FROM x;
SELECT REGEXP_I_LIKE('Türkiye' COLLATE "x", 'KI') AS "x";
SELECT REGEXP_I_LIKE('Türkiye' COLLATE "x", 'KI') AS "x";
/* true with ICU */ SELECT REGEXP_I_LIKE('bıt', 'BIT' COLLATE "x") AS "x";
SELECT REGEXP_I_LIKE('bıt', 'BIT' COLLATE "x") AS "x";
/* false with ICU */ /* The following actually exercises the selectivity estimation for ~*. */ SELECT x FROM x WHERE REGEXP_I_LIKE(x, '^abc');
SELECT TIME_TO_STR(CAST('2010-04-01' AS DATE), '%d T%mON %Y');
SELECT TIME_TO_STR(CAST('2010-04-01' AS DATE), 'DD TMMON YYYY' COLLATE "x");
CREATE VIEW x AS SELECT x, x FROM x ORDER BY x COLLATE "x" NULLS LAST;
CREATE VIEW x AS SELECT x, LOWER((x || x) COLLATE "x") FROM x;
SELECT x, x FROM x.x WHERE x LIKE 'collview%' ORDER BY 1 NULLS LAST;
/* collation propagation in various expression types */ SELECT x, COALESCE(x, 'foo') FROM x ORDER BY 2 NULLS LAST;
SELECT x, COALESCE(x, 'foo') FROM x ORDER BY 2 NULLS LAST;
SELECT x, COALESCE(x, 'foo') FROM x ORDER BY 2 NULLS LAST;
SELECT x, LOWER(COALESCE(x, 'foo')), LOWER(COALESCE(x, 'foo')) FROM x;
SELECT x, x, GREATEST(x, 'CCC') FROM x ORDER BY 3 NULLS LAST;
SELECT x, x, GREATEST(x, 'CCC') FROM x ORDER BY 3 NULLS LAST;
SELECT x, x, GREATEST(x, 'CCC') FROM x ORDER BY 3 NULLS LAST;
SELECT x, x, x, LOWER(GREATEST(x, 'foo')), LOWER(GREATEST(x, 'foo')) FROM x;
SELECT x, NULLIF(x, 'abc') FROM x ORDER BY 2 NULLS LAST;
SELECT x, NULLIF(x, 'abc') FROM x ORDER BY 2 NULLS LAST;
SELECT x, NULLIF(x, 'abc') FROM x ORDER BY 2 NULLS LAST;
SELECT x, LOWER(NULLIF(x, 'foo')), LOWER(NULLIF(x, 'foo')) FROM x;
SELECT x, CASE x WHEN 'abc' THEN 'abcd' ELSE x END FROM x ORDER BY 2 NULLS LAST;
SELECT x, CASE x WHEN 'abc' THEN 'abcd' ELSE x END FROM x ORDER BY 2 NULLS LAST;
SELECT x, CASE x WHEN 'abc' THEN 'abcd' ELSE x END FROM x ORDER BY 2 NULLS LAST;
CREATE DOMAIN testdomain AS text;
SELECT x, CAST(x AS testdomain) FROM x ORDER BY 2 NULLS LAST;
SELECT x, CAST(x AS testdomain) FROM x ORDER BY 2 NULLS LAST;
SELECT x, CAST(x AS testdomain) FROM x ORDER BY 2 NULLS LAST;
SELECT x, CAST(x AS testdomain_sv) FROM x ORDER BY 2 NULLS LAST;
SELECT x, LOWER(CAST(x AS testdomain)), LOWER(CAST(x AS testdomain)) FROM x;
SELECT MIN(x), MAX(x) FROM x;
SELECT MIN(x), MAX(x) FROM x;
SELECT MIN(x), MAX(x) FROM x;
SELECT ARRAY_AGG(x ORDER BY x NULLS LAST) FROM x;
SELECT ARRAY_AGG(x ORDER BY x NULLS LAST) FROM x;
SELECT ARRAY_AGG(x ORDER BY x NULLS LAST) FROM x;
SELECT x, x FROM x UNION ALL SELECT x, x FROM x ORDER BY 2 NULLS LAST;
SELECT x, x FROM x UNION SELECT x, x FROM x ORDER BY 2 NULLS LAST;
SELECT x, x FROM x WHERE x < 4 INTERSECT SELECT x, x FROM x WHERE x > 1 ORDER BY 2 NULLS LAST;
SELECT x, x FROM x EXCEPT SELECT x, x FROM x WHERE x < 2 ORDER BY 2 NULLS LAST;
SELECT x, x FROM x UNION ALL SELECT x, x FROM x ORDER BY 2 NULLS LAST;
/* fail */ SELECT x, x FROM x UNION ALL SELECT x, x FROM x;
/* ok */ SELECT x, x FROM x UNION SELECT x, x FROM x ORDER BY 2 NULLS LAST;
/* fail */ SELECT x, x COLLATE "x" FROM x UNION SELECT x, x FROM x ORDER BY 2 NULLS LAST;
/* ok */ SELECT x, x FROM x INTERSECT SELECT x, x FROM x ORDER BY 2 NULLS LAST;
/* fail */ SELECT x, x FROM x EXCEPT SELECT x, x FROM x ORDER BY 2 NULLS LAST;
/* fail */ CREATE TABLE x AS SELECT x, x FROM x UNION ALL SELECT x, x FROM x;
/* fail */ /* ideally this would be a parse-time error, but for now it must be run-time: */ SELECT x < x FROM x;
/* fail */ SELECT x || x FROM x;
/* ok, because || is not collation aware */ SELECT x, x FROM x ORDER BY x || x NULLS LAST;
/* not so ok */ /* collation mismatch between recursive and non-recursive term */ WITH RECURSIVE x AS (SELECT x FROM (VALUES ('a' COLLATE "x"), ('b')) AS x UNION ALL SELECT (x || 'c') COLLATE "x" FROM x WHERE LENGTH(x) < 10) SELECT * FROM x;
SELECT x, CAST(x AS VARCHAR) FROM x ORDER BY 2 NULLS LAST;
SELECT x, CAST(x AS VARCHAR) FROM x ORDER BY 2 NULLS LAST;
SELECT x, CAST(x AS VARCHAR) FROM x ORDER BY 2 NULLS LAST;
/* propagation of collation in SQL functions (inlined and non-inlined cases) */ /* and plpgsql functions too */ CREATE FUNCTION x(x, x) RETURNS BOOLEAN LANGUAGE sql AS $$ select $1 < $2 $$;
CREATE FUNCTION x(x, x) RETURNS BOOLEAN LANGUAGE sql AS $$ select $1 < $2 limit 1 $$;
SELECT x.x AS x, x.x AS x, x.x < x.x AS x, MYLT(x.x, x.x), MYLT_NONINLINE(x.x, x.x), MYLT_PLPGSQL(x.x, x.x) FROM x AS x, x AS x ORDER BY x.x NULLS LAST, x.x NULLS LAST;
SELECT x.x AS x, x.x AS x, x.x < x.x COLLATE "x" AS x, MYLT(x.x, x.x COLLATE "x"), MYLT_NONINLINE(x.x, x.x COLLATE "x"), MYLT_PLPGSQL(x.x, x.x COLLATE "x") FROM x AS x, x AS x ORDER BY x.x NULLS LAST, x.x NULLS LAST;
BEGIN return xx < yy;
SELECT MYLT2('a', 'B' COLLATE "x") AS x, MYLT2('a', 'B' COLLATE "x") AS x;
BEGIN return xx < yy;
SELECT MYLT2('a', 'B') AS x;
SELECT MYLT2('a', 'B' COLLATE "x") AS x;
/* conflicting collations */ SELECT MYLT2('a', 'B' COLLATE "x") AS x;
/* polymorphism */ SELECT * FROM UNNEST((SELECT ARRAY_AGG(x ORDER BY x NULLS LAST) FROM x)) ORDER BY 1 NULLS LAST;
SELECT * FROM UNNEST((SELECT ARRAY_AGG(x ORDER BY x NULLS LAST) FROM x)) ORDER BY 1 NULLS LAST;
SELECT * FROM UNNEST((SELECT ARRAY_AGG(x ORDER BY x NULLS LAST) FROM x)) ORDER BY 1 NULLS LAST;
CREATE FUNCTION x(x) RETURNS anyelement LANGUAGE sql AS 'select $1';
SELECT x, DUP(x) FROM x ORDER BY 2 NULLS LAST;
SELECT x, DUP(x) FROM x ORDER BY 2 NULLS LAST;
SELECT x, DUP(x) FROM x ORDER BY 2 NULLS LAST;
/* indexes */ CREATE INDEX x ON x(x NULLS LAST);
CREATE INDEX x ON x(x COLLATE "x" NULLS LAST);
CREATE INDEX x ON x((x COLLATE "x") NULLS LAST);
/* this is different grammatically */ CREATE INDEX x ON x(((x || 'foo') COLLATE "x") NULLS LAST);
CREATE INDEX x ON x(x COLLATE "x" NULLS LAST);
/* fail */ CREATE INDEX x ON x((x COLLATE "x") NULLS LAST);
/* fail */ SELECT x, PG_GET_INDEXDEF(x) FROM x WHERE x LIKE 'collate_test%_idx%' ORDER BY 1 NULLS LAST;
SET x = off;
EXPLAIN (costs off) select * from collate_test1 where b ilike 'abc';
SELECT * FROM x WHERE x ILIKE 'abc';
EXPLAIN (costs off) select * from collate_test1 where b ilike 'ABC';
SELECT * FROM x WHERE x ILIKE 'ABC';
RESET enable_seqscan;
/* schema manipulation commands */ CREATE ROLE regress_test_role;
CREATE SCHEMA x.x;
SET x = WARNING /* We need to do this this way to cope with varying names for encodings: */;
SET x = disabled;
CREATE COLLATION test0 FROM "C";
RESET icu_validation_level;
RESET client_min_messages;
CREATE COLLATION test3 (provider = icu, lc_collate = 'en_US.utf8');
SET x = ERROR /* fail, needs "locale" */;
CREATE COLLATION testx (provider = icu, locale = 'nonsense-nowhere');
/* fails */ RESET icu_validation_level;
DROP COLLATION testx;
CREATE COLLATION testx (provider = icu, locale = 'nonsense-nowhere');
DROP COLLATION testx;
CREATE COLLATION test4 FROM nonsense;
CREATE COLLATION test5 FROM test0;
SELECT x FROM x WHERE x LIKE 'test%' ORDER BY 1 NULLS LAST;
ALTER COLLATION test1 RENAME TO test11;
ALTER COLLATION test0 RENAME TO test11;
/* fail */ ALTER COLLATION test1 RENAME TO test22;
/* fail */ ALTER COLLATION test11 OWNER TO regress_test_role;
ALTER COLLATION test11 OWNER TO nonsense;
ALTER COLLATION test11 SET SCHEMA test_schema;
COMMENT ON COLLATION test0 IS 'US English';
SELECT x, x, OBJ_DESCRIPTION(x.x, 'pg_collation') FROM x JOIN x ON (x = x.x) WHERE x LIKE 'test%' ORDER BY 1 NULLS LAST;
DROP COLLATION test0, test_schema.test11, test5;
DROP COLLATION test0;
/* fail */ DROP COLLATION IF EXISTS test0;
SELECT x FROM x WHERE x LIKE 'test%';
DROP SCHEMA x.x;
DROP ROLE regress_test_role;
/* ALTER */ ALTER COLLATION "en-x-icu" REFRESH VERSION;
/* dependencies */ CREATE COLLATION test0 FROM "C";
CREATE TABLE x (x INT, x TEXT COLLATE x);
CREATE DOMAIN collate_dep_dom1 AS text COLLATE test0;
CREATE TYPE collate_dep_test2 AS (x int, y text COLLATE test0);
CREATE VIEW x AS SELECT CAST('foo' AS TEXT) COLLATE test0 AS x;
CREATE TABLE x (x INT, x TEXT);
CREATE INDEX x ON x(x COLLATE test0 NULLS LAST);
DROP COLLATION test0 RESTRICT;
/* fail */ DROP COLLATION test0 CASCADE;
DROP TYPE collate_dep_test2;
/* test range types and collations */ create type textrange_c as range(subtype=text, collation="C");
create type textrange_en_us as range(subtype=text, collation="en-x-icu");
SELECT TEXTRANGE_C('A', 'Z') @> CAST('b' AS TEXT);
SELECT TEXTRANGE_EN_US('A', 'Z') @> CAST('b' AS TEXT);
drop type textrange_c;
drop type textrange_en_us;
/* standard collations */ SELECT * FROM x ORDER BY x COLLATE UCS_BASIC NULLS LAST;
SELECT * FROM x ORDER BY x COLLATE UNICODE NULLS LAST;
SET x = WARNING /* test ICU collation customization */ /* test the attributes handled by icu_set_collation_attributes() */;
RESET client_min_messages;
SELECT 'aaá' > 'AAA' COLLATE "x", 'aaá' < 'AAA' COLLATE testcoll_ignore_accents;
SET x = WARNING;
CREATE COLLATION testcoll_backwards (provider = icu, locale = '@colBackwards=yes');
RESET client_min_messages;
SELECT 'coté' < 'côte' COLLATE "x", 'coté' > 'côte' COLLATE testcoll_backwards;
CREATE COLLATION testcoll_lower_first (provider = icu, locale = '@colCaseFirst=lower');
CREATE COLLATION testcoll_upper_first (provider = icu, locale = '@colCaseFirst=upper');
SELECT 'aaa' < 'AAA' COLLATE testcoll_lower_first, 'aaa' > 'AAA' COLLATE testcoll_upper_first;
CREATE COLLATION testcoll_shifted (provider = icu, locale = '@colAlternate=shifted');
SELECT 'de-luge' < 'deanza' COLLATE "x", 'de-luge' > 'deanza' COLLATE testcoll_shifted;
SET x = WARNING;
CREATE COLLATION testcoll_numeric (provider = icu, locale = '@colNumeric=yes');
RESET client_min_messages;
SELECT 'A-21' > 'A-123' COLLATE "x", 'A-21' < 'A-123' COLLATE testcoll_numeric;
CREATE COLLATION testcoll_error1 (provider = icu, locale = '@colNumeric=lower');
/* test that attributes not handled by icu_set_collation_attributes() */ /* (handled by ucol_open() directly) also work */ CREATE COLLATION testcoll_de_phonebook (provider = icu, locale = 'de@collation=phonebook');
SELECT 'Goldmann' < 'Götz' COLLATE "x", 'Goldmann' > 'Götz' COLLATE testcoll_de_phonebook;
/* rules */ CREATE COLLATION testcoll_rules1 (provider = icu, locale = '', rules = '&a < g');
CREATE TABLE x (x TEXT);
/* example from https://unicode-org.github.io/icu/userguide/collation/customization/#syntax */ INSERT INTO x VALUES ('Abernathy'), ('apple'), ('bird'), ('Boston'), ('Graham'), ('green');
SELECT * FROM x ORDER BY x COLLATE "x" NULLS LAST;
SELECT * FROM x ORDER BY x COLLATE testcoll_rules1 NULLS LAST;
DROP TABLE x;
CREATE COLLATION testcoll_rulesx (provider = icu, locale = '', rules = '!!wrong!!');
/* nondeterministic collations */ CREATE COLLATION ctest_det (provider = icu, locale = '', deterministic = true);
CREATE COLLATION ctest_nondet (provider = icu, locale = '', deterministic = false);
SELECT 'abc' LIKE 'abc' COLLATE ctest_det;
SELECT 'abc' LIKE 'a\bc' COLLATE ctest_det;
SELECT 'abc' LIKE 'abc' COLLATE ctest_nondet;
SELECT 'abc' LIKE 'a\bc' COLLATE ctest_nondet;
CREATE TABLE x (x INT, x TEXT);
/* same string in different normal forms */ INSERT INTO x VALUES (1, x & 'zy\00E4bc');
INSERT INTO x VALUES (2, x & 'zy\0061\0308bc');
SELECT * FROM x;
SELECT * FROM x WHERE x = 'zyäbc' COLLATE ctest_det;
SELECT * FROM x WHERE x = 'zyäbc' COLLATE ctest_nondet;
SELECT STR_POSITION(x COLLATE ctest_det, 'bc') FROM x;
SELECT STR_POSITION(x COLLATE ctest_nondet, 'bc') FROM x;
SELECT REPLACE(x COLLATE ctest_det, x & '\00E4b', 'X') FROM x;
SELECT REPLACE(x COLLATE ctest_nondet, x & '\00E4b', 'X') FROM x;
SELECT x, SPLIT_PART(x COLLATE ctest_det, x & '\00E4b', 2) FROM x;
SELECT x, SPLIT_PART(x COLLATE ctest_nondet, x & '\00E4b', 2) FROM x;
SELECT x, SPLIT_PART(x COLLATE ctest_det, x & '\00E4b', -1) FROM x;
SELECT x, SPLIT_PART(x COLLATE ctest_nondet, x & '\00E4b', -1) FROM x;
SELECT x, STRING_TO_ARRAY(x COLLATE ctest_det, x & '\00E4b') FROM x;
SELECT x, STRING_TO_ARRAY(x COLLATE ctest_nondet, x & '\00E4b') FROM x;
SELECT * FROM x WHERE x LIKE 'zyäbc' COLLATE ctest_det;
SELECT * FROM x WHERE x LIKE 'zyäbc' COLLATE ctest_nondet;
/* same with arrays */ CREATE TABLE x (x INT, x ARRAY<TEXT>);
INSERT INTO x VALUES (1, ARRAY(x & '\00E4bc'));
INSERT INTO x VALUES (2, ARRAY(x & '\0061\0308bc'));
SELECT * FROM x;
SELECT * FROM x WHERE x = ARRAY('äbc') COLLATE ctest_det;
SELECT * FROM x WHERE x = ARRAY('äbc') COLLATE ctest_nondet;
CREATE COLLATION case_sensitive (provider = icu, locale = '');
CREATE COLLATION case_insensitive (provider = icu, locale = '@colStrength=secondary', deterministic = false);
SELECT 'abc' <= 'ABC' COLLATE case_sensitive, 'abc' >= 'ABC' COLLATE case_sensitive;
SELECT 'abc' <= 'ABC' COLLATE case_insensitive, 'abc' >= 'ABC' COLLATE case_insensitive;
/* test language tags */ CREATE COLLATION lt_insensitive (provider = icu, locale = 'en-u-ks-level1', deterministic = false);
SELECT 'aBcD' COLLATE lt_insensitive = 'AbCd' COLLATE lt_insensitive;
CREATE COLLATION lt_upperfirst (provider = icu, locale = 'und-u-kf-upper');
SELECT 'Z' COLLATE lt_upperfirst < 'z' COLLATE lt_upperfirst;
CREATE TABLE x (x TEXT COLLATE x);
CREATE TABLE x (x TEXT COLLATE x);
CREATE TABLE x (x TEXT COLLATE x);
INSERT INTO x VALUES ('abc'), ('def'), ('ghi');
INSERT INTO x VALUES ('ABC'), ('ghi');
INSERT INTO x VALUES ('abc'), ('ABC'), ('def'), ('ghi');
SELECT x FROM x WHERE x = 'abc';
SELECT x FROM x WHERE x <> 'abc';
SELECT x FROM x WHERE x LIKE 'a%';
SELECT x FROM x WHERE x ILIKE 'a%';
SELECT x FROM x WHERE x SIMILAR TO 'a%';
SELECT x FROM x WHERE REGEXP_LIKE(x, 'a');
SET x = off;
SELECT x FROM x UNION SELECT x FROM x ORDER BY x NULLS LAST;
SELECT x FROM x UNION SELECT x FROM x ORDER BY x NULLS LAST;
SELECT x FROM x INTERSECT SELECT x FROM x;
SELECT x FROM x INTERSECT SELECT x FROM x;
SELECT x FROM x EXCEPT SELECT x FROM x;
SELECT x FROM x EXCEPT SELECT x FROM x;
SELECT DISTINCT x FROM x ORDER BY x NULLS LAST;
RESET enable_hashagg;
SELECT COUNT(DISTINCT x) FROM x;
SELECT x, COUNT(*) FROM x GROUP BY x ORDER BY x NULLS LAST;
SELECT x, ROW_NUMBER() OVER (ORDER BY x NULLS LAST), RANK() OVER (ORDER BY x NULLS LAST) FROM x ORDER BY x NULLS LAST;
CREATE UNIQUE INDEX ON x(x NULLS LAST);
/* ok */ INSERT INTO x VALUES ('ABC');
/* ok */ CREATE UNIQUE INDEX ON x(x NULLS LAST);
/* ok */ SELECT STRING_TO_ARRAY('ABC,DEF,GHI' COLLATE case_sensitive, ',', 'abc');
SELECT STRING_TO_ARRAY('ABCDEFGHI' COLLATE case_sensitive, NULL, 'b');
CREATE TABLE x (x TEXT COLLATE x);
CREATE TABLE x (x TEXT COLLATE x);
CREATE TABLE x (x TEXT COLLATE x);
CREATE INDEX ON x(x x NULLS LAST);
/* error */ INSERT INTO x VALUES ('abc'), ('def'), ('ghi');
INSERT INTO x VALUES ('ABC'), ('ghi');
INSERT INTO x VALUES ('abc'), ('ABC'), ('def'), ('ghi');
SELECT x FROM x WHERE x = 'abc';
SELECT x FROM x WHERE x <> 'abc';
SELECT x FROM x WHERE x LIKE 'a%';
SELECT x FROM x WHERE x ILIKE 'a%';
SELECT x FROM x WHERE x SIMILAR TO 'a%';
SELECT x FROM x WHERE REGEXP_LIKE(x, 'a');
SELECT x FROM x UNION SELECT x FROM x ORDER BY x NULLS LAST;
SELECT x FROM x UNION SELECT x FROM x ORDER BY x NULLS LAST;
SELECT x FROM x INTERSECT SELECT x FROM x ORDER BY x NULLS LAST;
SELECT x FROM x INTERSECT SELECT x FROM x ORDER BY x NULLS LAST;
SELECT x FROM x EXCEPT SELECT x FROM x;
SELECT x FROM x EXCEPT SELECT x FROM x;
SELECT DISTINCT x FROM x ORDER BY x NULLS LAST;
SELECT COUNT(DISTINCT x) FROM x;
SELECT x, COUNT(*) FROM x GROUP BY x ORDER BY x NULLS LAST;
SELECT x, ROW_NUMBER() OVER (ORDER BY x NULLS LAST), RANK() OVER (ORDER BY x NULLS LAST) FROM x ORDER BY x NULLS LAST;
CREATE UNIQUE INDEX ON x(x NULLS LAST);
/* ok */ INSERT INTO x VALUES ('ABC');
/* error */ CREATE UNIQUE INDEX ON x(x NULLS LAST);
/* error */ SELECT STRING_TO_ARRAY('ABC,DEF,GHI' COLLATE case_insensitive, ',', 'abc');
SELECT STRING_TO_ARRAY('ABCDEFGHI' COLLATE case_insensitive, NULL, 'b');
/* bpchar */ CREATE TABLE x (x CHAR(3) COLLATE x);
CREATE TABLE x (x CHAR(3) COLLATE x);
CREATE TABLE x (x CHAR(3) COLLATE x);
CREATE INDEX ON x(x x NULLS LAST);
/* error */ INSERT INTO x VALUES ('abc'), ('def'), ('ghi');
INSERT INTO x VALUES ('ABC'), ('ghi');
INSERT INTO x VALUES ('abc'), ('ABC'), ('def'), ('ghi');
SELECT x FROM x WHERE x = 'abc';
SELECT x FROM x WHERE x <> 'abc';
SELECT x FROM x WHERE x LIKE 'a%';
SELECT x FROM x WHERE x ILIKE 'a%';
SELECT x FROM x WHERE x SIMILAR TO 'a%';
SELECT x FROM x WHERE REGEXP_LIKE(x, 'a');
SELECT x FROM x UNION SELECT x FROM x ORDER BY x NULLS LAST;
SELECT x FROM x UNION SELECT x FROM x ORDER BY x NULLS LAST;
SELECT x FROM x INTERSECT SELECT x FROM x ORDER BY x NULLS LAST;
SELECT x FROM x INTERSECT SELECT x FROM x ORDER BY x NULLS LAST;
SELECT x FROM x EXCEPT SELECT x FROM x;
SELECT x FROM x EXCEPT SELECT x FROM x;
SELECT DISTINCT x FROM x ORDER BY x NULLS LAST;
SELECT COUNT(DISTINCT x) FROM x;
SELECT x, COUNT(*) FROM x GROUP BY x ORDER BY x NULLS LAST;
SELECT x, ROW_NUMBER() OVER (ORDER BY x NULLS LAST), RANK() OVER (ORDER BY x NULLS LAST) FROM x ORDER BY x NULLS LAST;
CREATE UNIQUE INDEX ON x(x NULLS LAST);
/* ok */ INSERT INTO x VALUES ('ABC');
/* error */ CREATE UNIQUE INDEX ON x(x NULLS LAST);
/* error */ SELECT STRING_TO_ARRAY(CAST('ABC,DEF,GHI' AS CHAR(11)) COLLATE case_insensitive, ',', 'abc');
SELECT STRING_TO_ARRAY(CAST('ABCDEFGHI' AS CHAR(9)) COLLATE case_insensitive, NULL, 'b');
/* This tests the issue described in match_pattern_prefix().  In the */ /* absence of that check, the case_insensitive tests below would */ /* return no rows where they should logically return one. */ CREATE TABLE x (x TEXT COLLATE x);
INSERT INTO x VALUES ('abc');
CREATE INDEX ON x(x NULLS LAST);
SET x = off;
SELECT x FROM x WHERE x LIKE 'ABC' COLLATE case_sensitive;
/* ok, no rows */ SELECT x FROM x WHERE x LIKE 'ABC%' COLLATE case_sensitive;
/* ok, no rows */ SELECT x FROM x WHERE x LIKE 'ABC' COLLATE case_insensitive;
/* ok */ SELECT x FROM x WHERE x LIKE 'ABC%' COLLATE case_insensitive;
/* ok */ RESET enable_seqscan;
/* Unicode special case: different variants of Greek lower case sigma. */ /* A naive implementation like citext that just does lower(x) = */ /* lower(y) will do the wrong thing here, because lower('Σ') is 'σ' */ /* but upper('ς') is 'Σ'. */ SELECT 'ὀδυσσεύς' = 'ὈΔΥΣΣΕΎΣ' COLLATE case_sensitive;
SELECT 'ὀδυσσεύς' = 'ὈΔΥΣΣΕΎΣ' COLLATE case_insensitive;
/* name vs. text comparison operators */ SELECT x FROM x WHERE x = CAST('PG_CLASS' AS TEXT) COLLATE case_insensitive;
SELECT x FROM x WHERE CAST('PG_CLASS' AS TEXT) = x COLLATE case_insensitive;
SELECT x FROM x WHERE x LIKE 'int_' AND x <> CAST('INT2' AS TEXT) COLLATE case_insensitive ORDER BY x NULLS LAST;
SELECT x FROM x WHERE x LIKE 'int_' AND CAST('INT2' AS TEXT) <> x COLLATE case_insensitive ORDER BY x NULLS LAST;
/* test case adapted from subselect.sql */ CREATE TEMPORARY TABLE x (x TEXT COLLATE x, x TEXT);
INSERT INTO x VALUES ('a', 'a');
INSERT INTO x VALUES ('b', 'a');
INSERT INTO x VALUES ('A', NULL);
INSERT INTO x VALUES ('B', NULL);
CREATE TEMPORARY TABLE x (x TEXT COLLATE x, x TEXT);
INSERT INTO x VALUES ('a', NULL);
SELECT * FROM x WHERE NOT (x, x) IN (SELECT * FROM x);
SET x = WARNING /* accents */;
RESET client_min_messages;
CREATE TABLE x (x INT, x TEXT);
INSERT INTO x VALUES (1, 'cote'), (2, 'côte'), (3, 'coté'), (4, 'côté');
SELECT * FROM x WHERE x = 'cote';
SELECT * FROM x WHERE x = 'cote' COLLATE ignore_accents;
SELECT * FROM x WHERE x = 'Cote' COLLATE ignore_accents;
/* still case-sensitive */ SELECT * FROM x WHERE x = 'Cote' COLLATE case_insensitive;
CREATE TABLE x (x INT, x TEXT);
INSERT INTO x VALUES (1, 'cote'), (2, 'côte'), (3, 'coté'), (4, 'côté');
UPDATE x SET x = NORMALIZE(x, nfd);
/* This shows why replace should be greedy.  Otherwise, in the NFD */ /* case, the match would stop before the decomposed accents, which */ /* would leave the accents in the results. */ SELECT x, x, REPLACE(x COLLATE ignore_accents, 'co', 'ma') FROM x;
SELECT x, x, REPLACE(x COLLATE ignore_accents, 'co', 'ma') FROM x;
/* This is a tricky one.  A naive implementation would first test */ /* \00E4 matches \0061, which is true under ignore_accents, but then */ /* the rest of the string won't match anymore.  Therefore, the */ /* algorithm has to test whether the rest of the string matches, and */ /* if not try matching \00E4 against a longer substring like */ /* \0061\0308, which will then work out. */ SELECT x & '\0061\0308bc' LIKE x & '\00E4_c' COLLATE ignore_accents;
/* and in reverse: */ SELECT x & '\00E4bc' LIKE x & '\0061\0308_c' COLLATE ignore_accents;
/* inner % matches b: */ SELECT x & '\0061\0308bc' LIKE x & '\00E4%c' COLLATE ignore_accents;
/* inner %% matches b then zero: */ SELECT x & '\0061\0308bc' LIKE x & '\00E4%%c' COLLATE ignore_accents;
/* inner %% matches b then zero: */ SELECT x & 'cb\0061\0308' LIKE x & 'c%%\00E4' COLLATE ignore_accents;
/* trailing _ matches two codepoints that form one grapheme: */ SELECT x & 'cb\0061\0308' LIKE x & 'cb_' COLLATE ignore_accents;
/* trailing __ matches two codepoints that form one grapheme: */ SELECT x & 'cb\0061\0308' LIKE x & 'cb__' COLLATE ignore_accents;
/* leading % matches zero: */ SELECT x & '\0061\0308bc' LIKE x & '%\00E4bc' COLLATE ignore_accents;
/* leading % matches zero (with later %): */ SELECT x & '\0061\0308bc' LIKE x & '%\00E4%c' COLLATE ignore_accents;
/* trailing % matches zero: */ SELECT x & '\0061\0308bc' LIKE x & '\00E4bc%' COLLATE ignore_accents;
/* trailing % matches zero (with previous %): */ SELECT x & '\0061\0308bc' LIKE x & '\00E4%c%' COLLATE ignore_accents;
/* _ versus two codepoints that form one grapheme: */ SELECT x & '\0061\0308bc' LIKE x & '_bc' COLLATE ignore_accents;
/* (actually this matches because) */ SELECT x & '\0308bc' = 'bc' COLLATE ignore_accents;
/* __ matches two codepoints that form one grapheme: */ SELECT x & '\0061\0308bc' LIKE x & '__bc' COLLATE ignore_accents;
/* _ matches one codepoint that forms half a grapheme: */ SELECT x & '\0061\0308bc' LIKE x & '_\0308bc' COLLATE ignore_accents;
/* doesn't match because \00e4 doesn't match only \0308 */ SELECT x & '\0061\0308bc' LIKE x & '_\00e4bc' COLLATE ignore_accents;
/* escape character at end of pattern */ SELECT 'foox' LIKE 'foo\' COLLATE ignore_accents;
/* foreign keys (mixing different nondeterministic collations not allowed) */ CREATE TABLE x (x TEXT COLLATE x PRIMARY KEY);
CREATE TABLE x (x TEXT COLLATE x REFERENCES x (x) ON UPDATE CASCADE ON DELETE CASCADE);
/* error */ CREATE TABLE x (x TEXT COLLATE x PRIMARY KEY);
CREATE TABLE x (x TEXT COLLATE x REFERENCES x (x) ON UPDATE CASCADE ON DELETE CASCADE);
/* error */ /* foreign key actions */ /* Some of the behaviors are most easily visible with a */ /* case-insensitive collation. */ CREATE TABLE x (x TEXT COLLATE x PRIMARY KEY);
CREATE TABLE x (x INT, x TEXT COLLATE x REFERENCES x (x) ON UPDATE NO ACTION);
INSERT INTO x VALUES ('abc');
INSERT INTO x VALUES (1, 'abc'), (2, 'ABC');
UPDATE x SET x = 'ABC' WHERE x = 'abc';
/* ok */ SELECT * FROM x;
SELECT * FROM x;
CREATE TABLE x (x TEXT COLLATE x PRIMARY KEY);
CREATE TABLE x (x INT, x TEXT COLLATE x REFERENCES x (x) ON UPDATE RESTRICT);
INSERT INTO x VALUES ('abc');
INSERT INTO x VALUES (1, 'abc'), (2, 'ABC');
UPDATE x SET x = 'ABC' WHERE x = 'abc';
/* restrict violation */ SELECT * FROM x;
SELECT * FROM x;
CREATE TABLE x (x TEXT COLLATE x PRIMARY KEY);
CREATE TABLE x (x INT, x TEXT COLLATE x REFERENCES x (x) ON UPDATE CASCADE);
INSERT INTO x VALUES ('abc');
INSERT INTO x VALUES (1, 'abc'), (2, 'ABC');
UPDATE x SET x = 'ABC' WHERE x = 'abc';
/* ok */ SELECT * FROM x;
SELECT * FROM x;
/* partitioning */ CREATE TABLE x (x INT, x TEXT COLLATE x) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN ('abc');
INSERT INTO x VALUES (1, 'abc');
INSERT INTO x VALUES (2, 'ABC');
SELECT * FROM x;
CREATE TABLE x (x INT, x TEXT COLLATE x) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM ('ABC') TO ('DEF');
INSERT INTO x VALUES (1, 'abc');
INSERT INTO x VALUES (2, 'ABC');
SELECT * FROM x;
CREATE TABLE x (x INT, x TEXT COLLATE x) WITH (PARTITIONED_BY=HASH(x));
CREATE TABLE x PARTITION OF x FOR VALUES WITH (MODULUS 2, REMAINDER 0);
CREATE TABLE x PARTITION OF x FOR VALUES WITH (MODULUS 2, REMAINDER 1);
INSERT INTO x VALUES (1, 'def');
INSERT INTO x VALUES (2, 'DEF');
/* they end up in different partitions */ SELECT (SELECT COUNT(*) FROM x) = (SELECT COUNT(*) FROM x);
/* same with arrays */ CREATE TABLE x (x INT, x ARRAY<TEXT> COLLATE x) WITH (PARTITIONED_BY=HASH(x));
CREATE TABLE x PARTITION OF x FOR VALUES WITH (MODULUS 2, REMAINDER 0);
CREATE TABLE x PARTITION OF x FOR VALUES WITH (MODULUS 2, REMAINDER 1);
INSERT INTO x VALUES (1, ARRAY('def'));
INSERT INTO x VALUES (2, ARRAY('DEF'));
/* they end up in different partitions */ SELECT (SELECT COUNT(*) FROM x) = (SELECT COUNT(*) FROM x);
CREATE TABLE x (x INT, x TEXT COLLATE x) WITH (PARTITIONED_BY=HASH(x));
CREATE TABLE x PARTITION OF x FOR VALUES WITH (MODULUS 2, REMAINDER 0);
CREATE TABLE x PARTITION OF x FOR VALUES WITH (MODULUS 2, REMAINDER 1);
INSERT INTO x VALUES (1, 'def');
INSERT INTO x VALUES (2, 'DEF');
/* they end up in the same partition (but it's platform-dependent which one) */ SELECT (SELECT COUNT(*) FROM x) <> (SELECT COUNT(*) FROM x);
/* same with arrays */ CREATE TABLE x (x INT, x ARRAY<TEXT> COLLATE x) WITH (PARTITIONED_BY=HASH(x));
CREATE TABLE x PARTITION OF x FOR VALUES WITH (MODULUS 2, REMAINDER 0);
CREATE TABLE x PARTITION OF x FOR VALUES WITH (MODULUS 2, REMAINDER 1);
INSERT INTO x VALUES (1, ARRAY('def'));
INSERT INTO x VALUES (2, ARRAY('DEF'));
/* they end up in the same partition (but it's platform-dependent which one) */ SELECT (SELECT COUNT(*) FROM x) <> (SELECT COUNT(*) FROM x);
CREATE TABLE x (x INT, x CHAR(3) COLLATE x) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN ('abc');
INSERT INTO x VALUES (1, 'abc');
INSERT INTO x VALUES (2, 'ABC');
SELECT * FROM x;
CREATE TABLE x (x INT, x CHAR(3) COLLATE x) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM ('ABC') TO ('DEF');
INSERT INTO x VALUES (1, 'abc');
INSERT INTO x VALUES (2, 'ABC');
SELECT * FROM x;
CREATE TABLE x (x INT, x CHAR(3) COLLATE x) WITH (PARTITIONED_BY=HASH(x));
CREATE TABLE x PARTITION OF x FOR VALUES WITH (MODULUS 2, REMAINDER 0);
CREATE TABLE x PARTITION OF x FOR VALUES WITH (MODULUS 2, REMAINDER 1);
INSERT INTO x VALUES (1, 'def');
INSERT INTO x VALUES (2, 'DEF');
/* they end up in different partitions */ SELECT (SELECT COUNT(*) FROM x) = (SELECT COUNT(*) FROM x);
CREATE TABLE x (x INT, x CHAR(3) COLLATE x) WITH (PARTITIONED_BY=HASH(x));
CREATE TABLE x PARTITION OF x FOR VALUES WITH (MODULUS 2, REMAINDER 0);
CREATE TABLE x PARTITION OF x FOR VALUES WITH (MODULUS 2, REMAINDER 1);
INSERT INTO x VALUES (1, 'def');
INSERT INTO x VALUES (2, 'DEF');
/* they end up in the same partition (but it's platform-dependent which one) */ SELECT (SELECT COUNT(*) FROM x) <> (SELECT COUNT(*) FROM x);
SET x = 0 /* Bug #18568 */ /* Partitionwise aggregate (full or partial) should not be used when a */ /* partition key's collation doesn't match that of the GROUP BY column it is */ /* matched with. */;
SET x = off;
CREATE TABLE x (x TEXT, x TEXT COLLATE x) WITH (PARTITIONED_BY=LIST(x COLLATE "x"));
CREATE TABLE x PARTITION OF x FOR VALUES IN ('a', 'b');
CREATE TABLE x PARTITION OF x FOR VALUES IN ('B', 'A');
INSERT INTO x SELECT x % 4 + 1, SUBSTRING('abAB', (x % 4) + 1, 1) FROM x AS x;
ANALYZE x;
SET x = FALSE;
EXPLAIN (COSTS OFF) SELECT upper(c collate case_insensitive), count(c) FROM pagg_tab3 GROUP BY c collate case_insensitive ORDER BY 1;
SELECT UPPER(x COLLATE case_insensitive), COUNT(x) FROM x GROUP BY x COLLATE case_insensitive ORDER BY 1 NULLS LAST;
SET x = TRUE /* No "full" partitionwise aggregation allowed, though "partial" is allowed. */;
EXPLAIN (COSTS OFF) SELECT upper(c collate case_insensitive), count(c) FROM pagg_tab3 GROUP BY c collate case_insensitive ORDER BY 1;
SELECT UPPER(x COLLATE case_insensitive), COUNT(x) FROM x GROUP BY x COLLATE case_insensitive ORDER BY 1 NULLS LAST;
/* OK to use full partitionwise aggregate after changing the GROUP BY column's */ /* collation to be the same as that of the partition key. */ EXPLAIN (COSTS OFF) SELECT c collate "C", count(c) FROM pagg_tab3 GROUP BY c collate "C" ORDER BY 1;
SELECT x COLLATE "x", COUNT(x) FROM x GROUP BY x COLLATE "x" ORDER BY 1 NULLS LAST;
SET x = FALSE /* Partitionwise join should not be allowed too when the collation used by the */ /* join keys doesn't match the partition key collation. */;
EXPLAIN (COSTS OFF) SELECT t1.c, count(t2.c) FROM pagg_tab3 t1 JOIN pagg_tab3 t2 ON t1.c = t2.c GROUP BY 1 ORDER BY t1.c COLLATE "C";
SELECT x.x, COUNT(x.x) FROM x AS x JOIN x AS x ON x.x = x.x GROUP BY 1 ORDER BY x.x COLLATE "x" NULLS LAST;
SET x = TRUE;
EXPLAIN (COSTS OFF) SELECT t1.c, count(t2.c) FROM pagg_tab3 t1 JOIN pagg_tab3 t2 ON t1.c = t2.c GROUP BY 1 ORDER BY t1.c COLLATE "C";
SELECT x.x, COUNT(x.x) FROM x AS x JOIN x AS x ON x.x = x.x GROUP BY 1 ORDER BY x.x COLLATE "x" NULLS LAST;
/* OK when the join clause uses the same collation as the partition key. */ EXPLAIN (COSTS OFF) SELECT t1.c COLLATE "C", count(t2.c) FROM pagg_tab3 t1 JOIN pagg_tab3 t2 ON t1.c = t2.c COLLATE "C" GROUP BY t1.c COLLATE "C" ORDER BY t1.c COLLATE "C";
SELECT x.x COLLATE "x", COUNT(x.x) FROM x AS x JOIN x AS x ON x.x = x.x COLLATE "x" GROUP BY x.x COLLATE "x" ORDER BY x.x COLLATE "x" NULLS LAST;
SET x = FALSE;
EXPLAIN (COSTS OFF) SELECT t1.c COLLATE "C", count(t2.c) FROM pagg_tab3 t1 JOIN pagg_tab3 t2 ON t1.c = t2.c COLLATE "C" GROUP BY t1.c COLLATE "C" ORDER BY t1.c COLLATE "C";
SELECT x.x COLLATE "x", COUNT(x.x) FROM x AS x JOIN x AS x ON x.x = x.x COLLATE "x" GROUP BY x.x COLLATE "x" ORDER BY x.x COLLATE "x" NULLS LAST;
SET x = TRUE /* Few other cases where the joined partition keys are matched via equivalence */ /* class, not a join restriction clause. */ /* Collations of joined columns match, but the partition keys collation is different */;
CREATE TABLE x (x TEXT COLLATE x, x TEXT COLLATE x) WITH (PARTITIONED_BY=LIST(x COLLATE "x"));
CREATE TABLE x PARTITION OF x FOR VALUES IN ('a', 'b');
CREATE TABLE x PARTITION OF x FOR VALUES IN ('B', 'A');
INSERT INTO x (x, x) SELECT SUBSTRING('abAB', (x % 4) + 1, 1), SUBSTRING('abAB', (x % 2) + 1, 1) FROM x AS x;
ANALYZE x;
EXPLAIN (COSTS OFF) SELECT t1.c, count(t2.c) FROM pagg_tab3 t1 JOIN pagg_tab4 t2 ON t1.c = t2.c AND t1.c = t2.b GROUP BY 1 ORDER BY t1.c COLLATE "C";
SELECT x.x, COUNT(x.x) FROM x AS x JOIN x AS x ON x.x = x.x AND x.x = x.x GROUP BY 1 ORDER BY x.x COLLATE "x" NULLS LAST;
/* OK when the partition key collation is same as that of the join columns */ CREATE TABLE x (x TEXT COLLATE x, x TEXT COLLATE x) WITH (PARTITIONED_BY=LIST(x COLLATE case_insensitive));
CREATE TABLE x PARTITION OF x FOR VALUES IN ('a', 'b');
CREATE TABLE x PARTITION OF x FOR VALUES IN ('c', 'd');
INSERT INTO x (x, x) SELECT SUBSTRING('abAB', (x % 4) + 1, 1), SUBSTRING('abAB', (x % 2) + 1, 1) FROM x AS x;
INSERT INTO x (x, x) SELECT SUBSTRING('cdCD', (x % 4) + 1, 1), SUBSTRING('cdCD', (x % 2) + 1, 1) FROM x AS x;
ANALYZE x;
CREATE TABLE x (x TEXT COLLATE x, x TEXT COLLATE x) WITH (PARTITIONED_BY=LIST(x COLLATE case_insensitive));
CREATE TABLE x PARTITION OF x FOR VALUES IN ('a', 'b');
CREATE TABLE x PARTITION OF x FOR VALUES IN ('c', 'd');
INSERT INTO x (x, x) SELECT SUBSTRING('abAB', (x % 4) + 1, 1), SUBSTRING('abAB', (x % 2) + 1, 1) FROM x AS x;
INSERT INTO x (x, x) SELECT SUBSTRING('cdCD', (x % 4) + 1, 1), SUBSTRING('cdCD', (x % 2) + 1, 1) FROM x AS x;
ANALYZE x;
EXPLAIN (COSTS OFF) SELECT t1.c, count(t2.c) FROM pagg_tab5 t1 JOIN pagg_tab6 t2 ON t1.c = t2.c AND t1.c = t2.b GROUP BY 1 ORDER BY t1.c COLLATE "C";
SELECT x.x, COUNT(x.x) FROM x AS x JOIN x AS x ON x.x = x.x AND x.x = x.x GROUP BY 1 ORDER BY x.x COLLATE "x" NULLS LAST;
SET x = FALSE;
EXPLAIN (COSTS OFF) SELECT t1.c, count(t2.c) FROM pagg_tab5 t1 JOIN pagg_tab6 t2 ON t1.c = t2.c AND t1.c = t2.b GROUP BY 1 ORDER BY t1.c COLLATE "C";
SELECT x.x, COUNT(x.x) FROM x AS x JOIN x AS x ON x.x = x.x AND x.x = x.x GROUP BY 1 ORDER BY x.x COLLATE "x" NULLS LAST;
DROP TABLE x;
DROP TABLE x;
DROP TABLE x;
DROP TABLE x;
RESET enable_partitionwise_aggregate;
RESET max_parallel_workers_per_gather;
RESET enable_incremental_sort;
/* virtual generated columns */ CREATE TABLE x (x INT, x TEXT COLLATE "x", x TEXT COLLATE "x" GENERATED ALWAYS AS (x COLLATE case_insensitive));
INSERT INTO x (x, x) VALUES (1, 'D1'), (2, 'D2'), (3, 'd1');
/* Collation of c should be the one defined for the column ("C"), not */ /* the one of the generation expression.  (Note that we cannot just */ /* test with, say, using COLLATION FOR, because the collation of */ /* function calls is already determined in the parser before */ /* rewriting.) */ SELECT * FROM x ORDER BY x ASC NULLS LAST, x ASC NULLS LAST;
/* cleanup */ RESET search_path;
SET x = warning;
DROP SCHEMA x.x CASCADE;
RESET client_min_messages;
/* leave a collation for pg_upgrade test */ CREATE COLLATION coll_icu_upgrade FROM "und-x-icu";
CREATE SCHEMA x.x;
SET x = collate_tests;
CREATE TABLE x (x INT, x TEXT COLLATE "x" NOT NULL);
CREATE TABLE x (x INT, x TEXT COLLATE "x");
CREATE TABLE x (x INT COLLATE "x", x TEXT);
CREATE TABLE x (LIKE x);
CREATE TABLE x (x INT, x TEXT COLLATE "x");
INSERT INTO x VALUES (1, 'abc'), (2, 'äbc'), (3, 'bbc'), (4, 'ABC');
INSERT INTO x SELECT * FROM x;
INSERT INTO x SELECT * FROM x;
SELECT * FROM x WHERE x >= 'bbc';
SELECT * FROM x WHERE x >= 'bbc';
SELECT * FROM x WHERE x >= 'bbc';
SELECT * FROM x WHERE x >= 'BBC';
SELECT * FROM x WHERE x COLLATE "x" >= 'bbc';
SELECT * FROM x WHERE x >= 'bbc' COLLATE "x";
SELECT * FROM x WHERE x COLLATE "x" >= 'bbc' COLLATE "x";
SELECT * FROM x WHERE x COLLATE "x" >= 'bbc' COLLATE "x";
CREATE DOMAIN testdomain_sv AS text COLLATE "sv_SE";
CREATE DOMAIN testdomain_i AS int COLLATE "sv_SE";
/* fails */ CREATE TABLE x (x INT, x testdomain_sv);
INSERT INTO x SELECT * FROM x;
SELECT x, x FROM x ORDER BY x NULLS LAST;
CREATE TABLE x (x INT, x testdomain_sv COLLATE "x");
INSERT INTO x SELECT * FROM x;
SELECT x, x FROM x ORDER BY x NULLS LAST;
SELECT x, x FROM x ORDER BY x NULLS LAST;
SELECT x, x FROM x ORDER BY x NULLS LAST;
SELECT x, x FROM x ORDER BY x NULLS LAST;
SELECT x, x FROM x ORDER BY x COLLATE "x" NULLS LAST;
/* star expansion */ SELECT * FROM x ORDER BY x NULLS LAST;
SELECT * FROM x ORDER BY x NULLS LAST;
SELECT * FROM x ORDER BY x NULLS LAST;
/* constant expression folding */ SELECT 'bbc' COLLATE "x" > 'äbc' COLLATE "x" AS "x";
SELECT 'bbc' COLLATE "x" > 'äbc' COLLATE "x" AS "x";
/* upper/lower */ CREATE TABLE x (x INT, x TEXT COLLATE "x", x TEXT COLLATE "x");
INSERT INTO x VALUES (1, 'hij', 'hij'), (2, 'HIJ', 'HIJ');
SELECT x, LOWER(x), LOWER(x), UPPER(x), UPPER(x), INITCAP(x), INITCAP(x) FROM x;
SELECT x, LOWER(x COLLATE "x"), LOWER(x COLLATE "x") FROM x;
SELECT x, x, x FROM x ORDER BY LOWER(x) NULLS LAST, x NULLS LAST;
/* LIKE/ILIKE */ SELECT * FROM x WHERE x LIKE 'abc';
SELECT * FROM x WHERE x LIKE 'abc%';
SELECT * FROM x WHERE x LIKE '%bc%';
SELECT * FROM x WHERE x ILIKE 'abc';
SELECT * FROM x WHERE x ILIKE 'abc%';
SELECT * FROM x WHERE x ILIKE '%bc%';
SELECT 'Türkiye' COLLATE "x" ILIKE '%KI%' AS "x";
SELECT 'Türkiye' COLLATE "x" ILIKE '%KI%' AS "x";
SELECT 'bıt' ILIKE 'BIT' COLLATE "x" AS "x";
SELECT 'bıt' ILIKE 'BIT' COLLATE "x" AS "x";
/* The following actually exercises the selectivity estimation for ILIKE. */ SELECT x FROM x WHERE x ILIKE 'abc%';
/* regular expressions */ SELECT * FROM x WHERE REGEXP_LIKE(x, '^abc$');
SELECT * FROM x WHERE REGEXP_LIKE(x, '^abc');
SELECT * FROM x WHERE REGEXP_LIKE(x, 'bc');
SELECT * FROM x WHERE REGEXP_I_LIKE(x, '^abc$');
SELECT * FROM x WHERE REGEXP_I_LIKE(x, '^abc');
SELECT * FROM x WHERE REGEXP_I_LIKE(x, 'bc');
CREATE TABLE x (x INT, x TEXT COLLATE "x");
SELECT x, REGEXP_LIKE(x, '^[[:alpha:]]+$') AS x, REGEXP_LIKE(x, '^[[:upper:]]+$') AS x, REGEXP_LIKE(x, '^[[:lower:]]+$') AS x, REGEXP_LIKE(x, '^[[:digit:]]+$') AS x, REGEXP_LIKE(x, '^[[:alnum:]]+$') AS x, REGEXP_LIKE(x, '^[[:graph:]]+$') AS x, REGEXP_LIKE(x, '^[[:print:]]+$') AS x, REGEXP_LIKE(x, '^[[:punct:]]+$') AS x, REGEXP_LIKE(x, '^[[:space:]]+$') AS x FROM x;
SELECT REGEXP_I_LIKE('Türkiye' COLLATE "x", 'KI') AS "x";
SELECT REGEXP_I_LIKE('Türkiye' COLLATE "x", 'KI') AS "x";
SELECT REGEXP_I_LIKE('bıt', 'BIT' COLLATE "x") AS "x";
SELECT REGEXP_I_LIKE('bıt', 'BIT' COLLATE "x") AS "x";
/* The following actually exercises the selectivity estimation for ~*. */ SELECT x FROM x WHERE REGEXP_I_LIKE(x, '^abc');
SET x = 'tr_TR' /* to_char */;
SELECT TIME_TO_STR(CAST('2010-02-01' AS DATE), '%d T%mON %Y');
SELECT TIME_TO_STR(CAST('2010-02-01' AS DATE), 'DD TMMON YYYY' COLLATE "x");
SELECT TIME_TO_STR(CAST('2010-04-01' AS DATE), '%d T%mON %Y');
SELECT TIME_TO_STR(CAST('2010-04-01' AS DATE), 'DD TMMON YYYY' COLLATE "x");
/* to_date */ SELECT STR_TO_DATE('01 ŞUB 2010', '%d T%mON %Y');
SELECT STR_TO_DATE('01 Şub 2010', '%d T%mON %Y');
SELECT STR_TO_DATE('1234567890ab 2010', 'T%mONTH %Y');
/* fail */ /* backwards parsing */ CREATE VIEW x AS SELECT * FROM x WHERE x COLLATE "x" >= 'bbc';
CREATE VIEW x AS SELECT x, x FROM x ORDER BY x COLLATE "x" NULLS LAST;
CREATE VIEW x AS SELECT x, LOWER((x || x) COLLATE "x") FROM x;
SELECT x, x FROM x.x WHERE x LIKE 'collview%' ORDER BY 1 NULLS LAST;
/* collation propagation in various expression types */ SELECT x, COALESCE(x, 'foo') FROM x ORDER BY 2 NULLS LAST;
SELECT x, COALESCE(x, 'foo') FROM x ORDER BY 2 NULLS LAST;
SELECT x, COALESCE(x, 'foo') FROM x ORDER BY 2 NULLS LAST;
SELECT x, LOWER(COALESCE(x, 'foo')), LOWER(COALESCE(x, 'foo')) FROM x;
SELECT x, x, GREATEST(x, 'CCC') FROM x ORDER BY 3 NULLS LAST;
SELECT x, x, GREATEST(x, 'CCC') FROM x ORDER BY 3 NULLS LAST;
SELECT x, x, GREATEST(x, 'CCC') FROM x ORDER BY 3 NULLS LAST;
SELECT x, x, x, LOWER(GREATEST(x, 'foo')), LOWER(GREATEST(x, 'foo')) FROM x;
SELECT x, NULLIF(x, 'abc') FROM x ORDER BY 2 NULLS LAST;
SELECT x, NULLIF(x, 'abc') FROM x ORDER BY 2 NULLS LAST;
SELECT x, NULLIF(x, 'abc') FROM x ORDER BY 2 NULLS LAST;
SELECT x, LOWER(NULLIF(x, 'foo')), LOWER(NULLIF(x, 'foo')) FROM x;
SELECT x, CASE x WHEN 'abc' THEN 'abcd' ELSE x END FROM x ORDER BY 2 NULLS LAST;
SELECT x, CASE x WHEN 'abc' THEN 'abcd' ELSE x END FROM x ORDER BY 2 NULLS LAST;
SELECT x, CASE x WHEN 'abc' THEN 'abcd' ELSE x END FROM x ORDER BY 2 NULLS LAST;
CREATE DOMAIN testdomain AS text;
SELECT x, CAST(x AS testdomain) FROM x ORDER BY 2 NULLS LAST;
SELECT x, CAST(x AS testdomain) FROM x ORDER BY 2 NULLS LAST;
SELECT x, CAST(x AS testdomain) FROM x ORDER BY 2 NULLS LAST;
SELECT x, CAST(x AS testdomain_sv) FROM x ORDER BY 2 NULLS LAST;
SELECT x, LOWER(CAST(x AS testdomain)), LOWER(CAST(x AS testdomain)) FROM x;
SELECT MIN(x), MAX(x) FROM x;
SELECT MIN(x), MAX(x) FROM x;
SELECT MIN(x), MAX(x) FROM x;
SELECT ARRAY_AGG(x ORDER BY x NULLS LAST) FROM x;
SELECT ARRAY_AGG(x ORDER BY x NULLS LAST) FROM x;
SELECT ARRAY_AGG(x ORDER BY x NULLS LAST) FROM x;
SELECT x, x FROM x UNION ALL SELECT x, x FROM x ORDER BY 2 NULLS LAST;
SELECT x, x FROM x UNION SELECT x, x FROM x ORDER BY 2 NULLS LAST;
SELECT x, x FROM x WHERE x < 4 INTERSECT SELECT x, x FROM x WHERE x > 1 ORDER BY 2 NULLS LAST;
SELECT x, x FROM x EXCEPT SELECT x, x FROM x WHERE x < 2 ORDER BY 2 NULLS LAST;
SELECT x, x FROM x UNION ALL SELECT x, x FROM x ORDER BY 2 NULLS LAST;
/* fail */ SELECT x, x FROM x UNION ALL SELECT x, x FROM x;
/* ok */ SELECT x, x FROM x UNION SELECT x, x FROM x ORDER BY 2 NULLS LAST;
/* fail */ SELECT x, x COLLATE "x" FROM x UNION SELECT x, x FROM x ORDER BY 2 NULLS LAST;
/* ok */ SELECT x, x FROM x INTERSECT SELECT x, x FROM x ORDER BY 2 NULLS LAST;
/* fail */ SELECT x, x FROM x EXCEPT SELECT x, x FROM x ORDER BY 2 NULLS LAST;
/* fail */ CREATE TABLE x AS SELECT x, x FROM x UNION ALL SELECT x, x FROM x;
/* fail */ /* ideally this would be a parse-time error, but for now it must be run-time: */ SELECT x < x FROM x;
/* fail */ SELECT x || x FROM x;
/* ok, because || is not collation aware */ SELECT x, x FROM x ORDER BY x || x NULLS LAST;
/* not so ok */ /* collation mismatch between recursive and non-recursive term */ WITH RECURSIVE x AS (SELECT x FROM (VALUES ('a' COLLATE "x"), ('b')) AS x UNION ALL SELECT (x || 'c') COLLATE "x" FROM x WHERE LENGTH(x) < 10) SELECT * FROM x;
SELECT x, CAST(x AS VARCHAR) FROM x ORDER BY 2 NULLS LAST;
SELECT x, CAST(x AS VARCHAR) FROM x ORDER BY 2 NULLS LAST;
SELECT x, CAST(x AS VARCHAR) FROM x ORDER BY 2 NULLS LAST;
/* propagation of collation in SQL functions (inlined and non-inlined cases) */ /* and plpgsql functions too */ CREATE FUNCTION x(x, x) RETURNS BOOLEAN LANGUAGE sql AS $$ select $1 < $2 $$;
CREATE FUNCTION x(x, x) RETURNS BOOLEAN LANGUAGE sql AS $$ select $1 < $2 limit 1 $$;
SELECT x.x AS x, x.x AS x, x.x < x.x AS x, MYLT(x.x, x.x), MYLT_NONINLINE(x.x, x.x), MYLT_PLPGSQL(x.x, x.x) FROM x AS x, x AS x ORDER BY x.x NULLS LAST, x.x NULLS LAST;
SELECT x.x AS x, x.x AS x, x.x < x.x COLLATE "x" AS x, MYLT(x.x, x.x COLLATE "x"), MYLT_NONINLINE(x.x, x.x COLLATE "x"), MYLT_PLPGSQL(x.x, x.x COLLATE "x") FROM x AS x, x AS x ORDER BY x.x NULLS LAST, x.x NULLS LAST;
BEGIN return xx < yy;
SELECT MYLT2('a', 'B' COLLATE "x") AS x, MYLT2('a', 'B' COLLATE "x") AS x;
BEGIN return xx < yy;
SELECT MYLT2('a', 'B') AS x;
SELECT MYLT2('a', 'B' COLLATE "x") AS x;
/* conflicting collations */ SELECT MYLT2('a', 'B' COLLATE "x") AS x;
/* polymorphism */ SELECT * FROM UNNEST((SELECT ARRAY_AGG(x ORDER BY x NULLS LAST) FROM x)) ORDER BY 1 NULLS LAST;
SELECT * FROM UNNEST((SELECT ARRAY_AGG(x ORDER BY x NULLS LAST) FROM x)) ORDER BY 1 NULLS LAST;
SELECT * FROM UNNEST((SELECT ARRAY_AGG(x ORDER BY x NULLS LAST) FROM x)) ORDER BY 1 NULLS LAST;
CREATE FUNCTION x(x) RETURNS anyelement LANGUAGE sql AS 'select $1';
SELECT x, DUP(x) FROM x ORDER BY 2 NULLS LAST;
SELECT x, DUP(x) FROM x ORDER BY 2 NULLS LAST;
SELECT x, DUP(x) FROM x ORDER BY 2 NULLS LAST;
/* indexes */ CREATE INDEX x ON x(x NULLS LAST);
CREATE INDEX x ON x(x COLLATE "x" NULLS LAST);
CREATE INDEX x ON x((x COLLATE "x") NULLS LAST);
/* this is different grammatically */ CREATE INDEX x ON x(((x || 'foo') COLLATE "x") NULLS LAST);
CREATE INDEX x ON x(x COLLATE "x" NULLS LAST);
/* fail */ CREATE INDEX x ON x((x COLLATE "x") NULLS LAST);
/* fail */ SELECT x, PG_GET_INDEXDEF(x) FROM x WHERE x LIKE 'collate_test%_idx%' ORDER BY 1 NULLS LAST;
/* schema manipulation commands */ CREATE ROLE regress_test_role;
CREATE SCHEMA x.x;
CREATE COLLATION test0 FROM "C";
/* fail, duplicate name */ CREATE COLLATION IF NOT EXISTS test0 FROM "C";
/* ok, skipped */ CREATE COLLATION IF NOT EXISTS test0 (locale = 'foo');
CREATE COLLATION test3 (lc_collate = 'en_US.utf8');
/* fail, need lc_ctype */ CREATE COLLATION testx (locale = 'nonsense');
/* fail */ CREATE COLLATION test4 FROM nonsense;
CREATE COLLATION test5 FROM test0;
SELECT x FROM x WHERE x LIKE 'test%' ORDER BY 1 NULLS LAST;
ALTER COLLATION test1 RENAME TO test11;
ALTER COLLATION test0 RENAME TO test11;
/* fail */ ALTER COLLATION test1 RENAME TO test22;
/* fail */ ALTER COLLATION test11 OWNER TO regress_test_role;
ALTER COLLATION test11 OWNER TO nonsense;
ALTER COLLATION test11 SET SCHEMA test_schema;
COMMENT ON COLLATION test0 IS 'US English';
SELECT x, x, OBJ_DESCRIPTION(x.x, 'pg_collation') FROM x JOIN x ON (x = x.x) WHERE x LIKE 'test%' ORDER BY 1 NULLS LAST;
DROP COLLATION test0, test_schema.test11, test5;
DROP COLLATION test0;
/* fail */ DROP COLLATION IF EXISTS test0;
SELECT x FROM x WHERE x LIKE 'test%';
DROP SCHEMA x.x;
DROP ROLE regress_test_role;
/* ALTER */ ALTER COLLATION "en_US" REFRESH VERSION;
/* dependencies */ CREATE COLLATION test0 FROM "C";
CREATE TABLE x (x INT, x TEXT COLLATE x);
CREATE DOMAIN collate_dep_dom1 AS text COLLATE test0;
CREATE TYPE collate_dep_test2 AS (x int, y text COLLATE test0);
CREATE VIEW x AS SELECT CAST('foo' AS TEXT) COLLATE test0 AS x;
CREATE TABLE x (x INT, x TEXT);
CREATE INDEX x ON x(x COLLATE test0 NULLS LAST);
DROP COLLATION test0 RESTRICT;
/* fail */ DROP COLLATION test0 CASCADE;
DROP TYPE collate_dep_test2;
/* test range types and collations */ create type textrange_c as range(subtype=text, collation="C");
create type textrange_en_us as range(subtype=text, collation="en_US");
SELECT TEXTRANGE_C('A', 'Z') @> CAST('b' AS TEXT);
SELECT TEXTRANGE_EN_US('A', 'Z') @> CAST('b' AS TEXT);
drop type textrange_c;
drop type textrange_en_us;
/* standard collations */ SELECT * FROM x ORDER BY x COLLATE UCS_BASIC NULLS LAST;
/* nondeterministic collations */ /* (not supported with libc provider) */ CREATE COLLATION ctest_det (locale = 'en_US.utf8', deterministic = true);
CREATE COLLATION ctest_nondet (locale = 'en_US.utf8', deterministic = false);
SET x = warning /* cleanup */;
DROP SCHEMA x.x CASCADE;
/*  * This test is intended to pass on all platforms supported by Postgres.  * We can therefore only assume that the default, C, and POSIX collations  * are available --- and since the regression tests are often run in a  * C-locale database, these may well all have the same behavior.  But  * fortunately, the system doesn't know that and will treat them as  * incompatible collations.  It is therefore at least possible to test  * parser behaviors such as collation conflict resolution.  This test will,  * however, be more revealing when run in a database with non-C locale,  * since any departure from C sorting behavior will show as a failure.  */ CREATE SCHEMA x.x;
SET x = collate_tests;
CREATE TABLE x (x INT, x TEXT COLLATE "x" NOT NULL);
CREATE TABLE x (LIKE x);
INSERT INTO x VALUES (1, 'abc'), (2, 'Abc'), (3, 'bbc'), (4, 'ABD');
INSERT INTO x SELECT * FROM x;
SELECT * FROM x WHERE x COLLATE "x" >= 'abc';
SELECT * FROM x WHERE x >= 'abc' COLLATE "x";
SELECT * FROM x WHERE x COLLATE "x" >= 'abc' COLLATE "x";
SELECT * FROM x WHERE x COLLATE "x" >= 'bbc' COLLATE "x";
/* fail */ CREATE DOMAIN testdomain_p AS text COLLATE "POSIX";
CREATE DOMAIN testdomain_i AS int COLLATE "POSIX";
/* fail */ CREATE TABLE x (x INT, x testdomain_p);
INSERT INTO x SELECT * FROM x;
SELECT x, x FROM x ORDER BY x NULLS LAST;
CREATE TABLE x (x INT, x testdomain_p COLLATE "x");
INSERT INTO x SELECT * FROM x;
SELECT x, x FROM x ORDER BY x NULLS LAST;
SELECT x, x FROM x ORDER BY x NULLS LAST;
SELECT x, x FROM x ORDER BY x NULLS LAST;
SELECT x, x FROM x ORDER BY x COLLATE "x" NULLS LAST;
/* star expansion */ SELECT * FROM x ORDER BY x NULLS LAST;
SELECT * FROM x ORDER BY x NULLS LAST;
/* constant expression folding */ SELECT 'bbc' COLLATE "x" > 'Abc' COLLATE "x" AS "x";
SELECT 'bbc' COLLATE "x" < 'Abc' COLLATE "x" AS "x";
/* upper/lower */ CREATE TABLE x (x INT, x TEXT COLLATE "x", x TEXT COLLATE "x");
INSERT INTO x VALUES (1, 'hij', 'hij'), (2, 'HIJ', 'HIJ');
SELECT x, LOWER(x), LOWER(x), UPPER(x), UPPER(x), INITCAP(x), INITCAP(x) FROM x;
SELECT x, LOWER(x COLLATE "x"), LOWER(x COLLATE "x") FROM x;
SELECT x, x, x FROM x ORDER BY LOWER(x) NULLS LAST, x NULLS LAST;
/* backwards parsing */ CREATE VIEW x AS SELECT * FROM x WHERE x COLLATE "x" >= 'bbc';
CREATE VIEW x AS SELECT x, x FROM x ORDER BY x COLLATE "x" NULLS LAST;
CREATE VIEW x AS SELECT x, LOWER((x || x) COLLATE "x") FROM x;
SELECT x, x FROM x.x WHERE x LIKE 'collview%' ORDER BY 1 NULLS LAST;
/* collation propagation in various expression types */ SELECT x, COALESCE(x, 'foo') FROM x ORDER BY 2 NULLS LAST;
SELECT x, COALESCE(x, 'foo') FROM x ORDER BY 2 NULLS LAST;
SELECT x, LOWER(COALESCE(x, 'foo')), LOWER(COALESCE(x, 'foo')) FROM x;
SELECT x, x, GREATEST(x, 'CCC') FROM x ORDER BY 3 NULLS LAST;
SELECT x, x, GREATEST(x, 'CCC') FROM x ORDER BY 3 NULLS LAST;
SELECT x, x, x, LOWER(GREATEST(x, 'foo')), LOWER(GREATEST(x, 'foo')) FROM x;
SELECT x, NULLIF(x, 'abc') FROM x ORDER BY 2 NULLS LAST;
SELECT x, NULLIF(x, 'abc') FROM x ORDER BY 2 NULLS LAST;
SELECT x, LOWER(NULLIF(x, 'foo')), LOWER(NULLIF(x, 'foo')) FROM x;
SELECT x, CASE x WHEN 'abc' THEN 'abcd' ELSE x END FROM x ORDER BY 2 NULLS LAST;
SELECT x, CASE x WHEN 'abc' THEN 'abcd' ELSE x END FROM x ORDER BY 2 NULLS LAST;
CREATE DOMAIN testdomain AS text;
SELECT x, CAST(x AS testdomain) FROM x ORDER BY 2 NULLS LAST;
SELECT x, CAST(x AS testdomain) FROM x ORDER BY 2 NULLS LAST;
SELECT x, CAST(x AS testdomain_p) FROM x ORDER BY 2 NULLS LAST;
SELECT x, LOWER(CAST(x AS testdomain)), LOWER(CAST(x AS testdomain)) FROM x;
SELECT MIN(x), MAX(x) FROM x;
SELECT MIN(x), MAX(x) FROM x;
SELECT ARRAY_AGG(x ORDER BY x NULLS LAST) FROM x;
SELECT ARRAY_AGG(x ORDER BY x NULLS LAST) FROM x;
/* In aggregates, ORDER BY expressions don't affect aggregate's collation */ SELECT GROUP_CONCAT(x COLLATE "x", x COLLATE "x") FROM x;
/* fail */ SELECT ARRAY_AGG(x COLLATE "x" ORDER BY x COLLATE "x" NULLS LAST) FROM x;
SELECT ARRAY_AGG(x ORDER BY x COLLATE "x" NULLS LAST, x COLLATE "x" NULLS LAST) FROM x;
SELECT ARRAY_AGG(x ORDER BY x || x NULLS LAST) FROM x;
/* fail */ SELECT x, x FROM x UNION ALL SELECT x, x FROM x ORDER BY 2 NULLS LAST;
SELECT x, x FROM x UNION SELECT x, x FROM x ORDER BY 2 NULLS LAST;
SELECT x, x FROM x WHERE x < 4 INTERSECT SELECT x, x FROM x WHERE x > 1 ORDER BY 2 NULLS LAST;
SELECT x, x FROM x EXCEPT SELECT x, x FROM x WHERE x < 2 ORDER BY 2 NULLS LAST;
SELECT x, x FROM x UNION ALL SELECT x, x FROM x ORDER BY 2 NULLS LAST;
/* fail */ SELECT x, x FROM x UNION ALL SELECT x, x FROM x;
/* ok */ SELECT x, x FROM x UNION SELECT x, x FROM x ORDER BY 2 NULLS LAST;
/* fail */ SELECT x, x COLLATE "x" FROM x UNION SELECT x, x FROM x ORDER BY 2 NULLS LAST;
/* ok */ SELECT x, x FROM x INTERSECT SELECT x, x FROM x ORDER BY 2 NULLS LAST;
/* fail */ SELECT x, x FROM x EXCEPT SELECT x, x FROM x ORDER BY 2 NULLS LAST;
/* fail */ CREATE TABLE x AS SELECT x, x FROM x UNION ALL SELECT x, x FROM x;
/* fail */ /* ideally this would be a parse-time error, but for now it must be run-time: */ SELECT x < x FROM x;
/* fail */ SELECT x || x FROM x;
/* ok, because || is not collation aware */ SELECT x, x FROM x ORDER BY x || x NULLS LAST;
/* not so ok */ /* collation mismatch between recursive and non-recursive term */ WITH RECURSIVE x AS (SELECT x FROM (VALUES ('a' COLLATE "x"), ('b')) AS x UNION ALL SELECT (x || 'c') COLLATE "x" FROM x WHERE LENGTH(x) < 10) SELECT * FROM x;
SELECT x, x, x < x AS x FROM (VALUES ('a', 'B'), ('A', 'b' COLLATE "x")) AS x;
/* collation mismatch in subselects */ SELECT * FROM x WHERE NOT (x, x) IN (SELECT x, x FROM x);
/* now it works with overrides */ SELECT * FROM x WHERE NOT (x COLLATE "x", x COLLATE "x") IN (SELECT x, x FROM x);
SELECT * FROM x WHERE NOT (x, x) IN (SELECT x COLLATE "x", x COLLATE "x" FROM x);
SELECT x, CAST(x AS VARCHAR) FROM x ORDER BY 2 NULLS LAST;
SELECT x, CAST(x AS VARCHAR) FROM x ORDER BY 2 NULLS LAST;
/* result of a SQL function */ CREATE FUNCTION x(x) RETURNS TEXT LANGUAGE sql AS 'select $1::varchar';
SELECT x, x FROM x ORDER BY x NULLS LAST, VC(x) NULLS LAST;
/* polymorphism */ SELECT * FROM UNNEST((SELECT ARRAY_AGG(x ORDER BY x NULLS LAST) FROM x)) ORDER BY 1 NULLS LAST;
SELECT * FROM UNNEST((SELECT ARRAY_AGG(x ORDER BY x NULLS LAST) FROM x)) ORDER BY 1 NULLS LAST;
CREATE FUNCTION x(x) RETURNS anyelement LANGUAGE sql AS 'select $1';
SELECT x, DUP(x) FROM x ORDER BY 2 NULLS LAST;
SELECT x, DUP(x) FROM x ORDER BY 2 NULLS LAST;
/* indexes */ CREATE INDEX x ON x(x NULLS LAST);
CREATE INDEX x ON x(x COLLATE "x" NULLS LAST);
CREATE INDEX x ON x((x COLLATE "x") NULLS LAST);
/* this is different grammatically */ CREATE INDEX x ON x(((x || 'foo') COLLATE "x") NULLS LAST);
CREATE INDEX x ON x(x COLLATE "x" NULLS LAST);
/* fail */ CREATE INDEX x ON x((x COLLATE "x") NULLS LAST);
/* fail */ SELECT x, PG_GET_INDEXDEF(x) FROM x WHERE x LIKE 'collate_test%_idx%' ORDER BY 1 NULLS LAST;
SET x = 0 /* foreign keys */ /* force indexes and mergejoins to be used for FK checking queries, */ /* else they might not exercise collation-dependent operators */;
SET x = 0;
SET x = 0;
CREATE TABLE x (x TEXT COLLATE "x" PRIMARY KEY);
INSERT INTO x VALUES ('foo'), ('bar');
CREATE TABLE x (x TEXT COLLATE "x" REFERENCES x);
INSERT INTO x VALUES ('foo'), ('bar');
INSERT INTO x VALUES ('baz');
/* fail */ CREATE TABLE x (x TEXT COLLATE "x");
INSERT INTO x VALUES ('foo'), ('bar'), ('baz');
ALTER TABLE x ADD FOREIGN KEY (x) REFERENCES x;
/* fail */ DELETE FROM x WHERE x = 'baz';
ALTER TABLE x ADD FOREIGN KEY (x) REFERENCES x;
RESET enable_seqscan;
RESET enable_hashjoin;
RESET enable_nestloop;
/* EXPLAIN */ EXPLAIN (COSTS OFF)   SELECT * FROM collate_test10 ORDER BY x, y;
EXPLAIN (COSTS OFF)   SELECT * FROM collate_test10 ORDER BY x DESC, y COLLATE "C" ASC NULLS FIRST;
/* CREATE/DROP COLLATION */ CREATE COLLATION builtin_c ( PROVIDER = builtin, LOCALE = "C" );
SELECT x FROM x ORDER BY x COLLATE builtin_c NULLS LAST;
CREATE COLLATION builtin2 ( PROVIDER = builtin );
/* fails */ CREATE COLLATION builtin2 ( PROVIDER = builtin, LOCALE = "en_US" );
/* fails */ CREATE COLLATION builtin2 ( PROVIDER = builtin, LC_CTYPE = "C", LC_COLLATE = "C" );
/* fails */ CREATE COLLATION mycoll1 FROM "C";
CREATE COLLATION mycoll2 ( LC_COLLATE = "POSIX", LC_CTYPE = "POSIX" );
CREATE COLLATION mycoll3 FROM "default";
/* intentionally unsupported */ DROP COLLATION mycoll1;
CREATE TABLE x (x TEXT COLLATE x);
DROP COLLATION mycoll2;
/* fail */ /* invalid: non-lowercase quoted identifiers */ CREATE COLLATION case_coll ("Lc_Collate" = "POSIX", "Lc_Ctype" = "POSIX");
/* 9.1 bug with useless COLLATE in an expression subject to length coercion */ CREATE TEMPORARY TABLE x (x VARCHAR(25));
INSERT INTO x VALUES ('foo' COLLATE "x");
/* old bug with not dropping COLLATE when coercing to non-collatable type */ CREATE VIEW x AS SELECT x + 1 AS x FROM (SELECT CAST(('4' COLLATE "x") AS INT) AS x) AS x;
/* LC_CTYPE */ CREATE COLLATION coll_dup_chk (LC_CTYPE = "POSIX", LC_CTYPE = "NONSENSE", LC_COLLATE = "POSIX");
/* PROVIDER */ CREATE COLLATION coll_dup_chk (PROVIDER = icu, PROVIDER = NONSENSE, LC_COLLATE = "POSIX", LC_CTYPE = "POSIX");
/* LOCALE */ CREATE COLLATION case_sensitive (LOCALE = '', LOCALE = "NONSENSE");
/* DETERMINISTIC */ CREATE COLLATION coll_dup_chk (DETERMINISTIC = TRUE, DETERMINISTIC = NONSENSE, LOCALE = '');
/* VERSION */ CREATE COLLATION coll_dup_chk (VERSION = '1', VERSION = "NONSENSE", LOCALE = '');
/* LOCALE conflicts with LC_COLLATE and LC_CTYPE */ CREATE COLLATION coll_dup_chk (LC_COLLATE = "POSIX", LC_CTYPE = "POSIX", LOCALE = '');
/* LOCALE conflicts with LC_COLLATE */ CREATE COLLATION coll_dup_chk (LC_COLLATE = "POSIX", LOCALE = '');
/* LOCALE conflicts with LC_CTYPE */ CREATE COLLATION coll_dup_chk (LC_CTYPE = "POSIX", LOCALE = '');
/* FROM conflicts with any other option */ CREATE COLLATION coll_dup_chk (FROM = "C", VERSION = "1");
/* Clean up.  Many of these table names will be re-used if the user is */ /* trying to run any platform-specific collation tests later, so we */ /* must get rid of them. */ DROP SCHEMA x.x CASCADE;
/* Test builtin "C" */ CREATE COLLATION regress_builtin_c (   provider = builtin, locale = 'C');
/* non-ASCII characters are unchanged */ SELECT LOWER(x & '\00C1' COLLATE regress_builtin_c) = x & '\00C1';
SELECT UPPER(x & '\00E1' COLLATE regress_builtin_c) = x & '\00E1';
/* non-ASCII characters are not alphabetic */ SELECT NOT REGEXP_LIKE(x & '\00C1\00E1', '[[:alpha:]]' COLLATE regress_builtin_c);
DROP COLLATION regress_builtin_c;
/* Test PG_C_UTF8 */ CREATE COLLATION regress_pg_c_utf8 (   provider = builtin, locale = 'C_UTF8');
/* fails */ CREATE COLLATION regress_pg_c_utf8 (   provider = builtin, locale = 'C.UTF8');
DROP COLLATION regress_pg_c_utf8;
CREATE COLLATION regress_pg_c_utf8 (   provider = builtin, locale = 'C.UTF-8');
CREATE TABLE x (x TEXT COLLATE x);
INSERT INTO x VALUES ('abc DEF 123abc'), ('ábc sßs ßss DÉF'), ('ǄxxǄ ǆxxǅ ǅxxǆ'), ('ȺȺȺ'), ('ⱥⱥⱥ'), ('ⱥȺ');
SELECT x, LOWER(x), INITCAP(x), UPPER(x), LENGTH(CONVERT_TO(x, 'UTF8')) AS x, LENGTH(CONVERT_TO(LOWER(x), 'UTF8')) AS x, LENGTH(CONVERT_TO(INITCAP(x), 'UTF8')) AS x, LENGTH(CONVERT_TO(UPPER(x), 'UTF8')) AS x FROM x;
DROP TABLE x;
/* negative test: Final_Sigma not used for builtin locale C.UTF-8 */ SELECT LOWER('ΑΣ' COLLATE PG_C_UTF8);
SELECT LOWER('ΑͺΣͺ' COLLATE PG_C_UTF8);
SELECT LOWER('Α΄Σ΄' COLLATE PG_C_UTF8);
/* properties */ SELECT REGEXP_LIKE('xyz', '[[:alnum:]]' COLLATE PG_C_UTF8);
SELECT NOT REGEXP_LIKE('xyz', '[[:upper:]]' COLLATE PG_C_UTF8);
SELECT NOT REGEXP_LIKE('@', '[[:alnum:]]' COLLATE PG_C_UTF8);
SELECT REGEXP_LIKE('=', '[[:punct:]]' COLLATE PG_C_UTF8);
/* symbols are punctuation in posix */ SELECT REGEXP_LIKE('a8a', '[[:digit:]]' COLLATE PG_C_UTF8);
SELECT NOT REGEXP_LIKE('൧', '\d' COLLATE PG_C_UTF8);
/* only 0-9 considered digits in posix */ /* case mapping */ SELECT REGEXP_I_LIKE('xYz', 'XyZ' COLLATE PG_C_UTF8);
SELECT REGEXP_I_LIKE('xAb', '[W-Y]' COLLATE PG_C_UTF8);
SELECT NOT REGEXP_I_LIKE('xAb', '[c-d]' COLLATE PG_C_UTF8);
SELECT REGEXP_I_LIKE('Δ', '[γ-λ]' COLLATE PG_C_UTF8);
SELECT REGEXP_I_LIKE('δ', '[Γ-Λ]' COLLATE PG_C_UTF8);
/* same as above with cases reversed */ /* case folding */ SELECT CASEFOLD('AbCd 123 #$% ıiIİ ẞ ß Ǆǅǆ Σσς' COLLATE PG_C_UTF8);
/* Test PG_UNICODE_FAST */ CREATE COLLATION regress_pg_unicode_fast (   provider = builtin, locale = 'unicode');
/* fails */ CREATE COLLATION regress_pg_unicode_fast (   provider = builtin, locale = 'PG_UNICODE_FAST');
CREATE TABLE x (x TEXT COLLATE x);
INSERT INTO x VALUES ('abc DEF 123abc'), ('ábc sßs ßss DÉF'), ('ǄxxǄ ǆxxǅ ǅxxǆ'), ('ȺȺȺ'), ('ⱥⱥⱥ'), ('ⱥȺ');
SELECT x, LOWER(x), INITCAP(x), UPPER(x), LENGTH(CONVERT_TO(x, 'UTF8')) AS x, LENGTH(CONVERT_TO(LOWER(x), 'UTF8')) AS x, LENGTH(CONVERT_TO(INITCAP(x), 'UTF8')) AS x, LENGTH(CONVERT_TO(UPPER(x), 'UTF8')) AS x FROM x;
DROP TABLE x;
/* test Final_Sigma */ SELECT LOWER('ΑΣ' COLLATE PG_UNICODE_FAST);
/* 0391 03A3 */ SELECT LOWER('ΑΣ0' COLLATE PG_UNICODE_FAST);
/* 0391 03A3 0030 */ SELECT LOWER('ἈΣ̓' COLLATE PG_UNICODE_FAST);
/* 0391 0343 03A3 0343 */ SELECT LOWER('ᾼΣͅ' COLLATE PG_UNICODE_FAST);
/* 0391 0345 03A3 0345 */ /* test !Final_Sigma */ SELECT LOWER('Σ' COLLATE PG_UNICODE_FAST);
/* 03A3 */ SELECT LOWER('0Σ' COLLATE PG_UNICODE_FAST);
/* 0030 03A3 */ SELECT LOWER('ΑΣΑ' COLLATE PG_UNICODE_FAST);
/* 0391 03A3 0391 */ SELECT LOWER('ἈΣ̓Α' COLLATE PG_UNICODE_FAST);
/* 0391 0343 03A3 0343 0391 */ SELECT LOWER('ᾼΣͅΑ' COLLATE PG_UNICODE_FAST);
/* 0391 0345 03A3 0345 0391 */ /* properties */ SELECT REGEXP_LIKE('xyz', '[[:alnum:]]' COLLATE PG_UNICODE_FAST);
SELECT NOT REGEXP_LIKE('xyz', '[[:upper:]]' COLLATE PG_UNICODE_FAST);
SELECT NOT REGEXP_LIKE('@', '[[:alnum:]]' COLLATE PG_UNICODE_FAST);
SELECT NOT REGEXP_LIKE('=', '[[:punct:]]' COLLATE PG_UNICODE_FAST);
/* symbols are not punctuation */ SELECT REGEXP_LIKE('a8a', '[[:digit:]]' COLLATE PG_UNICODE_FAST);
SELECT REGEXP_LIKE('൧', '\d' COLLATE PG_UNICODE_FAST);
/* case mapping */ SELECT REGEXP_I_LIKE('xYz', 'XyZ' COLLATE PG_UNICODE_FAST);
SELECT REGEXP_I_LIKE('xAb', '[W-Y]' COLLATE PG_UNICODE_FAST);
SELECT NOT REGEXP_I_LIKE('xAb', '[c-d]' COLLATE PG_UNICODE_FAST);
SELECT REGEXP_I_LIKE('Δ', '[γ-λ]' COLLATE PG_UNICODE_FAST);
SELECT REGEXP_I_LIKE('δ', '[Γ-Λ]' COLLATE PG_UNICODE_FAST);
/* same as above with cases reversed */ /* case folding */ SELECT CASEFOLD('AbCd 123 #$% ıiIİ ẞ ß Ǆǅǆ Σσς' COLLATE PG_UNICODE_FAST);
CREATE SCHEMA x.x;
SET x = collate_tests;
CREATE TABLE x (x INT, x TEXT COLLATE "x" NOT NULL);
CREATE TABLE x (x INT, x TEXT COLLATE "x");
CREATE TABLE x (x INT COLLATE "x", x TEXT);
CREATE TABLE x (LIKE x);
CREATE TABLE x (x INT, x TEXT COLLATE "x");
INSERT INTO x VALUES (1, 'abc'), (2, '�bc'), (3, 'bbc'), (4, 'ABC');
INSERT INTO x SELECT * FROM x;
INSERT INTO x SELECT * FROM x;
SELECT * FROM x WHERE x >= 'bbc';
SELECT * FROM x WHERE x >= 'bbc';
SELECT * FROM x WHERE x >= 'bbc';
SELECT * FROM x WHERE x >= 'BBC';
SELECT * FROM x WHERE x COLLATE "x" >= 'bbc';
SELECT * FROM x WHERE x >= 'bbc' COLLATE "x";
SELECT * FROM x WHERE x COLLATE "x" >= 'bbc' COLLATE "x";
SELECT * FROM x WHERE x COLLATE "x" >= 'bbc' COLLATE "x";
CREATE DOMAIN testdomain_sv AS text COLLATE "sv_SE";
CREATE DOMAIN testdomain_i AS int COLLATE "sv_SE";
/* fails */ CREATE TABLE x (x INT, x testdomain_sv);
INSERT INTO x SELECT * FROM x;
SELECT x, x FROM x ORDER BY x NULLS LAST;
CREATE TABLE x (x INT, x testdomain_sv COLLATE "x");
INSERT INTO x SELECT * FROM x;
SELECT x, x FROM x ORDER BY x NULLS LAST;
SELECT x, x FROM x ORDER BY x NULLS LAST;
SELECT x, x FROM x ORDER BY x NULLS LAST;
SELECT x, x FROM x ORDER BY x NULLS LAST;
SELECT x, x FROM x ORDER BY x COLLATE "x" NULLS LAST;
/* star expansion */ SELECT * FROM x ORDER BY x NULLS LAST;
SELECT * FROM x ORDER BY x NULLS LAST;
SELECT * FROM x ORDER BY x NULLS LAST;
/* constant expression folding */ SELECT 'bbc' COLLATE "x" > '�bc' COLLATE "x" AS "x";
SELECT 'bbc' COLLATE "x" > '�bc' COLLATE "x" AS "x";
/* LIKE/ILIKE */ SELECT * FROM x WHERE x LIKE 'abc';
SELECT * FROM x WHERE x LIKE 'abc%';
SELECT * FROM x WHERE x LIKE '%bc%';
SELECT * FROM x WHERE x ILIKE 'abc';
SELECT * FROM x WHERE x ILIKE 'abc%';
SELECT * FROM x WHERE x ILIKE '%bc%';
/* The following actually exercises the selectivity estimation for ILIKE. */ SELECT x FROM x WHERE x ILIKE 'abc%';
/* regular expressions */ SELECT * FROM x WHERE REGEXP_LIKE(x, '^abc$');
SELECT * FROM x WHERE REGEXP_LIKE(x, '^abc');
SELECT * FROM x WHERE REGEXP_LIKE(x, 'bc');
SELECT * FROM x WHERE REGEXP_I_LIKE(x, '^abc$');
SELECT * FROM x WHERE REGEXP_I_LIKE(x, '^abc');
SELECT * FROM x WHERE REGEXP_I_LIKE(x, 'bc');
CREATE TABLE x (x INT, x TEXT COLLATE "x");
SELECT x, REGEXP_LIKE(x, '^[[:alpha:]]+$') AS x, REGEXP_LIKE(x, '^[[:upper:]]+$') AS x, REGEXP_LIKE(x, '^[[:lower:]]+$') AS x, REGEXP_LIKE(x, '^[[:digit:]]+$') AS x, REGEXP_LIKE(x, '^[[:alnum:]]+$') AS x, REGEXP_LIKE(x, '^[[:graph:]]+$') AS x, REGEXP_LIKE(x, '^[[:print:]]+$') AS x, REGEXP_LIKE(x, '^[[:punct:]]+$') AS x, REGEXP_LIKE(x, '^[[:space:]]+$') AS x FROM x;
/* The following actually exercises the selectivity estimation for ~*. */ SELECT x FROM x WHERE REGEXP_I_LIKE(x, '^abc');
/* backwards parsing */ CREATE VIEW x AS SELECT * FROM x WHERE x COLLATE "x" >= 'bbc';
CREATE VIEW x AS SELECT x, x FROM x ORDER BY x COLLATE "x" NULLS LAST;
SELECT x, x FROM x.x WHERE x LIKE 'collview%' ORDER BY 1 NULLS LAST;
/* collation propagation in various expression types */ SELECT x, COALESCE(x, 'foo') FROM x ORDER BY 2 NULLS LAST;
SELECT x, COALESCE(x, 'foo') FROM x ORDER BY 2 NULLS LAST;
SELECT x, COALESCE(x, 'foo') FROM x ORDER BY 2 NULLS LAST;
SELECT x, x, GREATEST(x, 'CCC') FROM x ORDER BY 3 NULLS LAST;
SELECT x, x, GREATEST(x, 'CCC') FROM x ORDER BY 3 NULLS LAST;
SELECT x, x, GREATEST(x, 'CCC') FROM x ORDER BY 3 NULLS LAST;
SELECT x, NULLIF(x, 'abc') FROM x ORDER BY 2 NULLS LAST;
SELECT x, NULLIF(x, 'abc') FROM x ORDER BY 2 NULLS LAST;
SELECT x, NULLIF(x, 'abc') FROM x ORDER BY 2 NULLS LAST;
SELECT x, CASE x WHEN 'abc' THEN 'abcd' ELSE x END FROM x ORDER BY 2 NULLS LAST;
SELECT x, CASE x WHEN 'abc' THEN 'abcd' ELSE x END FROM x ORDER BY 2 NULLS LAST;
SELECT x, CASE x WHEN 'abc' THEN 'abcd' ELSE x END FROM x ORDER BY 2 NULLS LAST;
CREATE DOMAIN testdomain AS text;
SELECT x, CAST(x AS testdomain) FROM x ORDER BY 2 NULLS LAST;
SELECT x, CAST(x AS testdomain) FROM x ORDER BY 2 NULLS LAST;
SELECT x, CAST(x AS testdomain) FROM x ORDER BY 2 NULLS LAST;
SELECT x, CAST(x AS testdomain_sv) FROM x ORDER BY 2 NULLS LAST;
SELECT MIN(x), MAX(x) FROM x;
SELECT MIN(x), MAX(x) FROM x;
SELECT MIN(x), MAX(x) FROM x;
SELECT ARRAY_AGG(x ORDER BY x NULLS LAST) FROM x;
SELECT ARRAY_AGG(x ORDER BY x NULLS LAST) FROM x;
SELECT ARRAY_AGG(x ORDER BY x NULLS LAST) FROM x;
SELECT x, x FROM x UNION ALL SELECT x, x FROM x ORDER BY 2 NULLS LAST;
SELECT x, x FROM x UNION SELECT x, x FROM x ORDER BY 2 NULLS LAST;
SELECT x, x FROM x WHERE x < 4 INTERSECT SELECT x, x FROM x WHERE x > 1 ORDER BY 2 NULLS LAST;
SELECT x, x FROM x EXCEPT SELECT x, x FROM x WHERE x < 2 ORDER BY 2 NULLS LAST;
SELECT x, x FROM x UNION ALL SELECT x, x FROM x ORDER BY 2 NULLS LAST;
/* fail */ SELECT x, x FROM x UNION ALL SELECT x, x FROM x;
/* ok */ SELECT x, x FROM x UNION SELECT x, x FROM x ORDER BY 2 NULLS LAST;
/* fail */ SELECT x, x COLLATE "x" FROM x UNION SELECT x, x FROM x ORDER BY 2 NULLS LAST;
/* ok */ SELECT x, x FROM x INTERSECT SELECT x, x FROM x ORDER BY 2 NULLS LAST;
/* fail */ SELECT x, x FROM x EXCEPT SELECT x, x FROM x ORDER BY 2 NULLS LAST;
/* fail */ CREATE TABLE x AS SELECT x, x FROM x UNION ALL SELECT x, x FROM x;
/* fail */ /* collation mismatch between recursive and non-recursive term */ WITH RECURSIVE x AS (SELECT x FROM (VALUES ('a' COLLATE "x"), ('b')) AS x UNION ALL SELECT (x || 'c') COLLATE "x" FROM x WHERE LENGTH(x) < 10) SELECT * FROM x;
SELECT x, CAST(x AS VARCHAR) FROM x ORDER BY 2 NULLS LAST;
SELECT x, CAST(x AS VARCHAR) FROM x ORDER BY 2 NULLS LAST;
SELECT x, CAST(x AS VARCHAR) FROM x ORDER BY 2 NULLS LAST;
/* propagation of collation in SQL functions (inlined and non-inlined cases) */ /* and plpgsql functions too */ CREATE FUNCTION x(x, x) RETURNS BOOLEAN LANGUAGE sql AS $$ select $1 < $2 $$;
CREATE FUNCTION x(x, x) RETURNS BOOLEAN LANGUAGE sql AS $$ select $1 < $2 limit 1 $$;
SELECT x.x AS x, x.x AS x, x.x < x.x AS x, MYLT(x.x, x.x), MYLT_NONINLINE(x.x, x.x), MYLT_PLPGSQL(x.x, x.x) FROM x AS x, x AS x ORDER BY x.x NULLS LAST, x.x NULLS LAST;
SELECT x.x AS x, x.x AS x, x.x < x.x COLLATE "x" AS x, MYLT(x.x, x.x COLLATE "x"), MYLT_NONINLINE(x.x, x.x COLLATE "x"), MYLT_PLPGSQL(x.x, x.x COLLATE "x") FROM x AS x, x AS x ORDER BY x.x NULLS LAST, x.x NULLS LAST;
BEGIN return xx < yy;
SELECT MYLT2('a', 'B' COLLATE "x") AS x, MYLT2('a', 'B' COLLATE "x") AS x;
BEGIN return xx < yy;
SELECT MYLT2('a', 'B') AS x;
SELECT MYLT2('a', 'B' COLLATE "x") AS x;
/* conflicting collations */ SELECT MYLT2('a', 'B' COLLATE "x") AS x;
/* polymorphism */ SELECT * FROM UNNEST((SELECT ARRAY_AGG(x ORDER BY x NULLS LAST) FROM x)) ORDER BY 1 NULLS LAST;
SELECT * FROM UNNEST((SELECT ARRAY_AGG(x ORDER BY x NULLS LAST) FROM x)) ORDER BY 1 NULLS LAST;
SELECT * FROM UNNEST((SELECT ARRAY_AGG(x ORDER BY x NULLS LAST) FROM x)) ORDER BY 1 NULLS LAST;
CREATE FUNCTION x(x) RETURNS anyelement LANGUAGE sql AS 'select $1';
SELECT x, DUP(x) FROM x ORDER BY 2 NULLS LAST;
SELECT x, DUP(x) FROM x ORDER BY 2 NULLS LAST;
SELECT x, DUP(x) FROM x ORDER BY 2 NULLS LAST;
/* indexes */ CREATE INDEX x ON x(x NULLS LAST);
CREATE INDEX x ON x(x COLLATE "x" NULLS LAST);
CREATE INDEX x ON x((x COLLATE "x") NULLS LAST);
/* this is different grammatically */ CREATE INDEX x ON x(((x || 'foo') COLLATE "x") NULLS LAST);
CREATE INDEX x ON x(x COLLATE "x" NULLS LAST);
/* fail */ CREATE INDEX x ON x((x COLLATE "x") NULLS LAST);
/* fail */ SELECT x, PG_GET_INDEXDEF(x) FROM x WHERE x LIKE 'collate_test%_idx%' ORDER BY 1 NULLS LAST;
/* schema manipulation commands */ CREATE ROLE regress_test_role;
CREATE SCHEMA x.x;
CREATE COLLATION test0 FROM "C";
/* fail, duplicate name */ CREATE COLLATION IF NOT EXISTS test0 FROM "C";
/* ok, skipped */ CREATE COLLATION IF NOT EXISTS test0 (locale = 'foo');
CREATE COLLATION test3 (lc_collate = 'en_US.utf8');
/* fail, need lc_ctype */ CREATE COLLATION testx (locale = 'nonsense');
/* fail */ CREATE COLLATION test4 FROM nonsense;
CREATE COLLATION test5 FROM test0;
SELECT x FROM x WHERE x LIKE 'test%' ORDER BY 1 NULLS LAST;
ALTER COLLATION test1 RENAME TO test11;
ALTER COLLATION test0 RENAME TO test11;
/* fail */ ALTER COLLATION test1 RENAME TO test22;
/* fail */ ALTER COLLATION test11 OWNER TO regress_test_role;
ALTER COLLATION test11 OWNER TO nonsense;
ALTER COLLATION test11 SET SCHEMA test_schema;
COMMENT ON COLLATION test0 IS 'US English';
SELECT x, x, OBJ_DESCRIPTION(x.x, 'pg_collation') FROM x JOIN x ON (x = x.x) WHERE x LIKE 'test%' ORDER BY 1 NULLS LAST;
DROP COLLATION test0, test_schema.test11, test5;
DROP COLLATION test0;
/* fail */ DROP COLLATION IF EXISTS test0;
SELECT x FROM x WHERE x LIKE 'test%';
DROP SCHEMA x.x;
DROP ROLE regress_test_role;
/* ALTER */ ALTER COLLATION "en_US" REFRESH VERSION;
/* dependencies */ CREATE COLLATION test0 FROM "C";
CREATE TABLE x (x INT, x TEXT COLLATE x);
CREATE DOMAIN collate_dep_dom1 AS text COLLATE test0;
CREATE TYPE collate_dep_test2 AS (x int, y text COLLATE test0);
CREATE VIEW x AS SELECT CAST('foo' AS TEXT) COLLATE test0 AS x;
CREATE TABLE x (x INT, x TEXT);
CREATE INDEX x ON x(x COLLATE test0 NULLS LAST);
DROP COLLATION test0 RESTRICT;
/* fail */ DROP COLLATION test0 CASCADE;
DROP TYPE collate_dep_test2;
/* test range types and collations */ create type textrange_c as range(subtype=text, collation="C");
create type textrange_en_us as range(subtype=text, collation="en_US");
SELECT TEXTRANGE_C('A', 'Z') @> CAST('b' AS TEXT);
SELECT TEXTRANGE_EN_US('A', 'Z') @> CAST('b' AS TEXT);
drop type textrange_c;
drop type textrange_en_us;
CREATE COLLATION ctest_nondet (locale = 'en_US', deterministic = false);
SET x = warning /* cleanup */;
DROP SCHEMA x.x CASCADE;
/* Tests for some likely failure cases with combo cmin/cmax mechanism */ CREATE TEMPORARY TABLE x (x INT);
BEGIN;
/* a few dummy ops to push up the CommandId counter */ INSERT INTO x SELECT 1 LIMIT 0;
INSERT INTO x SELECT 1 LIMIT 0;
INSERT INTO x SELECT 1 LIMIT 0;
INSERT INTO x SELECT 1 LIMIT 0;
INSERT INTO x SELECT 1 LIMIT 0;
INSERT INTO x SELECT 1 LIMIT 0;
INSERT INTO x SELECT 1 LIMIT 0;
INSERT INTO x SELECT 1 LIMIT 0;
INSERT INTO x SELECT 1 LIMIT 0;
INSERT INTO x SELECT 1 LIMIT 0;
INSERT INTO x VALUES (1);
INSERT INTO x VALUES (2);
SELECT x, x, * FROM x;
x AS x;
UPDATE x SET x = x + 10;
/* here we should see only updated tuples */ SELECT x, x, * FROM x;
ROLLBACK TO x;
/* now we should see old tuples, but with combo CIDs starting at 0 */ SELECT x, x, * FROM x;
COMMIT;
/* combo data is not there anymore, but should still see tuples */ SELECT x, x, * FROM x;
/* Test combo CIDs with portals */ BEGIN;
INSERT INTO x VALUES (333);
DECLARE c CURSOR FOR SELECT ctid,cmin,* FROM combocidtest;
DELETE FROM x;
FETCH ALL FROM c;
ROLLBACK;
SELECT x, x, * FROM x;
/* check behavior with locked tuples */ BEGIN;
/* a few dummy ops to push up the CommandId counter */ INSERT INTO x SELECT 1 LIMIT 0;
INSERT INTO x SELECT 1 LIMIT 0;
INSERT INTO x SELECT 1 LIMIT 0;
INSERT INTO x SELECT 1 LIMIT 0;
INSERT INTO x SELECT 1 LIMIT 0;
INSERT INTO x SELECT 1 LIMIT 0;
INSERT INTO x SELECT 1 LIMIT 0;
INSERT INTO x SELECT 1 LIMIT 0;
INSERT INTO x SELECT 1 LIMIT 0;
INSERT INTO x SELECT 1 LIMIT 0;
INSERT INTO x VALUES (444);
SELECT x, x, * FROM x;
x AS x;
/* this doesn't affect cmin */ SELECT x, x, * FROM x;
SELECT x, x, * FROM x;
/* but this does */ UPDATE x SET x = x + 10;
SELECT x, x, * FROM x;
ROLLBACK TO x;
SELECT x, x, * FROM x;
COMMIT;
SELECT x, x, * FROM x;
/* test for bug reported in */ /* CABRT9RC81YUf1=jsmWopcKJEro=VoeG2ou6sPwyOUTx_qteRsg@mail.gmail.com */ CREATE TABLE IF NOT EXISTS x (x INT PRIMARY KEY, x DECIMAL);
INSERT INTO x VALUES (1, 0);
BEGIN;
SELECT * FROM x WHERE x.x = 1;
UPDATE x SET x = x + 400 WHERE x = 1;
x AS x;
UPDATE x SET x = x - 100 WHERE x = 1;
ROLLBACK TO x;
/* should return one tuple */ SELECT * FROM x WHERE x = 1;
ROLLBACK;
DROP TABLE x;
/* COMMENTS */ SELECT 'trailing' AS x;
/* trailing single line */ /* embedded single line */ SELECT 'embedded' AS x;
/* both embedded and trailing single line */ SELECT 'both' AS x;
/* trailing single line */ SELECT 'before multi-line' AS x;
CREATE INDEX x ON x(x NULLS LAST);
INSERT INTO x VALUES (REPEAT('1234567890', 1000));
INSERT INTO x VALUES (REPEAT('1234567890', 1004));
SELECT PG_COLUMN_COMPRESSION(x) FROM x;
/* decompress data slice */ SELECT SUBSTRING(x, 200, 5) FROM x;
SELECT SUBSTRING(x, 2000, 50) FROM x;
/* copy with table creation */ CREATE TABLE x AS SELECT * FROM x;
INSERT INTO x SELECT * FROM x;
INSERT INTO x SELECT * FROM x;
SELECT PG_COLUMN_COMPRESSION(x) FROM x;
/* test LIKE INCLUDING COMPRESSION */ CREATE TABLE x (LIKE x INCLUDING COMPRESSION);
INSERT INTO x VALUES (REPEAT('1234567890', 1004));
SELECT PG_COLUMN_COMPRESSION(x) FROM x;
UPDATE x SET x = x.x FROM x;
SELECT PG_COLUMN_COMPRESSION(x) FROM x;
/* test externally stored compressed data */ CREATE OR REPLACE FUNCTION x() RETURNS TEXT LANGUAGE SQL AS 'select array_agg(fipshash(g::text))::text from generate_series(1, 256) g';
INSERT INTO x SELECT LARGE_VAL() || REPEAT('a', 4000);
SELECT PG_COLUMN_COMPRESSION(x) FROM x;
INSERT INTO x SELECT LARGE_VAL() || REPEAT('a', 4000);
SELECT PG_COLUMN_COMPRESSION(x) FROM x;
SELECT SUBSTRING(x, 200, 5) FROM x;
SELECT SUBSTRING(x, 200, 5) FROM x;
DROP TABLE x;
/* test column type update varlena/non-varlena */ CREATE TABLE x (x INT);
ALTER TABLE x ALTER COLUMN x DROP DEFAULT, SET COMPRESSION pglz;
SELECT PG_COLUMN_COMPRESSION(x) FROM x;
/* test compression with materialized view */ CREATE MATERIALIZED VIEW x (x) AS SELECT * FROM x;
SELECT PG_COLUMN_COMPRESSION(x) FROM x;
CREATE TABLE x PARTITION OF x FOR VALUES WITH (MODULUS 2, REMAINDER 0);
ALTER TABLE cmpart ATTACH PARTITION cmpart2 FOR VALUES WITH (MODULUS 2, REMAINDER 1);
INSERT INTO x VALUES (REPEAT('123456789', 1004));
INSERT INTO x VALUES (REPEAT('123456789', 4004));
SELECT PG_COLUMN_COMPRESSION(x) FROM x;
SELECT PG_COLUMN_COMPRESSION(x) FROM x;
/* test compression with inheritance */ CREATE TABLE x INHERITS (x, x);
/* error */ CREATE TABLE x (x TEXT);
CREATE TABLE x INHERITS (x, x);
SET x = '' /* test default_toast_compression GUC */;
SET x = 'I do not exist compression';
SET x = 'lz4';
SET x = 'pglz';
ALTER TABLE x ALTER COLUMN x DROP DEFAULT, SET COMPRESSION lz4 /* test alter compression method */;
INSERT INTO x VALUES (REPEAT('123456789', 4004));
ALTER TABLE x ALTER COLUMN x DROP DEFAULT, SET COMPRESSION default;
ALTER TABLE x ALTER COLUMN x DROP DEFAULT, SET COMPRESSION lz4;
/* new data should be compressed with the current compression method */ INSERT INTO x VALUES (REPEAT('123456789', 1004));
INSERT INTO x VALUES (REPEAT('123456789', 4004));
SELECT PG_COLUMN_COMPRESSION(x) FROM x;
SELECT PG_COLUMN_COMPRESSION(x) FROM x;
/* VACUUM FULL does not recompress */ SELECT PG_COLUMN_COMPRESSION(x) FROM x;
VACUUM FULL cmdata;
SELECT PG_COLUMN_COMPRESSION(x) FROM x;
/* test expression index */ DROP TABLE x;
CREATE UNIQUE INDEX x ON x((x || x) NULLS LAST);
INSERT INTO x VALUES ((SELECT CAST(ARRAY_AGG(FIPSHASH(CAST(x AS TEXT))) AS TEXT) FROM x AS x), VERSION());
/* check data is ok */ SELECT LENGTH(x) FROM x;
SELECT LENGTH(x) FROM x;
SELECT LENGTH(x) FROM x;
SELECT LENGTH(x) FROM x;
SELECT LENGTH(x) FROM x;
/* fails */ CREATE TABLE x (x TEXT);
ALTER TABLE x ALTER COLUMN x DROP DEFAULT, SET COMPRESSION I_Do_Not_Exist_Compression;
/* fails */ DROP TABLE x;
INSERT INTO x VALUES (1, 'thomas', 57.0613);
INSERT INTO x VALUES (1, 'bruce');
INSERT INTO x (x, x) VALUES (2, 987.654);
INSERT INTO x (x) VALUES ('marc');
INSERT INTO x VALUES (3, NULL, 1.0);
SELECT * FROM x;
CREATE SEQUENCE x;
CREATE TABLE x (x INT DEFAULT 100 + (200 - 199) * 2, x INT DEFAULT NEXTVAL('default_seq'));
INSERT INTO x VALUES (-1, -2);
INSERT INTO x (x) VALUES (-3);
INSERT INTO x (x) VALUES (-4);
INSERT INTO x (x) VALUES (NULL);
SELECT * FROM x;
/* syntax errors */ /*  test for extraneous comma */ CREATE TABLE x (x INT DEFAULT (100));
/*  this should work, however: */ CREATE TABLE x (x BOOLEAN DEFAULT (1 IN (1, 2)));
DROP TABLE x;
/* CHECK syntax */ CREATE TABLE x (x INT, CONSTRAINT x CHECK (x > 3));
INSERT INTO x VALUES (5);
INSERT INTO x VALUES (4);
INSERT INTO x VALUES (3);
INSERT INTO x VALUES (2);
INSERT INTO x VALUES (6);
INSERT INTO x VALUES (1);
SELECT * FROM x;
INSERT INTO x VALUES (5);
INSERT INTO x VALUES (4);
INSERT INTO x VALUES (3);
INSERT INTO x VALUES (2);
INSERT INTO x VALUES (6);
INSERT INTO x VALUES (1);
SELECT * FROM x;
CREATE SEQUENCE x;
CREATE TABLE x (x INT, x TEXT, x INT, CONSTRAINT x CHECK (x > 3 AND x <> 'check failed' AND x < 8));
INSERT INTO x VALUES (4, 'check ok', -2);
INSERT INTO x VALUES (1, 'x check failed', -2);
INSERT INTO x VALUES (5, 'z check failed', 10);
INSERT INTO x VALUES (0, 'check failed', -2);
INSERT INTO x VALUES (6, 'check failed', 11);
INSERT INTO x VALUES (7, 'check ok', 7);
SELECT * FROM x;
/* Check constraints on INSERT */ CREATE SEQUENCE x;
INSERT INTO x (x, x) VALUES (2, -2);
SELECT * FROM x;
SELECT 'one' AS x, NEXTVAL('insert_seq');
INSERT INTO x (x) VALUES ('Y');
INSERT INTO x (x) VALUES ('Y');
INSERT INTO x (x, x) VALUES (1, -2);
INSERT INTO x (x, x) VALUES (-7, 7);
INSERT INTO x VALUES (5, 'check failed', -5);
INSERT INTO x VALUES (7, '!check failed', -7);
INSERT INTO x (x) VALUES ('-!NULL-');
SELECT * FROM x;
INSERT INTO x (x, x) VALUES ('check failed', 4);
INSERT INTO x (x, x) VALUES (5, 'check failed');
INSERT INTO x (x, x) VALUES (5, '!check failed');
INSERT INTO x (x) VALUES ('-!NULL-');
SELECT * FROM x;
SELECT 'seven' AS x, NEXTVAL('insert_seq');
INSERT INTO x (x) VALUES ('Y');
SELECT 'eight' AS x, CURRVAL('insert_seq');
/* According to SQL, it is OK to insert a record that gives rise to NULL */ /* constraint-condition results.  Postgres used to reject this, but it */ /* was wrong: */ INSERT INTO x VALUES (NULL, NULL, NULL);
SELECT * FROM x;
/* Check constraints on system columns */ CREATE TABLE x (x TEXT, x TEXT, x BOOLEAN, x INT, CHECK (NOT (x AND CAST(CAST(x AS REGCLASS) AS TEXT) = 'sys_col_check_tbl')));
INSERT INTO x VALUES ('Seattle', 'Washington', FALSE, 100);
INSERT INTO x VALUES ('Olympia', 'Washington', TRUE, 100);
SELECT *, CAST(CAST(x AS REGCLASS) AS TEXT) FROM x;
DROP TABLE x;
/* Check constraints on system columns other then TableOid should return error */ CREATE TABLE x (x TEXT, x TEXT, x BOOLEAN, x INT, CHECK (NOT (x AND CAST(x AS TEXT) = 'sys_col_check_tbl')));
/* Check inheritance of defaults and constraints */ CREATE TABLE x (x INT DEFAULT 42, x INT CHECK (x > x)) INHERITS (x);
INSERT INTO x (x, x, x) VALUES (7, -7, 11);
INSERT INTO x (x, x, x) VALUES (7, -7, 6);
INSERT INTO x (x, x, x) VALUES (6, -7, 7);
INSERT INTO x (x, x, x, x) VALUES (6, 'check failed', -6, 7);
SELECT * FROM x;
DROP TABLE x;
CREATE TABLE x (x INT) INHERITS (x);
/* check constraint is not there on child */ INSERT INTO x (x) VALUES (-3);
/* check constraint is there on parent */ INSERT INTO x (x) VALUES (-3);
DROP TABLE x CASCADE;
CREATE TABLE x INHERITS (x);
/* check constraint is there on child */ INSERT INTO x (x) VALUES (-3);
/* check constraint is there on parent */ INSERT INTO x (x) VALUES (-3);
/* check constraint is not there on child */ INSERT INTO x (x) VALUES (3);
/* check constraint is there on parent */ INSERT INTO x (x) VALUES (3);
DROP TABLE x CASCADE;
/* Check constraints on INSERT INTO */ DELETE FROM x;
ALTER SEQUENCE INSERT_SEQ RESTART WITH 4;
CREATE TEMPORARY TABLE x (x INT, x TEXT, x INT);
INSERT INTO x VALUES (NULL, 'Y', NULL);
INSERT INTO x VALUES (5, '!check failed', NULL);
INSERT INTO x VALUES (NULL, 'try again', NULL);
INSERT INTO x (x) SELECT x FROM x;
SELECT * FROM x;
INSERT INTO x SELECT * FROM x WHERE x = 'try again';
INSERT INTO x (x, x) SELECT x, -7 FROM x WHERE x = 'try again';
INSERT INTO x (x, x) SELECT x, -8 FROM x WHERE x = 'try again';
SELECT * FROM x;
DROP TABLE x;
/* Check constraints on UPDATE */ UPDATE x SET x = NULL WHERE x = 5;
UPDATE x SET x = 6 WHERE x = 6;
UPDATE x SET x = -x, x = -x;
UPDATE x SET x = x, x = x;
SELECT * FROM x;
/* Check constraints on COPY FROM */ CREATE TABLE x (x INT, x TEXT, x INT, CONSTRAINT x CHECK (x > 3 AND x <> 'check failed' AND x < 7));
SELECT * FROM x;
SELECT * FROM x;
/* Primary keys */ CREATE TABLE x (x INT PRIMARY KEY, x TEXT);
INSERT INTO x VALUES (1, 'one');
INSERT INTO x VALUES (2, 'two');
INSERT INTO x VALUES (1, 'three');
INSERT INTO x VALUES (4, 'three');
INSERT INTO x VALUES (5, 'one');
INSERT INTO x (x) VALUES ('six');
SELECT * FROM x;
DROP TABLE x;
CREATE TABLE x (x INT, x TEXT, PRIMARY KEY (x NULLS LAST, x NULLS LAST));
INSERT INTO x VALUES (1, 'one');
INSERT INTO x VALUES (2, 'two');
INSERT INTO x VALUES (1, 'three');
INSERT INTO x VALUES (4, 'three');
INSERT INTO x VALUES (5, 'one');
INSERT INTO x (x) VALUES ('six');
SELECT * FROM x;
DROP TABLE x;
/* Unique keys */ CREATE TABLE x (x INT UNIQUE, x TEXT);
INSERT INTO x VALUES (1, 'one');
INSERT INTO x VALUES (2, 'two');
INSERT INTO x VALUES (1, 'three');
INSERT INTO x VALUES (4, 'four');
INSERT INTO x VALUES (5, 'one');
INSERT INTO x (x) VALUES ('six');
INSERT INTO x (x) VALUES ('seven');
INSERT INTO x VALUES (5, 'five-upsert-insert') ON CONFLICT(x) DO UPDATE SET x = 'five-upsert-update';
INSERT INTO x VALUES (6, 'six-upsert-insert') ON CONFLICT(x) DO UPDATE SET x = 'six-upsert-update';
/* should fail */ INSERT INTO x VALUES (1, 'a'), (2, 'b'), (2, 'b') ON CONFLICT(x) DO UPDATE SET x = 'fails';
SELECT * FROM x;
DROP TABLE x;
CREATE TABLE x (x INT UNIQUE NULLS NOT DISTINCT, x TEXT);
INSERT INTO x VALUES (1, 'one');
INSERT INTO x VALUES (2, 'two');
INSERT INTO x VALUES (1, 'three');
/* fail */ INSERT INTO x VALUES (4, 'four');
INSERT INTO x VALUES (5, 'one');
INSERT INTO x (x) VALUES ('six');
INSERT INTO x (x) VALUES ('seven');
/* fail */ INSERT INTO x (x) VALUES ('eight') ON CONFLICT DO NOTHING;
/* no-op */ SELECT * FROM x;
DROP TABLE x;
CREATE TABLE x (x INT, x TEXT, UNIQUE (x, x));
INSERT INTO x VALUES (1, 'one');
INSERT INTO x VALUES (2, 'two');
INSERT INTO x VALUES (1, 'three');
INSERT INTO x VALUES (1, 'one');
INSERT INTO x VALUES (5, 'one');
INSERT INTO x (x) VALUES ('six');
SELECT * FROM x;
DROP TABLE x;
INSERT INTO x VALUES (0, 'one');
INSERT INTO x VALUES (1, 'two');
INSERT INTO x VALUES (2, 'tree');
INSERT INTO x VALUES (3, 'four');
INSERT INTO x VALUES (4, 'five');
BEGIN;
/* default is immediate so this should fail right away */ UPDATE x SET x = 1 WHERE x = 0;
ROLLBACK;
/* check is done at end of statement, so this should succeed */ UPDATE x SET x = x + 1;
SELECT * FROM x;
/* explicitly defer the constraint */ BEGIN;
SET CONSTRAINTS unique_tbl_i_key DEFERRED;
INSERT INTO x VALUES (3, 'three');
DELETE FROM x WHERE x = 'tree';
COMMIT /* makes constraint valid again */ /* makes constraint valid again */;
/* should succeed */ SELECT * FROM x;
ALTER TABLE x DROP CONSTRAINT x /* try adding an initially deferred constraint */;
ALTER TABLE unique_tbl ADD CONSTRAINT unique_tbl_i_key 	UNIQUE (i) DEFERRABLE INITIALLY DEFERRED;
BEGIN;
INSERT INTO x VALUES (1, 'five');
INSERT INTO x VALUES (5, 'one');
UPDATE x SET x = 4 WHERE x = 2;
UPDATE x SET x = 2 WHERE x = 4 AND x = 'four';
DELETE FROM x WHERE x = 1 AND x = 'one';
DELETE FROM x WHERE x = 5 AND x = 'five';
COMMIT;
SELECT * FROM x;
/* should fail at commit-time */ BEGIN;
INSERT INTO x VALUES (3, 'Three');
COMMIT /* should succeed for now */ /* should succeed for now */;
/* should fail */ /* make constraint check immediate */ BEGIN;
SET CONSTRAINTS ALL IMMEDIATE;
INSERT INTO x VALUES (3, 'Three');
COMMIT /* should fail */ /* should fail */;
/* forced check when SET CONSTRAINTS is called */ BEGIN;
SET CONSTRAINTS ALL DEFERRED;
INSERT INTO x VALUES (3, 'Three');
/* should succeed for now */ SET CONSTRAINTS ALL IMMEDIATE;
COMMIT /* should fail */ /* should fail */;
CREATE TABLE x PARTITION OF x FOR VALUES FROM (0) TO (10);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (20) TO (30);
SELECT x, CAST(x AS REGCLASS) FROM x WHERE x LIKE 'parted_uniq%' ORDER BY x NULLS LAST;
BEGIN;
INSERT INTO x VALUES (1);
x AS x;
INSERT INTO x VALUES (1);
ROLLBACK TO x /* unique violation */;
SET CONSTRAINTS parted_uniq_tbl_i_key DEFERRED;
INSERT INTO x VALUES (1);
COMMIT /* OK now, fail at commit */ /* OK now, fail at commit */;
DROP TABLE x;
/* test naming a constraint in a partition when a conflict exists */ CREATE TABLE x (x BIGINT NOT NULL DEFAULT 1, x BIGINT, CONSTRAINT x FOREIGN KEY (x) REFERENCES x (x), PRIMARY KEY (x NULLS LAST)) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x (x BIGINT NOT NULL DEFAULT 1, x BIGINT, PRIMARY KEY (x NULLS LAST), CONSTRAINT x CHECK (TRUE));
ALTER TABLE parted_fk_naming ATTACH PARTITION parted_fk_naming_1 FOR VALUES IN ('1');
SELECT x FROM x WHERE x = CAST('parted_fk_naming_1' AS REGCLASS) AND x = 'f';
DROP TABLE x;
/* Test various ways to create primary keys on partitions, linked to unique */ /* indexes (without constraints) on the partitioned table.  Ideally these should */ /* fail, but we don't dare change released behavior, so instead cope with it at */ /* DETACH time. */ CREATE TEMPORARY TABLE x (x INT, x INT) WITH (PARTITIONED_BY=HASH(x, x));
CREATE TEMPORARY TABLE x (x INT, x INT, PRIMARY KEY (x NULLS LAST, x NULLS LAST), UNIQUE (x, x));
ALTER TABLE t ATTACH PARTITION tp FOR VALUES WITH (MODULUS 1, REMAINDER 0);
CREATE UNIQUE INDEX x ON x(x NULLS LAST, x NULLS LAST);
CREATE UNIQUE INDEX x ON x(x NULLS LAST, x NULLS LAST);
ALTER INDEX t_a_idx ATTACH PARTITION tp_pkey;
ALTER INDEX t_b_idx ATTACH PARTITION tp_b_a_key;
SELECT x, x, x, x FROM x WHERE x IN ('tp_pkey', 'tp_b_a_key') ORDER BY x DESC NULLS FIRST;
ALTER TABLE t DETACH PARTITION tp;
CREATE TEMPORARY TABLE x (x INT) WITH (PARTITIONED_BY=LIST(x));
CREATE TEMPORARY TABLE x (x INT PRIMARY KEY);
CREATE UNIQUE INDEX x ON x(x NULLS LAST);
ALTER TABLE t ATTACH PARTITION tp FOR VALUES IN (1);
ALTER TABLE t DETACH PARTITION tp;
CREATE TEMPORARY TABLE x (x INT) WITH (PARTITIONED_BY=LIST(x));
CREATE TEMPORARY TABLE x (x INT PRIMARY KEY);
ALTER TABLE t ATTACH PARTITION tp FOR VALUES IN (1);
ALTER TABLE t DETACH PARTITION tp;
CREATE TABLE x (x INT) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN (1);
ALTER TABLE x ADD PRIMARY KEY (x NULLS LAST);
CREATE UNIQUE INDEX ON x(x NULLS LAST);
BEGIN;
ALTER TABLE regress_constr_partitioned DETACH PARTITION regress_constr_partition1;
ROLLBACK;
/*  Leave this one in funny state for pg_upgrade testing */ /* test a HOT update that invalidates the conflicting tuple. */ /* the trigger should still fire and catch the violation */ BEGIN;
INSERT INTO x VALUES (3, 'Three');
/* should succeed for now */ UPDATE x SET x = 'THREE' WHERE x = 3 AND x = 'Three';
COMMIT;
/* should fail */ SELECT * FROM x;
/* test a HOT update that modifies the newly inserted tuple, */ /* but should succeed because we then remove the other conflicting tuple. */ BEGIN;
INSERT INTO x VALUES (3, 'tree');
/* should succeed for now */ UPDATE x SET x = 'threex' WHERE x = 'tree';
DELETE FROM x WHERE x = 'three';
SELECT * FROM x;
COMMIT;
SELECT * FROM x;
ALTER TABLE unique_tbl ALTER CONSTRAINT unique_tbl_i_key ENFORCED;
ALTER TABLE unique_tbl ALTER CONSTRAINT unique_tbl_i_key NOT ENFORCED;
DROP TABLE x;
/* EXCLUDE constraints */ CREATE TABLE x (x CIRCLE, x TEXT, EXCLUDE USING gist(x NULLS LAST WITH &&, (CAST(x AS circle)) NULLS LAST WITH &&) WHERE (CIRCLE_CENTER(x) <> '(0,0)'));
/* these should succeed because they don't match the index predicate */ INSERT INTO x VALUES ('<(0,0), 5>', '<(0,0), 5>');
INSERT INTO x VALUES ('<(0,0), 5>', '<(0,0), 4>');
/* succeed */ INSERT INTO x VALUES ('<(10,10), 10>', '<(0,0), 5>');
/* fail, overlaps */ INSERT INTO x VALUES ('<(20,20), 10>', '<(0,0), 4>');
/* succeed, because violation is ignored */ INSERT INTO x VALUES ('<(20,20), 10>', '<(0,0), 4>') ON CONFLICT ON CONSTRAINT x DO NOTHING;
/* fail, because DO UPDATE variant requires unique index */ INSERT INTO x VALUES ('<(20,20), 10>', '<(0,0), 4>') ON CONFLICT ON CONSTRAINT x DO UPDATE SET x = x.x;
/* succeed because c1 doesn't overlap */ INSERT INTO x VALUES ('<(20,20), 1>', '<(0,0), 5>');
/* succeed because c2 doesn't overlap */ INSERT INTO x VALUES ('<(20,20), 10>', '<(10,10), 5>');
/* try reindexing an existing constraint */ REINDEX INDEX circles_c1_c2_excl;
DROP TABLE x;
INSERT INTO x VALUES (1);
INSERT INTO x VALUES (2);
INSERT INTO x VALUES (1);
/* fail */ INSERT INTO x VALUES (1) ON CONFLICT ON CONSTRAINT x DO NOTHING;
/* fail */ BEGIN;
INSERT INTO x VALUES (2);
COMMIT /* no fail here */ /* no fail here */;
/* should fail here */ BEGIN;
INSERT INTO x VALUES (3);
INSERT INTO x VALUES (3);
COMMIT /* no fail here */ /* no fail here */;
/* should fail here */ /* bug #13148: deferred constraint versus HOT update */ BEGIN;
INSERT INTO x VALUES (2, 1);
/* no fail here */ DELETE FROM x WHERE x = 2 AND x IS NULL;
/* remove old row */ UPDATE x SET x = 2 WHERE x = 2;
COMMIT;
/* should not fail */ SELECT * FROM x;
ALTER TABLE x DROP CONSTRAINT x;
/* This should fail, but worth testing because of HOT updates */ UPDATE x SET x = 3;
DROP TABLE x;
/* verify constraints created for NOT NULL clauses */ CREATE TABLE x (x INT NOT NULL NOT NULL);
ALTER TABLE x ALTER COLUMN x DROP NOT NULL /* DROP NOT NULL gets rid of both the attnotnull flag and the constraint itself */;
SELECT x, x, x FROM x WHERE x = CAST('notnull_tbl1' AS REGCLASS);
ALTER TABLE x ALTER COLUMN x DROP NOT NULL /* Using the "table constraint" syntax also works */;
ALTER TABLE notnull_tbl1 ADD CONSTRAINT foobar NOT NULL a;
/* Verify that constraint names and NO INHERIT are properly considered when */ /* multiple constraint are specified, either explicitly or via SERIAL/PK/etc, */ /* and that conflicting cases are rejected.  Mind that table constraints */ /* handle this separately from column constraints. */ CREATE TABLE x (x INT PRIMARY KEY CONSTRAINT x NOT NULL);
/* error cases: */ CREATE TABLE x (x SERIAL CONSTRAINT x NOT NULL CONSTRAINT x NOT NULL);
DROP TABLE x;
CREATE TABLE x INHERITS (x);
CREATE TABLE x (x INT);
CREATE TABLE x INHERITS (x);
CREATE TABLE x (x INT);
CREATE TABLE x INHERITS (x);
CREATE TABLE x (x INT);
CREATE TABLE x (x INT) INHERITS (x);
ALTER TABLE ATACC2 INHERIT ATACC1;
/* can't override */ ALTER TABLE ATACC1 ADD CONSTRAINT ditto NOT NULL a;
ALTER TABLE x DROP CONSTRAINT x /* dropping the NO INHERIT constraint allows this to work */;
ALTER TABLE ATACC1 ADD CONSTRAINT ditto NOT NULL a;
/* Can't have two constraints with the same name */ CREATE TABLE x (x INT CONSTRAINT x NOT NULL, x INT CONSTRAINT x NOT NULL);
/* can't drop not-null in primary key */ CREATE TABLE x (x INT PRIMARY KEY);
ALTER TABLE x ALTER COLUMN x DROP NOT NULL;
DROP TABLE x;
CREATE TABLE x (x INT NOT NULL, CHECK (NOT x IS NULL));
ALTER TABLE x ALTER COLUMN x DROP NOT NULL;
ALTER TABLE x ADD COLUMN x INT, ADD COLUMN x pk PRIMARY KEY (x NULLS LAST, x NULLS LAST);
CREATE TABLE x INHERITS (x);
ALTER TABLE x ADD CONSTRAINT x PRIMARY KEY (x NULLS LAST);
/* As above, but create the primary key ahead of time */ CREATE TABLE x (x INT, x INT, CONSTRAINT x PRIMARY KEY (x NULLS LAST));
CREATE TABLE x INHERITS (x);
/* As above, but create the primary key using a UNIQUE index */ CREATE TABLE x (x INT, x INT);
CREATE UNIQUE INDEX x ON x(x NULLS LAST);
CREATE TABLE x INHERITS (x);
ALTER TABLE cnn_pk ADD CONSTRAINT cnn_primarykey PRIMARY KEY USING INDEX cnn_uq;
/* Unique constraints don't give raise to not-null constraints, however. */ CREATE TABLE x (x INT);
ALTER TABLE x ADD UNIQUE (x);
CREATE TABLE x (x INT);
CREATE UNIQUE INDEX x ON x(x NULLS LAST);
alter table cnn_uq add unique using index cnn_uq_idx;
CREATE TABLE x PARTITION OF x FOR VALUES IN (1, NULL);
INSERT INTO x VALUES (NULL);
ALTER TABLE x ADD PRIMARY KEY (x NULLS LAST);
DROP TABLE x;
CREATE TABLE x (LIKE x);
CREATE TABLE x (LIKE x INCLUDING INDEXES);
ALTER TABLE notnull_tbl4_lk3 RENAME CONSTRAINT notnull_tbl4_a_not_null TO a_nn;
CREATE TABLE x INHERITS (x);
CREATE TABLE x (PRIMARY KEY (x NULLS LAST) DEFERRABLE) INHERITS (x);
CREATE TABLE x INHERITS (x);
ALTER TABLE ONLY x DROP CONSTRAINT x;
ALTER TABLE ONLY x ALTER COLUMN x DROP NOT NULL;
CREATE TABLE x PARTITION OF x FOR VALUES IN (1);
ALTER TABLE ONLY x DROP CONSTRAINT x;
ALTER TABLE ONLY x ALTER COLUMN x DROP NOT NULL;
SET SESSION AUTHORIZATION regress_constraint_comments;
CREATE TABLE x (x INT CONSTRAINT x CHECK (x > 0));
CREATE DOMAIN constraint_comments_dom AS int CONSTRAINT the_constraint CHECK (value > 0);
/* unauthorized user */ RESET SESSION AUTHORIZATION;
CREATE ROLE regress_constraint_comments_noaccess;
SET SESSION AUTHORIZATION regress_constraint_comments_noaccess;
RESET SESSION AUTHORIZATION;
DROP TABLE x;
DROP DOMAIN constraint_comments_dom;
DROP ROLE regress_constraint_comments;
DROP ROLE regress_constraint_comments_noaccess;
SELECT FROM x;
CREATE USER regress_conversion_user WITH NOCREATEDB NOCREATEROLE;
SET SESSION AUTHORIZATION regress_conversion_user;
CREATE CONVERSION myconv FOR 'LATIN1' TO 'UTF8' FROM iso8859_1_to_utf8;
/* cannot make same name conversion in same schema */ CREATE CONVERSION myconv FOR 'LATIN1' TO 'UTF8' FROM iso8859_1_to_utf8;
/* create default conversion with qualified name */ CREATE DEFAULT CONVERSION public.mydef FOR 'LATIN1' TO 'UTF8' FROM iso8859_1_to_utf8;
/* cannot make default conversion with same schema/for_encoding/to_encoding */ CREATE DEFAULT CONVERSION public.mydef2 FOR 'LATIN1' TO 'UTF8' FROM iso8859_1_to_utf8;
/* test comments */ COMMENT ON CONVERSION myconv_bad IS 'foo';
COMMENT ON CONVERSION myconv IS 'bar';
COMMENT ON CONVERSION myconv IS NULL;
/* drop user defined conversion */ DROP CONVERSION myconv;
DROP CONVERSION mydef;
/* Note: the built-in conversions are exercised in opr_sanity.sql, */ /* so there's no need to do that here. */ /* return to the superuser */ RESET SESSION AUTHORIZATION;
DROP USER regress_conversion_user;
BEGIN -- First try to perform the conversion with noError = false. If that errors out,   -- capture the error message, and try again with noError = true. The second call   -- should succeed and return the position of the error, return that too.   begin     select * into validlen, result from test_enc_conversion(input, src_encoding, dst_encoding, false);
x = NULL;
x := NULL;
x = SUBSTRING(x, x + 1);
COMMIT;
x;
COMMIT;
/* UTF-8 */ /* The description column must be unique. */ CREATE TABLE x (x VARBINARY, x TEXT PRIMARY KEY);
INSERT INTO x VALUES ('\x66006f', 'NUL byte'), ('\xaf', 'bare continuation'), ('\xc5', 'missing second byte in 2-byte char'), ('\xc080', 'smallest 2-byte overlong'), ('\xc1bf', 'largest 2-byte overlong'), ('\xc280', 'next 2-byte after overlongs'), ('\xdfbf', 'largest 2-byte'), ('\xe9af', 'missing third byte in 3-byte char'), ('\xe08080', 'smallest 3-byte overlong'), ('\xe09fbf', 'largest 3-byte overlong'), ('\xe0a080', 'next 3-byte after overlong'), ('\xed9fbf', 'last before surrogates'), ('\xeda080', 'smallest surrogate'), ('\xedbfbf', 'largest surrogate'), ('\xee8080', 'next after surrogates'), ('\xefbfbf', 'largest 3-byte'), ('\xf1afbf', 'missing fourth byte in 4-byte char'), ('\xf0808080', 'smallest 4-byte overlong'), ('\xf08fbfbf', 'largest 4-byte overlong'), ('\xf0908080', 'next 4-byte after overlong'), ('\xf48fbfbf', 'largest 4-byte'), ('\xf4908080', 'smallest too large'), ('\xfa9a9a8a8a', '5-byte');
/* Test UTF-8 verification slow path */ SELECT x, (TEST_CONV(x, 'utf8', 'utf8')).* FROM x;
/* Test UTF-8 verification with ASCII padding appended to provide */ /* coverage for algorithms that work on multiple bytes at a time. */ /* The error message for a sequence starting with a 4-byte lead */ /* will contain all 4 bytes if they are present, so various */ /* expressions below add 3 ASCII bytes to the end to ensure */ /* consistent error messages. */ /* The number 64 below needs to be at least the value of STRIDE_LENGTH in wchar.c. */ /* Test multibyte verification in fast path */ WITH x AS (SELECT x, x, (TEST_CONV(x || CAST(REPEAT('.', 3) AS VARBINARY), 'utf8', 'utf8')).x FROM x), x AS (SELECT x, (TEST_CONV(x || CAST(REPEAT('.', 64) AS VARBINARY), 'utf8', 'utf8')).x FROM x) SELECT x, x.x AS x, x.x AS x FROM x AS x JOIN x AS x USING (x) WHERE x.x IS DISTINCT FROM x.x ORDER BY x NULLS LAST;
/* Test ASCII verification in fast path where incomplete */ /* UTF-8 sequences fall at the end of the preceding chunk. */ WITH x AS (SELECT x, x, (TEST_CONV(x || CAST(REPEAT('.', 3) AS VARBINARY), 'utf8', 'utf8')).x FROM x), x AS (SELECT x, (TEST_CONV(CAST(REPEAT('.', 64 - LENGTH(x)) AS VARBINARY) || x || CAST(REPEAT('.', 64) AS VARBINARY), 'utf8', 'utf8')).x FROM x) SELECT x, x.x AS x, x.x AS x FROM x AS x JOIN x AS x USING (x) WHERE x.x IS DISTINCT FROM x.x ORDER BY x NULLS LAST;
/* Test cases where UTF-8 sequences within short text */ /* come after the fast path returns. */ WITH x AS (SELECT x, x, (TEST_CONV(x || CAST(REPEAT('.', 3) AS VARBINARY), 'utf8', 'utf8')).x FROM x), x AS (SELECT x, (TEST_CONV(CAST(REPEAT('.', 64) AS VARBINARY) || x || CAST(REPEAT('.', 3) AS VARBINARY), 'utf8', 'utf8')).x FROM x) SELECT x, x.x AS x, x.x AS x FROM x AS x JOIN x AS x USING (x) WHERE x.x IS DISTINCT FROM x.x ORDER BY x NULLS LAST;
/* Test cases where incomplete UTF-8 sequences fall at the */ /* end of the part checked by the fast path. */ WITH x AS (SELECT x, x, (TEST_CONV(x || CAST(REPEAT('.', 3) AS VARBINARY), 'utf8', 'utf8')).x FROM x), x AS (SELECT x, (TEST_CONV(CAST(REPEAT('.', 64 - LENGTH(x)) AS VARBINARY) || x || CAST(REPEAT('.', 3) AS VARBINARY), 'utf8', 'utf8')).x FROM x) SELECT x, x.x AS x, x.x AS x FROM x AS x JOIN x AS x USING (x) WHERE x.x IS DISTINCT FROM x.x ORDER BY x NULLS LAST;
CREATE TABLE x (x VARBINARY, x TEXT);
INSERT INTO x VALUES ('\x666f6f', 'valid, pure ASCII'), ('\xc3a4c3b6', 'valid, extra latin chars'), ('\xd184d0bed0be', 'valid, cyrillic'), ('\x666f6fe8b1a1', 'valid, kanji/Chinese'), ('\xe382abe3829a', 'valid, two chars that combine to one in EUC_JIS_2004'), ('\xe382ab', 'only first half of combined char in EUC_JIS_2004'), ('\xe382abe382', 'incomplete combination when converted EUC_JIS_2004'), ('\xecbd94eb81bceba6ac', 'valid, Hangul, Korean'), ('\x666f6fefa8aa', 'valid, needs mapping function to convert to GB18030'), ('\x66e8b1ff6f6f', 'invalid byte sequence'), ('\x66006f', 'invalid, NUL byte'), ('\x666f6fe8b100', 'invalid, NUL byte'), ('\x666f6fe8b1', 'incomplete character at end');
/* Test UTF-8 verification */ SELECT x, (TEST_CONV(x, 'utf8', 'utf8')).* FROM x;
/* Test conversions from UTF-8 */ SELECT x, x, (TEST_CONV(x, 'utf8', 'euc_jis_2004')).* FROM x;
SELECT x, x, (TEST_CONV(x, 'utf8', 'latin1')).* FROM x;
SELECT x, x, (TEST_CONV(x, 'utf8', 'latin2')).* FROM x;
SELECT x, x, (TEST_CONV(x, 'utf8', 'latin5')).* FROM x;
SELECT x, x, (TEST_CONV(x, 'utf8', 'koi8r')).* FROM x;
SELECT x, x, (TEST_CONV(x, 'utf8', 'gb18030')).* FROM x;
/* EUC_JIS_2004 */ CREATE TABLE x (x VARBINARY, x TEXT);
INSERT INTO x VALUES ('\x666f6f', 'valid, pure ASCII'), ('\x666f6fbedd', 'valid'), ('\xa5f7', 'valid, translates to two UTF-8 chars '), ('\xbeddbe', 'incomplete char '), ('\x666f6f00bedd', 'invalid, NUL byte'), ('\x666f6fbe00dd', 'invalid, NUL byte'), ('\x666f6fbedd00', 'invalid, NUL byte'), ('\xbe04', 'invalid byte sequence');
/* Test EUC_JIS_2004 verification */ SELECT x, x, (TEST_CONV(x, 'euc_jis_2004', 'euc_jis_2004')).* FROM x;
/* Test conversions from EUC_JIS_2004 */ SELECT x, x, (TEST_CONV(x, 'euc_jis_2004', 'utf8')).* FROM x;
/* SHIFT-JIS-2004 */ CREATE TABLE x (x VARBINARY, x TEXT);
INSERT INTO x VALUES ('\x666f6f', 'valid, pure ASCII'), ('\x666f6f8fdb', 'valid'), ('\x666f6f81c0', 'valid, no translation to UTF-8'), ('\x666f6f82f5', 'valid, translates to two UTF-8 chars '), ('\x666f6f8fdb8f', 'incomplete char '), ('\x666f6f820a', 'incomplete char, followed by newline '), ('\x666f6f008fdb', 'invalid, NUL byte'), ('\x666f6f8f00db', 'invalid, NUL byte'), ('\x666f6f8fdb00', 'invalid, NUL byte');
/* Test SHIFT-JIS-2004 verification */ SELECT x, x, (TEST_CONV(x, 'shiftjis2004', 'shiftjis2004')).* FROM x;
/* Test conversions from SHIFT-JIS-2004 */ SELECT x, x, (TEST_CONV(x, 'shiftjis2004', 'utf8')).* FROM x;
SELECT x, x, (TEST_CONV(x, 'shiftjis2004', 'euc_jis_2004')).* FROM x;
/* GB18030 */ CREATE TABLE x (x VARBINARY, x TEXT);
INSERT INTO x VALUES ('\x666f6f', 'valid, pure ASCII'), ('\x666f6fcff3', 'valid'), ('\x666f6f8431a530', 'valid, no translation to UTF-8'), ('\x666f6f84309c38', 'valid, translates to UTF-8 by mapping function'), ('\x666f6f84309c', 'incomplete char '), ('\x666f6f84309c0a', 'incomplete char, followed by newline '), ('\x666f6f84309c3800', 'invalid, NUL byte'), ('\x666f6f84309c0038', 'invalid, NUL byte');
/* Test GB18030 verification */ SELECT x, x, (TEST_CONV(x, 'gb18030', 'gb18030')).* FROM x;
/* Test conversions from GB18030 */ SELECT x, x, (TEST_CONV(x, 'gb18030', 'utf8')).* FROM x;
/* ISO-8859-5 */ CREATE TABLE x (x VARBINARY, x TEXT);
INSERT INTO x VALUES ('\x666f6f', 'valid, pure ASCII'), ('\xe4dede', 'valid'), ('\x00', 'invalid, NUL byte'), ('\xe400dede', 'invalid, NUL byte'), ('\xe4dede00', 'invalid, NUL byte');
/* Test ISO-8859-5 verification */ SELECT x, x, (TEST_CONV(x, 'iso8859-5', 'iso8859-5')).* FROM x;
/* Test conversions from ISO-8859-5 */ SELECT x, x, (TEST_CONV(x, 'iso8859-5', 'utf8')).* FROM x;
SELECT x, x, (TEST_CONV(x, 'iso8859-5', 'koi8r')).* FROM x;
SELECT x, x, (TEST_CONV(x, 'iso8859_5', 'mule_internal')).* FROM x;
/* Big5 */ CREATE TABLE x (x VARBINARY, x TEXT);
INSERT INTO x VALUES ('\x666f6f', 'valid, pure ASCII'), ('\x666f6fb648', 'valid'), ('\x666f6fa27f', 'valid, no translation to UTF-8'), ('\x666f6fb60048', 'invalid, NUL byte'), ('\x666f6fb64800', 'invalid, NUL byte');
/* Test Big5 verification */ SELECT x, x, (TEST_CONV(x, 'big5', 'big5')).* FROM x;
/* Test conversions from Big5 */ SELECT x, x, (TEST_CONV(x, 'big5', 'utf8')).* FROM x;
SELECT x, x, (TEST_CONV(x, 'big5', 'mule_internal')).* FROM x;
/* MULE_INTERNAL */ CREATE TABLE x (x VARBINARY, x TEXT);
INSERT INTO x VALUES ('\x666f6f', 'valid, pure ASCII'), ('\x8bc68bcf8bcf', 'valid (in KOI8R)'), ('\x8bc68bcf8b', 'invalid,incomplete char'), ('\x92bedd', 'valid (in SHIFT_JIS)'), ('\x92be', 'invalid, incomplete char)'), ('\x666f6f95a3c1', 'valid (in Big5)'), ('\x666f6f95a3', 'invalid, incomplete char'), ('\x9200bedd', 'invalid, NUL byte'), ('\x92bedd00', 'invalid, NUL byte'), ('\x8b00c68bcf8bcf', 'invalid, NUL byte');
/* Test MULE_INTERNAL verification */ SELECT x, x, (TEST_CONV(x, 'mule_internal', 'mule_internal')).* FROM x;
/* Test conversions from MULE_INTERNAL */ SELECT x, x, (TEST_CONV(x, 'mule_internal', 'koi8r')).* FROM x;
SELECT x, x, (TEST_CONV(x, 'mule_internal', 'iso8859-5')).* FROM x;
SELECT x, x, (TEST_CONV(x, 'mule_internal', 'sjis')).* FROM x;
SELECT x, x, (TEST_CONV(x, 'mule_internal', 'big5')).* FROM x;
SELECT x, x, (TEST_CONV(x, 'mule_internal', 'euc_jp')).* FROM x;
INSERT INTO x VALUES ('DOS', abc\r\ndef, 1);
INSERT INTO x VALUES ('Unix', abc\ndef, 2);
INSERT INTO x VALUES ('Mac', abc\rdef, 3);
INSERT INTO x VALUES (esc\\ape, a\\r\\\r\\\n\\nb, 4);
CREATE TEMPORARY TABLE x (LIKE x);
SELECT * FROM x EXCEPT SELECT * FROM x;
TRUNCATE TABLE x;
SELECT * FROM x EXCEPT SELECT * FROM x;
SELECT x FROM x ORDER BY x COLLATE "x" NULLS LAST;
TRUNCATE TABLE x /* in text mode, \. must be alone on its line */;
COPY INTO x (x) FROM x;
/* test header line feature */ CREATE TEMPORARY TABLE x (x INT, "x" TEXT, "x" INT);
COPY INTO x FROM x WITH (csv header);
CREATE TEMPORARY TABLE x (x INT, "x" TEXT);
COPY INTO x FROM STDIN(x);
/* test copy from with a partitioned table */ CREATE TABLE x (x INT, x INT, x TEXT) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x (x TEXT, x INT, x INT);
CREATE TABLE x (x INT, x TEXT, x INT);
alter table parted_copytest attach partition parted_copytest_a1 for values in(1);
alter table parted_copytest attach partition parted_copytest_a2 for values in(2);
/* We must insert enough rows to trigger multi-inserts.  These are only */ /* enabled adaptively when there are few enough partition changes. */ INSERT INTO x SELECT x, 1, 'One' FROM x AS x;
INSERT INTO x SELECT x, 2, 'Two' FROM x AS x;
INSERT INTO x SELECT x, 1, 'One' FROM x AS x;
TRUNCATE TABLE x;
/* Ensure COPY FREEZE errors for partitioned tables. */ BEGIN;
TRUNCATE TABLE x;
ROLLBACK;
SELECT CAST(x AS REGCLASS), COUNT(*), SUM(x) FROM x GROUP BY x ORDER BY CAST(CAST(x AS REGCLASS) AS NAME) NULLS LAST;
TRUNCATE TABLE x;
COMMIT;
create trigger part_ins_trig 	before insert on parted_copytest_a2 	for each row 	execute procedure part_ins_func();
SELECT CAST(x AS REGCLASS), COUNT(*), SUM(x) FROM x GROUP BY x ORDER BY CAST(CAST(x AS REGCLASS) AS NAME) NULLS LAST;
TRUNCATE TABLE x;
CREATE INDEX ON x(x NULLS LAST);
drop trigger part_ins_trig on parted_copytest_a2;
COPY INTO x FROM x;
SELECT * FROM x WHERE x = 2;
DROP TABLE x;
/* Progress reporting for COPY */ CREATE TABLE x (x TEXT, x INT, x point, x INT, x NAME);
BEGIN -- The fields ignored here are the ones that may not remain   -- consistent across multiple runs.  The sizes reported may differ   -- across platforms, so just check if these are strictly positive.   with progress_data as (     select        relid::regclass::text as relname,        command,        type,        bytes_processed > 0 as has_bytes_processed,        bytes_total > 0 as has_bytes_total,        tuples_processed,        tuples_excluded,        tuples_skipped       from pg_stat_progress_copy       where pid = pg_backend_pid())   select into report (to_jsonb(r)) as value     from progress_data r;
x AS x;
COMMIT;
create trigger check_after_tab_progress_reporting 	after insert on tab_progress_reporting 	for each statement 	execute function notice_after_tab_progress_reporting();
COPY INTO x FROM x /* Generate COPY FROM report with PIPE. */;
DROP FUNCTION x;
DROP TABLE x;
/* Test header matching feature */ CREATE TABLE x (x INT, x INT, x TEXT);
ALTER TABLE x DROP COLUMN x /* Make sure it works with dropped columns */;
ALTER TABLE x ADD COLUMN x TEXT;
COPY INTO x TO x WITH (header match);
COPY INTO x FROM x WITH (header wrong_choice);
COPY INTO x FROM x WITH (header match) /* works */;
ALTER TABLE x DROP COLUMN x /* Drop an extra column, in the middle of the existing set. */;
COPY INTO x (x, x) FROM x WITH (header match) /* works */;
DROP TABLE x;
/* test COPY with overlong column defaults */ CREATE TEMPORARY TABLE x (x VARCHAR(5) DEFAULT 'more than 5 chars', x VARCHAR(5));
COPY INTO x FROM x /* normal COPY should work */;
/* Create partitioned table that does not allow bulk insertions, to test bugs */ /* related to the reuse of BulkInsertState across partitions (only done when */ /* not using bulk insert).  Switching between partitions often makes it more */ /* likely to encounter these bugs, so we just switch on roughly every insert */ /* by having an even/odd number partition and inserting evenly distributed */ /* data. */ CREATE TABLE x (x INT NOT NULL, x TEXT NOT NULL, x /* prevent use of bulk insert by having a volatile function */ DOUBLE NOT NULL DEFAULT RAND()) WITH (PARTITIONED_BY=LIST((x % 2)));
CREATE TABLE x PARTITION OF x FOR VALUES IN (0);
CREATE TABLE x PARTITION OF x FOR VALUES IN (1);
/* An earlier bug (see commit b1ecb9b3fcf) could end up using a buffer from */ /* the wrong partition. This test is *not* guaranteed to trigger that bug, but */ /* does so when shared_buffers is small enough.  To test if we encountered the */ /* bug, check that the partition condition isn't violated. */ SELECT CAST(x AS REGCLASS), x % 2 = 0 AS x, COUNT(*) FROM x GROUP BY 1, 2 ORDER BY 1 NULLS LAST;
DROP TABLE x;
/* ensure COPY FREEZE errors for foreign tables */ BEGIN;
create foreign data wrapper copytest_wrapper;
create server copytest_server foreign data wrapper copytest_wrapper;
create foreign table copytest_foreign_table (a int) server copytest_server;
COPY INTO x FROM STDIN(x);
CREATE TEMPORARY TABLE x (x SERIAL, x INT, x TEXT NOT NULL DEFAULT 'stuff', x TEXT, x TEXT);
x AS x;
COMMIT;
x AS x;
COMMIT;
CREATE TRIGGER trg_x_after AFTER INSERT ON x FOR EACH ROW EXECUTE PROCEDURE fn_x_after();
CREATE TRIGGER trg_x_before BEFORE INSERT ON x FOR EACH ROW EXECUTE PROCEDURE fn_x_before();
COPY INTO x (x, x, x, x, x) FROM x;
COPY INTO x FROM STDIN(CAST(' ' AS NULL), CAST(' ' AS NULL));
COPY INTO x FROM STDIN(FORCE_NOT_NULL(x), FORCE_NOT_NULL(x));
COPY INTO x FROM STDIN(FORCE_NULL(x), FORCE_NULL(x));
COPY INTO x FROM STDIN(CONVERT_SELECTIVELY(x), CONVERT_SELECTIVELY(x));
COPY INTO x FROM x WITH (reject_limit 1);
COPY INTO x FROM x WITH (on_error ignore, reject_limit 0);
COPY INTO x (x, x, x, x, x, x, x) FROM x /* too many columns in column list: should fail */;
COPY INTO x FROM x /* missing data: should fail */;
3000;
x;
COPY INTO x FROM x WITH (WHERE a, IN (SELECT 1 FROM x));
COPY INTO x FROM x WITH (WHERE a, IN (UNNEST(GENERATE_SERIES(1, 5))));
/* check results of copy in */ SELECT * FROM x;
COPY INTO x TO x /* check copy out */;
COPY INTO x (x, x) TO x;
COPY INTO x (x, x) TO x WITH (NULL 'I''m null');
CREATE TEMPORARY TABLE x (x TEXT, x TEXT);
INSERT INTO x VALUES ('Jackson, Sam', \\h);
INSERT INTO x VALUES ('It is "perfect".', \t);
INSERT INTO x VALUES ('', NULL);
COPY INTO x TO x WITH (CSV);
COPY INTO x TO x WITH (CSV QUOTE, ' DELIMITER, |);
COPY INTO x TO x WITH (CSV FORCE, QUOTE col2, ESCAPE \\, ENCODING 'sql_ascii');
COPY INTO x TO x WITH (CSV FORCE, QUOTE *);
COPY INTO x FROM x WITH (CSV);
COPY INTO x FROM x WITH (CSV);
/* test handling of nonstandard null marker that violates escaping rules */ CREATE TEMPORARY TABLE x (x INT, x TEXT);
INSERT INTO x VALUES (1, \\0), (NULL, NULL);
COPY INTO x TO x WITH (NULL \\0);
COPY INTO x FROM x WITH (NULL \\0);
BEGIN;
CREATE TABLE x (LIKE x);
COPY INTO x FROM x WITH (CSV);
SELECT * FROM x;
BEGIN;
TRUNCATE TABLE x;
COPY INTO x FROM x WITH (CSV);
x AS x;
TRUNCATE TABLE x;
COPY INTO x FROM x WITH (CSV);
COMMIT;
SELECT * FROM x;
BEGIN;
TRUNCATE TABLE x;
COPY INTO x FROM x WITH (CSV FREEZE);
x AS x;
TRUNCATE TABLE x;
COPY INTO x FROM x WITH (CSV FREEZE);
COMMIT;
SELECT * FROM x;
BEGIN;
TRUNCATE TABLE x;
COPY INTO x FROM x WITH (CSV FREEZE);
COMMIT;
TRUNCATE TABLE x;
COPY INTO x FROM x WITH (CSV FREEZE);
TRUNCATE TABLE x;
x AS x;
COPY INTO x FROM x WITH (CSV FREEZE);
BEGIN;
INSERT INTO x VALUES ('z');
x AS x;
TRUNCATE TABLE x;
ROLLBACK TO x;
COPY INTO x FROM x WITH (CSV FREEZE);
COMMIT;
BEGIN;
INSERT INTO x VALUES ('z');
SELECT TRUNCATE_IN_SUBXACT();
COPY INTO x FROM x WITH (CSV FREEZE);
COMMIT;
SELECT * FROM x;
/* Test FORCE_NOT_NULL and FORCE_NULL options */ CREATE TEMPORARY TABLE x (x INT NOT NULL, x TEXT NOT NULL, x TEXT, x TEXT, x TEXT);
COPY INTO x (x, x, x) FROM x WITH (FORMAT csv, FORCE_NOT_NULL (x), FORCE_NULL (x));
SELECT x, x FROM x WHERE x = 1;
/* should succeed, FORCE_NULL and FORCE_NOT_NULL can be both specified */ BEGIN;
COPY INTO x (x, x, x, x) FROM x WITH (FORMAT csv, FORCE_NOT_NULL (x, x), FORCE_NULL (x, x));
SELECT x, x FROM x WHERE x = 2;
/* should fail with not-null constraint violation */ BEGIN;
COPY INTO x (x, x, x) FROM x WITH (FORMAT csv, FORCE_NULL (x), FORCE_NOT_NULL (x));
/* should fail with "not referenced by COPY" error */ BEGIN;
COPY INTO x (x, x) FROM x WITH (FORMAT csv, FORCE_NOT_NULL (x));
ROLLBACK;
/* should fail with "not referenced by COPY" error */ BEGIN;
COPY INTO x (x, x) FROM x WITH (FORMAT csv, FORCE_NULL (x));
ROLLBACK;
/* should succeed with no effect ("b" remains an empty string, "c" remains NULL) */ BEGIN;
COPY INTO x (x, x, x) FROM x WITH (FORMAT csv, FORCE_NOT_NULL *, FORCE_NULL *);
SELECT x, x FROM x WHERE x = 4;
/* should succeed with effect ("b" remains an empty string) */ BEGIN;
COPY INTO x (x, x, x) FROM x WITH (FORMAT csv, FORCE_NOT_NULL *);
SELECT x, x FROM x WHERE x = 5;
/* should succeed with effect ("c" remains NULL) */ BEGIN;
COPY INTO x (x, x, x) FROM x WITH (FORMAT csv, FORCE_NULL *);
SELECT x, x FROM x WHERE x = 6;
/* should fail with "conflicting or redundant options" error */ BEGIN;
COPY INTO x (x, x, x) FROM x WITH (FORMAT csv, FORCE_NOT_NULL *, FORCE_NOT_NULL (x));
ROLLBACK;
/* should fail with "conflicting or redundant options" error */ BEGIN;
COPY INTO x (x, x, x) FROM x WITH (FORMAT csv, FORCE_NULL *, FORCE_NULL (x));
ROLLBACK;
ALTER TABLE x CHECK(CHECK_CON_FUNCTION(x.*));
/* test with RLS enabled. */ CREATE ROLE regress_rls_copy_user;
CREATE ROLE regress_rls_copy_user_colperms;
CREATE TABLE x (x INT, x INT, x INT);
COPY INTO x (x, x, x) FROM x;
ALTER TABLE rls_t1 ENABLE ROW LEVEL SECURITY;
ALTER TABLE rls_t1 FORCE ROW LEVEL SECURITY;
GRANT SELECT ON TABLE x TO x;
GRANT SELECT(x, x) ON TABLE x TO x;
COPY INTO x TO x /* all columns */;
COPY INTO x (x, x, x) TO x;
COPY INTO x (x) TO x /* subset of columns */;
COPY INTO x (x, x) TO x;
COPY INTO x (x, x) TO x /* column reordering */;
SET SESSION AUTHORIZATION regress_rls_copy_user;
COPY INTO x TO x /* all columns */;
COPY INTO x (x, x, x) TO x;
COPY INTO x (x) TO x /* subset of columns */;
COPY INTO x (x, x) TO x;
COPY INTO x (x, x) TO x /* column reordering */;
RESET SESSION AUTHORIZATION;
SET SESSION AUTHORIZATION regress_rls_copy_user_colperms;
COPY INTO x TO x /* attempt all columns (should fail) */;
COPY INTO x (x, x, x) TO x;
COPY INTO x (x) TO x /* try to copy column with no privileges (should fail) */;
COPY INTO x (x) TO x /* subset of columns (should succeed) */;
COPY INTO x (x, x) TO x;
RESET SESSION AUTHORIZATION;
/* test with INSTEAD OF INSERT trigger on a view */ CREATE TABLE x (x SERIAL, x TEXT);
CREATE VIEW x AS SELECT CAST('' AS TEXT) AS x;
COPY INTO x FROM x;
x AS x;
COMMIT;
CREATE TRIGGER trig_instead_of_insert_tbl_view   INSTEAD OF INSERT ON instead_of_insert_tbl_view   FOR EACH ROW EXECUTE PROCEDURE fun_instead_of_insert_tbl();
COPY INTO x FROM x;
/* Test of COPY optimization with view using INSTEAD OF INSERT */ /* trigger when relation is created in the same transaction as */ /* when COPY is executed. */ BEGIN;
CREATE VIEW x AS SELECT CAST('' AS TEXT) AS x;
CREATE TRIGGER trig_instead_of_insert_tbl_view_2   INSTEAD OF INSERT ON instead_of_insert_tbl_view_2   FOR EACH ROW EXECUTE PROCEDURE fun_instead_of_insert_tbl();
COPY INTO x FROM x;
COMMIT;
/* tests for on_error option */ CREATE TABLE x (x INT, x ARRAY<INT>, x INT);
COPY INTO x FROM x WITH (on_error stop);
CREATE TABLE x (x INT, x ARRAY<INT>, x INT, x dcheck_ign_err2);
COPY INTO x FROM x WITH (on_error ignore, log_verbosity verbose);
SELECT * FROM x;
/* test datatype error that can't be handled as soft: should fail */ CREATE TABLE x (x widget);
COPY INTO x FROM x WITH (on_error ignore);
DROP TABLE x;
DROP FUNCTION x;
DROP TABLE x CASCADE;
DROP ROLE regress_rls_copy_user;
DROP ROLE regress_rls_copy_user_colperms;
DROP FUNCTION x;
DROP FUNCTION x;
DROP TABLE x;
DROP VIEW x;
DROP VIEW x;
DROP FUNCTION x;
DROP TABLE x;
DROP TABLE x;
DROP DOMAIN dcheck_ign_err2;
DROP TABLE x;
/* COPY FROM ... DEFAULT */ CREATE TEMPORARY TABLE x (x INT PRIMARY KEY, x TEXT NOT NULL DEFAULT 'test', x TIMESTAMP NOT NULL DEFAULT '2022-07-05');
COPY INTO x FROM x /* if DEFAULT is not specified, then the marker will be regular data */;
TRUNCATE TABLE x;
COPY INTO x FROM x WITH (format csv);
TRUNCATE TABLE x;
COPY INTO x FROM x WITH (format binary, default '\D') /* DEFAULT cannot be used in binary mode */;
COPY INTO x FROM x WITH (default \n) /* DEFAULT cannot be new line nor carriage return */;
COPY INTO x FROM x WITH (default \r);
', default ' AS x;
COPY INTO x FROM x WITH (format csv, quote '"', default 'test"test') /* CSV quote cannot appear in DEFAULT spec */;
COPY INTO x FROM x WITH (default '\N') /* NULL and DEFAULT spec must be different */;
COPY INTO x FROM x WITH (default '\D') /* cannot use DEFAULT marker in column that has no DEFAULT value */;
TRUNCATE TABLE x;
COPY INTO x FROM x WITH (format csv, default '\D');
TRUNCATE TABLE x;
COPY INTO x FROM x WITH (default '\D') /* successful usage of DEFAULT option in COPY */;
TRUNCATE TABLE x;
COPY INTO x FROM x WITH (format csv, default '\D');
TRUNCATE TABLE x;
COPY INTO (SELECT 1 AS x) TO x WITH (default '\D') /* DEFAULT cannot be used in COPY TO */;
/* Test cases for COPY (INSERT/UPDATE/DELETE) TO */ CREATE TABLE x (x SERIAL, x TEXT);
INSERT INTO x (x) VALUES ('a');
INSERT INTO x (x) VALUES ('b');
INSERT INTO x (x) VALUES ('c');
INSERT INTO x (x) VALUES ('d');
INSERT INTO x (x) VALUES ('e');
create rule qqq as on insert to copydml_test do instead nothing;
drop rule qqq on copydml_test;
create rule qqq as on insert to copydml_test do also delete from copydml_test;
drop rule qqq on copydml_test;
create rule qqq as on insert to copydml_test do instead (delete from copydml_test;
drop rule qqq on copydml_test;
create rule qqq as on insert to copydml_test where new.t <> 'f' do instead delete from copydml_test;
drop rule qqq on copydml_test;
create rule qqq as on update to copydml_test do instead nothing;
drop rule qqq on copydml_test;
create rule qqq as on update to copydml_test do also delete from copydml_test;
drop rule qqq on copydml_test;
create rule qqq as on update to copydml_test do instead (delete from copydml_test;
drop rule qqq on copydml_test;
create rule qqq as on update to copydml_test where new.t <> 'f' do instead delete from copydml_test;
drop rule qqq on copydml_test;
create rule qqq as on delete to copydml_test do instead nothing;
drop rule qqq on copydml_test;
create rule qqq as on delete to copydml_test do also insert into copydml_test default values;
drop rule qqq on copydml_test;
create rule qqq as on delete to copydml_test do instead (insert into copydml_test default values;
drop rule qqq on copydml_test;
create rule qqq as on delete to copydml_test where old.t <> 'f' do instead insert into copydml_test default values;
drop rule qqq on copydml_test;
create rule qqq as on insert to copydml_test do instead notify copydml_test;
drop rule qqq on copydml_test;
x AS x;
x AS x;
create trigger qqqbef before insert or update or delete on copydml_test     for each row execute procedure qqq_trig();
create trigger qqqaf after insert or update or delete on copydml_test     for each row execute procedure qqq_trig();
DROP TABLE x;
DROP FUNCTION x;
SET x = UTF8 /* Use client_encoding */;
SET x = LATIN1 /* Read UTF8 data as LATIN1: no error */;
RESET client_encoding;
SET x = UTF8 /* Use client_encoding */;
SET x = EUC_JP /* Read UTF8 data as EUC_JP: no error */;
RESET client_encoding;
DROP TABLE x;
/* Test cases for COPY (select) TO */ CREATE TABLE x (x SERIAL, x TEXT);
INSERT INTO x (x) VALUES ('a');
INSERT INTO x (x) VALUES ('b');
INSERT INTO x (x) VALUES ('c');
INSERT INTO x (x) VALUES ('d');
INSERT INTO x (x) VALUES ('e');
CREATE TABLE x (x SERIAL, x TEXT);
INSERT INTO x (x) VALUES ('A');
INSERT INTO x (x) VALUES ('B');
INSERT INTO x (x) VALUES ('C');
INSERT INTO x (x) VALUES ('D');
INSERT INTO x (x) VALUES ('E');
CREATE VIEW x AS SELECT 'v_' || x FROM x;
COPY INTO x TO x /* Test COPY table TO */;
COPY INTO x TO x /* This should fail */;
COPY INTO (SELECT x FROM x WHERE x = 1) TO x /* Test COPY (select) TO */;
COPY INTO (SELECT x FROM x WHERE x = 3) TO x /* Test COPY (select for update) TO */;
COPY INTO (CREATE TEMPORARY TABLE x AS SELECT x FROM x WHERE x = 3) TO x /* This should fail */;
COPY INTO (SELECT * FROM x) FROM x /* This should fail */;
COPY INTO (SELECT * FROM x) FROM (x, x) WITH (to stdout) /* This should fail */;
COPY INTO (SELECT * FROM x JOIN x USING (x)) TO x /* Test JOIN */;
COPY INTO (SELECT x FROM x WHERE x = 1 UNION SELECT * FROM x ORDER BY 1 NULLS LAST) TO x /* Test UNION SELECT */;
COPY INTO (SELECT * FROM (SELECT x FROM x WHERE x = 1 UNION SELECT * FROM x ORDER BY 1 NULLS LAST) AS x) TO x /* Test subselect */;
COPY INTO (SELECT x FROM x WHERE x = 1) TO x WITH (csv header, force quote, t) /* Test headers, CSV and quotes */;
DROP VIEW x;
DROP TABLE x;
SELECT 1 / 0;
COPY INTO (SELECT 1) TO x;
SELECT 4;
/* 1 2 3 4 */ CREATE TABLE x (x INT);
SELECT 1;
DROP TABLE x;
/* CREATE_AGGREGATE */ /* all functions CREATEd */ CREATE AGGREGATE newavg (    sfunc = int4_avg_accum, basetype = int4, stype = _int8,    finalfunc = int8_avg,    initcond1 = '{0,0}' );
/* test comments */ COMMENT ON AGGREGATE newavg_wrong (int4) IS 'an agg comment';
COMMENT ON AGGREGATE newavg (int4) IS 'an agg comment';
COMMENT ON AGGREGATE newavg (int4) IS NULL;
/* zero-argument aggregate */ CREATE AGGREGATE newcnt (*) (    sfunc = int8inc, stype = int8,    initcond = '0', parallel = safe );
/* aggregate that only cares about null/nonnull input */ CREATE AGGREGATE newcnt ("any") (    sfunc = int8inc_any, stype = int8,    initcond = '0' );
COMMENT ON AGGREGATE nosuchagg (*) IS 'should fail';
COMMENT ON AGGREGATE newcnt (*) IS 'an agg(*) comment';
COMMENT ON AGGREGATE newcnt ("any") IS 'an agg(any) comment';
/* multi-argument aggregate */ CREATE FUNCTION x(x, x, x) RETURNS BIGINT LANGUAGE sql STRICT IMMUTABLE AS 'select $1 + $2 + $3';
create aggregate sum2(int8,int8) (    sfunc = sum3, stype = int8,    initcond = '0' );
/* multi-argument aggregates sensitive to distinct/order, strict/nonstrict */ create type aggtype as (a integer, b integer, c text);
create aggregate aggfstr(integer,integer,text) (    sfunc = aggf_trans, stype = aggtype[],    initcond = '{}' );
create aggregate aggfns(integer,integer,text) (    sfunc = aggfns_trans, stype = aggtype[], sspace = 10000,    initcond = '{}' );
/* check error cases that would require run-time type coercion */ CREATE FUNCTION x(x, x) RETURNS BIGINT LANGUAGE sql AS 'select least($1, $2)';
create aggregate least_agg(int4) (   stype = int8, sfunc = least_accum );
/* fails */ DROP FUNCTION x (BIGINT, BIGINT);
CREATE FUNCTION x(x, x) RETURNS anycompatible LANGUAGE sql AS 'select least($1, $2)';
create aggregate least_agg(int4) (   stype = int8, sfunc = least_accum );
/* fails */ create aggregate least_agg(int8) (   stype = int8, sfunc = least_accum );
DROP FUNCTION x (anycompatible, anycompatible) CASCADE;
/* variadic aggregates */ CREATE FUNCTION x(x, x anyarray) RETURNS anyelement LANGUAGE sql AS 'select least($1, min($2[i])) from generate_subscripts($2,1) g(i)';
create aggregate least_agg(variadic items anyarray) (   stype = anyelement, sfunc = least_accum );
CREATE FUNCTION x(x, x anycompatiblearray) RETURNS anycompatible LANGUAGE sql AS 'select least($1, min($2[i])) from generate_subscripts($2,1) g(i)';
create aggregate cleast_agg(variadic items anycompatiblearray) (   stype = anycompatible, sfunc = cleast_accum );
/* test ordered-set aggs using built-in support functions */ create aggregate my_percentile_disc(float8 ORDER BY anyelement) (   stype = internal,   sfunc = ordered_set_transition,   finalfunc = percentile_disc_final,   finalfunc_extra = true,   finalfunc_modify = read_write );
create aggregate my_rank(VARIADIC "any" ORDER BY VARIADIC "any") (   stype = internal,   sfunc = ordered_set_transition_multi,   finalfunc = rank_final,   finalfunc_extra = true,   hypothetical );
alter aggregate my_percentile_disc(float8 ORDER BY anyelement)   rename to test_percentile_disc;
alter aggregate my_rank(VARIADIC "any" ORDER BY VARIADIC "any")   rename to test_rank;
/* aggregate combine and serialization functions */ /* can't specify just one of serialfunc and deserialfunc */ CREATE AGGREGATE myavg (numeric) ( 	stype = internal, 	sfunc = numeric_avg_accum, 	serialfunc = numeric_avg_serialize );
/* serialfunc must have correct parameters */ CREATE AGGREGATE myavg (numeric) ( 	stype = internal, 	sfunc = numeric_avg_accum, 	serialfunc = numeric_avg_deserialize, 	deserialfunc = numeric_avg_deserialize );
/* deserialfunc must have correct parameters */ CREATE AGGREGATE myavg (numeric) ( 	stype = internal, 	sfunc = numeric_avg_accum, 	serialfunc = numeric_avg_serialize, 	deserialfunc = numeric_avg_serialize );
/* ensure combine function parameters are checked */ CREATE AGGREGATE myavg (numeric) ( 	stype = internal, 	sfunc = numeric_avg_accum, 	serialfunc = numeric_avg_serialize, 	deserialfunc = numeric_avg_deserialize, 	combinefunc = int4larger );
/* ensure create aggregate works. */ CREATE AGGREGATE myavg (numeric) ( 	stype = internal, 	sfunc = numeric_avg_accum, 	finalfunc = numeric_avg, 	serialfunc = numeric_avg_serialize, 	deserialfunc = numeric_avg_deserialize, 	combinefunc = numeric_avg_combine, 	finalfunc_modify = shareable  -- just to test a non-default setting );
/* Ensure all these functions made it into the catalog */ SELECT x, x, x, CAST(x AS REGTYPE), x, x, x FROM x WHERE x = CAST('myavg' AS REGPROC);
DROP AGGREGATE myavg (numeric);
/* create or replace aggregate */ CREATE AGGREGATE myavg (numeric) ( 	stype = internal, 	sfunc = numeric_avg_accum, 	finalfunc = numeric_avg );
CREATE OR REPLACE AGGREGATE myavg (numeric) ( 	stype = internal, 	sfunc = numeric_avg_accum, 	finalfunc = numeric_avg, 	serialfunc = numeric_avg_serialize, 	deserialfunc = numeric_avg_deserialize, 	combinefunc = numeric_avg_combine, 	finalfunc_modify = shareable  -- just to test a non-default setting );
/* Ensure all these functions made it into the catalog again */ SELECT x, x, x, CAST(x AS REGTYPE), x, x, x FROM x WHERE x = CAST('myavg' AS REGPROC);
/* can change stype: */ CREATE OR REPLACE AGGREGATE myavg (numeric) ( 	stype = numeric, 	sfunc = numeric_add );
SELECT x, x, x, CAST(x AS REGTYPE), x, x, x FROM x WHERE x = CAST('myavg' AS REGPROC);
/* can't change return type: */ CREATE OR REPLACE AGGREGATE myavg (numeric) ( 	stype = numeric, 	sfunc = numeric_add, 	finalfunc = numeric_out );
/* can't change to a different kind: */ CREATE OR REPLACE AGGREGATE myavg (order by numeric) ( 	stype = numeric, 	sfunc = numeric_add );
/* can't change plain function to aggregate: */ CREATE FUNCTION x(x, x, x, x) RETURNS BIGINT LANGUAGE sql STRICT IMMUTABLE AS 'select $1 + $2 + $3 + $4';
CREATE OR REPLACE AGGREGATE sum3 (int8,int8,int8) ( 	stype = int8, 	sfunc = sum4 );
DROP FUNCTION x (BIGINT, BIGINT, BIGINT, BIGINT);
DROP AGGREGATE myavg (numeric);
/* invalid: bad parallel-safety marking */ CREATE AGGREGATE mysum (int) ( 	stype = int, 	sfunc = int4pl, 	parallel = pear );
CREATE AGGREGATE invalidsumdouble (float8) (     stype = float8,     sfunc = float8pl,     mstype = float8,     msfunc = float8pl,     minvfunc = float8mi_n );
CREATE AGGREGATE wrongreturntype (float8) (     stype = float8,     sfunc = float8pl,     mstype = float8,     msfunc = float8pl,     minvfunc = float8mi_int );
/* invalid: non-lowercase quoted identifiers */ CREATE AGGREGATE case_agg ( -- old syntax 	"Sfunc1" = int4pl, 	"Basetype" = int4, 	"Stype1" = int4, 	"Initcond1" = '0', 	"Parallel" = safe );
CREATE AGGREGATE case_agg(float8) ( 	"Stype" = internal, 	"Sfunc" = ordered_set_transition, 	"Finalfunc" = percentile_disc_final, 	"Finalfunc_extra" = true, 	"Finalfunc_modify" = read_write, 	"Parallel" = safe );
/* Create access method tests */ /* Make gist2 over gisthandler. In fact, it would be a synonym to gist. */ CREATE ACCESS METHOD gist2 TYPE INDEX HANDLER gisthandler;
/* Verify return type checks for handlers */ CREATE ACCESS METHOD bogus TYPE INDEX HANDLER int4in;
CREATE ACCESS METHOD bogus TYPE INDEX HANDLER heap_tableam_handler;
/* Try to create gist2 index on fast_emp4000: fail because opclass doesn't exist */ CREATE INDEX x ON x USING gist2(x NULLS LAST);
/* Make operator class for boxes using gist2 */ CREATE OPERATOR CLASS box_ops DEFAULT 	FOR TYPE box USING gist2 AS 	OPERATOR 1	<<, 	OPERATOR 2	&<, 	OPERATOR 3	&&, 	OPERATOR 4	&>, 	OPERATOR 5	>>, 	OPERATOR 6	~=, 	OPERATOR 7	@>, 	OPERATOR 8	<@, 	OPERATOR 9	&<|, 	OPERATOR 10	<<|, 	OPERATOR 11	|>>, 	OPERATOR 12	|&>, 	FUNCTION 1	gist_box_consistent(internal, box, smallint, oid, internal), 	FUNCTION 2	gist_box_union(internal, internal), 	-- don't need compress, decompress, or fetch functions 	FUNCTION 5	gist_box_penalty(internal, internal, internal), 	FUNCTION 6	gist_box_picksplit(internal, internal), 	FUNCTION 7	gist_box_same(box, box, internal);
/* Create gist2 index on fast_emp4000 */ CREATE INDEX x ON x USING gist2(x NULLS LAST);
DROP INDEX x;
SET x = OFF;
SET x = ON;
SET x = OFF;
EXPLAIN (COSTS OFF) SELECT * FROM fast_emp4000     WHERE home_base <@ '(200,200),(2000,1000)'::box     ORDER BY (home_base[0])[0];
SELECT * FROM x WHERE CAST('(200,200),(2000,1000)' AS box) @> x ORDER BY (x[-1])[-1] NULLS LAST;
EXPLAIN (COSTS OFF) SELECT count(*) FROM fast_emp4000 WHERE home_base && '(1000,1000,0,0)'::box;
SELECT COUNT(*) FROM x WHERE x && CAST('(1000,1000,0,0)' AS box);
EXPLAIN (COSTS OFF) SELECT count(*) FROM fast_emp4000 WHERE home_base IS NULL;
SELECT COUNT(*) FROM x WHERE x IS NULL;
ROLLBACK;
/* Try to drop access method: fail because of dependent objects */ DROP ACCESS METHOD gist2;
/* Drop access method cascade */ /* To prevent a (rare) deadlock against autovacuum, */ /* we must lock the table that owns the index that will be dropped */ BEGIN;
DROP ACCESS METHOD gist2 CASCADE;
COMMIT;
SET x = '' /* Test table access methods */ /* prevent empty values */;
SET x = 'I do not exist AM' /* prevent nonexistent values */;
SET x = 'btree' /* prevent setting it to an index AM */;
/* Create a heap2 table am handler with heapam handler */ CREATE ACCESS METHOD heap2 TYPE TABLE HANDLER heap_tableam_handler;
/* Verify return type checks for handlers */ CREATE ACCESS METHOD bogus TYPE TABLE HANDLER int4in;
CREATE ACCESS METHOD bogus TYPE TABLE HANDLER bthandler;
SELECT x, x, x FROM x WHERE x = 't' ORDER BY 1 NULLS LAST, 2 NULLS LAST;
/* First create tables employing the new AM using USING */ /* plain CREATE TABLE */ CREATE TABLE x (x INT) WITH (FORMAT=heap2);
INSERT INTO x VALUES (1);
SELECT x FROM x ORDER BY x NULLS LAST;
/* CREATE TABLE AS */ CREATE TABLE x WITH (FORMAT=heap2) AS SELECT * FROM x;
SELECT x FROM x ORDER BY x NULLS LAST;
/* CREATE VIEW doesn't support USING */ CREATE VIEW x WITH (FORMAT=heap2) AS SELECT * FROM x;
/* CREATE SEQUENCE doesn't support USING */ CREATE SEQUENCE x WITH (FORMAT=heap2);
/* CREATE MATERIALIZED VIEW does support USING */ CREATE MATERIALIZED VIEW x WITH (FORMAT=heap2) AS SELECT * FROM x;
SELECT x FROM x ORDER BY x NULLS LAST;
/* CREATE TABLE ..  PARTITION BY supports USING. */ CREATE TABLE x (x TEXT, x INT) WITH (PARTITIONED_BY=LIST(x), FORMAT=heap2);
SELECT x.x FROM x AS x, x AS x WHERE x.x = 'tableam_parted_heap2' AND x.x = x.x;
DROP TABLE x;
CREATE TABLE x (x TEXT, x INT) WITH (PARTITIONED_BY=LIST(x));
SET x = 'heap' /* new partitions will inherit from the current default, rather the partition root */;
CREATE TABLE x PARTITION OF x FOR VALUES IN ('a');
SET x = 'heap2';
CREATE TABLE x PARTITION OF x FOR VALUES IN ('b');
RESET default_table_access_method;
/* but the method can be explicitly specified */ CREATE TABLE x PARTITION OF x FOR VALUES IN ('c') WITH (FORMAT=heap);
CREATE TABLE x PARTITION OF x FOR VALUES IN ('d') WITH (FORMAT=heap2);
/* List all objects in AM */ SELECT x.x, x.x, CASE WHEN x = 't' THEN (SELECT 'toast for ' || CAST(x AS REGCLASS) FROM x AS x WHERE x.x = x.x) ELSE CAST(CAST(x AS REGCLASS) AS TEXT) END COLLATE "x" AS x FROM x AS x, x AS x WHERE x.x = x.x AND x.x = 'heap2' ORDER BY 3 NULLS LAST, 1 NULLS LAST, 2 NULLS LAST;
/* Show dependencies onto AM - there shouldn't be any for toast */ SELECT PG_DESCRIBE_OBJECT(x, x, x) AS x FROM x, x WHERE x.x = CAST('pg_am' AS REGCLASS) AND x.x = x.x AND x.x = 'heap2' ORDER BY x NULLS LAST, x NULLS LAST, x NULLS LAST;
/* ALTER TABLE SET ACCESS METHOD */ CREATE TABLE x WITH (FORMAT=heap) AS SELECT x, REPEAT(CAST(x AS TEXT), 100) FROM x AS x;
SELECT x FROM x AS x, x AS x WHERE x.x = x.x AND x.x = CAST('heaptable' AS REGCLASS);
ALTER TABLE x SET  /* Switching to heap2 adds new dependency entry to the AM. */;
SELECT PG_DESCRIBE_OBJECT(x, x, x) AS x, PG_DESCRIBE_OBJECT(x, x, x) AS x, x FROM x WHERE x = CAST('pg_class' AS REGCLASS) AND x = CAST('heaptable' AS REGCLASS) ORDER BY 1 NULLS LAST, 2 NULLS LAST;
ALTER TABLE x SET  /* Switching to heap should not have a dependency entry to the AM. */;
SELECT PG_DESCRIBE_OBJECT(x, x, x) AS x, PG_DESCRIBE_OBJECT(x, x, x) AS x, x FROM x WHERE x = CAST('pg_class' AS REGCLASS) AND x = CAST('heaptable' AS REGCLASS) ORDER BY 1 NULLS LAST, 2 NULLS LAST;
ALTER TABLE x SET;
SELECT x FROM x AS x, x AS x WHERE x.x = x.x AND x.x = CAST('heaptable' AS REGCLASS);
SELECT COUNT(x), COUNT(1) FILTER(WHERE x = 1) FROM x;
/* DEFAULT access method */ BEGIN;
SET LOCAL x = heap2;
ALTER TABLE x SET;
SELECT x FROM x AS x, x AS x WHERE x.x = x.x AND x.x = CAST('heaptable' AS REGCLASS);
SET LOCAL x = heap;
ALTER TABLE x SET;
SELECT x FROM x AS x, x AS x WHERE x.x = x.x AND x.x = CAST('heaptable' AS REGCLASS);
ROLLBACK;
/* ALTER MATERIALIZED VIEW SET ACCESS METHOD */ CREATE MATERIALIZED VIEW x WITH (FORMAT=heap) AS SELECT * FROM x;
SELECT x FROM x AS x, x AS x WHERE x.x = x.x AND x.x = CAST('heapmv' AS REGCLASS);
ALTER MATERIALIZED VIEW heapmv SET ACCESS METHOD heap2;
SELECT x FROM x AS x, x AS x WHERE x.x = x.x AND x.x = CAST('heapmv' AS REGCLASS);
SELECT COUNT(x), COUNT(1) FILTER(WHERE x = 1) FROM x;
/* No support for multiple subcommands */ ALTER TABLE heaptable SET ACCESS METHOD heap, SET ACCESS METHOD heap2;
ALTER TABLE heaptable SET ACCESS METHOD DEFAULT, SET ACCESS METHOD heap2;
ALTER MATERIALIZED VIEW heapmv SET ACCESS METHOD heap, SET ACCESS METHOD heap2;
DROP MATERIALIZED VIEW x;
DROP TABLE x;
/* Partitioned table with USING */ CREATE TABLE x (x INT, x INT) WITH (PARTITIONED_BY=HASH(x), FORMAT=heap2);
SELECT PG_DESCRIBE_OBJECT(x, x, x) AS x, PG_DESCRIBE_OBJECT(x, x, x) AS x FROM x, x WHERE x.x = CAST('pg_am' AS REGCLASS) AND x.x = x.x AND x.x = CAST('am_partitioned' AS REGCLASS);
DROP TABLE x;
/* Partition hierarchies with access methods */ BEGIN;
SET LOCAL x = 'heap';
CREATE TABLE x (x INT, x INT) WITH (PARTITIONED_BY=HASH(x));
/* pg_class.relam is 0, no dependency recorded between the AM and the */ /* partitioned table. */ SELECT x FROM x WHERE x = 'am_partitioned';
SELECT PG_DESCRIBE_OBJECT(x, x, x) AS x, PG_DESCRIBE_OBJECT(x, x, x) AS x FROM x, x WHERE x.x = CAST('pg_am' AS REGCLASS) AND x.x = x.x AND x.x = CAST('am_partitioned' AS REGCLASS);
ALTER TABLE x SET  /* New default is set, with dependency added. */;
SELECT x.x FROM x AS x, x AS x WHERE x.x = 'am_partitioned' AND x.x = x.x;
SELECT PG_DESCRIBE_OBJECT(x, x, x) AS x, PG_DESCRIBE_OBJECT(x, x, x) AS x FROM x, x WHERE x.x = CAST('pg_am' AS REGCLASS) AND x.x = x.x AND x.x = CAST('am_partitioned' AS REGCLASS);
SET LOCAL x = 'heap2' /* Default is set, with dependency updated. */;
ALTER TABLE x SET;
SELECT x.x FROM x AS x, x AS x WHERE x.x = 'am_partitioned' AND x.x = x.x;
/* Dependency pinned, hence removed. */ SELECT PG_DESCRIBE_OBJECT(x, x, x) AS x, PG_DESCRIBE_OBJECT(x, x, x) AS x FROM x, x WHERE x.x = CAST('pg_am' AS REGCLASS) AND x.x = x.x AND x.x = CAST('am_partitioned' AS REGCLASS);
SET LOCAL x = 'heap2' /* Default and AM set in the clause are the same, relam should be set. */;
ALTER TABLE x SET;
SELECT x.x FROM x AS x, x AS x WHERE x.x = 'am_partitioned' AND x.x = x.x;
ALTER TABLE x SET  /* Reset to default */;
SELECT x FROM x WHERE x = 'am_partitioned';
/* Upon ALTER TABLE SET ACCESS METHOD on a partitioned table, new partitions */ /* will inherit the AM set.  Existing partitioned are unchanged. */ SELECT x FROM x WHERE x = 'am_partitioned';
SET LOCAL x = 'heap';
CREATE TABLE x PARTITION OF x FOR VALUES WITH (MODULUS 10, REMAINDER 0);
SET LOCAL x = 'heap2';
CREATE TABLE x PARTITION OF x FOR VALUES WITH (MODULUS 10, REMAINDER 1);
SET LOCAL x = 'heap';
ALTER TABLE x SET;
CREATE TABLE x PARTITION OF x FOR VALUES WITH (MODULUS 10, REMAINDER 2);
ALTER TABLE x SET;
SELECT x FROM x WHERE x = 'am_partitioned';
CREATE TABLE x PARTITION OF x FOR VALUES WITH (MODULUS 10, REMAINDER 3);
ALTER TABLE x SET  /* Partitioned table with relam at 0 */;
CREATE TABLE x PARTITION OF x FOR VALUES WITH (MODULUS 10, REMAINDER 5) WITH (PARTITIONED_BY=HASH(x));
/* Partitions of this partitioned table inherit default AM at creation */ /* time. */ CREATE TABLE x PARTITION OF x FOR VALUES WITH (MODULUS 10, REMAINDER 1);
ALTER TABLE x SET  /* Partitioned table with relam set. */;
CREATE TABLE x PARTITION OF x FOR VALUES WITH (MODULUS 10, REMAINDER 6) WITH (PARTITIONED_BY=HASH(x));
/* Partitions of this partitioned table inherit its AM. */ CREATE TABLE x PARTITION OF x FOR VALUES WITH (MODULUS 10, REMAINDER 1);
SELECT x.x, x.x FROM x AS x, x AS x WHERE x.x = x.x AND x.x LIKE 'am_partitioned%' UNION ALL SELECT x.x, 'default' FROM x AS x WHERE x.x = 0 AND x.x LIKE 'am_partitioned%' ORDER BY 1 NULLS LAST;
DROP TABLE x;
COMMIT;
/* Second, create objects in the new AM by changing the default AM */ BEGIN;
SET LOCAL x = 'heap2';
/* following tests should all respect the default AM */ CREATE TABLE x (x INT);
CREATE TABLE x AS SELECT * FROM x;
CREATE TABLE x AS SELECT FROM x;
CREATE MATERIALIZED VIEW x WITH (FORMAT=heap2) AS SELECT * FROM x;
CREATE TABLE x (x TEXT, x INT) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN ('a', 'b');
/* but an explicitly set AM overrides it */ CREATE TABLE x PARTITION OF x FOR VALUES IN ('c', 'd') WITH (FORMAT=heap);
/* sequences, views and foreign servers shouldn't have an AM */ CREATE VIEW x AS SELECT * FROM x;
CREATE SEQUENCE x;
CREATE FOREIGN DATA WRAPPER fdw_heap2 VALIDATOR postgresql_fdw_validator;
CREATE SERVER fs_heap2 FOREIGN DATA WRAPPER fdw_heap2;
CREATE FOREIGN table tableam_fdw_heapx () SERVER fs_heap2;
/* Verify that new AM was used for tables, matviews, but not for sequences, views and fdws */ SELECT x.x, x.x, CASE WHEN x = 't' THEN (SELECT 'toast for ' || CAST(x AS REGCLASS) FROM x AS x WHERE x.x = x.x) ELSE CAST(CAST(x AS REGCLASS) AS TEXT) END COLLATE "x" AS x FROM x AS x LEFT JOIN x AS x ON (x.x = x.x) WHERE x.x LIKE 'tableam_%_heapx' ORDER BY 3 NULLS LAST, 1 NULLS LAST, 2 NULLS LAST;
ROLLBACK /* don't want to keep those tables, nor the default */ /* don't want to keep those tables, nor the default */;
/* Third, check that we can neither create a table using a nonexistent */ /* AM, nor using an index AM */ CREATE TABLE x WITH (FORMAT="x");
CREATE TABLE x WITH (FORMAT=i_do_not_exist_am);
CREATE TABLE x WITH (FORMAT="x");
CREATE TABLE x WITH (FORMAT="x");
/* Other weird invalid cases that cause problems */ CREATE FOREIGN TABLE fp PARTITION OF tableam_parted_a_heap2 DEFAULT SERVER x;
/* Drop table access method, which fails as objects depends on it */ DROP ACCESS METHOD heap2;
/* CREATE_CAST */ /* Create some types to test with */ CREATE TYPE casttesttype;
CREATE FUNCTION x(x) RETURNS casttesttype LANGUAGE internal STRICT IMMUTABLE AS 'textin';
CREATE FUNCTION x(x) RETURNS CSTRING LANGUAGE internal STRICT IMMUTABLE AS 'textout';
CREATE TYPE casttesttype (    internallength = variable,    input = casttesttype_in,    output = casttesttype_out,    alignment = int4 );
SELECT CASTTESTFUNC(CAST('foo' AS TEXT));
/* fails, as there's no cast */ /* Try binary coercion cast */ CREATE CAST (text AS casttesttype) WITHOUT FUNCTION;
SELECT CASTTESTFUNC(CAST('foo' AS TEXT));
/* doesn't work, as the cast is explicit */ SELECT CASTTESTFUNC(CAST(CAST('foo' AS TEXT) AS casttesttype));
/* should work */ DROP CAST (text AS casttesttype);
/* cleanup */ /* Try IMPLICIT binary coercion cast */ CREATE CAST (text AS casttesttype) WITHOUT FUNCTION AS IMPLICIT;
SELECT CASTTESTFUNC(CAST('foo' AS TEXT));
/* Should work now */ /* Try I/O conversion cast. */ SELECT CAST(CAST(1234 AS INT) AS casttesttype);
/* No cast yet, should fail */ CREATE CAST (int4 AS casttesttype) WITH INOUT;
SELECT CAST(CAST(1234 AS INT) AS casttesttype);
/* Should work now */ DROP CAST (int4 AS casttesttype);
CREATE CAST (int4 AS casttesttype) WITH FUNCTION int4_casttesttype(int4) AS IMPLICIT;
SELECT CAST(CAST(1234 AS INT) AS casttesttype);
/* Should work now */ DROP FUNCTION x (INT) CASCADE;
CREATE CAST (int4 AS casttesttype) WITH FUNCTION bar_int4_text(int4) AS IMPLICIT;
SELECT CAST(CAST(1234 AS INT) AS casttesttype);
/* Should work now */ /* check dependencies generated for that */ SELECT PG_DESCRIBE_OBJECT(x, x, x) AS x, PG_DESCRIBE_OBJECT(x, x, x) AS x, x FROM x WHERE x = CAST('pg_cast' AS REGCLASS) AND x = (SELECT x FROM x WHERE x = CAST('int4' AS REGTYPE) AND x = CAST('casttesttype' AS REGTYPE)) ORDER BY x NULLS LAST;
/* Things that shouldn't work: */ CREATE FUNCTION x(x) RETURNS INT LANGUAGE C AS 'nosuchfile';
CREATE FUNCTION x(x) RETURNS INT LANGUAGE internal AS 'nosuch';
/* CREATE_FUNCTION_SQL */ /* Assorted tests using SQL-language functions */ /* All objects made in this test are in temp_func_test schema */ CREATE USER regress_unpriv_user;
CREATE SCHEMA x.x;
GRANT ALL ON SCHEMA x TO x;
SET search_path TO temp_func_test, public;
/* Make sanity checks on the pg_proc entries created by CREATE FUNCTION */ /* ARGUMENT and RETURN TYPES */ CREATE FUNCTION x(x, x) RETURNS BOOLEAN LANGUAGE 'sql' AS 'SELECT $1 = ''abcd'' AND $2 > ''2001-01-01''';
CREATE FUNCTION x() RETURNS BOOLEAN LANGUAGE 'sql' AS 'SELECT false';
SELECT FUNCTEST_A_1('abcd', '2020-01-01');
SELECT FUNCTEST_A_2(ARRAY('1', '2', '3'));
SELECT FUNCTEST_A_3();
/* IMMUTABLE | STABLE | VOLATILE */ CREATE FUNCTION x(x) RETURNS BOOLEAN LANGUAGE 'sql' AS 'SELECT $1 > 0';
CREATE FUNCTION x(x) RETURNS BOOLEAN LANGUAGE 'sql' IMMUTABLE AS 'SELECT $1 > 0';
CREATE FUNCTION x(x) RETURNS BOOLEAN LANGUAGE 'sql' STABLE AS 'SELECT $1 = 0';
CREATE FUNCTION x(x) RETURNS BOOLEAN LANGUAGE 'sql' VOLATILE AS 'SELECT $1 < 0';
SELECT x, x FROM x WHERE x IN (CAST('functest_B_1' AS REGPROC), CAST('functest_B_2' AS REGPROC), CAST('functest_B_3' AS REGPROC), CAST('functest_B_4' AS REGPROC)) ORDER BY x NULLS LAST;
ALTER FUNCTION functest_B_2(int) VOLATILE;
ALTER FUNCTION functest_B_3(int) COST 100;
/* unrelated change, no effect */ SELECT x, x FROM x WHERE x IN (CAST('functest_B_1' AS REGPROC), CAST('functest_B_2' AS REGPROC), CAST('functest_B_3' AS REGPROC), CAST('functest_B_4' AS REGPROC)) ORDER BY x NULLS LAST;
/* SECURITY DEFINER | INVOKER */ CREATE FUNCTION x(x) RETURNS BOOLEAN LANGUAGE 'sql' AS 'SELECT $1 > 0';
CREATE FUNCTION x(x) RETURNS BOOLEAN LANGUAGE 'sql' SECURITY DEFINER AS 'SELECT $1 = 0';
CREATE FUNCTION x(x) RETURNS BOOLEAN LANGUAGE 'sql' SECURITY INVOKER AS 'SELECT $1 < 0';
SELECT x, x FROM x WHERE x IN (CAST('functest_C_1' AS REGPROC), CAST('functest_C_2' AS REGPROC), CAST('functest_C_3' AS REGPROC)) ORDER BY x NULLS LAST;
ALTER FUNCTION functest_C_1(int) IMMUTABLE;
/* unrelated change, no effect */ ALTER FUNCTION functest_C_2(int) SECURITY INVOKER;
ALTER FUNCTION functest_C_3(int) SECURITY DEFINER;
SELECT x, x FROM x WHERE x IN (CAST('functest_C_1' AS REGPROC), CAST('functest_C_2' AS REGPROC), CAST('functest_C_3' AS REGPROC)) ORDER BY x NULLS LAST;
/* LEAKPROOF */ CREATE FUNCTION x(x) RETURNS BOOLEAN LANGUAGE 'sql' AS 'SELECT $1 > 100';
CREATE FUNCTION x(x) RETURNS BOOLEAN LANGUAGE 'sql' AS x AS "x";
SELECT x, x FROM x WHERE x IN (CAST('functest_E_1' AS REGPROC), CAST('functest_E_2' AS REGPROC)) ORDER BY x NULLS LAST;
ALTER FUNCTION functest_E_1(int) LEAKPROOF;
ALTER FUNCTION functest_E_2(int) STABLE;
/* unrelated change, no effect */ SELECT x, x FROM x WHERE x IN (CAST('functest_E_1' AS REGPROC), CAST('functest_E_2' AS REGPROC)) ORDER BY x NULLS LAST;
ALTER FUNCTION functest_E_2(int) NOT LEAKPROOF;
/* remove leakproof attribute */ SELECT x, x FROM x WHERE x IN (CAST('functest_E_1' AS REGPROC), CAST('functest_E_2' AS REGPROC)) ORDER BY x NULLS LAST;
/* it takes superuser privilege to turn on leakproof, but not to turn off */ ALTER FUNCTION functest_E_1(int) OWNER TO regress_unpriv_user;
ALTER FUNCTION functest_E_2(int) OWNER TO regress_unpriv_user;
SET SESSION AUTHORIZATION regress_unpriv_user;
SET search_path TO temp_func_test, public;
ALTER FUNCTION functest_E_1(int) NOT LEAKPROOF;
ALTER FUNCTION functest_E_2(int) LEAKPROOF;
CREATE FUNCTION x(x) RETURNS BOOLEAN LANGUAGE 'sql' AS x AS "x";
/* fail */ RESET SESSION AUTHORIZATION;
/* CALLED ON NULL INPUT | RETURNS NULL ON NULL INPUT | STRICT */ CREATE FUNCTION x(x) RETURNS BOOLEAN LANGUAGE 'sql' AS 'SELECT $1 > 50';
CREATE FUNCTION functest_F_2(int) RETURNS bool LANGUAGE 'sql'        CALLED ON NULL INPUT AS 'SELECT $1 = 50';
CREATE FUNCTION x(x) RETURNS BOOLEAN LANGUAGE 'sql' RETURNS NULL ON NULL INPUT AS 'SELECT $1 < 50';
CREATE FUNCTION x(x) RETURNS BOOLEAN LANGUAGE 'sql' STRICT AS 'SELECT $1 = 50';
SELECT x, x FROM x WHERE x IN (CAST('functest_F_1' AS REGPROC), CAST('functest_F_2' AS REGPROC), CAST('functest_F_3' AS REGPROC), CAST('functest_F_4' AS REGPROC)) ORDER BY x NULLS LAST;
ALTER FUNCTION functest_F_1(int) IMMUTABLE;
/* unrelated change, no effect */ ALTER FUNCTION functest_F_2(int) STRICT;
ALTER FUNCTION functest_F_3(int) CALLED ON NULL INPUT;
SELECT x, x FROM x WHERE x IN (CAST('functest_F_1' AS REGPROC), CAST('functest_F_2' AS REGPROC), CAST('functest_F_3' AS REGPROC), CAST('functest_F_4' AS REGPROC)) ORDER BY x NULLS LAST;
/* pg_get_functiondef tests */ SELECT PG_GET_FUNCTIONDEF(CAST('functest_A_1' AS REGPROC));
SELECT PG_GET_FUNCTIONDEF(CAST('functest_B_3' AS REGPROC));
SELECT PG_GET_FUNCTIONDEF(CAST('functest_C_3' AS REGPROC));
SELECT PG_GET_FUNCTIONDEF(CAST('functest_F_2' AS REGPROC));
/* SQL-standard body */ CREATE FUNCTION x(x TEXT, x DATE) RETURNS BOOLEAN LANGUAGE SQL AS RETURN x = 'abcd' AND x > '2001-01-01';
CREATE FUNCTION x(x ARRAY<TEXT>) RETURNS INT AS RETURN CAST(x[0] AS INT);
CREATE FUNCTION x() RETURNS BOOLEAN AS RETURN FALSE;
CREATE FUNCTION x() RETURNS BOOLEAN AS BEGIN ATOMIC;
x AS x;
COMMIT;
CREATE FUNCTION x(x TEXT, x DATE) RETURNS BOOLEAN LANGUAGE SQL AS BEGIN ATOMIC         SELECT a = 'abcd' AND b > '2001-01-01';
COMMIT;
CREATE FUNCTION x() RETURNS BOOLEAN AS BEGIN ATOMIC         SELECT 1;
SELECT FALSE;
COMMIT;
/* check display of function arguments in sub-SELECT */ CREATE TABLE x (x INT);
CREATE FUNCTION x(x INT, x INT) RETURNS void LANGUAGE SQL AS BEGIN ATOMIC         INSERT INTO functest1 SELECT a + $2;
COMMIT;
/* error: duplicate function body */ CREATE FUNCTION functest_S_xxx(x int) RETURNS int     LANGUAGE SQL     AS $$ SELECT x * 2 $$     RETURN x * 3;
/* polymorphic arguments not allowed in this form */ CREATE FUNCTION x(x anyarray) RETURNS anyelement LANGUAGE SQL AS RETURN x[0];
/* check reporting of parse-analysis errors */ CREATE FUNCTION x(x DATE) RETURNS BOOLEAN LANGUAGE SQL AS RETURN x > 1;
/* tricky parsing */ CREATE FUNCTION x(x INT) RETURNS BOOLEAN LANGUAGE SQL AS BEGIN ATOMIC     select case when x % 2 = 0 then true else false end;
COMMIT;
SELECT FUNCTEST_S_1('abcd', '2020-01-01');
SELECT FUNCTEST_S_2(ARRAY('1', '2', '3'));
SELECT FUNCTEST_S_3();
SELECT FUNCTEST_S_10('abcd', '2020-01-01');
SELECT FUNCTEST_S_13();
SELECT PG_GET_FUNCTIONDEF(CAST('functest_S_1' AS REGPROC));
SELECT PG_GET_FUNCTIONDEF(CAST('functest_S_2' AS REGPROC));
SELECT PG_GET_FUNCTIONDEF(CAST('functest_S_3' AS REGPROC));
SELECT PG_GET_FUNCTIONDEF(CAST('functest_S_3a' AS REGPROC));
SELECT PG_GET_FUNCTIONDEF(CAST('functest_S_10' AS REGPROC));
SELECT PG_GET_FUNCTIONDEF(CAST('functest_S_13' AS REGPROC));
SELECT PG_GET_FUNCTIONDEF(CAST('functest_S_15' AS REGPROC));
SELECT PG_GET_FUNCTIONDEF(CAST('functest_S_16' AS REGPROC));
DROP TABLE x CASCADE;
/* test with views */ CREATE TABLE x (x INT);
INSERT INTO x VALUES (1), (2);
CREATE VIEW x AS SELECT * FROM x;
CREATE FUNCTION x() RETURNS BIGINT AS RETURN (SELECT COUNT(*) FROM x);
SELECT FUNCTEST_S_14();
DROP TABLE x CASCADE;
/* information_schema tests */ CREATE FUNCTION x(x INT, x INT DEFAULT 1, x TEXT DEFAULT 'foo') RETURNS INT LANGUAGE SQL AS 'SELECT $1 + $2';
SELECT x, x, x, x FROM x.x JOIN x.x USING (x, x) WHERE x = 'temp_func_test' AND REGEXP_LIKE(x, '^functest_is_') ORDER BY 1 NULLS LAST, 2 NULLS LAST;
/* routine usage views */ CREATE FUNCTION x() RETURNS INT LANGUAGE SQL AS 'SELECT 1';
CREATE FUNCTION x(x INT DEFAULT FUNCTEST_IS_4A()) RETURNS INT LANGUAGE SQL AS 'SELECT x';
CREATE SEQUENCE x;
CREATE FUNCTION x(x INT DEFAULT NEXTVAL('functest1')) RETURNS INT LANGUAGE SQL AS 'SELECT x';
CREATE FUNCTION x() RETURNS INT LANGUAGE SQL AS RETURN NEXTVAL('functest1');
CREATE TABLE x (x INT, x INT);
CREATE FUNCTION x() RETURNS INT LANGUAGE SQL AS RETURN (SELECT COUNT(x) FROM x);
SELECT x.x, x.x FROM x.x AS x JOIN x.x AS x ON x.x = x.x JOIN x.x AS x ON x.x = x.x WHERE x.x = 'temp_func_test' AND x.x = 'temp_func_test' ORDER BY 1 NULLS LAST, 2 NULLS LAST;
SELECT x, x FROM x.x WHERE x = 'temp_func_test' ORDER BY 1 NULLS LAST, 2 NULLS LAST;
SELECT x, x, x FROM x.x WHERE x = 'temp_func_test' ORDER BY 1 NULLS LAST, 2 NULLS LAST;
SELECT x, x FROM x.x WHERE x = 'temp_func_test' ORDER BY 1 NULLS LAST, 2 NULLS LAST;
DROP FUNCTION x CASCADE;
DROP SEQUENCE x CASCADE;
DROP TABLE x CASCADE;
/* overload */ CREATE FUNCTION x(x) RETURNS BOOLEAN LANGUAGE 'sql' IMMUTABLE AS 'SELECT $1 > 0';
DROP FUNCTION x;
DROP FUNCTION x;
/* error, not found */ DROP FUNCTION x;
/* error, ambiguous */ /* CREATE OR REPLACE tests */ CREATE FUNCTION x(x INT) RETURNS INT LANGUAGE SQL AS 'SELECT $1';
CREATE OR REPLACE FUNCTION x(x INT) RETURNS INT LANGUAGE SQL AS x AS "x";
CREATE OR REPLACE PROCEDURE x(x INT) LANGUAGE SQL AS 'SELECT $1';
/* inlining of set-returning functions */ CREATE TABLE x (x INT);
INSERT INTO x VALUES (1), (2), (3);
SELECT * FROM x;
EXPLAIN (verbose, costs off) SELECT * FROM functest_sri1();
CREATE FUNCTION functest_sri2() RETURNS SETOF int LANGUAGE SQL STABLE BEGIN ATOMIC     SELECT * FROM functest3;
COMMIT;
SELECT * FROM x;
EXPLAIN (verbose, costs off) SELECT * FROM functest_sri2();
DROP TABLE x CASCADE;
/* Check behavior of VOID-returning SQL functions */ CREATE FUNCTION x(x INT) RETURNS VOID LANGUAGE SQL AS $$ SELECT a + 1 $$;
SELECT VOIDTEST1(42);
CREATE FUNCTION x(x INT, x INT) RETURNS VOID LANGUAGE SQL AS $$ SELECT voidtest1(a + b) $$;
SELECT VOIDTEST2(11, 22);
/* currently, we can inline voidtest2 but not voidtest1 */ EXPLAIN (verbose, costs off) SELECT voidtest2(11,22);
CREATE TEMPORARY TABLE x (x INT);
CREATE FUNCTION x(x INT) RETURNS VOID LANGUAGE SQL AS $$ INSERT INTO sometable VALUES(a + 1) $$;
SELECT VOIDTEST3(17);
CREATE FUNCTION x(x INT) RETURNS VOID LANGUAGE SQL AS $$ INSERT INTO sometable VALUES(a - 1) RETURNING f1 $$;
SELECT VOIDTEST4(39);
x AS x;
CREATE FUNCTION voidtest5(a int) RETURNS SETOF VOID LANGUAGE SQL AS $$ SELECT generate_series(1, a) $$ STABLE;
SELECT * FROM x;
/* Regression tests for bugs: */ /* Check that arguments that are R/W expanded datums aren't corrupted by */ /* multiple uses.  This test knows that array_append() returns a R/W datum */ /* and will modify a R/W array input in-place.  We use SETOF to prevent */ /* inlining of the SQL function. */ CREATE FUNCTION double_append(anyarray, anyelement) RETURNS SETOF anyarray LANGUAGE SQL IMMUTABLE AS $$ SELECT array_append($1, $2) || array_append($1, $2) $$;
SELECT DOUBLE_APPEND(ARRAY_APPEND(ARRAY(x), x), x) FROM (VALUES (1, 2, 3), (4, 5, 6)) AS x;
CREATE FUNCTION x(x) RETURNS INT LANGUAGE SQL AS 'not even SQL';
CREATE FUNCTION test1 (int) RETURNS int LANGUAGE SQL     AS 'a', 'b';
/* Cleanup */ DROP SCHEMA x.x CASCADE;
DROP USER regress_unpriv_user;
RESET search_path;
CREATE INDEX IF NOT EXISTS x ON x USING btree(x x NULLS LAST);
CREATE INDEX IF NOT EXISTS ON x USING btree(x x NULLS LAST);
CREATE INDEX x ON x USING btree(x x NULLS LAST);
CREATE INDEX x ON x USING btree(x x NULLS LAST);
CREATE INDEX x ON x USING btree(x x NULLS LAST);
CREATE INDEX x ON x USING btree(x x NULLS LAST);
CREATE INDEX x ON x USING btree(x x NULLS LAST);
CREATE INDEX x ON x USING btree(x x NULLS LAST);
CREATE INDEX x ON x(x NULLS LAST, x NULLS LAST);
CREATE INDEX x ON x USING btree(x x NULLS LAST);
CREATE INDEX x ON x USING btree(x x NULLS LAST);
CREATE INDEX x ON x USING btree(x x NULLS LAST);
CREATE INDEX x ON x USING btree(x x NULLS LAST);
CREATE INDEX x ON x USING btree(x x NULLS LAST);
CREATE INDEX x ON x USING btree(x x NULLS LAST);
COMMENT ON INDEX x IS 'bad index' /* test comments */;
COMMENT ON INDEX x IS 'good index';
/* BTREE partial indices */ CREATE INDEX x ON x USING btree(x x NULLS LAST) WHERE x < 20 OR x > 980;
CREATE INDEX x ON x USING btree(x x NULLS LAST) WHERE x < 'B';
CREATE INDEX x ON x USING btree(x x NULLS LAST) WHERE x.x >= 'J' AND x.x < 'K';
/* GiST (rtree-equivalent opclasses only) */ CREATE TABLE x (x box);
CREATE TABLE x (x box);
INSERT INTO x SELECT * FROM x;
ANALYZE x;
ANALYZE x;
CREATE INDEX x ON x USING gist(x NULLS LAST);
/* we want to work with a point_tbl that includes a null */ CREATE TEMPORARY TABLE x AS SELECT * FROM x.x;
INSERT INTO x (x) VALUES (NULL);
CREATE INDEX x ON x USING gist(x NULLS LAST);
CREATE TEMPORARY TABLE x AS SELECT POLYGON(x) AS x FROM x;
INSERT INTO x VALUES ('(1000,0,0,1000)');
INSERT INTO x VALUES ('(0,1000,1000,1000)');
CREATE TEMPORARY TABLE x AS SELECT CIRCLE(x) AS x FROM x;
CREATE INDEX x ON x USING gist(x NULLS LAST);
CREATE INDEX x ON x USING gist(x NULLS LAST);
SET x = ON /* Test GiST indexes */ /* get non-indexed results for comparison purposes */;
SET x = OFF;
SET x = OFF;
SELECT * FROM x WHERE CAST('(200,200),(2000,1000)' AS box) @> x ORDER BY (x[-1])[-1] NULLS LAST;
SELECT COUNT(*) FROM x WHERE x && CAST('(1000,1000,0,0)' AS box);
SELECT COUNT(*) FROM x WHERE x IS NULL;
SELECT COUNT(*) FROM x WHERE x && CAST('(1000,1000,0,0)' AS polygon);
SELECT COUNT(*) FROM x WHERE x && CAST('<(500,500),500>' AS circle);
SELECT COUNT(*) FROM x AS x WHERE x.x << '(0.0, 0.0)';
SELECT COUNT(*) FROM x AS x WHERE x.x >> '(0.0, 0.0)';
SELECT * FROM x ORDER BY x <-> '0,1' NULLS LAST;
SELECT * FROM x WHERE x IS NULL;
SELECT * FROM x WHERE NOT x IS NULL ORDER BY x <-> '0,1' NULLS LAST;
SELECT * FROM x WHERE CAST('(-10,-10),(10,10)' AS box) @> x ORDER BY x <-> '0,1' NULLS LAST;
SELECT * FROM x ORDER BY x <-> CAST('(0,0)' AS point) NULLS LAST LIMIT 10;
SELECT CIRCLE_CENTER(x), ROUND(RADIUS(x)) AS x FROM x ORDER BY x <-> CAST('(200,300)' AS point) NULLS LAST LIMIT 10;
SET x = OFF /* Now check the results from plain indexscan */;
SET x = ON;
SET x = OFF;
EXPLAIN (COSTS OFF) SELECT * FROM fast_emp4000     WHERE home_base <@ '(200,200),(2000,1000)'::box     ORDER BY (home_base[0])[0];
SELECT * FROM x WHERE CAST('(200,200),(2000,1000)' AS box) @> x ORDER BY (x[-1])[-1] NULLS LAST;
EXPLAIN (COSTS OFF) SELECT count(*) FROM fast_emp4000 WHERE home_base && '(1000,1000,0,0)'::box;
SELECT COUNT(*) FROM x WHERE x && CAST('(1000,1000,0,0)' AS box);
EXPLAIN (COSTS OFF) SELECT count(*) FROM fast_emp4000 WHERE home_base IS NULL;
SELECT COUNT(*) FROM x WHERE x IS NULL;
EXPLAIN (COSTS OFF) SELECT count(*) FROM gpolygon_tbl WHERE f1 && '(1000,1000,0,0)'::polygon;
SELECT COUNT(*) FROM x WHERE x && CAST('(1000,1000,0,0)' AS polygon);
EXPLAIN (COSTS OFF) SELECT count(*) FROM gcircle_tbl WHERE f1 && '<(500,500),500>'::circle;
SELECT COUNT(*) FROM x WHERE x && CAST('<(500,500),500>' AS circle);
EXPLAIN (COSTS OFF) SELECT count(*) FROM point_tbl WHERE f1 <@ box '(0,0,100,100)';
EXPLAIN (COSTS OFF) SELECT count(*) FROM point_tbl WHERE box '(0,0,100,100)' @> f1;
EXPLAIN (COSTS OFF) SELECT count(*) FROM point_tbl WHERE f1 <@ polygon '(0,0),(0,100),(100,100),(50,50),(100,0),(0,0)';
EXPLAIN (COSTS OFF) SELECT count(*) FROM point_tbl WHERE f1 <@ circle '<(50,50),50>';
EXPLAIN (COSTS OFF) SELECT count(*) FROM point_tbl p WHERE p.f1 << '(0.0, 0.0)';
SELECT COUNT(*) FROM x AS x WHERE x.x << '(0.0, 0.0)';
EXPLAIN (COSTS OFF) SELECT count(*) FROM point_tbl p WHERE p.f1 >> '(0.0, 0.0)';
SELECT COUNT(*) FROM x AS x WHERE x.x >> '(0.0, 0.0)';
EXPLAIN (COSTS OFF) SELECT count(*) FROM point_tbl p WHERE p.f1 <<| '(0.0, 0.0)';
EXPLAIN (COSTS OFF) SELECT count(*) FROM point_tbl p WHERE p.f1 |>> '(0.0, 0.0)';
EXPLAIN (COSTS OFF) SELECT count(*) FROM point_tbl p WHERE p.f1 ~= '(-5, -12)';
EXPLAIN (COSTS OFF) SELECT * FROM point_tbl ORDER BY f1 <-> '0,1';
SELECT * FROM x ORDER BY x <-> '0,1' NULLS LAST;
EXPLAIN (COSTS OFF) SELECT * FROM point_tbl WHERE f1 IS NULL;
SELECT * FROM x WHERE x IS NULL;
EXPLAIN (COSTS OFF) SELECT * FROM point_tbl WHERE f1 IS NOT NULL ORDER BY f1 <-> '0,1';
SELECT * FROM x WHERE NOT x IS NULL ORDER BY x <-> '0,1' NULLS LAST;
EXPLAIN (COSTS OFF) SELECT * FROM point_tbl WHERE f1 <@ '(-10,-10),(10,10)':: box ORDER BY f1 <-> '0,1';
SELECT * FROM x WHERE CAST('(-10,-10),(10,10)' AS box) @> x ORDER BY x <-> '0,1' NULLS LAST;
EXPLAIN (COSTS OFF) SELECT * FROM gpolygon_tbl ORDER BY f1 <-> '(0,0)'::point LIMIT 10;
SELECT * FROM x ORDER BY x <-> CAST('(0,0)' AS point) NULLS LAST LIMIT 10;
EXPLAIN (COSTS OFF) SELECT circle_center(f1), round(radius(f1)) as radius FROM gcircle_tbl ORDER BY f1 <-> '(200,300)'::point LIMIT 10;
SELECT CIRCLE_CENTER(x), ROUND(RADIUS(x)) AS x FROM x ORDER BY x <-> CAST('(200,300)' AS point) NULLS LAST LIMIT 10;
EXPLAIN (COSTS OFF) SELECT point(x,x), (SELECT f1 FROM gpolygon_tbl ORDER BY f1 <-> point(x,x) LIMIT 1) as c FROM generate_series(0,10,1) x;
SELECT POINT(x, x), (SELECT x FROM x ORDER BY x <-> POINT(x, x) NULLS LAST LIMIT 1) AS x FROM x AS x;
SET x = OFF /* Now check the results from bitmap indexscan */;
SET x = OFF;
SET x = ON;
EXPLAIN (COSTS OFF) SELECT * FROM point_tbl WHERE f1 <@ '(-10,-10),(10,10)':: box ORDER BY f1 <-> '0,1';
SELECT * FROM x WHERE CAST('(-10,-10),(10,10)' AS box) @> x ORDER BY x <-> '0,1' NULLS LAST;
RESET enable_seqscan;
RESET enable_indexscan;
RESET enable_bitmapscan;
/* GIN over int[] and text[] */ /* Note: GIN currently supports only bitmap scans, not plain indexscans */ CREATE TABLE x (x INT, x ARRAY<INT>, x ARRAY<TEXT>);
ANALYZE x;
SELECT * FROM x WHERE x = '{NULL}' ORDER BY x NULLS LAST;
SELECT * FROM x WHERE x @> '{NULL}' ORDER BY x NULLS LAST;
SELECT * FROM x WHERE x && '{NULL}' ORDER BY x NULLS LAST;
SELECT * FROM x WHERE '{NULL}' @> x ORDER BY x NULLS LAST;
SET x = OFF;
SET x = OFF;
SET x = ON;
CREATE INDEX x ON x USING gin(x NULLS LAST);
EXPLAIN (costs off) SELECT * FROM array_index_op_test WHERE i @> '{32}' ORDER BY seqno;
SELECT * FROM x WHERE x @> '{32}' ORDER BY x NULLS LAST;
SELECT * FROM x WHERE x && '{32}' ORDER BY x NULLS LAST;
SELECT * FROM x WHERE x @> '{17}' ORDER BY x NULLS LAST;
SELECT * FROM x WHERE x && '{17}' ORDER BY x NULLS LAST;
SELECT * FROM x WHERE x @> '{32,17}' ORDER BY x NULLS LAST;
SELECT * FROM x WHERE x && '{32,17}' ORDER BY x NULLS LAST;
SELECT * FROM x WHERE '{38,34,32,89}' @> x ORDER BY x NULLS LAST;
SELECT * FROM x WHERE x = '{47,77}' ORDER BY x NULLS LAST;
SELECT * FROM x WHERE x = '{}' ORDER BY x NULLS LAST;
SELECT * FROM x WHERE x @> '{}' ORDER BY x NULLS LAST;
SELECT * FROM x WHERE x && '{}' ORDER BY x NULLS LAST;
SELECT * FROM x WHERE '{}' @> x ORDER BY x NULLS LAST;
CREATE INDEX x ON x USING gin(x NULLS LAST);
EXPLAIN (costs off) SELECT * FROM array_index_op_test WHERE t @> '{AAAAAAAA72908}' ORDER BY seqno;
SELECT * FROM x WHERE x @> '{AAAAAAAA72908}' ORDER BY x NULLS LAST;
SELECT * FROM x WHERE x && '{AAAAAAAA72908}' ORDER BY x NULLS LAST;
SELECT * FROM x WHERE x @> '{AAAAAAAAAA646}' ORDER BY x NULLS LAST;
SELECT * FROM x WHERE x && '{AAAAAAAAAA646}' ORDER BY x NULLS LAST;
SELECT * FROM x WHERE x @> '{AAAAAAAA72908,AAAAAAAAAA646}' ORDER BY x NULLS LAST;
SELECT * FROM x WHERE x && '{AAAAAAAA72908,AAAAAAAAAA646}' ORDER BY x NULLS LAST;
SELECT * FROM x WHERE '{AAAAAAAA72908,AAAAAAAAAAAAAAAAAAA17075,AA88409,AAAAAAAAAAAAAAAAAA36842,AAAAAAA48038,AAAAAAAAAAAAAA10611}' @> x ORDER BY x NULLS LAST;
SELECT * FROM x WHERE x = '{AAAAAAAAAA646,A87088}' ORDER BY x NULLS LAST;
SELECT * FROM x WHERE x = '{}' ORDER BY x NULLS LAST;
SELECT * FROM x WHERE x @> '{}' ORDER BY x NULLS LAST;
SELECT * FROM x WHERE x && '{}' ORDER BY x NULLS LAST;
SELECT * FROM x WHERE '{}' @> x ORDER BY x NULLS LAST;
CREATE INDEX x ON x USING gin(x NULLS LAST, x NULLS LAST);
SELECT * FROM x WHERE x @> '{32}' ORDER BY x NULLS LAST;
SELECT * FROM x WHERE x && '{32}' ORDER BY x NULLS LAST;
SELECT * FROM x WHERE x @> '{AAAAAAA80240}' ORDER BY x NULLS LAST;
SELECT * FROM x WHERE x && '{AAAAAAA80240}' ORDER BY x NULLS LAST;
SELECT * FROM x WHERE x @> '{32}' AND x && '{AAAAAAA80240}' ORDER BY x NULLS LAST;
SELECT * FROM x WHERE x && '{32}' AND x @> '{AAAAAAA80240}' ORDER BY x NULLS LAST;
SELECT * FROM x WHERE x = '{}' ORDER BY x NULLS LAST;
RESET enable_seqscan;
RESET enable_indexscan;
RESET enable_bitmapscan;
/* Try a GIN index with a lot of items with same key. (GIN creates a posting */ /* tree when there are enough duplicates) */ CREATE TABLE x (x ARRAY<INT>);
INSERT INTO x SELECT ARRAY(1, x % 5, x) FROM x AS x;
CREATE INDEX x ON x USING gin(x NULLS LAST);
SELECT COUNT(*) FROM x WHERE x @> '{2}';
DROP TABLE x;
/* Test GIN index's reloptions */ CREATE INDEX x ON x USING gin(x NULLS LAST) WITH (FASTUPDATE=on, GIN_PENDING_LIST_LIMIT=128);
CREATE INDEX x ON x USING hash(x x NULLS LAST);
DROP TABLE x;
SET x = '1MB' /* Test hash index build tuplesorting.  Force hash tuplesort using low */ /* maintenance_work_mem setting and fillfactor: */;
CREATE INDEX x ON x USING hash(x x NULLS LAST) WITH (fillfactor=10);
EXPLAIN (COSTS OFF) SELECT count(*) FROM tenk1 WHERE stringu1 = 'TVAAAA';
SELECT COUNT(*) FROM x WHERE x = 'TVAAAA';
SET x = off /* OR-clauses shouldn't be transformed into SAOP because hash indexes don't */ /* support SAOP scans. */;
EXPLAIN (COSTS OFF) SELECT COUNT(*) FROM tenk1 WHERE stringu1 = 'TVAAAA' OR  stringu1 = 'TVAAAB';
RESET enable_seqscan;
DROP INDEX x;
RESET maintenance_work_mem;
/* Test unique null behavior */ CREATE TABLE x (x INT, x TEXT);
CREATE UNIQUE INDEX unique_idx1 ON unique_tbl (i) NULLS DISTINCT;
CREATE UNIQUE INDEX unique_idx2 ON unique_tbl (i) NULLS NOT DISTINCT;
INSERT INTO x VALUES (1, 'one');
INSERT INTO x VALUES (2, 'two');
INSERT INTO x VALUES (3, 'three');
INSERT INTO x VALUES (4, 'four');
INSERT INTO x VALUES (5, 'one');
INSERT INTO x (x) VALUES ('six');
INSERT INTO x (x) VALUES ('seven');
INSERT INTO x (x) VALUES ('seven');
/* build indexes on filled table */ CREATE UNIQUE INDEX unique_idx3 ON unique_tbl (i) NULLS DISTINCT;
/* ok */ CREATE UNIQUE INDEX unique_idx4 ON unique_tbl (i) NULLS NOT DISTINCT;
/* error */ DELETE FROM x WHERE x = 'seven';
CREATE UNIQUE INDEX unique_idx4 ON unique_tbl (i) NULLS NOT DISTINCT;
SELECT PG_GET_INDEXDEF(CAST('unique_idx4' AS REGCLASS));
DROP TABLE x;
/* Test functional index */ CREATE TABLE x (x TEXT, x TEXT);
CREATE UNIQUE INDEX x ON x(TEXTCAT(x, x) NULLS LAST);
INSERT INTO x VALUES ('ABC', 'DEF');
INSERT INTO x VALUES ('AB', 'CDEFG');
INSERT INTO x VALUES ('QWE', 'RTY');
/* this should fail because of unique index: */ INSERT INTO x VALUES ('ABCD', 'EF');
/* but this shouldn't: */ INSERT INTO x VALUES ('QWERTY');
CREATE TABLE x (x TEXT, x TEXT);
CREATE UNIQUE INDEX x ON x((x || x) x NULLS LAST);
INSERT INTO x VALUES ('ABC', 'DEF');
INSERT INTO x VALUES ('AB', 'CDEFG');
INSERT INTO x VALUES ('QWE', 'RTY');
/* this should fail because of unique index: */ INSERT INTO x VALUES ('ABCD', 'EF');
/* but this shouldn't: */ INSERT INTO x VALUES ('QWERTY');
/* Test unique index with included columns */ CREATE TABLE x (x INT, x INT, x TEXT);
CREATE UNIQUE INDEX x ON x(x NULLS LAST, x NULLS LAST) INCLUDE (x);
INSERT INTO x VALUES (1, 1, 'AAA');
INSERT INTO x VALUES (1, 2, 'AAA');
/* this should fail because of unique index on f1,f2: */ INSERT INTO x VALUES (1, 2, 'BBB');
/* and this shouldn't: */ INSERT INTO x VALUES (1, 4, 'AAA');
/* Try to build index on table that already contains data */ CREATE UNIQUE INDEX x ON x(x NULLS LAST, x NULLS LAST) INCLUDE (x);
/* Try to use existing covering index as primary key */ ALTER TABLE covering_index_heap ADD CONSTRAINT covering_pkey PRIMARY KEY USING INDEX covering_pkey;
DROP TABLE x;
/* Try some concurrent index builds */ /* Unfortunately this only tests about half the code paths because there are */ /* no concurrent updates happening to the table at the same time. */ CREATE TABLE x (x TEXT, x TEXT);
/* empty table */ CREATE INDEX CONCURRENTLY x ON x(x NULLS LAST, x NULLS LAST);
CREATE INDEX CONCURRENTLY IF NOT EXISTS x ON x(x NULLS LAST, x NULLS LAST);
INSERT INTO x VALUES ('a', 'b');
INSERT INTO x VALUES ('b', 'b');
/* unique index */ CREATE UNIQUE INDEX CONCURRENTLY x ON x(x NULLS LAST);
CREATE UNIQUE INDEX CONCURRENTLY IF NOT EXISTS x ON x(x NULLS LAST);
/* check if constraint is set up properly to be enforced */ INSERT INTO x VALUES ('b', 'x');
/* check if constraint is enforced properly at build time */ CREATE UNIQUE INDEX CONCURRENTLY x ON x(x NULLS LAST);
/* test that expression indexes and partial indexes work concurrently */ CREATE INDEX CONCURRENTLY x ON x(x NULLS LAST) WHERE x = 'a';
CREATE INDEX CONCURRENTLY x ON x(x NULLS LAST) WHERE x = 'x';
/* here we also check that you can default the index name */ CREATE INDEX CONCURRENTLY ON x((x || x) NULLS LAST);
/* You can't do a concurrent index build in a transaction */ BEGIN;
CREATE INDEX CONCURRENTLY x ON x(x NULLS LAST);
COMMIT;
x AS x;
COMMIT;
CREATE INDEX CONCURRENTLY x ON x(x NULLS LAST) WHERE PREDICATE_STABLE();
DROP INDEX x;
DROP FUNCTION x;
/* But you can do a regular index build in a transaction */ BEGIN;
CREATE INDEX x ON x(x NULLS LAST);
COMMIT;
/* Failed builds are left invalid by VACUUM FULL, fixed by REINDEX */ VACUUM FULL concur_heap;
REINDEX TABLE concur_heap;
DELETE FROM x WHERE x = 'b';
VACUUM FULL concur_heap;
INSERT INTO x VALUES (1, 'foo'), (2, 'bar');
CREATE INDEX CONCURRENTLY x ON x(x NULLS LAST);
DROP INDEX CONCURRENTLY x;
DROP TABLE x;
/* ON COMMIT DROP */ BEGIN;
CREATE TEMP TABLE concur_temp (f1 int, f2 text)   ON COMMIT DROP;
INSERT INTO x VALUES (1, 'foo'), (2, 'bar');
/* Fails when running in a transaction. */ CREATE INDEX CONCURRENTLY x ON x(x NULLS LAST);
COMMIT;
/* ON COMMIT DELETE ROWS */ CREATE TEMPORARY TABLE x (x INT, x TEXT) ON COMMIT DELETE ROWS;
INSERT INTO x VALUES (1, 'foo'), (2, 'bar');
CREATE INDEX CONCURRENTLY x ON x(x NULLS LAST);
DROP INDEX CONCURRENTLY x;
DROP TABLE x;
/* Try some concurrent index drops */ DROP INDEX CONCURRENTLY x;
/* works */ DROP INDEX CONCURRENTLY IF EXISTS x;
BEGIN;
DROP INDEX CONCURRENTLY x;
ROLLBACK;
/* successes */ DROP INDEX CONCURRENTLY IF EXISTS x;
DROP INDEX CONCURRENTLY x;
DROP INDEX CONCURRENTLY x;
DROP INDEX CONCURRENTLY x;
DROP INDEX CONCURRENTLY x;
/* Test ADD CONSTRAINT USING INDEX */ CREATE TABLE x (x INT, x VARCHAR(10), x CHAR);
/* add some data so that all tests have something to work with. */ INSERT INTO x VALUES (1, 2), (3, 4), (5, 6);
CREATE UNIQUE INDEX x ON x(x NULLS LAST, x NULLS LAST);
ALTER TABLE cwi_test ADD primary key USING INDEX cwi_uniq_idx;
ALTER TABLE cwi_test DROP CONSTRAINT cwi_uniq_idx, 	ADD CONSTRAINT cwi_replaced_pkey PRIMARY KEY 		USING INDEX cwi_uniq2_idx;
ALTER TABLE cwi_test ADD UNIQUE USING INDEX cwi_uniq3_idx;
/* fail */ CREATE UNIQUE INDEX x ON x(x COLLATE "x" NULLS LAST);
ALTER TABLE cwi_test ADD UNIQUE USING INDEX cwi_uniq4_idx;
/* fail */ DROP TABLE x;
/* ADD CONSTRAINT USING INDEX is forbidden on partitioned tables */ CREATE TABLE x (x INT) WITH (PARTITIONED_BY=HASH(x));
CREATE UNIQUE INDEX ON x(x NULLS LAST);
alter table cwi_test add primary key using index cwi_test_a_idx;
DROP TABLE x;
/* PRIMARY KEY constraint cannot be backed by a NULLS NOT DISTINCT index */ CREATE TABLE x (x INT, x INT);
CREATE UNIQUE INDEX cwi_a_nnd ON cwi_test (a) NULLS NOT DISTINCT;
ALTER TABLE cwi_test ADD PRIMARY KEY USING INDEX cwi_a_nnd;
DROP TABLE x;
/* Check handling of indexes on system columns */ CREATE TABLE x (x INT);
/* System columns cannot be indexed */ CREATE INDEX ON x(x NULLS LAST);
/* nor used in expressions */ CREATE INDEX ON x((x >= '(1000,0)') NULLS LAST);
/* nor used in predicates */ CREATE INDEX ON x(x NULLS LAST) WHERE x >= '(1000,0)';
DROP TABLE x;
/* Tests for IS NULL/IS NOT NULL with b-tree indexes */ CREATE TABLE x AS SELECT x, x FROM x;
INSERT INTO x (x, x) VALUES (NULL, -1), (NULL, NULL);
CREATE UNIQUE INDEX x ON x(x NULLS LAST, x NULLS LAST);
SET x = OFF;
SET x = ON;
SET x = ON;
SELECT COUNT(*) FROM x WHERE x IS NULL;
SELECT COUNT(*) FROM x WHERE x IS NULL AND x IS NULL;
SELECT COUNT(*) FROM x WHERE NOT x IS NULL;
SELECT COUNT(*) FROM x WHERE x IS NULL AND NOT x IS NULL;
SELECT COUNT(*) FROM x WHERE NOT x IS NULL AND x > 500;
SELECT COUNT(*) FROM x WHERE x IS NULL AND x > 500;
DROP INDEX x;
CREATE UNIQUE INDEX x ON x(x DESC NULLS FIRST, x NULLS LAST);
SELECT COUNT(*) FROM x WHERE x IS NULL;
SELECT COUNT(*) FROM x WHERE x IS NULL AND x IS NULL;
SELECT COUNT(*) FROM x WHERE NOT x IS NULL;
SELECT COUNT(*) FROM x WHERE x IS NULL AND NOT x IS NULL;
SELECT COUNT(*) FROM x WHERE NOT x IS NULL AND x > 500;
SELECT COUNT(*) FROM x WHERE x IS NULL AND x > 500;
SELECT COUNT(*) FROM x WHERE x IS NULL AND x IN (-1, 0, 1);
DROP INDEX x;
CREATE UNIQUE INDEX x ON x(x DESC, x NULLS LAST);
SELECT COUNT(*) FROM x WHERE x IS NULL;
SELECT COUNT(*) FROM x WHERE x IS NULL AND x IS NULL;
SELECT COUNT(*) FROM x WHERE NOT x IS NULL;
SELECT COUNT(*) FROM x WHERE x IS NULL AND NOT x IS NULL;
SELECT COUNT(*) FROM x WHERE NOT x IS NULL AND x > 500;
SELECT COUNT(*) FROM x WHERE x IS NULL AND x > 500;
DROP INDEX x;
CREATE UNIQUE INDEX x ON x(x, x NULLS LAST);
SELECT COUNT(*) FROM x WHERE x IS NULL;
SELECT COUNT(*) FROM x WHERE x IS NULL AND x IS NULL;
SELECT COUNT(*) FROM x WHERE NOT x IS NULL;
SELECT COUNT(*) FROM x WHERE x IS NULL AND NOT x IS NULL;
SELECT COUNT(*) FROM x WHERE NOT x IS NULL AND x > 500;
SELECT COUNT(*) FROM x WHERE x IS NULL AND x > 500;
DROP INDEX x;
/* Check initial-positioning logic too */ CREATE UNIQUE INDEX x ON x(x NULLS LAST);
SET x = OFF;
SET x = ON;
SET x = OFF;
SELECT x, x FROM x ORDER BY x NULLS LAST LIMIT 2;
SELECT x, x FROM x WHERE x >= -1 ORDER BY x NULLS LAST LIMIT 2;
SELECT x, x FROM x WHERE x >= 0 ORDER BY x NULLS LAST LIMIT 2;
SELECT x, x FROM x ORDER BY x DESC NULLS FIRST LIMIT 2;
SELECT x, x FROM x WHERE x >= -1 ORDER BY x DESC NULLS FIRST LIMIT 2;
SELECT x, x FROM x WHERE x < 999 ORDER BY x DESC NULLS FIRST LIMIT 2;
RESET enable_seqscan;
RESET enable_indexscan;
RESET enable_bitmapscan;
DROP TABLE x;
/* Check bitmap index path planning */ EXPLAIN (COSTS OFF) SELECT * FROM tenk1   WHERE thousand = 42 AND (tenthous = 1 OR tenthous = 3 OR tenthous = 42 OR tenthous = 0);
SELECT * FROM x WHERE x = 42 AND (x = 1 OR x = 3 OR x = 42 OR x = 0);
EXPLAIN (COSTS OFF) SELECT * FROM tenk1   WHERE thousand = 42 AND (tenthous = 1 OR tenthous = (SELECT 1 + 2) OR tenthous = 42);
SELECT * FROM x WHERE x = 42 AND (x = 1 OR x = (SELECT 1 + 2) OR x = 42);
EXPLAIN (COSTS OFF) SELECT * FROM tenk1   WHERE thousand = 42 AND (tenthous = 1 OR tenthous = 3 OR tenthous = 42 OR tenthous IS NULL);
EXPLAIN (COSTS OFF) SELECT * FROM tenk1   WHERE thousand = 42 AND (tenthous = 1::int2 OR tenthous::int2 = 3::int8 OR tenthous = 42::int8);
EXPLAIN (COSTS OFF) SELECT * FROM tenk1   WHERE thousand = 42 AND (tenthous = 1::int2 OR tenthous::int2 = 3::int8 OR tenthous::int2 = 42::int8);
EXPLAIN (COSTS OFF) SELECT * FROM tenk1   WHERE thousand = 42 AND (tenthous = 1::int2 OR tenthous = 3::int8 OR tenthous = 42::int8);
EXPLAIN (COSTS OFF) SELECT count(*) FROM tenk1   WHERE hundred = 42 AND (thousand = 42 OR thousand = 99);
SELECT COUNT(*) FROM x WHERE x = 42 AND (x = 42 OR x = 99);
EXPLAIN (COSTS OFF) SELECT * FROM tenk1   WHERE thousand = 42 AND (tenthous = 1 OR tenthous = 3 OR tenthous = 42);
SELECT * FROM x WHERE x = 42 AND (x = 1 OR x = 3 OR x = 42);
EXPLAIN (COSTS OFF) SELECT * FROM tenk1   WHERE thousand = 42 AND (tenthous = 1::numeric OR tenthous = 3::int4 OR tenthous = 42::numeric);
EXPLAIN (COSTS OFF) SELECT * FROM tenk1   WHERE tenthous = 1::numeric OR tenthous = 3::int4 OR tenthous = 42::numeric;
EXPLAIN (COSTS OFF) SELECT count(*) FROM tenk1 t1   WHERE t1.thousand = 42 OR t1.thousand = (SELECT t2.tenthous FROM tenk1 t2 WHERE t2.thousand = t1.tenthous + 1 LIMIT 1);
SELECT COUNT(*) FROM x AS x WHERE x.x = 42 OR x.x = (SELECT x.x FROM x AS x WHERE x.x = x.x + 1 LIMIT 1);
EXPLAIN (COSTS OFF) SELECT count(*) FROM tenk1   WHERE hundred = 42 AND (thousand = 42 OR thousand = 99);
SELECT COUNT(*) FROM x WHERE x = 42 AND (x = 42 OR x = 99);
EXPLAIN (COSTS OFF) SELECT count(*) FROM tenk1   WHERE hundred = 42 AND (thousand < 42 OR thousand < 99 OR 43 > thousand OR 42 > thousand);
SELECT COUNT(*) FROM x WHERE x = 42 AND (x < 42 OR x < 99 OR 43 > x OR 42 > x);
EXPLAIN (COSTS OFF) SELECT count(*) FROM tenk1   WHERE thousand = 42 AND (tenthous = 1 OR tenthous = 3) OR thousand = 41;
SELECT COUNT(*) FROM x WHERE x = 42 AND (x = 1 OR x = 3) OR x = 41;
EXPLAIN (COSTS OFF) SELECT count(*) FROM tenk1   WHERE hundred = 42 AND (thousand = 42 OR thousand = 99 OR tenthous < 2) OR thousand = 41;
SELECT COUNT(*) FROM x WHERE x = 42 AND (x = 42 OR x = 99 OR x < 2) OR x = 41;
EXPLAIN (COSTS OFF) SELECT count(*) FROM tenk1   WHERE hundred = 42 AND (thousand = 42 OR thousand = 41 OR thousand = 99 AND tenthous = 2);
SELECT COUNT(*) FROM x WHERE x = 42 AND (x = 42 OR x = 41 OR x = 99 AND x = 2);
EXPLAIN (COSTS OFF) SELECT count(*) FROM tenk1, tenk2   WHERE tenk1.hundred = 42 AND (tenk2.thousand = 42 OR tenk1.thousand = 41 OR tenk2.tenthous = 2) AND   tenk2.hundred = tenk1.hundred;
EXPLAIN (COSTS OFF) SELECT count(*) FROM tenk1, tenk2   WHERE tenk1.hundred = 42 AND (tenk2.thousand = 42 OR tenk2.thousand = 41 OR tenk2.tenthous = 2) AND   tenk2.hundred = tenk1.hundred;
EXPLAIN (COSTS OFF) SELECT count(*) FROM tenk1 JOIN tenk2 ON   tenk1.hundred = 42 AND (tenk2.thousand = 42 OR tenk2.thousand = 41 OR tenk2.tenthous = 2) AND   tenk2.hundred = tenk1.hundred;
EXPLAIN (COSTS OFF) SELECT count(*) FROM tenk1 LEFT JOIN tenk2 ON   tenk1.hundred = 42 AND (tenk2.thousand = 42 OR tenk2.thousand = 41 OR tenk2.tenthous = 2) AND   tenk2.hundred = tenk1.hundred;
/* Check behavior with duplicate index column contents */ CREATE TABLE x AS SELECT x AS x, CAST(x AS TEXT) AS x FROM x;
CREATE INDEX x ON x(x NULLS LAST, x NULLS LAST, x x NULLS LAST);
ANALYZE x;
EXPLAIN (COSTS OFF)   SELECT count(*) FROM dupindexcols     WHERE f1 BETWEEN 'WA' AND 'ZZZ' and id < 1000 and f1 ~<~ 'YX';
/* Check that index scans with =ANY indexquals return rows in index order */ EXPLAIN (costs off) SELECT unique1 FROM tenk1 WHERE unique1 IN (1,42,7) ORDER BY unique1;
SELECT x FROM x WHERE x IN (1, 42, 7) ORDER BY x NULLS LAST;
/* Non-required array scan key on "tenthous": */ EXPLAIN (costs off) SELECT thousand, tenthous FROM tenk1 WHERE thousand < 2 AND tenthous IN (1001,3000) ORDER BY thousand;
SELECT x, x FROM x WHERE x < 2 AND x IN (1001, 3000) ORDER BY x NULLS LAST;
/* Non-required array scan key on "tenthous", backward scan: */ EXPLAIN (costs off) SELECT thousand, tenthous FROM tenk1 WHERE thousand < 2 AND tenthous IN (1001,3000) ORDER BY thousand DESC, tenthous DESC;
SELECT x, x FROM x WHERE x < 2 AND x IN (1001, 3000) ORDER BY x DESC NULLS FIRST, x DESC NULLS FIRST;
/* Check elimination of redundant and contradictory index quals */ EXPLAIN (costs off) SELECT unique1 FROM tenk1 WHERE unique1 IN (1, 42, 7) and unique1 = ANY('{7, 8, 9}');
SELECT x FROM x WHERE x IN (1, 42, 7) AND x = ANY('{7, 8, 9}');
EXPLAIN (costs off) SELECT unique1 FROM tenk1 WHERE unique1 = ANY('{7, 14, 22}') and unique1 = ANY('{33, 44}'::bigint[]);
SELECT x FROM x WHERE x = ANY('{7, 14, 22}') AND x = ANY(CAST('{33, 44}' AS ARRAY<BIGINT>));
EXPLAIN (costs off) SELECT unique1 FROM tenk1 WHERE unique1 IN (1, 42, 7) and unique1 = 1;
SELECT x FROM x WHERE x IN (1, 42, 7) AND x = 1;
EXPLAIN (costs off) SELECT unique1 FROM tenk1 WHERE unique1 IN (1, 42, 7) and unique1 = 12345;
SELECT x FROM x WHERE x IN (1, 42, 7) AND x = 12345;
EXPLAIN (costs off) SELECT unique1 FROM tenk1 WHERE unique1 IN (1, 42, 7) and unique1 >= 42;
SELECT x FROM x WHERE x IN (1, 42, 7) AND x >= 42;
EXPLAIN (costs off) SELECT unique1 FROM tenk1 WHERE unique1 IN (1, 42, 7) and unique1 > 42;
SELECT x FROM x WHERE x IN (1, 42, 7) AND x > 42;
EXPLAIN (costs off) SELECT unique1 FROM tenk1 WHERE unique1 > 9996 and unique1 >= 9999;
SELECT x FROM x WHERE x > 9996 AND x >= 9999;
EXPLAIN (costs off) SELECT unique1 FROM tenk1 WHERE unique1 < 3 and unique1 <= 3;
SELECT x FROM x WHERE x < 3 AND x <= 3;
EXPLAIN (costs off) SELECT unique1 FROM tenk1 WHERE unique1 < 3 and unique1 < (-1)::bigint;
SELECT x FROM x WHERE x < 3 AND x < CAST((-1) AS BIGINT);
EXPLAIN (costs off) SELECT unique1 FROM tenk1 WHERE unique1 IN (1, 42, 7) and unique1 < (-1)::bigint;
SELECT x FROM x WHERE x IN (1, 42, 7) AND x < CAST((-1) AS BIGINT);
EXPLAIN (costs off) SELECT unique1 FROM tenk1 WHERE (thousand, tenthous) > (NULL, 5);
SELECT x FROM x WHERE (x, x) > (NULL, 5);
/* Check elimination of constant-NULL subexpressions */ EXPLAIN (costs off)   select * from tenk1 where (thousand, tenthous) in ((1,1001), (null,null));
/* Check matching of boolean index columns to WHERE conditions and sort keys */ CREATE TEMPORARY TABLE x (x BOOLEAN, x INT, UNIQUE (x, x), x DOUBLE);
EXPLAIN (costs off)   select * from boolindex order by b, i limit 10;
EXPLAIN (costs off)   select * from boolindex where b order by i limit 10;
EXPLAIN (costs off)   select * from boolindex where b = true order by i desc limit 10;
EXPLAIN (costs off)   select * from boolindex where not b order by i limit 10;
EXPLAIN (costs off)   select * from boolindex where b is true order by i desc limit 10;
EXPLAIN (costs off)   select * from boolindex where b is false order by i desc limit 10;
/* REINDEX (VERBOSE) */ CREATE TABLE x (x INT PRIMARY KEY);
/* REINDEX CONCURRENTLY */ CREATE TABLE x (x INT);
/* REINDEX */ REINDEX TABLE concur_reindex_tab;
/* notice */ REINDEX (CONCURRENTLY) TABLE concur_reindex_tab;
ALTER TABLE x ADD COLUMN x TEXT /* notice */;
/* add toast index */ /* Normal index with integer column */ CREATE UNIQUE INDEX x ON x(x NULLS LAST);
/* Normal index with text column */ CREATE INDEX x ON x(x NULLS LAST);
/* UNIQUE index with expression */ CREATE UNIQUE INDEX x ON x(ABS(x) NULLS LAST);
/* Duplicate column names */ CREATE INDEX x ON x(x NULLS LAST, x NULLS LAST, x NULLS LAST);
/* Create table for check on foreign key dependence switch with indexes swapped */ ALTER TABLE concur_reindex_tab ADD PRIMARY KEY USING INDEX concur_reindex_ind1;
CREATE TABLE x (x INT REFERENCES x);
INSERT INTO x VALUES (1, 'a');
INSERT INTO x VALUES (2, 'a');
/* Reindex concurrently of exclusion constraint currently not supported */ CREATE TABLE x (x INT, x INT4RANGE, EXCLUDE USING gist(x NULLS LAST WITH &&));
INSERT INTO x VALUES (3, '[1,2]');
REINDEX INDEX CONCURRENTLY  concur_reindex_tab3_c2_excl;
/* error */ REINDEX TABLE CONCURRENTLY concur_reindex_tab3;
/* succeeds with warning */ INSERT INTO x VALUES (4, '[2,4]');
/* Check materialized views */ CREATE MATERIALIZED VIEW x AS SELECT * FROM x;
/* Dependency lookup before and after the follow-up REINDEX commands. */ /* These should remain consistent. */ SELECT PG_DESCRIBE_OBJECT(x, x, x) AS x, PG_DESCRIBE_OBJECT(x, x, x) AS x, x FROM x WHERE x = CAST('pg_class' AS REGCLASS) AND x IN (CAST('concur_reindex_tab' AS REGCLASS), CAST('concur_reindex_ind1' AS REGCLASS), CAST('concur_reindex_ind2' AS REGCLASS), CAST('concur_reindex_ind3' AS REGCLASS), CAST('concur_reindex_ind4' AS REGCLASS), CAST('concur_reindex_matview' AS REGCLASS)) ORDER BY 1 NULLS LAST, 2 NULLS LAST;
REINDEX INDEX CONCURRENTLY concur_reindex_ind1;
REINDEX TABLE CONCURRENTLY concur_reindex_tab;
REINDEX TABLE CONCURRENTLY concur_reindex_matview;
SELECT PG_DESCRIBE_OBJECT(x, x, x) AS x, PG_DESCRIBE_OBJECT(x, x, x) AS x, x FROM x WHERE x = CAST('pg_class' AS REGCLASS) AND x IN (CAST('concur_reindex_tab' AS REGCLASS), CAST('concur_reindex_ind1' AS REGCLASS), CAST('concur_reindex_ind2' AS REGCLASS), CAST('concur_reindex_ind3' AS REGCLASS), CAST('concur_reindex_ind4' AS REGCLASS), CAST('concur_reindex_matview' AS REGCLASS)) ORDER BY 1 NULLS LAST, 2 NULLS LAST;
/* Check that comments are preserved */ CREATE TABLE x (x INT);
CREATE INDEX x ON x(x NULLS LAST);
COMMENT ON INDEX x IS 'test comment';
SELECT OBJ_DESCRIPTION(CAST('testcomment_idx1' AS REGCLASS), 'pg_class');
REINDEX TABLE testcomment;
SELECT OBJ_DESCRIPTION(CAST('testcomment_idx1' AS REGCLASS), 'pg_class');
REINDEX TABLE CONCURRENTLY testcomment;
SELECT OBJ_DESCRIPTION(CAST('testcomment_idx1' AS REGCLASS), 'pg_class');
DROP TABLE x;
/* Check that indisclustered updates are preserved */ CREATE TABLE x (x INT);
CREATE INDEX x ON x(x NULLS LAST);
ALTER TABLE concur_clustered CLUSTER ON concur_clustered_i_idx;
REINDEX TABLE CONCURRENTLY concur_clustered;
SELECT CAST(x AS REGCLASS), x FROM x WHERE x = CAST('concur_clustered' AS REGCLASS);
DROP TABLE x;
/* Check that indisreplident updates are preserved. */ CREATE TABLE x (x INT NOT NULL);
CREATE UNIQUE INDEX x ON x(x NULLS LAST);
ALTER TABLE concur_replident REPLICA IDENTITY   USING INDEX concur_replident_i_idx;
SELECT CAST(x AS REGCLASS), x FROM x WHERE x = CAST('concur_replident' AS REGCLASS);
REINDEX TABLE CONCURRENTLY concur_replident;
SELECT CAST(x AS REGCLASS), x FROM x WHERE x = CAST('concur_replident' AS REGCLASS);
DROP TABLE x;
/* Check that opclass parameters are preserved */ CREATE TABLE x (x tsvector, x tsvector, x tsvector);
CREATE INDEX x ON x USING gist(x x NULLS LAST, x x NULLS LAST);
CREATE INDEX x ON x USING gist(x x NULLS LAST, x x NULLS LAST);
REINDEX TABLE CONCURRENTLY concur_appclass_tab;
/* Partitions */ /* Create some partitioned tables */ CREATE TABLE x (x INT, x INT) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (0) TO (10) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN (1);
CREATE TABLE x PARTITION OF x FOR VALUES IN (2);
/* This partitioned table will have no partitions. */ CREATE TABLE x PARTITION OF x FOR VALUES FROM (10) TO (20) WITH (PARTITIONED_BY=LIST(x));
ALTER INDEX concur_reindex_part_index ATTACH PARTITION concur_reindex_part_index_0;
ALTER INDEX concur_reindex_part_index ATTACH PARTITION concur_reindex_part_index_10;
ALTER INDEX concur_reindex_part_index_0 ATTACH PARTITION concur_reindex_part_index_0_1;
ALTER INDEX concur_reindex_part_index_0 ATTACH PARTITION concur_reindex_part_index_0_2;
SELECT x, x, x FROM x ORDER BY x NULLS LAST, x NULLS LAST;
SELECT x, x, x FROM x ORDER BY x NULLS LAST, x NULLS LAST;
/* REINDEX should preserve dependencies of partition tree. */ SELECT PG_DESCRIBE_OBJECT(x, x, x) AS x, PG_DESCRIBE_OBJECT(x, x, x) AS x, x FROM x WHERE x = CAST('pg_class' AS REGCLASS) AND x IN (CAST('concur_reindex_part' AS REGCLASS), CAST('concur_reindex_part_0' AS REGCLASS), CAST('concur_reindex_part_0_1' AS REGCLASS), CAST('concur_reindex_part_0_2' AS REGCLASS), CAST('concur_reindex_part_index' AS REGCLASS), CAST('concur_reindex_part_index_0' AS REGCLASS), CAST('concur_reindex_part_index_0_1' AS REGCLASS), CAST('concur_reindex_part_index_0_2' AS REGCLASS)) ORDER BY 1 NULLS LAST, 2 NULLS LAST;
REINDEX INDEX CONCURRENTLY concur_reindex_part_index_0_1;
REINDEX INDEX CONCURRENTLY concur_reindex_part_index_0_2;
SELECT x, x, x FROM x ORDER BY x NULLS LAST, x NULLS LAST;
REINDEX TABLE CONCURRENTLY concur_reindex_part_0_1;
REINDEX TABLE CONCURRENTLY concur_reindex_part_0_2;
SELECT PG_DESCRIBE_OBJECT(x, x, x) AS x, PG_DESCRIBE_OBJECT(x, x, x) AS x, x FROM x WHERE x = CAST('pg_class' AS REGCLASS) AND x IN (CAST('concur_reindex_part' AS REGCLASS), CAST('concur_reindex_part_0' AS REGCLASS), CAST('concur_reindex_part_0_1' AS REGCLASS), CAST('concur_reindex_part_0_2' AS REGCLASS), CAST('concur_reindex_part_index' AS REGCLASS), CAST('concur_reindex_part_index_0' AS REGCLASS), CAST('concur_reindex_part_index_0_1' AS REGCLASS), CAST('concur_reindex_part_index_0_2' AS REGCLASS)) ORDER BY 1 NULLS LAST, 2 NULLS LAST;
SELECT x, x, x FROM x ORDER BY x NULLS LAST, x NULLS LAST;
/* REINDEX for partitioned indexes */ /* REINDEX TABLE fails for partitioned indexes */ /* Top-most parent index */ REINDEX TABLE concur_reindex_part_index;
/* error */ REINDEX TABLE CONCURRENTLY concur_reindex_part_index;
/* error */ /* Partitioned index with no leaves */ REINDEX TABLE concur_reindex_part_index_10;
/* error */ REINDEX TABLE CONCURRENTLY concur_reindex_part_index_10;
/* error */ /* Cannot run in a transaction block */ BEGIN;
REINDEX INDEX concur_reindex_part_index;
ROLLBACK;
/*  Check that expected relfilenodes are changed, non-concurrent case. */ SELECT CREATE_RELFILENODE_PART('reindex_index_status', 'concur_reindex_part_index');
REINDEX INDEX concur_reindex_part_index;
SELECT * FROM x;
DROP TABLE x;
/* concurrent case. */ SELECT CREATE_RELFILENODE_PART('reindex_index_status', 'concur_reindex_part_index');
REINDEX INDEX CONCURRENTLY concur_reindex_part_index;
SELECT * FROM x;
DROP TABLE x;
/* REINDEX for partitioned tables */ /* REINDEX INDEX fails for partitioned tables */ /* Top-most parent */ REINDEX INDEX concur_reindex_part;
/* error */ REINDEX INDEX CONCURRENTLY concur_reindex_part;
/* error */ /* Partitioned with no leaves */ REINDEX INDEX concur_reindex_part_10;
/* error */ REINDEX INDEX CONCURRENTLY concur_reindex_part_10;
/* error */ /* Cannot run in a transaction block */ BEGIN;
REINDEX TABLE concur_reindex_part;
ROLLBACK;
/* Check that expected relfilenodes are changed, non-concurrent case. */ /* Note that the partition tree changes of the *indexes* need to be checked. */ SELECT CREATE_RELFILENODE_PART('reindex_index_status', 'concur_reindex_part_index');
REINDEX TABLE concur_reindex_part;
SELECT * FROM x;
DROP TABLE x;
/* concurrent case. */ SELECT CREATE_RELFILENODE_PART('reindex_index_status', 'concur_reindex_part_index');
REINDEX TABLE CONCURRENTLY concur_reindex_part;
SELECT * FROM x;
DROP TABLE x;
DROP FUNCTION x;
DROP FUNCTION x;
/* Cleanup of partition tree used for REINDEX test. */ DROP TABLE x;
/* Check errors */ /* Cannot run inside a transaction block */ BEGIN;
REINDEX TABLE CONCURRENTLY concur_reindex_tab;
COMMIT;
REINDEX TABLE CONCURRENTLY pg_class;
/* no catalog relation */ REINDEX INDEX CONCURRENTLY pg_class_oid_index;
/* no catalog index */ /* These are the toast table and index of pg_database. */ REINDEX TABLE CONCURRENTLY pg_toast.pg_toast_1262;
/* no catalog toast table */ REINDEX INDEX CONCURRENTLY pg_toast.pg_toast_1262_index;
/* no catalog toast index */ REINDEX SYSTEM CONCURRENTLY postgres;
/* not allowed for SYSTEM */ REINDEX (CONCURRENTLY) SYSTEM postgres;
/* ditto */ REINDEX (CONCURRENTLY) SYSTEM;
/* ditto */ /* Warns about catalog relations */ REINDEX SCHEMA CONCURRENTLY pg_catalog;
/* Not the current database */ REINDEX DATABASE not_current_database;
/* Check handling of invalid indexes */ CREATE TABLE x (x INT);
INSERT INTO x VALUES (1), (1), (2);
/* This trick creates an invalid index. */ CREATE UNIQUE INDEX CONCURRENTLY x ON x(x NULLS LAST);
/* Reindexing concurrently this index fails with the same failure. */ /* The extra index created is itself invalid, and can be dropped. */ REINDEX INDEX CONCURRENTLY concur_reindex_ind5;
/* This makes the previous failure go away, so the index can become valid. */ DELETE FROM x WHERE x = 1;
/* The invalid index is not processed when running REINDEX TABLE. */ REINDEX TABLE CONCURRENTLY concur_reindex_tab4;
/* Check handling of indexes with expressions and predicates.  The */ /* definitions of the rebuilt indexes should match the original */ /* definitions. */ CREATE TABLE x (x INT, x BOOLEAN);
INSERT INTO x (x, x) VALUES (1369652450, FALSE), (414515746, TRUE), (897778963, FALSE);
CREATE UNIQUE INDEX x ON x((CAST(x AS TEXT) COLLATE "x") NULLS LAST);
CREATE UNIQUE INDEX x ON x(x NULLS LAST) WHERE (CAST(x AS TEXT) > CAST(500000000 AS TEXT) COLLATE "x");
CREATE UNIQUE INDEX x ON x((1 / x) NULLS LAST) WHERE ('-H') >= (CAST(x AS TEXT)) COLLATE "x";
ALTER INDEX x ALTER COLUMN 1 DROP DEFAULT, SET STATISTICS 100;
ANALYZE x;
SELECT CAST(x AS REGCLASS), COUNT(*) FROM x WHERE x IN (CAST('concur_exprs_index_expr' AS REGCLASS), CAST('concur_exprs_index_pred' AS REGCLASS), CAST('concur_exprs_index_pred_2' AS REGCLASS)) GROUP BY x ORDER BY CAST(CAST(x AS REGCLASS) AS TEXT) NULLS LAST;
SELECT PG_GET_INDEXDEF(CAST('concur_exprs_index_expr' AS REGCLASS));
SELECT PG_GET_INDEXDEF(CAST('concur_exprs_index_pred' AS REGCLASS));
SELECT PG_GET_INDEXDEF(CAST('concur_exprs_index_pred_2' AS REGCLASS));
REINDEX TABLE CONCURRENTLY concur_exprs_tab;
SELECT PG_GET_INDEXDEF(CAST('concur_exprs_index_expr' AS REGCLASS));
SELECT PG_GET_INDEXDEF(CAST('concur_exprs_index_pred' AS REGCLASS));
SELECT PG_GET_INDEXDEF(CAST('concur_exprs_index_pred_2' AS REGCLASS));
ALTER TABLE x ALTER COLUMN x SET DATA TYPE TEXT /* ALTER TABLE recreates the indexes, which should keep their collations. */;
SELECT PG_GET_INDEXDEF(CAST('concur_exprs_index_expr' AS REGCLASS));
SELECT PG_GET_INDEXDEF(CAST('concur_exprs_index_pred' AS REGCLASS));
SELECT PG_GET_INDEXDEF(CAST('concur_exprs_index_pred_2' AS REGCLASS));
/* Statistics should remain intact. */ SELECT CAST(x AS REGCLASS), COUNT(*) FROM x WHERE x IN (CAST('concur_exprs_index_expr' AS REGCLASS), CAST('concur_exprs_index_pred' AS REGCLASS), CAST('concur_exprs_index_pred_2' AS REGCLASS)) GROUP BY x ORDER BY CAST(CAST(x AS REGCLASS) AS TEXT) NULLS LAST;
/* attstattarget should remain intact */ SELECT CAST(x AS REGCLASS), x, x FROM x WHERE x IN (CAST('concur_exprs_index_expr' AS REGCLASS), CAST('concur_exprs_index_pred' AS REGCLASS), CAST('concur_exprs_index_pred_2' AS REGCLASS)) ORDER BY CAST(CAST(x AS REGCLASS) AS TEXT) NULLS LAST, x NULLS LAST;
DROP TABLE x;
/* Temporary tables and on-commit actions, where CONCURRENTLY is ignored. */ /* ON COMMIT PRESERVE ROWS, the default. */ CREATE TEMPORARY TABLE x (x INT, x TEXT) ON COMMIT PRESERVE ROWS;
INSERT INTO x VALUES (1, 'foo'), (2, 'bar');
CREATE INDEX x ON x(x NULLS LAST);
REINDEX TABLE CONCURRENTLY concur_temp_tab_1;
REINDEX INDEX CONCURRENTLY concur_temp_ind_1;
/* Still fails in transaction blocks */ BEGIN;
REINDEX INDEX CONCURRENTLY concur_temp_ind_1;
COMMIT;
/* ON COMMIT DELETE ROWS */ CREATE TEMPORARY TABLE x (x INT, x TEXT) ON COMMIT DELETE ROWS;
CREATE INDEX x ON x(x NULLS LAST);
REINDEX TABLE CONCURRENTLY concur_temp_tab_2;
REINDEX INDEX CONCURRENTLY concur_temp_ind_2;
/* ON COMMIT DROP */ BEGIN;
CREATE TEMPORARY TABLE x (x INT, x TEXT) ON COMMIT PRESERVE ROWS;
INSERT INTO x VALUES (1, 'foo'), (2, 'bar');
CREATE INDEX x ON x(x NULLS LAST);
/* Fails when running in a transaction */ REINDEX INDEX CONCURRENTLY concur_temp_ind_3;
COMMIT;
/* REINDEX SCHEMA processes all temporary relations */ CREATE TABLE x AS SELECT x, x, x, x, x FROM x WHERE x IN ('concur_temp_ind_1', 'concur_temp_ind_2');
SELECT x.x, x.x, CASE WHEN x.x = x.x THEN 'relfilenode is unchanged' ELSE 'relfilenode has changed' END FROM x AS x JOIN x AS x ON x.x = x.x ORDER BY 1 NULLS LAST;
/* Check bitmap scan can consider similar OR arguments separately without */ /* grouping them into SAOP. */ CREATE TABLE x (x INT NOT NULL, x INT NOT NULL, x INT NOT NULL);
INSERT INTO x (SELECT 1, 1, x FROM x AS x);
INSERT INTO x (SELECT x, 2, 2 FROM x AS x);
VACUUM ANALYZE bitmap_split_or;
CREATE INDEX x ON x(x NULLS LAST) WHERE x = 1;
CREATE INDEX x ON x(x NULLS LAST) WHERE x = 2;
EXPLAIN (COSTS OFF) SELECT * FROM bitmap_split_or WHERE (a = 1 OR a = 2) AND b = 2;
DROP INDEX x;
DROP INDEX x;
CREATE INDEX x ON x(x NULLS LAST, x NULLS LAST);
CREATE INDEX x ON x(x NULLS LAST, x NULLS LAST);
CREATE STATISTICS t_a_b_stat (mcv) ON a, b FROM bitmap_split_or;
CREATE STATISTICS t_b_c_stat (mcv) ON b, c FROM bitmap_split_or;
ANALYZE x;
EXPLAIN (COSTS OFF) SELECT * FROM bitmap_split_or t1, bitmap_split_or t2 WHERE t1.a = t2.b OR t1.a = 2;
EXPLAIN (COSTS OFF) SELECT * FROM bitmap_split_or WHERE a = 1 AND (b = 1 OR b = 2) AND c = 2;
DROP TABLE x;
/* REINDEX SCHEMA */ REINDEX SCHEMA schema_to_reindex;
/* failure, schema does not exist */ CREATE SCHEMA x.x;
SET x = 'schema_to_reindex';
CREATE TABLE x (x SERIAL PRIMARY KEY);
INSERT INTO x SELECT UNNEST(GENERATE_SERIES(1, 400));
CREATE TABLE x (x SERIAL PRIMARY KEY, x TEXT NOT NULL);
INSERT INTO x SELECT UNNEST(GENERATE_SERIES(1, 400)), 'abc';
CREATE INDEX ON x(x NULLS LAST);
CREATE MATERIALIZED VIEW x AS SELECT x FROM x;
CREATE INDEX ON x(x NULLS LAST);
CREATE VIEW x AS SELECT x FROM x;
CREATE TABLE x AS SELECT x, x, x, x, x FROM x WHERE x = (SELECT x FROM x WHERE x = 'schema_to_reindex');
INSERT INTO x SELECT x, 'pg_toast_TABLE', x, x, x FROM x WHERE x IN (SELECT x FROM x WHERE x > 0);
INSERT INTO x SELECT x, 'pg_toast_TABLE_index', x, x, x FROM x WHERE x IN (SELECT x FROM x WHERE x IN (SELECT x FROM x WHERE x > 0));
REINDEX SCHEMA schema_to_reindex;
CREATE TABLE x AS SELECT x, x, x, x FROM x WHERE x = (SELECT x FROM x WHERE x = 'schema_to_reindex');
SELECT x.x, x.x, CASE WHEN x.x = x.x THEN 'relfilenode is unchanged' ELSE 'relfilenode has changed' END FROM x AS x JOIN x AS x ON x.x = x.x ORDER BY 1 NULLS LAST;
REINDEX SCHEMA schema_to_reindex;
BEGIN;
REINDEX SCHEMA schema_to_reindex;
COMMIT /* failure, cannot run in a transaction */ /* failure, cannot run in a transaction */;
/* concurrently */ REINDEX SCHEMA CONCURRENTLY schema_to_reindex;
/* Failure for unauthorized user */ CREATE ROLE regress_reindexuser NOLOGIN;
SET SESSION ROLE regress_reindexuser;
REINDEX SCHEMA schema_to_reindex;
/* Permission failures with toast tables and indexes (pg_authid here) */ RESET ROLE;
GRANT USAGE ON SCHEMA x TO x;
SET SESSION ROLE regress_reindexuser;
REINDEX TABLE pg_toast.pg_toast_1262;
REINDEX INDEX pg_toast.pg_toast_1262_index;
/* Clean up */ RESET ROLE;
REVOKE USAGE ON SCHEMA pg_toast FROM regress_reindexuser;
DROP ROLE regress_reindexuser;
DROP SCHEMA x.x CASCADE;
/* SP-GiST index tests */ CREATE TABLE x AS SELECT POINT(x, x) AS x FROM x;
INSERT INTO x SELECT CAST('(333.0,400.0)' AS point) FROM x;
INSERT INTO x VALUES (NULL), (NULL), (NULL);
CREATE INDEX x ON x USING spgist(x NULLS LAST);
CREATE TABLE x AS SELECT * FROM x;
CREATE INDEX x ON x USING spgist(x x NULLS LAST);
CREATE TABLE x AS SELECT x AS x FROM x WHERE NOT REGEXP_LIKE(x, '^[0-9]');
INSERT INTO x SELECT 'P0123456789abcdef' FROM x;
INSERT INTO x VALUES ('P0123456789abcde');
INSERT INTO x VALUES ('P0123456789abcdefF');
CREATE INDEX x ON x USING spgist(x NULLS LAST);
SET x = ON /* get non-indexed results for comparison purposes */;
SET x = OFF;
SET x = OFF;
SELECT COUNT(*) FROM x WHERE x IS NULL;
SELECT COUNT(*) FROM x WHERE NOT x IS NULL;
SELECT COUNT(*) FROM x;
SELECT COUNT(*) FROM x WHERE x << '(5000, 4000)';
SELECT COUNT(*) FROM x WHERE x >> '(5000, 4000)';
CREATE TEMPORARY TABLE x AS SELECT ROW_NUMBER() OVER (ORDER BY x <-> '0,0' NULLS LAST) AS x, x <-> '0,0' AS x, x FROM x;
CREATE TEMP TABLE quad_point_tbl_ord_seq2 AS SELECT row_number() OVER (ORDER BY p <-> '0,0') n, p <-> '0,0' dist, p FROM quad_point_tbl WHERE p <@ box '(200,200,1000,1000)';
CREATE TEMPORARY TABLE x AS SELECT ROW_NUMBER() OVER (ORDER BY x <-> '333,400' NULLS LAST) AS x, x <-> '333,400' AS x, x FROM x WHERE NOT x IS NULL;
SELECT COUNT(*) FROM x WHERE x = 'P0123456789abcdef';
SELECT COUNT(*) FROM x WHERE x = 'P0123456789abcde';
SELECT COUNT(*) FROM x WHERE x = 'P0123456789abcdefF';
SELECT COUNT(*) FROM x WHERE x < 'Aztec                         Ct  ';
SELECT COUNT(*) FROM x WHERE x <= 'Aztec                         Ct  ';
SELECT COUNT(*) FROM x WHERE x = 'Aztec                         Ct  ';
SELECT COUNT(*) FROM x WHERE x = 'Worth                         St  ';
SELECT COUNT(*) FROM x WHERE x >= 'Worth                         St  ';
SELECT COUNT(*) FROM x WHERE x > 'Worth                         St  ';
SELECT COUNT(*) FROM x WHERE POWER(x, @'Worth');
SET x = OFF /* Now check the results from plain indexscan */;
SET x = ON;
SET x = OFF;
EXPLAIN (COSTS OFF) SELECT count(*) FROM quad_point_tbl WHERE p IS NULL;
SELECT COUNT(*) FROM x WHERE x IS NULL;
EXPLAIN (COSTS OFF) SELECT count(*) FROM quad_point_tbl WHERE p IS NOT NULL;
SELECT COUNT(*) FROM x WHERE NOT x IS NULL;
EXPLAIN (COSTS OFF) SELECT count(*) FROM quad_point_tbl;
SELECT COUNT(*) FROM x;
EXPLAIN (COSTS OFF) SELECT count(*) FROM quad_point_tbl WHERE p <@ box '(200,200,1000,1000)';
EXPLAIN (COSTS OFF) SELECT count(*) FROM quad_point_tbl WHERE box '(200,200,1000,1000)' @> p;
EXPLAIN (COSTS OFF) SELECT count(*) FROM quad_point_tbl WHERE p << '(5000, 4000)';
SELECT COUNT(*) FROM x WHERE x << '(5000, 4000)';
EXPLAIN (COSTS OFF) SELECT count(*) FROM quad_point_tbl WHERE p >> '(5000, 4000)';
SELECT COUNT(*) FROM x WHERE x >> '(5000, 4000)';
EXPLAIN (COSTS OFF) SELECT count(*) FROM quad_point_tbl WHERE p <<| '(5000, 4000)';
EXPLAIN (COSTS OFF) SELECT count(*) FROM quad_point_tbl WHERE p |>> '(5000, 4000)';
EXPLAIN (COSTS OFF) SELECT count(*) FROM quad_point_tbl WHERE p ~= '(4585, 365)';
EXPLAIN (COSTS OFF) SELECT row_number() OVER (ORDER BY p <-> '0,0') n, p <-> '0,0' dist, p FROM quad_point_tbl;
CREATE TEMPORARY TABLE x AS SELECT ROW_NUMBER() OVER (ORDER BY x <-> '0,0' NULLS LAST) AS x, x <-> '0,0' AS x, x FROM x;
SELECT * FROM x AS x FULL JOIN x AS x ON x.x = x.x WHERE x.x IS DISTINCT FROM x.x;
EXPLAIN (COSTS OFF) SELECT row_number() OVER (ORDER BY p <-> '0,0') n, p <-> '0,0' dist, p FROM quad_point_tbl WHERE p <@ box '(200,200,1000,1000)';
CREATE TEMP TABLE quad_point_tbl_ord_idx2 AS SELECT row_number() OVER (ORDER BY p <-> '0,0') n, p <-> '0,0' dist, p FROM quad_point_tbl WHERE p <@ box '(200,200,1000,1000)';
SELECT * FROM x AS x FULL JOIN x AS x ON x.x = x.x WHERE x.x IS DISTINCT FROM x.x;
EXPLAIN (COSTS OFF) SELECT row_number() OVER (ORDER BY p <-> '333,400') n, p <-> '333,400' dist, p FROM quad_point_tbl WHERE p IS NOT NULL;
CREATE TEMPORARY TABLE x AS SELECT ROW_NUMBER() OVER (ORDER BY x <-> '333,400' NULLS LAST) AS x, x <-> '333,400' AS x, x FROM x WHERE NOT x IS NULL;
SELECT * FROM x AS x FULL JOIN x AS x ON x.x = x.x WHERE x.x IS DISTINCT FROM x.x;
EXPLAIN (COSTS OFF) SELECT count(*) FROM kd_point_tbl WHERE p <@ box '(200,200,1000,1000)';
EXPLAIN (COSTS OFF) SELECT count(*) FROM kd_point_tbl WHERE box '(200,200,1000,1000)' @> p;
EXPLAIN (COSTS OFF) SELECT count(*) FROM kd_point_tbl WHERE p << '(5000, 4000)';
SELECT COUNT(*) FROM x WHERE x << '(5000, 4000)';
EXPLAIN (COSTS OFF) SELECT count(*) FROM kd_point_tbl WHERE p >> '(5000, 4000)';
SELECT COUNT(*) FROM x WHERE x >> '(5000, 4000)';
EXPLAIN (COSTS OFF) SELECT count(*) FROM kd_point_tbl WHERE p <<| '(5000, 4000)';
EXPLAIN (COSTS OFF) SELECT count(*) FROM kd_point_tbl WHERE p |>> '(5000, 4000)';
EXPLAIN (COSTS OFF) SELECT count(*) FROM kd_point_tbl WHERE p ~= '(4585, 365)';
EXPLAIN (COSTS OFF) SELECT row_number() OVER (ORDER BY p <-> '0,0') n, p <-> '0,0' dist, p FROM kd_point_tbl;
CREATE TEMPORARY TABLE x AS SELECT ROW_NUMBER() OVER (ORDER BY x <-> '0,0' NULLS LAST) AS x, x <-> '0,0' AS x, x FROM x;
SELECT * FROM x AS x FULL JOIN x AS x ON x.x = x.x WHERE x.x IS DISTINCT FROM x.x;
EXPLAIN (COSTS OFF) SELECT row_number() OVER (ORDER BY p <-> '0,0') n, p <-> '0,0' dist, p FROM kd_point_tbl WHERE p <@ box '(200,200,1000,1000)';
CREATE TEMP TABLE kd_point_tbl_ord_idx2 AS SELECT row_number() OVER (ORDER BY p <-> '0,0') n, p <-> '0,0' dist, p FROM kd_point_tbl WHERE p <@ box '(200,200,1000,1000)';
SELECT * FROM x AS x FULL JOIN x AS x ON x.x = x.x WHERE x.x IS DISTINCT FROM x.x;
EXPLAIN (COSTS OFF) SELECT row_number() OVER (ORDER BY p <-> '333,400') n, p <-> '333,400' dist, p FROM kd_point_tbl WHERE p IS NOT NULL;
CREATE TEMPORARY TABLE x AS SELECT ROW_NUMBER() OVER (ORDER BY x <-> '333,400' NULLS LAST) AS x, x <-> '333,400' AS x, x FROM x WHERE NOT x IS NULL;
SELECT * FROM x AS x FULL JOIN x AS x ON x.x = x.x WHERE x.x IS DISTINCT FROM x.x;
SET x = 0 /* test KNN scan with included columns */ /* the distance numbers are not exactly the same across platforms */;
CREATE INDEX ON x USING spgist(x NULLS LAST) INCLUDE (x);
EXPLAIN (COSTS OFF) SELECT p, dist FROM quad_point_tbl_ord_seq1 ORDER BY p <-> '0,0' LIMIT 10;
SELECT x, x FROM x ORDER BY x <-> '0,0' NULLS LAST LIMIT 10;
RESET extra_float_digits;
EXPLAIN (COSTS OFF) SELECT count(*) FROM radix_text_tbl WHERE t = 'P0123456789abcdef';
SELECT COUNT(*) FROM x WHERE x = 'P0123456789abcdef';
EXPLAIN (COSTS OFF) SELECT count(*) FROM radix_text_tbl WHERE t = 'P0123456789abcde';
SELECT COUNT(*) FROM x WHERE x = 'P0123456789abcde';
EXPLAIN (COSTS OFF) SELECT count(*) FROM radix_text_tbl WHERE t = 'P0123456789abcdefF';
SELECT COUNT(*) FROM x WHERE x = 'P0123456789abcdefF';
EXPLAIN (COSTS OFF) SELECT count(*) FROM radix_text_tbl WHERE t <    'Aztec                         Ct  ';
SELECT COUNT(*) FROM x WHERE x < 'Aztec                         Ct  ';
EXPLAIN (COSTS OFF) SELECT count(*) FROM radix_text_tbl WHERE t ~<~  'Aztec                         Ct  ';
EXPLAIN (COSTS OFF) SELECT count(*) FROM radix_text_tbl WHERE t <=   'Aztec                         Ct  ';
SELECT COUNT(*) FROM x WHERE x <= 'Aztec                         Ct  ';
EXPLAIN (COSTS OFF) SELECT count(*) FROM radix_text_tbl WHERE t ~<=~ 'Aztec                         Ct  ';
EXPLAIN (COSTS OFF) SELECT count(*) FROM radix_text_tbl WHERE t =    'Aztec                         Ct  ';
SELECT COUNT(*) FROM x WHERE x = 'Aztec                         Ct  ';
EXPLAIN (COSTS OFF) SELECT count(*) FROM radix_text_tbl WHERE t =    'Worth                         St  ';
SELECT COUNT(*) FROM x WHERE x = 'Worth                         St  ';
EXPLAIN (COSTS OFF) SELECT count(*) FROM radix_text_tbl WHERE t >=   'Worth                         St  ';
SELECT COUNT(*) FROM x WHERE x >= 'Worth                         St  ';
EXPLAIN (COSTS OFF) SELECT count(*) FROM radix_text_tbl WHERE t ~>=~ 'Worth                         St  ';
EXPLAIN (COSTS OFF) SELECT count(*) FROM radix_text_tbl WHERE t >    'Worth                         St  ';
SELECT COUNT(*) FROM x WHERE x > 'Worth                         St  ';
EXPLAIN (COSTS OFF) SELECT count(*) FROM radix_text_tbl WHERE t ~>~  'Worth                         St  ';
EXPLAIN (COSTS OFF) SELECT count(*) FROM radix_text_tbl WHERE t ^@	 'Worth';
SELECT COUNT(*) FROM x WHERE POWER(x, @'Worth');
EXPLAIN (COSTS OFF) SELECT count(*) FROM radix_text_tbl WHERE starts_with(t, 'Worth');
SELECT COUNT(*) FROM x WHERE STARTS_WITH(x, 'Worth');
SET x = OFF /* Now check the results from bitmap indexscan */;
SET x = OFF;
SET x = ON;
EXPLAIN (COSTS OFF) SELECT count(*) FROM quad_point_tbl WHERE p IS NULL;
SELECT COUNT(*) FROM x WHERE x IS NULL;
EXPLAIN (COSTS OFF) SELECT count(*) FROM quad_point_tbl WHERE p IS NOT NULL;
SELECT COUNT(*) FROM x WHERE NOT x IS NULL;
EXPLAIN (COSTS OFF) SELECT count(*) FROM quad_point_tbl;
SELECT COUNT(*) FROM x;
EXPLAIN (COSTS OFF) SELECT count(*) FROM quad_point_tbl WHERE p <@ box '(200,200,1000,1000)';
EXPLAIN (COSTS OFF) SELECT count(*) FROM quad_point_tbl WHERE box '(200,200,1000,1000)' @> p;
EXPLAIN (COSTS OFF) SELECT count(*) FROM quad_point_tbl WHERE p << '(5000, 4000)';
SELECT COUNT(*) FROM x WHERE x << '(5000, 4000)';
EXPLAIN (COSTS OFF) SELECT count(*) FROM quad_point_tbl WHERE p >> '(5000, 4000)';
SELECT COUNT(*) FROM x WHERE x >> '(5000, 4000)';
EXPLAIN (COSTS OFF) SELECT count(*) FROM quad_point_tbl WHERE p <<| '(5000, 4000)';
EXPLAIN (COSTS OFF) SELECT count(*) FROM quad_point_tbl WHERE p |>> '(5000, 4000)';
EXPLAIN (COSTS OFF) SELECT count(*) FROM quad_point_tbl WHERE p ~= '(4585, 365)';
EXPLAIN (COSTS OFF) SELECT count(*) FROM kd_point_tbl WHERE p <@ box '(200,200,1000,1000)';
EXPLAIN (COSTS OFF) SELECT count(*) FROM kd_point_tbl WHERE box '(200,200,1000,1000)' @> p;
EXPLAIN (COSTS OFF) SELECT count(*) FROM kd_point_tbl WHERE p << '(5000, 4000)';
SELECT COUNT(*) FROM x WHERE x << '(5000, 4000)';
EXPLAIN (COSTS OFF) SELECT count(*) FROM kd_point_tbl WHERE p >> '(5000, 4000)';
SELECT COUNT(*) FROM x WHERE x >> '(5000, 4000)';
EXPLAIN (COSTS OFF) SELECT count(*) FROM kd_point_tbl WHERE p <<| '(5000, 4000)';
EXPLAIN (COSTS OFF) SELECT count(*) FROM kd_point_tbl WHERE p |>> '(5000, 4000)';
EXPLAIN (COSTS OFF) SELECT count(*) FROM kd_point_tbl WHERE p ~= '(4585, 365)';
EXPLAIN (COSTS OFF) SELECT count(*) FROM radix_text_tbl WHERE t = 'P0123456789abcdef';
SELECT COUNT(*) FROM x WHERE x = 'P0123456789abcdef';
EXPLAIN (COSTS OFF) SELECT count(*) FROM radix_text_tbl WHERE t = 'P0123456789abcde';
SELECT COUNT(*) FROM x WHERE x = 'P0123456789abcde';
EXPLAIN (COSTS OFF) SELECT count(*) FROM radix_text_tbl WHERE t = 'P0123456789abcdefF';
SELECT COUNT(*) FROM x WHERE x = 'P0123456789abcdefF';
EXPLAIN (COSTS OFF) SELECT count(*) FROM radix_text_tbl WHERE t <    'Aztec                         Ct  ';
SELECT COUNT(*) FROM x WHERE x < 'Aztec                         Ct  ';
EXPLAIN (COSTS OFF) SELECT count(*) FROM radix_text_tbl WHERE t ~<~  'Aztec                         Ct  ';
EXPLAIN (COSTS OFF) SELECT count(*) FROM radix_text_tbl WHERE t <=   'Aztec                         Ct  ';
SELECT COUNT(*) FROM x WHERE x <= 'Aztec                         Ct  ';
EXPLAIN (COSTS OFF) SELECT count(*) FROM radix_text_tbl WHERE t ~<=~ 'Aztec                         Ct  ';
EXPLAIN (COSTS OFF) SELECT count(*) FROM radix_text_tbl WHERE t =    'Aztec                         Ct  ';
SELECT COUNT(*) FROM x WHERE x = 'Aztec                         Ct  ';
EXPLAIN (COSTS OFF) SELECT count(*) FROM radix_text_tbl WHERE t =    'Worth                         St  ';
SELECT COUNT(*) FROM x WHERE x = 'Worth                         St  ';
EXPLAIN (COSTS OFF) SELECT count(*) FROM radix_text_tbl WHERE t >=   'Worth                         St  ';
SELECT COUNT(*) FROM x WHERE x >= 'Worth                         St  ';
EXPLAIN (COSTS OFF) SELECT count(*) FROM radix_text_tbl WHERE t ~>=~ 'Worth                         St  ';
EXPLAIN (COSTS OFF) SELECT count(*) FROM radix_text_tbl WHERE t >    'Worth                         St  ';
SELECT COUNT(*) FROM x WHERE x > 'Worth                         St  ';
EXPLAIN (COSTS OFF) SELECT count(*) FROM radix_text_tbl WHERE t ~>~  'Worth                         St  ';
EXPLAIN (COSTS OFF) SELECT count(*) FROM radix_text_tbl WHERE t ^@	 'Worth';
SELECT COUNT(*) FROM x WHERE POWER(x, @'Worth');
EXPLAIN (COSTS OFF) SELECT count(*) FROM radix_text_tbl WHERE starts_with(t, 'Worth');
SELECT COUNT(*) FROM x WHERE STARTS_WITH(x, 'Worth');
RESET enable_seqscan;
RESET enable_indexscan;
RESET enable_bitmapscan;
/* CREATE_MISC */ /* a is the type root */ /* b and c inherit from a (one-level single inheritance) */ /* d inherits from b and c (two-level multiple inheritance) */ /* e inherits from c (two-level single inheritance) */ /* f inherits from e (three-level single inheritance) */ CREATE TABLE x (x CHAR, x INT);
CREATE TABLE x (x TEXT) INHERITS (x);
CREATE TABLE x (x NAME) INHERITS (x);
CREATE TABLE x (x DOUBLE) INHERITS (x, x);
CREATE TABLE x (x SMALLINT) INHERITS (x);
CREATE TABLE x (x polygon) INHERITS (x);
INSERT INTO x (x, x) VALUES ('a', 1);
INSERT INTO x (x, x) VALUES ('a', 2);
INSERT INTO x (x) VALUES ('a');
INSERT INTO x (x, x, x) VALUES ('b', 3, CAST('mumble' AS TEXT));
INSERT INTO x (x, x) VALUES ('b', 4);
INSERT INTO x (x, x) VALUES ('b', CAST('bumble' AS TEXT));
INSERT INTO x (x) VALUES ('b');
INSERT INTO x (x, x, x) VALUES ('c', 5, CAST('hi mom' AS NAME));
INSERT INTO x (x, x) VALUES ('c', 6);
INSERT INTO x (x, x) VALUES ('c', CAST('hi paul' AS NAME));
INSERT INTO x (x) VALUES ('c');
INSERT INTO x (x, x, x, x, x) VALUES ('d', 7, CAST('grumble' AS TEXT), CAST('hi sunita' AS NAME), CAST('0.0' AS DOUBLE));
INSERT INTO x (x, x, x, x) VALUES ('d', 8, CAST('stumble' AS TEXT), CAST('hi koko' AS NAME));
INSERT INTO x (x, x, x, x) VALUES ('d', 9, CAST('rumble' AS TEXT), CAST('1.1' AS DOUBLE));
INSERT INTO x (x, x, x, x) VALUES ('d', 10, CAST('hi kristin' AS NAME), CAST('10.01' AS DOUBLE));
INSERT INTO x (x, x, x, x) VALUES ('d', CAST('crumble' AS TEXT), CAST('hi boris' AS NAME), CAST('100.001' AS DOUBLE));
INSERT INTO x (x, x, x) VALUES ('d', 11, CAST('fumble' AS TEXT));
INSERT INTO x (x, x, x) VALUES ('d', 12, CAST('hi avi' AS NAME));
INSERT INTO x (x, x, x) VALUES ('d', 13, CAST('1000.0001' AS DOUBLE));
INSERT INTO x (x, x, x) VALUES ('d', CAST('tumble' AS TEXT), CAST('hi andrew' AS NAME));
INSERT INTO x (x, x, x) VALUES ('d', CAST('humble' AS TEXT), CAST('10000.00001' AS DOUBLE));
INSERT INTO x (x, x, x) VALUES ('d', CAST('hi ginger' AS NAME), CAST('100000.000001' AS DOUBLE));
INSERT INTO x (x, x) VALUES ('d', 14);
INSERT INTO x (x, x) VALUES ('d', CAST('jumble' AS TEXT));
INSERT INTO x (x, x) VALUES ('d', CAST('hi jolly' AS NAME));
INSERT INTO x (x, x) VALUES ('d', CAST('1000000.0000001' AS DOUBLE));
INSERT INTO x (x) VALUES ('d');
INSERT INTO x (x, x, x, x) VALUES ('e', 15, CAST('hi carol' AS NAME), CAST('-1' AS SMALLINT));
INSERT INTO x (x, x, x) VALUES ('e', 16, CAST('hi bob' AS NAME));
INSERT INTO x (x, x, x) VALUES ('e', 17, CAST('-2' AS SMALLINT));
INSERT INTO x (x, x, x) VALUES ('e', CAST('hi michelle' AS NAME), CAST('-3' AS SMALLINT));
INSERT INTO x (x, x) VALUES ('e', 18);
INSERT INTO x (x, x) VALUES ('e', CAST('hi elisa' AS NAME));
INSERT INTO x (x, x) VALUES ('e', CAST('-4' AS SMALLINT));
INSERT INTO x (x, x, x, x, x) VALUES ('f', 19, CAST('hi claire' AS NAME), CAST('-5' AS SMALLINT), CAST('(1,3),(2,4)' AS polygon));
INSERT INTO x (x, x, x, x) VALUES ('f', 20, CAST('hi mike' AS NAME), CAST('-6' AS SMALLINT));
INSERT INTO x (x, x, x, x) VALUES ('f', 21, CAST('hi marcel' AS NAME), CAST('(11,44),(22,55),(33,66)' AS polygon));
INSERT INTO x (x, x, x, x) VALUES ('f', 22, CAST('-7' AS SMALLINT), CAST('(111,555),(222,666),(333,777),(444,888)' AS polygon));
INSERT INTO x (x, x, x, x) VALUES ('f', CAST('hi keith' AS NAME), CAST('-8' AS SMALLINT), CAST('(1111,3333),(2222,4444)' AS polygon));
INSERT INTO x (x, x, x) VALUES ('f', 24, CAST('hi marc' AS NAME));
INSERT INTO x (x, x, x) VALUES ('f', 25, CAST('-9' AS SMALLINT));
INSERT INTO x (x, x, x) VALUES ('f', 26, CAST('(11111,33333),(22222,44444)' AS polygon));
INSERT INTO x (x, x, x) VALUES ('f', CAST('hi allison' AS NAME), CAST('-10' AS SMALLINT));
INSERT INTO x (x, x, x) VALUES ('f', CAST('hi jeff' AS NAME), CAST('(111111,333333),(222222,444444)' AS polygon));
INSERT INTO x (x, x, x) VALUES ('f', CAST('-11' AS SMALLINT), CAST('(1111111,3333333),(2222222,4444444)' AS polygon));
INSERT INTO x (x, x) VALUES ('f', 27);
INSERT INTO x (x, x) VALUES ('f', CAST('hi carl' AS NAME));
INSERT INTO x (x, x) VALUES ('f', CAST('-12' AS SMALLINT));
INSERT INTO x (x, x) VALUES ('f', CAST('(11111111,33333333),(22222222,44444444)' AS polygon));
INSERT INTO x (x) VALUES ('f');
ANALYZE x /* Analyze the X_star tables for better plan stability in later tests */;
ANALYZE x;
ANALYZE x;
ANALYZE x;
ANALYZE x;
ANALYZE x;
/* inheritance stress test */ SELECT * FROM x;
SELECT * FROM x AS x WHERE x.x = CAST('bumble' AS TEXT) OR x.x < 3;
SELECT x, x FROM x AS x WHERE REGEXP_LIKE(x.x, CAST('hi' AS TEXT));
SELECT x, x, x FROM x AS x WHERE x.x < 100;
SELECT x, x FROM x AS x WHERE NOT x.x IS NULL;
SELECT * FROM x AS x WHERE x.x IS NULL;
/* grouping and aggregation on inherited sets have been busted in the past... */ SELECT SUM(x) FROM x;
SELECT x, SUM(x) FROM x GROUP BY x ORDER BY x NULLS LAST;
ALTER TABLE x RENAME COLUMN x TO x;
ALTER TABLE x RENAME COLUMN x TO x;
ALTER TABLE x RENAME COLUMN x TO x;
ALTER TABLE x RENAME COLUMN x TO x;
ALTER TABLE x RENAME COLUMN x TO x;
ALTER TABLE x RENAME COLUMN x TO x;
SELECT x, x FROM x AS x WHERE x IS NULL;
ALTER TABLE x RENAME COLUMN x TO x /* As of Postgres 7.1, ALTER implicitly recurses, */ /* so this should be same as ALTER a_star* */;
SELECT x, x FROM x AS x WHERE x.x >= 2;
ALTER TABLE x RENAME COLUMN x TO x;
SELECT * FROM x WHERE x < 1000;
ALTER TABLE x ADD COLUMN x INT;
UPDATE x SET x = 10;
ALTER TABLE x ADD COLUMN x INT;
SELECT * FROM x;
ALTER TABLE x ADD COLUMN x TEXT;
/* That ALTER TABLE should have added TOAST tables. */ SELECT x, x <> 0 AS x FROM x WHERE CAST(x AS REGCLASS) IN ('a_star', 'c_star') ORDER BY 1 NULLS LAST;
SELECT x, x, x FROM x;
/* CREATE_OPERATOR */ CREATE OPERATOR ## (    leftarg = path,    rightarg = path,    function = path_inter,    commutator = ## );
CREATE OPERATOR @#@ (    rightarg = int8,		-- prefix    procedure = factorial );
CREATE OPERATOR #%# (    leftarg = int8,		-- fail, postfix is no longer supported    procedure = factorial );
/* Test comments */ COMMENT ON OPERATOR ###### (NONE, int4) IS 'bad prefix';
COMMENT ON OPERATOR ###### (int4, NONE) IS 'bad postfix';
COMMENT ON OPERATOR ###### (int4, int8) IS 'bad infix';
/* Check that DROP on a nonexistent op behaves sanely, too */ DROP OPERATOR ###### (NONE, int4);
DROP OPERATOR ###### (int4, NONE);
DROP OPERATOR ###### (int4, int8);
/* => is disallowed as an operator name now */ CREATE OPERATOR => (    rightarg = int8,    procedure = factorial );
/* lexing of <=, >=, <>, != has a number of edge cases */ /* (=> is tested elsewhere) */ /* this is legal because ! is not allowed in sql ops */ CREATE OPERATOR !=- (    rightarg = int8,    procedure = factorial );
/* make sure lexer returns != as <> even in edge cases */ SELECT 2 <> 1, 2 <> 2;
SELECT 2 <> /* comment to be removed by psql */ 1;
BEGIN execute $e$ select 2 !=-- comment       1 $e$ into r;
COMMIT;
/* check that <= etc. followed by more operator characters are returned */ /* as the correct token with correct precedence */ SELECT TRUE <> -1 BETWEEN 1 AND 1;
/* BETWEEN has prec. above <> but below Op */ SELECT FALSE <> 1 BETWEEN 1 AND 1;
SELECT FALSE <= -1 BETWEEN 1 AND 1;
SELECT FALSE >= -1 BETWEEN 1 AND 1;
SELECT 2 <= 3, 3 >= 2, 2 <> 3;
SELECT 3 <= 2, 2 >= 3, 2 <> 2;
BEGIN /* Should fail. CREATE OPERATOR requires USAGE on SCHEMA */ /* Should fail. CREATE OPERATOR requires USAGE on SCHEMA */;
CREATE ROLE regress_rol_op1;
CREATE SCHEMA x.x;
GRANT USAGE ON SCHEMA x TO x;
REVOKE USAGE ON SCHEMA schema_op1 FROM regress_rol_op1;
SET ROLE regress_rol_op1;
CREATE OPERATOR schema_op1.#*# (    rightarg = int8,    procedure = factorial );
ROLLBACK;
BEGIN /* Should fail. SETOF type functions not allowed as argument (testing leftarg) */ /* Should fail. SETOF type functions not allowed as argument (testing leftarg) */;
CREATE OPERATOR #*# (    leftarg = SETOF int8,    procedure = factorial );
ROLLBACK;
BEGIN /* Should fail. SETOF type functions not allowed as argument (testing rightarg) */ /* Should fail. SETOF type functions not allowed as argument (testing rightarg) */;
CREATE OPERATOR #*# (    rightarg = SETOF int8,    procedure = factorial );
ROLLBACK;
BEGIN /* Should work. Sample text-book case */ /* Should work. Sample text-book case */;
ROLLBACK;
/* Should fail. Invalid attribute */ CREATE OPERATOR #@%# (    rightarg = int8,    procedure = factorial,    invalid_att = int8 );
/* Should fail. At least rightarg should be mandatorily specified */ CREATE OPERATOR #@%# (    procedure = factorial );
/* Should fail. Procedure should be mandatorily specified */ CREATE OPERATOR #@%# (    rightarg = int8 );
BEGIN /* Should fail. CREATE OPERATOR requires USAGE on TYPE */ /* Should fail. CREATE OPERATOR requires USAGE on TYPE */;
CREATE ROLE regress_rol_op3;
CREATE TYPE type_op3 AS ENUM ('new', 'open', 'closed');
REVOKE USAGE ON TYPE type_op3 FROM regress_rol_op3;
REVOKE USAGE ON TYPE type_op3 FROM PUBLIC;
/* Need to do this so that regress_rol_op3 is not allowed USAGE via PUBLIC */ SET ROLE regress_rol_op3;
CREATE OPERATOR #*# (    leftarg = type_op3,    rightarg = int8,    procedure = fn_op3 );
ROLLBACK;
BEGIN /* Should fail. CREATE OPERATOR requires USAGE on TYPE (need to check separately for rightarg) */ /* Should fail. CREATE OPERATOR requires USAGE on TYPE (need to check separately for rightarg) */;
CREATE ROLE regress_rol_op4;
CREATE TYPE type_op4 AS ENUM ('new', 'open', 'closed');
REVOKE USAGE ON TYPE type_op4 FROM regress_rol_op4;
REVOKE USAGE ON TYPE type_op4 FROM PUBLIC;
/* Need to do this so that regress_rol_op3 is not allowed USAGE via PUBLIC */ SET ROLE regress_rol_op4;
CREATE OPERATOR #*# (    leftarg = int8,    rightarg = type_op4,    procedure = fn_op4 );
ROLLBACK;
BEGIN /* Should fail. CREATE OPERATOR requires EXECUTE on function */ /* Should fail. CREATE OPERATOR requires EXECUTE on function */;
CREATE ROLE regress_rol_op5;
CREATE TYPE type_op5 AS ENUM ('new', 'open', 'closed');
REVOKE EXECUTE ON FUNCTION fn_op5(int8, int8) FROM regress_rol_op5;
REVOKE EXECUTE ON FUNCTION fn_op5(int8, int8) FROM PUBLIC;
/* Need to do this so that regress_rol_op3 is not allowed EXECUTE via PUBLIC */ SET ROLE regress_rol_op5;
CREATE OPERATOR #*# (    leftarg = int8,    rightarg = int8,    procedure = fn_op5 );
ROLLBACK;
BEGIN /* Should fail. CREATE OPERATOR requires USAGE on return TYPE */ /* Should fail. CREATE OPERATOR requires USAGE on return TYPE */;
CREATE ROLE regress_rol_op6;
CREATE TYPE type_op6 AS ENUM ('new', 'open', 'closed');
REVOKE USAGE ON TYPE type_op6 FROM regress_rol_op6;
REVOKE USAGE ON TYPE type_op6 FROM PUBLIC;
/* Need to do this so that regress_rol_op3 is not allowed USAGE via PUBLIC */ SET ROLE regress_rol_op6;
CREATE OPERATOR #*# (    leftarg = int8,    rightarg = int8,    procedure = fn_op6 );
ROLLBACK;
BEGIN /* Should fail. An operator cannot be its own negator. */ /* Should fail. An operator cannot be its own negator. */;
ROLLBACK;
BEGIN /* Should fail. An operator cannot be its own negator. Here we check that */ /* this error is detected when replacing a shell operator. */ /* Should fail. An operator cannot be its own negator. Here we check that */ /* this error is detected when replacing a shell operator. */;
ROLLBACK;
CALL nonexistent();
/* error */ CALL random();
/* error */ CREATE FUNCTION x(x INT) RETURNS INT LANGUAGE SQL AS $$ SELECT a $$;
CREATE TABLE x (x INT, x TEXT);
/* error */ CALL ptest1('a');
/* ok */ CALL ptest1('xy' || 'zzy');
/* ok, constant-folded arg */ CALL ptest1(substring(random()::numeric(20,15)::text, 1, 1));
/* ok, volatile arg */ SELECT * FROM x ORDER BY x COLLATE "x" NULLS LAST;
/* SQL-standard body */ CREATE PROCEDURE x(x TEXT) LANGUAGE SQL AS BEGIN ATOMIC   INSERT INTO cp_test VALUES (1, x);
COMMIT;
CALL ptest1s('b');
SELECT * FROM x ORDER BY x COLLATE "x" NULLS LAST;
/* utility functions currently not supported here */ CREATE PROCEDURE x() LANGUAGE SQL AS BEGIN ATOMIC   CREATE TABLE x (a int);
COMMIT;
CALL ptest2();
TRUNCATE TABLE x /* nested CALL */;
CALL ptest1($1);
CALL ptest3('b');
SELECT * FROM x;
CALL ptest4a(NULL, NULL);
CALL ptest4c(NULL);
INSERT INTO x VALUES (x, x);
TRUNCATE TABLE x;
CALL ptest5(10, 'Hello', 20);
CALL ptest5(10, 'Hello');
CALL ptest5(10, b => 'Hello');
CALL ptest5(b => 'Hello', a => 10);
SELECT * FROM x;
CALL ptest6(1, 2);
CALL ptest6a(1, null);
CALL ptest6a(1.1, null);
CALL ptest6b(1, null, null);
CALL ptest6b(1.1, null, null);
CALL ptest6c(1, null);
CALL ptest6c(1.1, null);
CALL ptest7(least('a', 'b'), 'a');
/* empty body */ CREATE PROCEDURE x(x TEXT) AS BEGIN ATOMIC END;
CALL ptest8('');
SELECT 1;
/* standard way to do a call: */ CALL ptest9(NULL);
/* you can write an expression, but it's not evaluated */ CALL ptest9(1/0);
/* no error */ /* ... and it had better match the type of the parameter */ CALL ptest9(1./0.);
CALL ptest10(null, 7, 4);
CALL ptest10(a => null, b => 8, c => 2);
CALL ptest10(null, 7, c => 2);
CALL ptest10(null, c => 4, b => 11);
CALL ptest10(b => 8, c => 2, a => 0);
CALL ptest11(null, 11, 12, 13);
/* fail */ DROP PROCEDURE x (INT, INT, INT);
/* fail */ BEGIN;
ROLLBACK /* now this would work */ /* now this would work */;
BEGIN;
ROLLBACK /* now this would work */ /* now this would work */;
/* various error cases */ CALL version();
/* error: not a procedure */ CALL sum(1);
/* error: not a procedure */ CREATE PROCEDURE x() LANGUAGE SQL AS x AS x;
CREATE PROCEDURE x() LANGUAGE SQL STRICT AS $$ INSERT INTO cp_test VALUES (1, 'a') $$;
ALTER PROCEDURE ptest1(text) STRICT;
ALTER FUNCTION ptest1(text) VOLATILE;
/* error: not a function */ ALTER PROCEDURE cp_testfunc1(int) VOLATILE;
/* error: not a procedure */ ALTER PROCEDURE nonexistent() VOLATILE;
DROP FUNCTION x (TEXT);
/* error: not a function */ DROP PROCEDURE x (INT);
/* error: not a procedure */ DROP PROCEDURE x;
/* privileges */ CREATE USER regress_cp_user1;
GRANT INSERT ON x TO x;
REVOKE EXECUTE ON PROCEDURE ptest1(text) FROM PUBLIC;
SET ROLE regress_cp_user1;
CALL ptest1('a');
/* error */ RESET ROLE;
GRANT EXECUTE ON PROCEDURE x TO x;
SET ROLE regress_cp_user1;
CALL ptest1('a');
/* ok */ RESET ROLE;
/* ROUTINE syntax */ ALTER ROUTINE cp_testfunc1(int) RENAME TO cp_testfunc1a;
ALTER ROUTINE cp_testfunc1a RENAME TO cp_testfunc1;
ALTER ROUTINE ptest1(text) RENAME TO ptest1a;
ALTER ROUTINE ptest1a RENAME TO ptest1;
DROP ROUTINE cp_testfunc1(int);
/* cleanup */ DROP PROCEDURE x;
DROP PROCEDURE x;
DROP PROCEDURE x;
DROP TABLE x;
DROP USER regress_cp_user1;
/* ok, superuser can create users with any set of privileges */ CREATE ROLE regress_role_super SUPERUSER;
CREATE ROLE regress_role_admin CREATEDB CREATEROLE REPLICATION BYPASSRLS;
GRANT CREATE ON DATABASE x TO x WITH GRANT OPTION;
CREATE ROLE regress_role_limited_admin CREATEROLE;
CREATE ROLE regress_role_normal;
/* fail, CREATEROLE user can't give away role attributes without having them */ SET SESSION AUTHORIZATION regress_role_limited_admin;
CREATE ROLE regress_nosuch_superuser SUPERUSER;
CREATE ROLE regress_nosuch_replication_bypassrls REPLICATION BYPASSRLS;
CREATE ROLE regress_nosuch_replication REPLICATION;
CREATE ROLE regress_nosuch_bypassrls BYPASSRLS;
CREATE ROLE regress_nosuch_createdb CREATEDB;
/* ok, can create a role without any special attributes */ CREATE ROLE regress_role_limited;
/* fail, can't give it in any of the restricted attributes */ ALTER ROLE regress_role_limited SUPERUSER;
ALTER ROLE regress_role_limited REPLICATION;
ALTER ROLE regress_role_limited CREATEDB;
ALTER ROLE regress_role_limited BYPASSRLS;
DROP ROLE regress_role_limited;
/* ok, can give away these role attributes if you have them */ SET SESSION AUTHORIZATION regress_role_admin;
CREATE ROLE regress_replication_bypassrls REPLICATION BYPASSRLS;
CREATE ROLE regress_replication REPLICATION;
CREATE ROLE regress_bypassrls BYPASSRLS;
CREATE ROLE regress_createdb CREATEDB;
/* ok, can toggle these role attributes off and on if you have them */ ALTER ROLE regress_replication NOREPLICATION;
ALTER ROLE regress_replication REPLICATION;
ALTER ROLE regress_bypassrls NOBYPASSRLS;
ALTER ROLE regress_bypassrls BYPASSRLS;
ALTER ROLE regress_createdb NOCREATEDB;
ALTER ROLE regress_createdb CREATEDB;
/* fail, can't toggle SUPERUSER */ ALTER ROLE regress_createdb SUPERUSER;
ALTER ROLE regress_createdb NOSUPERUSER;
/* ok, having CREATEROLE is enough to create users with these privileges */ CREATE ROLE regress_createrole CREATEROLE NOINHERIT;
GRANT CREATE ON DATABASE x TO x WITH GRANT OPTION;
CREATE ROLE regress_login LOGIN;
CREATE ROLE regress_inherit INHERIT;
CREATE ROLE regress_connection_limit CONNECTION LIMIT 5;
CREATE ROLE regress_encrypted_password ENCRYPTED PASSWORD 'foo';
CREATE ROLE regress_password_null PASSWORD NULL;
/* ok, backwards compatible noise words should be ignored */ CREATE ROLE regress_noiseword SYSID 12345;
/* fail, cannot grant membership in superuser role */ CREATE ROLE regress_nosuch_super IN ROLE regress_role_super;
/* fail, database owner cannot have members */ CREATE ROLE regress_nosuch_dbowner IN ROLE pg_database_owner;
/* ok, can grant other users into a role */ CREATE ROLE regress_inroles ROLE 	regress_role_super, regress_createdb, regress_createrole, regress_login, 	regress_inherit, regress_connection_limit, regress_encrypted_password, regress_password_null;
/* fail, cannot grant a role into itself */ CREATE ROLE regress_nosuch_recursive ROLE regress_nosuch_recursive;
/* ok, can grant other users into a role with admin option */ CREATE ROLE regress_adminroles ADMIN 	regress_role_super, regress_createdb, regress_createrole, regress_login, 	regress_inherit, regress_connection_limit, regress_encrypted_password, regress_password_null;
/* fail, cannot grant a role into itself with admin option */ CREATE ROLE regress_nosuch_admin_recursive ADMIN regress_nosuch_admin_recursive;
/* fail, regress_createrole does not have CREATEDB privilege */ SET SESSION AUTHORIZATION regress_createrole;
CREATE DATABASE x;
/* ok, regress_createrole can create new roles */ CREATE ROLE regress_plainrole;
/* ok, roles with CREATEROLE can create new roles with it */ CREATE ROLE regress_rolecreator CREATEROLE;
/* ok, roles with CREATEROLE can create new roles with different role */ /* attributes, including CREATEROLE */ CREATE ROLE regress_hasprivs CREATEROLE LOGIN INHERIT CONNECTION LIMIT 5;
/* ok, we should be able to modify a role we created */ COMMENT ON ROLE regress_hasprivs IS 'some comment';
ALTER ROLE regress_hasprivs RENAME TO regress_tenant;
ALTER ROLE regress_tenant NOINHERIT NOLOGIN CONNECTION LIMIT 7;
/* fail, we should be unable to modify a role we did not create */ COMMENT ON ROLE regress_role_normal IS 'some comment';
ALTER ROLE regress_role_normal RENAME TO regress_role_abnormal;
ALTER ROLE regress_role_normal NOINHERIT NOLOGIN CONNECTION LIMIT 7;
/* ok, regress_tenant can create objects within the database */ SET SESSION AUTHORIZATION regress_tenant;
CREATE TABLE x (x INT);
CREATE INDEX x ON x(x NULLS LAST);
CREATE VIEW x AS SELECT * FROM x.x;
REVOKE ALL PRIVILEGES ON tenant_table FROM PUBLIC;
/* fail, these objects belonging to regress_tenant */ SET SESSION AUTHORIZATION regress_createrole;
DROP INDEX x;
ALTER TABLE x ADD COLUMN x TEXT;
DROP TABLE x;
ALTER VIEW tenant_view OWNER TO regress_role_admin;
DROP VIEW x;
/* fail, can't create objects owned as regress_tenant */ CREATE SCHEMA regress_tenant_schema AUTHORIZATION regress_tenant;
SET x = 'set, inherit' /* ok, create a role with a value for createrole_self_grant */;
CREATE ROLE regress_tenant2;
GRANT CREATE ON DATABASE x TO x;
/* ok, regress_tenant2 can create objects within the database */ SET SESSION AUTHORIZATION regress_tenant2;
CREATE TABLE x (x INT);
REVOKE ALL PRIVILEGES ON tenant2_table FROM PUBLIC;
/* ok, because we have SET and INHERIT on regress_tenant2 */ SET SESSION AUTHORIZATION regress_createrole;
CREATE SCHEMA regress_tenant2_schema AUTHORIZATION regress_tenant2;
ALTER SCHEMA regress_tenant2_schema OWNER TO regress_createrole;
ALTER TABLE tenant2_table OWNER TO regress_createrole;
ALTER TABLE tenant2_table OWNER TO regress_tenant2;
/* with SET but not INHERIT, we can give away objects but not take them */ REVOKE INHERIT OPTION FOR regress_tenant2 FROM regress_createrole;
ALTER SCHEMA regress_tenant2_schema OWNER TO regress_tenant2;
ALTER TABLE tenant2_table OWNER TO regress_createrole;
/* with INHERIT but not SET, we can take objects but not give them away */ GRANT regress_tenant2 TO regress_createrole WITH INHERIT TRUE, SET FALSE;
ALTER TABLE tenant2_table OWNER TO regress_createrole;
ALTER TABLE tenant2_table OWNER TO regress_tenant2;
DROP TABLE x;
/* fail, CREATEROLE is not enough to create roles in privileged roles */ CREATE ROLE regress_read_all_data IN ROLE pg_read_all_data;
CREATE ROLE regress_write_all_data IN ROLE pg_write_all_data;
CREATE ROLE regress_monitor IN ROLE pg_monitor;
CREATE ROLE regress_read_all_settings IN ROLE pg_read_all_settings;
CREATE ROLE regress_read_all_stats IN ROLE pg_read_all_stats;
CREATE ROLE regress_stat_scan_tables IN ROLE pg_stat_scan_tables;
CREATE ROLE regress_read_server_files IN ROLE pg_read_server_files;
CREATE ROLE regress_write_server_files IN ROLE pg_write_server_files;
CREATE ROLE regress_execute_server_program IN ROLE pg_execute_server_program;
CREATE ROLE regress_signal_backend IN ROLE pg_signal_backend;
/* fail, role still owns database objects */ DROP ROLE regress_tenant;
/* fail, creation of these roles failed above so they do not now exist */ SET SESSION AUTHORIZATION regress_role_admin;
DROP ROLE regress_nosuch_superuser;
DROP ROLE regress_nosuch_replication_bypassrls;
DROP ROLE regress_nosuch_replication;
DROP ROLE regress_nosuch_bypassrls;
DROP ROLE regress_nosuch_super;
DROP ROLE regress_nosuch_dbowner;
DROP ROLE regress_nosuch_recursive;
DROP ROLE regress_nosuch_admin_recursive;
DROP ROLE regress_plainrole;
/* must revoke privileges before dropping role */ REVOKE CREATE ON DATABASE regression FROM regress_createrole CASCADE;
/* ok, should be able to drop non-superuser roles we created */ DROP ROLE regress_replication_bypassrls;
DROP ROLE regress_replication;
DROP ROLE regress_bypassrls;
DROP ROLE regress_createdb;
DROP ROLE regress_createrole;
DROP ROLE regress_login;
DROP ROLE regress_inherit;
DROP ROLE regress_connection_limit;
DROP ROLE regress_encrypted_password;
DROP ROLE regress_password_null;
DROP ROLE regress_noiseword;
DROP ROLE regress_inroles;
DROP ROLE regress_adminroles;
/* fail, cannot drop ourself, nor superusers or roles we lack ADMIN for */ DROP ROLE regress_role_super;
DROP ROLE regress_role_admin;
DROP ROLE regress_rolecreator;
/* ok */ RESET SESSION AUTHORIZATION;
REVOKE CREATE ON DATABASE regression FROM regress_role_admin CASCADE;
DROP INDEX x;
DROP TABLE x;
DROP VIEW x;
DROP SCHEMA x.x;
/* check for duplicated drop */ DROP ROLE regress_tenant, regress_tenant;
DROP ROLE regress_tenant2;
DROP ROLE regress_rolecreator;
DROP ROLE regress_role_admin;
DROP ROLE regress_role_limited_admin;
DROP ROLE regress_role_super;
DROP ROLE regress_role_normal;
/* CREATE_SCHEMA */ /* Schema creation with elements. */ CREATE ROLE regress_create_schema_role SUPERUSER;
/* Cases where schema creation fails as objects are qualified with a schema */ /* that does not match with what's expected. */ /* This checks all the object types that include schema qualifications. */ CREATE SCHEMA AUTHORIZATION regress_create_schema_role   CREATE SEQUENCE schema_not_existing.seq;
CREATE SCHEMA AUTHORIZATION regress_create_schema_role   CREATE TABLE schema_not_existing.tab (id int);
CREATE SCHEMA AUTHORIZATION regress_create_schema_role   CREATE VIEW schema_not_existing.view AS SELECT 1;
CREATE SCHEMA AUTHORIZATION regress_create_schema_role   CREATE INDEX ON schema_not_existing.tab (id);
CREATE SCHEMA AUTHORIZATION regress_create_schema_role   CREATE TRIGGER schema_trig BEFORE INSERT ON schema_not_existing.tab   EXECUTE FUNCTION schema_trig.no_func();
/* Again, with a role specification and no schema names. */ SET ROLE regress_create_schema_role;
CREATE SCHEMA AUTHORIZATION CURRENT_ROLE   CREATE SEQUENCE schema_not_existing.seq;
CREATE SCHEMA AUTHORIZATION CURRENT_ROLE   CREATE TABLE schema_not_existing.tab (id int);
CREATE SCHEMA AUTHORIZATION CURRENT_ROLE   CREATE VIEW schema_not_existing.view AS SELECT 1;
CREATE SCHEMA AUTHORIZATION CURRENT_ROLE   CREATE INDEX ON schema_not_existing.tab (id);
CREATE SCHEMA AUTHORIZATION CURRENT_ROLE   CREATE TRIGGER schema_trig BEFORE INSERT ON schema_not_existing.tab   EXECUTE FUNCTION schema_trig.no_func();
/* Again, with a schema name and a role specification. */ CREATE SCHEMA regress_schema_1 AUTHORIZATION CURRENT_ROLE   CREATE SEQUENCE schema_not_existing.seq;
CREATE SCHEMA regress_schema_1 AUTHORIZATION CURRENT_ROLE   CREATE TABLE schema_not_existing.tab (id int);
CREATE SCHEMA regress_schema_1 AUTHORIZATION CURRENT_ROLE   CREATE VIEW schema_not_existing.view AS SELECT 1;
CREATE SCHEMA regress_schema_1 AUTHORIZATION CURRENT_ROLE   CREATE INDEX ON schema_not_existing.tab (id);
CREATE SCHEMA regress_schema_1 AUTHORIZATION CURRENT_ROLE   CREATE TRIGGER schema_trig BEFORE INSERT ON schema_not_existing.tab   EXECUTE FUNCTION schema_trig.no_func();
RESET ROLE;
/* Cases where the schema creation succeeds. */ /* The schema created matches the role name. */ CREATE SCHEMA AUTHORIZATION regress_create_schema_role   CREATE TABLE regress_create_schema_role.tab (id int);
/* Again, with a different role specification and no schema names. */ SET ROLE regress_create_schema_role;
CREATE SCHEMA AUTHORIZATION CURRENT_ROLE   CREATE TABLE regress_create_schema_role.tab (id int);
/* Again, with a schema name and a role specification. */ CREATE SCHEMA regress_schema_1 AUTHORIZATION CURRENT_ROLE   CREATE TABLE regress_schema_1.tab (id int);
RESET ROLE;
/* Clean up */ DROP ROLE regress_create_schema_role;
/* CREATE_TABLE */ /* Error cases */ CREATE TABLE x (x UNKNOWN /* fail */);
CREATE TYPE unknown_comptype AS ( 	u unknown    -- fail );
/* invalid: non-lowercase quoted reloptions identifiers */ CREATE TABLE x WITH (Fillfactor=10) AS SELECT 1 AS x;
CREATE UNLOGGED TABLE x (x INT PRIMARY KEY);
/* OK */ CREATE TEMPORARY TABLE x (x INT PRIMARY KEY);
/* OK */ SELECT x, x, x FROM x WHERE REGEXP_LIKE(x, '^unlogged\d') ORDER BY x NULLS LAST;
REINDEX INDEX unlogged1_pkey;
REINDEX INDEX unlogged2_pkey;
SELECT x, x, x FROM x WHERE REGEXP_LIKE(x, '^unlogged\d') ORDER BY x NULLS LAST;
DROP TABLE x;
INSERT INTO x VALUES (42);
CREATE UNLOGGED TABLE x.x (x INT PRIMARY KEY);
/* also OK */ CREATE UNLOGGED TABLE x.x (x INT PRIMARY KEY);
/* not OK */ CREATE TABLE x.x (x INT PRIMARY KEY);
/* OK */ CREATE TEMPORARY TABLE x (x INT PRIMARY KEY);
/* also OK */ CREATE TEMPORARY TABLE x.x (x INT PRIMARY KEY);
/* also OK */ CREATE TEMPORARY TABLE x.x (x INT PRIMARY KEY);
CREATE UNLOGGED TABLE x (x INT) WITH (PARTITIONED_BY=RANGE(x));
/* fail */ CREATE TABLE x (x INT) WITH (PARTITIONED_BY=RANGE(x));
ALTER TABLE x SET  /* ok */;
ALTER TABLE x SET  /* fails */;
/* fails */ DROP TABLE x;
CREATE TABLE x AS SELECT * FROM x WHERE x = 'r';
CREATE TABLE x AS SELECT * FROM x WHERE x = 'r';
CREATE TABLE IF NOT EXISTS x AS SELECT * FROM x WHERE x = 'r';
DROP TABLE x;
PREPARE select1 AS SELECT 1 as a;
CREATE TABLE x EXECUTE AS select1;
CREATE TABLE x EXECUTE AS select1;
SELECT * FROM x;
CREATE TABLE IF NOT EXISTS x EXECUTE AS select1;
DROP TABLE x;
x AS x;
SELECT x, x FROM x;
/* check that tables with oids cannot be created anymore */ CREATE TABLE withoid() WITH OIDS;
CREATE TABLE x WITH (oids=TRUE);
/* but explicitly not adding oids is still supported */ CREATE TEMP TABLE withoutoid() WITHOUT OIDS;
DROP TABLE x;
CREATE TEMPORARY TABLE x WITH (oids=FALSE);
DROP TABLE x;
/* check restriction with default expressions */ /* invalid use of column reference in default expressions */ CREATE TABLE x (x INT DEFAULT (x));
CREATE TABLE x (x INT DEFAULT (x.x));
CREATE TABLE x (x INT DEFAULT (AVG(x)));
/* invalid column definition */ CREATE TABLE x (x INT DEFAULT (AVG(x)));
/* invalid use of aggregate */ CREATE TABLE x (x INT DEFAULT (AVG(1)));
/* invalid use of subquery */ CREATE TABLE x (x INT DEFAULT (SELECT 1));
/* invalid use of set-returning function */ CREATE TABLE x (x INT DEFAULT (UNNEST(GENERATE_SERIES(1, 3))));
/* Verify that subtransaction rollback restores rd_createSubid. */ BEGIN;
CREATE TABLE x (x INT);
x AS x;
DROP TABLE x;
ROLLBACK TO x;
COMMIT;
DROP TABLE x;
/* Verify that subtransaction rollback restores rd_firstRelfilenodeSubid. */ CREATE TABLE x (x INT);
BEGIN;
ALTER TABLE x ALTER COLUMN x SET DATA TYPE BIGINT;
x AS x;
DROP TABLE x;
ROLLBACK TO x;
COMMIT;
DROP TABLE x;
/* Partitioned tables */ /* cannot combine INHERITS and PARTITION BY (although grammar allows) */ CREATE TABLE x (x INT) INHERITS (x) WITH (PARTITIONED_BY=LIST(x));
/* cannot use more than 1 column as partition key for list partitioned table */ CREATE TABLE x (x INT, x INT) WITH (PARTITIONED_BY=LIST(x, x));
CREATE TABLE x (x INT) WITH (PARTITIONED_BY=RANGE(RETSET(x)));
DROP FUNCTION x (INT);
CREATE TABLE x (x INT) WITH (PARTITIONED_BY=RANGE((AVG(x))));
CREATE TABLE x (x INT, x INT) WITH (PARTITIONED_BY=RANGE((AVG(x) OVER (PARTITION BY x))));
CREATE TABLE x (x INT) WITH (PARTITIONED_BY=LIST((x LIKE (SELECT 1))));
CREATE TABLE x (x INT) WITH (PARTITIONED_BY=RANGE((42)));
CREATE TABLE x (x INT) WITH (PARTITIONED_BY=RANGE(CONST_FUNC()));
DROP FUNCTION x;
/* only accept valid partitioning strategy */ CREATE TABLE x (x INT) WITH (PARTITIONED_BY=MAGIC(x));
/* specified column must be present in the table */ CREATE TABLE x (x INT) WITH (PARTITIONED_BY=RANGE(x));
/* cannot use system columns in partition key */ CREATE TABLE x (x INT) WITH (PARTITIONED_BY=RANGE(x));
/* cannot use pseudotypes */ CREATE TABLE x (x INT, x INT) WITH (PARTITIONED_BY=RANGE(((x, x))));
CREATE TABLE x (x INT, x INT) WITH (PARTITIONED_BY=RANGE(x, ('unknown')));
CREATE TABLE x (x INT) WITH (PARTITIONED_BY=RANGE(IMMUT_FUNC(x)));
DROP FUNCTION x (INT);
/* prevent using columns of unsupported types in key (type must have a btree operator class) */ CREATE TABLE x (x point) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x (x point) WITH (PARTITIONED_BY=RANGE(x));
/* check relkind */ SELECT x FROM x WHERE x = 'partitioned';
/* prevent a function referenced in partition key from being dropped */ DROP FUNCTION x (INT);
/* partitioned table cannot participate in regular inheritance */ CREATE TABLE x (x INT, x TEXT) WITH (PARTITIONED_BY=RANGE((x + 1), SUBSTRING(x, 1, 5)));
CREATE TABLE x INHERITS (x);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (-1, 'aaaaa') TO (100, 'ccccc');
/* check reference to partitioned table's rowtype in partition descriptor */ CREATE TABLE x (x INT, x INT) WITH (PARTITIONED_BY=LIST((CAST(ROW(x, x) AS partitioned))));
CREATE TABLE x PARTITION OF x FOR VALUES IN (CAST('(1,2)' AS partitioned));
CREATE TABLE x PARTITION OF x FOR VALUES IN (CAST('(2,4)' AS partitioned));
EXPLAIN (costs off) select * from partitioned where row(a,b)::partitioned = '(1,2)'::partitioned;
DROP TABLE x;
/* whole-row Var in partition key works too */ CREATE TABLE x (x INT, x INT) WITH (PARTITIONED_BY=LIST((x)));
CREATE TABLE x PARTITION OF x FOR VALUES IN ('(1,2)');
CREATE TABLE x PARTITION OF x FOR VALUES IN ('(2,4)');
EXPLAIN (costs off) select * from partitioned where partitioned = '(1,2)'::partitioned;
/* check that dependencies of partition columns are handled correctly */ create domain intdom1 as int;
CREATE TABLE x (x intdom1, x TEXT) WITH (PARTITIONED_BY=RANGE(x));
ALTER TABLE x DROP COLUMN x;
/* fail */ drop domain intdom1;
/* fail, requires cascade */ drop domain intdom1 cascade;
x AS x;
/* gone */ /* likewise for columns used in partition expressions */ create domain intdom1 as int;
CREATE TABLE x (x intdom1, x TEXT) WITH (PARTITIONED_BY=RANGE(PLUSONE(x)));
ALTER TABLE x DROP COLUMN x;
/* fail */ drop domain intdom1;
/* fail, requires cascade */ drop domain intdom1 cascade;
x AS x;
/* gone */ /* Partitions */ /* check partition bound syntax */ CREATE TABLE x (x INT) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN ('1');
CREATE TABLE x PARTITION OF x FOR VALUES IN (2);
CREATE TABLE x PARTITION OF x FOR VALUES IN ((2 + 1));
CREATE TABLE x PARTITION OF x FOR VALUES IN (NULL);
CREATE TABLE x PARTITION OF x FOR VALUES IN (x.x);
CREATE TABLE x PARTITION OF x FOR VALUES IN (x);
CREATE TABLE x PARTITION OF x FOR VALUES IN (SUM(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN (SUM(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN (SUM(1));
CREATE TABLE x PARTITION OF x FOR VALUES IN ((SELECT 1));
CREATE TABLE x PARTITION OF x FOR VALUES IN (UNNEST(GENERATE_SERIES(4, 6)));
CREATE TABLE x PARTITION OF x FOR VALUES IN ((1 + 1) COLLATE "x");
/* syntax does not allow empty list of values for list partitions */ CREATE TABLE x PARTITION OF x FOR VALUES IN ();
/* trying to specify range for list partitioned table */ CREATE TABLE x PARTITION OF x FOR VALUES FROM (1) TO (2);
/* trying to specify modulus and remainder for list partitioned table */ CREATE TABLE x PARTITION OF x FOR VALUES WITH (MODULUS 10, REMAINDER 1);
/* check default partition cannot be created more than once */ CREATE TABLE x PARTITION OF x DEFAULT;
CREATE TABLE x PARTITION OF x DEFAULT;
/* specified literal can't be cast to the partition column data type */ CREATE TABLE x (x BOOLEAN) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN (1);
DROP TABLE x;
/* specified literal can be cast, and the cast might not be immutable */ CREATE TABLE x (x MONEY) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN (10);
CREATE TABLE x PARTITION OF x FOR VALUES IN ('11');
CREATE TABLE x PARTITION OF x FOR VALUES IN (CAST(TIME_TO_STR(12, '99') AS INT));
DROP TABLE x;
/* cast is immutable */ CREATE TABLE x (x BIGINT) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN (10);
/* fails due to overlap: */ CREATE TABLE x PARTITION OF x FOR VALUES IN ('10');
DROP TABLE x;
CREATE TABLE x (x DATE) WITH (PARTITIONED_BY=RANGE(x));
/* forbidden expressions for partition bounds with range partitioned table */ CREATE TABLE x PARTITION OF x FOR VALUES FROM (x) TO ('2019-01-01');
CREATE TABLE x PARTITION OF x FOR VALUES FROM (x.x) TO ('2019-01-01');
CREATE TABLE x PARTITION OF x FOR VALUES FROM (x) TO ('2019-01-01');
CREATE TABLE x PARTITION OF x FOR VALUES FROM (MAX(x)) TO ('2019-01-01');
CREATE TABLE x PARTITION OF x FOR VALUES FROM (MAX(x)) TO ('2019-01-01');
CREATE TABLE x PARTITION OF x FOR VALUES FROM (MAX(CAST('2019-02-01' AS DATE))) TO ('2019-01-01');
CREATE TABLE x PARTITION OF x FOR VALUES FROM ((SELECT 1)) TO ('2019-01-01');
CREATE TABLE x PARTITION OF x FOR VALUES FROM (UNNEST(GENERATE_SERIES(1, 3))) TO ('2019-01-01');
/* trying to specify list for range partitioned table */ CREATE TABLE x PARTITION OF x FOR VALUES IN ('a');
/* trying to specify modulus and remainder for range partitioned table */ CREATE TABLE x PARTITION OF x FOR VALUES WITH (MODULUS 10, REMAINDER 1);
/* each of start and end bounds must have same number of values as the */ /* length of the partition key */ CREATE TABLE x PARTITION OF x FOR VALUES FROM ('a', 1) TO ('z');
CREATE TABLE x PARTITION OF x FOR VALUES FROM ('a') TO ('z', 1);
/* cannot specify null values in range bounds */ CREATE TABLE x PARTITION OF x FOR VALUES FROM (NULL) TO (MAXVALUE);
/* trying to specify modulus and remainder for range partitioned table */ CREATE TABLE x PARTITION OF x FOR VALUES WITH (MODULUS 10, REMAINDER 1);
/* check partition bound syntax for the hash partition */ CREATE TABLE x (x INT) WITH (PARTITIONED_BY=HASH(x));
CREATE TABLE x PARTITION OF x FOR VALUES WITH (MODULUS 10, REMAINDER 0);
CREATE TABLE x PARTITION OF x FOR VALUES WITH (MODULUS 50, REMAINDER 1);
CREATE TABLE x PARTITION OF x FOR VALUES WITH (MODULUS 200, REMAINDER 2);
CREATE TABLE x PARTITION OF x FOR VALUES WITH (MODULUS 10, REMAINDER 3);
/* modulus 25 is factor of modulus of 50 but 10 is not a factor of 25. */ CREATE TABLE x PARTITION OF x FOR VALUES WITH (MODULUS 25, REMAINDER 3);
/* previous modulus 50 is factor of 150 but this modulus is not a factor of next modulus 200. */ CREATE TABLE x PARTITION OF x FOR VALUES WITH (MODULUS 150, REMAINDER 3);
/* overlapping remainders */ CREATE TABLE x PARTITION OF x FOR VALUES WITH (MODULUS 100, REMAINDER 3);
/* trying to specify range for the hash partitioned table */ CREATE TABLE x PARTITION OF x FOR VALUES FROM ('a', 1) TO ('z');
/* trying to specify list value for the hash partitioned table */ CREATE TABLE x PARTITION OF x FOR VALUES IN (1000);
/* trying to create default partition for the hash partitioned table */ CREATE TABLE x PARTITION OF x DEFAULT;
/* check if compatible with the specified parent */ /* cannot create as partition of a non-partitioned table */ CREATE TABLE x (x INT);
CREATE TABLE x PARTITION OF x FOR VALUES IN ('a');
CREATE TABLE x PARTITION OF x FOR VALUES WITH (MODULUS 2, REMAINDER 1);
DROP TABLE x;
/* cannot create a permanent rel as partition of a temp rel */ CREATE TEMPORARY TABLE x (x INT) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN ('a');
DROP TABLE x;
/* check for partition bound overlap and other invalid specifications */ CREATE TABLE x (x VARCHAR) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN (NULL, 'z');
CREATE TABLE x PARTITION OF x FOR VALUES IN ('a', 'b');
CREATE TABLE x PARTITION OF x DEFAULT;
CREATE TABLE x PARTITION OF x FOR VALUES IN (NULL);
CREATE TABLE x PARTITION OF x FOR VALUES IN ('b', 'c');
/* check default partition overlap */ INSERT INTO x VALUES ('X');
CREATE TABLE x PARTITION OF x FOR VALUES IN ('W', 'X', 'Y');
CREATE TABLE x (x INT) WITH (PARTITIONED_BY=RANGE(x));
/* trying to create range partition with empty range */ CREATE TABLE x PARTITION OF x FOR VALUES FROM (1) TO (0);
/* note that the range '[1, 1)' has no elements */ CREATE TABLE x PARTITION OF x FOR VALUES FROM (1) TO (1);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (MINVALUE) TO (1);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (MINVALUE) TO (2);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (1) TO (10);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (-1) TO (1);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (9) TO (MAXVALUE);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (20) TO (30);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (30) TO (40);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (10) TO (30);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (10) TO (50);
/* Create a default partition for range partitioned table */ CREATE TABLE x PARTITION OF x DEFAULT;
/* More than one default partition is not allowed, so this should give error */ CREATE TABLE x PARTITION OF x DEFAULT;
/* Check if the range for default partitions overlap */ INSERT INTO x VALUES (85);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (80) TO (90);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (90) TO (100);
/* now check for multi-column range partition key */ CREATE TABLE x (x INT, x INT) WITH (PARTITIONED_BY=RANGE(x, (x + 1)));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (0, MINVALUE) TO (0, MAXVALUE);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (0, MINVALUE) TO (0, 1);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (1, MINVALUE) TO (1, 1);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (1, 1) TO (1, 10);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (1, 10) TO (1, MAXVALUE);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (1, 10) TO (1, 20);
CREATE TABLE x PARTITION OF x DEFAULT;
/* cannot create a partition that says column b is allowed to range */ /* from -infinity to +infinity, while there exist partitions that have */ /* more specific ranges */ CREATE TABLE x PARTITION OF x FOR VALUES FROM (1, MINVALUE) TO (1, MAXVALUE);
/* check for partition bound overlap and other invalid specifications for the hash partition */ CREATE TABLE x (x VARCHAR) WITH (PARTITIONED_BY=HASH(x));
CREATE TABLE x PARTITION OF x FOR VALUES WITH (MODULUS 4, REMAINDER 2);
CREATE TABLE x PARTITION OF x FOR VALUES WITH (MODULUS 8, REMAINDER 0);
CREATE TABLE x PARTITION OF x FOR VALUES WITH (MODULUS 8, REMAINDER 4);
CREATE TABLE x PARTITION OF x FOR VALUES WITH (MODULUS 8, REMAINDER 5);
/* overlap with part_4 */ CREATE TABLE x PARTITION OF x FOR VALUES WITH (MODULUS 2, REMAINDER 1);
/* modulus must be greater than zero */ CREATE TABLE x PARTITION OF x FOR VALUES WITH (MODULUS 0, REMAINDER 1);
/* remainder must be greater than or equal to zero and less than modulus */ CREATE TABLE x PARTITION OF x FOR VALUES WITH (MODULUS 8, REMAINDER 8);
/* check schema propagation from parent */ CREATE TABLE x (x TEXT, x INT NOT NULL DEFAULT 0, CONSTRAINT x CHECK (LENGTH(x) > 0)) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN ('a');
/* only inherited attributes (never local ones) */ SELECT x, x, x FROM x WHERE x = CAST('part_a' AS REGCLASS) AND x > 0 ORDER BY x NULLS LAST;
/* able to specify column default, column constraint, and table constraint */ /* first check the "column specified more than once" error */ CREATE TABLE x PARTITION OF x (x NOT NULL, x DEFAULT 1, x CHECK (x >= 0), CONSTRAINT x CHECK (LENGTH(x) > 0)) FOR VALUES IN ('b');
CREATE TABLE x PARTITION OF x (x NOT NULL DEFAULT 1, CONSTRAINT x CHECK (LENGTH(x) > 0), CONSTRAINT x CHECK (x >= 0)) FOR VALUES IN ('b');
/* conislocal should be false for any merged constraints, true otherwise */ SELECT x, x, x FROM x WHERE x = CAST('part_b' AS REGCLASS) ORDER BY x DESC NULLS FIRST, x NULLS LAST;
ALTER TABLE x ADD CONSTRAINT x CHECK (x >= 0) /* Once check_b is added to the parent, it should be made non-local for part_b */;
SELECT x, x, x FROM x WHERE x = CAST('part_b' AS REGCLASS) ORDER BY x DESC NULLS FIRST, x NULLS LAST;
ALTER TABLE x DROP CONSTRAINT x /* Neither check_a nor check_b are droppable from part_b */;
ALTER TABLE x DROP CONSTRAINT x;
ALTER TABLE x DROP CONSTRAINT x, DROP CONSTRAINT x /* And dropping it from parted should leave no trace of them on part_b, unlike */ /* traditional inheritance where they will be left behind, because they would */ /* be local constraints. */;
SELECT x, x, x FROM x WHERE x = CAST('part_b' AS REGCLASS) ORDER BY x DESC NULLS FIRST, x NULLS LAST;
/* specify PARTITION BY for a partition */ CREATE TABLE x PARTITION OF x FOR VALUES IN ('c') WITH (PARTITIONED_BY=RANGE(x));
/* create a level-2 partition */ CREATE TABLE x PARTITION OF x FOR VALUES FROM (1) TO (10);
/* check that NOT NULL and default value are inherited correctly */ CREATE TABLE x (x INT DEFAULT 1, x INT NOT NULL DEFAULT 0) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x (x NOT NULL, x DEFAULT 1) FOR VALUES IN (1);
INSERT INTO x (x) VALUES (NULL);
/* check that collations are assigned in partition bound expressions */ CREATE TABLE x (x BOOLEAN, x TEXT) WITH (PARTITIONED_BY=LIST(x));
DROP TABLE x;
/* check for a conflicting COLLATE clause */ CREATE TABLE x (x TEXT COLLATE "x", x TEXT COLLATE "x") WITH (PARTITIONED_BY=RANGE(x));
/* on the partition key */ CREATE TABLE x PARTITION OF x (x COLLATE "x") FOR VALUES FROM ('a') TO ('m');
/* on another column */ CREATE TABLE x PARTITION OF x (x COLLATE "x") FOR VALUES FROM ('m') TO ('z');
DROP TABLE x;
/* check that non-matching collations for partition bound */ /* expressions are coerced to the right collation */ CREATE TABLE x (x TEXT) WITH (PARTITIONED_BY=RANGE(x COLLATE "x"));
/* ok, collation is implicitly coerced */ CREATE TABLE x PARTITION OF x FOR VALUES FROM ('a' COLLATE "x") TO ('g');
/* ok */ CREATE TABLE x PARTITION OF x FOR VALUES FROM ('g') TO ('m');
/* ok, collation is implicitly coerced */ CREATE TABLE x PARTITION OF x FOR VALUES FROM (CAST('m' AS NAME) COLLATE "x") TO ('s');
DROP TABLE x;
CREATE TABLE x PARTITION OF x FOR VALUES FROM (MINVALUE, MINVALUE, MINVALUE) TO (MAXVALUE, MAXVALUE, MAXVALUE);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (MINVALUE, MINVALUE, MINVALUE) TO (1, MAXVALUE, MAXVALUE);
CREATE OPERATOR CLASS test_int4_ops FOR TYPE int4 USING btree AS   OPERATOR 1 < (int4,int4), OPERATOR 2 <= (int4,int4),   OPERATOR 3 = (int4,int4), OPERATOR 4 >= (int4,int4),   OPERATOR 5 > (int4,int4), FUNCTION 1 my_int4_sort(int4,int4);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (0) TO (1000);
INSERT INTO x VALUES (100);
INSERT INTO x VALUES (200);
DROP OPERATOR CLASS test_int4_ops USING btree;
DROP FUNCTION x (INT, INT);
/* comments on partitioned tables columns */ CREATE TABLE x (x INT, x TEXT) WITH (PARTITIONED_BY=LIST(x));
COMMENT ON TABLE x IS 'Am partitioned table';
COMMENT ON COLUMN x.x IS 'Partition key';
SELECT OBJ_DESCRIPTION(CAST('parted_col_comment' AS REGCLASS));
/* specifying storage parameters for partitioned tables is not supported */ CREATE TABLE x (x INT, x TEXT) WITH (PARTITIONED_BY=LIST(x), fillfactor=100);
/* list partitioning on array type column */ CREATE TABLE x (x ARRAY<INT>) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN ('{1}', '{2}');
/* partition on boolean column */ CREATE TABLE x (x BOOLEAN) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN (TRUE);
CREATE TABLE x PARTITION OF x FOR VALUES IN (FALSE);
/* partitions mixing temporary and permanent relations */ CREATE TABLE x (x INT) WITH (PARTITIONED_BY=LIST(x));
CREATE TEMPORARY TABLE x (x INT) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x DEFAULT;
/* error */ CREATE TEMPORARY TABLE x PARTITION OF x DEFAULT;
/* error */ CREATE TEMPORARY TABLE x PARTITION OF x DEFAULT;
/* ok */ DROP TABLE x CASCADE;
DROP TABLE x CASCADE;
/* check that adding partitions to a table while it is being used is prevented */ CREATE TABLE x (x INT) WITH (PARTITIONED_BY=LIST(x));
x AS x;
create trigger trig_part_create before insert on tab_part_create   for each statement execute procedure func_part_create();
INSERT INTO x VALUES (1);
DROP TABLE x;
DROP FUNCTION x;
/* test using a volatile expression as partition bound */ CREATE TABLE x (x TIMESTAMP) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (MINVALUE) TO (CURRENT_TIMESTAMP());
CREATE TABLE x PARTITION OF x FOR VALUES FROM (CURRENT_TIMESTAMP()) TO (MAXVALUE);
/* this should go into the partition volatile_partbound_test2 */ INSERT INTO x VALUES (CURRENT_TIMESTAMP());
SELECT CAST(x AS REGCLASS) FROM x;
DROP TABLE x;
/* test the case where a check constraint on default partition allows */ /* to avoid scanning it when adding a new partition */ CREATE TABLE x (x INT, x INT) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x (x INT, x INT, x INT);
ALTER TABLE x drop c;
alter table defcheck attach partition defcheck_def default;
ALTER TABLE x CHECK(x <= 0 AND NOT x IS NULL);
CREATE TABLE x PARTITION OF x FOR VALUES IN (1, NULL);
/* test that complex default partition constraints are enforced correctly */ INSERT INTO x VALUES (0, 0);
CREATE TABLE x PARTITION OF x FOR VALUES IN (0);
DROP TABLE x;
/* tests of column drop with partition tables and indexes using */ /* predicates and expressions. */ CREATE TABLE x (x INT, x INT, x INT, x INT, x INT, x INT) WITH (PARTITIONED_BY=RANGE(x));
ALTER TABLE x DROP COLUMN x;
ALTER TABLE x DROP COLUMN x;
ALTER TABLE x DROP COLUMN x;
CREATE INDEX x ON x(x NULLS LAST) WHERE x = 1;
CREATE INDEX x ON x((x = 1) NULLS LAST);
CREATE INDEX x ON x(x NULLS LAST) WHERE x = 2;
CREATE INDEX x ON x((x = 2) NULLS LAST);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (1) TO (10);
/* Test inheritance of structure (LIKE) */ CREATE TABLE x (x TEXT DEFAULT 'text');
/*  * Test double inheritance  *  * Ensure that defaults are NOT included unless  * INCLUDING DEFAULTS is specified  */ CREATE TABLE x (x TEXT);
CREATE TABLE x (x TEXT) INHERITS (x);
CREATE TABLE x (LIKE x);
CREATE TABLE x (x TEXT, LIKE x) INHERITS (x);
INSERT INTO x VALUES ('ee-col1', 'ee-col2', DEFAULT, 'ee-col4');
SELECT * FROM x;
/* Columns aa, bb, xx value NULL, ee */ SELECT * FROM x;
/* Empty set since LIKE inherits structure only */ SELECT * FROM x;
/* Has ee entry */ SELECT * FROM x;
/* Has ee entry */ CREATE TABLE x (LIKE x, LIKE x);
/* Throw error */ CREATE TABLE x (LIKE x INCLUDING DEFAULTS INCLUDING CONSTRAINTS);
SELECT * FROM x;
ALTER TABLE x ADD CONSTRAINT x CHECK (x = 'text') /* Single entry with value 'text' */;
ALTER TABLE x ADD PRIMARY KEY (x NULLS LAST);
CREATE TABLE x (LIKE x);
/* Doesn't copy constraint */ INSERT INTO x VALUES ('foo');
DROP TABLE x;
CREATE TABLE x (x TEXT, LIKE x INCLUDING CONSTRAINTS, x TEXT);
/* Copies constraints */ INSERT INTO x VALUES ('x', 'text', 'y');
/* Succeeds */ INSERT INTO x VALUES ('x', 'text', 'y');
/* Succeeds -- Unique constraints not copied */ INSERT INTO x VALUES ('x', 'foo', 'y');
/* fails due to constraint */ SELECT * FROM x;
/* Two records with three columns in order x=x, xx=text, y=y */ DROP TABLE x;
CREATE TABLE x (x BIGINT GENERATED ALWAYS AS IDENTITY, x TEXT);
SELECT * FROM x;
CREATE TABLE x (LIKE x);
SELECT * FROM x;
/* identity was not copied */ CREATE TABLE x (LIKE x INCLUDING IDENTITY);
SELECT * FROM x;
SELECT * FROM x;
CREATE TABLE x (LIKE x);
SELECT * FROM x;
CREATE TABLE x (LIKE x INCLUDING GENERATED);
SELECT * FROM x;
/* also test generated column with a "forward" reference (bug #16342) */ CREATE TABLE x (x INT DEFAULT 42, x INT AS x * 2, x INT CHECK (x > 0));
CREATE TABLE x (LIKE x INCLUDING DEFAULTS);
CREATE TABLE x (LIKE x INCLUDING GENERATED);
CREATE TABLE x (LIKE x INCLUDING DEFAULTS INCLUDING GENERATED);
SELECT x, x, x FROM x;
SELECT x, x, x FROM x;
SELECT x, x, x FROM x;
SELECT x, x, x FROM x;
/* Test renumbering of Vars when combining LIKE with inheritance */ CREATE TABLE x (x point, x point, x point);
CREATE TABLE x (x INT CHECK (x > 0), x INT AS x * 2);
CREATE TABLE x (LIKE x INCLUDING ALL) INHERITS (x, x);
CREATE STATISTICS ext_stat ON (a || b) FROM test_like_6;
ALTER TABLE x DROP COLUMN x;
CREATE TABLE x (LIKE x INCLUDING ALL);
CREATE TABLE x (x TEXT, LIKE x INCLUDING INDEXES, x TEXT);
/* copies indexes */ INSERT INTO x VALUES (5, 10);
INSERT INTO x VALUES (20, 10);
/* should fail */ DROP TABLE x;
/* Multiple primary keys creation should fail */ CREATE TABLE x (x TEXT, LIKE x INCLUDING INDEXES, PRIMARY KEY (x NULLS LAST));
/* fails */ CREATE TABLE x (x TEXT DEFAULT 'text', x INT UNIQUE);
CREATE UNIQUE INDEX x ON x(x NULLS LAST) WHERE x <> 'test';
/* Ok to create multiple unique indexes */ CREATE TABLE x (x TEXT UNIQUE, LIKE x INCLUDING INDEXES);
INSERT INTO x (x, x, x) VALUES ('test', 5, 10);
INSERT INTO x (x, x, x) VALUES ('test', 10, 15);
INSERT INTO x (x, x, x) VALUES ('foo', 10, 15);
/* should fail */ DROP TABLE x;
DROP TABLE x;
/* Use primary key imported by LIKE for self-referential FK constraint */ CREATE TABLE x (x TEXT REFERENCES x, LIKE x INCLUDING INDEXES);
CREATE INDEX x ON x(x NULLS LAST);
CREATE INDEX x ON x((x || x) NULLS LAST);
CREATE STATISTICS ctlt1_a_b_stat ON a,b FROM ctlt1;
CREATE STATISTICS ctlt1_expr_stat ON (a || b) FROM ctlt1;
COMMENT ON STATISTICS ctlt1_a_b_stat IS 'ab stats';
COMMENT ON STATISTICS ctlt1_expr_stat IS 'ab expr stats';
COMMENT ON COLUMN x.x IS 'A';
COMMENT ON COLUMN x.x IS 'B';
COMMENT ON INDEX x IS 'index pkey';
COMMENT ON INDEX x IS 'index b_key';
ALTER TABLE x ALTER COLUMN x DROP DEFAULT, SET STORAGE MAIN;
CREATE TABLE x (x TEXT);
ALTER TABLE x ALTER COLUMN x DROP DEFAULT, SET STORAGE EXTERNAL;
COMMENT ON COLUMN x.x IS 'C';
CREATE TABLE x (x TEXT CHECK (LENGTH(x) < 5), x TEXT CHECK (LENGTH(x) < 7));
ALTER TABLE x ALTER COLUMN x DROP DEFAULT, SET STORAGE EXTERNAL;
ALTER TABLE x ALTER COLUMN x DROP DEFAULT, SET STORAGE MAIN;
CREATE INDEX x ON x((x || x) NULLS LAST);
COMMENT ON COLUMN x.x IS 'A3';
COMMENT ON COLUMN x.x IS 'C';
CREATE TABLE x (x TEXT, x TEXT);
ALTER TABLE x ALTER COLUMN x DROP DEFAULT, SET STORAGE EXTERNAL;
CREATE TABLE x (LIKE x INCLUDING STORAGE, LIKE x INCLUDING STORAGE);
CREATE TABLE x INHERITS (x, x);
CREATE TABLE x (LIKE x INCLUDING ALL);
SELECT x.x, x, x FROM x, x AS x WHERE x = CAST('pg_statistic_ext' AS REGCLASS) AND x = x.x AND x.x = CAST('ctlt_all' AS REGCLASS) ORDER BY x.x NULLS LAST, x NULLS LAST;
CREATE TABLE x INHERITS (x, x);
CREATE TABLE x (LIKE x INCLUDING STORAGE) INHERITS (x);
/* Check that LIKE isn't confused by a system catalog of the same name */ CREATE TABLE x (LIKE x INCLUDING ALL);
/* Check that LIKE isn't confused when new table masks the old, either */ BEGIN;
CREATE SCHEMA x.x;
SET LOCAL search_path = ctl_schema, public;
CREATE TABLE x (LIKE x INCLUDING ALL);
CREATE TABLE x (LIKE x INCLUDING CONSTRAINTS);
/* LIKE with other relation kinds */ CREATE TABLE x (x INT, x TEXT);
CREATE SEQUENCE x;
CREATE TABLE x (LIKE x);
/* fail */ CREATE VIEW x AS SELECT * FROM x;
CREATE TABLE x (LIKE x);
CREATE TABLE x (LIKE x INCLUDING ALL);
CREATE TYPE ctlty1 AS (a int, b text);
CREATE TABLE x (LIKE x);
DROP SEQUENCE x;
DROP TYPE ctlty1;
DROP VIEW x;
/* CREATE FOREIGN TABLE LIKE */ CREATE FOREIGN DATA WRAPPER ctl_dummy;
CREATE SERVER ctl_s0 FOREIGN DATA WRAPPER ctl_dummy;
CREATE INDEX x ON x(x NULLS LAST);
COMMENT ON COLUMN x.x IS 'Column b';
CREATE STATISTICS ctl_table_stat ON a,b FROM ctl_table;
ALTER TABLE x ADD CONSTRAINT x CHECK (x = 'text');
ALTER TABLE x ALTER COLUMN x DROP DEFAULT, SET STORAGE MAIN;
/* Test INCLUDING ALL */ /* INDEXES, IDENTITY, COMPRESSION, STORAGE are not copied. */ CREATE FOREIGN TABLE ctl_foreign_table2(LIKE ctl_table INCLUDING ALL) SERVER ctl_s0;
DROP TABLE x;
DROP FOREIGN TABLE ctl_foreign_table1;
DROP FOREIGN TABLE ctl_foreign_table2;
DROP FOREIGN DATA WRAPPER ctl_dummy CASCADE;
CREATE FUNCTION widget_out(widget)    RETURNS cstring    AS :'regresslib'    LANGUAGE C STRICT IMMUTABLE;
CREATE FUNCTION int44in(cstring)    RETURNS city_budget    AS :'regresslib'    LANGUAGE C STRICT IMMUTABLE;
CREATE FUNCTION int44out(city_budget)    RETURNS cstring    AS :'regresslib'    LANGUAGE C STRICT IMMUTABLE;
CREATE TYPE widget (    internallength = 24,    input = widget_in,    output = widget_out,    typmod_in = numerictypmodin,    typmod_out = numerictypmodout,    alignment = double );
CREATE TYPE city_budget (    internallength = 16,    input = int44in,    output = int44out,    element = int4,    category = 'x',   -- just to verify the system will take it    preferred = true  -- ditto );
/* Test creation and destruction of shell types */ CREATE TYPE shell;
CREATE TYPE shell;
/* fail, type already present */ DROP TYPE shell;
DROP TYPE shell;
/* fail, type not exist */ /* also, let's leave one around for purposes of pg_dump testing */ CREATE TYPE myshell;
/* Test type-related default values (broken in releases before PG 7.2) */ /* This part of the test also exercises the "new style" approach of making */ /* a shell type and then filling it in. */ CREATE TYPE int42;
CREATE TYPE text_w_default;
/* Make dummy I/O routines using the existing internal support for int4, text */ CREATE FUNCTION x(x) RETURNS int42 LANGUAGE internal STRICT IMMUTABLE AS 'int4in';
CREATE FUNCTION x(x) RETURNS CSTRING LANGUAGE internal STRICT IMMUTABLE AS 'int4out';
CREATE FUNCTION x(x) RETURNS text_w_default LANGUAGE internal STRICT IMMUTABLE AS 'textin';
CREATE FUNCTION x(x) RETURNS CSTRING LANGUAGE internal STRICT IMMUTABLE AS 'textout';
CREATE TYPE int42 (    internallength = 4,    input = int42_in,    output = int42_out,    alignment = int4,    default = 42,    passedbyvalue );
CREATE TYPE text_w_default (    internallength = variable,    input = text_w_default_in,    output = text_w_default_out,    alignment = int4,    default = 'zippo' );
CREATE TABLE x (x text_w_default, x int42);
SELECT * FROM x;
/* We need a shell type to test some CREATE TYPE failure cases with */ CREATE TYPE bogus_type;
/* invalid: non-lowercase quoted identifiers */ CREATE TYPE bogus_type ( 	"Internallength" = 4, 	"Input" = int42_in, 	"Output" = int42_out, 	"Alignment" = int4, 	"Default" = 42, 	"Passedbyvalue" );
/* invalid: input/output function incompatibility */ CREATE TYPE bogus_type (INPUT = array_in,     OUTPUT = array_out,     ELEMENT = int,     INTERNALLENGTH = 32);
DROP TYPE bogus_type;
/* It no longer is possible to issue CREATE TYPE without making a shell first */ CREATE TYPE bogus_type (INPUT = array_in,     OUTPUT = array_out,     ELEMENT = int,     INTERNALLENGTH = 32);
/* Test stand-alone composite type */ CREATE TYPE default_test_row AS (f1 text_w_default, f2 int42);
SELECT * FROM x;
/* Test comments */ COMMENT ON TYPE bad IS 'bad comment';
COMMENT ON TYPE default_test_row IS 'good comment';
COMMENT ON TYPE default_test_row IS NULL;
COMMENT ON COLUMN x.x IS 'bad comment';
COMMENT ON COLUMN x.x IS 'good comment';
/* Check shell type create for existing types */ CREATE TYPE text_w_default;
/* should fail */ DROP TYPE default_test_row CASCADE;
DROP TABLE x;
/* Check dependencies are established when creating a new type */ CREATE TYPE base_type;
CREATE FUNCTION x(x) RETURNS base_type LANGUAGE internal IMMUTABLE STRICT AS 'boolin';
CREATE FUNCTION x(x) RETURNS CSTRING LANGUAGE internal IMMUTABLE STRICT AS 'boolout';
CREATE TYPE base_type(INPUT = base_fn_in, OUTPUT = base_fn_out);
DROP FUNCTION x (CSTRING);
/* error */ DROP FUNCTION x (base_type);
/* error */ DROP TYPE base_type;
/* error */ DROP TYPE base_type CASCADE;
/* Check usage of typmod with a user-defined type */ /* (we have borrowed numeric's typmod functions) */ CREATE TEMPORARY TABLE x (x widget(42, 13, 7));
/* should fail */ CREATE TEMPORARY TABLE x (x widget(42, 13));
SELECT FORMAT_TYPE(x, x) FROM x WHERE x = CAST('mytab' AS REGCLASS) AND x > 0;
/* might as well exercise the widget type while we're here */ INSERT INTO x VALUES ('(1,2,3)'), ('(-44,5.5,12)');
x AS x;
/* and test format_type() a bit more, too */ SELECT FORMAT_TYPE(CAST('varchar' AS REGTYPE), 42);
SELECT FORMAT_TYPE(CAST('bpchar' AS REGTYPE), NULL);
/* this behavior difference is intentional */ SELECT FORMAT_TYPE(CAST('bpchar' AS REGTYPE), -1);
/* Test non-error-throwing APIs using widget, which still throws errors */ SELECT PG_INPUT_IS_VALID('(1,2,3)', 'widget');
SELECT PG_INPUT_IS_VALID('(1,2)', 'widget');
/* hard error expected */ SELECT PG_INPUT_IS_VALID('{"(1,2,3)"}', 'widget[]');
SELECT PG_INPUT_IS_VALID('{"(1,2)"}', 'widget[]');
/* hard error expected */ SELECT PG_INPUT_IS_VALID('("(1,2,3)")', 'mytab');
SELECT PG_INPUT_IS_VALID('("(1,2)")', 'mytab');
/* hard error expected */ /* Test creation of an operator over a user-defined type */ CREATE FUNCTION pt_in_widget(point, widget)    RETURNS bool    AS :'regresslib'    LANGUAGE C STRICT;
CREATE OPERATOR <% (    leftarg = point,    rightarg = widget,    procedure = pt_in_widget,    commutator = >% ,    negator = >=% );
/* exercise city_budget type */ CREATE TABLE x (x NAME, x box, x city_budget);
INSERT INTO x VALUES ('Podunk', '(1,2),(3,4)', '100,127,1000'), ('Gotham', '(1000,34),(1100,334)', '123456,127,-1000,6789');
x AS x;
/* Test CREATE/ALTER TYPE using a type that's compatible with varchar, */ /* so we can re-use those support functions */ CREATE TYPE myvarchar;
CREATE FUNCTION myvarcharin(cstring, oid, integer) RETURNS myvarchar LANGUAGE internal IMMUTABLE PARALLEL SAFE STRICT AS 'varcharin';
CREATE FUNCTION myvarcharout(myvarchar) RETURNS cstring LANGUAGE internal IMMUTABLE PARALLEL SAFE STRICT AS 'varcharout';
CREATE FUNCTION myvarcharsend(myvarchar) RETURNS bytea LANGUAGE internal STABLE PARALLEL SAFE STRICT AS 'varcharsend';
CREATE FUNCTION myvarcharrecv(internal, oid, integer) RETURNS myvarchar LANGUAGE internal STABLE PARALLEL SAFE STRICT AS 'varcharrecv';
/* fail, it's still a shell: */ ALTER TYPE myvarchar SET (storage = extended);
CREATE TYPE myvarchar (     input = myvarcharin,     output = myvarcharout,     alignment = integer,     storage = main );
/* want to check updating of a domain over the target type, too */ CREATE DOMAIN myvarchardom AS myvarchar;
ALTER TYPE myvarchar SET (storage = plain);
/* not allowed */ ALTER TYPE myvarchar SET (storage = extended);
ALTER TYPE myvarchar SET (     send = myvarcharsend,     receive = myvarcharrecv,     typmod_in = varchartypmodin,     typmod_out = varchartypmodout,     -- these are bogus, but it's safe as long as we don't use the type:     analyze = ts_typanalyze,     subscript = raw_array_subscript_handler );
SELECT x, x, x, x, x, x, x, x, x FROM x WHERE x = 'myvarchar';
SELECT x, x, x, x, x, x, x, x, x FROM x WHERE x = '_myvarchar';
SELECT x, x, x, x, x, x, x, x, x FROM x WHERE x = 'myvarchardom';
SELECT x, x, x, x, x, x, x, x, x FROM x WHERE x = '_myvarchardom';
/* ensure dependencies are straight */ DROP FUNCTION x (myvarchar);
/* fail */ DROP TYPE myvarchar;
/* fail */ DROP TYPE myvarchar CASCADE;
CREATE TABLE x (x INT, x TEXT, x path);
ANALYZE x;
CREATE TABLE x AS SELECT * FROM ONLY x WHERE REGEXP_LIKE(x, '.*Ramp');
CREATE VIEW x AS SELECT x, x, x, 12 * x AS x FROM x;
COMMENT ON VIEW x IS 'no view' /* Test comments */;
COMMENT ON VIEW x IS 'is a view';
/* These views are left around mainly to exercise special cases in pg_dump. */ CREATE TABLE x (x INT PRIMARY KEY, x VARCHAR(20));
CREATE VIEW x AS SELECT * FROM x GROUP BY x;
ALTER TABLE x DROP CONSTRAINT x;
/* fails */ CREATE VIEW x AS SELECT FROM x GROUP BY x HAVING LENGTH(x) > 0;
/* CREATE OR REPLACE VIEW */ CREATE TABLE x (x INT, x INT, x DECIMAL(10, 1), x TEXT COLLATE "x");
COPY INTO x FROM x;
CREATE OR REPLACE VIEW x AS SELECT * FROM x WHERE x > 10;
SELECT * FROM x;
CREATE OR REPLACE VIEW x AS SELECT x, x, x, x FROM x WHERE x > 5 ORDER BY x DESC NULLS FIRST;
SELECT * FROM x;
/* should fail */ CREATE OR REPLACE VIEW x AS SELECT x FROM x WHERE x <> 20;
/* should fail */ CREATE OR REPLACE VIEW x AS SELECT 1, * FROM x;
/* should fail */ CREATE OR REPLACE VIEW x AS SELECT x, CAST(x AS DECIMAL), x, x FROM x;
/* should fail */ CREATE OR REPLACE VIEW x AS SELECT x, x, CAST(x AS DECIMAL(10, 2)), x FROM x;
/* should fail */ CREATE OR REPLACE VIEW x AS SELECT x, x, x, x COLLATE "x" FROM x;
/* should work */ CREATE OR REPLACE VIEW x AS SELECT x, x, x, x, 0 AS x FROM x;
DROP VIEW x;
DROP TABLE x;
/* tests for temporary views */ CREATE SCHEMA temp_view_test     CREATE TABLE base_table (a int, id int)     CREATE TABLE base_table2 (a int, id int);
SET search_path TO temp_view_test, public;
CREATE TEMPORARY TABLE x (x INT, x INT);
/* should be created in temp_view_test schema */ CREATE VIEW x AS SELECT * FROM x;
/* should be created in temp object schema */ CREATE VIEW x AS SELECT * FROM x;
/* should be created in temp object schema */ CREATE TEMPORARY VIEW x AS SELECT * FROM x;
/* should be created in temp_views schema */ CREATE VIEW x.x AS SELECT * FROM x;
/* should fail */ CREATE VIEW x.x AS SELECT * FROM x;
/* should fail */ CREATE SCHEMA test_view_schema     CREATE TEMP VIEW testview AS SELECT 1;
/* joins: if any of the join relations are temporary, the view */ /* should also be temporary */ /* should be non-temp */ CREATE VIEW x AS SELECT x.x AS x, x.x AS x FROM x AS x, x AS x WHERE x.x = x.x;
/* should be temp (one join rel is temp) */ CREATE VIEW x AS SELECT x.x AS x, x.x AS x FROM x AS x, x AS x WHERE x.x = x.x;
/* should be temp */ CREATE VIEW x AS SELECT x.x AS x, x.x AS x, x.x AS x FROM x AS x, x AS x, x AS x WHERE x.x = x.x AND x.x = x.x;
/* subqueries */ CREATE VIEW x AS SELECT * FROM x WHERE x IN (SELECT x FROM x);
CREATE VIEW x AS SELECT x.x, x.x FROM x AS x, (SELECT * FROM x) AS x;
CREATE VIEW x AS SELECT * FROM x WHERE EXISTS(SELECT 1 FROM x);
CREATE VIEW x AS SELECT * FROM x WHERE NOT EXISTS(SELECT 1 FROM x);
CREATE VIEW x AS SELECT * FROM x WHERE EXISTS(SELECT 1);
CREATE VIEW x AS SELECT * FROM x WHERE x IN (SELECT x FROM x);
CREATE VIEW x AS SELECT x.x, x.x FROM x AS x, (SELECT * FROM x) AS x;
CREATE VIEW x AS SELECT * FROM x WHERE EXISTS(SELECT 1 FROM x);
CREATE VIEW x AS SELECT * FROM x WHERE NOT EXISTS(SELECT 1 FROM x);
/* a view should also be temporary if it references a temporary view */ CREATE VIEW x AS SELECT * FROM x;
CREATE VIEW x AS SELECT x.x, x.x FROM x AS x, x AS x;
CREATE VIEW x AS SELECT TRUE FROM x;
/* a view should also be temporary if it references a temporary sequence */ CREATE SEQUENCE x;
CREATE TEMPORARY SEQUENCE x;
CREATE VIEW x AS SELECT x.x FROM x;
CREATE VIEW x AS SELECT x.x FROM x;
SELECT x FROM x WHERE x LIKE 'v_' AND x = (SELECT x FROM x WHERE x = 'temp_view_test') ORDER BY x NULLS LAST;
SELECT x FROM x WHERE x LIKE 'v%' AND x IN (SELECT x FROM x WHERE x LIKE 'pg_temp%') ORDER BY x NULLS LAST;
CREATE SCHEMA x.x;
SET search_path TO testviewschm2, public;
CREATE TABLE x (x INT, x TEXT);
CREATE TABLE x (x INT, x TEXT);
CREATE TEMPORARY TABLE x (x INT, x TEXT);
CREATE VIEW x AS SELECT * FROM x CROSS JOIN x;
CREATE VIEW x AS SELECT * FROM x CROSS JOIN x;
CREATE VIEW x AS SELECT * FROM x INNER JOIN x ON x.x = x.x;
CREATE VIEW x AS SELECT * FROM x INNER JOIN x ON x.x = x.x;
CREATE VIEW x AS SELECT * FROM x LEFT JOIN x ON x.x = x.x;
CREATE VIEW x AS SELECT * FROM x LEFT JOIN x ON x.x = x.x;
CREATE VIEW x AS SELECT * FROM x LEFT JOIN x ON x.x = x.x AND x.x = 'xxx';
CREATE VIEW x AS SELECT * FROM x LEFT JOIN x ON x.x = x.x AND x.x = 'xxx';
SELECT x FROM x WHERE x LIKE 'nontemp%' AND x = (SELECT x FROM x WHERE x = 'testviewschm2') ORDER BY x NULLS LAST;
SELECT x FROM x WHERE x LIKE 'temporal%' AND x IN (SELECT x FROM x WHERE x LIKE 'pg_temp%') ORDER BY x NULLS LAST;
CREATE TABLE x (x INT, x INT);
CREATE TABLE x (x INT, x INT);
CREATE TABLE x (x INT, x INT);
CREATE TABLE x (x INT, x INT);
CREATE TEMPORARY TABLE x (x INT, x INT);
/* Should be in testviewschm2 */ CREATE VIEW x AS SELECT * FROM x WHERE x.x BETWEEN (SELECT x FROM x WHERE x = 1) AND (SELECT x FROM x WHERE x = 2) AND EXISTS(SELECT x FROM x LEFT JOIN x ON x.x = x.x);
SELECT COUNT(*) FROM x WHERE x = 'pubview' AND x IN (SELECT x FROM x WHERE x = 'testviewschm2');
/* Should be in temp object schema */ CREATE VIEW x AS SELECT * FROM x WHERE x.x BETWEEN (SELECT x FROM x WHERE x = 1) AND (SELECT x FROM x WHERE x = 2) AND EXISTS(SELECT x FROM x LEFT JOIN x ON x.x = x.x) AND NOT EXISTS(SELECT x FROM x LEFT JOIN x ON x.x = x.x);
SELECT COUNT(*) FROM x WHERE x LIKE 'mytempview' AND x IN (SELECT x FROM x WHERE x LIKE 'pg_temp%');
/* CREATE VIEW and WITH(...) clause */ CREATE VIEW x AS SELECT * FROM x WHERE x = 0;
CREATE VIEW x WITH (security_barrier=TRUE) AS SELECT * FROM x WHERE x > 0;
CREATE VIEW x WITH (security_barrier=FALSE) AS SELECT * FROM x WHERE x < 0;
CREATE VIEW x WITH (security_barrier=100) AS SELECT * FROM x WHERE x > 100;
CREATE VIEW x WITH (security_invoker=TRUE) AS SELECT * FROM x WHERE x = 100;
CREATE VIEW x WITH (security_invoker=FALSE, security_barrier=TRUE) AS SELECT * FROM x WHERE x > 100;
CREATE VIEW x WITH (security_invoker=100) AS SELECT * FROM x WHERE x <> 100;
SELECT x, x, x FROM x WHERE x IN (CAST('mysecview1' AS REGCLASS), CAST('mysecview2' AS REGCLASS), CAST('mysecview3' AS REGCLASS), CAST('mysecview4' AS REGCLASS), CAST('mysecview7' AS REGCLASS), CAST('mysecview8' AS REGCLASS), CAST('mysecview9' AS REGCLASS)) ORDER BY x NULLS LAST;
CREATE OR REPLACE VIEW x AS SELECT * FROM x WHERE x = 256;
CREATE OR REPLACE VIEW x AS SELECT * FROM x WHERE x > 256;
CREATE OR REPLACE VIEW x WITH (security_barrier=TRUE) AS SELECT * FROM x WHERE x < 256;
CREATE OR REPLACE VIEW x WITH (security_barrier=FALSE) AS SELECT * FROM x WHERE x <> 256;
CREATE OR REPLACE VIEW x AS SELECT * FROM x WHERE x > 256;
CREATE OR REPLACE VIEW x WITH (security_invoker=TRUE) AS SELECT * FROM x WHERE x < 256;
CREATE OR REPLACE VIEW x WITH (security_invoker=FALSE, security_barrier=TRUE) AS SELECT * FROM x WHERE x <> 256;
SELECT x, x, x FROM x WHERE x IN (CAST('mysecview1' AS REGCLASS), CAST('mysecview2' AS REGCLASS), CAST('mysecview3' AS REGCLASS), CAST('mysecview4' AS REGCLASS), CAST('mysecview7' AS REGCLASS), CAST('mysecview8' AS REGCLASS), CAST('mysecview9' AS REGCLASS)) ORDER BY x NULLS LAST;
/* Check that unknown literals are converted to "text" in CREATE VIEW, */ /* so that we don't end up with unknown-type columns. */ CREATE VIEW x AS SELECT 42 AS x, 42.5 AS x, 'foo' AS x, CAST('foo' AS UNKNOWN) AS x, NULL AS x;
/* This test checks that proper typmods are assigned in a multi-row VALUES */ CREATE VIEW x AS SELECT * FROM (VALUES (CAST('abc' AS VARCHAR(3)), '0123456789', 42, CAST('abcd' AS VARCHAR(4))), ('0123456789', CAST('abc' AS VARCHAR(3)), 42.12, CAST('abc' AS VARCHAR(4)))) AS x;
SELECT CAST(x AS VARCHAR(3)) FROM x;
DROP VIEW x;
/* Test view decompilation in the face of relation renaming conflicts */ CREATE TABLE x (x INT, x INT, x TEXT);
CREATE TABLE x (x INT, x INT, x TEXT);
CREATE TABLE x.x (x INT, x INT, x TEXT);
CREATE VIEW x AS SELECT * FROM x WHERE EXISTS(SELECT 1 FROM x WHERE x.x = x.x);
CREATE VIEW x AS SELECT * FROM x AS x WHERE EXISTS(SELECT 1 FROM x WHERE x.x = x.x);
CREATE VIEW x AS SELECT * FROM x WHERE EXISTS(SELECT 1 FROM x AS x WHERE x.x = x.x);
CREATE VIEW x AS SELECT * FROM x.x WHERE EXISTS(SELECT 1 FROM x WHERE x.x.x = x.x);
ALTER TABLE tx1 SET SCHEMA temp_view_test;
ALTER TABLE temp_view_test.tmp1 SET SCHEMA testviewschm2;
ALTER TABLE x RENAME TO x;
CREATE VIEW x AS SELECT * FROM x JOIN x USING (x);
create view view_of_joins_2b as select * from tbl1 join tbl1a using (a) as x;
CREATE VIEW x AS SELECT * FROM (x JOIN x USING (x)) AS x;
SELECT PG_GET_VIEWDEF('view_of_joins_2a', TRUE);
SELECT PG_GET_VIEWDEF('view_of_joins_2b', TRUE);
SELECT PG_GET_VIEWDEF('view_of_joins_2c', TRUE);
SELECT PG_GET_VIEWDEF('view_of_joins_2d', TRUE);
/* Test view decompilation in the face of column addition/deletion/renaming */ CREATE TABLE x (x INT, x INT, x INT);
CREATE TABLE x (x BIGINT, x SMALLINT, x DECIMAL);
CREATE TABLE x (x INT, x INT, x INT);
CREATE VIEW x AS SELECT * FROM x NATURAL JOIN x;
CREATE VIEW x AS SELECT * FROM (x NATURAL JOIN x) AS x;
CREATE VIEW x AS SELECT * FROM x JOIN x USING (x, x) JOIN x USING (x);
CREATE VIEW x AS SELECT * FROM (x JOIN x USING (x, x) JOIN x USING (x)) AS x;
CREATE VIEW x AS SELECT * FROM x JOIN x USING (x, x) FULL JOIN x USING (x);
SELECT PG_GET_VIEWDEF('v1', TRUE);
SELECT PG_GET_VIEWDEF('v1a', TRUE);
SELECT PG_GET_VIEWDEF('v2', TRUE);
SELECT PG_GET_VIEWDEF('v2a', TRUE);
SELECT PG_GET_VIEWDEF('v3', TRUE);
ALTER TABLE x ADD COLUMN x INT;
ALTER TABLE x ADD COLUMN x INT;
SELECT PG_GET_VIEWDEF('v1', TRUE);
SELECT PG_GET_VIEWDEF('v1a', TRUE);
SELECT PG_GET_VIEWDEF('v2', TRUE);
SELECT PG_GET_VIEWDEF('v2a', TRUE);
SELECT PG_GET_VIEWDEF('v3', TRUE);
ALTER TABLE x RENAME TO x, TO x;
SELECT PG_GET_VIEWDEF('v1', TRUE);
SELECT PG_GET_VIEWDEF('v1a', TRUE);
SELECT PG_GET_VIEWDEF('v2', TRUE);
SELECT PG_GET_VIEWDEF('v2a', TRUE);
SELECT PG_GET_VIEWDEF('v3', TRUE);
ALTER TABLE x ADD COLUMN x INT;
ALTER TABLE x ADD COLUMN x INT;
SELECT PG_GET_VIEWDEF('v1', TRUE);
SELECT PG_GET_VIEWDEF('v1a', TRUE);
SELECT PG_GET_VIEWDEF('v2', TRUE);
SELECT PG_GET_VIEWDEF('v2a', TRUE);
SELECT PG_GET_VIEWDEF('v3', TRUE);
ALTER TABLE x DROP COLUMN x;
SELECT PG_GET_VIEWDEF('v1', TRUE);
SELECT PG_GET_VIEWDEF('v1a', TRUE);
SELECT PG_GET_VIEWDEF('v2', TRUE);
SELECT PG_GET_VIEWDEF('v2a', TRUE);
SELECT PG_GET_VIEWDEF('v3', TRUE);
CREATE TABLE x (x INT, x INT);
CREATE TABLE x (x INT, x INT);
CREATE VIEW x AS SELECT * FROM (x CROSS JOIN x) AS x;
SELECT PG_GET_VIEWDEF('vv1', TRUE);
ALTER TABLE x ADD COLUMN x INT;
SELECT PG_GET_VIEWDEF('vv1', TRUE);
ALTER TABLE x ADD COLUMN x INT;
SELECT PG_GET_VIEWDEF('vv1', TRUE);
ALTER TABLE x DROP COLUMN x;
SELECT PG_GET_VIEWDEF('vv1', TRUE);
CREATE VIEW x AS SELECT * FROM x;
ALTER VIEW x RENAME COLUMN x TO x;
SELECT PG_GET_VIEWDEF('v1', TRUE);
SELECT PG_GET_VIEWDEF('v4', TRUE);
/* Unnamed FULL JOIN USING is lots of fun too */ CREATE TABLE x (x INT, x INT, x INT);
ALTER TABLE x DROP COLUMN x;
CREATE TABLE x (x INT, x INT);
CREATE VIEW x AS SELECT * FROM (VALUES (1, 2, 3, 4, 5)) AS x UNION ALL SELECT * FROM x FULL JOIN x USING (x), x AS x;
SELECT PG_GET_VIEWDEF('vv2', TRUE);
CREATE VIEW x AS SELECT * FROM (VALUES (1, 2, 3, 4, 5, 6)) AS x UNION ALL SELECT * FROM x FULL JOIN x USING (x), x AS x FULL JOIN x AS x USING (x);
SELECT PG_GET_VIEWDEF('vv3', TRUE);
CREATE VIEW x AS SELECT * FROM (VALUES (1, 2, 3, 4, 5, 6, 7)) AS x UNION ALL SELECT * FROM x FULL JOIN x USING (x), x AS x FULL JOIN x AS x USING (x) FULL JOIN x AS x USING (x);
SELECT PG_GET_VIEWDEF('vv4', TRUE);
ALTER TABLE x ADD COLUMN x INT;
ALTER TABLE x ADD COLUMN x INT;
ALTER TABLE x DROP COLUMN x;
ALTER TABLE x ADD COLUMN x INT;
SELECT PG_GET_VIEWDEF('vv2', TRUE);
SELECT PG_GET_VIEWDEF('vv3', TRUE);
SELECT PG_GET_VIEWDEF('vv4', TRUE);
/* Implicit coercions in a JOIN USING create issues similar to FULL JOIN */ CREATE TABLE x (x DATE, x INT, x INT);
ALTER TABLE x DROP COLUMN x;
CREATE TABLE x (x TIMESTAMPTZ, x INT);
CREATE VIEW x AS SELECT * FROM (VALUES (CURRENT_TIMESTAMP(), 2, 3, CURRENT_TIMESTAMP(), 5)) AS x UNION ALL SELECT * FROM x LEFT JOIN x USING (x), x AS x;
SELECT PG_GET_VIEWDEF('vv2a', TRUE);
/* Also check dropping a column that existed when the view was made */ CREATE TABLE x (x INT, x INT, x INT);
CREATE TABLE x (x INT, x INT);
CREATE VIEW x AS SELECT x, x, x FROM x JOIN x USING (x);
SELECT PG_GET_VIEWDEF('vv5', TRUE);
ALTER TABLE x DROP COLUMN x;
SELECT PG_GET_VIEWDEF('vv5', TRUE);
/* Another corner case is that we might add a column to a table below a */ /* JOIN USING, and thereby make the USING column name ambiguous */ CREATE TABLE x (x INT, x INT);
CREATE TABLE x (x INT, x INT);
CREATE TABLE x (x INT, x INT);
CREATE VIEW x AS SELECT x, x, x, x FROM (x JOIN x USING (x)) JOIN x USING (x);
SELECT PG_GET_VIEWDEF('vv6', TRUE);
ALTER TABLE x ADD COLUMN x INT;
SELECT PG_GET_VIEWDEF('vv6', TRUE);
/* Check cases involving dropped/altered columns in a function's rowtype result */ CREATE TABLE x (x TEXT, x TEXT, x TEXT, x TEXT);
INSERT INTO x VALUES ('foo', 'bar', 'baz', '42');
ALTER TABLE x DROP COLUMN x;
BEGIN for rec1 in select * from tt14t     loop         return next rec1;
COMMIT;
CREATE VIEW x AS SELECT x.* FROM x AS x;
SELECT PG_GET_VIEWDEF('tt14v', TRUE);
SELECT * FROM x;
ALTER TABLE x DROP COLUMN x;
/* fail, view has explicit reference to f3 */ /* We used to have a bug that would allow the above to succeed, posing */ /* hazards for later execution of the view.  Check that the internal */ /* defenses for those hazards haven't bit-rotted, in case some other */ /* bug with similar symptoms emerges. */ BEGIN;
/* destroy the dependency entry that prevents the DROP: */ DELETE FROM x WHERE x = (SELECT x FROM x WHERE x = CAST('tt14v' AS REGCLASS) AND x = '_RETURN') AND x = 3 RETURNING PG_DESCRIBE_OBJECT(x, x, x) AS x, PG_DESCRIBE_OBJECT(x, x, x) AS x, x;
ALTER TABLE x DROP COLUMN x /* this will now succeed: */;
/* column f3 is still in the view, sort of ... */ SELECT PG_GET_VIEWDEF('tt14v', TRUE);
/* ... and you can even EXPLAIN it ... */ EXPLAIN (verbose, costs off) select * from tt14v;
/* but it will fail at execution */ SELECT x, x FROM x;
SELECT * FROM x;
ROLLBACK;
ALTER TABLE x ALTER COLUMN x SET DATA TYPE INT USING CAST(x AS INT) /* likewise, altering a referenced column's type is prohibited ... */;
/* fail */ /* ... but some bug might let it happen, so check defenses */ BEGIN;
/* destroy the dependency entry that prevents the ALTER: */ DELETE FROM x WHERE x = (SELECT x FROM x WHERE x = CAST('tt14v' AS REGCLASS) AND x = '_RETURN') AND x = 4 RETURNING PG_DESCRIBE_OBJECT(x, x, x) AS x, PG_DESCRIBE_OBJECT(x, x, x) AS x, x;
ALTER TABLE x ALTER COLUMN x SET DATA TYPE INT USING CAST(x AS INT) /* this will now succeed: */;
/* f4 is still in the view ... */ SELECT PG_GET_VIEWDEF('tt14v', TRUE);
/* but will fail at execution */ SELECT x, x FROM x;
SELECT * FROM x;
ROLLBACK;
DROP VIEW x;
CREATE VIEW x AS SELECT x.x, x.x FROM x AS x;
SELECT PG_GET_VIEWDEF('tt14v', TRUE);
SELECT * FROM x;
ALTER TABLE x DROP COLUMN x;
/* ok */ SELECT PG_GET_VIEWDEF('tt14v', TRUE);
EXPLAIN (verbose, costs off) select * from tt14v;
SELECT * FROM x;
/* check display of whole-row variables in some corner cases */ create type nestedcomposite as (x int8_tbl);
CREATE VIEW x AS SELECT CAST(ROW(x) AS nestedcomposite) FROM x AS x;
SELECT * FROM x;
SELECT PG_GET_VIEWDEF('tt15v', TRUE);
SELECT CAST(ROW(CAST(x.* AS int8_tbl)) AS nestedcomposite) FROM x AS x;
CREATE VIEW x AS SELECT * FROM x AS x, LATERAL (VALUES (x)) AS x;
SELECT * FROM x;
SELECT PG_GET_VIEWDEF('tt16v', TRUE);
SELECT * FROM x AS x, LATERAL (VALUES (CAST(x.* AS int8_tbl))) AS x;
CREATE VIEW x AS SELECT * FROM x AS x WHERE x IN (VALUES (x));
SELECT * FROM x;
SELECT PG_GET_VIEWDEF('tt17v', TRUE);
SELECT * FROM x AS x WHERE x.* IN (VALUES (CAST(x.* AS int8_tbl)));
CREATE TABLE x (x tt15v, x tt15v, x BOOLEAN);
create rule updlog as on update to tt15v do also   insert into tt15v_log values(old, new, row(old,old) < row(new,new));
SELECT PG_GET_VIEWDEF('tt18v', TRUE);
EXPLAIN (costs off) select * from tt18v;
/* check display of ScalarArrayOp with a sub-select */ SELECT CAST('foo' AS TEXT) = ANY(CAST(ARRAY('abc', 'def', 'foo') AS ARRAY<TEXT>));
SELECT CAST('foo' AS TEXT) = ANY ((SELECT CAST(ARRAY('abc', 'def', 'foo') AS ARRAY<TEXT>)));
/* fail */ SELECT CAST('foo' AS TEXT) = ANY(CAST((SELECT CAST(ARRAY('abc', 'def', 'foo') AS ARRAY<TEXT>)) AS ARRAY<TEXT>));
CREATE VIEW x AS SELECT CAST('foo' AS TEXT) = ANY(CAST(ARRAY('abc', 'def', 'foo') AS ARRAY<TEXT>)) AS x, CAST('foo' AS TEXT) = ANY(CAST((SELECT CAST(ARRAY('abc', 'def', 'foo') AS ARRAY<TEXT>)) AS ARRAY<TEXT>)) AS x;
SELECT PG_GET_VIEWDEF('tt19v', TRUE);
/* check display of assorted RTE_FUNCTION expressions */ create view tt20v as select * from   coalesce(1,2) as c,   collation for ('x'::text) col,   current_date as d,   localtimestamp(3) as t,   cast(1+2 as int4) as i4,   cast(1+2 as int8) as i8;
SELECT PG_GET_VIEWDEF('tt20v', TRUE);
/* reverse-listing of various special function syntaxes required by SQL */ create view tt201v as select   ('2022-12-01'::date + '1 day'::interval) at time zone 'UTC' as atz,   extract(day from now()) as extr,   (now(), '1 day'::interval) overlaps     (current_timestamp(2), '1 day'::interval) as o,   'foo' is normalized isn,   'foo' is nfkc normalized isnn,   normalize('foo') as n,   normalize('foo', nfkd) as nfkd,   overlay('foo' placing 'bar' from 2) as ovl,   overlay('foo' placing 'bar' from 2 for 3) as ovl2,   position('foo' in 'foobar') as p,   substring('foo' from 2 for 3) as s,   substring('foo' similar 'f' escape '#') as ss,   substring('foo' from 'oo') as ssf,  -- historically-permitted abuse   trim(' ' from ' foo ') as bt,   trim(leading ' ' from ' foo ') as lt,   trim(trailing ' foo ') as rt,   trim(E'\\000'::bytea from E'\\000Tom\\000'::bytea) as btb,   trim(leading E'\\000'::bytea from E'\\000Tom\\000'::bytea) as ltb,   trim(trailing E'\\000'::bytea from E'\\000Tom\\000'::bytea) as rtb,   CURRENT_DATE as cd,   (select * from CURRENT_DATE) as cd2,   CURRENT_TIME as ct,   (select * from CURRENT_TIME) as ct2,   CURRENT_TIME (1) as ct3,   (select * from CURRENT_TIME (1)) as ct4,   CURRENT_TIMESTAMP as ct5,   (select * from CURRENT_TIMESTAMP) as ct6,   CURRENT_TIMESTAMP (1) as ct7,   (select * from CURRENT_TIMESTAMP (1)) as ct8,   LOCALTIME as lt1,   (select * from LOCALTIME) as lt2,   LOCALTIME (1) as lt3,   (select * from LOCALTIME (1)) as lt4,   LOCALTIMESTAMP as lt5,   (select * from LOCALTIMESTAMP) as lt6,   LOCALTIMESTAMP (1) as lt7,   (select * from LOCALTIMESTAMP (1)) as lt8,   CURRENT_CATALOG as ca,   (select * from CURRENT_CATALOG) as ca2,   CURRENT_ROLE as cr,   (select * from CURRENT_ROLE) as cr2,   CURRENT_SCHEMA as cs,   (select * from CURRENT_SCHEMA) as cs2,   CURRENT_USER as cu,   (select * from CURRENT_USER) as cu2,   USER as us,   (select * from USER) as us2,   SESSION_USER seu,   (select * from SESSION_USER) as seu2,   SYSTEM_USER as su,   (select * from SYSTEM_USER) as su2;
SELECT PG_GET_VIEWDEF('tt201v', TRUE);
/* corner cases with empty join conditions */ CREATE VIEW x AS SELECT * FROM x NATURAL INNER JOIN x;
SELECT PG_GET_VIEWDEF('tt21v', TRUE);
CREATE VIEW x AS SELECT * FROM x NATURAL LEFT JOIN x;
SELECT PG_GET_VIEWDEF('tt22v', TRUE);
/* check handling of views with immediately-renamed columns */ CREATE VIEW x (x, x) AS SELECT x AS x, x AS x FROM x UNION SELECT 42, 43;
SELECT PG_GET_VIEWDEF('tt23v', TRUE);
SELECT PG_GET_RULEDEF(x, TRUE) FROM x WHERE x = CAST('tt23v' AS REGCLASS) AND x = '1';
/* test extraction of FieldSelect field names (get_name_for_var_field) */ CREATE VIEW x AS WITH x AS MATERIALIZED (SELECT x FROM (VALUES (1, 2), (3, 4)) AS x) SELECT (x).x AS x, (x).x AS x FROM x JOIN (SELECT x FROM (VALUES (1, 7), (3, 8)) AS x LIMIT 2) AS x ON (x).x = (x).x;
SELECT PG_GET_VIEWDEF('tt24v', TRUE);
CREATE VIEW x AS WITH x AS MATERIALIZED (SELECT PG_GET_KEYWORDS() AS x) SELECT (x).x FROM x;
SELECT PG_GET_VIEWDEF('tt25v', TRUE);
/* also check cases seen only in EXPLAIN */ EXPLAIN (verbose, costs off) select * from tt24v;
EXPLAIN (verbose, costs off) select (r).column2 from (select r from (values(1,2),(3,4)) r limit 1) ss;
/* test pretty-print parenthesization rules, and SubLink deparsing */ CREATE VIEW x AS SELECT x + x + x AS x, (x * x) + x AS x, x + (x * x) AS x, (x + x) * x AS x, x * (x + x) AS x, x + (x + x) AS x, x + (x ^ x) AS x, (x > x) AND (x > x OR x > x) AS x, (x > x) OR (x > x AND NOT (x > x)) AS x, (x, x) <> ALL(VALUES (1, 2), (3, 4)) AS x, (x, x) <= ANY(VALUES (1, 2), (3, 4)) AS x FROM (VALUES (1, 2, 3)) AS x;
SELECT PG_GET_VIEWDEF('tt26v', TRUE);
/* test restriction on non-system view expansion. */ CREATE TABLE x (x INT);
CREATE VIEW x AS SELECT x FROM x;
SET x = 'view';
SELECT x FROM x WHERE x > 0;
/* Error */ INSERT INTO x VALUES (1);
/* Error */ SELECT x FROM x WHERE x = 'tt27v';
/* Ok to access a system view. */ RESET restrict_nonsystem_relation_kind;
/* clean up all the random objects we made above */ DROP SCHEMA x.x CASCADE;
DROP SCHEMA x.x CASCADE;
CREATE DATABASE regression_tbd 	ENCODING utf8 LC_COLLATE "C" LC_CTYPE "C" TEMPLATE template0;
ALTER DATABASE regression_tbd RENAME TO regression_utf8;
ALTER DATABASE regression_utf8 SET TABLESPACE regress_tblspace;
ALTER DATABASE regression_utf8 RESET TABLESPACE;
ALTER DATABASE regression_utf8 CONNECTION_LIMIT 123;
/* Test PgDatabaseToastTable.  Doing this with GRANT would be slow. */ BEGIN;
UPDATE x SET x = ARRAY_FILL(MAKEACLITEM(10, 10, 'USAGE', FALSE), ARRAY(CAST(5e5 AS INT))) WHERE x = 'regression_utf8';
/* load catcache entry, if nothing else does */ ALTER DATABASE regression_utf8 RESET TABLESPACE;
ROLLBACK;
CREATE ROLE regress_datdba_before;
CREATE ROLE regress_datdba_after;
ALTER DATABASE regression_utf8 OWNER TO regress_datdba_before;
DROP DATABASE x;
DROP ROLE regress_datdba_before;
DROP ROLE regress_datdba_after;
/* DATE */ CREATE TABLE x (x DATE);
INSERT INTO x VALUES ('1957-04-09');
INSERT INTO x VALUES ('1957-06-13');
INSERT INTO x VALUES ('1996-02-28');
INSERT INTO x VALUES ('1996-02-29');
INSERT INTO x VALUES ('1996-03-01');
INSERT INTO x VALUES ('1996-03-02');
INSERT INTO x VALUES ('1997-02-28');
INSERT INTO x VALUES ('1997-02-29');
INSERT INTO x VALUES ('1997-03-01');
INSERT INTO x VALUES ('1997-03-02');
INSERT INTO x VALUES ('2000-04-01');
INSERT INTO x VALUES ('2000-04-02');
INSERT INTO x VALUES ('2000-04-03');
INSERT INTO x VALUES ('2038-04-08');
INSERT INTO x VALUES ('2039-04-09');
INSERT INTO x VALUES ('2040-04-10');
INSERT INTO x VALUES ('2040-04-10 BC');
SELECT x FROM x;
SELECT x FROM x WHERE x < '2000-01-01';
SELECT x FROM x WHERE x BETWEEN '2000-01-01' AND '2001-01-01';
SET x = iso /* Check all the documented input formats */;
SET x = ymd /* display results in ISO */;
SELECT CAST('January 8, 1999' AS DATE);
SELECT CAST('1999-01-08' AS DATE);
SELECT CAST('1999-01-18' AS DATE);
SELECT CAST('1/8/1999' AS DATE);
SELECT CAST('1/18/1999' AS DATE);
SELECT CAST('18/1/1999' AS DATE);
SELECT CAST('01/02/03' AS DATE);
SELECT CAST('19990108' AS DATE);
SELECT CAST('990108' AS DATE);
SELECT CAST('1999.008' AS DATE);
SELECT CAST('J2451187' AS DATE);
SELECT CAST('January 8, 99 BC' AS DATE);
SELECT CAST('99-Jan-08' AS DATE);
SELECT CAST('1999-Jan-08' AS DATE);
SELECT CAST('08-Jan-99' AS DATE);
SELECT CAST('08-Jan-1999' AS DATE);
SELECT CAST('Jan-08-99' AS DATE);
SELECT CAST('Jan-08-1999' AS DATE);
SELECT CAST('99-08-Jan' AS DATE);
SELECT CAST('1999-08-Jan' AS DATE);
SELECT CAST('99 Jan 08' AS DATE);
SELECT CAST('1999 Jan 08' AS DATE);
SELECT CAST('08 Jan 99' AS DATE);
SELECT CAST('08 Jan 1999' AS DATE);
SELECT CAST('Jan 08 99' AS DATE);
SELECT CAST('Jan 08 1999' AS DATE);
SELECT CAST('99 08 Jan' AS DATE);
SELECT CAST('1999 08 Jan' AS DATE);
SELECT CAST('99-01-08' AS DATE);
SELECT CAST('1999-01-08' AS DATE);
SELECT CAST('08-01-99' AS DATE);
SELECT CAST('08-01-1999' AS DATE);
SELECT CAST('01-08-99' AS DATE);
SELECT CAST('01-08-1999' AS DATE);
SELECT CAST('99-08-01' AS DATE);
SELECT CAST('1999-08-01' AS DATE);
SELECT CAST('99 01 08' AS DATE);
SELECT CAST('1999 01 08' AS DATE);
SELECT CAST('08 01 99' AS DATE);
SELECT CAST('08 01 1999' AS DATE);
SELECT CAST('01 08 99' AS DATE);
SELECT CAST('01 08 1999' AS DATE);
SELECT CAST('99 08 01' AS DATE);
SELECT CAST('1999 08 01' AS DATE);
SET x = dmy;
SELECT CAST('January 8, 1999' AS DATE);
SELECT CAST('1999-01-08' AS DATE);
SELECT CAST('1999-01-18' AS DATE);
SELECT CAST('1/8/1999' AS DATE);
SELECT CAST('1/18/1999' AS DATE);
SELECT CAST('18/1/1999' AS DATE);
SELECT CAST('01/02/03' AS DATE);
SELECT CAST('19990108' AS DATE);
SELECT CAST('990108' AS DATE);
SELECT CAST('1999.008' AS DATE);
SELECT CAST('J2451187' AS DATE);
SELECT CAST('January 8, 99 BC' AS DATE);
SELECT CAST('99-Jan-08' AS DATE);
SELECT CAST('1999-Jan-08' AS DATE);
SELECT CAST('08-Jan-99' AS DATE);
SELECT CAST('08-Jan-1999' AS DATE);
SELECT CAST('Jan-08-99' AS DATE);
SELECT CAST('Jan-08-1999' AS DATE);
SELECT CAST('99-08-Jan' AS DATE);
SELECT CAST('1999-08-Jan' AS DATE);
SELECT CAST('99 Jan 08' AS DATE);
SELECT CAST('1999 Jan 08' AS DATE);
SELECT CAST('08 Jan 99' AS DATE);
SELECT CAST('08 Jan 1999' AS DATE);
SELECT CAST('Jan 08 99' AS DATE);
SELECT CAST('Jan 08 1999' AS DATE);
SELECT CAST('99 08 Jan' AS DATE);
SELECT CAST('1999 08 Jan' AS DATE);
SELECT CAST('99-01-08' AS DATE);
SELECT CAST('1999-01-08' AS DATE);
SELECT CAST('08-01-99' AS DATE);
SELECT CAST('08-01-1999' AS DATE);
SELECT CAST('01-08-99' AS DATE);
SELECT CAST('01-08-1999' AS DATE);
SELECT CAST('99-08-01' AS DATE);
SELECT CAST('1999-08-01' AS DATE);
SELECT CAST('99 01 08' AS DATE);
SELECT CAST('1999 01 08' AS DATE);
SELECT CAST('08 01 99' AS DATE);
SELECT CAST('08 01 1999' AS DATE);
SELECT CAST('01 08 99' AS DATE);
SELECT CAST('01 08 1999' AS DATE);
SELECT CAST('99 08 01' AS DATE);
SELECT CAST('1999 08 01' AS DATE);
SET x = mdy;
SELECT CAST('January 8, 1999' AS DATE);
SELECT CAST('1999-01-08' AS DATE);
SELECT CAST('1999-01-18' AS DATE);
SELECT CAST('1/8/1999' AS DATE);
SELECT CAST('1/18/1999' AS DATE);
SELECT CAST('18/1/1999' AS DATE);
SELECT CAST('01/02/03' AS DATE);
SELECT CAST('19990108' AS DATE);
SELECT CAST('990108' AS DATE);
SELECT CAST('1999.008' AS DATE);
SELECT CAST('J2451187' AS DATE);
SELECT CAST('January 8, 99 BC' AS DATE);
SELECT CAST('99-Jan-08' AS DATE);
SELECT CAST('1999-Jan-08' AS DATE);
SELECT CAST('08-Jan-99' AS DATE);
SELECT CAST('08-Jan-1999' AS DATE);
SELECT CAST('Jan-08-99' AS DATE);
SELECT CAST('Jan-08-1999' AS DATE);
SELECT CAST('99-08-Jan' AS DATE);
SELECT CAST('1999-08-Jan' AS DATE);
SELECT CAST('99 Jan 08' AS DATE);
SELECT CAST('1999 Jan 08' AS DATE);
SELECT CAST('08 Jan 99' AS DATE);
SELECT CAST('08 Jan 1999' AS DATE);
SELECT CAST('Jan 08 99' AS DATE);
SELECT CAST('Jan 08 1999' AS DATE);
SELECT CAST('99 08 Jan' AS DATE);
SELECT CAST('1999 08 Jan' AS DATE);
SELECT CAST('99-01-08' AS DATE);
SELECT CAST('1999-01-08' AS DATE);
SELECT CAST('08-01-99' AS DATE);
SELECT CAST('08-01-1999' AS DATE);
SELECT CAST('01-08-99' AS DATE);
SELECT CAST('01-08-1999' AS DATE);
SELECT CAST('99-08-01' AS DATE);
SELECT CAST('1999-08-01' AS DATE);
SELECT CAST('99 01 08' AS DATE);
SELECT CAST('1999 01 08' AS DATE);
SELECT CAST('08 01 99' AS DATE);
SELECT CAST('08 01 1999' AS DATE);
SELECT CAST('01 08 99' AS DATE);
SELECT CAST('01 08 1999' AS DATE);
SELECT CAST('99 08 01' AS DATE);
SELECT CAST('1999 08 01' AS DATE);
/* Check upper and lower limits of date range */ SELECT CAST('4714-11-24 BC' AS DATE);
SELECT CAST('4714-11-23 BC' AS DATE);
/* out of range */ SELECT CAST('5874897-12-31' AS DATE);
SELECT CAST('5874898-01-01' AS DATE);
/* out of range */ /* Test non-error-throwing API */ SELECT PG_INPUT_IS_VALID('now', 'date');
SELECT PG_INPUT_IS_VALID('garbage', 'date');
SELECT PG_INPUT_IS_VALID('6874898-01-01', 'date');
SELECT * FROM x;
SELECT * FROM x;
RESET datestyle;
/* Simple math */ /* Leave most of it for the horology tests */ SELECT x - CAST('2000-01-01' AS DATE) AS "x" FROM x;
SELECT x - CAST('epoch' AS DATE) AS "x" FROM x;
SELECT CAST('yesterday' AS DATE) - CAST('today' AS DATE) AS "x";
SELECT CAST('today' AS DATE) - CAST('tomorrow' AS DATE) AS "x";
SELECT CAST('yesterday' AS DATE) - CAST('tomorrow' AS DATE) AS "x";
SELECT CAST('tomorrow' AS DATE) - CAST('today' AS DATE) AS "x";
SELECT CAST('today' AS DATE) - CAST('yesterday' AS DATE) AS "x";
SELECT CAST('tomorrow' AS DATE) - CAST('yesterday' AS DATE) AS "x";
/* test extract! */ SELECT x AS "x", EXTRACT(year FROM x) AS x, EXTRACT(month FROM x) AS x, EXTRACT(day FROM x) AS x, EXTRACT(quarter FROM x) AS x, EXTRACT(decade FROM x) AS x, EXTRACT(century FROM x) AS x, EXTRACT(millennium FROM x) AS x, EXTRACT(isoyear FROM x) AS x, EXTRACT(week FROM x) AS x, EXTRACT(dow FROM x) AS x, EXTRACT(isodow FROM x) AS x, EXTRACT(doy FROM x) AS x, EXTRACT(julian FROM x) AS x, EXTRACT(epoch FROM x) AS x FROM x;
/* epoch */ SELECT EXTRACT(EPOCH FROM CAST('1970-01-01' AS DATE));
/*  0 */ /* century */ SELECT EXTRACT(CENTURY FROM CAST('0101-12-31 BC' AS DATE));
/* -2 */ SELECT EXTRACT(CENTURY FROM CAST('0100-12-31 BC' AS DATE));
/* -1 */ SELECT EXTRACT(CENTURY FROM CAST('0001-12-31 BC' AS DATE));
/* -1 */ SELECT EXTRACT(CENTURY FROM CAST('0001-01-01' AS DATE));
/*  1 */ SELECT EXTRACT(CENTURY FROM CAST('0001-01-01 AD' AS DATE));
/*  1 */ SELECT EXTRACT(CENTURY FROM CAST('1900-12-31' AS DATE));
/* 19 */ SELECT EXTRACT(CENTURY FROM CAST('1901-01-01' AS DATE));
/* 20 */ SELECT EXTRACT(CENTURY FROM CAST('2000-12-31' AS DATE));
/* 20 */ SELECT EXTRACT(CENTURY FROM CAST('2001-01-01' AS DATE));
/* 21 */ SELECT EXTRACT(CENTURY FROM CURRENT_DATE) >= 21 AS x;
/* true */ /* millennium */ SELECT EXTRACT(MILLENNIUM FROM CAST('0001-12-31 BC' AS DATE));
/* -1 */ SELECT EXTRACT(MILLENNIUM FROM CAST('0001-01-01 AD' AS DATE));
/*  1 */ SELECT EXTRACT(MILLENNIUM FROM CAST('1000-12-31' AS DATE));
/*  1 */ SELECT EXTRACT(MILLENNIUM FROM CAST('1001-01-01' AS DATE));
/*  2 */ SELECT EXTRACT(MILLENNIUM FROM CAST('2000-12-31' AS DATE));
/*  2 */ SELECT EXTRACT(MILLENNIUM FROM CAST('2001-01-01' AS DATE));
/*  3 */ /* decade */ SELECT EXTRACT(DECADE FROM CAST('1994-12-25' AS DATE));
/* 199 */ SELECT EXTRACT(DECADE FROM CAST('0010-01-01' AS DATE));
/*   1 */ SELECT EXTRACT(DECADE FROM CAST('0009-12-31' AS DATE));
/*   0 */ SELECT EXTRACT(DECADE FROM CAST('0001-01-01 BC' AS DATE));
/*   0 */ SELECT EXTRACT(DECADE FROM CAST('0002-12-31 BC' AS DATE));
/*  -1 */ SELECT EXTRACT(DECADE FROM CAST('0011-01-01 BC' AS DATE));
/*  -1 */ SELECT EXTRACT(DECADE FROM CAST('0012-12-31 BC' AS DATE));
/*  -2 */ /* all possible fields */ SELECT EXTRACT(MICROSECONDS FROM CAST('2020-08-11' AS DATE));
SELECT EXTRACT(MILLISECONDS FROM CAST('2020-08-11' AS DATE));
SELECT EXTRACT(SECOND FROM CAST('2020-08-11' AS DATE));
SELECT EXTRACT(MINUTE FROM CAST('2020-08-11' AS DATE));
SELECT EXTRACT(HOUR FROM CAST('2020-08-11' AS DATE));
SELECT EXTRACT(DAY FROM CAST('2020-08-11' AS DATE));
SELECT EXTRACT(MONTH FROM CAST('2020-08-11' AS DATE));
SELECT EXTRACT(YEAR FROM CAST('2020-08-11' AS DATE));
SELECT EXTRACT(YEAR FROM CAST('2020-08-11 BC' AS DATE));
SELECT EXTRACT(DECADE FROM CAST('2020-08-11' AS DATE));
SELECT EXTRACT(CENTURY FROM CAST('2020-08-11' AS DATE));
SELECT EXTRACT(MILLENNIUM FROM CAST('2020-08-11' AS DATE));
SELECT EXTRACT(ISOYEAR FROM CAST('2020-08-11' AS DATE));
SELECT EXTRACT(ISOYEAR FROM CAST('2020-08-11 BC' AS DATE));
SELECT EXTRACT(QUARTER FROM CAST('2020-08-11' AS DATE));
SELECT EXTRACT(WEEK FROM CAST('2020-08-11' AS DATE));
SELECT EXTRACT(DOW FROM CAST('2020-08-11' AS DATE));
SELECT EXTRACT(DOW FROM CAST('2020-08-16' AS DATE));
SELECT EXTRACT(ISODOW FROM CAST('2020-08-11' AS DATE));
SELECT EXTRACT(ISODOW FROM CAST('2020-08-16' AS DATE));
SELECT EXTRACT(DOY FROM CAST('2020-08-11' AS DATE));
SELECT EXTRACT(TIMEZONE FROM CAST('2020-08-11' AS DATE));
SELECT EXTRACT(TIMEZONE_M FROM CAST('2020-08-11' AS DATE));
SELECT EXTRACT(TIMEZONE_H FROM CAST('2020-08-11' AS DATE));
SELECT EXTRACT(EPOCH FROM CAST('2020-08-11' AS DATE));
SELECT EXTRACT(JULIAN FROM CAST('2020-08-11' AS DATE));
/* test trunc function! */ SELECT TIMESTAMP_TRUNC(CAST('1970-03-20 04:30:00.00000' AS TIMESTAMP), MILLENNIUM);
/* 1001 */ SELECT TIMESTAMP_TRUNC(CAST('1970-03-20' AS DATE), MILLENNIUM);
/* 1001-01-01 */ SELECT TIMESTAMP_TRUNC(CAST('1970-03-20 04:30:00.00000' AS TIMESTAMP), CENTURY);
/* 1901 */ SELECT TIMESTAMP_TRUNC(CAST('1970-03-20' AS DATE), CENTURY);
/* 1901 */ SELECT TIMESTAMP_TRUNC(CAST('2004-08-10' AS DATE), CENTURY);
/* 2001-01-01 */ SELECT TIMESTAMP_TRUNC(CAST('0002-02-04' AS DATE), CENTURY);
/* 0001-01-01 */ SELECT TIMESTAMP_TRUNC(CAST('0055-08-10 BC' AS DATE), CENTURY);
/* 0100-01-01 BC */ SELECT TIMESTAMP_TRUNC(CAST('1993-12-25' AS DATE), DECADE);
/* 1990-01-01 */ SELECT TIMESTAMP_TRUNC(CAST('0004-12-25' AS DATE), DECADE);
/* 0001-01-01 BC */ SELECT TIMESTAMP_TRUNC(CAST('0002-12-31 BC' AS DATE), DECADE);
/* 0011-01-01 BC */ /* test infinity */ SELECT CAST('infinity' AS DATE), CAST('-infinity' AS DATE);
SELECT CAST('infinity' AS DATE) > CAST('today' AS DATE) AS x;
SELECT CAST('-infinity' AS DATE) < CAST('today' AS DATE) AS x;
SELECT ISFINITE(CAST('infinity' AS DATE)), ISFINITE(CAST('-infinity' AS DATE)), ISFINITE(CAST('today' AS DATE));
SELECT CAST('infinity' AS DATE) = CAST('+infinity' AS DATE) AS x;
/* oscillating fields from non-finite date: */ SELECT EXTRACT(DAY FROM CAST('infinity' AS DATE));
/* NULL */ SELECT EXTRACT(DAY FROM CAST('-infinity' AS DATE));
/* NULL */ /* all supported fields */ SELECT EXTRACT(DAY FROM CAST('infinity' AS DATE));
/* NULL */ SELECT EXTRACT(MONTH FROM CAST('infinity' AS DATE));
/* NULL */ SELECT EXTRACT(QUARTER FROM CAST('infinity' AS DATE));
/* NULL */ SELECT EXTRACT(WEEK FROM CAST('infinity' AS DATE));
/* NULL */ SELECT EXTRACT(DOW FROM CAST('infinity' AS DATE));
/* NULL */ SELECT EXTRACT(ISODOW FROM CAST('infinity' AS DATE));
/* NULL */ SELECT EXTRACT(DOY FROM CAST('infinity' AS DATE));
/* NULL */ /* monotonic fields from non-finite date: */ SELECT EXTRACT(EPOCH FROM CAST('infinity' AS DATE));
/*  Infinity */ SELECT EXTRACT(EPOCH FROM CAST('-infinity' AS DATE));
/* -Infinity */ /* all supported fields */ SELECT EXTRACT(YEAR FROM CAST('infinity' AS DATE));
/*  Infinity */ SELECT EXTRACT(DECADE FROM CAST('infinity' AS DATE));
/*  Infinity */ SELECT EXTRACT(CENTURY FROM CAST('infinity' AS DATE));
/*  Infinity */ SELECT EXTRACT(MILLENNIUM FROM CAST('infinity' AS DATE));
/*  Infinity */ SELECT EXTRACT(JULIAN FROM CAST('infinity' AS DATE));
/*  Infinity */ SELECT EXTRACT(ISOYEAR FROM CAST('infinity' AS DATE));
/*  Infinity */ SELECT EXTRACT(EPOCH FROM CAST('infinity' AS DATE));
/*  Infinity */ /* wrong fields from non-finite date: */ SELECT EXTRACT(MICROSEC FROM CAST('infinity' AS DATE));
/* error */ /* test constructors */ SELECT MAKE_DATE(2013, 7, 15);
SELECT MAKE_DATE(-44, 3, 15);
SELECT TIME_FROM_PARTS(8, 20, 0.0);
/* should fail */ SELECT MAKE_DATE(0, 7, 15);
SELECT MAKE_DATE(2013, 2, 30);
SELECT MAKE_DATE(2013, 13, 1);
SELECT MAKE_DATE(2013, 11, -1);
SELECT MAKE_DATE(-2147483648, 1, 1);
SELECT TIME_FROM_PARTS(10, 55, 100.1);
SELECT TIME_FROM_PARTS(24, 0, 2.1);
SELECT x, PG_SIZE_PRETTY(x), PG_SIZE_PRETTY(-1 * x) FROM (VALUES (CAST(10 AS BIGINT)), (CAST(1000 AS BIGINT)), (CAST(1000000 AS BIGINT)), (CAST(1000000000 AS BIGINT)), (CAST(1000000000000 AS BIGINT)), (CAST(1000000000000000 AS BIGINT))) AS x;
SELECT x, PG_SIZE_PRETTY(x), PG_SIZE_PRETTY(-1 * x) FROM (VALUES (CAST(10 AS DECIMAL)), (CAST(1000 AS DECIMAL)), (CAST(1000000 AS DECIMAL)), (CAST(1000000000 AS DECIMAL)), (CAST(1000000000000 AS DECIMAL)), (CAST(1000000000000000 AS DECIMAL)), (CAST(10.5 AS DECIMAL)), (CAST(1000.5 AS DECIMAL)), (CAST(1000000.5 AS DECIMAL)), (CAST(1000000000.5 AS DECIMAL)), (CAST(1000000000000.5 AS DECIMAL)), (CAST(1000000000000000.5 AS DECIMAL))) AS x;
/* test where units change up */ SELECT x, PG_SIZE_PRETTY(x), PG_SIZE_PRETTY(-1 * x) FROM (VALUES (CAST(10239 AS BIGINT)), (CAST(10240 AS BIGINT)), (CAST(10485247 AS BIGINT)), (CAST(10485248 AS BIGINT)), (CAST(10736893951 AS BIGINT)), (CAST(10736893952 AS BIGINT)), (CAST(10994579406847 AS BIGINT)), (CAST(10994579406848 AS BIGINT)), (CAST(11258449312612351 AS BIGINT)), (CAST(11258449312612352 AS BIGINT))) AS x;
SELECT x, PG_SIZE_PRETTY(x), PG_SIZE_PRETTY(-1 * x) FROM (VALUES (CAST(10239 AS DECIMAL)), (CAST(10240 AS DECIMAL)), (CAST(10485247 AS DECIMAL)), (CAST(10485248 AS DECIMAL)), (CAST(10736893951 AS DECIMAL)), (CAST(10736893952 AS DECIMAL)), (CAST(10994579406847 AS DECIMAL)), (CAST(10994579406848 AS DECIMAL)), (CAST(11258449312612351 AS DECIMAL)), (CAST(11258449312612352 AS DECIMAL)), (CAST(11528652096115048447 AS DECIMAL)), (CAST(11528652096115048448 AS DECIMAL))) AS x;
/* Ensure we get the expected results when passing the extremities of bigint */ SELECT PG_SIZE_PRETTY(CAST('-9223372036854775808' AS BIGINT)), PG_SIZE_PRETTY(CAST('9223372036854775807' AS BIGINT));
/* pg_size_bytes() tests */ SELECT x, PG_SIZE_BYTES(x) FROM (VALUES ('1'), ('123bytes'), ('256 B'), ('1kB'), ('1MB'), (' 1 GB'), ('1.5 GB '), ('1TB'), ('3000 TB'), ('1e6 MB'), ('99 PB')) AS x;
/* case-insensitive units are supported */ SELECT x, PG_SIZE_BYTES(x) FROM (VALUES ('1'), ('123bYteS'), ('1kb'), ('1mb'), (' 1 Gb'), ('1.5 gB '), ('1tb'), ('3000 tb'), ('1e6 mb'), ('99 pb')) AS x;
/* negative numbers are supported */ SELECT x, PG_SIZE_BYTES(x) FROM (VALUES ('-1'), ('-123bytes'), ('-1kb'), ('-1mb'), (' -1 Gb'), ('-1.5 gB '), ('-1tb'), ('-3000 TB'), ('-10e-1 MB'), ('-99 PB')) AS x;
/* different cases with allowed points */ SELECT x, PG_SIZE_BYTES(x) FROM (VALUES ('-1.'), ('-1.kb'), ('-1. kb'), ('-0. gb'), ('-.1'), ('-.1kb'), ('-.1 kb'), ('-.0 gb')) AS x;
/* invalid inputs */ SELECT PG_SIZE_BYTES('1 AB');
SELECT PG_SIZE_BYTES('1 AB A');
SELECT PG_SIZE_BYTES('1 AB A    ');
SELECT PG_SIZE_BYTES('9223372036854775807.9');
SELECT PG_SIZE_BYTES('1e100');
SELECT PG_SIZE_BYTES('1e1000000000000000000');
SELECT PG_SIZE_BYTES('1 byte');
/* the singular "byte" is not supported */ SELECT PG_SIZE_BYTES('');
SELECT PG_SIZE_BYTES('kb');
SELECT PG_SIZE_BYTES('..');
SELECT PG_SIZE_BYTES('-.');
SELECT PG_SIZE_BYTES('-.kb');
SELECT PG_SIZE_BYTES('-. kb');
SELECT PG_SIZE_BYTES('.+912');
SELECT PG_SIZE_BYTES('+912+ kB');
SELECT PG_SIZE_BYTES('++123 kB');
CREATE TABLE x (x SERIAL PRIMARY KEY, x INT, x TEXT);
INSERT INTO x (x) VALUES (10);
INSERT INTO x (x, x) VALUES (50, REPEAT('x', 10000));
INSERT INTO x (x) VALUES (100);
/* allow an alias to be specified for DELETE's target table */ DELETE FROM x AS x WHERE x.x > 75;
/* if an alias is specified, don't allow the original table name */ /* to be referenced */ DELETE FROM x AS x WHERE x.x > 25;
SELECT x, x, LENGTH(x) FROM x;
/* delete a row with a TOASTed value */ DELETE FROM x WHERE x > 25;
SELECT x, x, LENGTH(x) FROM x;
DROP TABLE x;
/* DEPENDENCIES */ CREATE USER regress_dep_user;
CREATE USER regress_dep_user2;
CREATE USER regress_dep_user3;
CREATE GROUP regress_dep_group;
CREATE TABLE x (x SERIAL PRIMARY KEY, x TEXT);
GRANT SELECT ON TABLE x TO GROUP x;
GRANT ALL ON TABLE x TO x, x;
/* can't drop neither because they have privileges somewhere */ DROP USER regress_dep_user;
DROP GROUP regress_dep_group;
/* if we revoke the privileges we can drop the group */ REVOKE SELECT ON deptest FROM GROUP regress_dep_group;
DROP GROUP regress_dep_group;
/* can't drop the user if we revoke the privileges partially */ REVOKE SELECT, INSERT, UPDATE, DELETE, TRUNCATE, REFERENCES, MAINTAIN ON deptest FROM regress_dep_user;
DROP USER regress_dep_user;
/* now we are OK to drop him */ REVOKE TRIGGER ON deptest FROM regress_dep_user;
DROP USER regress_dep_user;
/* we are OK too if we drop the privileges all at once */ REVOKE ALL ON deptest FROM regress_dep_user2;
DROP USER regress_dep_user2;
DROP USER regress_dep_user3;
DROP USER regress_dep_user3;
/* Test DROP OWNED */ CREATE USER regress_dep_user0;
CREATE USER regress_dep_user1;
CREATE USER regress_dep_user2;
SET SESSION AUTHORIZATION regress_dep_user0;
/* permission denied */ DROP OWNED BY regress_dep_user1;
DROP OWNED BY regress_dep_user0, regress_dep_user2;
/* this one is allowed */ DROP OWNED BY regress_dep_user0;
CREATE TABLE x (x INT UNIQUE);
GRANT ALL ON x TO x WITH GRANT OPTION;
SET SESSION AUTHORIZATION regress_dep_user1;
CREATE TABLE x (x SERIAL PRIMARY KEY, x TEXT);
GRANT ALL ON x TO x;
RESET SESSION AUTHORIZATION;
GRANT CREATE ON DATABASE x TO x;
SET SESSION AUTHORIZATION regress_dep_user1;
CREATE SCHEMA x.x;
CREATE TABLE x (x SERIAL PRIMARY KEY, x TEXT);
ALTER DEFAULT PRIVILEGES FOR ROLE regress_dep_user1 IN SCHEMA deptest   GRANT ALL ON TABLES TO regress_dep_user2;
CREATE TYPE deptest_enum AS ENUM ('red');
CREATE TYPE deptest_range AS RANGE (SUBTYPE = int4);
CREATE TABLE x (x INT);
/* make a serial column the hard way */ CREATE SEQUENCE x;
ALTER TABLE x ALTER COLUMN x SET DEFAULT NEXTVAL('ss1');
ALTER SEQUENCE ss1 OWNED BY deptest2.f1;
/* When reassigning ownership of a composite type, its pg_class entry */ /* should match */ CREATE TYPE deptest_t AS (a int);
SELECT x = x FROM x JOIN x AS x ON x = x.x WHERE x = 'deptest_t';
RESET SESSION AUTHORIZATION;
/* doesn't work: grant still exists */ DROP USER regress_dep_user1;
DROP OWNED BY regress_dep_user1;
DROP USER regress_dep_user1;
DROP USER regress_dep_user2;
DROP OWNED BY regress_dep_user2, regress_dep_user0;
DROP USER regress_dep_user2;
DROP USER regress_dep_user0;
/* Test domains. */ /* Test Comment / Drop */ create domain domaindroptest int4;
comment on domain domaindroptest is 'About to drop this..';
create domain dependenttypetest domaindroptest;
/* fail because of dependent type */ drop domain domaindroptest;
drop domain domaindroptest cascade;
/* this should fail because already gone */ drop domain domaindroptest cascade;
/* some error cases */ create domain d_fail as no_such_type;
create domain d_fail as int constraint cc REFERENCES this_table_not_exists(i);
create domain d_fail as int4 not null no inherit;
create domain d_fail as int4 not null null;
create domain d_fail as int4 not null default 3 default 3;
create domain d_fail int4 DEFAULT 3 + 'h';
create domain d_fail int4 collate "C";
create domain d_fail as anyelement;
create domain d_fail as int4 unique;
create domain d_fail as int4 PRIMARY key;
create domain d_fail as int4 constraint cc generated by default as identity;
create domain d_fail as int4 constraint cc check (values > 1) no inherit;
create domain d_fail as int4 constraint cc check (values > 1) deferrable;
/* Test domain input. */ /* Note: the point of checking both INSERT and COPY FROM is that INSERT */ /* exercises CoerceToDomain while COPY exercises domain_in. */ create domain domainvarchar varchar(5);
create domain domainnumeric numeric(8,2);
create domain domainint4 int4;
create domain domaintext text;
/* Test explicit coercions --- these should succeed (and truncate) */ SELECT CAST('123456' AS domainvarchar);
SELECT CAST('12345' AS domainvarchar);
/* Test tables using domains */ CREATE TABLE x (x domainint4, x domaintext, x domainvarchar, x domainnumeric);
INSERT INTO x VALUES ('88', 'haha', 'short', '123.12');
/* Good */ INSERT INTO x VALUES ('88', 'haha', 'short text', '123.12');
/* Bad varchar */ INSERT INTO x VALUES ('88', 'haha', 'short', '123.1212');
COPY INTO x (x) FROM x /* Truncate numeric */ /* Test copy */;
/* check that domains inherit operations from base types */ SELECT x || x AS x, x + 42 AS x FROM x;
/* check that union/case/coalesce type resolution handles domains properly */ SELECT PG_TYPEOF(COALESCE(CAST(4 AS domainint4), 7));
SELECT PG_TYPEOF(COALESCE(CAST(4 AS domainint4), CAST(7 AS domainint4)));
DROP TABLE x;
drop domain domainvarchar restrict;
drop domain domainnumeric restrict;
drop domain domainint4 restrict;
drop domain domaintext;
/* Test non-error-throwing input */ create domain positiveint int4 check(value > 0);
create domain weirdfloat float8 check((1 / value) < 10);
SELECT PG_INPUT_IS_VALID('1', 'positiveint');
SELECT PG_INPUT_IS_VALID('junk', 'positiveint');
SELECT PG_INPUT_IS_VALID('-1', 'positiveint');
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
/* We currently can't trap errors raised in the CHECK expression itself */ SELECT * FROM x;
drop domain positiveint;
drop domain weirdfloat;
/* Test domains over array types */ create domain domainint4arr int4[1];
create domain domainchar4arr varchar(4)[2][3];
CREATE TABLE x (x domainint4arr, x domainchar4arr);
INSERT INTO x VALUES ('{2,2}', '{{"a","b"},{"c","d"}}');
INSERT INTO x VALUES ('{{2,2},{2,2}}', '{{"a","b"}}');
INSERT INTO x VALUES ('{2,2}', '{{"a","b"},{"c","d"},{"e","f"}}');
INSERT INTO x VALUES ('{2,2}', '{{"a"},{"c"}}');
INSERT INTO x VALUES (NULL, '{{"a","b","c"},{"d","e","f"}}');
INSERT INTO x VALUES (NULL, '{{"toolong","b","c"},{"d","e","f"}}');
SELECT * FROM x;
SELECT x[0], x[2 : 2] FROM x;
SELECT ARRAY_DIMS(x), ARRAY_DIMS(x) FROM x;
COPY INTO x FROM x;
UPDATE x SET x[0] = x[0] + 1, x[2] = x[2] - 1 WHERE x IS NULL;
SELECT * FROM x WHERE x IS NULL;
DROP TABLE x;
drop domain domainint4arr restrict;
drop domain domainchar4arr restrict;
create domain dia as int[];
SELECT CAST('{1,2,3}' AS dia);
SELECT ARRAY_DIMS(CAST('{1,2,3}' AS dia));
SELECT PG_TYPEOF(CAST('{1,2,3}' AS dia));
SELECT PG_TYPEOF(CAST('{1,2,3}' AS dia) || 42);
/* should be int[] not dia */ drop domain dia;
/* Test domains over composites */ create type comptype as (r float8, i float8);
create domain dcomptype as comptype;
CREATE TABLE x (x dcomptype UNIQUE);
INSERT INTO x VALUES (CAST(ROW(1, 2) AS dcomptype));
INSERT INTO x VALUES (CAST(ROW(3, 4) AS comptype));
INSERT INTO x VALUES (CAST(ROW(1, 2) AS dcomptype));
SELECT * FROM x;
SELECT (x).x, (x).x, (x).* FROM x;
UPDATE x SET x.x = (x).x + 1 WHERE (x).x > 0;
SELECT * FROM x;
alter domain dcomptype add constraint c1 check ((value).r <= (value).i);
alter domain dcomptype add constraint c2 check ((value).r > (value).i);
/* fail */ SELECT CAST(ROW(2, 1) AS dcomptype);
/* fail */ INSERT INTO x VALUES (CAST(ROW(1, 2) AS comptype));
INSERT INTO x VALUES (CAST(ROW(2, 1) AS comptype));
/* fail */ UPDATE x SET x.x = (x).x + 1 WHERE (x).x > 0;
/* fail */ UPDATE x SET x.x = (x).x - 1, x.x = (x).x + 1 WHERE (x).x > 0;
SELECT * FROM x;
EXPLAIN (verbose, costs off)   update dcomptable set d1.r = (d1).r - 1, d1.i = (d1).i + 1 where (d1).i > 0;
create rule silly as on delete to dcomptable do instead   update dcomptable set d1.r = (d1).r - 1, d1.i = (d1).i + 1 where (d1).i > 0;
SELECT MAKEDCOMP(1, 2);
SELECT MAKEDCOMP(2, 1);
/* fail */ SELECT * FROM x AS x;
SELECT x, NOT x IS NULL FROM x AS x;
DROP FUNCTION x (DOUBLE, DOUBLE);
DROP TABLE x;
drop type comptype cascade;
/* check altering and dropping columns used by domain constraints */ create type comptype as (r float8, i float8);
create domain dcomptype as comptype;
alter domain dcomptype add constraint c1 check ((value).r > 0);
SELECT CAST(ROW(0, 1) AS dcomptype);
/* fail */ alter type comptype alter attribute r type varchar;
/* fail */ alter type comptype alter attribute r type bigint;
alter type comptype drop attribute r;
/* fail */ alter type comptype drop attribute i;
SELECT x, OBJ_DESCRIPTION(x, 'pg_constraint') FROM x WHERE x = CAST('dcomptype' AS REGTYPE);
/* check comment is still there */ drop type comptype cascade;
/* Test domains over arrays of composite */ create type comptype as (r float8, i float8);
create domain dcomptypea as comptype[];
CREATE TABLE x (x dcomptypea UNIQUE);
INSERT INTO x VALUES (CAST(ARRAY(ROW(1, 2)) AS dcomptypea));
INSERT INTO x VALUES (CAST(ARRAY(ROW(3, 4), ROW(5, 6)) AS ARRAY<comptype>));
INSERT INTO x VALUES (ARRAY(CAST(ROW(7, 8) AS comptype), CAST(ROW(9, 10) AS comptype)));
INSERT INTO x VALUES (CAST(ARRAY(ROW(1, 2)) AS dcomptypea));
SELECT * FROM x;
SELECT x[1], x[0].x, x[0].x FROM x;
UPDATE x SET x[1] = ROW(x[1].x, x[1].x);
SELECT * FROM x;
UPDATE x SET x[0].x = x[0].x + 1 WHERE x[0].x > 0;
SELECT * FROM x;
alter domain dcomptypea add constraint c1 check (value[1].r <= value[1].i);
alter domain dcomptypea add constraint c2 check (value[1].r > value[1].i);
/* fail */ SELECT CAST(ARRAY(ROW(2, 1)) AS dcomptypea);
/* fail */ INSERT INTO x VALUES (CAST(ARRAY(ROW(1, 2)) AS ARRAY<comptype>));
INSERT INTO x VALUES (CAST(ARRAY(ROW(2, 1)) AS ARRAY<comptype>));
/* fail */ UPDATE x SET x[0].x = x[0].x + 1 WHERE x[0].x > 0;
/* fail */ UPDATE x SET x[0].x = x[0].x - 1, x[0].x = x[0].x + 1 WHERE x[0].x > 0;
SELECT * FROM x;
EXPLAIN (verbose, costs off)   update dcomptable set d1[1].r = d1[1].r - 1, d1[1].i = d1[1].i + 1     where d1[1].i > 0;
create rule silly as on delete to dcomptable do instead   update dcomptable set d1[1].r = d1[1].r - 1, d1[1].i = d1[1].i + 1     where d1[1].i > 0;
drop type comptype cascade;
/* Test arrays over domains */ create domain posint as int check (value > 0);
CREATE TABLE x (x ARRAY<posint>);
INSERT INTO x VALUES (ARRAY(42));
INSERT INTO x VALUES (ARRAY(-1));
/* fail */ INSERT INTO x VALUES ('{0}');
/* fail */ UPDATE x SET x[0] = x[0] + 1;
UPDATE x SET x[0] = 0;
/* fail */ SELECT * FROM x;
DROP TABLE x;
create domain vc4 as varchar(4);
CREATE TABLE x (x ARRAY<vc4>);
INSERT INTO x VALUES (ARRAY('too long'));
/* fail */ INSERT INTO x VALUES (CAST(ARRAY('too long') AS ARRAY<vc4>));
/* cast truncates */ SELECT * FROM x;
DROP TABLE x;
drop type vc4;
/* You can sort of fake arrays-of-arrays by putting a domain in between */ create domain dposinta as posint[];
CREATE TABLE x (x ARRAY<dposinta>);
INSERT INTO x VALUES (ARRAY(ARRAY(42)));
/* fail */ INSERT INTO x VALUES (ARRAY(CAST(ARRAY(42) AS ARRAY<posint>)));
/* still fail */ INSERT INTO x VALUES (ARRAY(CAST(ARRAY(42) AS dposinta)));
/* but this works */ SELECT x, x[0], (x[0])[0] FROM x;
SELECT PG_TYPEOF(x) FROM x;
SELECT PG_TYPEOF(x[0]) FROM x;
SELECT PG_TYPEOF(x[0][0]) FROM x;
SELECT PG_TYPEOF((x[0])[0]) FROM x;
UPDATE x SET x[1] = ARRAY(99);
SELECT x, x[0], (x[1])[0] FROM x;
/* it'd be nice if you could do something like this, but for now you can't: */ UPDATE x SET x[1][0] = ARRAY(97);
/* maybe someday we can make this syntax work: */ UPDATE x SET (x[1])[0] = ARRAY(98);
DROP TABLE x;
drop domain posint cascade;
/* Test arrays over domains of composite */ create type comptype as (cf1 int, cf2 int);
create domain dcomptype as comptype check ((value).cf1 > 0);
CREATE TABLE x (x ARRAY<dcomptype>);
INSERT INTO x VALUES (NULL);
UPDATE x SET x[0].x = 5;
x AS x;
UPDATE x SET x[0].x = -1;
/* fail */ UPDATE x SET x[0].x = 1;
x AS x;
/* if there's no constraints, a different code path is taken: */ alter domain dcomptype drop constraint dcomptype_check;
UPDATE x SET x[0].x = -1;
x AS x /* now ok */;
DROP TABLE x;
drop type comptype cascade;
/* Test not-null restrictions */ create domain dnotnull varchar(15) NOT NULL;
create domain dnull    varchar(15);
create domain dcheck   varchar(15) NOT NULL CHECK (VALUE = 'a' OR VALUE = 'c' OR VALUE = 'd');
CREATE TABLE x (x dnotnull, x dnotnull NULL /* NOT NULL in the domain cannot be overridden */, x dnull NOT NULL, x dnull, x dcheck CHECK (x IN ('c', 'd')));
INSERT INTO x VALUES ('a', 'b', 'c', 'd', 'c');
/* Good */ INSERT INTO x VALUES ('a', 'b', 'c', 'd', NULL);
INSERT INTO x VALUES ('a', 'b', 'c', 'd', 'a');
INSERT INTO x VALUES (NULL, 'b', 'c', 'd', 'd');
INSERT INTO x VALUES ('a', NULL, 'c', 'd', 'c');
INSERT INTO x VALUES ('a', 'b', NULL, 'd', 'c');
INSERT INTO x VALUES ('a', 'b', 'c', NULL, 'd');
COPY INTO x FROM x /* Good */ /* Test copy */;
/* Test out coerced (casted) constraints */ SELECT CAST('1' AS dnotnull);
SELECT CAST(NULL AS dnotnull);
/* fail */ SELECT CAST(CAST(NULL AS dnull) AS dnotnull);
/* fail */ SELECT CAST(x AS dnotnull) FROM x;
/* fail */ /* cleanup */ DROP TABLE x;
drop domain dnotnull restrict;
drop domain dnull restrict;
drop domain dcheck restrict;
create domain ddef1 int4 DEFAULT 3;
create domain ddef2 oid DEFAULT '12';
/* Type mixing, function returns int8 */ create domain ddef3 text DEFAULT 5;
CREATE SEQUENCE x;
create domain ddef4 int4 DEFAULT nextval('ddef4_seq');
create domain ddef5 numeric(8,2) NOT NULL DEFAULT '12.12';
CREATE TABLE x (x ddef1, x ddef2, x ddef3, x ddef4 PRIMARY KEY, x ddef1 NOT NULL DEFAULT NULL, x ddef2 DEFAULT '88', x ddef4 DEFAULT 8000, x ddef5);
INSERT INTO x (x) VALUES (0);
ALTER TABLE x ALTER COLUMN x DROP DEFAULT /* fails, col5 defaults to null */;
INSERT INTO x (x) VALUES (0);
ALTER TABLE x ALTER COLUMN x DROP DEFAULT /* fails */;
COPY INTO x (x) FROM x /* Test defaults with copy */;
DROP TABLE x CASCADE;
/* Test ALTER DOMAIN .. NOT NULL */ create domain dnotnulltest integer;
CREATE TABLE x (x dnotnulltest, x dnotnulltest);
alter domain dnotnulltest set not null;
/* fails */ UPDATE x SET x = 5;
alter domain dnotnulltest set not null;
/* fails */ UPDATE x SET x = 6;
alter domain dnotnulltest set not null;
UPDATE x SET x = NULL;
/* fails */ alter domain dnotnulltest drop not null;
UPDATE x SET x = NULL;
UPDATE x SET x = 5;
/* these constraints can also be added and removed by name */ alter domain dnotnulltest add constraint dnotnulltest_notnull not null;
UPDATE x SET x = NULL;
/* fails */ SELECT x, PG_GET_CONSTRAINTDEF(x) FROM x WHERE x = CAST('dnotnulltest' AS REGTYPE);
alter domain dnotnulltest drop constraint dnotnulltest_notnull;
UPDATE x SET x = NULL;
drop domain dnotnulltest cascade;
/* Test ALTER DOMAIN .. DEFAULT .. */ CREATE TABLE x (x ddef1);
SELECT * FROM x;
alter domain ddef1 set default '42';
SELECT * FROM x;
alter domain ddef1 drop default;
SELECT * FROM x;
DROP TABLE x;
/* Test ALTER DOMAIN .. CONSTRAINT .. */ create domain con as integer;
CREATE TABLE x (x con);
INSERT INTO x VALUES (1);
INSERT INTO x VALUES (2);
alter domain con add constraint t check (VALUE < 1);
/* fails */ alter domain con add constraint t check (VALUE < 34);
alter domain con add check (VALUE > 0);
/* fails */ INSERT INTO x VALUES (42);
/* fails */ INSERT INTO x VALUES (5);
alter domain con drop constraint t;
INSERT INTO x VALUES (-5);
/* fails */ INSERT INTO x VALUES (42);
alter domain con drop constraint nonexistent;
alter domain con drop constraint if exists nonexistent;
/* not-null constraints */ create domain connotnull integer;
CREATE TABLE x (x connotnull, x connotnull);
alter domain connotnull add not null;
/* fails */ UPDATE x SET x = 5;
alter domain connotnull add not null;
/* fails */ UPDATE x SET x = 6;
alter domain connotnull add constraint constr1 not null;
SELECT COUNT(*) FROM x WHERE x = CAST('connotnull' AS REGTYPE) AND x = 'n';
alter domain connotnull add constraint constr1bis not null;
/* redundant */ SELECT COUNT(*) FROM x WHERE x = CAST('connotnull' AS REGTYPE) AND x = 'n';
/* fails */ alter domain connotnull drop constraint constr1;
UPDATE x SET x = NULL;
drop domain connotnull cascade;
DROP TABLE x;
/* Test ALTER DOMAIN .. CONSTRAINT .. NOT VALID */ create domain things AS INT;
CREATE TABLE x (x things);
INSERT INTO x (x) VALUES (55);
ALTER DOMAIN things ADD CONSTRAINT meow CHECK (VALUE < 11);
ALTER DOMAIN things ADD CONSTRAINT meow CHECK (VALUE < 11) NOT VALID;
ALTER DOMAIN things VALIDATE CONSTRAINT meow;
UPDATE x SET x = 10;
ALTER DOMAIN things VALIDATE CONSTRAINT meow;
/* Confirm ALTER DOMAIN with RULES. */ CREATE TABLE x (x INT);
create domain dom as integer;
CREATE VIEW x AS SELECT CAST(x AS dom) FROM x;
INSERT INTO x (x) VALUES (NULL);
INSERT INTO x (x) VALUES (5);
SELECT * FROM x;
alter domain dom set not null;
SELECT * FROM x;
/* fail */ alter domain dom drop not null;
SELECT * FROM x;
alter domain dom add constraint domchkgt6 check(value > 6);
SELECT * FROM x;
/* fail */ alter domain dom drop constraint domchkgt6 restrict;
SELECT * FROM x;
/* cleanup */ drop domain ddef1 restrict;
drop domain ddef2 restrict;
drop domain ddef3 restrict;
drop domain ddef4 restrict;
drop domain ddef5 restrict;
DROP SEQUENCE x;
/* Test domains over domains */ create domain vchar4 varchar(4);
create domain dinter vchar4 check (substring(VALUE, 1, 1) = 'x');
create domain dtop dinter check (substring(VALUE, 2, 1) = '1');
SELECT CAST('x123' AS dtop);
SELECT CAST('x1234' AS dtop);
/* explicit coercion should truncate */ SELECT CAST('y1234' AS dtop);
/* fail */ SELECT CAST('y123' AS dtop);
/* fail */ SELECT CAST('yz23' AS dtop);
/* fail */ SELECT CAST('xz23' AS dtop);
/* fail */ CREATE TEMPORARY TABLE x (x dtop);
INSERT INTO x VALUES ('x123');
INSERT INTO x VALUES ('x1234');
/* fail, implicit coercion */ INSERT INTO x VALUES ('y1234');
/* fail, implicit coercion */ INSERT INTO x VALUES ('y123');
/* fail */ INSERT INTO x VALUES ('yz23');
/* fail */ INSERT INTO x VALUES ('xz23');
/* fail */ DROP TABLE x;
drop domain vchar4 cascade;
/* Make sure that constraints of newly-added domain columns are */ /* enforced correctly, even if there's no default value for the new */ /* column. Per bug #1433 */ create domain str_domain as text not null;
CREATE TABLE x (x INT, x INT);
INSERT INTO x VALUES (1, 2);
INSERT INTO x VALUES (1, 2);
ALTER TABLE x ADD COLUMN x str_domain /* should fail */;
create domain str_domain2 as text check (value <> 'foo') default 'foo';
ALTER TABLE x ADD COLUMN x str_domain2 /* should fail */;
/* Check that domain constraints on prepared statement parameters of */ /* unknown type are enforced correctly. */ create domain pos_int as int4 check (value > 0) not null;
PREPARE s1 as select $1::pos_int = 10 as "is_ten";
EXECUTE s1(10);
EXECUTE s1(0);
/* should fail */ EXECUTE s1(NULL);
BEGIN return p1;
SELECT DOUBLEDECREMENT(3);
BEGIN return p1;
SELECT DOUBLEDECREMENT(3);
BEGIN v := p1 - 1;
SELECT DOUBLEDECREMENT(NULL);
/* fail before call */ SELECT DOUBLEDECREMENT(0);
/* fail before call */ SELECT DOUBLEDECREMENT(1);
/* fail at assignment to v */ SELECT DOUBLEDECREMENT(2);
/* fail at return */ SELECT DOUBLEDECREMENT(3);
/* good */ /* Check that ALTER DOMAIN tests columns of derived types */ create domain posint as int4;
/* Currently, this doesn't work for composite types, but verify it complains */ create type ddtest1 as (f1 posint);
CREATE TABLE x (x ddtest1);
INSERT INTO x VALUES (ROW(-1));
alter domain posint add constraint c1 check(value >= 0);
DROP TABLE x;
/* Likewise for domains within arrays of composite */ CREATE TABLE x (x ARRAY<ddtest1>);
INSERT INTO x VALUES ('{(-1)}');
alter domain posint add constraint c1 check(value >= 0);
DROP TABLE x;
/* Likewise for domains within domains over composite */ create domain ddtest1d as ddtest1;
CREATE TABLE x (x ddtest1d);
INSERT INTO x VALUES ('(-1)');
alter domain posint add constraint c1 check(value >= 0);
DROP TABLE x;
drop domain ddtest1d;
/* Likewise for domains within domains over array of composite */ create domain ddtest1d as ddtest1[];
CREATE TABLE x (x ddtest1d);
INSERT INTO x VALUES ('{(-1)}');
alter domain posint add constraint c1 check(value >= 0);
DROP TABLE x;
drop domain ddtest1d;
/* Doesn't work for ranges, either */ create type rposint as range (subtype = posint);
CREATE TABLE x (x rposint);
INSERT INTO x VALUES ('(-1,3]');
alter domain posint add constraint c1 check(value >= 0);
DROP TABLE x;
drop type rposint;
alter domain posint add constraint c1 check(value >= 0);
create domain posint2 as posint check (value % 2 = 0);
CREATE TABLE x (x posint2);
INSERT INTO x VALUES (11);
/* fail */ INSERT INTO x VALUES (-2);
/* fail */ INSERT INTO x VALUES (2);
alter domain posint add constraint c2 check(value >= 10);
/* fail */ alter domain posint add constraint c2 check(value > 0);
/* OK */ DROP TABLE x;
drop type ddtest1;
drop domain posint cascade;
BEGIN x[1] := $1;
SELECT ARRAY_ELEM_CHECK(121.00);
SELECT ARRAY_ELEM_CHECK(1.23456);
create domain mynums as numeric(4,2)[1];
BEGIN x[1] := $1;
SELECT ARRAY_ELEM_CHECK(121.00);
SELECT ARRAY_ELEM_CHECK(1.23456);
create domain mynums2 as mynums;
BEGIN x[1] := $1;
SELECT ARRAY_ELEM_CHECK(121.00);
SELECT ARRAY_ELEM_CHECK(1.23456);
DROP FUNCTION x (DECIMAL);
/* Check enforcement of array-level domain constraints */ create domain orderedpair as int[2] check (value[1] < value[2]);
SELECT CAST(ARRAY(1, 2) AS orderedpair);
SELECT CAST(ARRAY(2, 1) AS orderedpair);
/* fail */ CREATE TEMPORARY TABLE x (x orderedpair);
INSERT INTO x VALUES (ARRAY(1, 2));
INSERT INTO x VALUES (ARRAY(2, 1));
/* fail */ UPDATE x SET x[1] = 3;
UPDATE x SET x[1] = 0;
/* fail */ SELECT * FROM x;
BEGIN x[2] := $1;
SELECT ARRAY_ELEM_CHECK(3);
SELECT ARRAY_ELEM_CHECK(-1);
DROP FUNCTION x (INT);
/* Check enforcement of changing constraints in plpgsql */ create domain di as int;
BEGIN d := $1::di;
x AS x;
SELECT DOM_CHECK(0);
alter domain di add constraint pos check (value > 0);
SELECT DOM_CHECK(0);
/* fail */ alter domain di drop constraint pos;
SELECT DOM_CHECK(0);
BEGIN d := $1;
x AS x;
SELECT DOM_CHECK(0);
alter domain di add constraint pos check (value > 0);
SELECT DOM_CHECK(0);
/* fail */ alter domain di drop constraint pos;
SELECT DOM_CHECK(0);
DROP FUNCTION x (INT);
drop domain di;
/* this has caused issues in the past */ CREATE FUNCTION x(x, x) RETURNS BOOLEAN LANGUAGE sql AS 'select $1 is distinct from $2 limit 1';
create domain inotnull int   check (sql_is_distinct_from(value, null));
SELECT CAST(1 AS inotnull);
SELECT CAST(NULL AS inotnull);
CREATE TABLE x (x inotnull);
INSERT INTO x VALUES ('1');
INSERT INTO x VALUES (1);
INSERT INTO x VALUES (NULL);
DROP TABLE x;
drop domain inotnull;
DROP FUNCTION x (anyelement, anyelement);
/* Renaming */ create domain testdomain1 as int;
alter domain testdomain1 rename to testdomain2;
alter type testdomain2 rename to testdomain3;
/* alter type also works */ drop domain testdomain3;
/* Renaming domain constraints */ create domain testdomain1 as int constraint unsigned check (value > 0);
alter domain testdomain1 rename constraint unsigned to unsigned_foo;
alter domain testdomain1 drop constraint unsigned_foo;
drop domain testdomain1;
/* Get the base type of a domain */ create domain mytext as text;
create domain mytext_child_1 as mytext;
SELECT PG_BASETYPE(CAST('mytext' AS REGTYPE));
SELECT PG_BASETYPE(CAST('mytext_child_1' AS REGTYPE));
SELECT PG_BASETYPE(1);
/* expect NULL not error */ drop domain mytext cascade;
/* Explicit enforceability specification not allowed */ /* - */ CREATE DOMAIN constraint_enforced_dom AS int CONSTRAINT the_constraint CHECK (value > 0) ENFORCED;
CREATE DOMAIN constraint_not_enforced_dom AS int CONSTRAINT the_constraint CHECK (value > 0) NOT ENFORCED;
CREATE DOMAIN constraint_enforced_dom AS int;
/* XXX misleading error messages */ ALTER DOMAIN constraint_enforced_dom ADD CONSTRAINT the_constraint CHECK (value > 0) ENFORCED;
ALTER DOMAIN constraint_enforced_dom ADD CONSTRAINT the_constraint CHECK (value > 0) NOT ENFORCED;
DROP DOMAIN constraint_enforced_dom;
/* Information schema */ SELECT * FROM x.x WHERE x IN ('con', 'dom', 'pos_int', 'things') ORDER BY x NULLS LAST;
SELECT * FROM x.x WHERE x IN ('con', 'dom', 'pos_int', 'things') ORDER BY x NULLS LAST;
SELECT * FROM x.x WHERE x IN ('con', 'dom', 'pos_int', 'things') ORDER BY x NULLS LAST;
SELECT * FROM x.x WHERE (x, x) IN (SELECT x, x FROM x.x WHERE x IN ('con', 'dom', 'pos_int', 'things')) ORDER BY x NULLS LAST;
/* IF EXISTS tests */ /* table (will be really dropped at the end) */ DROP TABLE x;
DROP TABLE IF EXISTS x;
CREATE TABLE x (x INT, x TEXT);
/* view */ DROP VIEW x;
DROP VIEW IF EXISTS x;
CREATE VIEW x AS SELECT * FROM x;
DROP VIEW IF EXISTS x;
DROP VIEW x;
/* index */ DROP INDEX x;
DROP INDEX IF EXISTS x;
CREATE INDEX x ON x(x NULLS LAST);
DROP INDEX IF EXISTS x;
DROP INDEX x;
/* sequence */ DROP SEQUENCE x;
DROP SEQUENCE IF EXISTS x;
CREATE SEQUENCE x;
DROP SEQUENCE IF EXISTS x;
DROP SEQUENCE x;
/* schema */ DROP SCHEMA x.x;
DROP SCHEMA IF EXISTS x;
CREATE SCHEMA x.x;
DROP SCHEMA IF EXISTS x;
DROP SCHEMA x.x;
/* type */ DROP TYPE test_type_exists;
DROP TYPE IF EXISTS test_type_exists;
CREATE type test_type_exists as (a int, b text);
DROP TYPE IF EXISTS test_type_exists;
DROP TYPE test_type_exists;
/* domain */ DROP DOMAIN test_domain_exists;
DROP DOMAIN IF EXISTS test_domain_exists;
CREATE domain test_domain_exists as int not null check (value > 0);
DROP DOMAIN IF EXISTS test_domain_exists;
DROP DOMAIN test_domain_exists;
/* - */ /* - role/user/group */ /* - */ CREATE USER regress_test_u1;
CREATE ROLE regress_test_r1;
CREATE GROUP regress_test_g1;
DROP USER regress_test_u2;
DROP USER IF EXISTS regress_test_u1, regress_test_u2;
DROP USER regress_test_u1;
DROP ROLE regress_test_r2;
DROP ROLE IF EXISTS regress_test_r1, regress_test_r2;
DROP ROLE regress_test_r1;
DROP GROUP regress_test_g2;
DROP GROUP IF EXISTS regress_test_g1, regress_test_g2;
DROP GROUP regress_test_g1;
/* collation */ DROP COLLATION IF EXISTS test_collation_exists;
/* conversion */ DROP CONVERSION test_conversion_exists;
DROP CONVERSION IF EXISTS test_conversion_exists;
CREATE CONVERSION test_conversion_exists     FOR 'LATIN1' TO 'UTF8' FROM iso8859_1_to_utf8;
DROP CONVERSION test_conversion_exists;
/* text search parser */ DROP TEXT SEARCH PARSER test_tsparser_exists;
DROP TEXT SEARCH PARSER IF EXISTS test_tsparser_exists;
/* text search dictionary */ DROP TEXT SEARCH DICTIONARY test_tsdict_exists;
DROP TEXT SEARCH DICTIONARY IF EXISTS test_tsdict_exists;
CREATE TEXT SEARCH DICTIONARY test_tsdict_exists (         Template=ispell,         DictFile=ispell_sample,         AffFile=ispell_sample );
DROP TEXT SEARCH DICTIONARY test_tsdict_exists;
/* test search template */ DROP TEXT SEARCH TEMPLATE test_tstemplate_exists;
DROP TEXT SEARCH TEMPLATE IF EXISTS test_tstemplate_exists;
/* text search configuration */ DROP TEXT SEARCH CONFIGURATION test_tsconfig_exists;
DROP TEXT SEARCH CONFIGURATION IF EXISTS test_tsconfig_exists;
CREATE TEXT SEARCH CONFIGURATION test_tsconfig_exists (COPY=english);
DROP TEXT SEARCH CONFIGURATION test_tsconfig_exists;
/* extension */ DROP EXTENSION test_extension_exists;
DROP EXTENSION IF EXISTS test_extension_exists;
/* functions */ DROP FUNCTION x;
DROP FUNCTION IF EXISTS x;
DROP FUNCTION x (INT, TEXT, ARRAY<INT>);
DROP FUNCTION IF EXISTS x (INT, TEXT, ARRAY<INT>);
/* aggregate */ DROP AGGREGATE test_aggregate_exists(*);
DROP AGGREGATE IF EXISTS test_aggregate_exists(*);
DROP AGGREGATE test_aggregate_exists(int);
DROP AGGREGATE IF EXISTS test_aggregate_exists(int);
/* operator */ DROP OPERATOR @#@ (int, int);
DROP OPERATOR IF EXISTS @#@ (int, int);
CREATE OPERATOR @#@         (leftarg = int8, rightarg = int8, procedure = int8xor);
DROP OPERATOR @#@ (int8, int8);
/* language */ DROP LANGUAGE test_language_exists;
DROP LANGUAGE IF EXISTS test_language_exists;
/* cast */ DROP CAST (text AS text);
DROP CAST IF EXISTS (text AS text);
/* trigger */ DROP TRIGGER test_trigger_exists ON test_exists;
DROP TRIGGER IF EXISTS test_trigger_exists ON test_exists;
DROP TRIGGER test_trigger_exists ON no_such_table;
DROP TRIGGER IF EXISTS test_trigger_exists ON no_such_table;
DROP TRIGGER test_trigger_exists ON no_such_schema.no_such_table;
DROP TRIGGER IF EXISTS test_trigger_exists ON no_such_schema.no_such_table;
CREATE TRIGGER test_trigger_exists     BEFORE UPDATE ON test_exists     FOR EACH ROW EXECUTE PROCEDURE suppress_redundant_updates_trigger();
DROP TRIGGER test_trigger_exists ON test_exists;
/* rule */ DROP RULE test_rule_exists ON test_exists;
DROP RULE IF EXISTS test_rule_exists ON test_exists;
DROP RULE test_rule_exists ON no_such_table;
DROP RULE IF EXISTS test_rule_exists ON no_such_table;
DROP RULE test_rule_exists ON no_such_schema.no_such_table;
DROP RULE IF EXISTS test_rule_exists ON no_such_schema.no_such_table;
CREATE RULE test_rule_exists AS ON INSERT TO test_exists     DO INSTEAD     INSERT INTO test_exists VALUES (NEW.a, NEW.b || NEW.a::text);
DROP RULE test_rule_exists ON test_exists;
/* foreign data wrapper */ DROP FOREIGN DATA WRAPPER test_fdw_exists;
DROP FOREIGN DATA WRAPPER IF EXISTS test_fdw_exists;
/* foreign server */ DROP SERVER test_server_exists;
DROP SERVER IF EXISTS test_server_exists;
/* operator class */ DROP OPERATOR CLASS test_operator_class USING btree;
DROP OPERATOR CLASS IF EXISTS test_operator_class USING btree;
DROP OPERATOR CLASS test_operator_class USING no_such_am;
DROP OPERATOR CLASS IF EXISTS test_operator_class USING no_such_am;
/* operator family */ DROP OPERATOR FAMILY test_operator_family USING btree;
DROP OPERATOR FAMILY IF EXISTS test_operator_family USING btree;
DROP OPERATOR FAMILY test_operator_family USING no_such_am;
DROP OPERATOR FAMILY IF EXISTS test_operator_family USING no_such_am;
/* access method */ DROP ACCESS METHOD no_such_am;
DROP ACCESS METHOD IF EXISTS no_such_am;
/* drop the table */ DROP TABLE IF EXISTS x;
DROP TABLE x;
/* be tolerant with missing schemas, types, etc */ DROP AGGREGATE IF EXISTS no_such_schema.foo(int);
DROP AGGREGATE IF EXISTS foo(no_such_type);
DROP AGGREGATE IF EXISTS foo(no_such_schema.no_such_type);
DROP CAST IF EXISTS (INTEGER AS no_such_type2);
DROP CAST IF EXISTS (no_such_type1 AS INTEGER);
DROP CAST IF EXISTS (INTEGER AS no_such_schema.bar);
DROP CAST IF EXISTS (no_such_schema.foo AS INTEGER);
DROP COLLATION IF EXISTS no_such_schema.foo;
DROP CONVERSION IF EXISTS no_such_schema.foo;
DROP DOMAIN IF EXISTS no_such_schema.foo;
DROP FOREIGN TABLE IF EXISTS no_such_schema.foo;
DROP FUNCTION IF EXISTS x.x;
DROP FUNCTION IF EXISTS x (no_such_type);
DROP FUNCTION IF EXISTS x (no_such_schema.no_such_type);
DROP INDEX IF EXISTS x.x;
DROP MATERIALIZED VIEW IF EXISTS x.x;
DROP OPERATOR IF EXISTS no_such_schema.+ (int, int);
DROP OPERATOR IF EXISTS + (no_such_type, no_such_type);
DROP OPERATOR IF EXISTS + (no_such_schema.no_such_type, no_such_schema.no_such_type);
DROP OPERATOR IF EXISTS # (NONE, no_such_schema.no_such_type);
DROP OPERATOR CLASS IF EXISTS no_such_schema.widget_ops USING btree;
DROP OPERATOR FAMILY IF EXISTS no_such_schema.float_ops USING btree;
DROP RULE IF EXISTS foo ON no_such_schema.bar;
DROP SEQUENCE IF EXISTS x.x;
DROP TABLE IF EXISTS x.x;
DROP TEXT SEARCH CONFIGURATION IF EXISTS no_such_schema.foo;
DROP TEXT SEARCH DICTIONARY IF EXISTS no_such_schema.foo;
DROP TEXT SEARCH PARSER IF EXISTS no_such_schema.foo;
DROP TEXT SEARCH TEMPLATE IF EXISTS no_such_schema.foo;
DROP TRIGGER IF EXISTS foo ON no_such_schema.bar;
DROP TYPE IF EXISTS no_such_schema.foo;
DROP VIEW IF EXISTS x.x;
DROP FUNCTION x;
DROP FUNCTION IF EXISTS x;
/* cleanup */ DROP FUNCTION x (INT);
DROP FUNCTION x (TEXT);
DROP PROCEDURE x;
DROP PROCEDURE IF EXISTS x;
/* Check we get a similar error if we use ROUTINE instead of PROCEDURE. */ DROP ROUTINE IF EXISTS test_ambiguous_procname;
/* cleanup */ DROP PROCEDURE x (INT);
DROP PROCEDURE x (TEXT);
/* This test checks both the functionality of 'if exists' and the syntax */ /* of the drop database command. */ DROP DATABASE x (force);
DROP DATABASE IF EXISTS x (force);
CREATE OPERATOR !== (         PROCEDURE = int8ne,         LEFTARG = bigint,         RIGHTARG = bigint,         NEGATOR = ===,         COMMUTATOR = !== );
DROP OPERATOR !==(bigint, bigint);
SELECT x, x FROM x.x AS x WHERE x <> 0 AND NOT EXISTS(SELECT 1 FROM x.x AS x WHERE x.x = x.x);
SELECT x, x FROM x.x AS x WHERE x <> 0 AND NOT EXISTS(SELECT 1 FROM x.x AS x WHERE x.x = x.x);
DROP OPERATOR ===(bigint, bigint);
CREATE OPERATOR <| (         PROCEDURE = int8lt,         LEFTARG = bigint,         RIGHTARG = bigint );
CREATE OPERATOR |> (         PROCEDURE = int8gt,         LEFTARG = bigint,         RIGHTARG = bigint,         NEGATOR = <|,         COMMUTATOR = <| );
DROP OPERATOR |>(bigint, bigint);
SELECT x, x FROM x.x AS x WHERE x <> 0 AND NOT EXISTS(SELECT 1 FROM x.x AS x WHERE x.x = x.x);
SELECT x, x FROM x.x AS x WHERE x <> 0 AND NOT EXISTS(SELECT 1 FROM x.x AS x WHERE x.x = x.x);
DROP OPERATOR <|(bigint, bigint);
/* Enum tests */ CREATE TYPE rainbow AS ENUM ('red', 'orange', 'yellow', 'green', 'blue', 'purple');
/* Did it create the right number of rows? */ SELECT COUNT(*) FROM x WHERE x = CAST('rainbow' AS REGTYPE);
/* I/O functions */ SELECT CAST('red' AS rainbow);
SELECT CAST('mauve' AS rainbow);
/* Also try it with non-error-throwing API */ SELECT PG_INPUT_IS_VALID('red', 'rainbow');
SELECT PG_INPUT_IS_VALID('mauve', 'rainbow');
SELECT * FROM x;
SELECT x, x FROM x WHERE x = CAST('planets' AS REGTYPE) ORDER BY 2 NULLS LAST;
ALTER TYPE planets ADD VALUE 'uranus';
SELECT x, x FROM x WHERE x = CAST('planets' AS REGTYPE) ORDER BY 2 NULLS LAST;
ALTER TYPE planets ADD VALUE 'mercury' BEFORE 'venus';
ALTER TYPE planets ADD VALUE 'saturn' BEFORE 'uranus';
ALTER TYPE planets ADD VALUE 'jupiter' AFTER 'mars';
ALTER TYPE planets ADD VALUE 'neptune' AFTER 'uranus';
SELECT x, x FROM x WHERE x = CAST('planets' AS REGTYPE) ORDER BY 2 NULLS LAST;
SELECT x, x FROM x WHERE x = CAST('planets' AS REGTYPE) ORDER BY CAST(x AS planets) NULLS LAST;
/* errors for adding labels */ ALTER TYPE planets ADD VALUE   'plutoplutoplutoplutoplutoplutoplutoplutoplutoplutoplutoplutoplutopluto';
ALTER TYPE planets ADD VALUE 'pluto' AFTER 'zeus';
/* if not exists tests */ /*  existing value gives error */ ALTER TYPE planets ADD VALUE 'mercury';
/* unless IF NOT EXISTS is specified */ ALTER TYPE planets ADD VALUE IF NOT EXISTS 'mercury';
/* should be neptune, not mercury */ SELECT ENUM_LAST(CAST(NULL AS planets));
ALTER TYPE planets ADD VALUE IF NOT EXISTS 'pluto';
/* should be pluto, i.e. the new value */ SELECT ENUM_LAST(CAST(NULL AS planets));
/* Test inserting so many values that we have to renumber */ create type insenum as enum ('L1', 'L2');
alter type insenum add value 'i1' before 'L2';
alter type insenum add value 'i2' before 'L2';
alter type insenum add value 'i3' before 'L2';
alter type insenum add value 'i4' before 'L2';
alter type insenum add value 'i5' before 'L2';
alter type insenum add value 'i6' before 'L2';
alter type insenum add value 'i7' before 'L2';
alter type insenum add value 'i8' before 'L2';
alter type insenum add value 'i9' before 'L2';
alter type insenum add value 'i10' before 'L2';
alter type insenum add value 'i11' before 'L2';
alter type insenum add value 'i12' before 'L2';
alter type insenum add value 'i13' before 'L2';
alter type insenum add value 'i14' before 'L2';
alter type insenum add value 'i15' before 'L2';
alter type insenum add value 'i16' before 'L2';
alter type insenum add value 'i17' before 'L2';
alter type insenum add value 'i18' before 'L2';
alter type insenum add value 'i19' before 'L2';
alter type insenum add value 'i20' before 'L2';
alter type insenum add value 'i21' before 'L2';
alter type insenum add value 'i22' before 'L2';
alter type insenum add value 'i23' before 'L2';
alter type insenum add value 'i24' before 'L2';
alter type insenum add value 'i25' before 'L2';
alter type insenum add value 'i26' before 'L2';
alter type insenum add value 'i27' before 'L2';
alter type insenum add value 'i28' before 'L2';
alter type insenum add value 'i29' before 'L2';
alter type insenum add value 'i30' before 'L2';
/* Basic table creation, row selection */ CREATE TABLE x (x rainbow);
INSERT INTO x VALUES ('red'), ('orange'), ('yellow'), ('green');
COPY INTO x FROM x;
/* Operators, no index */ SELECT * FROM x WHERE x = 'orange';
SELECT * FROM x WHERE x <> 'orange' ORDER BY x NULLS LAST;
SELECT * FROM x WHERE x > 'yellow' ORDER BY x NULLS LAST;
SELECT * FROM x WHERE x >= 'yellow' ORDER BY x NULLS LAST;
SELECT * FROM x WHERE x < 'green' ORDER BY x NULLS LAST;
SELECT * FROM x WHERE x <= 'green' ORDER BY x NULLS LAST;
/* Cast to/from text */ SELECT CAST(CAST('red' AS rainbow) AS TEXT) || 'hithere';
SELECT CAST(CAST('red' AS TEXT) AS rainbow) = CAST('red' AS rainbow);
/* Aggregates */ SELECT MIN(x) FROM x;
SELECT MAX(x) FROM x;
SELECT MAX(x) FROM x WHERE x < 'green';
SET x = off /* Index tests, force use of index */;
SET x = off;
/* Btree index / opclass with the various operators */ CREATE UNIQUE INDEX x ON x USING btree(x NULLS LAST);
SELECT * FROM x WHERE x = 'orange';
SELECT * FROM x WHERE x <> 'orange' ORDER BY x NULLS LAST;
SELECT * FROM x WHERE x > 'yellow' ORDER BY x NULLS LAST;
SELECT * FROM x WHERE x >= 'yellow' ORDER BY x NULLS LAST;
SELECT * FROM x WHERE x < 'green' ORDER BY x NULLS LAST;
SELECT * FROM x WHERE x <= 'green' ORDER BY x NULLS LAST;
SELECT MIN(x) FROM x;
SELECT MAX(x) FROM x;
SELECT MAX(x) FROM x WHERE x < 'green';
DROP INDEX x;
/* Hash index / opclass with the = operator */ CREATE INDEX x ON x USING hash(x NULLS LAST);
SELECT * FROM x WHERE x = 'orange';
DROP INDEX x;
/* End index tests */ RESET enable_seqscan;
RESET enable_bitmapscan;
/* Domains over enums */ CREATE DOMAIN rgb AS rainbow CHECK (VALUE IN ('red', 'green', 'blue'));
SELECT CAST('red' AS rgb);
SELECT CAST('purple' AS rgb);
SELECT CAST(CAST('purple' AS rainbow) AS rgb);
DROP DOMAIN rgb;
/* Arrays */ SELECT CAST('{red,green,blue}' AS ARRAY<rainbow>);
SELECT (CAST('{red,green,blue}' AS ARRAY<rainbow>))[1];
SELECT 'red' = ANY(CAST('{red,green,blue}' AS ARRAY<rainbow>));
SELECT 'yellow' = ANY(CAST('{red,green,blue}' AS ARRAY<rainbow>));
SELECT 'red' = ALL(CAST('{red,green,blue}' AS ARRAY<rainbow>));
SELECT 'red' = ALL(CAST('{red,red}' AS ARRAY<rainbow>));
/* Support functions */ SELECT ENUM_FIRST(CAST(NULL AS rainbow));
SELECT ENUM_LAST(CAST('green' AS rainbow));
SELECT ENUM_RANGE(CAST(NULL AS rainbow));
SELECT ENUM_RANGE(CAST('orange' AS rainbow), CAST('green' AS rainbow));
SELECT ENUM_RANGE(NULL, CAST('green' AS rainbow));
SELECT ENUM_RANGE(CAST('orange' AS rainbow), NULL);
SELECT ENUM_RANGE(CAST(NULL AS rainbow), NULL);
SELECT ECHO_ME(CAST('red' AS rainbow));
SELECT ECHO_ME(CAST('red' AS rainbow));
/* If we drop the original generic one, we don't have to qualify the type */ /* anymore, since there's only one match */ DROP FUNCTION x (anyenum);
SELECT ECHO_ME('red');
DROP FUNCTION x (rainbow);
/* RI triggers on enum types */ CREATE TABLE x (x rainbow PRIMARY KEY);
CREATE TABLE x (x rainbow REFERENCES x);
INSERT INTO x VALUES ('red');
INSERT INTO x VALUES ('red');
INSERT INTO x VALUES ('blue');
/* fail */ DELETE FROM x;
/* fail */ /* cross-type RI should fail */ CREATE TYPE bogus AS ENUM('good', 'bad', 'ugly');
CREATE TABLE x (x bogus REFERENCES x);
DROP TYPE bogus;
/* check renaming a value */ ALTER TYPE rainbow RENAME VALUE 'red' TO 'crimson';
SELECT x, x FROM x WHERE x = CAST('rainbow' AS REGTYPE) ORDER BY 2 NULLS LAST;
/* check that renaming a non-existent value fails */ ALTER TYPE rainbow RENAME VALUE 'red' TO 'crimson';
/* check that renaming to an existent value fails */ ALTER TYPE rainbow RENAME VALUE 'blue' TO 'green';
/* check transactional behaviour of ALTER TYPE ... ADD VALUE */ CREATE TYPE bogus AS ENUM('good');
/* check that we can add new values to existing enums in a transaction */ /* but we can't use them */ BEGIN;
ALTER TYPE bogus ADD VALUE 'new';
x AS x;
SELECT CAST('new' AS bogus);
ROLLBACK TO x /* unsafe */;
SELECT ENUM_FIRST(CAST(NULL AS bogus));
/* safe */ SELECT ENUM_LAST(CAST(NULL AS bogus));
ROLLBACK TO x /* unsafe */;
SELECT ENUM_RANGE(CAST(NULL AS bogus));
ROLLBACK TO x /* unsafe */;
COMMIT;
SELECT CAST('new' AS bogus);
/* now safe */ SELECT x, x FROM x WHERE x = CAST('bogus' AS REGTYPE) ORDER BY 2 NULLS LAST;
ALTER TYPE bogus RENAME TO bogon;
ALTER TYPE bogon ADD VALUE 'bad';
SELECT CAST('bad' AS bogon);
ROLLBACK;
/* but a renamed value is safe to use later in same transaction */ BEGIN;
ALTER TYPE bogus RENAME VALUE 'good' to 'bad';
SELECT CAST('bad' AS bogus);
ROLLBACK;
DROP TYPE bogus;
/* check that values created during CREATE TYPE can be used in any case */ BEGIN;
CREATE TYPE bogus AS ENUM('good','bad','ugly');
ALTER TYPE bogus RENAME TO bogon;
SELECT ENUM_RANGE(CAST(NULL AS bogon));
ROLLBACK;
/* we must allow this usage to support pg_dump in binary upgrade mode */ BEGIN;
CREATE TYPE bogus AS ENUM('good');
ALTER TYPE bogus RENAME TO bogon;
ALTER TYPE bogon ADD VALUE 'bad';
ALTER TYPE bogon ADD VALUE 'ugly';
SELECT ENUM_RANGE(CAST(NULL AS bogon));
ROLLBACK;
/* Cleanup */ DROP TABLE x;
DROP TABLE x;
DROP TABLE x;
DROP TYPE rainbow;
/* Verify properly cleaned up */ SELECT COUNT(*) FROM x WHERE x = 'rainbow';
SELECT * FROM x WHERE NOT EXISTS(SELECT 1 FROM x WHERE x.x = x);
CREATE FUNCTION x(x) RETURNS int8alias1 STRICT IMMUTABLE LANGUAGE internal AS 'int8in';
CREATE FUNCTION x(x) RETURNS CSTRING STRICT IMMUTABLE LANGUAGE internal AS 'int8out';
create type int8alias1 (     input = int8alias1in,     output = int8alias1out,     like = int8 );
create type int8alias2;
CREATE FUNCTION x(x) RETURNS int8alias2 STRICT IMMUTABLE LANGUAGE internal AS 'int8in';
CREATE FUNCTION x(x) RETURNS CSTRING STRICT IMMUTABLE LANGUAGE internal AS 'int8out';
create type int8alias2 (     input = int8alias2in,     output = int8alias2out,     like = int8 );
create cast (int8 as int8alias1) without function;
create cast (int8 as int8alias2) without function;
create cast (int8alias1 as int8) without function;
create cast (int8alias2 as int8) without function;
CREATE FUNCTION x(x, x) RETURNS BOOLEAN STRICT IMMUTABLE LANGUAGE internal AS 'int8eq';
alter operator family integer_ops using btree add   operator 3 = (int8alias1, int8alias1);
CREATE FUNCTION x(x, x) RETURNS BOOLEAN STRICT IMMUTABLE LANGUAGE internal AS 'int8eq';
alter operator family integer_ops using btree add   operator 3 = (int8alias2, int8alias2);
CREATE FUNCTION x(x, x) RETURNS BOOLEAN STRICT IMMUTABLE LANGUAGE internal AS 'int8eq';
alter operator family integer_ops using btree add   operator 3 = (int8, int8alias1);
CREATE FUNCTION x(x, x) RETURNS BOOLEAN STRICT IMMUTABLE LANGUAGE internal AS 'int8eq';
alter operator family integer_ops using btree add   operator 3 = (int8alias1, int8alias2);
CREATE FUNCTION x(x, x) RETURNS BOOLEAN STRICT IMMUTABLE LANGUAGE internal AS 'int8lt';
create operator < (     procedure = int8alias1lt,     leftarg = int8alias1, rightarg = int8alias1 );
alter operator family integer_ops using btree add   operator 1 < (int8alias1, int8alias1);
CREATE FUNCTION x(x, x) RETURNS INT STRICT IMMUTABLE LANGUAGE internal AS 'btint8cmp';
alter operator family integer_ops using btree add   function 1 int8alias1cmp (int8, int8alias1);
CREATE TABLE x (x BIGINT PRIMARY KEY, x BIGINT, x BIGINT);
CREATE TABLE x (x BIGINT PRIMARY KEY, x int8alias1, x int8alias2);
CREATE TABLE x (x BIGINT PRIMARY KEY, x int8alias1, x int8alias2);
SET x = off /* for the moment we only want to look at nestloop plans */;
SET x = off;
/* Note that for cases where there's a missing operator, we don't care so */ /* much whether the plan is ideal as that we don't fail or generate an */ /* outright incorrect plan. */ EXPLAIN (costs off)   select * from ec0 where ff = f1 and f1 = '42'::int8;
EXPLAIN (costs off)   select * from ec0 where ff = f1 and f1 = '42'::int8alias1;
EXPLAIN (costs off)   select * from ec1 where ff = f1 and f1 = '42'::int8alias1;
EXPLAIN (costs off)   select * from ec1 where ff = f1 and f1 = '42'::int8alias2;
EXPLAIN (costs off)   select * from ec1, ec2 where ff = x1 and ff = '42'::int8;
EXPLAIN (costs off)   select * from ec1, ec2 where ff = x1 and ff = '42'::int8alias1;
EXPLAIN (costs off)   select * from ec1, ec2 where ff = x1 and '42'::int8 = x1;
EXPLAIN (costs off)   select * from ec1, ec2 where ff = x1 and x1 = '42'::int8alias1;
EXPLAIN (costs off)   select * from ec1, ec2 where ff = x1 and x1 = '42'::int8alias2;
CREATE UNIQUE INDEX x ON x((x + 1) NULLS LAST);
CREATE UNIQUE INDEX x ON x((x + 2 + 1) NULLS LAST);
CREATE UNIQUE INDEX x ON x((x + 3 + 1) NULLS LAST);
CREATE UNIQUE INDEX x ON x((x + 4) NULLS LAST);
EXPLAIN (costs off)   select * from ec1,     (select ff + 1 as x from        (select ff + 2 as ff from ec1         union all         select ff + 3 as ff from ec1) ss0      union all      select ff + 4 as x from ec1) as ss1   where ss1.x = ec1.f1 and ec1.ff = 42::int8;
EXPLAIN (costs off)   select * from ec1,     (select ff + 1 as x from        (select ff + 2 as ff from ec1         union all         select ff + 3 as ff from ec1) ss0      union all      select ff + 4 as x from ec1) as ss1   where ss1.x = ec1.f1 and ec1.ff = 42::int8 and ec1.ff = ec1.f1;
EXPLAIN (costs off)   select * from ec1,     (select ff + 1 as x from        (select ff + 2 as ff from ec1         union all         select ff + 3 as ff from ec1) ss0      union all      select ff + 4 as x from ec1) as ss1,     (select ff + 1 as x from        (select ff + 2 as ff from ec1         union all         select ff + 3 as ff from ec1) ss0      union all      select ff + 4 as x from ec1) as ss2   where ss1.x = ec1.f1 and ss1.x = ss2.x and ec1.ff = 42::int8;
SET x = on /* let's try that as a mergejoin */;
SET x = off;
EXPLAIN (costs off)   select * from ec1,     (select ff + 1 as x from        (select ff + 2 as ff from ec1         union all         select ff + 3 as ff from ec1) ss0      union all      select ff + 4 as x from ec1) as ss1,     (select ff + 1 as x from        (select ff + 2 as ff from ec1         union all         select ff + 3 as ff from ec1) ss0      union all      select ff + 4 as x from ec1) as ss2   where ss1.x = ec1.f1 and ss1.x = ss2.x and ec1.ff = 42::int8;
SET x = on /* check partially indexed scan */;
SET x = off;
DROP INDEX x;
EXPLAIN (costs off)   select * from ec1,     (select ff + 1 as x from        (select ff + 2 as ff from ec1         union all         select ff + 3 as ff from ec1) ss0      union all      select ff + 4 as x from ec1) as ss1   where ss1.x = ec1.f1 and ec1.ff = 42::int8;
SET x = on /* let's try that as a mergejoin */;
SET x = off;
EXPLAIN (costs off)   select * from ec1,     (select ff + 1 as x from        (select ff + 2 as ff from ec1         union all         select ff + 3 as ff from ec1) ss0      union all      select ff + 4 as x from ec1) as ss1   where ss1.x = ec1.f1 and ec1.ff = 42::int8;
SET x = on /* check effects of row-level security */;
SET x = off;
alter table ec1 enable row level security;
create policy p1 on ec1 using (f1 < '5'::int8alias1);
create user regress_user_ectest;
GRANT SELECT ON x TO x;
GRANT SELECT ON x TO x;
/* without any RLS, we'll treat {a.ff, b.ff, 43} as an EquivalenceClass */ EXPLAIN (costs off)   select * from ec0 a, ec1 b   where a.ff = b.ff and a.ff = 43::bigint::int8alias1;
set session authorization regress_user_ectest;
RESET session authorization;
REVOKE select on ec0 from regress_user_ectest;
REVOKE select on ec1 from regress_user_ectest;
drop user regress_user_ectest;
/* check that X=X is converted to X IS NOT NULL when appropriate */ EXPLAIN (costs off)   select * from tenk1 where unique1 = unique1 and unique2 = unique2;
SET x = off /* Test that broken ECs are processed correctly during self join removal. */ /* Disable merge joins so that we don't get an error about missing commutator. */ /* Test both orientations of the join clause, because only one of them breaks */ /* the EC. */;
EXPLAIN (costs off)   select * from ec0 m join ec0 n on m.ff = n.ff   join ec1 p on m.ff + n.ff = p.f1;
EXPLAIN (costs off)   select * from ec0 m join ec0 n on m.ff = n.ff   join ec1 p on p.f1::int8 = (m.ff + n.ff)::int8alias1;
RESET enable_mergejoin;
/* this could be converted, but isn't at present */ EXPLAIN (costs off)   select * from tenk1 where unique1 = unique1 or unique2 = unique2;
/* check that we recognize equivalence with dummy domains in the way */ CREATE TEMPORARY TABLE x (x NAME, x INT);
CREATE TEMPORARY VIEW x AS SELECT CAST(x AS information_schema.sql_identifier) AS x, x FROM x;
EXPLAIN (costs off)  -- this should not require a sort   select * from overview where sqli = 'foo' order by sqli;
CREATE TABLE x (x BIGINT, x int8alias1);
SET x = off /* check that non-commutable merge clauses do not lead to error */;
SET x = on;
EXPLAIN (costs off) select * from tbl_nocom t1 full join tbl_nocom t2 on t2.a = t1.b;
/* check that non-commutable hash clauses do not lead to error */ alter operator = (int8, int8alias1) set (hashes);
alter operator family integer_ops using hash add   operator 1 = (int8, int8alias1);
CREATE FUNCTION x(x) RETURNS INT STRICT IMMUTABLE LANGUAGE internal AS 'hashint8';
alter operator family integer_ops using hash add   function 1 hashint8alias1(int8alias1);
SET x = on;
SET x = off;
EXPLAIN (costs off) select * from tbl_nocom t1 full join tbl_nocom t2 on t2.a = t1.b;
x;
/* ERRORS */ /* bad in postquel, but ok in PostgreSQL */ SELECT 1;
/* UNSUPPORTED STUFF */ /* doesn't work */ /* notify pg_class */ /* SELECT */ /* this used to be a syntax error, but now we allow an empty target list */ SELECT;
/* no such relation */ SELECT * FROM x;
/* bad name in target list */ SELECT x FROM x;
/* empty distinct list isn't OK */ SELECT DISTINCT FROM x;
/* bad attribute name on lhs of operator */ SELECT * FROM x WHERE x = x.x;
/* bad attribute name on rhs of operator */ SELECT * FROM x WHERE x.x = x;
/* bad attribute name in select distinct on */ SELECT DISTINCT ON (x) * FROM x;
/* grouping with FOR UPDATE */ SELECT NULL FROM x GROUP BY x;
SELECT NULL FROM x GROUP BY GROUPING SETS (());
/* no such relation */ DELETE FROM x;
/* no such relation */ DROP TABLE x;
ALTER TABLE x RENAME TO x /* no such relation */;
ALTER TABLE x RENAME TO x /* no such relation */;
ALTER TABLE x RENAME TO x /* conflict */;
ALTER TABLE x RENAME TO x /* self-conflict */;
ALTER TABLE x RENAME COLUMN x TO x /* attribute renaming */ /* no such relation */;
ALTER TABLE x RENAME COLUMN x TO x /* no such attribute */;
ALTER TABLE x RENAME COLUMN x TO x /* conflict */;
ALTER TABLE x RENAME COLUMN x TO x /* conflict */;
x /* TRANSACTION STUFF */ /* not in a xact */;
COMMIT /* not in a xact */ /* not in a xact */;
/* CREATE AGGREGATE */ /* sfunc/finalfunc type disagreement */ create aggregate newavg2 (sfunc = int4pl, 			  basetype = int4, 			  stype = int4, 			  finalfunc = int2um, 			  initcond = '0');
/* left out basetype */ create aggregate newcnt1 (sfunc = int4inc, 			  stype = int4, 			  initcond = '0');
/* no such index */ DROP INDEX x;
/* DROP AGGREGATE */ /* missing aggregate name */ drop aggregate;
/* missing aggregate type */ drop aggregate newcnt1;
/* bad aggregate name */ drop aggregate 314159 (int);
/* bad aggregate type */ drop aggregate newcnt (nonesuch);
/* no such aggregate */ drop aggregate nonesuch (int4);
/* no such aggregate for type */ drop aggregate newcnt (float4);
/* no such function */ DROP FUNCTION x;
/* DROP TYPE */ /* missing type name */ drop type;
/* bad type name */ drop type 314159;
/* no such type */ drop type nonesuch;
/* DROP OPERATOR */ /* missing everything */ drop operator;
/* bad operator name */ drop operator equals;
/* missing type list */ drop operator ===;
/* missing parentheses */ drop operator int4, int4;
/* missing operator name */ drop operator (int4, int4);
/* missing type list contents */ drop operator === ();
/* no such operator */ drop operator === (int4);
/* no such operator by that name */ drop operator === (int4, int4);
/* no such type1 */ drop operator = (nonesuch);
/* no such type1 */ drop operator = ( , int4);
/* no such type1 */ drop operator = (nonesuch, int4);
/* no such type2 */ drop operator = (int4, nonesuch);
/* no such type2 */ drop operator = (int4, );
/* DROP RULE */ /* missing rule name */ drop rule;
/* bad rule name */ drop rule 314159;
/* no such rule */ drop rule nonesuch on noplace;
/* these postquel variants are no longer supported */ drop tuple rule nonesuch;
drop instance rule nonesuch on noplace;
drop rewrite rule nonesuch;
/* Check that division-by-zero is properly caught. */ SELECT 1 / 0;
SELECT CAST(1 AS BIGINT) / 0;
SELECT 1 / CAST(0 AS BIGINT);
SELECT CAST(1 AS SMALLINT) / 0;
SELECT 1 / CAST(0 AS SMALLINT);
SELECT CAST(1 AS DECIMAL) / 0;
SELECT 1 / CAST(0 AS DECIMAL);
SELECT CAST(1 AS DOUBLE) / 0;
SELECT 1 / CAST(0 AS DOUBLE);
SELECT CAST(1 AS FLOAT) / 0;
SELECT 1 / CAST(0 AS FLOAT);
x /* Test psql's reporting of syntax error location */;
CREATE foo;
/* should fail, return type mismatch */ create event trigger regress_event_trigger    on ddl_command_start    execute procedure pg_backend_pid();
/* should fail, can't call it as a plain function */ SELECT TEST_EVENT_TRIGGER();
/* should fail, SQL functions cannot be event triggers */ CREATE FUNCTION x() RETURNS event_trigger LANGUAGE sql AS $$ SELECT 1 $$;
/* should fail, no elephant_bootstrap entry point */ create event trigger regress_event_trigger on elephant_bootstrap    execute procedure test_event_trigger();
/* OK */ create event trigger regress_event_trigger on ddl_command_start    execute procedure test_event_trigger();
/* OK */ create event trigger regress_event_trigger_end on ddl_command_end    execute function test_event_trigger();
/* should fail, food is not a valid filter variable */ create event trigger regress_event_trigger2 on ddl_command_start    when food in ('sandwich')    execute procedure test_event_trigger();
/* should fail, sandwich is not a valid command tag */ create event trigger regress_event_trigger2 on ddl_command_start    when tag in ('sandwich')    execute procedure test_event_trigger();
/* should fail, create skunkcabbage is not a valid command tag */ create event trigger regress_event_trigger2 on ddl_command_start    when tag in ('create table', 'create skunkcabbage')    execute procedure test_event_trigger();
/* should fail, can't have event triggers on event triggers */ create event trigger regress_event_trigger2 on ddl_command_start    when tag in ('DROP EVENT TRIGGER')    execute procedure test_event_trigger();
/* should fail, can't have event triggers on global objects */ create event trigger regress_event_trigger2 on ddl_command_start    when tag in ('CREATE ROLE')    execute procedure test_event_trigger();
/* should fail, can't have event triggers on global objects */ create event trigger regress_event_trigger2 on ddl_command_start    when tag in ('CREATE DATABASE')    execute procedure test_event_trigger();
/* should fail, can't have event triggers on global objects */ create event trigger regress_event_trigger2 on ddl_command_start    when tag in ('CREATE TABLESPACE')    execute procedure test_event_trigger();
/* should fail, can't have same filter variable twice */ create event trigger regress_event_trigger2 on ddl_command_start    when tag in ('create table') and tag in ('CREATE FUNCTION')    execute procedure test_event_trigger();
/* should fail, can't have arguments */ create event trigger regress_event_trigger2 on ddl_command_start    execute procedure test_event_trigger('argument not allowed');
/* OK */ create event trigger regress_event_trigger2 on ddl_command_start    when tag in ('create table', 'CREATE FUNCTION')    execute procedure test_event_trigger();
/* OK */ comment on event trigger regress_event_trigger is 'test comment';
/* drop as non-superuser should fail */ create role regress_evt_user;
set role regress_evt_user;
create event trigger regress_event_trigger_noperms on ddl_command_start    execute procedure test_event_trigger();
RESET role;
/* test enabling and disabling */ alter event trigger regress_event_trigger disable;
/* fires _trigger2 and _trigger_end should fire, but not _trigger */ CREATE TABLE x (x INT);
alter event trigger regress_event_trigger enable;
SET x = replica;
/* fires nothing */ CREATE TABLE x (x INT);
alter event trigger regress_event_trigger enable replica;
/* fires only _trigger */ CREATE TABLE x (x INT);
alter event trigger regress_event_trigger enable always;
/* fires only _trigger */ CREATE TABLE x (x INT);
RESET session_replication_role;
/* fires all three */ CREATE TABLE x (x INT);
SELECT F1();
CALL p1();
/* clean up */ alter event trigger regress_event_trigger disable;
drop routine f1(), p1();
GRANT ALL ON TABLE x TO x /* regress_event_trigger_end should fire on these commands */;
COMMENT ON table x IS 'here is a comment';
REVOKE all on table event_trigger_fire1 from public;
DROP TABLE x;
create foreign data wrapper useless;
create server useless_server foreign data wrapper useless;
create user mapping for regress_evt_user server useless_server;
alter default privileges for role regress_evt_user  revoke delete on tables from regress_evt_user;
/* alter owner to non-superuser should fail */ alter event trigger regress_event_trigger owner to regress_evt_user;
/* alter owner to superuser should work */ alter role regress_evt_user superuser;
alter event trigger regress_event_trigger owner to regress_evt_user;
/* should fail, name collision */ alter event trigger regress_event_trigger rename to regress_event_trigger2;
/* OK */ alter event trigger regress_event_trigger rename to regress_event_trigger3;
/* should fail, doesn't exist any more */ drop event trigger regress_event_trigger;
/* should fail, regress_evt_user owns some objects */ drop role regress_evt_user;
drop event trigger if exists regress_event_trigger2;
drop event trigger regress_event_trigger3;
drop event trigger regress_event_trigger_end;
/* test support for dropped objects */ CREATE SCHEMA schema_one authorization regress_evt_user;
CREATE SCHEMA schema_two authorization regress_evt_user;
CREATE SCHEMA audit_tbls authorization regress_evt_user;
CREATE TEMPORARY TABLE x;
SET SESSION AUTHORIZATION regress_evt_user;
CREATE TABLE x.x (x INT);
CREATE TABLE x.x (x INT);
CREATE TABLE x.x (x INT);
CREATE TABLE x.x (x TEXT);
CREATE TABLE x.x (x INT);
CREATE TABLE x.x (x INT, x TEXT);
CREATE TABLE x.x (x TEXT);
COMMIT;
CREATE AGGREGATE schema_two.newton   (BASETYPE = int, SFUNC = schema_two.add, STYPE = int);
RESET SESSION AUTHORIZATION;
CREATE TABLE x (x TEXT, x TEXT);
INSERT INTO x VALUES ('table', 'schema_one.table_three'), ('table', 'audit_tbls.schema_two_table_three');
CREATE TABLE x (x TEXT, x TEXT, x TEXT);
BEGIN PERFORM 1 FROM pg_tables WHERE tablename = 'undroppable_objs';
IF NOT FOUND THEN 		RAISE NOTICE 'table undroppable_objs not found, skipping';
x;
COMMIT;
CREATE EVENT TRIGGER undroppable ON sql_drop 	EXECUTE PROCEDURE undroppable();
BEGIN FOR obj IN SELECT * FROM pg_event_trigger_dropped_objects()     LOOP         IF obj.object_type = 'table' THEN                 EXECUTE format('DROP TABLE IF EXISTS audit_tbls.%I', 					format('%s_%s', obj.schema_name, obj.object_name));
INSERT INTO x (x, x, x) VALUES (x.x, x.x, x.x);
CREATE EVENT TRIGGER regress_event_trigger_drop_objects ON sql_drop 	WHEN TAG IN ('drop table', 'drop function', 'drop view', 		'drop owned', 'drop schema', 'alter table') 	EXECUTE PROCEDURE test_evtrig_dropped_objects();
ALTER TABLE x.x DROP COLUMN x;
DELETE FROM x WHERE x = 'audit_tbls.schema_two_table_three';
DELETE FROM x WHERE x = 'schema_one.table_three';
SELECT * FROM x WHERE x IS NULL OR x <> 'pg_toast';
DROP OWNED BY regress_evt_user;
SELECT * FROM x WHERE x = 'schema';
DROP ROLE regress_evt_user;
DROP EVENT TRIGGER regress_event_trigger_drop_objects;
DROP EVENT TRIGGER undroppable;
BEGIN FOR r IN SELECT * from pg_event_trigger_dropped_objects()     LOOP     IF NOT r.normal AND NOT r.original THEN         CONTINUE;
COMMIT;
CREATE EVENT TRIGGER regress_event_trigger_report_dropped ON sql_drop     EXECUTE PROCEDURE event_trigger_report_dropped();
BEGIN FOR r IN SELECT * FROM pg_event_trigger_ddl_commands()     LOOP         RAISE NOTICE 'END: command_tag=% type=% identity=%',             r.command_tag, r.object_type, r.object_identity;
COMMIT;
CREATE EVENT TRIGGER regress_event_trigger_report_end ON ddl_command_end   EXECUTE PROCEDURE event_trigger_report_end();
CREATE SCHEMA evttrig 	CREATE TABLE one (col_a SERIAL PRIMARY KEY, col_b text DEFAULT 'forty two', col_c SERIAL) 	CREATE INDEX one_idx ON one (col_b) 	CREATE TABLE two (col_c INTEGER CHECK (col_c > 0) REFERENCES one DEFAULT 42) 	CREATE TABLE id (col_d int NOT NULL GENERATED ALWAYS AS IDENTITY);
/* Partitioned tables with a partitioned index */ CREATE TABLE x.x (x INT PRIMARY KEY) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x.x PARTITION OF x.x (x) FOR VALUES FROM (1) TO (10);
CREATE TABLE x.x PARTITION OF x.x (x) FOR VALUES FROM (10) TO (20) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x.x PARTITION OF x.x (x) FOR VALUES FROM (10) TO (15);
CREATE TABLE x.x PARTITION OF x.x (x) FOR VALUES FROM (15) TO (20);
ALTER TABLE x.x DROP COLUMN x;
ALTER TABLE x.x ALTER COLUMN x DROP DEFAULT;
ALTER TABLE x.x DROP CONSTRAINT x;
ALTER TABLE x.x DROP COLUMN x;
ALTER TABLE x.x ALTER COLUMN x SET DATA TYPE BIGINT;
ALTER TABLE evttrig.id ALTER COLUMN col_d DROP IDENTITY,   ALTER COLUMN col_d SET DATA TYPE int;
DROP INDEX x.x;
DROP SCHEMA x.x CASCADE;
DROP TABLE x;
/* CREATE OPERATOR CLASS without FAMILY clause should report */ /* both CREATE OPERATOR FAMILY and CREATE OPERATOR CLASS */ CREATE OPERATOR CLASS evttrigopclass FOR TYPE int USING btree AS STORAGE int;
DROP EVENT TRIGGER regress_event_trigger_report_dropped;
DROP EVENT TRIGGER regress_event_trigger_report_end;
/* only allowed from within an event trigger function, should fail */ SELECT PG_EVENT_TRIGGER_TABLE_REWRITE_OID();
COMMIT;
create event trigger no_rewrite_allowed on table_rewrite   execute procedure test_evtrig_no_rewrite();
CREATE TABLE x (x SERIAL PRIMARY KEY, x DOUBLE, x TIMESTAMPTZ);
INSERT INTO x SELECT x * 1.001 FROM x AS x;
ALTER TABLE x ALTER COLUMN x SET DATA TYPE DECIMAL;
ALTER TABLE x ADD COLUMN x INT DEFAULT 0;
COMMIT;
alter table rewriteme  add column onemore int default 0,  add column another int default -1,  alter column foo type numeric(10,4);
/* matview rewrite when changing access method */ CREATE MATERIALIZED VIEW x WITH (FORMAT=heap) AS SELECT 1 AS x;
ALTER MATERIALIZED VIEW heapmv SET ACCESS METHOD heap2;
DROP MATERIALIZED VIEW x;
ALTER TABLE x ALTER COLUMN x SET DATA TYPE DECIMAL(12, 4) /* shouldn't trigger a table_rewrite event */;
BEGIN;
SET x = 'UTC';
ALTER TABLE x ALTER COLUMN x SET DATA TYPE TIMESTAMP;
SET x = '0';
ALTER TABLE x ALTER COLUMN x SET DATA TYPE TIMESTAMPTZ;
SET x = 'Europe/London';
ALTER TABLE x ALTER COLUMN x SET DATA TYPE TIMESTAMP;
ROLLBACK /* does rewrite */ /* does rewrite */;
COMMIT;
create type rewritetype as (a int);
create table rewritemetoo1 of rewritetype;
create table rewritemetoo2 of rewritetype;
alter type rewritetype alter attribute a type text cascade;
/* but this doesn't work */ CREATE TABLE x (x rewritetype);
alter type rewritetype alter attribute a type varchar cascade;
DROP TABLE x;
drop event trigger no_rewrite_allowed;
DROP FUNCTION x;
COMMIT;
CREATE EVENT TRIGGER regress_reindex_start ON ddl_command_start     WHEN TAG IN ('REINDEX')     EXECUTE PROCEDURE reindex_start_command();
BEGIN FOR obj IN SELECT * FROM pg_event_trigger_ddl_commands()     LOOP         RAISE NOTICE 'REINDEX END: command_tag=% type=% identity=%', 	    obj.command_tag, obj.object_type, obj.object_identity;
COMMIT;
CREATE EVENT TRIGGER regress_reindex_end ON ddl_command_end     WHEN TAG IN ('REINDEX')     EXECUTE PROCEDURE reindex_end_command();
CREATE EVENT TRIGGER regress_reindex_end_snap ON ddl_command_end     EXECUTE FUNCTION reindex_end_command_snap();
/* With simple relation */ CREATE TABLE x (x INT);
CREATE INDEX x ON x(x NULLS LAST);
/* Both start and end triggers enabled. */ REINDEX INDEX concur_reindex_ind;
REINDEX TABLE concur_reindex_tab;
REINDEX INDEX CONCURRENTLY concur_reindex_ind;
REINDEX TABLE CONCURRENTLY concur_reindex_tab;
/* with start trigger disabled. */ ALTER EVENT TRIGGER regress_reindex_start DISABLE;
REINDEX INDEX concur_reindex_ind;
REINDEX INDEX CONCURRENTLY concur_reindex_ind;
/* without an index */ DROP INDEX x;
REINDEX TABLE concur_reindex_tab;
REINDEX TABLE CONCURRENTLY concur_reindex_tab;
/* With a Schema */ CREATE SCHEMA x.x;
/* No indexes */ REINDEX SCHEMA concur_reindex_schema;
REINDEX SCHEMA CONCURRENTLY concur_reindex_schema;
CREATE TABLE x.x (x INT);
CREATE INDEX x ON x.x(x NULLS LAST);
/* One index reported */ REINDEX SCHEMA concur_reindex_schema;
REINDEX SCHEMA CONCURRENTLY concur_reindex_schema;
/* One table on schema but no indexes */ DROP INDEX x.x;
REINDEX SCHEMA concur_reindex_schema;
REINDEX SCHEMA CONCURRENTLY concur_reindex_schema;
DROP SCHEMA x.x CASCADE;
/* With a partitioned table, and nothing else. */ CREATE TABLE x (x INT) WITH (PARTITIONED_BY=RANGE(x));
REINDEX TABLE concur_reindex_part;
REINDEX TABLE CONCURRENTLY concur_reindex_part;
/* Partition that would be reindexed, still nothing. */ CREATE TABLE x PARTITION OF x FOR VALUES FROM (0) TO (10);
REINDEX TABLE concur_reindex_part;
REINDEX TABLE CONCURRENTLY concur_reindex_part;
/* Now add some indexes. */ CREATE INDEX x ON x(x NULLS LAST);
REINDEX INDEX concur_reindex_partidx;
REINDEX INDEX CONCURRENTLY concur_reindex_partidx;
REINDEX TABLE concur_reindex_part;
REINDEX TABLE CONCURRENTLY concur_reindex_part;
DROP TABLE x;
/* Clean up */ DROP EVENT TRIGGER regress_reindex_start;
DROP EVENT TRIGGER regress_reindex_end;
DROP EVENT TRIGGER regress_reindex_end_snap;
DROP FUNCTION x;
DROP FUNCTION x;
DROP FUNCTION x;
DROP TABLE x;
/* test Row Security Event Trigger */ RESET SESSION AUTHORIZATION;
CREATE TABLE x (x INT, x TEXT);
COMMIT;
COMMIT;
COMMIT;
CREATE EVENT TRIGGER start_rls_command ON ddl_command_start     WHEN TAG IN ('CREATE POLICY', 'ALTER POLICY', 'DROP POLICY') EXECUTE PROCEDURE start_command();
CREATE EVENT TRIGGER end_rls_command ON ddl_command_end     WHEN TAG IN ('CREATE POLICY', 'ALTER POLICY', 'DROP POLICY') EXECUTE PROCEDURE end_command();
CREATE EVENT TRIGGER sql_drop_command ON sql_drop     WHEN TAG IN ('DROP POLICY') EXECUTE PROCEDURE drop_sql_command();
CREATE POLICY p1 ON event_trigger_test USING (FALSE);
ALTER POLICY p1 ON event_trigger_test USING (TRUE);
ALTER POLICY p1 ON event_trigger_test RENAME TO p2;
DROP POLICY p2 ON event_trigger_test;
/* Check the object addresses of all the event triggers. */ SELECT x.x, PG_DESCRIBE_OBJECT(CAST('pg_event_trigger' AS REGCLASS), x.x, 0) AS x, x.x, x.x, x.x, PG_IDENTIFY_OBJECT(x.x, x.x, x.x) AS x FROM x AS x, LATERAL PG_IDENTIFY_OBJECT_AS_ADDRESS(CAST('pg_event_trigger' AS REGCLASS), x.x, 0) AS x, LATERAL PG_GET_OBJECT_ADDRESS(x.x, x.x, x.x) AS x ORDER BY x.x NULLS LAST;
DROP EVENT TRIGGER start_rls_command;
DROP EVENT TRIGGER end_rls_command;
DROP EVENT TRIGGER sql_drop_command;
BEGIN FOR obj IN SELECT * FROM pg_event_trigger_dropped_objects() 	LOOP 		RAISE NOTICE '% dropped %', tg_tag, obj.object_type;
COMMIT;
CREATE EVENT TRIGGER test_event_trigger_guc 	ON sql_drop 	WHEN TAG IN ('DROP POLICY') EXECUTE FUNCTION test_event_trigger_guc();
SET x = 'on';
CREATE POLICY pguc ON event_trigger_test USING (FALSE);
DROP POLICY pguc ON event_trigger_test;
CREATE POLICY pguc ON event_trigger_test USING (FALSE);
SET x = 'off';
DROP POLICY pguc ON event_trigger_test;
/* Login event triggers */ CREATE TABLE x (x SERIAL, x TEXT);
GRANT SELECT ON x TO x;
COMMIT;
CREATE EVENT TRIGGER on_login_trigger ON login EXECUTE PROCEDURE on_login_proc();
ALTER EVENT TRIGGER on_login_trigger ENABLE ALWAYS;
/* Cleanup */ DROP TABLE x;
DROP EVENT TRIGGER on_login_trigger;
DROP FUNCTION x;
BEGIN for ln in execute $1     loop         -- Replace any numeric word with just 'N'         ln := regexp_replace(ln, '-?\m\d+\M', 'N', 'g');
x := REGEXP_REPLACE(x, '\m\d+kB', 'NkB', 'g');
COMMIT;
x AS x;
BEGIN for ln in execute $1     loop         -- Replace any numeric word with just '0'         ln := regexp_replace(ln, '\m\d+\M', '0', 'g');
x := x || x;
COMMIT;
SET x = off /* Disable JIT, or we'll get different output on machines where that's been */ /* forced on */;
SET x = off /* Similarly, disable track_io_timing, to avoid output differences when */ /* enabled. */;
/* Simple cases */ SELECT EXPLAIN_FILTER('explain select * from int8_tbl i8');
SELECT EXPLAIN_FILTER('explain (analyze, buffers off) select * from int8_tbl i8');
SELECT EXPLAIN_FILTER('explain (analyze, buffers off, verbose) select * from int8_tbl i8');
SELECT EXPLAIN_FILTER('explain (analyze, buffers, format text) select * from int8_tbl i8');
SELECT EXPLAIN_FILTER('explain (analyze, buffers, format xml) select * from int8_tbl i8');
SELECT EXPLAIN_FILTER('explain (analyze, serialize, buffers, format yaml) select * from int8_tbl i8');
SELECT EXPLAIN_FILTER('explain (buffers, format text) select * from int8_tbl i8');
SELECT EXPLAIN_FILTER('explain (buffers, format json) select * from int8_tbl i8');
/* Check expansion of window definitions */ SELECT EXPLAIN_FILTER('explain verbose select sum(unique1) over w, sum(unique2) over (w order by hundred), sum(tenthous) over (w order by hundred) from tenk1 window w as (partition by ten)');
SELECT EXPLAIN_FILTER('explain verbose select sum(unique1) over w1, sum(unique2) over (w1 order by hundred), sum(tenthous) over (w1 order by hundred rows 10 preceding) from tenk1 window w1 as (partition by ten)');
SET x = on /* Check output including I/O timings.  These fields are conditional */ /* but always set in JSON format, so check them only in this case. */;
SELECT EXPLAIN_FILTER('explain (analyze, buffers, format json) select * from int8_tbl i8');
SET x = off;
/* SETTINGS option */ /* We have to ignore other settings that might be imposed by the environment, */ /* so printing the whole Settings field unfortunately won't do. */ BEGIN;
SET LOCAL x = force_generic_plan;
SELECT TRUE AS "x" FROM x AS x WHERE REGEXP_LIKE(x, '^ *Settings: .*plan_cache_mode = ''force_generic_plan''');
SELECT JSONB_EXTRACT(EXPLAIN_FILTER_TO_JSON('explain (settings, format json) select * from int8_tbl i8'), '{0,Settings,plan_cache_mode}');
ROLLBACK;
/* GENERIC_PLAN option */ SELECT EXPLAIN_FILTER('explain (generic_plan) select unique1 from tenk1 where thousand = $1');
/* should fail */ SELECT EXPLAIN_FILTER('explain (analyze, generic_plan) select unique1 from tenk1 where thousand = $1');
/* MEMORY option */ SELECT EXPLAIN_FILTER('explain (memory) select * from int8_tbl i8');
SELECT EXPLAIN_FILTER('explain (memory, analyze, buffers off) select * from int8_tbl i8');
SELECT EXPLAIN_FILTER('explain (memory, summary, format yaml) select * from int8_tbl i8');
SELECT EXPLAIN_FILTER('explain (memory, analyze, format json) select * from int8_tbl i8');
PREPARE int8_query as select * from int8_tbl i8;
SELECT EXPLAIN_FILTER('explain (memory) execute int8_query');
/* Test EXPLAIN (GENERIC_PLAN) with partition pruning */ /* partitions should be pruned at plan time, based on constants, */ /* but there should be no pruning based on parameter placeholders */ CREATE TABLE x (x INT NOT NULL, x INT NOT NULL) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN (1) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (1) TO (2);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (2) TO (3);
CREATE TABLE x PARTITION OF x FOR VALUES IN (2);
/* should scan gen_part_1_1 and gen_part_1_2, but not gen_part_2 */ SELECT EXPLAIN_FILTER('explain (generic_plan) select key1, key2 from gen_part where key1 = 1 and key2 = $1');
DROP TABLE x;
/* Test production of per-worker data */ /* Unfortunately, because we don't know how many worker processes we'll */ /* actually get (maybe none at all), we can't examine the "Workers" output */ /* in any detail.  We can check that it parses correctly as JSON, and then */ /* remove it from the displayed results. */ BEGIN;
SET x = 0 /* encourage use of parallel plans */;
SET x = 0;
SET x = 0;
SET x = 4;
SELECT JSONB_PRETTY(EXPLAIN_FILTER_TO_JSON('explain (analyze, verbose, buffers, format json)                          select * from tenk1 order by tenthous') ^ -'{0,Plan,Plans,0,Plans,0,Workers}' ^ -'{0,Plan,Plans,0,Workers}' ^ -'{0,Plan,Plans,0,Sort Method}' ^ -'{0,Plan,Plans,0,Sort Space Type}');
ROLLBACK;
/* Test display of temporary objects */ CREATE TEMPORARY TABLE x (x DOUBLE);
SELECT EXPLAIN_FILTER('explain (verbose) select * from t1 where pg_temp.mysin(f1) < 0.5');
SET x = on /* Test compute_query_id */;
SELECT EXPLAIN_FILTER('explain (verbose) select * from int8_tbl i8');
/* Test compute_query_id with utility statements containing plannable query */ SELECT EXPLAIN_FILTER('explain (verbose) declare test_cur cursor for select * from int8_tbl');
SELECT EXPLAIN_FILTER('explain (verbose) create table test_ctas as select 1');
/* Test SERIALIZE option */ SELECT EXPLAIN_FILTER('explain (analyze,buffers off,serialize) select * from int8_tbl i8');
SELECT EXPLAIN_FILTER('explain (analyze,serialize text,buffers,timing off) select * from int8_tbl i8');
SELECT EXPLAIN_FILTER('explain (analyze,serialize binary,buffers,timing) select * from int8_tbl i8');
/* this tests an edge case where we have no data to return */ SELECT EXPLAIN_FILTER('explain (analyze,buffers off,serialize) create temp table explain_temp as select * from int8_tbl i8');
/* Test tuplestore storage usage in Window aggregate (memory case) */ SELECT EXPLAIN_FILTER('explain (analyze,buffers off,costs off) select sum(n) over() from generate_series(1,10) a(n)');
SET x = 64 /* Test tuplestore storage usage in Window aggregate (disk case) */;
SELECT EXPLAIN_FILTER('explain (analyze,buffers off,costs off) select sum(n) over() from generate_series(1,2000) a(n)');
/* Test tuplestore storage usage in Window aggregate (memory and disk case, final result is disk) */ SELECT EXPLAIN_FILTER('explain (analyze,buffers off,costs off) select sum(n) over(partition by m) from (SELECT n < 3 as m, n from generate_series(1,2000) a(n))');
RESET work_mem;
/* expression evaluation tests that don't fit into a more specific file */ /* Tests for SQLValueFunction */ /* current_date  (always matches because of transactional behaviour) */ SELECT CAST(DATE(CURRENT_TIMESTAMP()) AS TEXT) = CAST(CURRENT_DATE AS TEXT);
/* current_time / localtime */ SELECT CAST(CAST(CURRENT_TIMESTAMP() AS TIMETZ) AS TEXT) = CAST(CURRENT_TIME() AS TEXT);
SELECT CAST(CAST(CURRENT_TIMESTAMP() AS TIMETZ(4)) AS TEXT) = CAST(CURRENT_TIME(4) AS TEXT);
SELECT CAST(CAST(CURRENT_TIMESTAMP() AS TIME) AS TEXT) = CAST(x AS TEXT);
SELECT CAST(CAST(CURRENT_TIMESTAMP() AS TIME(3)) AS TEXT) = CAST(LOCALTIME(3) AS TEXT);
/* current_time[stamp]/ localtime[stamp] (always matches because of transactional behaviour) */ SELECT CURRENT_TIMESTAMP() = CURRENT_TIMESTAMP();
/* precision */ SELECT LENGTH(CAST(CURRENT_TIMESTAMP() AS TEXT)) >= LENGTH(CAST(CURRENT_TIMESTAMP(0) AS TEXT));
/* localtimestamp */ SELECT CAST(CAST(CURRENT_TIMESTAMP() AS TIMESTAMP) AS TEXT) = CAST(x AS TEXT);
/* precision overflow */ SELECT CURRENT_TIME() = CURRENT_TIME(7);
SELECT CURRENT_TIMESTAMP() = CURRENT_TIMESTAMP(7);
SELECT x = LOCALTIME(7);
SELECT x = LOCALTIMESTAMP(7);
/* current_role/user/user is tested in rolenames.sql */ /* current database / catalog */ SELECT x = CURRENT_DATABASE();
/* current_schema */ SELECT CURRENT_SCHEMA();
SET x = 'notme';
SELECT CURRENT_SCHEMA();
SET x = 'pg_catalog';
SELECT CURRENT_SCHEMA();
RESET search_path;
/* Test parsing of a no-op cast to a type with unspecified typmod */ BEGIN;
CREATE TABLE x (x DECIMAL(18, 3), x DECIMAL);
CREATE VIEW x AS SELECT x, CAST(x AS DECIMAL(16, 4)) AS x, CAST(x AS DECIMAL) AS x, x, CAST(x AS DECIMAL(16, 4)) AS x, CAST(x AS DECIMAL) AS x FROM x;
/* bpchar, lacking planner support for its length coercion function, */ /* could behave differently */ CREATE TABLE x (x CHAR(16) UNIQUE, x BPCHAR);
CREATE VIEW x AS SELECT x, CAST(x AS CHAR(14)) AS x, CAST(x AS BPCHAR) AS x, x, CAST(x AS CHAR(14)) AS x, CAST(x AS BPCHAR) AS x FROM x;
ROLLBACK;
/* Ordinarily, IN/NOT IN can be converted to a ScalarArrayOpExpr */ /* with a suitably-chosen array type. */ EXPLAIN (verbose, costs off) select random() IN (1, 4, 8.0);
EXPLAIN (verbose, costs off) select random()::int IN (1, 4, 8.0);
/* However, if there's not a common supertype for the IN elements, */ /* we should instead try to produce "x = v1 OR x = v2 OR ...". */ /* In most cases that'll fail for lack of all the requisite = operators, */ /* but it can succeed sometimes.  So this should complain about lack of */ /* an = operator, not about cast failure. */ SELECT CAST('(0,0)' AS point) IN (CAST('(0,0,0,0)' AS box), POINT(0, 0));
/* Tests for ScalarArrayOpExpr with a hashfn */ /* create a stable function so that the tests below are not */ /* evaluated using the planner's constant folding. */ BEGIN;
COMMIT;
COMMIT;
SELECT RETURN_INT_INPUT(1) IN (10, 9, 2, 8, 3, 7, 4, 6, 5, 1);
SELECT RETURN_INT_INPUT(1) IN (10, 9, 2, 8, 3, 7, 4, 6, 5, NULL);
SELECT RETURN_INT_INPUT(1) IN (NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
SELECT RETURN_INT_INPUT(1) IN (10, 9, 2, 8, 3, 7, 4, 6, 5, 1, NULL);
SELECT RETURN_INT_INPUT(CAST(NULL AS INT)) IN (10, 9, 2, 8, 3, 7, 4, 6, 5, 1);
SELECT RETURN_INT_INPUT(CAST(NULL AS INT)) IN (10, 9, 2, 8, 3, 7, 4, 6, 5, NULL);
SELECT RETURN_TEXT_INPUT('a') IN ('a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j');
/* NOT IN */ SELECT NOT RETURN_INT_INPUT(1) IN (10, 9, 2, 8, 3, 7, 4, 6, 5, 1);
SELECT NOT RETURN_INT_INPUT(1) IN (10, 9, 2, 8, 3, 7, 4, 6, 5, 0);
SELECT NOT RETURN_INT_INPUT(1) IN (10, 9, 2, 8, 3, 7, 4, 6, 5, 2, NULL);
SELECT NOT RETURN_INT_INPUT(1) IN (10, 9, 2, 8, 3, 7, 4, 6, 5, 1, NULL);
SELECT NOT RETURN_INT_INPUT(1) IN (NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
SELECT NOT RETURN_INT_INPUT(CAST(NULL AS INT)) IN (10, 9, 2, 8, 3, 7, 4, 6, 5, 1);
SELECT NOT RETURN_INT_INPUT(CAST(NULL AS INT)) IN (10, 9, 2, 8, 3, 7, 4, 6, 5, NULL);
SELECT NOT RETURN_TEXT_INPUT('a') IN ('a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j');
ROLLBACK;
/* Test with non-strict equality function. */ /* We need to create our own type for this. */ BEGIN;
create type myint;
CREATE FUNCTION x(x) RETURNS myint STRICT IMMUTABLE LANGUAGE internal AS 'int4in';
CREATE FUNCTION x(x) RETURNS CSTRING STRICT IMMUTABLE LANGUAGE internal AS 'int4out';
CREATE FUNCTION x(x) RETURNS INT STRICT IMMUTABLE LANGUAGE internal AS 'hashint4';
create type myint (input = myintin, output = myintout, like = int4);
create cast (int4 as myint) without function;
create cast (myint as int4) without function;
COMMIT;
COMMIT;
create operator <> (   leftarg    = myint,   rightarg   = myint,   commutator = <>,   negator    = =,   procedure  = myintne,   restrict   = eqsel,   join       = eqjoinsel,   merges );
create operator class myint_ops default for type myint using hash as   operator    1   =  (myint, myint),   function    1   myinthash(myint);
CREATE TABLE x (x myint);
INSERT INTO x VALUES (CAST(1 AS myint)), (NULL);
/* try an array with enough elements to cause hashing */ SELECT * FROM x WHERE x IN (CAST(1 AS myint), CAST(2 AS myint), CAST(3 AS myint), CAST(4 AS myint), CAST(5 AS myint), CAST(6 AS myint), CAST(7 AS myint), CAST(8 AS myint), CAST(9 AS myint), NULL);
SELECT * FROM x WHERE NOT x IN (CAST(1 AS myint), CAST(2 AS myint), CAST(3 AS myint), CAST(4 AS myint), CAST(5 AS myint), CAST(6 AS myint), CAST(7 AS myint), CAST(8 AS myint), CAST(9 AS myint), NULL);
SELECT * FROM x WHERE NOT x IN (CAST(0 AS myint), CAST(2 AS myint), CAST(3 AS myint), CAST(4 AS myint), CAST(5 AS myint), CAST(6 AS myint), CAST(7 AS myint), CAST(8 AS myint), CAST(9 AS myint), NULL);
/* ensure the result matched with the non-hashed version.  We simply remove */ /* some array elements so that we don't reach the hashing threshold. */ SELECT * FROM x WHERE x IN (CAST(1 AS myint), CAST(2 AS myint), CAST(3 AS myint), CAST(4 AS myint), CAST(5 AS myint), NULL);
SELECT * FROM x WHERE NOT x IN (CAST(1 AS myint), CAST(2 AS myint), CAST(3 AS myint), CAST(4 AS myint), CAST(5 AS myint), NULL);
SELECT * FROM x WHERE NOT x IN (CAST(0 AS myint), CAST(2 AS myint), CAST(3 AS myint), CAST(4 AS myint), CAST(5 AS myint), NULL);
ROLLBACK;
SET x = fast_default /* ALTER TABLE ADD COLUMN DEFAULT test */;
CREATE SCHEMA x.x;
CREATE TABLE x (x OID);
INSERT INTO x VALUES (CAST(NULL AS OID));
COMMIT;
COMMIT;
BEGIN select into this_schema relnamespace::regnamespace::text     from pg_class     where oid = pg_event_trigger_table_rewrite_oid();
if this_schema = 'fast_default'     then         RAISE NOTICE 'rewriting table % for reason %',           pg_event_trigger_table_rewrite_oid()::regclass,           pg_event_trigger_table_rewrite_reason();
COMMIT;
@unc$;
CREATE TABLE x AS SELECT * FROM x AS x;
CREATE EVENT TRIGGER has_volatile_rewrite                   ON table_rewrite    EXECUTE PROCEDURE log_rewrite();
ALTER TABLE x ADD COLUMN x INT /* only the last of these should trigger a rewrite */;
ALTER TABLE x ADD COLUMN x INT DEFAULT 1;
ALTER TABLE x ADD COLUMN x TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP();
ALTER TABLE x ADD COLUMN x INT DEFAULT CAST((RAND() * 10000) AS INT);
/* virtual generated columns don't need a rewrite */ ALTER TABLE has_volatile ADD col5 int GENERATED ALWAYS AS (tableoid::int + col2) VIRTUAL;
ALTER TABLE x ALTER COLUMN x SET DATA TYPE DOUBLE;
ALTER TABLE x ALTER COLUMN x SET DATA TYPE DECIMAL;
ALTER TABLE x ALTER COLUMN x SET DATA TYPE DECIMAL;
/* here, we do need a rewrite */ ALTER TABLE has_volatile ALTER COLUMN col1 SET DATA TYPE float8,   ADD COLUMN col6 float8 GENERATED ALWAYS AS (col1 * 4) VIRTUAL;
ALTER TABLE x ADD COLUMN x INT AS 55 /* stored generated columns need a rewrite */;
/* Test a large sample of different datatypes */ CREATE TABLE x (x INT NOT NULL PRIMARY KEY, x INT DEFAULT 1);
INSERT INTO x VALUES (1), (2);
ALTER TABLE T ADD COLUMN c_bpchar BPCHAR(5) DEFAULT 'hello',               ALTER COLUMN c_int SET DEFAULT 2;
INSERT INTO x VALUES (3), (4);
ALTER TABLE T ADD COLUMN c_text TEXT  DEFAULT 'world',               ALTER COLUMN c_bpchar SET DEFAULT 'dog';
INSERT INTO x VALUES (5), (6);
ALTER TABLE T ADD COLUMN c_date DATE DEFAULT '2016-06-02',               ALTER COLUMN c_text SET DEFAULT 'cat';
INSERT INTO x VALUES (7), (8);
ALTER TABLE T ADD COLUMN c_timestamp TIMESTAMP DEFAULT '2016-09-01 12:00:00',               ADD COLUMN c_timestamp_null TIMESTAMP,               ALTER COLUMN c_date SET DEFAULT '2010-01-01';
INSERT INTO x VALUES (9), (10);
ALTER TABLE T ADD COLUMN c_array TEXT[]                   DEFAULT '{"This", "is", "the", "real", "world"}',               ALTER COLUMN c_timestamp SET DEFAULT '1970-12-31 11:12:13',               ALTER COLUMN c_timestamp_null SET DEFAULT '2016-09-29 12:00:00';
INSERT INTO x VALUES (11), (12);
ALTER TABLE T ADD COLUMN c_small SMALLINT DEFAULT -5,               ADD COLUMN c_small_null SMALLINT,               ALTER COLUMN c_array                   SET DEFAULT '{"This", "is", "no", "fantasy"}';
INSERT INTO x VALUES (13), (14);
ALTER TABLE T ADD COLUMN c_big BIGINT DEFAULT 180000000000018,               ALTER COLUMN c_small SET DEFAULT 9,               ALTER COLUMN c_small_null SET DEFAULT 13;
INSERT INTO x VALUES (15), (16);
ALTER TABLE T ADD COLUMN c_num NUMERIC DEFAULT 1.00000000001,               ALTER COLUMN c_big SET DEFAULT -9999999999999999;
INSERT INTO x VALUES (17), (18);
ALTER TABLE T ADD COLUMN c_time TIME DEFAULT '12:00:00',               ALTER COLUMN c_num SET DEFAULT 2.000000000000002;
INSERT INTO x VALUES (19), (20);
ALTER TABLE T ADD COLUMN c_interval INTERVAL DEFAULT '1 day',               ALTER COLUMN c_time SET DEFAULT '23:59:59';
INSERT INTO x VALUES (21), (22);
ALTER TABLE T ADD COLUMN c_hugetext TEXT DEFAULT repeat('abcdefg',1000),               ALTER COLUMN c_interval SET DEFAULT '3 hours';
INSERT INTO x VALUES (23), (24);
ALTER TABLE T ALTER COLUMN c_interval DROP DEFAULT,               ALTER COLUMN c_hugetext SET DEFAULT repeat('poiuyt', 1000);
INSERT INTO x VALUES (25), (26);
ALTER TABLE T ALTER COLUMN c_bpchar    DROP DEFAULT,               ALTER COLUMN c_date      DROP DEFAULT,               ALTER COLUMN c_text      DROP DEFAULT,               ALTER COLUMN c_timestamp DROP DEFAULT,               ALTER COLUMN c_array     DROP DEFAULT,               ALTER COLUMN c_small     DROP DEFAULT,               ALTER COLUMN c_big       DROP DEFAULT,               ALTER COLUMN c_num       DROP DEFAULT,               ALTER COLUMN c_time      DROP DEFAULT,               ALTER COLUMN c_hugetext  DROP DEFAULT;
INSERT INTO x VALUES (27), (28);
SELECT x, x, x, x, x, x, x, x, x, x, x, x, x, x, x = REPEAT('abcdefg', 1000) AS x, x = REPEAT('poiuyt', 1000) AS x FROM x ORDER BY x NULLS LAST;
SELECT COMP();
DROP TABLE x;
x AS x;
BEGIN i := 0;
x := x + 1;
x AS x;
COMMIT;
CREATE TABLE x (x INT NOT NULL PRIMARY KEY, x INT DEFAULT LENGTH(FOO(6)));
INSERT INTO x VALUES (1), (2);
ALTER TABLE T ADD COLUMN c_bpchar BPCHAR(5) DEFAULT foo(4),               ALTER COLUMN c_int SET DEFAULT LENGTH(foo(8));
INSERT INTO x VALUES (3), (4);
ALTER TABLE T ADD COLUMN c_text TEXT  DEFAULT foo(6),               ALTER COLUMN c_bpchar SET DEFAULT foo(3);
INSERT INTO x VALUES (5), (6);
ALTER TABLE T ADD COLUMN c_date DATE                   DEFAULT '2016-06-02'::DATE  + LENGTH(foo(10)),               ALTER COLUMN c_text SET DEFAULT foo(12);
INSERT INTO x VALUES (7), (8);
ALTER TABLE T ADD COLUMN c_timestamp TIMESTAMP                   DEFAULT '2016-09-01'::DATE + LENGTH(foo(10)),               ALTER COLUMN c_date                   SET DEFAULT '2010-01-01'::DATE - LENGTH(foo(4));
INSERT INTO x VALUES (9), (10);
ALTER TABLE T ADD COLUMN c_array TEXT[]                   DEFAULT ('{"This", "is", "' || foo(4) ||                            '","the", "real", "world"}')::TEXT[],               ALTER COLUMN c_timestamp                   SET DEFAULT '1970-12-31'::DATE + LENGTH(foo(30));
INSERT INTO x VALUES (11), (12);
ALTER TABLE T ALTER COLUMN c_int DROP DEFAULT,               ALTER COLUMN c_array                   SET DEFAULT ('{"This", "is", "' || foo(1) ||                                '", "fantasy"}')::text[];
INSERT INTO x VALUES (13), (14);
ALTER TABLE T ALTER COLUMN c_bpchar    DROP DEFAULT,               ALTER COLUMN c_date      DROP DEFAULT,               ALTER COLUMN c_text      DROP DEFAULT,               ALTER COLUMN c_timestamp DROP DEFAULT,               ALTER COLUMN c_array     DROP DEFAULT;
INSERT INTO x VALUES (15), (16);
SELECT * FROM x;
SELECT COMP();
DROP TABLE x;
/* Test domains with default value for table rewrite. */ CREATE DOMAIN domain1 AS int DEFAULT 11;
/* constant */ CREATE DOMAIN domain2 AS int DEFAULT random(min=>10, max=>100);
/* volatile */ CREATE DOMAIN domain3 AS text DEFAULT foo(4);
/* stable */ CREATE DOMAIN domain4 AS text[]   DEFAULT ('{"This", "is", "' || foo(4) || '","the", "real", "world"}')::TEXT[];
CREATE TABLE x (x domain1);
INSERT INTO x VALUES (1), (2);
ALTER TABLE x ADD COLUMN x domain1 DEFAULT 3 /* no table rewrite */;
SELECT x, x, x, x, x FROM x WHERE x > 0 AND x = CAST('t2' AS REGCLASS) ORDER BY x NULLS LAST;
ALTER TABLE x ADD COLUMN x domain3 DEFAULT LEFT(CAST(RAND() AS TEXT), 3) /* table rewrite should happen */;
ALTER TABLE x ADD COLUMN x domain4 /* no table rewrite */;
SELECT x, x, x, x, x FROM x WHERE x > 0 AND x = CAST('t2' AS REGCLASS) ORDER BY x NULLS LAST;
ALTER TABLE x ADD COLUMN x domain2 /* table rewrite should happen */;
SELECT x, x, x, x, x FROM x WHERE x > 0 AND x = CAST('t2' AS REGCLASS) ORDER BY x NULLS LAST;
SELECT x, x, LENGTH(x) = 3 AS x, x, x >= 10 AS x FROM x;
DROP TABLE x;
DROP DOMAIN domain1;
DROP DOMAIN domain2;
DROP DOMAIN domain3;
DROP DOMAIN domain4;
DROP FUNCTION x (INT);
/* Fall back to full rewrite for volatile expressions */ CREATE TABLE x (x INT NOT NULL PRIMARY KEY);
INSERT INTO x VALUES (1);
ALTER TABLE x ADD COLUMN x TIMESTAMP DEFAULT CURRENT_TIMESTAMP() /* now() is stable, because it returns the transaction timestamp */;
SELECT COMP();
ALTER TABLE x ADD COLUMN x TIMESTAMP DEFAULT CLOCK_TIMESTAMP() /* clock_timestamp() is volatile */;
SELECT COMP();
/* check that we notice insertion of a volatile default argument */ CREATE FUNCTION x(x DEFAULT CLOCK_TIMESTAMP()) RETURNS TIMESTAMPTZ IMMUTABLE LANGUAGE sql AS 'select $1';
ALTER TABLE x ADD COLUMN x TIMESTAMPTZ DEFAULT FOOLME();
SELECT x, x, x FROM x WHERE x = CAST('t' AS REGCLASS) AND x > 0 ORDER BY x NULLS LAST;
DROP TABLE x;
DROP FUNCTION x (TIMESTAMPTZ);
/* Simple querie */ CREATE TABLE x (x INT NOT NULL PRIMARY KEY);
INSERT INTO x SELECT * FROM x AS x;
ALTER TABLE x ADD COLUMN x BIGINT NOT NULL DEFAULT -1;
INSERT INTO x SELECT x, x - 10 FROM x AS x;
ALTER TABLE x ADD COLUMN x TEXT DEFAULT 'hello';
INSERT INTO x SELECT x, x - 10, CAST((x + 10) AS TEXT) FROM x AS x;
/* WHERE clause */ SELECT x, x FROM x WHERE x = -1 LIMIT 1;
EXPLAIN (VERBOSE TRUE, COSTS FALSE) SELECT c_bigint, c_text FROM T WHERE c_bigint = -1 LIMIT 1;
SELECT x, x FROM x WHERE x = 'hello' LIMIT 1;
EXPLAIN (VERBOSE TRUE, COSTS FALSE) SELECT c_bigint, c_text FROM T WHERE c_text = 'hello' LIMIT 1;
/* COALESCE */ SELECT COALESCE(x, x), COALESCE(x, CAST(x AS TEXT)) FROM x ORDER BY x NULLS LAST LIMIT 10;
/* Aggregate function */ SELECT SUM(x), MAX(x COLLATE "x"), MIN(x COLLATE "x") FROM x;
/* ORDER BY */ SELECT * FROM x ORDER BY x NULLS LAST, x NULLS LAST, x NULLS LAST LIMIT 10;
EXPLAIN (VERBOSE TRUE, COSTS FALSE) SELECT * FROM T ORDER BY c_bigint, c_text, pk LIMIT 10;
/* LIMIT */ SELECT * FROM x WHERE x > -1 ORDER BY x NULLS LAST, x NULLS LAST, x NULLS LAST LIMIT 10;
EXPLAIN (VERBOSE TRUE, COSTS FALSE) SELECT * FROM T WHERE c_bigint > -1 ORDER BY c_bigint, c_text, pk LIMIT 10;
/*  DELETE with RETURNING */ DELETE FROM x WHERE x BETWEEN 10 AND 20 RETURNING *;
EXPLAIN (VERBOSE TRUE, COSTS FALSE) DELETE FROM T WHERE pk BETWEEN 10 AND 20 RETURNING *;
/* UPDATE */ UPDATE x SET x = '"' || x || '"' WHERE x < 10;
SELECT * FROM x WHERE x LIKE '"%"' ORDER BY x NULLS LAST;
SELECT COMP();
DROP TABLE x;
/* Combine with other DDL */ CREATE TABLE x (x INT NOT NULL PRIMARY KEY);
INSERT INTO x VALUES (1), (2);
ALTER TABLE x ADD COLUMN x INT NOT NULL DEFAULT -1;
INSERT INTO x VALUES (3), (4);
ALTER TABLE x ADD COLUMN x TEXT DEFAULT 'Hello';
INSERT INTO x VALUES (5), (6);
ALTER TABLE T ALTER COLUMN c_text SET DEFAULT 'world',               ALTER COLUMN c_int  SET DEFAULT 1;
INSERT INTO x VALUES (7), (8);
SELECT * FROM x ORDER BY x NULLS LAST;
/* Add an index */ CREATE INDEX x ON x(x NULLS LAST, x NULLS LAST);
SELECT x FROM x WHERE x = -1;
SELECT COMP();
/* query to exercise expand_tuple function */ CREATE TABLE x AS SELECT CAST(1 AS INT) AS x, CAST(2 AS INT) AS x FROM x AS x;
ALTER TABLE x ADD COLUMN x TEXT;
SELECT x, STDDEV(CAST((SELECT SUM(1) FROM x AS x) AS FLOAT)) OVER (PARTITION BY x, x, x ORDER BY x NULLS LAST) AS x FROM x;
DROP TABLE x;
if TG_OP = 'DELETE'     then        return OLD;
COMMIT;
/* 2 new columns, both have defaults */ CREATE TABLE x (x SERIAL PRIMARY KEY, x INT, x INT, x INT);
INSERT INTO x (x, x, x) VALUES (1, 2, 3);
ALTER TABLE x ADD COLUMN x INT NOT NULL DEFAULT 4;
ALTER TABLE x ADD COLUMN x INT NOT NULL DEFAULT 5;
CREATE TRIGGER a BEFORE UPDATE ON t FOR EACH ROW EXECUTE PROCEDURE test_trigger();
SELECT * FROM x;
UPDATE x SET x = 2;
SELECT * FROM x;
DROP TABLE x;
/* 2 new columns, first has default */ CREATE TABLE x (x SERIAL PRIMARY KEY, x INT, x INT, x INT);
INSERT INTO x (x, x, x) VALUES (1, 2, 3);
ALTER TABLE x ADD COLUMN x INT NOT NULL DEFAULT 4;
ALTER TABLE x ADD COLUMN x INT;
CREATE TRIGGER a BEFORE UPDATE ON t FOR EACH ROW EXECUTE PROCEDURE test_trigger();
SELECT * FROM x;
UPDATE x SET x = 2;
SELECT * FROM x;
DROP TABLE x;
/* 2 new columns, second has default */ CREATE TABLE x (x SERIAL PRIMARY KEY, x INT, x INT, x INT);
INSERT INTO x (x, x, x) VALUES (1, 2, 3);
ALTER TABLE x ADD COLUMN x INT;
ALTER TABLE x ADD COLUMN x INT NOT NULL DEFAULT 5;
CREATE TRIGGER a BEFORE UPDATE ON t FOR EACH ROW EXECUTE PROCEDURE test_trigger();
SELECT * FROM x;
UPDATE x SET x = 2;
SELECT * FROM x;
DROP TABLE x;
/* 2 new columns, neither has default */ CREATE TABLE x (x SERIAL PRIMARY KEY, x INT, x INT, x INT);
INSERT INTO x (x, x, x) VALUES (1, 2, 3);
ALTER TABLE x ADD COLUMN x INT;
ALTER TABLE x ADD COLUMN x INT;
CREATE TRIGGER a BEFORE UPDATE ON t FOR EACH ROW EXECUTE PROCEDURE test_trigger();
SELECT * FROM x;
UPDATE x SET x = 2;
SELECT * FROM x;
DROP TABLE x;
/* same as last 4 tests but here the last original column has a NULL value */ /* 2 new columns, both have defaults */ CREATE TABLE x (x SERIAL PRIMARY KEY, x INT, x INT, x INT);
INSERT INTO x (x, x, x) VALUES (1, 2, NULL);
ALTER TABLE x ADD COLUMN x INT NOT NULL DEFAULT 4;
ALTER TABLE x ADD COLUMN x INT NOT NULL DEFAULT 5;
CREATE TRIGGER a BEFORE UPDATE ON t FOR EACH ROW EXECUTE PROCEDURE test_trigger();
SELECT * FROM x;
UPDATE x SET x = 2;
SELECT * FROM x;
DROP TABLE x;
/* 2 new columns, first has default */ CREATE TABLE x (x SERIAL PRIMARY KEY, x INT, x INT, x INT);
INSERT INTO x (x, x, x) VALUES (1, 2, NULL);
ALTER TABLE x ADD COLUMN x INT NOT NULL DEFAULT 4;
ALTER TABLE x ADD COLUMN x INT;
CREATE TRIGGER a BEFORE UPDATE ON t FOR EACH ROW EXECUTE PROCEDURE test_trigger();
SELECT * FROM x;
UPDATE x SET x = 2;
SELECT * FROM x;
DROP TABLE x;
/* 2 new columns, second has default */ CREATE TABLE x (x SERIAL PRIMARY KEY, x INT, x INT, x INT);
INSERT INTO x (x, x, x) VALUES (1, 2, NULL);
ALTER TABLE x ADD COLUMN x INT;
ALTER TABLE x ADD COLUMN x INT NOT NULL DEFAULT 5;
CREATE TRIGGER a BEFORE UPDATE ON t FOR EACH ROW EXECUTE PROCEDURE test_trigger();
SELECT * FROM x;
UPDATE x SET x = 2;
SELECT * FROM x;
DROP TABLE x;
/* 2 new columns, neither has default */ CREATE TABLE x (x SERIAL PRIMARY KEY, x INT, x INT, x INT);
INSERT INTO x (x, x, x) VALUES (1, 2, NULL);
ALTER TABLE x ADD COLUMN x INT;
ALTER TABLE x ADD COLUMN x INT;
CREATE TRIGGER a BEFORE UPDATE ON t FOR EACH ROW EXECUTE PROCEDURE test_trigger();
SELECT * FROM x;
UPDATE x SET x = 2;
SELECT * FROM x;
DROP TABLE x;
/* make sure expanded tuple has correct self pointer */ /* it will be required by the RI trigger doing the cascading delete */ CREATE TABLE x (x INT PRIMARY KEY, x INT);
CREATE TABLE x (x INT REFERENCES x ON DELETE CASCADE, x INT);
INSERT INTO x VALUES (1, 1), (2, 2);
ALTER TABLE x ADD COLUMN x INT;
ALTER TABLE x DROP c;
DELETE FROM x;
/* check that ALTER TABLE ... ALTER TYPE does the right thing */ CREATE TABLE x (x INT);
INSERT INTO x VALUES (1);
ALTER TABLE x ADD COLUMN x DOUBLE DEFAULT 0.2;
ALTER TABLE x ADD COLUMN x BOOLEAN DEFAULT TRUE;
SELECT * FROM x;
ALTER TABLE vtype       ALTER b TYPE text USING b::text,       ALTER c TYPE text USING c::text;
SELECT * FROM x;
/* also check the case that doesn't rewrite the table */ CREATE TABLE x (x INT);
INSERT INTO x VALUES (1);
ALTER TABLE x ADD COLUMN x VARCHAR(10) DEFAULT 'xxx';
ALTER TABLE x ALTER COLUMN x SET DEFAULT 'yyy';
INSERT INTO x VALUES (2);
ALTER TABLE x ALTER COLUMN x SET DATA TYPE VARCHAR(20) USING CAST(x AS VARCHAR(20));
SELECT * FROM x;
/* Ensure that defaults are checked when evaluating whether HOT update */ /* is possible, this was broken for a while: */ /* https://postgr.es/m/20190202133521.ylauh3ckqa7colzj%40alap3.anarazel.de */ BEGIN;
CREATE TABLE x;
ALTER TABLE x ADD COLUMN x INT DEFAULT 1;
CREATE INDEX ON x(x NULLS LAST);
/* set column with a default 1 to NULL, due to a bug that wasn't */ /* noticed has heap_getattr buggily returned NULL for default columns */ UPDATE x SET x = NULL;
SET LOCAL x = TRUE /* verify that index and non-index scans show the same result */;
SELECT * FROM x WHERE x IS NULL;
SET LOCAL x = FALSE;
SELECT * FROM x WHERE x IS NULL;
ROLLBACK;
/* verify that a default set on a non-plain table doesn't set a missing */ /* value on the attribute */ CREATE FOREIGN DATA WRAPPER dummy;
CREATE SERVER s0 FOREIGN DATA WRAPPER dummy;
CREATE FOREIGN TABLE ft1 (c1 integer NOT NULL) SERVER s0;
ALTER FOREIGN TABLE ft1 ADD COLUMN c8 integer DEFAULT 0;
ALTER FOREIGN TABLE ft1 ALTER COLUMN c8 TYPE char(10);
SELECT COUNT(*) FROM x WHERE x = CAST('ft1' AS REGCLASS) AND (NOT x IS NULL OR x);
/* cleanup */ DROP FOREIGN TABLE ft1;
DROP SERVER s0;
DROP FOREIGN DATA WRAPPER dummy;
DROP TABLE x;
DROP TABLE x;
DROP TABLE x;
DROP TABLE x;
DROP FUNCTION x;
DROP TABLE x;
DROP FUNCTION x (NAME);
DROP FUNCTION x;
DROP TABLE x;
DROP TABLE x;
DROP EVENT TRIGGER has_volatile_rewrite;
DROP FUNCTION x;
DROP SCHEMA x.x;
SET x = public /* Leave a table with an active fast default in place, for pg_upgrade testing */;
CREATE TABLE x (x INT);
INSERT INTO x VALUES (1);
ALTER TABLE x ADD COLUMN x INT DEFAULT 42;
x AS x;
/* FLOAT4 */ CREATE TABLE x (x FLOAT);
INSERT INTO x (x) VALUES ('    0.0');
INSERT INTO x (x) VALUES ('1004.30   ');
INSERT INTO x (x) VALUES ('     -34.84    ');
INSERT INTO x (x) VALUES ('1.2345678901234e+20');
INSERT INTO x (x) VALUES ('1.2345678901234e-20');
/* test for over and under flow */ INSERT INTO x (x) VALUES ('10e70');
INSERT INTO x (x) VALUES ('-10e70');
INSERT INTO x (x) VALUES ('10e-70');
INSERT INTO x (x) VALUES ('-10e-70');
INSERT INTO x (x) VALUES (CAST('10e70' AS DOUBLE));
INSERT INTO x (x) VALUES (CAST('-10e70' AS DOUBLE));
INSERT INTO x (x) VALUES (CAST('10e-70' AS DOUBLE));
INSERT INTO x (x) VALUES (CAST('-10e-70' AS DOUBLE));
INSERT INTO x (x) VALUES ('10e400');
INSERT INTO x (x) VALUES ('-10e400');
INSERT INTO x (x) VALUES ('10e-400');
INSERT INTO x (x) VALUES ('-10e-400');
/* bad input */ INSERT INTO x (x) VALUES ('');
INSERT INTO x (x) VALUES ('       ');
INSERT INTO x (x) VALUES ('xyz');
INSERT INTO x (x) VALUES ('5.0.0');
INSERT INTO x (x) VALUES ('5 . 0');
INSERT INTO x (x) VALUES ('5.   0');
INSERT INTO x (x) VALUES ('     - 3.0');
INSERT INTO x (x) VALUES ('123            5');
/* Also try it with non-error-throwing API */ SELECT PG_INPUT_IS_VALID('34.5', 'float4');
SELECT PG_INPUT_IS_VALID('xyz', 'float4');
SELECT PG_INPUT_IS_VALID('1e400', 'float4');
SELECT * FROM x;
/* special inputs */ SELECT CAST('NaN' AS FLOAT);
SELECT CAST('nan' AS FLOAT);
SELECT CAST('   NAN  ' AS FLOAT);
SELECT CAST('infinity' AS FLOAT);
SELECT CAST('          -INFINiTY   ' AS FLOAT);
/* bad special inputs */ SELECT CAST('N A N' AS FLOAT);
SELECT CAST('NaN x' AS FLOAT);
SELECT CAST(' INFINITY    x' AS FLOAT);
SELECT CAST('Infinity' AS FLOAT) + 100.0;
SELECT CAST('Infinity' AS FLOAT) / CAST('Infinity' AS FLOAT);
SELECT CAST('42' AS FLOAT) / CAST('Infinity' AS FLOAT);
SELECT CAST('nan' AS FLOAT) / CAST('nan' AS FLOAT);
SELECT CAST('nan' AS FLOAT) / CAST('0' AS FLOAT);
SELECT CAST(CAST('nan' AS DECIMAL) AS FLOAT);
SELECT * FROM x;
SELECT x.* FROM x AS x WHERE x.x <> '1004.3';
SELECT x.* FROM x AS x WHERE x.x = '1004.3';
SELECT x.* FROM x AS x WHERE '1004.3' > x.x;
SELECT x.* FROM x AS x WHERE x.x < '1004.3';
SELECT x.* FROM x AS x WHERE '1004.3' >= x.x;
SELECT x.* FROM x AS x WHERE x.x <= '1004.3';
SELECT x.x, x.x * '-10' AS x FROM x AS x WHERE x.x > '0.0';
SELECT x.x, x.x + '-10' AS x FROM x AS x WHERE x.x > '0.0';
SELECT x.x, x.x / '-10' AS x FROM x AS x WHERE x.x > '0.0';
SELECT x.x, x.x - '-10' AS x FROM x AS x WHERE x.x > '0.0';
/* test divide by zero */ SELECT x.x / '0.0' FROM x AS x;
SELECT * FROM x;
/* test the unary float4abs operator */ SELECT x.x, @f.x AS x FROM x AS x;
UPDATE x SET x = x.x * '-1' WHERE x.x > '0.0';
SELECT * FROM x;
/* test edge-case coercions to integer */ SELECT CAST(CAST('32767.4' AS FLOAT) AS SMALLINT);
SELECT CAST(CAST('32767.6' AS FLOAT) AS SMALLINT);
SELECT CAST(CAST('-32768.4' AS FLOAT) AS SMALLINT);
SELECT CAST(CAST('-32768.6' AS FLOAT) AS SMALLINT);
SELECT CAST(CAST('2147483520' AS FLOAT) AS INT);
SELECT CAST(CAST('2147483647' AS FLOAT) AS INT);
SELECT CAST(CAST('-2147483648.5' AS FLOAT) AS INT);
SELECT CAST(CAST('-2147483900' AS FLOAT) AS INT);
SELECT CAST(CAST('9223369837831520256' AS FLOAT) AS BIGINT);
SELECT CAST(CAST('9223372036854775807' AS FLOAT) AS BIGINT);
SELECT CAST(CAST('-9223372036854775808.5' AS FLOAT) AS BIGINT);
SELECT CAST(CAST('-9223380000000000000' AS FLOAT) AS BIGINT);
/* Test for correct input rounding in edge cases. */ /* These lists are from Paxson 1991, excluding subnormals and */ /* inputs of over 9 sig. digits. */ SELECT FLOAT4SEND(CAST('5e-20' AS FLOAT));
SELECT FLOAT4SEND(CAST('67e14' AS FLOAT));
SELECT FLOAT4SEND(CAST('985e15' AS FLOAT));
SELECT FLOAT4SEND(CAST('55895e-16' AS FLOAT));
SELECT FLOAT4SEND(CAST('7038531e-32' AS FLOAT));
SELECT FLOAT4SEND(CAST('702990899e-20' AS FLOAT));
SELECT FLOAT4SEND(CAST('3e-23' AS FLOAT));
SELECT FLOAT4SEND(CAST('57e18' AS FLOAT));
SELECT FLOAT4SEND(CAST('789e-35' AS FLOAT));
SELECT FLOAT4SEND(CAST('2539e-18' AS FLOAT));
SELECT FLOAT4SEND(CAST('76173e28' AS FLOAT));
SELECT FLOAT4SEND(CAST('887745e-11' AS FLOAT));
SELECT FLOAT4SEND(CAST('5382571e-37' AS FLOAT));
SELECT FLOAT4SEND(CAST('82381273e-35' AS FLOAT));
SELECT FLOAT4SEND(CAST('750486563e-38' AS FLOAT));
/* Test that the smallest possible normalized input value inputs */ /* correctly, either in 9-significant-digit or shortest-decimal */ /* format. */ /* exact val is             1.1754943508... */ /* shortest val is          1.1754944000 */ /* midpoint to next val is  1.1754944208... */ SELECT FLOAT4SEND(CAST('1.17549435e-38' AS FLOAT));
SELECT FLOAT4SEND(CAST('1.1754944e-38' AS FLOAT));
/* test output (and round-trip safety) of various values. */ /* To ensure we're testing what we think we're testing, start with */ /* float values specified by bit patterns (as a useful side effect, */ /* this means we'll fail on non-IEEE platforms). */ create type xfloat4;
CREATE FUNCTION x(x) RETURNS xfloat4 IMMUTABLE STRICT LANGUAGE internal AS 'int4in';
CREATE FUNCTION x(x) RETURNS CSTRING IMMUTABLE STRICT LANGUAGE internal AS 'int4out';
create type xfloat4 (input = xfloat4in, output = xfloat4out, like = float4);
create cast (xfloat4 as float4) without function;
create cast (float4 as xfloat4) without function;
create cast (xfloat4 as integer) without function;
create cast (integer as xfloat4) without function;
WITH x AS (SELECT * FROM (VALUES (0), (8388608), (8388609), (8388612), (8388613), (8388614), (8389361), (8389362), (8389363), (8392215), (8392216), (8392217), (16777217), (17836099), (27602072), (35242537), (48514637), (57885633), (61414198), (75160165), (77004423), (89162831), (93953443), (101623266), (115752005), (133293384), (264579115), (528810627), (678734294), (861323156), (861323157), (861323158), (869711764), (869711765), (869711766), (882970543), (882970544), (882970545), (889599932), (889599933), (889599934), (896636806), (896636807), (896636808), (897988540), (897988541), (897988542), (916964779), (916964780), (916964781), (925353387), (925353388), (925353389), (953267988), (953267989), (953267990), (953267991), (953267992), (953267993), (953267994), (953267995), (953267996), (953267997), (954204158), (954204159), (954204160), (955252735), (955252736), (955252737), (981668462), (981668463), (981668464), (1008981769), (1008981770), (1008981771), (1036831948), (1036831949), (1036831950), (1036832111), (1036832112), (1036832113), (1056964607), (1056964608), (1056964609), (1060320050), (1060320051), (1060320052), (1063675493), (1063675494), (1063675495), (1065185443), (1065185444), (1065185445), (1065336438), (1065336439), (1065336440), (1065351537), (1065351538), (1065351539), (1065353047), (1065353048), (1065353049), (1065353198), (1065353199), (1065353200), (1065353201), (1065353202), (1065353203), (1065353204), (1065353205), (1065353206), (1065353207), (1065353208), (1065353209), (1065353210), (1065353211), (1065353212), (1065353213), (1065353214), (1065353215), (1065353216), (1065353217), (1065353218), (1065353219), (1065353220), (1065353221), (1065353222), (1065353223), (1065353224), (1065353225), (1065353231), (1065353232), (1065353233), (1065353234), (1065353235), (1065353236), (1065353239), (1065353240), (1065353241), (1065353242), (1065353243), (1065353244), (1065353257), (1065353258), (1065353259), (1065353299), (1065353300), (1065353301), (1065354054), (1065354055), (1065354056), (1065361604), (1065361605), (1065361606), (1065437101), (1065437102), (1065437103), (1066192076), (1066192077), (1066192078), (1070141403) /* pi/2 */, (1076754516) /* e */, (1078530011) /* pi */, (1084227583), (1084227584), (1084227585), (1085276159), (1085276160), (1085276161), (1092616191), (1092616192), (1092616193), (1120403455), (1120403456), (1120403457), (1148846079), (1148846080), (1148846081), (1176256511), (1176256512), (1176256513), (1203982335), (1203982336), (1203982337), (1232348159), (1232348160), (1232348161), (1259902591), (1259902592), (1259902593), (1287568415), (1287568416), (1287568417), (1315859239), (1315859240), (1315859241), (1343554296), (1343554297), (1343554298), (1371161526), (1371161527), (1371161528), (527179338) /* 5e-20 */, (1505651946) /* 67e14 */, (1566226116) /* 985e15 */, (751086013) /* 55895e-16 */, (363742205) /* 7038531e-32 */, (754407370) /* 702990899e-20 */, (1717283224) /* 25933168707e13 */, (1950102308) /* 596428896559e20 */, (1206984794), (1178658478), (1150964261), (1123477973), (1095075805), (1067320907), (1275068420), (1342577734), (1358956200), (1217732484), (1174214720), (964689920), (991952896), (999292928), (1003487232), (1669332992), (1258291200), (1266679808), (1275068417), (1283459853), (13780356), (14224264), (1166032692), (1335829751), (981934787), (1551892545), (363742205), (1565314299), (1283457025), (1468010200), (1593835520), (1879048432), (1596189100), (1586823929), (1585451697), (1006633000), (1624107105), (61483600), (1128792064), (1275068416), (1561658105), (1570046713), (1578435321), (1067030938), (1067282596), (1067316150), (1067320345), (1067320848), (1067320907), (1067320913), (64097534)) AS x) SELECT FLOAT4SEND(x) AS x, x, CAST(CAST(x AS TEXT) AS FLOAT) AS x, FLOAT4SEND(CAST(CAST(x AS TEXT) AS FLOAT)) AS x, FLOAT4SEND(CAST(CAST(x AS TEXT) AS FLOAT)) = FLOAT4SEND(x) AS x FROM (SELECT CAST(CAST(CAST(x AS INT) AS xfloat4) AS FLOAT) AS x FROM x OFFSET 0) AS x;
/* clean up, lest opr_sanity complain */ drop type xfloat4 cascade;
/* FLOAT8 */ /* Build a table for testing */ /* (This temporarily hides the table created in test_setup.sql) */ CREATE TEMPORARY TABLE x (x DOUBLE);
INSERT INTO x (x) VALUES ('    0.0   ');
INSERT INTO x (x) VALUES ('1004.30  ');
INSERT INTO x (x) VALUES ('   -34.84');
INSERT INTO x (x) VALUES ('1.2345678901234e+200');
INSERT INTO x (x) VALUES ('1.2345678901234e-200');
/* test for underflow and overflow handling */ SELECT CAST('10e400' AS DOUBLE);
SELECT CAST('-10e400' AS DOUBLE);
SELECT CAST('10e-400' AS DOUBLE);
SELECT CAST('-10e-400' AS DOUBLE);
/* test smallest normalized input */ SELECT FLOAT8SEND(CAST('2.2250738585072014E-308' AS DOUBLE));
/* bad input */ INSERT INTO x (x) VALUES ('');
INSERT INTO x (x) VALUES ('     ');
INSERT INTO x (x) VALUES ('xyz');
INSERT INTO x (x) VALUES ('5.0.0');
INSERT INTO x (x) VALUES ('5 . 0');
INSERT INTO x (x) VALUES ('5.   0');
INSERT INTO x (x) VALUES ('    - 3');
INSERT INTO x (x) VALUES ('123           5');
/* Also try it with non-error-throwing API */ SELECT PG_INPUT_IS_VALID('34.5', 'float8');
SELECT PG_INPUT_IS_VALID('xyz', 'float8');
SELECT PG_INPUT_IS_VALID('1e4000', 'float8');
SELECT * FROM x;
/* special inputs */ SELECT CAST('NaN' AS DOUBLE);
SELECT CAST('nan' AS DOUBLE);
SELECT CAST('   NAN  ' AS DOUBLE);
SELECT CAST('infinity' AS DOUBLE);
SELECT CAST('          -INFINiTY   ' AS DOUBLE);
/* bad special inputs */ SELECT CAST('N A N' AS DOUBLE);
SELECT CAST('NaN x' AS DOUBLE);
SELECT CAST(' INFINITY    x' AS DOUBLE);
SELECT CAST('Infinity' AS DOUBLE) + 100.0;
SELECT CAST('Infinity' AS DOUBLE) / CAST('Infinity' AS DOUBLE);
SELECT CAST('42' AS DOUBLE) / CAST('Infinity' AS DOUBLE);
SELECT CAST('nan' AS DOUBLE) / CAST('nan' AS DOUBLE);
SELECT CAST('nan' AS DOUBLE) / CAST('0' AS DOUBLE);
SELECT CAST(CAST('nan' AS DECIMAL) AS DOUBLE);
SELECT * FROM x;
SELECT x.* FROM x AS x WHERE x.x <> '1004.3';
SELECT x.* FROM x AS x WHERE x.x = '1004.3';
SELECT x.* FROM x AS x WHERE '1004.3' > x.x;
SELECT x.* FROM x AS x WHERE x.x < '1004.3';
SELECT x.* FROM x AS x WHERE '1004.3' >= x.x;
SELECT x.* FROM x AS x WHERE x.x <= '1004.3';
SELECT x.x, x.x * '-10' AS x FROM x AS x WHERE x.x > '0.0';
SELECT x.x, x.x + '-10' AS x FROM x AS x WHERE x.x > '0.0';
SELECT x.x, x.x / '-10' AS x FROM x AS x WHERE x.x > '0.0';
SELECT x.x, x.x - '-10' AS x FROM x AS x WHERE x.x > '0.0';
SELECT POWER(x.x, '2.0') AS x FROM x AS x WHERE x.x = '1004.3';
/* absolute value */ SELECT x.x, @f.x AS x FROM x AS x;
/* truncate */ SELECT x.x, TRUNC(x.x) AS x FROM x AS x;
/* round */ SELECT x.x, ROUND(x.x) AS x FROM x AS x;
/* ceil / ceiling */ SELECT CEIL(x) AS x FROM x AS x;
SELECT CEIL(x) AS x FROM x AS x;
/* floor */ SELECT FLOOR(x) AS x FROM x AS x;
/* sign */ SELECT SIGN(x) AS x FROM x AS x;
SET x = 0 /* avoid bit-exact output here because operations may not be bit-exact. */;
/* square root */ SELECT SQRT(CAST('64' AS DOUBLE)) AS x;
SELECT SQRT(CAST('64' AS DOUBLE)) AS x;
SELECT x.x, SQRT(x.x) AS x FROM x AS x WHERE x.x > '0.0';
/* power */ SELECT POWER(CAST('144' AS DOUBLE), CAST('0.5' AS DOUBLE));
SELECT POWER(CAST('NaN' AS DOUBLE), CAST('0.5' AS DOUBLE));
SELECT POWER(CAST('144' AS DOUBLE), CAST('NaN' AS DOUBLE));
SELECT POWER(CAST('NaN' AS DOUBLE), CAST('NaN' AS DOUBLE));
SELECT POWER(CAST('-1' AS DOUBLE), CAST('NaN' AS DOUBLE));
SELECT POWER(CAST('1' AS DOUBLE), CAST('NaN' AS DOUBLE));
SELECT POWER(CAST('NaN' AS DOUBLE), CAST('0' AS DOUBLE));
SELECT POWER(CAST('inf' AS DOUBLE), CAST('0' AS DOUBLE));
SELECT POWER(CAST('-inf' AS DOUBLE), CAST('0' AS DOUBLE));
SELECT POWER(CAST('0' AS DOUBLE), CAST('inf' AS DOUBLE));
SELECT POWER(CAST('0' AS DOUBLE), CAST('-inf' AS DOUBLE));
SELECT POWER(CAST('1' AS DOUBLE), CAST('inf' AS DOUBLE));
SELECT POWER(CAST('1' AS DOUBLE), CAST('-inf' AS DOUBLE));
SELECT POWER(CAST('-1' AS DOUBLE), CAST('inf' AS DOUBLE));
SELECT POWER(CAST('-1' AS DOUBLE), CAST('-inf' AS DOUBLE));
SELECT POWER(CAST('0.1' AS DOUBLE), CAST('inf' AS DOUBLE));
SELECT POWER(CAST('-0.1' AS DOUBLE), CAST('inf' AS DOUBLE));
SELECT POWER(CAST('1.1' AS DOUBLE), CAST('inf' AS DOUBLE));
SELECT POWER(CAST('-1.1' AS DOUBLE), CAST('inf' AS DOUBLE));
SELECT POWER(CAST('0.1' AS DOUBLE), CAST('-inf' AS DOUBLE));
SELECT POWER(CAST('-0.1' AS DOUBLE), CAST('-inf' AS DOUBLE));
SELECT POWER(CAST('1.1' AS DOUBLE), CAST('-inf' AS DOUBLE));
SELECT POWER(CAST('-1.1' AS DOUBLE), CAST('-inf' AS DOUBLE));
SELECT POWER(CAST('inf' AS DOUBLE), CAST('-2' AS DOUBLE));
SELECT POWER(CAST('inf' AS DOUBLE), CAST('2' AS DOUBLE));
SELECT POWER(CAST('inf' AS DOUBLE), CAST('inf' AS DOUBLE));
SELECT POWER(CAST('inf' AS DOUBLE), CAST('-inf' AS DOUBLE));
/* Intel's icc misoptimizes the code that controls the sign of this result, */ /* even with -mp1.  Pending a fix for that, only test for "is it zero". */ SELECT POWER(CAST('-inf' AS DOUBLE), CAST('-2' AS DOUBLE)) = '0';
SELECT POWER(CAST('-inf' AS DOUBLE), CAST('-3' AS DOUBLE));
SELECT POWER(CAST('-inf' AS DOUBLE), CAST('2' AS DOUBLE));
SELECT POWER(CAST('-inf' AS DOUBLE), CAST('3' AS DOUBLE));
SELECT POWER(CAST('-inf' AS DOUBLE), CAST('3.5' AS DOUBLE));
SELECT POWER(CAST('-inf' AS DOUBLE), CAST('inf' AS DOUBLE));
SELECT POWER(CAST('-inf' AS DOUBLE), CAST('-inf' AS DOUBLE));
/* take exp of ln(f.f1) */ SELECT x.x, EXP(LN(x.x)) AS x FROM x AS x WHERE x.x > '0.0';
/* check edge cases for exp */ SELECT EXP(CAST('inf' AS DOUBLE)), EXP(CAST('-inf' AS DOUBLE)), EXP(CAST('nan' AS DOUBLE));
/* cube root */ SELECT CBRT(CAST('27' AS DOUBLE)) AS x;
SELECT x.x, CBRT(x.x) AS x FROM x AS x;
SELECT * FROM x;
UPDATE x SET x = x.x * '-1' WHERE x.x > '0.0';
SELECT x.x * '1e200' FROM x AS x;
SELECT POWER(x.x, '1e200') FROM x AS x;
SELECT POWER(0, 0) + POWER(0, 1) + POWER(0, 0.0) + POWER(0, 0.5);
SELECT LN(x.x) FROM x AS x WHERE x.x = '0.0';
SELECT LN(x.x) FROM x AS x WHERE x.x < '0.0';
SELECT EXP(x.x) FROM x AS x;
SELECT x.x / '0.0' FROM x AS x;
SELECT * FROM x;
/* hyperbolic functions */ /* we run these with extra_float_digits = 0 too, since different platforms */ /* tend to produce results that vary in the last place. */ SELECT SINH(CAST('1' AS DOUBLE));
SELECT COSH(CAST('1' AS DOUBLE));
SELECT TANH(CAST('1' AS DOUBLE));
SELECT ASINH(CAST('1' AS DOUBLE));
SELECT ACOSH(CAST('2' AS DOUBLE));
SELECT ATANH(CAST('0.5' AS DOUBLE));
/* test Inf/NaN cases for hyperbolic functions */ SELECT SINH(CAST('infinity' AS DOUBLE));
SELECT SINH(CAST('-infinity' AS DOUBLE));
SELECT SINH(CAST('nan' AS DOUBLE));
SELECT COSH(CAST('infinity' AS DOUBLE));
SELECT COSH(CAST('-infinity' AS DOUBLE));
SELECT COSH(CAST('nan' AS DOUBLE));
SELECT TANH(CAST('infinity' AS DOUBLE));
SELECT TANH(CAST('-infinity' AS DOUBLE));
SELECT TANH(CAST('nan' AS DOUBLE));
SELECT ASINH(CAST('infinity' AS DOUBLE));
SELECT ASINH(CAST('-infinity' AS DOUBLE));
SELECT ASINH(CAST('nan' AS DOUBLE));
SELECT ACOSH(CAST('-infinity' AS DOUBLE));
SELECT ACOSH(CAST('nan' AS DOUBLE));
SELECT ATANH(CAST('infinity' AS DOUBLE));
SELECT ATANH(CAST('-infinity' AS DOUBLE));
SELECT ATANH(CAST('nan' AS DOUBLE));
SET x = -1 /* error functions */ /* we run these with extra_float_digits = -1, to get consistently rounded */ /* results on all platforms. */;
SELECT x, ERF(x), ERFC(x) FROM (VALUES (CAST('-infinity' AS DOUBLE)), (-28), (-6), (-3.4), (-2.1), (-1.1), (-0.45), (-1.2e-9), (-2.3e-13), (-1.2e-17), (0), (1.2e-17), (2.3e-13), (1.2e-9), (0.45), (1.1), (2.1), (3.4), (6), (28), (CAST('infinity' AS DOUBLE)), (CAST('nan' AS DOUBLE))) AS x;
RESET extra_float_digits;
/* test for over- and underflow */ INSERT INTO x (x) VALUES ('10e400');
INSERT INTO x (x) VALUES ('-10e400');
INSERT INTO x (x) VALUES ('10e-400');
INSERT INTO x (x) VALUES ('-10e-400');
DROP TABLE x;
/* Check the float8 values exported for use by other tests */ SELECT * FROM x;
/* test edge-case coercions to integer */ SELECT CAST(CAST('32767.4' AS DOUBLE) AS SMALLINT);
SELECT CAST(CAST('32767.6' AS DOUBLE) AS SMALLINT);
SELECT CAST(CAST('-32768.4' AS DOUBLE) AS SMALLINT);
SELECT CAST(CAST('-32768.6' AS DOUBLE) AS SMALLINT);
SELECT CAST(CAST('2147483647.4' AS DOUBLE) AS INT);
SELECT CAST(CAST('2147483647.6' AS DOUBLE) AS INT);
SELECT CAST(CAST('-2147483648.4' AS DOUBLE) AS INT);
SELECT CAST(CAST('-2147483648.6' AS DOUBLE) AS INT);
SELECT CAST(CAST('9223372036854773760' AS DOUBLE) AS BIGINT);
SELECT CAST(CAST('9223372036854775807' AS DOUBLE) AS BIGINT);
SELECT CAST(CAST('-9223372036854775808.5' AS DOUBLE) AS BIGINT);
SELECT CAST(CAST('-9223372036854780000' AS DOUBLE) AS BIGINT);
/* test exact cases for trigonometric functions in degrees */ SELECT x, SIND(x), SIND(x) IN (-1, -0.5, 0, 0.5, 1) AS x FROM (VALUES (0), (30), (90), (150), (180), (210), (270), (330), (360)) AS x;
SELECT x, COSD(x), COSD(x) IN (-1, -0.5, 0, 0.5, 1) AS x FROM (VALUES (0), (60), (90), (120), (180), (240), (270), (300), (360)) AS x;
SELECT x, TAND(x), TAND(x) IN (CAST('-Infinity' AS DOUBLE), -1, 0, 1, CAST('Infinity' AS DOUBLE)) AS x, COTD(x), COTD(x) IN (CAST('-Infinity' AS DOUBLE), -1, 0, 1, CAST('Infinity' AS DOUBLE)) AS x FROM (VALUES (0), (45), (90), (135), (180), (225), (270), (315), (360)) AS x;
SELECT x, ASIND(x), ASIND(x) IN (-90, -30, 0, 30, 90) AS x, ACOSD(x), ACOSD(x) IN (0, 60, 90, 120, 180) AS x FROM (VALUES (-1), (-0.5), (0), (0.5), (1)) AS x;
SELECT x, ATAND(x), ATAND(x) IN (-90, -45, 0, 45, 90) AS x FROM (VALUES (CAST('-Infinity' AS DOUBLE)), (-1), (0), (1), (CAST('Infinity' AS DOUBLE))) AS x;
SELECT x, x, ATAN2D(x, x), ATAN2D(x, x) IN (-90, 0, 90, 180) AS x FROM (SELECT 10 * COSD(x), 10 * SIND(x) FROM x AS x) AS x;
/* test output (and round-trip safety) of various values. */ /* To ensure we're testing what we think we're testing, start with */ /* float values specified by bit patterns (as a useful side effect, */ /* this means we'll fail on non-IEEE platforms). */ create type xfloat8;
CREATE FUNCTION x(x) RETURNS xfloat8 IMMUTABLE STRICT LANGUAGE internal AS 'int8in';
CREATE FUNCTION x(x) RETURNS CSTRING IMMUTABLE STRICT LANGUAGE internal AS 'int8out';
create type xfloat8 (input = xfloat8in, output = xfloat8out, like = no_such_type);
create type xfloat8 (input = xfloat8in, output = xfloat8out, like = float8);
create cast (xfloat8 as float8) without function;
create cast (float8 as xfloat8) without function;
create cast (xfloat8 as bigint) without function;
create cast (bigint as xfloat8) without function;
/* round-trip tests */ WITH x AS (SELECT * FROM (VALUES (0), (4503599627370496), (4503599627370497), (4503599627370498), (6755399441055744), (4457293557087583674), (4457293557087583675), (4457293557087583676), (4472406533629990548), (4472406533629990549), (4472406533629990550), (4487126258331716665), (4487126258331716666), (4487126258331716667), (4502148214488346439), (4502148214488346440), (4502148214488346441), (4517329193108106636), (4517329193108106637), (4517329193108106638), (4532020583610935535), (4532020583610935536), (4532020583610935537), (4547007122018943788), (4547007122018943789), (4547007122018943790), (4562254508917369339), (4562254508917369340), (4562254508917369341), (4576918229304087674), (4576918229304087675), (4576918229304087676), (4591870180066957721), (4591870180066957722), (4591870180066957723), (4607182418800017392), (4607182418800017393), (4607182418800017394), (4607182418800017395), (4607182418800017396), (4607182418800017397), (4607182418800017398), (4607182418800017399), (4607182418800017400), (4607182418800017401), (4607182418800017402), (4607182418800017403), (4607182418800017404), (4607182418800017405), (4607182418800017406), (4607182418800017407), (4607182418800017408), (4607182418800017409), (4607182418800017410), (4607182418800017411), (4607182418800017412), (4607182418800017413), (4607182418800017414), (4607182418800017415), (4607182418800017416), (4607182418800017417), (4609753056924675352), (4613303445314885482), (4614256656552045848), (4621819117588971519), (4621819117588971520), (4621819117588971521), (4636737291354636287), (4636737291354636288), (4636737291354636289), (4652007308841189375), (4652007308841189376), (4652007308841189377), (4666723172467343359), (4666723172467343360), (4666723172467343361), (4681608360884174847), (4681608360884174848), (4681608360884174849), (4696837146684686335), (4696837146684686336), (4696837146684686337), (4711630319722168319), (4711630319722168320), (4711630319722168321), (4726483295884279807), (4726483295884279808), (4726483295884279809), (4741671816366391295), (4741671816366391296), (4741671816366391297), (4756540486875873279), (4756540486875873280), (4756540486875873281), (4771362005757984767), (4771362005757984768), (4771362005757984769), (4786511204640096255), (4786511204640096256), (4786511204640096257), (4801453603149578239), (4801453603149578240), (4801453603149578241), (4816244402031689727), (4816244402031689728), (4816244402031689729), (4831355200913801215), (4831355200913801216), (4831355200913801217), (4846369599423283199), (4846369599423283200), (4846369599423283201), (4861130398305394687), (4861130398305394688), (4861130398305394689), (4876203697187506175), (4876203697187506176), (4876203697187506177), (4891288408196988159), (4891288408196988160), (4891288408196988161), (4906019910204099647), (4906019910204099648), (4906019910204099649), (4921056587992461135), (4921056587992461136), (4921056587992461137), (4936209963552724369), (4936209963552724370), (4936209963552724371), (4950912855330343669), (4950912855330343670), (4950912855330343671), (4965913770331839923), (4965913770331839924), (4965913770331839925), (4981134201117475472), (4981134201117475473), (4981134201117475474), (9218868437227405310), (9218868437227405311), (4850376798678024194), (4850376798678035974), (4850939748631445507), (4850939748631445508), (4852628598491709443), (4852628598491709444), (4854598923328684064), (14073748835532800002), (14073748835532811782), (14074311785486221315), (14074311785486221316), (14076000635346485251), (14076000635346485252), (14077970960183459872), (4817745636528479846), (4802654590747010335), (4787879594345412428), (4772899269882697849), (4757770298175643745), (4742964961033578164), (4728057454347986003), (4712889646493133276), (4698053240432828797), (4683220299151009992), (4668012723080811475), (4653144502448230364), (4638387916139875475), (4623139617417162870), (4608238818662570488), (4494592428115755008), (14074519758152169412), (4845900000000000000), (4886500000000000000), (4891000000000000000), (4608238818256690525), (5201922341567583634), (5206425941194954130), (5210929540822324626), (4608083138725491507), (4608218246714312622), (4608236261112822104), (4608238512912635789), (4608238783128613432), (4608238814653810823), (4608238818256690525), (4608238818662014491), (4608238818684532490), (4608238818662464851), (4608238818662554923), (4608238818662568434), (4608238818662570236), (4608238818662570461), (4608238818662570488), (4608238818662570491), (4616521721703594621), (4616521721704720521), (4616521721705846421), (4616521721706972321), (4616521721708098221), (18014398509481984), (36028797018963967), (184647584722190336), (189151184349560831), (4850376798678024192), (4854880398305394687), (1382605085602742272), (1387108685230112767), (4210767889987104268)) AS x) SELECT FLOAT8SEND(x) AS x, x, CAST(CAST(x AS TEXT) AS DOUBLE) AS x, FLOAT8SEND(CAST(CAST(x AS TEXT) AS DOUBLE)) AS x, FLOAT8SEND(CAST(CAST(x AS TEXT) AS DOUBLE)) = FLOAT8SEND(x) AS x FROM (SELECT CAST(CAST(CAST(x AS BIGINT) AS xfloat8) AS DOUBLE) AS x FROM x OFFSET 0) AS x;
/* clean up, lest opr_sanity complain */ drop type xfloat8 cascade;
SET x = 'warning' /* Clean up in case a prior regression run failed */ /* Suppress NOTICE messages when roles don't exist */;
DROP ROLE IF EXISTS regress_foreign_data_user, regress_test_role, regress_test_role2, regress_test_role_super, regress_test_indirect, regress_unprivileged_role;
RESET client_min_messages;
CREATE ROLE regress_foreign_data_user LOGIN SUPERUSER;
SET SESSION AUTHORIZATION 'regress_foreign_data_user';
CREATE ROLE regress_test_role;
CREATE ROLE regress_test_role2;
CREATE ROLE regress_test_role_super SUPERUSER;
CREATE ROLE regress_test_indirect;
CREATE ROLE regress_unprivileged_role;
CREATE FOREIGN DATA WRAPPER dummy;
COMMENT ON FOREIGN DATA WRAPPER dummy IS 'useless';
CREATE FOREIGN DATA WRAPPER postgresql VALIDATOR postgresql_fdw_validator;
/* At this point we should have 2 built-in wrappers and no servers. */ SELECT x, CAST(x AS REGPROC), CAST(x AS REGPROC), x FROM x ORDER BY 1 NULLS LAST, 2 NULLS LAST, 3 NULLS LAST;
SELECT x, x FROM x;
SELECT * FROM x;
/* CREATE FOREIGN DATA WRAPPER */ CREATE FOREIGN DATA WRAPPER foo VALIDATOR bar;
/* ERROR */ CREATE FOREIGN DATA WRAPPER foo;
/* duplicate */ DROP FOREIGN DATA WRAPPER foo;
CREATE FOREIGN DATA WRAPPER foo OPTIONS (testing '1');
CREATE FOREIGN DATA WRAPPER foo OPTIONS (testing '1', testing '2');
/* ERROR */ CREATE FOREIGN DATA WRAPPER foo OPTIONS (testing '1', another '2');
SET ROLE regress_test_role;
CREATE FOREIGN DATA WRAPPER foo;
/* ERROR */ RESET ROLE;
CREATE FOREIGN DATA WRAPPER foo VALIDATOR postgresql_fdw_validator;
CREATE FOREIGN DATA WRAPPER test_fdw HANDLER invalid_fdw_handler;
/* ERROR */ CREATE FOREIGN DATA WRAPPER test_fdw HANDLER test_fdw_handler HANDLER invalid_fdw_handler;
/* ERROR */ CREATE FOREIGN DATA WRAPPER test_fdw HANDLER test_fdw_handler;
DROP FOREIGN DATA WRAPPER test_fdw;
/* ALTER FOREIGN DATA WRAPPER */ ALTER FOREIGN DATA WRAPPER foo OPTIONS (nonexistent 'fdw');
/* ERROR */ ALTER FOREIGN DATA WRAPPER foo;
/* ERROR */ ALTER FOREIGN DATA WRAPPER foo VALIDATOR bar;
/* ERROR */ ALTER FOREIGN DATA WRAPPER foo NO VALIDATOR;
ALTER FOREIGN DATA WRAPPER foo OPTIONS (SET c '4');
/* ERROR */ ALTER FOREIGN DATA WRAPPER foo OPTIONS (DROP c);
/* ERROR */ ALTER FOREIGN DATA WRAPPER foo OPTIONS (ADD x '1', DROP x);
ALTER FOREIGN DATA WRAPPER foo OPTIONS (b '4');
ALTER FOREIGN DATA WRAPPER foo OPTIONS (ADD d '5');
/* ERROR */ SET ROLE regress_test_role_super;
ALTER FOREIGN DATA WRAPPER foo OPTIONS (ADD d '5');
/* ERROR */ ALTER FOREIGN DATA WRAPPER foo OWNER TO regress_test_role_super;
ALTER ROLE regress_test_role_super NOSUPERUSER;
SET ROLE regress_test_role_super;
ALTER FOREIGN DATA WRAPPER foo OPTIONS (ADD e '6');
/* ERROR */ RESET ROLE;
/* HANDLER related checks */ ALTER FOREIGN DATA WRAPPER foo HANDLER invalid_fdw_handler;
/* ERROR */ ALTER FOREIGN DATA WRAPPER foo HANDLER test_fdw_handler HANDLER anything;
/* ERROR */ ALTER FOREIGN DATA WRAPPER foo HANDLER test_fdw_handler;
DROP FUNCTION x;
/* DROP FOREIGN DATA WRAPPER */ DROP FOREIGN DATA WRAPPER nonexistent;
/* ERROR */ DROP FOREIGN DATA WRAPPER IF EXISTS nonexistent;
/* ERROR */ SET ROLE regress_test_role_super;
DROP FOREIGN DATA WRAPPER foo;
RESET ROLE;
DROP ROLE regress_test_role_super;
CREATE SERVER s1 FOREIGN DATA WRAPPER foo;
COMMENT ON SERVER s1 IS 'foreign server';
CREATE USER MAPPING FOR current_user SERVER s1;
CREATE USER MAPPING FOR current_user SERVER s1;
/* ERROR */ CREATE USER MAPPING IF NOT EXISTS FOR current_user SERVER s1;
/* ERROR */ SET ROLE regress_test_role;
DROP FOREIGN DATA WRAPPER foo CASCADE;
/* ERROR */ RESET ROLE;
DROP FOREIGN DATA WRAPPER foo CASCADE;
/* ERROR */ CREATE FOREIGN DATA WRAPPER foo OPTIONS ("test wrapper" 'true');
CREATE SERVER s1 FOREIGN DATA WRAPPER foo;
CREATE SERVER s1 FOREIGN DATA WRAPPER foo;
/* ERROR */ CREATE SERVER IF NOT EXISTS s1 FOREIGN DATA WRAPPER foo;
/* No ERROR, just NOTICE */ CREATE SERVER s2 FOREIGN DATA WRAPPER foo OPTIONS (host 'a', dbname 'b');
CREATE SERVER s3 TYPE 'oracle' FOREIGN DATA WRAPPER foo;
CREATE SERVER s4 TYPE 'oracle' FOREIGN DATA WRAPPER foo OPTIONS (host 'a', dbname 'b');
CREATE SERVER s5 VERSION '15.0' FOREIGN DATA WRAPPER foo;
CREATE SERVER s6 VERSION '16.0' FOREIGN DATA WRAPPER foo OPTIONS (host 'a', dbname 'b');
CREATE SERVER s7 TYPE 'oracle' VERSION '17.0' FOREIGN DATA WRAPPER foo OPTIONS (host 'a', dbname 'b');
CREATE SERVER s8 FOREIGN DATA WRAPPER postgresql OPTIONS (foo '1');
/* ERROR */ CREATE SERVER s8 FOREIGN DATA WRAPPER postgresql OPTIONS (host 'localhost', dbname 's8db');
CREATE SERVER t1 FOREIGN DATA WRAPPER foo;
/* ERROR: no usage on FDW */ RESET ROLE;
GRANT USAGE ON FOREIGN DATA WRAPPER foo TO regress_test_role;
SET ROLE regress_test_role;
CREATE SERVER t1 FOREIGN DATA WRAPPER foo;
RESET ROLE;
GRANT USAGE ON FOREIGN DATA WRAPPER foo TO regress_test_indirect;
SET ROLE regress_test_role;
CREATE SERVER t2 FOREIGN DATA WRAPPER foo;
/* ERROR */ RESET ROLE;
GRANT regress_test_indirect TO regress_test_role;
SET ROLE regress_test_role;
CREATE SERVER t2 FOREIGN DATA WRAPPER foo;
REVOKE regress_test_indirect FROM regress_test_role;
/* ALTER SERVER */ ALTER SERVER s0;
/* ERROR */ ALTER SERVER s0 OPTIONS (a '1');
/* ERROR */ ALTER SERVER s1 VERSION '1.0' OPTIONS (servername 's1');
ALTER SERVER s2 VERSION '1.1';
ALTER SERVER s3 OPTIONS ("tns name" 'orcl', port '1521');
GRANT USAGE ON FOREIGN SERVER s1 TO regress_test_role;
GRANT USAGE ON FOREIGN SERVER s6 TO regress_test_role2 WITH GRANT OPTION;
ALTER SERVER s1 VERSION '1.1';
/* ERROR */ ALTER SERVER s1 OWNER TO regress_test_role;
/* ERROR */ RESET ROLE;
ALTER SERVER s1 OWNER TO regress_test_role;
GRANT regress_test_role2 TO regress_test_role;
SET ROLE regress_test_role;
ALTER SERVER s1 VERSION '1.1';
ALTER SERVER s1 OWNER TO regress_test_role2;
/* ERROR */ RESET ROLE;
ALTER SERVER s8 OPTIONS (foo '1');
/* ERROR option validation */ ALTER SERVER s8 OPTIONS (connect_timeout '30', SET dbname 'db1', DROP host);
SET ROLE regress_test_role;
ALTER SERVER s1 OWNER TO regress_test_indirect;
/* ERROR */ RESET ROLE;
GRANT regress_test_indirect TO regress_test_role;
SET ROLE regress_test_role;
ALTER SERVER s1 OWNER TO regress_test_indirect;
RESET ROLE;
GRANT USAGE ON FOREIGN DATA WRAPPER foo TO regress_test_indirect;
SET ROLE regress_test_role;
ALTER SERVER s1 OWNER TO regress_test_indirect;
RESET ROLE;
DROP ROLE regress_test_indirect;
/* DROP SERVER */ DROP SERVER nonexistent;
/* ERROR */ DROP SERVER IF EXISTS nonexistent;
DROP SERVER s2;
/* ERROR */ DROP SERVER s1;
RESET ROLE;
SET ROLE regress_test_role;
DROP SERVER s2;
RESET ROLE;
/* ERROR */ DROP SERVER s3 CASCADE;
/* ERROR */ CREATE USER MAPPING FOR current_user SERVER s1;
/* ERROR */ CREATE USER MAPPING FOR current_user SERVER s4;
CREATE USER MAPPING FOR user SERVER s4;
/* ERROR duplicate */ CREATE USER MAPPING FOR public SERVER s4 OPTIONS ("this mapping" 'is public');
CREATE USER MAPPING FOR user SERVER s8 OPTIONS (username 'test', password 'secret');
/* ERROR */ CREATE USER MAPPING FOR user SERVER s8 OPTIONS (user 'test', password 'secret');
ALTER SERVER s5 OWNER TO regress_test_role;
ALTER SERVER s6 OWNER TO regress_test_indirect;
SET ROLE regress_test_role;
CREATE USER MAPPING FOR current_user SERVER s5;
CREATE USER MAPPING FOR current_user SERVER s6 OPTIONS (username 'test');
CREATE USER MAPPING FOR current_user SERVER s7;
/* ERROR */ CREATE USER MAPPING FOR public SERVER s8;
/* ERROR */ RESET ROLE;
ALTER SERVER t1 OWNER TO regress_test_indirect;
SET ROLE regress_test_role;
CREATE USER MAPPING FOR current_user SERVER t1 OPTIONS (username 'bob', password 'boo');
CREATE USER MAPPING FOR public SERVER t1;
RESET ROLE;
/* ERROR */ ALTER USER MAPPING FOR user SERVER ss4 OPTIONS (gotcha 'true');
/* ERROR */ ALTER USER MAPPING FOR public SERVER s5 OPTIONS (gotcha 'true');
/* ERROR */ ALTER USER MAPPING FOR current_user SERVER s8 OPTIONS (username 'test');
/* ERROR */ ALTER USER MAPPING FOR current_user SERVER s8 OPTIONS (DROP user, SET password 'public');
SET ROLE regress_test_role;
ALTER USER MAPPING FOR current_user SERVER s5 OPTIONS (ADD modified '1');
ALTER USER MAPPING FOR public SERVER s4 OPTIONS (ADD modified '1');
/* ERROR */ ALTER USER MAPPING FOR public SERVER t1 OPTIONS (ADD modified '1');
RESET ROLE;
/* ERROR */ DROP USER MAPPING FOR user SERVER ss4;
DROP USER MAPPING FOR public SERVER s7;
/* ERROR */ DROP USER MAPPING IF EXISTS FOR regress_test_missing_role SERVER s4;
DROP USER MAPPING IF EXISTS FOR user SERVER ss4;
DROP USER MAPPING IF EXISTS FOR public SERVER s7;
CREATE USER MAPPING FOR public SERVER s8;
SET ROLE regress_test_role;
DROP USER MAPPING FOR public SERVER s8;
/* ERROR */ RESET ROLE;
DROP SERVER s7;
CREATE SERVER s0 FOREIGN DATA WRAPPER dummy;
CREATE FOREIGN TABLE ft1 ();
/* ERROR */ CREATE FOREIGN TABLE ft1 () SERVER no_server;
/* ERROR */ CREATE FOREIGN TABLE ft1 ( 	c1 integer OPTIONS ("param 1" 'val1') PRIMARY KEY, 	c2 text OPTIONS (param2 'val2', param3 'val3'), 	c3 date ) SERVER s0 OPTIONS (delimiter ',', quote '"', "be quoted" 'value');
/* ERROR */ CREATE TABLE x (x INT PRIMARY KEY);
CREATE FOREIGN TABLE ft1 ( 	c1 integer OPTIONS ("param 1" 'val1') REFERENCES ref_table (id), 	c2 text OPTIONS (param2 'val2', param3 'val3'), 	c3 date ) SERVER s0 OPTIONS (delimiter ',', quote '"', "be quoted" 'value');
/* ERROR */ DROP TABLE x;
CREATE FOREIGN TABLE ft1 ( 	c1 integer OPTIONS ("param 1" 'val1') NOT NULL, 	c2 text OPTIONS (param2 'val2', param3 'val3'), 	c3 date, 	UNIQUE (c3) ) SERVER s0 OPTIONS (delimiter ',', quote '"', "be quoted" 'value');
/* ERROR */ CREATE FOREIGN TABLE ft1 ( 	c1 integer OPTIONS ("param 1" 'val1') NOT NULL, 	c2 text OPTIONS (param2 'val2', param3 'val3') CHECK (c2 <> ''), 	c3 date, 	CHECK (c3 BETWEEN '1994-01-01'::date AND '1994-01-31'::date) ) SERVER s0 OPTIONS (delimiter ',', quote '"', "be quoted" 'value');
COMMENT ON FOREIGN TABLE ft1 IS 'ft1';
COMMENT ON COLUMN x.x IS 'ft1.c1';
/* ERROR */ SELECT * FROM x;
/* ERROR */ EXPLAIN SELECT * FROM ft1;
/* ERROR */ CREATE TABLE x (x INT) WITH (PARTITIONED_BY=RANGE(x));
CREATE FOREIGN TABLE ft_part1   PARTITION OF lt1 FOR VALUES FROM (0) TO (1000) SERVER s0;
CREATE INDEX ON x(x NULLS LAST);
/* skips partition */ CREATE UNIQUE INDEX ON x(x NULLS LAST);
ALTER TABLE x ADD PRIMARY KEY (x NULLS LAST) /* ERROR */;
/* ERROR */ DROP TABLE x;
CREATE TABLE x (x INT) WITH (PARTITIONED_BY=RANGE(x));
CREATE INDEX ON x(x NULLS LAST);
CREATE FOREIGN TABLE ft_part1   PARTITION OF lt1 FOR VALUES FROM (0) TO (1000) SERVER s0;
CREATE FOREIGN TABLE ft_part2 (a INT) SERVER s0;
ALTER TABLE lt1 ATTACH PARTITION ft_part2 FOR VALUES FROM (1000) TO (2000);
DROP FOREIGN TABLE ft_part1, ft_part2;
CREATE UNIQUE INDEX ON x(x NULLS LAST);
ALTER TABLE x ADD PRIMARY KEY (x NULLS LAST);
CREATE FOREIGN TABLE ft_part1   PARTITION OF lt1 FOR VALUES FROM (0) TO (1000) SERVER s0;
/* ERROR */ CREATE FOREIGN TABLE ft_part2 (a INT NOT NULL) SERVER s0;
ALTER TABLE lt1 ATTACH PARTITION ft_part2   FOR VALUES FROM (1000) TO (2000);
/* ERROR */ DROP TABLE x;
DROP FOREIGN TABLE ft_part2;
CREATE TABLE x (x INT) WITH (PARTITIONED_BY=RANGE(x));
CREATE INDEX ON x(x NULLS LAST);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (0) TO (1000) WITH (PARTITIONED_BY=RANGE(x));
CREATE FOREIGN TABLE ft_part_1_1   PARTITION OF lt1_part1 FOR VALUES FROM (0) TO (100) SERVER s0;
CREATE FOREIGN TABLE ft_part_1_2 (a INT) SERVER s0;
ALTER TABLE lt1_part1 ATTACH PARTITION ft_part_1_2 FOR VALUES FROM (100) TO (200);
CREATE UNIQUE INDEX ON x(x NULLS LAST);
ALTER TABLE x ADD PRIMARY KEY (x NULLS LAST);
DROP FOREIGN TABLE ft_part_1_1, ft_part_1_2;
CREATE UNIQUE INDEX ON x(x NULLS LAST);
ALTER TABLE x ADD PRIMARY KEY (x NULLS LAST);
CREATE FOREIGN TABLE ft_part_1_1   PARTITION OF lt1_part1 FOR VALUES FROM (0) TO (100) SERVER s0;
CREATE FOREIGN TABLE ft_part_1_2 (a INT NOT NULL) SERVER s0;
ALTER TABLE lt1_part1 ATTACH PARTITION ft_part_1_2 FOR VALUES FROM (100) TO (200);
DROP TABLE x;
DROP FOREIGN TABLE ft_part_1_2;
/* ALTER FOREIGN TABLE */ COMMENT ON FOREIGN TABLE ft1 IS 'foreign table';
COMMENT ON FOREIGN TABLE ft1 IS NULL;
COMMENT ON COLUMN x.x IS 'foreign column';
ALTER FOREIGN TABLE ft1 ADD COLUMN c4 integer;
ALTER FOREIGN TABLE ft1 ADD COLUMN c5 integer DEFAULT 0;
ALTER FOREIGN TABLE ft1 ADD COLUMN c6 integer;
ALTER FOREIGN TABLE ft1 ADD COLUMN c7 integer NOT NULL;
ALTER FOREIGN TABLE ft1 ADD COLUMN c8 integer;
ALTER FOREIGN TABLE ft1 ADD COLUMN c9 integer;
ALTER FOREIGN TABLE ft1 ADD COLUMN c10 integer OPTIONS (p1 'v1');
ALTER FOREIGN TABLE ft1 ALTER COLUMN c4 SET DEFAULT 0;
ALTER FOREIGN TABLE ft1 ALTER COLUMN c5 DROP DEFAULT;
ALTER FOREIGN TABLE ft1 ALTER COLUMN c6 SET NOT NULL;
ALTER FOREIGN TABLE ft1 ALTER COLUMN c7 DROP NOT NULL;
ALTER FOREIGN TABLE ft1 ALTER COLUMN c8 TYPE char(10) USING '0';
/* ERROR */ ALTER FOREIGN TABLE ft1 ALTER COLUMN c8 TYPE char(10);
ALTER FOREIGN TABLE ft1 ALTER COLUMN c8 SET DATA TYPE text;
ALTER FOREIGN TABLE ft1 ALTER COLUMN xmin OPTIONS (ADD p1 'v1');
/* ERROR */ ALTER FOREIGN TABLE ft1 ALTER COLUMN c7 OPTIONS (ADD p1 'v1', ADD p2 'v2'),                         ALTER COLUMN c8 OPTIONS (ADD p1 'v1', ADD p2 'v2');
ALTER FOREIGN TABLE ft1 ALTER COLUMN c8 OPTIONS (SET p2 'V2', DROP p1);
ALTER FOREIGN TABLE ft1 ALTER COLUMN c1 SET STATISTICS 10000;
ALTER FOREIGN TABLE ft1 ALTER COLUMN c1 SET (n_distinct = 100);
ALTER FOREIGN TABLE ft1 ALTER COLUMN c8 SET STATISTICS -1;
ALTER FOREIGN TABLE ft1 ALTER COLUMN c8 SET STORAGE PLAIN;
ALTER FOREIGN TABLE ft1 ALTER COLUMN c8 SET DATA TYPE integer;
/* ERROR */ DROP TABLE x;
ALTER FOREIGN TABLE ft1 ADD PRIMARY KEY (c7);
/* ERROR */ ALTER FOREIGN TABLE ft1 ADD CONSTRAINT ft1_c9_check CHECK (c9 < 0) NOT VALID;
ALTER FOREIGN TABLE ft1 ALTER CONSTRAINT ft1_c9_check DEFERRABLE;
/* ERROR */ ALTER FOREIGN TABLE ft1 DROP CONSTRAINT ft1_c9_check;
ALTER FOREIGN TABLE ft1 DROP CONSTRAINT no_const;
/* ERROR */ ALTER FOREIGN TABLE ft1 DROP CONSTRAINT IF EXISTS no_const;
ALTER FOREIGN TABLE ft1 OWNER TO regress_test_role;
ALTER FOREIGN TABLE ft1 OPTIONS (DROP delimiter, SET quote '~', ADD escape '@');
ALTER FOREIGN TABLE ft1 DROP COLUMN no_column;
/* ERROR */ ALTER FOREIGN TABLE ft1 DROP COLUMN IF EXISTS no_column;
ALTER FOREIGN TABLE ft1 DROP COLUMN c9;
ALTER FOREIGN TABLE ft1 ADD COLUMN c11 serial;
ALTER FOREIGN TABLE ft1 SET SCHEMA foreign_schema;
ALTER FOREIGN TABLE ft1 SET TABLESPACE ts;
/* ERROR */ ALTER SEQUENCE foreign_schema.ft1_c11_seq SET SCHEMA public;
/* ERROR */ ALTER FOREIGN TABLE foreign_schema.ft1 RENAME c1 TO foreign_column_1;
ALTER FOREIGN TABLE foreign_schema.ft1 RENAME TO foreign_table_1;
ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 ADD COLUMN c6 integer;
ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 ADD COLUMN c7 integer NOT NULL;
ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 ADD COLUMN c8 integer;
ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 ADD COLUMN c9 integer;
ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 ADD COLUMN c10 integer OPTIONS (p1 'v1');
ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 ALTER COLUMN c6 SET NOT NULL;
ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 ALTER COLUMN c7 DROP NOT NULL;
ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 ALTER COLUMN c8 TYPE char(10);
ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 ALTER COLUMN c8 SET DATA TYPE text;
ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 ALTER COLUMN c7 OPTIONS (ADD p1 'v1', ADD p2 'v2'),                         ALTER COLUMN c8 OPTIONS (ADD p1 'v1', ADD p2 'v2');
ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 ALTER COLUMN c8 OPTIONS (SET p2 'V2', DROP p1);
ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 DROP CONSTRAINT IF EXISTS no_const;
ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 DROP CONSTRAINT ft1_c1_check;
ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 OWNER TO regress_test_role;
ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 OPTIONS (DROP delimiter, SET quote '~', ADD escape '@');
ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 DROP COLUMN IF EXISTS no_column;
ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 DROP COLUMN c9;
ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 SET SCHEMA foreign_schema;
ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 RENAME c1 TO foreign_column_1;
ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 RENAME TO foreign_table_1;
/* Information schema */ SELECT * FROM x.x ORDER BY 1 NULLS LAST, 2 NULLS LAST;
SELECT * FROM x.x ORDER BY 1 NULLS LAST, 2 NULLS LAST, 3 NULLS LAST;
SELECT * FROM x.x ORDER BY 1 NULLS LAST, 2 NULLS LAST;
SELECT * FROM x.x ORDER BY 1 NULLS LAST, 2 NULLS LAST, 3 NULLS LAST;
SELECT * FROM x.x ORDER BY LOWER(x) NULLS LAST, 2 NULLS LAST, 3 NULLS LAST;
SELECT * FROM x.x ORDER BY LOWER(x) NULLS LAST, 2 NULLS LAST, 3 NULLS LAST, 4 NULLS LAST;
SELECT * FROM x.x WHERE x LIKE 'FOREIGN%' AND x IN ('s6', 'foo') ORDER BY 1 NULLS LAST, 2 NULLS LAST, 3 NULLS LAST, 4 NULLS LAST, 5 NULLS LAST;
SELECT * FROM x.x WHERE x LIKE 'FOREIGN%' AND x IN ('s6', 'foo') ORDER BY 1 NULLS LAST, 2 NULLS LAST, 3 NULLS LAST, 4 NULLS LAST, 5 NULLS LAST;
SELECT * FROM x.x ORDER BY 1 NULLS LAST, 2 NULLS LAST, 3 NULLS LAST;
SELECT * FROM x.x ORDER BY 1 NULLS LAST, 2 NULLS LAST, 3 NULLS LAST, 4 NULLS LAST;
SET ROLE regress_test_role;
SELECT * FROM x.x ORDER BY 1 NULLS LAST, 2 NULLS LAST, 3 NULLS LAST, 4 NULLS LAST;
SELECT * FROM x.x WHERE x LIKE 'FOREIGN%' AND x IN ('s6', 'foo') ORDER BY 1 NULLS LAST, 2 NULLS LAST, 3 NULLS LAST, 4 NULLS LAST, 5 NULLS LAST;
SELECT * FROM x.x WHERE x LIKE 'FOREIGN%' AND x IN ('s6', 'foo') ORDER BY 1 NULLS LAST, 2 NULLS LAST, 3 NULLS LAST, 4 NULLS LAST, 5 NULLS LAST;
DROP USER MAPPING FOR current_user SERVER t1;
SET ROLE regress_test_role2;
SELECT * FROM x.x ORDER BY 1 NULLS LAST, 2 NULLS LAST, 3 NULLS LAST, 4 NULLS LAST;
RESET ROLE;
/* has_foreign_data_wrapper_privilege */ SELECT HAS_FOREIGN_DATA_WRAPPER_PRIVILEGE('regress_test_role', (SELECT x FROM x WHERE x = 'foo'), 'USAGE');
SELECT HAS_FOREIGN_DATA_WRAPPER_PRIVILEGE('regress_test_role', 'foo', 'USAGE');
SELECT HAS_FOREIGN_DATA_WRAPPER_PRIVILEGE((SELECT x FROM x WHERE x = 'regress_test_role'), (SELECT x FROM x WHERE x = 'foo'), 'USAGE');
SELECT HAS_FOREIGN_DATA_WRAPPER_PRIVILEGE((SELECT x FROM x WHERE x = 'foo'), 'USAGE');
SELECT HAS_FOREIGN_DATA_WRAPPER_PRIVILEGE((SELECT x FROM x WHERE x = 'regress_test_role'), 'foo', 'USAGE');
SELECT HAS_FOREIGN_DATA_WRAPPER_PRIVILEGE('foo', 'USAGE');
GRANT USAGE ON FOREIGN DATA WRAPPER foo TO regress_test_role;
SELECT HAS_FOREIGN_DATA_WRAPPER_PRIVILEGE('regress_test_role', 'foo', 'USAGE');
/* has_server_privilege */ SELECT HAS_SERVER_PRIVILEGE('regress_test_role', (SELECT x FROM x WHERE x = 's8'), 'USAGE');
SELECT HAS_SERVER_PRIVILEGE('regress_test_role', 's8', 'USAGE');
SELECT HAS_SERVER_PRIVILEGE((SELECT x FROM x WHERE x = 'regress_test_role'), (SELECT x FROM x WHERE x = 's8'), 'USAGE');
SELECT HAS_SERVER_PRIVILEGE((SELECT x FROM x WHERE x = 's8'), 'USAGE');
SELECT HAS_SERVER_PRIVILEGE((SELECT x FROM x WHERE x = 'regress_test_role'), 's8', 'USAGE');
SELECT HAS_SERVER_PRIVILEGE('s8', 'USAGE');
GRANT USAGE ON FOREIGN SERVER s8 TO regress_test_role;
SELECT HAS_SERVER_PRIVILEGE('regress_test_role', 's8', 'USAGE');
REVOKE USAGE ON FOREIGN SERVER s8 FROM regress_test_role;
GRANT USAGE ON FOREIGN SERVER s4 TO regress_test_role;
DROP USER MAPPING FOR public SERVER s4;
ALTER SERVER s6 OPTIONS (DROP host, DROP dbname);
ALTER USER MAPPING FOR regress_test_role SERVER s6 OPTIONS (DROP username);
ALTER FOREIGN DATA WRAPPER foo VALIDATOR postgresql_fdw_validator;
/* Privileges */ SET ROLE regress_unprivileged_role;
CREATE FOREIGN DATA WRAPPER foobar;
/* ERROR */ ALTER FOREIGN DATA WRAPPER foo OPTIONS (gotcha 'true');
/* ERROR */ ALTER FOREIGN DATA WRAPPER foo OWNER TO regress_unprivileged_role;
/* ERROR */ DROP FOREIGN DATA WRAPPER foo;
/* ERROR */ GRANT USAGE ON FOREIGN DATA WRAPPER foo TO regress_test_role;
/* ERROR */ CREATE SERVER s9 FOREIGN DATA WRAPPER foo;
/* ERROR */ ALTER SERVER s4 VERSION '0.5';
/* ERROR */ ALTER SERVER s4 OWNER TO regress_unprivileged_role;
/* ERROR */ DROP SERVER s4;
/* ERROR */ GRANT USAGE ON FOREIGN SERVER s4 TO regress_test_role;
/* ERROR */ CREATE USER MAPPING FOR public SERVER s4;
/* ERROR */ ALTER USER MAPPING FOR regress_test_role SERVER s6 OPTIONS (gotcha 'true');
/* ERROR */ DROP USER MAPPING FOR regress_test_role SERVER s6;
/* ERROR */ RESET ROLE;
GRANT USAGE ON FOREIGN DATA WRAPPER postgresql TO regress_unprivileged_role;
GRANT USAGE ON FOREIGN DATA WRAPPER foo TO regress_unprivileged_role WITH GRANT OPTION;
SET ROLE regress_unprivileged_role;
CREATE FOREIGN DATA WRAPPER foobar;
/* ERROR */ ALTER FOREIGN DATA WRAPPER foo OPTIONS (gotcha 'true');
/* ERROR */ DROP FOREIGN DATA WRAPPER foo;
/* ERROR */ GRANT USAGE ON FOREIGN DATA WRAPPER postgresql TO regress_test_role;
/* WARNING */ GRANT USAGE ON FOREIGN DATA WRAPPER foo TO regress_test_role;
CREATE SERVER s9 FOREIGN DATA WRAPPER postgresql;
ALTER SERVER s6 VERSION '0.5';
/* ERROR */ DROP SERVER s6;
/* ERROR */ GRANT USAGE ON FOREIGN SERVER s6 TO regress_test_role;
/* ERROR */ GRANT USAGE ON FOREIGN SERVER s9 TO regress_test_role;
CREATE USER MAPPING FOR public SERVER s6;
/* ERROR */ CREATE USER MAPPING FOR public SERVER s9;
ALTER USER MAPPING FOR regress_test_role SERVER s6 OPTIONS (gotcha 'true');
/* ERROR */ DROP USER MAPPING FOR regress_test_role SERVER s6;
/* ERROR */ RESET ROLE;
REVOKE USAGE ON FOREIGN DATA WRAPPER foo FROM regress_unprivileged_role;
/* ERROR */ REVOKE USAGE ON FOREIGN DATA WRAPPER foo FROM regress_unprivileged_role CASCADE;
SET ROLE regress_unprivileged_role;
GRANT USAGE ON FOREIGN DATA WRAPPER foo TO regress_test_role;
/* ERROR */ CREATE SERVER s10 FOREIGN DATA WRAPPER foo;
/* ERROR */ ALTER SERVER s9 VERSION '1.1';
GRANT USAGE ON FOREIGN SERVER s9 TO regress_test_role;
CREATE USER MAPPING FOR current_user SERVER s9;
DROP SERVER s9 CASCADE;
RESET ROLE;
CREATE SERVER s9 FOREIGN DATA WRAPPER foo;
GRANT USAGE ON FOREIGN SERVER s9 TO regress_unprivileged_role;
SET ROLE regress_unprivileged_role;
ALTER SERVER s9 VERSION '1.2';
/* ERROR */ GRANT USAGE ON FOREIGN SERVER s9 TO regress_test_role;
/* WARNING */ CREATE USER MAPPING FOR current_user SERVER s9;
DROP SERVER s9 CASCADE;
/* ERROR */ /* Check visibility of user mapping data */ SET ROLE regress_test_role;
CREATE SERVER s10 FOREIGN DATA WRAPPER foo;
CREATE USER MAPPING FOR public SERVER s10 OPTIONS (user 'secret');
CREATE USER MAPPING FOR regress_unprivileged_role SERVER s10 OPTIONS (user 'secret');
DROP SERVER s10 CASCADE;
CREATE TRIGGER trigtest_before_stmt BEFORE INSERT OR UPDATE OR DELETE ON foreign_schema.foreign_table_1 FOR EACH STATEMENT EXECUTE PROCEDURE dummy_trigger();
CREATE TRIGGER trigtest_after_stmt AFTER INSERT OR UPDATE OR DELETE ON foreign_schema.foreign_table_1 FOR EACH STATEMENT EXECUTE PROCEDURE dummy_trigger();
CREATE TRIGGER trigtest_after_stmt_tt AFTER INSERT OR UPDATE OR DELETE -- ERROR ON foreign_schema.foreign_table_1 REFERENCING NEW TABLE AS new_table FOR EACH STATEMENT EXECUTE PROCEDURE dummy_trigger();
CREATE TRIGGER trigtest_before_row BEFORE INSERT OR UPDATE OR DELETE ON foreign_schema.foreign_table_1 FOR EACH ROW EXECUTE PROCEDURE dummy_trigger();
CREATE TRIGGER trigtest_after_row AFTER INSERT OR UPDATE OR DELETE ON foreign_schema.foreign_table_1 FOR EACH ROW EXECUTE PROCEDURE dummy_trigger();
CREATE CONSTRAINT TRIGGER trigtest_constraint AFTER INSERT OR UPDATE OR DELETE ON foreign_schema.foreign_table_1 FOR EACH ROW EXECUTE PROCEDURE dummy_trigger();
ALTER FOREIGN TABLE foreign_schema.foreign_table_1 	DISABLE TRIGGER trigtest_before_stmt;
ALTER FOREIGN TABLE foreign_schema.foreign_table_1 	ENABLE TRIGGER trigtest_before_stmt;
DROP TRIGGER trigtest_before_stmt ON foreign_schema.foreign_table_1;
DROP TRIGGER trigtest_before_row ON foreign_schema.foreign_table_1;
DROP TRIGGER trigtest_after_stmt ON foreign_schema.foreign_table_1;
DROP TRIGGER trigtest_after_row ON foreign_schema.foreign_table_1;
DROP FUNCTION x;
/* Table inheritance */ CREATE TABLE x (x INT NOT NULL, x TEXT, x DATE);
CREATE FOREIGN TABLE ft2 () INHERITS (fd_pt1)   SERVER s0 OPTIONS (delimiter ',', quote '"', "be quoted" 'value');
CREATE FOREIGN TABLE ft3 ( 	c1 integer NOT NULL, 	c2 text, 	c3 date ) INHERITS(ft2)   SERVER s0;
ALTER TABLE x ADD COLUMN x INT DEFAULT 0;
ALTER TABLE x ADD COLUMN x INT;
ALTER TABLE x ADD COLUMN x INT NOT NULL;
ALTER TABLE x ADD COLUMN x INT;
ALTER TABLE x ALTER COLUMN x DROP DEFAULT;
ALTER TABLE x ALTER COLUMN x SET NOT NULL;
ALTER TABLE x ALTER COLUMN x DROP NOT NULL;
ALTER TABLE x ALTER COLUMN x SET DATA TYPE CHAR(10) USING '0';
ALTER TABLE x ALTER COLUMN x SET DATA TYPE CHAR(10) /* ERROR */;
ALTER TABLE x ALTER COLUMN x SET DATA TYPE TEXT;
ALTER TABLE x ALTER COLUMN x DROP DEFAULT, SET STATISTICS 10000;
ALTER TABLE x ALTER COLUMN x DROP DEFAULT, SET (n_distinct = 100);
ALTER TABLE x ALTER COLUMN x DROP DEFAULT, SET STATISTICS -1;
ALTER TABLE x ALTER COLUMN x DROP DEFAULT, SET STORAGE EXTERNAL;
ALTER TABLE x DROP COLUMN x;
ALTER TABLE x DROP COLUMN x;
ALTER TABLE x DROP COLUMN x;
ALTER TABLE x DROP COLUMN x;
ALTER TABLE x ADD CONSTRAINT x CHECK (x <> '');
/* connoinherit should be true for NO INHERIT constraint */ SELECT x, x, x, x, x, x FROM x AS x JOIN x AS x ON (x = x.x) WHERE x.x = 'fd_pt1' ORDER BY 1 NULLS LAST, 2 NULLS LAST;
/* ERROR */ DROP FOREIGN TABLE ft2 CASCADE;
CREATE FOREIGN TABLE ft2 ( 	c1 integer NOT NULL, 	c2 text, 	c3 date ) SERVER s0 OPTIONS (delimiter ',', quote '"', "be quoted" 'value');
/* child must have parent's INHERIT constraints */ ALTER FOREIGN TABLE ft2 INHERIT fd_pt1;
/* ERROR */ ALTER FOREIGN TABLE ft2 ADD CONSTRAINT fd_pt1chk2 CHECK (c2 <> '');
ALTER FOREIGN TABLE ft2 INHERIT fd_pt1;
ALTER TABLE x DROP CONSTRAINT x CASCADE;
/* NOT VALID case */ INSERT INTO x VALUES (1, CAST('fd_pt1' AS TEXT), CAST('1994-01-01' AS DATE));
ALTER TABLE x ADD CONSTRAINT x CHECK (x <> '') NOT VALID;
ALTER TABLE x RENAME COLUMN x TO x;
ALTER TABLE x RENAME COLUMN x TO x;
/* changes name of a constraint recursively */ ALTER TABLE fd_pt1 RENAME CONSTRAINT fd_pt1chk3 TO f2_check;
/* ERROR */ /* DROP FOREIGN TABLE */ DROP FOREIGN TABLE no_table;
/* ERROR */ DROP FOREIGN TABLE IF EXISTS no_table;
DROP FOREIGN TABLE foreign_schema.foreign_table_1;
DROP OWNED BY regress_test_role2;
DROP OWNED BY regress_test_role2 CASCADE;
/* Foreign partition DDL stuff */ CREATE TABLE x (x INT NOT NULL, x TEXT, x DATE) WITH (PARTITIONED_BY=LIST(x));
CREATE FOREIGN TABLE fd_pt2_1 PARTITION OF fd_pt2 FOR VALUES IN (1)   SERVER s0 OPTIONS (delimiter ',', quote '"', "be quoted" 'value');
CREATE FOREIGN TABLE fd_pt2_1 ( 	c1 integer NOT NULL, 	c2 text, 	c3 date, 	c4 char ) SERVER s0 OPTIONS (delimiter ',', quote '"', "be quoted" 'value');
/* ERROR */ DROP FOREIGN TABLE fd_pt2_1;
ALTER TABLE x ALTER COLUMN x SET NOT NULL /* ok to have a partition's own constraints though */;
ALTER TABLE x ADD CONSTRAINT x CHECK (x <> '');
/* partition must have parent's constraints */ ALTER TABLE fd_pt2 DETACH PARTITION fd_pt2_1;
ALTER TABLE x ALTER COLUMN x SET NOT NULL;
/* ERROR */ ALTER FOREIGN TABLE fd_pt2_1 ALTER c2 SET NOT NULL;
ALTER TABLE fd_pt2 ATTACH PARTITION fd_pt2_1 FOR VALUES IN (1);
ALTER TABLE fd_pt2 DETACH PARTITION fd_pt2_1;
ALTER TABLE x ADD CONSTRAINT x CHECK (x > 0);
/* ERROR */ ALTER FOREIGN TABLE fd_pt2_1 ADD CONSTRAINT fd_pt2chk1 CHECK (c1 > 0);
ALTER TABLE fd_pt2 ATTACH PARTITION fd_pt2_1 FOR VALUES IN (1);
DROP FOREIGN TABLE fd_pt2_1;
DROP TABLE x;
/* foreign table cannot be part of partition tree made of temporary */ /* relations. */ CREATE TEMPORARY TABLE x (x INT) WITH (PARTITIONED_BY=LIST(x));
CREATE FOREIGN TABLE foreign_part PARTITION OF temp_parted DEFAULT   SERVER s0;
/* ERROR */ CREATE FOREIGN TABLE foreign_part (a int) SERVER s0;
ALTER TABLE temp_parted ATTACH PARTITION foreign_part DEFAULT;
/* ERROR */ DROP FOREIGN TABLE foreign_part;
DROP TABLE x;
/* Cleanup */ DROP SCHEMA x.x CASCADE;
DROP ROLE regress_test_role;
/* ERROR */ DROP SERVER t1 CASCADE;
DROP USER MAPPING FOR regress_test_role SERVER s6;
DROP FOREIGN DATA WRAPPER foo CASCADE;
DROP SERVER s8 CASCADE;
DROP ROLE regress_test_indirect;
DROP ROLE regress_test_role;
DROP ROLE regress_unprivileged_role;
/* ERROR */ REVOKE ALL ON FOREIGN DATA WRAPPER postgresql FROM regress_unprivileged_role;
DROP ROLE regress_unprivileged_role;
DROP ROLE regress_test_role2;
DROP FOREIGN DATA WRAPPER postgresql CASCADE;
DROP FOREIGN DATA WRAPPER dummy CASCADE;
/* At this point we should have no wrappers, no servers, and no mappings. */ SELECT x, x, x, x FROM x;
SELECT x, x FROM x;
SELECT * FROM x;
/* FOREIGN KEY */ /* MATCH FULL */ /* First test, check and cascade */ CREATE TABLE x (x INT PRIMARY KEY, x TEXT);
CREATE TABLE x (x INT REFERENCES x MATCH FULL ON DELETE CASCADE ON UPDATE CASCADE, x INT);
/* Insert test data into PKTABLE */ INSERT INTO x VALUES (1, 'Test1');
INSERT INTO x VALUES (2, 'Test2');
INSERT INTO x VALUES (3, 'Test3');
INSERT INTO x VALUES (4, 'Test4');
INSERT INTO x VALUES (5, 'Test5');
/* Insert successful rows into FK TABLE */ INSERT INTO x VALUES (1, 2);
INSERT INTO x VALUES (2, 3);
INSERT INTO x VALUES (3, 4);
INSERT INTO x VALUES (NULL, 1);
/* Insert a failed row into FK TABLE */ INSERT INTO x VALUES (100, 2);
/* Check FKTABLE */ SELECT * FROM x;
/* Delete a row from PK TABLE */ DELETE FROM x WHERE x = 1;
/* Check FKTABLE for removal of matched row */ SELECT * FROM x;
/* Update a row from PK TABLE */ UPDATE x SET x = 1 WHERE x = 2;
/* Check FKTABLE for update of matched row */ SELECT * FROM x;
DROP TABLE x;
DROP TABLE x;
/* check set NULL and table constraint on multiple columns */ CREATE TABLE x (x INT, x INT, x TEXT, PRIMARY KEY (x NULLS LAST, x NULLS LAST));
CREATE TABLE x (x INT, x INT, x INT, CONSTRAINT x FOREIGN KEY (x, x) REFERENCES x MATCH FULL ON DELETE SET NULL ON UPDATE SET NULL);
/* Insert test data into PKTABLE */ INSERT INTO x VALUES (1, 2, 'Test1');
INSERT INTO x VALUES (1, 3, 'Test1-2');
INSERT INTO x VALUES (2, 4, 'Test2');
INSERT INTO x VALUES (3, 6, 'Test3');
INSERT INTO x VALUES (4, 8, 'Test4');
INSERT INTO x VALUES (5, 10, 'Test5');
/* Insert successful rows into FK TABLE */ INSERT INTO x VALUES (1, 2, 4);
INSERT INTO x VALUES (1, 3, 5);
INSERT INTO x VALUES (2, 4, 8);
INSERT INTO x VALUES (3, 6, 12);
INSERT INTO x VALUES (NULL, NULL, 0);
/* Insert failed rows into FK TABLE */ INSERT INTO x VALUES (100, 2, 4);
INSERT INTO x VALUES (2, 2, 4);
INSERT INTO x VALUES (NULL, 2, 4);
INSERT INTO x VALUES (1, NULL, 4);
/* Check FKTABLE */ SELECT * FROM x;
/* Delete a row from PK TABLE */ DELETE FROM x WHERE x = 1 AND x = 2;
/* Check FKTABLE for removal of matched row */ SELECT * FROM x;
/* Delete another row from PK TABLE */ DELETE FROM x WHERE x = 5 AND x = 10;
/* Check FKTABLE (should be no change) */ SELECT * FROM x;
/* Update a row from PK TABLE */ UPDATE x SET x = 1 WHERE x = 2;
/* Check FKTABLE for update of matched row */ SELECT * FROM x;
/* Check update with part of key null */ UPDATE x SET x = NULL WHERE x = 1;
/* Check update with old and new key values equal */ UPDATE x SET x = 1 WHERE x = 1;
ALTER TABLE x ALTER COLUMN x SET DATA TYPE BIGINT /* Try altering the column type where foreign keys are involved */;
ALTER TABLE x ALTER COLUMN x SET DATA TYPE BIGINT;
SELECT * FROM x;
SELECT * FROM x;
DROP TABLE x CASCADE;
DROP TABLE x;
/* check set default and table constraint on multiple columns */ CREATE TABLE x (x INT, x INT, x TEXT, PRIMARY KEY (x NULLS LAST, x NULLS LAST));
CREATE TABLE x (x INT DEFAULT -1, x INT DEFAULT -2, x INT, CONSTRAINT x FOREIGN KEY (x, x) REFERENCES x MATCH FULL ON DELETE SET DEFAULT ON UPDATE SET DEFAULT);
/* Insert a value in PKTABLE for default */ INSERT INTO x VALUES (-1, -2, 'The Default!');
/* Insert test data into PKTABLE */ INSERT INTO x VALUES (1, 2, 'Test1');
INSERT INTO x VALUES (1, 3, 'Test1-2');
INSERT INTO x VALUES (2, 4, 'Test2');
INSERT INTO x VALUES (3, 6, 'Test3');
INSERT INTO x VALUES (4, 8, 'Test4');
INSERT INTO x VALUES (5, 10, 'Test5');
/* Insert successful rows into FK TABLE */ INSERT INTO x VALUES (1, 2, 4);
INSERT INTO x VALUES (1, 3, 5);
INSERT INTO x VALUES (2, 4, 8);
INSERT INTO x VALUES (3, 6, 12);
INSERT INTO x VALUES (NULL, NULL, 0);
/* Insert failed rows into FK TABLE */ INSERT INTO x VALUES (100, 2, 4);
INSERT INTO x VALUES (2, 2, 4);
INSERT INTO x VALUES (NULL, 2, 4);
INSERT INTO x VALUES (1, NULL, 4);
/* Check FKTABLE */ SELECT * FROM x;
/* Delete a row from PK TABLE */ DELETE FROM x WHERE x = 1 AND x = 2;
/* Check FKTABLE to check for removal */ SELECT * FROM x;
/* Delete another row from PK TABLE */ DELETE FROM x WHERE x = 5 AND x = 10;
/* Check FKTABLE (should be no change) */ SELECT * FROM x;
/* Update a row from PK TABLE */ UPDATE x SET x = 1 WHERE x = 2;
/* Check FKTABLE for update of matched row */ SELECT * FROM x;
/* this should fail for lack of CASCADE */ DROP TABLE x;
DROP TABLE x CASCADE;
DROP TABLE x;
/* First test, check with no on delete or on update */ CREATE TABLE x (x INT PRIMARY KEY, x TEXT);
CREATE TABLE x (x INT REFERENCES x MATCH FULL, x INT);
/* Insert test data into PKTABLE */ INSERT INTO x VALUES (1, 'Test1');
INSERT INTO x VALUES (2, 'Test2');
INSERT INTO x VALUES (3, 'Test3');
INSERT INTO x VALUES (4, 'Test4');
INSERT INTO x VALUES (5, 'Test5');
/* Insert successful rows into FK TABLE */ INSERT INTO x VALUES (1, 2);
INSERT INTO x VALUES (2, 3);
INSERT INTO x VALUES (3, 4);
INSERT INTO x VALUES (NULL, 1);
/* Insert a failed row into FK TABLE */ INSERT INTO x VALUES (100, 2);
/* Check FKTABLE */ SELECT * FROM x;
/* Check PKTABLE */ SELECT * FROM x;
/* Delete a row from PK TABLE (should fail) */ DELETE FROM x WHERE x = 1;
/* Delete a row from PK TABLE (should succeed) */ DELETE FROM x WHERE x = 5;
/* Check PKTABLE for deletes */ SELECT * FROM x;
/* Update a row from PK TABLE (should fail) */ UPDATE x SET x = 0 WHERE x = 2;
/* Update a row from PK TABLE (should succeed) */ UPDATE x SET x = 0 WHERE x = 4;
/* Check PKTABLE for updates */ SELECT * FROM x;
DROP TABLE x;
DROP TABLE x;
/* Check initial check upon ALTER TABLE */ CREATE TABLE x (x INT, x INT, PRIMARY KEY (x NULLS LAST, x NULLS LAST));
CREATE TABLE x (x INT, x INT);
INSERT INTO x VALUES (1, 2);
INSERT INTO x VALUES (1, NULL);
ALTER TABLE x ADD FOREIGN KEY (x, x) REFERENCES x MATCH FULL;
DROP TABLE x;
DROP TABLE x;
/* MATCH SIMPLE */ /* Base test restricting update/delete */ CREATE TABLE x (x INT, x INT, x INT, x TEXT, PRIMARY KEY (x NULLS LAST, x NULLS LAST, x NULLS LAST));
CREATE TABLE x (x INT, x INT, x INT, x INT, CONSTRAINT x FOREIGN KEY (x, x, x) REFERENCES x);
/* Insert Primary Key values */ INSERT INTO x VALUES (1, 2, 3, 'test1');
INSERT INTO x VALUES (1, 3, 3, 'test2');
INSERT INTO x VALUES (2, 3, 4, 'test3');
INSERT INTO x VALUES (2, 4, 5, 'test4');
/* Insert Foreign Key values */ INSERT INTO x VALUES (1, 2, 3, 1);
INSERT INTO x VALUES (NULL, 2, 3, 2);
INSERT INTO x VALUES (2, NULL, 3, 3);
INSERT INTO x VALUES (NULL, 2, 7, 4);
INSERT INTO x VALUES (NULL, 3, 4, 5);
/* Insert a failed values */ INSERT INTO x VALUES (1, 2, 7, 6);
/* Show FKTABLE */ SELECT * FROM x;
/* Try to update something that should fail */ UPDATE x SET x = 5 WHERE x = 2;
/* Try to update something that should succeed */ UPDATE x SET x = 1 WHERE x = 3;
/* Try to delete something that should fail */ DELETE FROM x WHERE x = 1 AND x = 2 AND x = 3;
/* Try to delete something that should work */ DELETE FROM x WHERE x = 2;
/* Show PKTABLE and FKTABLE */ SELECT * FROM x;
SELECT * FROM x;
DROP TABLE x;
DROP TABLE x;
/* restrict with null values */ CREATE TABLE x (x INT, x INT, x INT, x TEXT, UNIQUE (x, x, x));
CREATE TABLE x (x INT, x INT, x INT, x INT, CONSTRAINT x FOREIGN KEY (x, x, x) REFERENCES x (x, x, x));
INSERT INTO x VALUES (1, 2, 3, 'test1');
INSERT INTO x VALUES (1, 3, NULL, 'test2');
INSERT INTO x VALUES (2, NULL, 4, 'test3');
INSERT INTO x VALUES (1, 2, 3, 1);
DELETE FROM x WHERE x = 2;
SELECT * FROM x;
SELECT * FROM x;
DROP TABLE x;
DROP TABLE x;
/* cascade update/delete */ CREATE TABLE x (x INT, x INT, x INT, x TEXT, PRIMARY KEY (x NULLS LAST, x NULLS LAST, x NULLS LAST));
CREATE TABLE x (x INT, x INT, x INT, x INT, CONSTRAINT x FOREIGN KEY (x, x, x) REFERENCES x ON DELETE CASCADE ON UPDATE CASCADE);
/* Insert Primary Key values */ INSERT INTO x VALUES (1, 2, 3, 'test1');
INSERT INTO x VALUES (1, 3, 3, 'test2');
INSERT INTO x VALUES (2, 3, 4, 'test3');
INSERT INTO x VALUES (2, 4, 5, 'test4');
/* Insert Foreign Key values */ INSERT INTO x VALUES (1, 2, 3, 1);
INSERT INTO x VALUES (NULL, 2, 3, 2);
INSERT INTO x VALUES (2, NULL, 3, 3);
INSERT INTO x VALUES (NULL, 2, 7, 4);
INSERT INTO x VALUES (NULL, 3, 4, 5);
/* Insert a failed values */ INSERT INTO x VALUES (1, 2, 7, 6);
/* Show FKTABLE */ SELECT * FROM x;
/* Try to update something that will cascade */ UPDATE x SET x = 5 WHERE x = 2;
/* Try to update something that should not cascade */ UPDATE x SET x = 1 WHERE x = 3;
/* Show PKTABLE and FKTABLE */ SELECT * FROM x;
SELECT * FROM x;
/* Try to delete something that should cascade */ DELETE FROM x WHERE x = 1 AND x = 5 AND x = 3;
/* Show PKTABLE and FKTABLE */ SELECT * FROM x;
SELECT * FROM x;
/* Try to delete something that should not have a cascade */ DELETE FROM x WHERE x = 2;
/* Show PKTABLE and FKTABLE */ SELECT * FROM x;
SELECT * FROM x;
DROP TABLE x;
DROP TABLE x;
/* set null update / set default delete */ CREATE TABLE x (x INT, x INT, x INT, x TEXT, PRIMARY KEY (x NULLS LAST, x NULLS LAST, x NULLS LAST));
CREATE TABLE x (x INT DEFAULT 0, x INT, x INT, x INT, CONSTRAINT x FOREIGN KEY (x, x, x) REFERENCES x ON DELETE SET DEFAULT ON UPDATE SET NULL);
/* Insert Primary Key values */ INSERT INTO x VALUES (1, 2, 3, 'test1');
INSERT INTO x VALUES (1, 3, 3, 'test2');
INSERT INTO x VALUES (2, 3, 4, 'test3');
INSERT INTO x VALUES (2, 4, 5, 'test4');
/* Insert Foreign Key values */ INSERT INTO x VALUES (1, 2, 3, 1);
INSERT INTO x VALUES (2, 3, 4, 1);
INSERT INTO x VALUES (NULL, 2, 3, 2);
INSERT INTO x VALUES (2, NULL, 3, 3);
INSERT INTO x VALUES (NULL, 2, 7, 4);
INSERT INTO x VALUES (NULL, 3, 4, 5);
/* Insert a failed values */ INSERT INTO x VALUES (1, 2, 7, 6);
/* Show FKTABLE */ SELECT * FROM x;
/* Try to update something that will set null */ UPDATE x SET x = 5 WHERE x = 2;
/* Try to update something that should not set null */ UPDATE x SET x = 2 WHERE x = 3 AND x = 1;
/* Show PKTABLE and FKTABLE */ SELECT * FROM x;
SELECT * FROM x;
/* Try to delete something that should set default */ DELETE FROM x WHERE x = 2 AND x = 3 AND x = 4;
/* Show PKTABLE and FKTABLE */ SELECT * FROM x;
SELECT * FROM x;
/* Try to delete something that should not set default */ DELETE FROM x WHERE x = 5;
/* Show PKTABLE and FKTABLE */ SELECT * FROM x;
SELECT * FROM x;
DROP TABLE x;
DROP TABLE x;
/* set default update / set null delete */ CREATE TABLE x (x INT, x INT, x INT, x TEXT, PRIMARY KEY (x NULLS LAST, x NULLS LAST, x NULLS LAST));
CREATE TABLE x (x INT DEFAULT 0, x INT DEFAULT -1, x INT DEFAULT -2, x INT, CONSTRAINT x FOREIGN KEY (x, x, x) REFERENCES x ON DELETE SET NULL ON UPDATE SET DEFAULT);
/* Insert Primary Key values */ INSERT INTO x VALUES (1, 2, 3, 'test1');
INSERT INTO x VALUES (1, 3, 3, 'test2');
INSERT INTO x VALUES (2, 3, 4, 'test3');
INSERT INTO x VALUES (2, 4, 5, 'test4');
INSERT INTO x VALUES (2, -1, 5, 'test5');
/* Insert Foreign Key values */ INSERT INTO x VALUES (1, 2, 3, 1);
INSERT INTO x VALUES (2, 3, 4, 1);
INSERT INTO x VALUES (2, 4, 5, 1);
INSERT INTO x VALUES (NULL, 2, 3, 2);
INSERT INTO x VALUES (2, NULL, 3, 3);
INSERT INTO x VALUES (NULL, 2, 7, 4);
INSERT INTO x VALUES (NULL, 3, 4, 5);
/* Insert a failed values */ INSERT INTO x VALUES (1, 2, 7, 6);
/* Show FKTABLE */ SELECT * FROM x;
/* Try to update something that will fail */ UPDATE x SET x = 5 WHERE x = 2;
/* Try to update something that will set default */ UPDATE x SET x = 0, x = -1, x = -2 WHERE x = 2;
UPDATE x SET x = 10 WHERE x = 4;
/* Try to update something that should not set default */ UPDATE x SET x = 2 WHERE x = 3 AND x = 1;
/* Show PKTABLE and FKTABLE */ SELECT * FROM x;
SELECT * FROM x;
/* Try to delete something that should set null */ DELETE FROM x WHERE x = 2 AND x = 3 AND x = 4;
/* Show PKTABLE and FKTABLE */ SELECT * FROM x;
SELECT * FROM x;
/* Try to delete something that should not set null */ DELETE FROM x WHERE x = -1 AND x = 5;
/* Show PKTABLE and FKTABLE */ SELECT * FROM x;
SELECT * FROM x;
DROP TABLE x;
DROP TABLE x;
CREATE TABLE x (x INT, x INT, PRIMARY KEY (x NULLS LAST, x NULLS LAST));
SELECT PG_GET_CONSTRAINTDEF(x) FROM x WHERE x = CAST(CAST('fktable' AS REGCLASS) AS OID) ORDER BY x NULLS LAST;
INSERT INTO x VALUES (1, 0), (1, 1), (1, 2);
INSERT INTO x VALUES (1, 1, 1, NULL), (1, 2, NULL, 2);
DELETE FROM x WHERE x = 1 OR x = 2;
SELECT * FROM x ORDER BY x NULLS LAST;
DROP TABLE x;
DROP TABLE x;
/* Test some invalid FK definitions */ CREATE TABLE x (x INT PRIMARY KEY, x OID);
CREATE TABLE x (x INT, CONSTRAINT x FOREIGN KEY (x) REFERENCES x);
CREATE TABLE x (x INT, CONSTRAINT x FOREIGN KEY (x) REFERENCES x (x));
CREATE TABLE x (x INT, CONSTRAINT x FOREIGN KEY (x) REFERENCES x (x));
CREATE TABLE x (x OID, CONSTRAINT x FOREIGN KEY (x) REFERENCES x (x));
DROP TABLE x;
/* Test for referencing column number smaller than referenced constraint */ CREATE TABLE x (x INT, x INT, UNIQUE (x, x));
CREATE TABLE x (x INT REFERENCES x (x));
DROP TABLE x;
DROP TABLE x;
/* Tests for mismatched types */ /* Basic one column, two table setup */ CREATE TABLE x (x INT PRIMARY KEY);
INSERT INTO x VALUES (42);
/* This next should fail, because int=inet does not exist */ CREATE TABLE x (x INET REFERENCES x);
/* This should also fail for the same reason, but here we */ /* give the column name */ CREATE TABLE x (x INET REFERENCES x (x));
/* This should succeed, even though they are different types, */ /* because int=int8 exists and is a member of the integer opfamily */ CREATE TABLE x (x BIGINT REFERENCES x);
/* Check it actually works */ INSERT INTO x VALUES (42);
/* should succeed */ INSERT INTO x VALUES (43);
/* should fail */ UPDATE x SET x = x;
/* should succeed */ UPDATE x SET x = x + 1;
/* should fail */ DROP TABLE x;
/* This should fail, because we'd have to cast numeric to int which is */ /* not an implicit coercion (or use numeric=numeric, but that's not part */ /* of the integer opfamily) */ CREATE TABLE x (x DECIMAL REFERENCES x);
DROP TABLE x;
/* On the other hand, this should work because int implicitly promotes to */ /* numeric, and we allow promotion on the FK side */ CREATE TABLE x (x DECIMAL PRIMARY KEY);
INSERT INTO x VALUES (42);
CREATE TABLE x (x INT REFERENCES x);
/* Check it actually works */ INSERT INTO x VALUES (42);
/* should succeed */ INSERT INTO x VALUES (43);
/* should fail */ UPDATE x SET x = x;
/* should succeed */ UPDATE x SET x = x + 1;
/* should fail */ DROP TABLE x;
DROP TABLE x;
/* Two columns, two tables */ CREATE TABLE x (x INT, x INET, PRIMARY KEY (x NULLS LAST, x NULLS LAST));
/* This should fail, because we just chose really odd types */ CREATE TABLE x (x cidr, x TIMESTAMP, FOREIGN KEY (x, x) REFERENCES x);
/* Again, so should this... */ CREATE TABLE x (x cidr, x TIMESTAMP, FOREIGN KEY (x, x) REFERENCES x (x, x));
/* This fails because we mixed up the column ordering */ CREATE TABLE x (x INT, x INET, FOREIGN KEY (x, x) REFERENCES x);
/* As does this... */ CREATE TABLE x (x INT, x INET, FOREIGN KEY (x, x) REFERENCES x (x, x));
/* And again.. */ CREATE TABLE x (x INT, x INET, FOREIGN KEY (x, x) REFERENCES x (x, x));
/* This works... */ CREATE TABLE x (x INT, x INET, FOREIGN KEY (x, x) REFERENCES x (x, x));
DROP TABLE x;
/* As does this */ CREATE TABLE x (x INT, x INET, FOREIGN KEY (x, x) REFERENCES x (x, x));
DROP TABLE x;
DROP TABLE x;
/* Two columns, same table */ /* Make sure this still works... */ CREATE TABLE x (x INT, x INET, x INT, x INET, PRIMARY KEY (x NULLS LAST, x NULLS LAST), FOREIGN KEY (x, x) REFERENCES x (x, x));
DROP TABLE x;
/* And this, */ CREATE TABLE x (x INT, x INET, x INT, x INET, PRIMARY KEY (x NULLS LAST, x NULLS LAST), FOREIGN KEY (x, x) REFERENCES x);
DROP TABLE x;
/* This shouldn't (mixed up columns) */ CREATE TABLE x (x INT, x INET, x INT, x INET, PRIMARY KEY (x NULLS LAST, x NULLS LAST), FOREIGN KEY (x, x) REFERENCES x (x, x));
/* Nor should this... (same reason, we have 4,3 referencing 1,2 which mismatches types */ CREATE TABLE x (x INT, x INET, x INT, x INET, PRIMARY KEY (x NULLS LAST, x NULLS LAST), FOREIGN KEY (x, x) REFERENCES x (x, x));
/* Not this one either... Same as the last one except we didn't defined the columns being referenced. */ CREATE TABLE x (x INT, x INET, x INT, x INET, PRIMARY KEY (x NULLS LAST, x NULLS LAST), FOREIGN KEY (x, x) REFERENCES x);
/* Now some cases with inheritance */ /* Basic 2 table case: 1 column of matching types. */ CREATE TABLE x (x INT NOT NULL);
CREATE TABLE x (x INT, PRIMARY KEY (x NULLS LAST), UNIQUE (x, x)) INHERITS (x);
CREATE TABLE x (x INT REFERENCES x (x));
/* now some ins, upd, del */ INSERT INTO x (x) VALUES (1);
INSERT INTO x (x) VALUES (2);
/*  let's insert a non-existent fktable value */ INSERT INTO x (x) VALUES (3);
/*  let's make a valid row for that */ INSERT INTO x (x) VALUES (3);
INSERT INTO x (x) VALUES (3);
/* let's try removing a row that should fail from pktable */ DELETE FROM x WHERE x > 2;
/* okay, let's try updating all of the base1 values to *4 */ /* which should fail. */ UPDATE x SET x = x * 4;
/* okay, let's try an update that should work. */ UPDATE x SET x = x * 4 WHERE x < 3;
/* and a delete that should work */ DELETE FROM x WHERE x > 3;
/* cleanup */ DROP TABLE x;
DELETE FROM x;
/* Now 2 columns 2 tables, matching types */ CREATE TABLE x (x INT, x INT, FOREIGN KEY (x, x) REFERENCES x (x, x));
/* now some ins, upd, del */ INSERT INTO x (x, x) VALUES (1, 1);
INSERT INTO x (x, x) VALUES (2, 2);
/*  let's insert a non-existent fktable value */ INSERT INTO x (x, x) VALUES (3, 1);
/*  let's make a valid row for that */ INSERT INTO x (x, x) VALUES (3, 1);
INSERT INTO x (x, x) VALUES (3, 1);
/* let's try removing a row that should fail from pktable */ DELETE FROM x WHERE x > 2;
/* okay, let's try updating all of the base1 values to *4 */ /* which should fail. */ UPDATE x SET x = x * 4;
/* okay, let's try an update that should work. */ UPDATE x SET x = x * 4 WHERE x < 3;
/* and a delete that should work */ DELETE FROM x WHERE x > 3;
/* cleanup */ DROP TABLE x;
DROP TABLE x;
DROP TABLE x;
/* Now we'll do one all in 1 table with 2 columns of matching types */ CREATE TABLE x (x INT NOT NULL, x INT);
CREATE TABLE x (x INT, x INT, PRIMARY KEY (x NULLS LAST, x NULLS LAST), FOREIGN KEY (x, x) REFERENCES x (x, x)) INHERITS (x);
INSERT INTO x (x, x, x, x) VALUES (1, 1, 1, 1);
INSERT INTO x (x, x, x, x) VALUES (2, 1, 1, 1);
INSERT INTO x (x, x, x, x) VALUES (2, 2, 2, 1);
INSERT INTO x (x, x, x, x) VALUES (1, 3, 2, 2);
/* fails (3,2) isn't in base1, ptest1 */ INSERT INTO x (x, x, x, x) VALUES (2, 3, 3, 2);
/* fails (2,2) is being referenced */ DELETE FROM x WHERE x = 2;
/* fails (1,1) is being referenced (twice) */ UPDATE x SET x = 3 WHERE x = 1;
/* this sequence of two deletes will work, since after the first there will be no (2,*) references */ DELETE FROM x WHERE x = 2;
DELETE FROM x WHERE x = 2;
DROP TABLE x;
DROP TABLE x;
/* 2 columns (2 tables), mismatched types */ CREATE TABLE x (x INT NOT NULL);
CREATE TABLE x (x INET, PRIMARY KEY (x NULLS LAST, x NULLS LAST)) INHERITS (x);
/* just generally bad types (with and without column references on the referenced table) */ CREATE TABLE x (x cidr, x ARRAY<INT>, FOREIGN KEY (x, x) REFERENCES x);
CREATE TABLE x (x cidr, x ARRAY<INT>, FOREIGN KEY (x, x) REFERENCES x (x, x));
/* let's mix up which columns reference which */ CREATE TABLE x (x INT, x INET, FOREIGN KEY (x, x) REFERENCES x);
CREATE TABLE x (x INT, x INET, FOREIGN KEY (x, x) REFERENCES x (x, x));
CREATE TABLE x (x INT, x INET, FOREIGN KEY (x, x) REFERENCES x (x, x));
DROP TABLE x;
DROP TABLE x;
/* 2 columns (1 table), mismatched types */ CREATE TABLE x (x INT NOT NULL, x INT);
CREATE TABLE x (x INET, x ARRAY<INET>, PRIMARY KEY (x NULLS LAST, x NULLS LAST), FOREIGN KEY (x, x) REFERENCES x (x, x)) INHERITS (x);
CREATE TABLE x (x INET, x INET, PRIMARY KEY (x NULLS LAST, x NULLS LAST), FOREIGN KEY (x, x) REFERENCES x (x, x)) INHERITS (x);
CREATE TABLE x (x INET, x INET, PRIMARY KEY (x NULLS LAST, x NULLS LAST), FOREIGN KEY (x, x) REFERENCES x (x, x)) INHERITS (x);
CREATE TABLE x (x INET, x INET, PRIMARY KEY (x NULLS LAST, x NULLS LAST), FOREIGN KEY (x, x) REFERENCES x (x, x)) INHERITS (x);
DROP TABLE x;
DROP TABLE x;
/* Deferrable constraints */ /* deferrable, explicitly deferred */ CREATE TABLE x (x INT PRIMARY KEY, x INT);
CREATE TABLE x (x INT PRIMARY KEY, x INT REFERENCES x DEFERRABLE);
/* default to immediate: should fail */ INSERT INTO x VALUES (5, 10);
/* explicitly defer the constraint */ BEGIN;
SET CONSTRAINTS ALL DEFERRED;
INSERT INTO x VALUES (10, 15);
INSERT INTO x VALUES (15, 0);
COMMIT /* make the FK insert valid */ /* make the FK insert valid */;
/* deferrable, initially deferred */ CREATE TABLE x (x INT PRIMARY KEY, x INT);
CREATE TABLE x (x INT PRIMARY KEY, x INT REFERENCES x DEFERRABLE INITIALLY DEFERRED);
/* default to deferred, should succeed */ BEGIN;
INSERT INTO x VALUES (100, 200);
INSERT INTO x VALUES (200, 500);
COMMIT /* make the FK insert valid */ /* make the FK insert valid */;
/* default to deferred, explicitly make immediate */ BEGIN;
SET CONSTRAINTS ALL IMMEDIATE;
/* should fail */ INSERT INTO x VALUES (500, 1000);
COMMIT;
/* tricky behavior: according to SQL99, if a deferred constraint is set */ /* to 'immediate' mode, it should be checked for validity *immediately*, */ /* not when the current transaction commits (i.e. the mode change applies */ /* retroactively) */ CREATE TABLE x (x INT PRIMARY KEY, x INT);
CREATE TABLE x (x INT PRIMARY KEY, x INT REFERENCES x DEFERRABLE);
BEGIN;
SET CONSTRAINTS ALL DEFERRED;
/* should succeed, for now */ INSERT INTO x VALUES (1000, 2000);
/* should cause transaction abort, due to preceding error */ SET CONSTRAINTS ALL IMMEDIATE;
INSERT INTO x VALUES (2000, 3);
COMMIT /* too late */ /* too late */;
/* deferrable, initially deferred */ CREATE TABLE x (x INT PRIMARY KEY, x INT);
CREATE TABLE x (x INT PRIMARY KEY, x INT REFERENCES x DEFERRABLE INITIALLY DEFERRED);
BEGIN;
/* no error here */ INSERT INTO x VALUES (100, 200);
COMMIT /* error here on commit */ /* error here on commit */;
/* test notice about expensive referential integrity checks, */ /* where the index cannot be used because of type incompatibilities. */ CREATE TEMPORARY TABLE x (x INT PRIMARY KEY, x VARCHAR(4) UNIQUE, x FLOAT UNIQUE, UNIQUE (x, x, x));
CREATE TEMPORARY TABLE x (x INT REFERENCES x (x), x VARCHAR(4) REFERENCES x (x), x FLOAT REFERENCES x (x), x TEXT, x SMALLINT);
ALTER TABLE x ADD CONSTRAINT x FOREIGN KEY (x) REFERENCES x (x) /* check individual constraints with alter table. */ /* should fail */ /* varchar does not promote to real */;
ALTER TABLE x ADD CONSTRAINT x FOREIGN KEY (x) REFERENCES x (x) /* nor to int4 */;
ALTER TABLE x ADD CONSTRAINT x FOREIGN KEY (x) REFERENCES x (x) /* real does not promote to int4 */;
ALTER TABLE x ADD CONSTRAINT x FOREIGN KEY (x) REFERENCES x (x) /* int4 does not promote to text */;
ALTER TABLE x ADD CONSTRAINT x FOREIGN KEY (x) REFERENCES x (x) /* should succeed */ /* int4 promotes to real */;
ALTER TABLE x ADD CONSTRAINT x FOREIGN KEY (x) REFERENCES x (x) /* text is compatible with varchar */;
ALTER TABLE x ADD CONSTRAINT x FOREIGN KEY (x) REFERENCES x (x) /* int2 is part of integer opfamily as of 8.0 */;
ALTER TABLE x ADD CONSTRAINT x FOREIGN KEY (x, x, x) REFERENCES x (x, x, x) /* check multikey cases, especially out-of-order column lists */ /* these should work */;
ALTER TABLE x ADD CONSTRAINT x FOREIGN KEY (x, x, x) REFERENCES x (x, x, x);
ALTER TABLE x ADD CONSTRAINT x FOREIGN KEY (x, x, x) REFERENCES x (x, x, x);
ALTER TABLE x ADD CONSTRAINT x FOREIGN KEY (x, x, x) REFERENCES x (x, x, x) /* these should fail */;
ALTER TABLE x ADD CONSTRAINT x FOREIGN KEY (x, x, x) REFERENCES x (x, x, x);
/* test a tricky case: we can elide firing the FK check trigger during */ /* an UPDATE if the UPDATE did not change the foreign key */ /* field. However, we can't do this if our transaction was the one that */ /* created the updated row and the trigger is deferred, since our UPDATE */ /* will have invalidated the original newly-inserted tuple, and therefore */ /* cause the on-INSERT RI trigger not to be fired. */ CREATE TEMPORARY TABLE x (x INT PRIMARY KEY, x INT);
CREATE TEMPORARY TABLE x (x INT PRIMARY KEY, x INT REFERENCES x DEFERRABLE INITIALLY DEFERRED);
INSERT INTO x VALUES (5, 10);
BEGIN;
/* doesn't match PK, but no error yet */ INSERT INTO x VALUES (0, 20);
/* don't change FK */ UPDATE x SET x = x + 1;
COMMIT /* should catch error from initial INSERT */ /* should catch error from initial INSERT */;
/* check same case when insert is in a different subtransaction than update */ BEGIN;
/* doesn't match PK, but no error yet */ INSERT INTO x VALUES (0, 20);
x AS x /* UPDATE will be in a subxact */;
/* don't change FK */ UPDATE x SET x = x + 1;
COMMIT /* should catch error from initial INSERT */ /* should catch error from initial INSERT */;
BEGIN;
x AS x /* INSERT will be in a subxact */;
/* doesn't match PK, but no error yet */ INSERT INTO x VALUES (0, 20);
/* don't change FK */ UPDATE x SET x = x + 1;
COMMIT /* should catch error from initial INSERT */ /* should catch error from initial INSERT */;
BEGIN;
/* doesn't match PK, but no error yet */ INSERT INTO x VALUES (0, 20);
x AS x /* UPDATE will be in a subxact */;
/* don't change FK */ UPDATE x SET x = x + 1;
ROLLBACK TO x /* Roll back the UPDATE */;
COMMIT /* should catch error from initial INSERT */ /* should catch error from initial INSERT */;
/* check ALTER CONSTRAINT */ INSERT INTO x VALUES (1, 5);
ALTER TABLE fktable ALTER CONSTRAINT fktable_fk_fkey DEFERRABLE INITIALLY IMMEDIATE;
BEGIN;
/* doesn't match FK, should throw error now */ UPDATE x SET x = 10 WHERE x = 5;
COMMIT;
BEGIN;
/* doesn't match PK, should throw error now */ INSERT INTO x VALUES (0, 20);
COMMIT;
/* try additional syntax */ ALTER TABLE fktable ALTER CONSTRAINT fktable_fk_fkey NOT DEFERRABLE;
/* illegal options */ ALTER TABLE fktable ALTER CONSTRAINT fktable_fk_fkey NOT DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE fktable ALTER CONSTRAINT fktable_fk_fkey NO INHERIT;
ALTER TABLE x ALTER COLUMN x SET DATA TYPE fktable_fk_fkey NOT VALID;
/* test order of firing of FK triggers when several RI-induced changes need to */ /* be made to the same row.  This was broken by subtransaction-related */ /* changes in 8.0. */ CREATE TEMPORARY TABLE x (x INT PRIMARY KEY, x VARCHAR NOT NULL);
INSERT INTO x VALUES (1, 'Jozko');
INSERT INTO x VALUES (2, 'Ferko');
INSERT INTO x VALUES (3, 'Samko');
CREATE TEMPORARY TABLE x (x INT PRIMARY KEY, x INT REFERENCES x ON UPDATE CASCADE ON DELETE SET NULL, x INT REFERENCES x ON UPDATE CASCADE ON DELETE SET NULL, x INT REFERENCES x ON UPDATE CASCADE ON DELETE SET NULL);
INSERT INTO x VALUES (1, 1, NULL, NULL);
INSERT INTO x VALUES (2, 2, 2, NULL);
INSERT INTO x VALUES (3, 3, 3, 3);
SELECT * FROM x;
UPDATE x SET x = 4 WHERE x = 3;
SELECT * FROM x;
DELETE FROM x WHERE x = 4;
SELECT * FROM x;
/* could fail with only 2 changes to make, if row was already updated */ BEGIN;
UPDATE x SET x = x WHERE x = 2;
SELECT * FROM x;
DELETE FROM x WHERE x = 2;
SELECT * FROM x;
COMMIT;
/* Test self-referential FK with CASCADE (bug #6268) */ CREATE TEMPORARY TABLE x (x INT PRIMARY KEY, x INT, FOREIGN KEY (x) REFERENCES x (x) ON update CASCADE ON delete CASCADE);
INSERT INTO x (x, x) VALUES (0, 0), (1, 1);
BEGIN;
UPDATE x SET x = 123 WHERE x = 0;
SELECT x, x FROM x;
UPDATE x SET x = 456 WHERE x = 123;
SELECT x, x FROM x;
COMMIT;
/* Test that SET DEFAULT actions recognize updates to default values */ CREATE TEMPORARY TABLE x (x INT PRIMARY KEY);
CREATE TEMPORARY TABLE x (x INT DEFAULT 0 REFERENCES x ON delete SET DEFAULT);
INSERT INTO x VALUES (0), (1), (2);
INSERT INTO x VALUES (2);
SELECT * FROM x;
DELETE FROM x WHERE x = 2;
SELECT * FROM x;
DELETE FROM x WHERE x = 0;
ALTER TABLE x ALTER COLUMN x SET DEFAULT 1 /* fail */;
DELETE FROM x WHERE x = 0;
SELECT * FROM x;
DELETE FROM x WHERE x = 1;
/* fail */ /* Test the difference between NO ACTION and RESTRICT */ CREATE TEMPORARY TABLE x (x INT PRIMARY KEY);
CREATE TEMPORARY TABLE x (x INT REFERENCES x ON update NO ACTION ON delete NO ACTION);
INSERT INTO x VALUES (12);
INSERT INTO x VALUES (11);
UPDATE x SET x = x + 1;
INSERT INTO x VALUES (13);
UPDATE x SET x = x + 1;
UPDATE x SET x = x + 1;
/* fail */ DELETE FROM x WHERE x = 13;
CREATE TEMPORARY TABLE x (x INT PRIMARY KEY);
CREATE TEMPORARY TABLE x (x INT REFERENCES x ON update RESTRICT ON delete RESTRICT);
INSERT INTO x VALUES (12);
INSERT INTO x VALUES (11);
UPDATE x SET x = x + 1;
INSERT INTO x VALUES (13);
UPDATE x SET x = x + 1;
/* fail */ DELETE FROM x WHERE x = 13;
/* Test interaction of foreign-key optimization with rules (bug #14219) */ CREATE TEMPORARY TABLE x (x INT PRIMARY KEY, x TEXT);
CREATE TEMPORARY TABLE x (x INT PRIMARY KEY, x INT REFERENCES x);
create rule r1 as on delete to t1 do delete from t2 where t2.b = old.a;
EXPLAIN (costs off) delete from t1 where a = 1;
DELETE FROM x WHERE x = 1;
/* Test a primary key with attributes located in later attnum positions */ /* compared to the fk attributes. */ CREATE TABLE x (x INT, x INT, x INT, x INT, x INT, PRIMARY KEY (x NULLS LAST, x NULLS LAST));
CREATE TABLE x (x INT, x INT, FOREIGN KEY (x, x) REFERENCES x);
INSERT INTO x VALUES (1, 2, 3, 4, 5);
INSERT INTO x VALUES (4, 5);
DELETE FROM x;
UPDATE x SET x = 5;
/* Test truncation of long foreign key names */ CREATE TABLE x (x INT PRIMARY KEY);
CREATE TABLE x (x INT, x INT, PRIMARY KEY (x NULLS LAST, x NULLS LAST));
CREATE TABLE x (x INT, x INT, x INT, FOREIGN KEY (x) REFERENCES x, FOREIGN KEY (x, x) REFERENCES x, FOREIGN KEY (x, x) REFERENCES x);
SELECT x FROM x WHERE x = CAST('fktable2' AS REGCLASS) ORDER BY x NULLS LAST;
/* Test deferred FK check on a tuple deleted by a rolled-back subtransaction */ CREATE TABLE x (x INT PRIMARY KEY);
CREATE TABLE x (x INT REFERENCES x DEFERRABLE INITIALLY DEFERRED);
INSERT INTO x VALUES (1);
BEGIN;
INSERT INTO x VALUES (1);
x AS x;
DELETE FROM x;
ROLLBACK TO x;
COMMIT;
BEGIN;
INSERT INTO x VALUES (2);
x AS x;
DELETE FROM x;
ROLLBACK TO x;
COMMIT;
/* fail */ /* Test that we prevent dropping FK constraint with pending trigger events */ BEGIN;
INSERT INTO x VALUES (2);
ALTER TABLE x DROP CONSTRAINT x;
COMMIT;
BEGIN;
DELETE FROM x WHERE x = 1;
ALTER TABLE x DROP CONSTRAINT x;
COMMIT;
/* Test keys that "look" different but compare as equal */ CREATE TABLE x (x DOUBLE, x DOUBLE, PRIMARY KEY (x NULLS LAST, x NULLS LAST));
CREATE TABLE x (x DOUBLE, x DOUBLE, FOREIGN KEY (x, x) REFERENCES x (x, x) ON update CASCADE);
INSERT INTO x VALUES ('-0', '-0');
INSERT INTO x VALUES ('-0', '-0');
SELECT * FROM x;
SELECT * FROM x;
UPDATE x SET x = '0' WHERE x = '-0';
SELECT * FROM x;
/* should have updated fktable2.x */ SELECT * FROM x;
/* Foreign keys and partitioned tables */ /* Creation of a partitioned hierarchy with irregular definitions */ CREATE TABLE x (x INT, x INT, x INT, x INT, PRIMARY KEY (x NULLS LAST, x NULLS LAST));
ALTER TABLE x DROP COLUMN x, DROP COLUMN x;
CREATE TABLE x (x INT, x INT, x INT) WITH (PARTITIONED_BY=RANGE(x, x));
ALTER TABLE x DROP COLUMN x;
CREATE TABLE x (x INT, x INT, x INT, x INT, x INT);
ALTER TABLE x DROP COLUMN x, DROP COLUMN x, DROP COLUMN x;
ALTER TABLE fk_partitioned_fk ATTACH PARTITION fk_partitioned_fk_1 FOR VALUES FROM (0,0) TO (1000,1000);
ALTER TABLE x ADD FOREIGN KEY (x, x) REFERENCES x;
CREATE TABLE x (x INT, x INT, x INT, x INT);
ALTER TABLE x DROP COLUMN x, DROP COLUMN x;
ALTER TABLE fk_partitioned_fk ATTACH PARTITION fk_partitioned_fk_2 FOR VALUES FROM (1000,1000) TO (2000,2000);
CREATE TABLE x (x INT, x INT, x INT, x INT, x INT, x INT) WITH (PARTITIONED_BY=HASH(x));
ALTER TABLE x DROP COLUMN x, DROP COLUMN x, DROP COLUMN x, DROP COLUMN x;
CREATE TABLE x PARTITION OF x FOR VALUES WITH (MODULUS 5, REMAINDER 0);
CREATE TABLE x PARTITION OF x FOR VALUES WITH (MODULUS 5, REMAINDER 1);
ALTER TABLE fk_partitioned_fk ATTACH PARTITION fk_partitioned_fk_3   FOR VALUES FROM (2000,2000) TO (3000,3000);
ALTER TABLE ONLY x ADD FOREIGN KEY (x, x) REFERENCES x /* Creating a foreign key with ONLY on a partitioned table referencing */ /* a non-partitioned table fails. */;
/* these inserts, targeting both the partition directly as well as the */ /* partitioned table, should all fail */ INSERT INTO x (x, x) VALUES (500, 501);
INSERT INTO x (x, x) VALUES (500, 501);
INSERT INTO x (x, x) VALUES (1500, 1501);
INSERT INTO x (x, x) VALUES (1500, 1501);
INSERT INTO x (x, x) VALUES (2500, 2502);
INSERT INTO x (x, x) VALUES (2500, 2502);
INSERT INTO x (x, x) VALUES (2501, 2503);
INSERT INTO x (x, x) VALUES (2501, 2503);
/* but if we insert the values that make them valid, then they work */ INSERT INTO x VALUES (500, 501), (1500, 1501), (2500, 2502), (2501, 2503);
INSERT INTO x (x, x) VALUES (500, 501);
INSERT INTO x (x, x) VALUES (1500, 1501);
INSERT INTO x (x, x) VALUES (2500, 2502);
INSERT INTO x (x, x) VALUES (2501, 2503);
/* this update fails because there is no referenced row */ UPDATE x SET x = x + 1 WHERE x = 2501;
/* but we can fix it thusly: */ INSERT INTO x (x, x) VALUES (2502, 2503);
UPDATE x SET x = x + 1 WHERE x = 2501;
UPDATE x SET x = 1502 WHERE x = 1500;
UPDATE x SET x = 2504 WHERE x = 2500;
/* Altering a type referenced by a foreign key needs to drop/recreate the FK. */ /* Ensure that works. */ CREATE TABLE x (x INT, PRIMARY KEY (x NULLS LAST), CHECK (x > 0));
CREATE TABLE x (x INT REFERENCES x (x) PRIMARY KEY) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (MINVALUE) TO (MAXVALUE);
INSERT INTO x VALUES (1);
INSERT INTO x VALUES (1);
ALTER TABLE x ALTER COLUMN x SET DATA TYPE BIGINT;
DELETE FROM x WHERE x = 1;
/* NOT VALID foreign keys on partitioned table */ CREATE TABLE x (x INT, x INT, PRIMARY KEY (x NULLS LAST, x NULLS LAST));
CREATE TABLE x (x INT, x INT) WITH (PARTITIONED_BY=RANGE(x, x));
ALTER TABLE x ADD FOREIGN KEY (x, x) REFERENCES x NOT VALID;
/* Attaching a child table with the same valid foreign key constraint. */ CREATE TABLE x (x INT, x INT);
ALTER TABLE x ADD FOREIGN KEY (x, x) REFERENCES x;
ALTER TABLE fk_partitioned_fk ATTACH PARTITION fk_partitioned_fk_1 FOR VALUES FROM (0,0) TO (1000,1000);
/* Child constraint will remain valid. */ SELECT x, x, CAST(x AS REGCLASS) FROM x WHERE CAST(CAST(x AS REGCLASS) AS TEXT) LIKE 'fk_partitioned_fk%' ORDER BY CAST(CAST(x AS REGCLASS) AS TEXT) NULLS LAST;
/* Validate the constraint */ ALTER TABLE fk_partitioned_fk VALIDATE CONSTRAINT fk_partitioned_fk_a_b_fkey;
/* All constraints are now valid. */ SELECT x, x, CAST(x AS REGCLASS) FROM x WHERE CAST(CAST(x AS REGCLASS) AS TEXT) LIKE 'fk_partitioned_fk%' ORDER BY CAST(CAST(x AS REGCLASS) AS TEXT) NULLS LAST;
/* Attaching a child with a NOT VALID constraint. */ CREATE TABLE x (x INT, x INT);
INSERT INTO x VALUES (1000, 1000);
ALTER TABLE x ADD FOREIGN KEY (x, x) REFERENCES x NOT VALID /* doesn't exist in referenced table */;
/* It will fail because the attach operation implicitly validates the data. */ ALTER TABLE fk_partitioned_fk ATTACH PARTITION fk_partitioned_fk_2 FOR VALUES FROM (1000,1000) TO (2000,2000);
TRUNCATE TABLE x /* Remove the invalid data and try again. */;
ALTER TABLE fk_partitioned_fk ATTACH PARTITION fk_partitioned_fk_2 FOR VALUES FROM (1000,1000) TO (2000,2000);
/* The child constraint will also be valid. */ SELECT x, x FROM x WHERE x = CAST('fk_partitioned_fk_2' AS REGCLASS) ORDER BY CAST(CAST(x AS REGCLASS) AS TEXT) NULLS LAST;
/* Test case where the child constraint is invalid, the grandchild constraint */ /* is valid, and the validation for the grandchild should be skipped when a */ /* valid constraint is applied to the top parent. */ CREATE TABLE x (x INT, x INT) WITH (PARTITIONED_BY=RANGE(x, x));
ALTER TABLE x ADD FOREIGN KEY (x, x) REFERENCES x NOT VALID;
CREATE TABLE x (x INT, x INT);
ALTER TABLE x ADD FOREIGN KEY (x, x) REFERENCES x;
ALTER TABLE fk_partitioned_fk_3 ATTACH PARTITION fk_partitioned_fk_3_1 FOR VALUES FROM (2000,2000) TO (3000,3000);
ALTER TABLE fk_partitioned_fk ATTACH PARTITION fk_partitioned_fk_3 FOR VALUES FROM (2000,2000) TO (3000,3000);
/* All constraints are now valid. */ SELECT x, x, CAST(x AS REGCLASS) FROM x WHERE CAST(CAST(x AS REGCLASS) AS TEXT) LIKE 'fk_partitioned_fk%' ORDER BY CAST(CAST(x AS REGCLASS) AS TEXT) NULLS LAST;
/* NOT VALID foreign key on a non-partitioned table referencing a partitioned table */ CREATE TABLE x (x INT, x INT, PRIMARY KEY (x NULLS LAST, x NULLS LAST)) WITH (PARTITIONED_BY=RANGE(x, x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (0, 0) TO (1000, 1000);
CREATE TABLE x (x INT, x INT);
ALTER TABLE x ADD FOREIGN KEY (x, x) REFERENCES x NOT VALID;
/* Constraint will be invalid. */ SELECT x, x FROM x WHERE x = CAST('fk_notpartitioned_fk' AS REGCLASS) ORDER BY CAST(CAST(x AS REGCLASS) AS TEXT) NULLS LAST;
ALTER TABLE fk_notpartitioned_fk VALIDATE CONSTRAINT fk_notpartitioned_fk_a_b_fkey;
/* All constraints are now valid. */ SELECT x, x FROM x WHERE x = CAST('fk_notpartitioned_fk' AS REGCLASS) ORDER BY CAST(CAST(x AS REGCLASS) AS TEXT) NULLS LAST;
/* Test some other exotic foreign key features: MATCH SIMPLE, ON UPDATE/DELETE */ /* actions */ CREATE TABLE x (x INT, x INT, PRIMARY KEY (x NULLS LAST, x NULLS LAST));
CREATE TABLE x (x INT DEFAULT 2501, x INT DEFAULT 142857) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN (NULL, 500, 501, 502);
ALTER TABLE x ADD FOREIGN KEY (x, x) REFERENCES x MATCH SIMPLE ON DELETE SET NULL ON UPDATE SET NULL;
CREATE TABLE x PARTITION OF x FOR VALUES IN (1500, 1502);
CREATE TABLE x (x INT, x INT);
ALTER TABLE fk_partitioned_fk ATTACH PARTITION fk_partitioned_fk_3 FOR VALUES IN (2500,2501,2502,2503);
/* this insert fails */ INSERT INTO x (x, x) VALUES (2502, 2503);
INSERT INTO x (x, x) VALUES (2502, 2503);
/* but since the FK is MATCH SIMPLE, this one doesn't */ INSERT INTO x (x, x) VALUES (2502, NULL);
/* now create the referenced row ... */ INSERT INTO x VALUES (2502, 2503);
/* - and now the same insert work */ INSERT INTO x (x, x) VALUES (2502, 2503);
/* this always works */ INSERT INTO x (x, x) VALUES (NULL, NULL);
/* MATCH FULL */ INSERT INTO x VALUES (1, 2);
CREATE TABLE x (x INT, x INT) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x DEFAULT;
INSERT INTO x VALUES (1, NULL);
ALTER TABLE x ADD FOREIGN KEY (x, x) REFERENCES x MATCH FULL;
TRUNCATE TABLE x /* fails */;
ALTER TABLE x ADD FOREIGN KEY (x, x) REFERENCES x MATCH FULL;
INSERT INTO x VALUES (1, NULL);
/* fails */ DROP TABLE x;
/* ON UPDATE SET NULL */ SELECT CAST(x AS REGCLASS), x, x FROM x WHERE x IS NULL ORDER BY x NULLS LAST;
UPDATE x SET x = x + 1 WHERE x = 2502;
SELECT CAST(x AS REGCLASS), x, x FROM x WHERE x IS NULL ORDER BY x NULLS LAST;
/* ON DELETE SET NULL */ INSERT INTO x VALUES (2503, 2503);
SELECT COUNT(*) FROM x WHERE x IS NULL;
DELETE FROM x;
SELECT COUNT(*) FROM x WHERE x IS NULL;
ALTER TABLE x DROP CONSTRAINT x /* ON UPDATE/DELETE SET DEFAULT */;
ALTER TABLE x ADD FOREIGN KEY (x, x) REFERENCES x ON DELETE SET DEFAULT ON UPDATE SET DEFAULT;
INSERT INTO x VALUES (2502, 2503);
INSERT INTO x (x, x) VALUES (2502, 2503);
/* this fails, because the defaults for the referencing table are not present */ /* in the referenced table: */ UPDATE x SET x = 1500 WHERE x = 2502;
/* but inserting the row we can make it work: */ INSERT INTO x VALUES (2501, 142857);
UPDATE x SET x = 1500 WHERE x = 2502;
SELECT * FROM x WHERE x = 142857;
ALTER TABLE x DROP CONSTRAINT x /* ON DELETE SET NULL column_list */;
ALTER TABLE fk_partitioned_fk ADD FOREIGN KEY (a, b)   REFERENCES fk_notpartitioned_pk   ON DELETE SET NULL (a);
BEGIN;
DELETE FROM x WHERE x = 142857;
SELECT * FROM x WHERE NOT x IS NULL OR NOT x IS NULL ORDER BY x NULLS LAST;
ROLLBACK;
ALTER TABLE x DROP CONSTRAINT x /* ON DELETE SET DEFAULT column_list */;
ALTER TABLE fk_partitioned_fk ADD FOREIGN KEY (a, b)   REFERENCES fk_notpartitioned_pk   ON DELETE SET DEFAULT (a);
BEGIN;
DELETE FROM x;
DELETE FROM x;
INSERT INTO x VALUES (500, 100000), (2501, 100000);
INSERT INTO x VALUES (500, 100000);
DELETE FROM x WHERE x = 500;
SELECT * FROM x ORDER BY x NULLS LAST;
ROLLBACK;
ALTER TABLE x DROP CONSTRAINT x /* ON UPDATE/DELETE CASCADE */;
ALTER TABLE x ADD FOREIGN KEY (x, x) REFERENCES x ON DELETE CASCADE ON UPDATE CASCADE;
UPDATE x SET x = 2502 WHERE x = 2501;
SELECT * FROM x WHERE x = 142857;
/* Now you see it ... */ SELECT * FROM x WHERE x = 142857;
DELETE FROM x WHERE x = 142857;
/* now you don't. */ SELECT * FROM x WHERE x = 142857;
/* verify that DROP works */ DROP TABLE x;
/* Test behavior of the constraint together with attaching and detaching */ /* partitions. */ CREATE TABLE x PARTITION OF x FOR VALUES IN (1500, 1502);
ALTER TABLE fk_partitioned_fk DETACH PARTITION fk_partitioned_fk_2;
BEGIN;
DROP TABLE x;
ROLLBACK;
ALTER TABLE fk_partitioned_fk ATTACH PARTITION fk_partitioned_fk_2 FOR VALUES IN (1500,1502);
DROP TABLE x;
CREATE TABLE x (x INT, x TEXT, x INT, FOREIGN KEY (x, x) REFERENCES x ON UPDATE CASCADE ON DELETE CASCADE);
ALTER TABLE x DROP COLUMN x;
ALTER TABLE fk_partitioned_fk ATTACH PARTITION fk_partitioned_fk_2 FOR VALUES IN (1500,1502);
CREATE TABLE x (x INT, x INT, FOREIGN KEY (x, x) REFERENCES x (x, x) ON UPDATE CASCADE ON DELETE CASCADE) WITH (PARTITIONED_BY=RANGE(x, x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (1, 1) TO (100, 100);
CREATE TABLE x (x INT, x INT, FOREIGN KEY (x, x) REFERENCES x (x, x) ON UPDATE SET NULL);
ALTER TABLE fk_partitioned_fk_4 ATTACH PARTITION fk_partitioned_fk_4_2 FOR VALUES FROM (100,100) TO (1000,1000);
ALTER TABLE fk_partitioned_fk ATTACH PARTITION fk_partitioned_fk_4 FOR VALUES IN (3500,3502);
ALTER TABLE fk_partitioned_fk DETACH PARTITION fk_partitioned_fk_4;
ALTER TABLE fk_partitioned_fk ATTACH PARTITION fk_partitioned_fk_4 FOR VALUES IN (3500,3502);
CREATE TABLE x (x INT, x INT, FOREIGN KEY (x, x) REFERENCES x);
ALTER TABLE fk_partitioned_fk ATTACH PARTITION fk_partitioned_fk_5 FOR VALUES IN (4500);
ALTER TABLE fk_partitioned_fk_5 ATTACH PARTITION fk_partitioned_fk_5_1 FOR VALUES FROM (0) TO (10);
ALTER TABLE fk_partitioned_fk DETACH PARTITION fk_partitioned_fk_5;
ALTER TABLE fk_partitioned_fk ATTACH PARTITION fk_partitioned_fk_5 FOR VALUES IN (4500);
ALTER TABLE fk_partitioned_fk_5 ATTACH PARTITION fk_partitioned_fk_5_1 FOR VALUES FROM (0) TO (10);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (0) TO (1000);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (1000) TO (2000);
INSERT INTO x VALUES (1600, 601), (1600, 1601);
ALTER TABLE fk_partitioned_fk ATTACH PARTITION fk_partitioned_fk_2   FOR VALUES IN (1600);
INSERT INTO x VALUES (1600, 601), (1600, 1601);
ALTER TABLE fk_partitioned_fk ATTACH PARTITION fk_partitioned_fk_2   FOR VALUES IN (1600);
/* leave these tables around intentionally */ /* Verify that attaching a table that's referenced by an existing FK */ /* in the parent throws an error */ CREATE TABLE x (x INT PRIMARY KEY);
CREATE TABLE x (x INT REFERENCES x) WITH (PARTITIONED_BY=LIST(x));
ALTER TABLE fk_partitioned_fk_6 ATTACH PARTITION fk_partitioned_pk_6 FOR VALUES IN (1);
/* Verify that attaching to a parent with two identical constraints work */ CREATE TABLE x (x INT PRIMARY KEY);
CREATE TABLE x (x INT, FOREIGN KEY (x) REFERENCES x, FOREIGN KEY (x) REFERENCES x) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN (1);
ALTER TABLE fk_partitioned_fk_6 DETACH PARTITION fk_partitioned_fk_6_1;
ALTER TABLE fk_partitioned_fk_6 ATTACH PARTITION fk_partitioned_fk_6_1 FOR VALUES IN (1);
/* This case is similar to above, but the referenced relation is one level */ /* lower in the hierarchy.  This one fails in a different way as the above, */ /* because we don't bother to protect against this case explicitly.  If the */ /* current error stops happening, we'll need to add a better protection. */ CREATE TABLE x (x INT PRIMARY KEY) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN (1);
CREATE TABLE x (x INT REFERENCES x) WITH (PARTITIONED_BY=LIST(x));
ALTER TABLE fk_partitioned_fk_6 ATTACH PARTITION fk_partitioned_pk_6 FOR VALUES IN (1);
/* test the case when the referenced table is owned by a different user */ create role regress_other_partitioned_fk_owner;
GRANT REFERENCES ON x TO x;
set role regress_other_partitioned_fk_owner;
CREATE TABLE x (x INT, x INT) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN (2048);
INSERT INTO x SELECT 2048, x FROM x AS x;
ALTER TABLE x ADD FOREIGN KEY (x, x) REFERENCES x (x, x) /* this should fail */;
/* add the missing keys and retry */ RESET role;
INSERT INTO x (x, x) SELECT 2048, x FROM x AS x;
set role regress_other_partitioned_fk_owner;
ALTER TABLE x ADD FOREIGN KEY (x, x) REFERENCES x (x, x);
/* clean up */ DROP TABLE x;
RESET role;
REVOKE all on fk_notpartitioned_pk from regress_other_partitioned_fk_owner;
drop role regress_other_partitioned_fk_owner;
/* Test self-referencing foreign key with partition. */ /* This should create only one fk constraint per partition */ CREATE TABLE x (x BIGINT NOT NULL PRIMARY KEY, x BIGINT, FOREIGN KEY (x) REFERENCES x (x)) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x (x BIGINT NOT NULL PRIMARY KEY, x BIGINT);
ALTER TABLE parted_self_fk ATTACH PARTITION part1_self_fk FOR VALUES FROM (0) TO (10);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (10) TO (20);
CREATE TABLE x (x BIGINT NOT NULL PRIMARY KEY, x BIGINT) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (20) TO (30);
ALTER TABLE parted_self_fk ATTACH PARTITION part3_self_fk FOR VALUES FROM (20) TO (40);
CREATE TABLE x (x BIGINT NOT NULL PRIMARY KEY, x BIGINT);
ALTER TABLE part3_self_fk ATTACH PARTITION part33_self_fk FOR VALUES FROM (30) TO (40);
SELECT x.x, x.x, x.x, x.x, x.x AS x, x.x, x.x AS x FROM x AS x JOIN x AS x ON x.x = x.x LEFT JOIN x AS x ON x.x = x.x LEFT JOIN x AS x ON x.x = x.x WHERE x.x IN (SELECT x FROM x) ORDER BY x.x NULLS LAST, x.x NULLS LAST, x.x NULLS LAST, x.x NULLS LAST;
/* detach and re-attach multiple times just to ensure everything is kosher */ ALTER TABLE parted_self_fk DETACH PARTITION part2_self_fk;
ALTER TABLE parted_self_fk ATTACH PARTITION part2_self_fk FOR VALUES FROM (10) TO (20);
ALTER TABLE parted_self_fk DETACH PARTITION part2_self_fk;
ALTER TABLE parted_self_fk ATTACH PARTITION part2_self_fk FOR VALUES FROM (10) TO (20);
SELECT x.x, x.x, x.x, x.x, x.x AS x, x.x, x.x AS x FROM x AS x JOIN x AS x ON x.x = x.x LEFT JOIN x AS x ON x.x = x.x LEFT JOIN x AS x ON x.x = x.x WHERE x.x IN (SELECT x FROM x) ORDER BY x.x NULLS LAST, x.x NULLS LAST, x.x NULLS LAST, x.x NULLS LAST;
/* Leave this table around, for pg_upgrade/pg_dump tests */ /* Test creating a constraint at the parent that already exists in partitions. */ /* There should be no duplicated constraints, and attempts to drop the */ /* constraint in partitions should raise appropriate errors. */ create schema fkpart0   create table pkey (a int primary key)   create table fk_part (a int) partition by list (a)   create table fk_part_1 partition of fk_part       (foreign key (a) references fkpart0.pkey) for values in (1)   create table fk_part_23 partition of fk_part       (foreign key (a) references fkpart0.pkey) for values in (2, 3)       partition by list (a)   create table fk_part_23_2 partition of fk_part_23 for values in (2);
ALTER TABLE x.x ADD FOREIGN KEY (x) REFERENCES x.x;
ALTER TABLE x.x DROP CONSTRAINT x;
CREATE TABLE x.x PARTITION OF x.x FOR VALUES IN (4);
CREATE TABLE x.x PARTITION OF x.x FOR VALUES IN (5, 6) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x.x PARTITION OF x.x FOR VALUES IN (5);
ALTER TABLE x.x DROP CONSTRAINT x;
/* verify that attaching and detaching partitions maintains the right set of */ /* triggers */ create schema fkpart1   create table pkey (a int primary key)   create table fk_part (a int) partition by list (a)   create table fk_part_1 partition of fk_part for values in (1) partition by list (a)   create table fk_part_1_1 partition of fk_part_1 for values in (1);
ALTER TABLE x.x ADD FOREIGN KEY (x) REFERENCES x.x;
INSERT INTO x.x VALUES (1);
/* should fail */ INSERT INTO x.x VALUES (1);
INSERT INTO x.x VALUES (1);
DELETE FROM x.x WHERE x = 1;
/* should fail */ alter table fkpart1.fk_part detach partition fkpart1.fk_part_1;
CREATE TABLE x.x PARTITION OF x.x FOR VALUES IN (2);
INSERT INTO x.x VALUES (2);
/* should fail */ DELETE FROM x.x WHERE x = 1;
/* verify that attaching and detaching partitions manipulates the inheritance */ /* properties of their FK constraints correctly */ create schema fkpart2   create table pkey (a int primary key)   create table fk_part (a int, constraint fkey foreign key (a) references fkpart2.pkey) partition by list (a)   create table fk_part_1 partition of fkpart2.fk_part for values in (1) partition by list (a)   create table fk_part_1_1 (a int, constraint my_fkey foreign key (a) references fkpart2.pkey);
alter table fkpart2.fk_part_1 attach partition fkpart2.fk_part_1_1 for values in (1);
ALTER TABLE x.x DROP CONSTRAINT x;
ALTER TABLE x.x DROP CONSTRAINT x /* should fail */;
/* should fail */ alter table fkpart2.fk_part detach partition fkpart2.fk_part_1;
ALTER TABLE x.x DROP CONSTRAINT x;
ALTER TABLE x.x DROP CONSTRAINT x /* ok */;
/* doesn't exist */ /* verify constraint deferrability */ create schema fkpart3   create table pkey (a int primary key)   create table fk_part (a int, constraint fkey foreign key (a) references fkpart3.pkey deferrable initially immediate) partition by list (a)   create table fk_part_1 partition of fkpart3.fk_part for values in (1) partition by list (a)   create table fk_part_1_1 partition of fkpart3.fk_part_1 for values in (1)   create table fk_part_2 partition of fkpart3.fk_part for values in (2);
BEGIN;
set constraints fkpart3.fkey deferred;
INSERT INTO x.x VALUES (1);
INSERT INTO x.x VALUES (1);
COMMIT;
BEGIN;
set constraints fkpart3.fkey deferred;
DELETE FROM x.x;
DELETE FROM x.x;
COMMIT;
/* Test a partitioned table as referenced table. */ /* Verify basic functionality with a regular partition creation and a partition */ /* with a different column layout, as well as partitions added (created and */ /* attached) after creating the foreign key. */ CREATE SCHEMA x.x;
SET x = fkpart3;
CREATE TABLE x (x INT PRIMARY KEY) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (0) TO (1000);
CREATE TABLE x (x INT, x INT);
ALTER TABLE x DROP COLUMN x;
ALTER TABLE x ALTER COLUMN x SET NOT NULL;
ALTER TABLE pk ATTACH PARTITION pk2 FOR VALUES FROM (1000) TO (2000);
CREATE TABLE x (x INT) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (0) TO (750);
ALTER TABLE x ADD FOREIGN KEY (x) REFERENCES x;
CREATE TABLE x (x INT, x INT);
ALTER TABLE x DROP COLUMN x;
ALTER TABLE fk ATTACH PARTITION fk2 FOR VALUES FROM (750) TO (3500);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (2000) TO (3000);
CREATE TABLE x (LIKE x);
ALTER TABLE pk ATTACH PARTITION pk4 FOR VALUES FROM (3000) TO (4000);
CREATE TABLE x (x INT, x INT, x INT NOT NULL) WITH (PARTITIONED_BY=RANGE(x));
ALTER TABLE x DROP COLUMN x, DROP COLUMN x;
CREATE TABLE x PARTITION OF x FOR VALUES FROM (4000) TO (4500);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (4500) TO (5000);
ALTER TABLE pk ATTACH PARTITION pk5 FOR VALUES FROM (4000) TO (5000);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (3500) TO (5000);
/* these should fail: referenced value not present */ INSERT INTO x VALUES (1);
INSERT INTO x VALUES (1000);
INSERT INTO x VALUES (2000);
INSERT INTO x VALUES (3000);
INSERT INTO x VALUES (4000);
INSERT INTO x VALUES (4500);
/* insert into the referenced table, now they should work */ INSERT INTO x VALUES (1), (1000), (2000), (3000), (4000), (4500);
INSERT INTO x VALUES (1), (1000), (2000), (3000), (4000), (4500);
/* should fail: referencing value present */ DELETE FROM x WHERE x = 1;
DELETE FROM x WHERE x = 1000;
DELETE FROM x WHERE x = 2000;
DELETE FROM x WHERE x = 3000;
DELETE FROM x WHERE x = 4000;
DELETE FROM x WHERE x = 4500;
UPDATE x SET x = 2 WHERE x = 1;
UPDATE x SET x = 1002 WHERE x = 1000;
UPDATE x SET x = 2002 WHERE x = 2000;
UPDATE x SET x = 3002 WHERE x = 3000;
UPDATE x SET x = 4002 WHERE x = 4000;
UPDATE x SET x = 4502 WHERE x = 4500;
/* now they should work */ DELETE FROM x;
UPDATE x SET x = 2 WHERE x = 1;
DELETE FROM x WHERE x = 2;
UPDATE x SET x = 1002 WHERE x = 1000;
DELETE FROM x WHERE x = 1002;
UPDATE x SET x = 2002 WHERE x = 2000;
DELETE FROM x WHERE x = 2002;
UPDATE x SET x = 3002 WHERE x = 3000;
DELETE FROM x WHERE x = 3002;
UPDATE x SET x = 4002 WHERE x = 4000;
DELETE FROM x WHERE x = 4002;
UPDATE x SET x = 4502 WHERE x = 4500;
DELETE FROM x WHERE x = 4502;
/* Also, detaching a partition that has the FK itself should work */ /* https://postgr.es/m/CAAJ_b97GuPh6wQPbxQS-Zpy16Oh+0aMv-w64QcGrLhCOZZ6p+g@mail.gmail.com */ CREATE TABLE x (x INT, x INT REFERENCES x) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN (1);
ALTER TABLE x ADD FOREIGN KEY (x) REFERENCES x;
ALTER TABLE ffk DETACH PARTITION ffk1;
CREATE SCHEMA x.x;
SET x = fkpart4;
/* dropping/detaching PARTITIONs is prevented if that would break */ /* a foreign key's existing data */ CREATE TABLE x (x INT PRIMARY KEY) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (0) TO (1000);
CREATE TABLE x PARTITION OF x DEFAULT;
CREATE TABLE x PARTITION OF x FOR VALUES FROM (1000) TO (2000) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (1000) TO (1400);
CREATE TABLE x PARTITION OF x DEFAULT;
INSERT INTO x VALUES (1), (1000), (1500), (2000);
CREATE TABLE x (x INT REFERENCES x);
INSERT INTO x VALUES (1), (1000), (1500), (2000);
/* these should all fail */ ALTER TABLE droppk DETACH PARTITION droppk_d;
ALTER TABLE droppk2 DETACH PARTITION droppk2_d;
ALTER TABLE droppk DETACH PARTITION droppk1;
ALTER TABLE droppk DETACH PARTITION droppk2;
ALTER TABLE droppk2 DETACH PARTITION droppk21;
/* dropping partitions is disallowed */ DROP TABLE x;
DROP TABLE x;
DROP TABLE x;
DROP TABLE x;
DROP TABLE x;
DELETE FROM x;
/* dropping partitions is disallowed, even when no referencing values */ DROP TABLE x;
DROP TABLE x;
DROP TABLE x;
/* but DETACH is allowed, and DROP afterwards works */ ALTER TABLE droppk2 DETACH PARTITION droppk21;
DROP TABLE x;
/* Verify that initial constraint creation and cloning behave correctly */ CREATE SCHEMA x.x;
SET x = fkpart5;
CREATE TABLE x (x INT PRIMARY KEY) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN (1) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN (1);
CREATE TABLE x (x INT) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN (1) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN (1);
ALTER TABLE x ADD FOREIGN KEY (x) REFERENCES x;
CREATE TABLE x PARTITION OF x FOR VALUES IN (2);
CREATE TABLE x (x INT NOT NULL) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN (31);
CREATE TABLE x (x INT, x INT NOT NULL);
ALTER TABLE x DROP COLUMN x;
ALTER TABLE pk3 ATTACH PARTITION pk32 FOR VALUES IN (32);
ALTER TABLE pk ATTACH PARTITION pk3 FOR VALUES IN (31, 32);
CREATE TABLE x PARTITION OF x FOR VALUES IN (2);
CREATE TABLE x (x INT, x INT);
ALTER TABLE x DROP COLUMN x;
ALTER TABLE fk ATTACH PARTITION fk3 FOR VALUES IN (3);
SELECT PG_DESCRIBE_OBJECT(CAST('pg_constraint' AS REGCLASS), x, 0), CAST(x AS REGCLASS), CASE WHEN x <> 0 THEN PG_DESCRIBE_OBJECT(CAST('pg_constraint' AS REGCLASS), x, 0) ELSE 'TOP' END FROM x.x WHERE x IN (SELECT x FROM x) ORDER BY CAST(CAST(x AS REGCLASS) AS TEXT) NULLS LAST, x NULLS LAST;
CREATE TABLE x (LIKE x);
INSERT INTO x VALUES (50);
ALTER TABLE fk ATTACH PARTITION fk4 FOR VALUES IN (50);
/* Verify constraint deferrability */ CREATE SCHEMA x.x;
SET x = fkpart9;
CREATE TABLE x (x INT PRIMARY KEY) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN (1, 2) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN (1);
CREATE TABLE x PARTITION OF x FOR VALUES IN (3);
CREATE TABLE x (x INT REFERENCES x DEFERRABLE INITIALLY IMMEDIATE);
INSERT INTO x VALUES (1);
/* should fail */ BEGIN;
SET CONSTRAINTS fk_a_fkey DEFERRED;
INSERT INTO x VALUES (1);
COMMIT;
/* should fail */ BEGIN;
SET CONSTRAINTS fk_a_fkey DEFERRED;
INSERT INTO x VALUES (1);
INSERT INTO x VALUES (1);
COMMIT;
/* OK */ BEGIN;
SET CONSTRAINTS fk_a_fkey DEFERRED;
DELETE FROM x WHERE x = 1;
DELETE FROM x WHERE x = 1;
COMMIT;
/* OK */ /* Verify constraint deferrability when changed by ALTER */ /* Partitioned table at referencing end */ CREATE TABLE x (x INT, x INT, x INT, PRIMARY KEY (x NULLS LAST, x NULLS LAST));
CREATE TABLE x (x INT, x INT, x INT) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN (1);
CREATE TABLE x PARTITION OF x FOR VALUES IN (2);
ALTER TABLE x ADD FOREIGN KEY (x, x) REFERENCES x;
ALTER TABLE ref ALTER CONSTRAINT ref_f1_f2_fkey   DEFERRABLE INITIALLY DEFERRED;
INSERT INTO x VALUES (1, 2, 3);
INSERT INTO x VALUES (1, 2, 3);
BEGIN;
DELETE FROM x;
DELETE FROM x;
x;
/* Multi-level partitioning at referencing end */ CREATE TABLE x (x INT, x INT, x INT, PRIMARY KEY (x NULLS LAST, x NULLS LAST));
CREATE TABLE x (x INT, x INT, x INT) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN (1, 2) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN (1);
CREATE TABLE x PARTITION OF x FOR VALUES IN (2) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN (2);
ALTER TABLE x ADD FOREIGN KEY (x, x) REFERENCES x;
INSERT INTO x VALUES (1, 2, 3);
INSERT INTO x VALUES (1, 2, 3);
ALTER TABLE ref22 ALTER CONSTRAINT ref_f1_f2_fkey   DEFERRABLE INITIALLY IMMEDIATE;
/* fails */ ALTER TABLE ref ALTER CONSTRAINT ref_f1_f2_fkey   DEFERRABLE INITIALLY DEFERRED;
BEGIN;
DELETE FROM x;
DELETE FROM x;
x;
/* Partitioned table at referenced end */ CREATE TABLE x (x INT, x INT, x INT, PRIMARY KEY (x NULLS LAST, x NULLS LAST)) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN (1);
CREATE TABLE x PARTITION OF x FOR VALUES IN (2);
CREATE TABLE x (x INT, x INT, x INT);
ALTER TABLE x ADD FOREIGN KEY (x, x) REFERENCES x;
ALTER TABLE ref ALTER CONSTRAINT ref_f1_f2_fkey   DEFERRABLE INITIALLY DEFERRED;
INSERT INTO x VALUES (1, 2, 3);
INSERT INTO x VALUES (1, 2, 3);
BEGIN;
DELETE FROM x;
DELETE FROM x;
x;
/* Multi-level partitioning at referenced end */ CREATE TABLE x (x INT, x INT, x INT, PRIMARY KEY (x NULLS LAST, x NULLS LAST)) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN (1, 2) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN (1);
CREATE TABLE x PARTITION OF x FOR VALUES IN (2);
CREATE TABLE x (x INT, x INT, x INT);
ALTER TABLE x ADD FOREIGN KEY (x, x) REFERENCES x;
ALTER TABLE ref ALTER CONSTRAINT ref_f1_f2_fkey1   DEFERRABLE INITIALLY DEFERRED;
/* fails */ ALTER TABLE ref ALTER CONSTRAINT ref_f1_f2_fkey   DEFERRABLE INITIALLY DEFERRED;
INSERT INTO x VALUES (1, 2, 3);
INSERT INTO x VALUES (1, 2, 3);
BEGIN;
DELETE FROM x;
DELETE FROM x;
x;
DROP SCHEMA x.x CASCADE;
/* Verify ON UPDATE/DELETE behavior */ CREATE SCHEMA x.x;
SET x = fkpart6;
CREATE TABLE x (x INT PRIMARY KEY) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (1) TO (100) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (1) TO (50);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (50) TO (100);
CREATE TABLE x (x INT) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (1) TO (100) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (1) TO (10);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (10) TO (100);
ALTER TABLE x ADD FOREIGN KEY (x) REFERENCES x ON UPDATE CASCADE ON DELETE CASCADE;
CREATE TABLE x PARTITION OF x DEFAULT;
INSERT INTO x VALUES (1);
INSERT INTO x VALUES (1);
UPDATE x SET x = 20;
SELECT CAST(x AS REGCLASS), * FROM x;
DELETE FROM x WHERE x = 20;
SELECT CAST(x AS REGCLASS), * FROM x;
DROP TABLE x;
TRUNCATE TABLE x;
INSERT INTO x VALUES (20), (50);
CREATE TABLE x (x INT) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (1) TO (100) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (1) TO (10);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (10) TO (100);
ALTER TABLE x ADD FOREIGN KEY (x) REFERENCES x ON UPDATE SET NULL ON DELETE SET NULL;
CREATE TABLE x PARTITION OF x DEFAULT;
INSERT INTO x VALUES (20), (50);
UPDATE x SET x = 21 WHERE x = 20;
DELETE FROM x WHERE x = 50;
SELECT CAST(x AS REGCLASS), * FROM x;
DROP TABLE x;
TRUNCATE TABLE x;
INSERT INTO x VALUES (20), (30), (50);
CREATE TABLE x (x INT, x INT DEFAULT 50) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (1) TO (100) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (1) TO (10);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (10) TO (100);
ALTER TABLE x ADD FOREIGN KEY (x) REFERENCES x ON UPDATE SET DEFAULT ON DELETE SET DEFAULT;
CREATE TABLE x PARTITION OF x DEFAULT;
INSERT INTO x VALUES (1, 20), (2, 30);
DELETE FROM x WHERE x = 20 RETURNING *;
UPDATE x SET x = 90 WHERE x = 30 RETURNING *;
SELECT CAST(x AS REGCLASS), * FROM x;
DROP TABLE x;
TRUNCATE TABLE x;
INSERT INTO x VALUES (20), (30);
CREATE TABLE x (x INT DEFAULT 50) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (1) TO (100) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (1) TO (10);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (10) TO (100);
ALTER TABLE x ADD FOREIGN KEY (x) REFERENCES x ON UPDATE RESTRICT ON DELETE RESTRICT;
CREATE TABLE x PARTITION OF x DEFAULT;
INSERT INTO x VALUES (20), (30);
DELETE FROM x WHERE x = 20;
UPDATE x SET x = 90 WHERE x = 30;
SELECT CAST(x AS REGCLASS), * FROM x;
DROP TABLE x;
/* test for reported bug: relispartition not set */ /* https://postgr.es/m/CA+HiwqHMsRtRYRWYTWavKJ8x14AFsv7bmAV46mYwnfD3vy8goQ@mail.gmail.com */ CREATE SCHEMA fkpart7   CREATE TABLE pkpart (a int) PARTITION BY LIST (a)   CREATE TABLE pkpart1 PARTITION OF pkpart FOR VALUES IN (1);
ALTER TABLE x.x ADD PRIMARY KEY (x NULLS LAST);
ALTER TABLE x.x ADD PRIMARY KEY (x NULLS LAST);
CREATE TABLE x.x (x INT REFERENCES x.x);
DROP SCHEMA x.x CASCADE;
/* ensure we check partitions are "not used" when dropping constraints */ CREATE SCHEMA fkpart8   CREATE TABLE tbl1(f1 int PRIMARY KEY)   CREATE TABLE tbl2(f1 int REFERENCES tbl1 DEFERRABLE INITIALLY DEFERRED) PARTITION BY RANGE(f1)   CREATE TABLE tbl2_p1 PARTITION OF tbl2 FOR VALUES FROM (minvalue) TO (maxvalue);
INSERT INTO x.x VALUES (1);
BEGIN;
INSERT INTO x.x VALUES (1);
ALTER TABLE x.x DROP CONSTRAINT x;
COMMIT;
DROP SCHEMA x.x CASCADE;
/* ensure FK referencing a multi-level partitioned table are */ /* enforce reference to sub-children. */ CREATE SCHEMA fkpart9   CREATE TABLE pk (a INT PRIMARY KEY) PARTITION BY RANGE (a)   CREATE TABLE fk (     fk_a INT REFERENCES pk(a) ON DELETE CASCADE   )   CREATE TABLE pk1 PARTITION OF pk FOR VALUES FROM (30) TO (50) PARTITION BY RANGE (a)   CREATE TABLE pk11 PARTITION OF pk1 FOR VALUES FROM (30) TO (40);
INSERT INTO x.x VALUES (35);
INSERT INTO x.x VALUES (35);
DELETE FROM x.x WHERE x = 35;
SELECT * FROM x.x;
SELECT * FROM x.x;
DROP SCHEMA x.x CASCADE;
/* test that ri_Check_Pk_Match() scans the correct partition for a deferred */ /* ON DELETE/UPDATE NO ACTION constraint */ CREATE SCHEMA fkpart10   CREATE TABLE tbl1(f1 int PRIMARY KEY) PARTITION BY RANGE(f1)   CREATE TABLE tbl1_p1 PARTITION OF tbl1 FOR VALUES FROM (minvalue) TO (1)   CREATE TABLE tbl1_p2 PARTITION OF tbl1 FOR VALUES FROM (1) TO (maxvalue)   CREATE TABLE tbl2(f1 int REFERENCES tbl1 DEFERRABLE INITIALLY DEFERRED)   CREATE TABLE tbl3(f1 int PRIMARY KEY) PARTITION BY RANGE(f1)   CREATE TABLE tbl3_p1 PARTITION OF tbl3 FOR VALUES FROM (minvalue) TO (1)   CREATE TABLE tbl3_p2 PARTITION OF tbl3 FOR VALUES FROM (1) TO (maxvalue)   CREATE TABLE tbl4(f1 int REFERENCES tbl3 DEFERRABLE INITIALLY DEFERRED);
INSERT INTO x.x VALUES (0), (1);
INSERT INTO x.x VALUES (0), (1);
INSERT INTO x.x VALUES (-2), (-1), (0);
INSERT INTO x.x VALUES (-2), (-1);
BEGIN;
DELETE FROM x.x WHERE x = 0;
UPDATE x.x SET x = 2 WHERE x = 1;
INSERT INTO x.x VALUES (0), (1);
COMMIT;
/* test that cross-partition updates correctly enforces the foreign key */ /* restriction (specifically testing INITIALLY DEFERRED) */ BEGIN;
UPDATE x.x SET x = 3 WHERE x = 0;
UPDATE x.x SET x = x * -1;
INSERT INTO x.x VALUES (4);
COMMIT;
BEGIN;
UPDATE x.x SET x = x * -1;
UPDATE x.x SET x = x + 3;
UPDATE x.x SET x = 3 WHERE x = 0;
INSERT INTO x.x VALUES (0);
COMMIT;
BEGIN;
UPDATE x.x SET x = x * -1;
UPDATE x.x SET x = 3 WHERE x = 0;
INSERT INTO x.x VALUES (0);
INSERT INTO x.x VALUES (-2), (-1);
COMMIT;
/* test where the updated table now has both an IMMEDIATE and a DEFERRED */ /* constraint pointing into it */ CREATE TABLE x.x (x INT REFERENCES x.x);
INSERT INTO x.x VALUES (-2), (-1);
BEGIN;
UPDATE x.x SET x = x * -3;
COMMIT;
/* Now test where the row referenced from the table with an IMMEDIATE */ /* constraint stays in place, while those referenced from the table with a */ /* DEFERRED constraint don't. */ DELETE FROM x.x;
INSERT INTO x.x VALUES (0);
BEGIN;
UPDATE x.x SET x = x * -3;
COMMIT;
DROP SCHEMA x.x CASCADE;
/* verify foreign keys are enforced during cross-partition updates, */ /* especially on the PK side */ CREATE SCHEMA fkpart11   CREATE TABLE pk (a INT PRIMARY KEY, b text) PARTITION BY LIST (a)   CREATE TABLE fk (     a INT,     CONSTRAINT fkey FOREIGN KEY (a) REFERENCES pk(a) ON UPDATE CASCADE ON DELETE CASCADE   )   CREATE TABLE fk_parted (     a INT PRIMARY KEY,     CONSTRAINT fkey FOREIGN KEY (a) REFERENCES pk(a) ON UPDATE CASCADE ON DELETE CASCADE   ) PARTITION BY LIST (a)   CREATE TABLE fk_another (     a INT,     CONSTRAINT fkey FOREIGN KEY (a) REFERENCES fk_parted (a) ON UPDATE CASCADE ON DELETE CASCADE   )   CREATE TABLE pk1 PARTITION OF pk FOR VALUES IN (1, 2) PARTITION BY LIST (a)   CREATE TABLE pk2 PARTITION OF pk FOR VALUES IN (3)   CREATE TABLE pk3 PARTITION OF pk FOR VALUES IN (4)   CREATE TABLE fk1 PARTITION OF fk_parted FOR VALUES IN (1, 2)   CREATE TABLE fk2 PARTITION OF fk_parted FOR VALUES IN (3)   CREATE TABLE fk3 PARTITION OF fk_parted FOR VALUES IN (4);
CREATE TABLE x.x (x TEXT, x INT NOT NULL);
ALTER TABLE fkpart11.pk1 ATTACH PARTITION fkpart11.pk11 FOR VALUES IN (1);
CREATE TABLE x.x (x TEXT, x INT, x INT NOT NULL);
ALTER TABLE x.x DROP c;
ALTER TABLE fkpart11.pk1 ATTACH PARTITION fkpart11.pk12 FOR VALUES IN (2);
INSERT INTO x.x VALUES (1, 'xxx'), (3, 'yyy');
INSERT INTO x.x VALUES (1), (3);
INSERT INTO x.x VALUES (1), (3);
INSERT INTO x.x VALUES (1), (3);
/* moves 2 rows from one leaf partition to another, with both updates being */ /* cascaded to fk and fk_parted.  Updates of fk_parted, of which one is */ /* cross-partition (3 -> 4), are further cascaded to fk_another. */ UPDATE x.x SET x = x + 1 RETURNING CAST(x AS REGCLASS), *;
SELECT CAST(x AS REGCLASS), * FROM x.x;
SELECT CAST(x AS REGCLASS), * FROM x.x;
SELECT CAST(x AS REGCLASS), * FROM x.x;
ALTER TABLE x.x DROP CONSTRAINT x /* let's try with the foreign key pointing at tables in the partition tree */ /* that are not the same as the query's target table */ /* 1. foreign key pointing into a non-root ancestor */ /* A cross-partition update on the root table will fail, because we currently */ /* can't enforce the foreign keys pointing into a non-leaf partition */;
DELETE FROM x.x WHERE x = 4;
ALTER TABLE x.x ADD CONSTRAINT x FOREIGN KEY (x) REFERENCES x.x (x) ON UPDATE CASCADE ON DELETE CASCADE;
UPDATE x.x SET x = x - 1;
/* it's okay though if the non-leaf partition is updated directly */ UPDATE x.x SET x = x - 1;
SELECT CAST(x AS REGCLASS), * FROM x.x;
SELECT CAST(x AS REGCLASS), * FROM x.x;
SELECT CAST(x AS REGCLASS), * FROM x.x;
SELECT CAST(x AS REGCLASS), * FROM x.x;
ALTER TABLE x.x DROP CONSTRAINT x /* 2. foreign key pointing into a single leaf partition */ /* A cross-partition update that deletes from the pointed-to leaf partition */ /* is allowed to succeed */;
ALTER TABLE x.x ADD CONSTRAINT x FOREIGN KEY (x) REFERENCES x.x (x) ON UPDATE CASCADE ON DELETE CASCADE;
/* will delete (1) from p11 which is cascaded to fk */ UPDATE x.x SET x = x + 1 WHERE x = 1;
SELECT CAST(x AS REGCLASS), * FROM x.x;
DROP TABLE x.x;
x AS x;
COMMIT;
CREATE TRIGGER trig_upd_pk AFTER UPDATE ON fkpart11.pk FOR EACH ROW EXECUTE FUNCTION fkpart11.print_row();
CREATE TRIGGER trig_del_pk AFTER DELETE ON fkpart11.pk FOR EACH ROW EXECUTE FUNCTION fkpart11.print_row();
CREATE TRIGGER trig_ins_pk AFTER INSERT ON fkpart11.pk FOR EACH ROW EXECUTE FUNCTION fkpart11.print_row();
CREATE CONSTRAINT TRIGGER trig_upd_fk_parted AFTER UPDATE ON fkpart11.fk_parted INITIALLY DEFERRED FOR EACH ROW EXECUTE FUNCTION fkpart11.print_row();
CREATE CONSTRAINT TRIGGER trig_del_fk_parted AFTER DELETE ON fkpart11.fk_parted INITIALLY DEFERRED FOR EACH ROW EXECUTE FUNCTION fkpart11.print_row();
CREATE CONSTRAINT TRIGGER trig_ins_fk_parted AFTER INSERT ON fkpart11.fk_parted INITIALLY DEFERRED FOR EACH ROW EXECUTE FUNCTION fkpart11.print_row();
UPDATE x.x SET x = 3 WHERE x = 4;
UPDATE x.x SET x = 1 WHERE x = 2;
DROP SCHEMA x.x CASCADE;
/* When a table is attached as partition to a partitioned table that has */ /* a foreign key to another partitioned table, it acquires a clone of the */ /* FK.  Upon detach, this clone is not removed, but instead becomes an */ /* independent FK.  If it then attaches to the partitioned table again, */ /* the FK from the parent "takes over" ownership of the independent FK rather */ /* than creating a separate one. */ CREATE SCHEMA fkpart12   CREATE TABLE fk_p ( id int, jd int, PRIMARY KEY(id, jd)) PARTITION BY list (id)   CREATE TABLE fk_p_1 PARTITION OF fk_p FOR VALUES IN (1) PARTITION BY list (jd)   CREATE TABLE fk_p_1_1 PARTITION OF fk_p_1 FOR VALUES IN (1)   CREATE TABLE fk_p_1_2 (x int, y int, jd int NOT NULL, id int NOT NULL)   CREATE TABLE fk_p_2 PARTITION OF fk_p FOR VALUES IN (2) PARTITION BY list (jd)   CREATE TABLE fk_p_2_1 PARTITION OF fk_p_2 FOR VALUES IN (1)   CREATE TABLE fk_p_2_2 PARTITION OF fk_p_2 FOR VALUES IN (2)   CREATE TABLE fk_r_1 ( p_jd int NOT NULL, x int, id int PRIMARY KEY, p_id int NOT NULL)   CREATE TABLE fk_r_2 ( id int PRIMARY KEY, p_id int NOT NULL, p_jd int NOT NULL) PARTITION BY list (id)   CREATE TABLE fk_r_2_1 PARTITION OF fk_r_2 FOR VALUES IN (2, 1)   CREATE TABLE fk_r   ( id int PRIMARY KEY, p_id int NOT NULL, p_jd int NOT NULL,        FOREIGN KEY (p_id, p_jd) REFERENCES fk_p (id, jd)   ) PARTITION BY list (id);
SET x = fkpart12;
ALTER TABLE x DROP COLUMN x, DROP COLUMN x;
ALTER TABLE fk_p_1 ATTACH PARTITION fk_p_1_2 FOR VALUES IN (2);
ALTER TABLE x DROP COLUMN x;
INSERT INTO x VALUES (1, 1);
ALTER TABLE fk_r ATTACH PARTITION fk_r_1 FOR VALUES IN (1);
ALTER TABLE fk_r ATTACH PARTITION fk_r_2 FOR VALUES IN (2);
INSERT INTO x VALUES (2, 2, 1);
ALTER TABLE fk_r DETACH PARTITION fk_r_1;
ALTER TABLE fk_r DETACH PARTITION fk_r_2;
/* should fail */ DELETE FROM x;
/* should fail */ ALTER TABLE fk_r ATTACH PARTITION fk_r_1 FOR VALUES IN (1);
ALTER TABLE fk_r ATTACH PARTITION fk_r_2 FOR VALUES IN (2);
ALTER TABLE x DROP CONSTRAINT x /* should fail */ /* these should all fail */;
ALTER TABLE x DROP CONSTRAINT x;
ALTER TABLE x DROP CONSTRAINT x;
SET x = warning;
DROP SCHEMA x.x CASCADE;
RESET client_min_messages;
RESET search_path;
/* from http://www.depesz.com/index.php/2010/04/19/getting-unique-elements/ */ CREATE TEMPORARY TABLE x (x INT CONSTRAINT x PRIMARY KEY, x TEXT, x TEXT UNIQUE NOT NULL, x TEXT UNIQUE, x DATE);
CREATE TEMPORARY TABLE x (x INT, x INT, x DATE, PRIMARY KEY (x NULLS LAST, x NULLS LAST));
/* test functional dependencies based on primary keys/unique constraints */ /* base tables */ /* group by primary key (OK) */ SELECT x, x, x, x, x FROM x GROUP BY x;
/* group by unique not null (fail/todo) */ SELECT x, x, x, x, x FROM x GROUP BY x;
/* group by unique nullable (fail) */ SELECT x, x, x, x, x FROM x GROUP BY x;
/* group by something else (fail) */ SELECT x, x, x, x, x FROM x GROUP BY x;
/* multiple tables */ /* group by primary key (OK) */ SELECT x.x, x.x, x.x, x.x, x.x FROM x AS x, x AS x WHERE x.x = x.x AND x.x IN (14, 62, 70, 53, 138) GROUP BY x.x;
/* group by something else (fail) */ SELECT x.x, x.x, x.x, x.x, x.x FROM x AS x, x AS x WHERE x.x = x.x AND x.x IN (14, 62, 70, 53, 138) GROUP BY x.x, x.x;
/* JOIN syntax */ /* group by left table's primary key (OK) */ SELECT x.x, x.x, x.x, x.x, x.x FROM x AS x JOIN x AS x ON x.x = x.x WHERE x.x IN (14, 62, 70, 53, 138) GROUP BY x.x;
/* group by something else (fail) */ SELECT x.x, x.x, x.x, x.x, x.x FROM x AS x JOIN x AS x ON x.x = x.x WHERE x.x IN (14, 62, 70, 53, 138) GROUP BY x.x, x.x;
/* group by right table's (composite) primary key (OK) */ SELECT x.x FROM x AS x JOIN x AS x ON x.x = x.x WHERE x.x IN (14, 62, 70, 53, 138) GROUP BY x.x, x.x;
/* group by right table's partial primary key (fail) */ SELECT x.x FROM x AS x JOIN x AS x ON x.x = x.x WHERE x.x IN (14, 62, 70, 53, 138) GROUP BY x.x;
/* example from documentation */ CREATE TEMPORARY TABLE x (x INT, x TEXT, x DECIMAL);
CREATE TEMPORARY TABLE x (x INT, x INT);
/* OK */ SELECT x, x.x, (SUM(x.x) * x.x) AS x FROM x AS x LEFT JOIN x AS x USING (x) GROUP BY x, x.x, x.x;
/* fail */ SELECT x, x.x, (SUM(x.x) * x.x) AS x FROM x AS x LEFT JOIN x AS x USING (x) GROUP BY x;
ALTER TABLE x ADD PRIMARY KEY (x NULLS LAST);
/* OK now */ SELECT x, x.x, (SUM(x.x) * x.x) AS x FROM x AS x LEFT JOIN x AS x USING (x) GROUP BY x;
/* Drupal example, http://drupal.org/node/555530 */ CREATE TEMPORARY TABLE x (x SERIAL, x INT NOT NULL DEFAULT '0', x VARCHAR(32) NOT NULL DEFAULT '', x VARCHAR(128) NOT NULL DEFAULT '', x INT NOT NULL DEFAULT '0', x INT NOT NULL DEFAULT '1', x INT NOT NULL DEFAULT '0', PRIMARY KEY (x NULLS LAST, x NULLS LAST));
CREATE TEMPORARY TABLE x (x INT NOT NULL DEFAULT '0', x VARCHAR(60) NOT NULL DEFAULT '', x VARCHAR(32) NOT NULL DEFAULT '', PRIMARY KEY (x NULLS LAST), UNIQUE (x));
/* OK */ SELECT x.x, x.x FROM x AS x INNER JOIN x AS x ON x.x = x.x WHERE x.x = 'blog' AND x.x = 1 GROUP BY x.x, x.x;
/* OK */ SELECT x.x, x.x FROM x AS x INNER JOIN x AS x ON x.x = x.x WHERE x.x = 'blog' AND x.x = 1 GROUP BY x.x;
/* Check views and dependencies */ /* fail */ CREATE TEMPORARY VIEW x AS SELECT x, x, x, x, x FROM x GROUP BY x;
/* OK */ CREATE TEMPORARY VIEW x AS SELECT x, x, x, x, x FROM x GROUP BY x;
/* fail */ ALTER TABLE articles DROP CONSTRAINT articles_pkey RESTRICT;
DROP VIEW x;
/* multiple dependencies */ CREATE TEMPORARY VIEW x AS SELECT x.x, x.x, x.x, x.x, x.x FROM x AS x JOIN x AS x ON x.x = x.x WHERE x.x IN (14, 62, 70, 53, 138) GROUP BY x.x, x.x, x.x;
ALTER TABLE articles DROP CONSTRAINT articles_pkey RESTRICT;
/* fail */ ALTER TABLE articles_in_category DROP CONSTRAINT articles_in_category_pkey RESTRICT;
/* fail */ DROP VIEW x;
/* nested queries */ CREATE TEMPORARY VIEW x AS SELECT x, x, x, x, x FROM x GROUP BY x UNION SELECT x, x, x, x, x FROM x GROUP BY x;
ALTER TABLE articles DROP CONSTRAINT articles_pkey RESTRICT;
/* fail */ DROP VIEW x;
CREATE TEMPORARY VIEW x AS SELECT * FROM x WHERE x IN (SELECT x FROM x GROUP BY x);
ALTER TABLE articles DROP CONSTRAINT articles_pkey RESTRICT;
/* fail */ DROP VIEW x;
/* prepared query plans: this results in failure on reuse */ PREPARE foo AS   SELECT id, keywords, title, body, created   FROM articles   GROUP BY id;
EXECUTE foo;
ALTER TABLE articles DROP CONSTRAINT articles_pkey RESTRICT;
EXECUTE foo;
/* keep these tests aligned with generated_virtual.sql */ CREATE SCHEMA x.x;
GRANT USAGE ON SCHEMA x TO x;
SET x = generated_stored_tests;
CREATE TABLE x (x INT PRIMARY KEY, x INT AS 55);
CREATE TABLE x (x INT PRIMARY KEY, x INT AS x * 2);
SELECT x, x, x, x, x, x FROM x.x WHERE x = 'generated_stored_tests' ORDER BY 1 NULLS LAST, 2 NULLS LAST;
SELECT x, x, x FROM x.x WHERE x = 'generated_stored_tests' ORDER BY 1 NULLS LAST, 2 NULLS LAST, 3 NULLS LAST;
/* references to other generated columns, including self-references */ CREATE TABLE x (x INT PRIMARY KEY, x INT AS x * 2);
CREATE TABLE x (x INT PRIMARY KEY, x INT AS x * 2, x INT AS x * 3);
/* a whole-row var is a self-reference on steroids, so disallow that too */ CREATE TABLE x (x INT PRIMARY KEY, x INT AS NUM_NULLS(x));
/* invalid reference */ CREATE TABLE x (x INT PRIMARY KEY, x INT AS x * 2);
/* generation expression must be immutable */ CREATE TABLE x (x INT PRIMARY KEY, x DOUBLE AS RAND());
/* ... but be sure that the immutability test is accurate */ CREATE TABLE x (x INT, x TEXT AS x || ' sec');
DROP TABLE x;
/* cannot have default/identity and generated */ CREATE TABLE x (x INT PRIMARY KEY, x INT DEFAULT 5 AS x * 2);
CREATE TABLE x (x INT PRIMARY KEY, x INT GENERATED ALWAYS AS IDENTITY AS x * 2);
/* various prohibited constructs */ CREATE TABLE x (x INT PRIMARY KEY, x INT AS AVG(x));
CREATE TABLE x (x INT PRIMARY KEY, x INT AS ROW_NUMBER() OVER (ORDER BY x NULLS LAST));
CREATE TABLE x (x INT PRIMARY KEY, x INT AS (SELECT x));
CREATE TABLE x (x INT PRIMARY KEY, x INT AS UNNEST(GENERATE_SERIES(1, x)));
/* GENERATED BY DEFAULT not allowed */ CREATE TABLE x (x INT PRIMARY KEY, x INT AS x * 2);
INSERT INTO x VALUES (1);
INSERT INTO x VALUES (2, DEFAULT);
/* ok */ INSERT INTO x VALUES (3, 33);
/* error */ INSERT INTO x VALUES (3, 33), (4, 44);
/* error */ INSERT INTO x VALUES (3, DEFAULT), (4, 44);
/* error */ INSERT INTO x VALUES (3, 33), (4, DEFAULT);
/* error */ INSERT INTO x VALUES (3, DEFAULT), (4, DEFAULT);
/* ok */ SELECT * FROM x ORDER BY x NULLS LAST;
SELECT x FROM x ORDER BY x NULLS LAST;
/* whole-row reference */ SELECT x, (SELECT x.x) FROM x ORDER BY x NULLS LAST;
/* sublink */ DELETE FROM x WHERE x >= 3;
UPDATE x SET x = x WHERE x = 1;
UPDATE x SET x = 11 WHERE x = 1;
/* error */ SELECT * FROM x ORDER BY x NULLS LAST;
SELECT x, x, x * 2 AS x FROM x ORDER BY x NULLS LAST;
SELECT x, x FROM x WHERE x = 4 ORDER BY x NULLS LAST;
/* test that overflow error happens on write */ INSERT INTO x VALUES (2000000000);
SELECT * FROM x;
DELETE FROM x WHERE x = 2000000000;
/* test with joins */ CREATE TABLE x (x INT, x INT);
INSERT INTO x VALUES (11, 1), (22, 2), (33, 3);
SELECT * FROM x, x WHERE x.x = x.x;
DROP TABLE x;
/* test UPDATE/DELETE quals */ SELECT * FROM x ORDER BY x NULLS LAST;
UPDATE x SET x = 3 WHERE x = 4 RETURNING x.*, x.*;
SELECT * FROM x ORDER BY x NULLS LAST;
DELETE FROM x WHERE x = 2;
SELECT * FROM x ORDER BY x NULLS LAST;
/* test MERGE */ CREATE TABLE x (x INT PRIMARY KEY, x INT, x INT, x INT AS x * 2, x INT AS x * 2);
INSERT INTO x VALUES (1, 5, 100);
MERGE INTO x AS x USING (VALUES (1, 10), (2, 20)) AS x ON x.x = x.x WHEN MATCHED THEN UPDATE SET x = x.x WHEN NOT MATCHED THEN INSERT VALUES (x.x, x.x, 200) RETURNING MERGE_ACTION(), x.*, x.*;
SELECT * FROM x ORDER BY x NULLS LAST;
DROP TABLE x;
CREATE TABLE x (x INT PRIMARY KEY, x INT AS x * 2);
INSERT INTO x (x) SELECT x FROM x AS x;
MERGE INTO x AS x USING x AS x ON 2 * x.x = x.x WHEN MATCHED THEN DELETE RETURNING *;
DROP TABLE x;
/* views */ CREATE VIEW x AS SELECT * FROM x;
SELECT * FROM x;
INSERT INTO x VALUES (4, 8);
/* error */ INSERT INTO x VALUES (5, DEFAULT);
/* ok */ INSERT INTO x VALUES (6, 66), (7, 77);
/* error */ INSERT INTO x VALUES (6, DEFAULT), (7, 77);
/* error */ INSERT INTO x VALUES (6, 66), (7, DEFAULT);
/* error */ INSERT INTO x VALUES (6, DEFAULT), (7, DEFAULT);
ALTER VIEW x ALTER COLUMN x SET DEFAULT 100 /* ok */;
INSERT INTO x VALUES (8, DEFAULT);
/* error */ INSERT INTO x VALUES (8, DEFAULT), (9, DEFAULT);
/* error */ SELECT * FROM x;
DELETE FROM x WHERE x >= 5;
DROP VIEW x;
/* CTEs */ WITH x AS (SELECT * FROM x) SELECT * FROM x;
/* inheritance */ CREATE TABLE x INHERITS (x);
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
/* can't have generated column that is a child of normal column */ CREATE TABLE x (x INT, x INT);
CREATE TABLE x (x INT, x INT AS x * 2) INHERITS (x);
/* error */ CREATE TABLE x (x INT, x INT AS x * 2);
ALTER TABLE gtest_normal_child INHERIT gtest_normal;
/* test inheritance mismatches between parent and child */ CREATE TABLE x (x INT, x INT DEFAULT 10) INHERITS (x);
/* error */ CREATE TABLE x (x INT, x INT GENERATED ALWAYS AS IDENTITY) INHERITS (x);
/* error */ CREATE TABLE x (x INT, x INT AS x * 22) INHERITS (x);
SELECT * FROM x;
SELECT * FROM x;
CREATE TABLE x (x INT NOT NULL, x INT);
ALTER TABLE gtestxx_1 INHERIT gtest1;
/* error */ CREATE TABLE x (x INT NOT NULL, x INT AS x * 2);
ALTER TABLE gtestxx_3 INHERIT gtest1;
/* ok */ CREATE TABLE x (x INT AS x * 2, x INT NOT NULL);
ALTER TABLE gtestxx_4 INHERIT gtest1;
/* ok */ /* test multiple inheritance mismatches */ CREATE TABLE x (x INT, x INT DEFAULT 55);
CREATE TABLE x INHERITS (x, x);
/* error */ DROP TABLE x;
CREATE TABLE x (x INT, x INT);
CREATE TABLE x INHERITS (x, x);
/* error */ DROP TABLE x;
CREATE TABLE x (x INT, x INT AS x * 22);
CREATE TABLE x INHERITS (x, x);
/* error */ CREATE TABLE x (x INT AS x + 1) INHERITS (x, x);
CREATE TABLE x (x INT AS x + 1) INHERITS (x);
INSERT INTO x VALUES (42);
x AS x;
UPDATE x SET x = x * 10;
x AS x;
DROP TABLE x CASCADE;
/* test stored update */ CREATE TABLE x (x INT, x INT AS x * 3);
INSERT INTO x (x) VALUES (1), (2), (3), (NULL);
SELECT * FROM x ORDER BY x NULLS LAST;
UPDATE x SET x = 22 WHERE x = 2;
SELECT * FROM x ORDER BY x NULLS LAST;
CREATE TABLE x (x TEXT, x TEXT AS x || '+' || x);
INSERT INTO x (x) VALUES ('a'), ('b'), ('c'), (NULL);
SELECT * FROM x ORDER BY x NULLS LAST;
UPDATE x SET x = 'bb' WHERE x = 'b';
SELECT * FROM x ORDER BY x NULLS LAST;
TRUNCATE TABLE x /* COPY */;
INSERT INTO x (x) VALUES (1), (2);
COPY INTO x TO x;
COPY INTO x (x, x) TO x;
COPY INTO x FROM x;
SELECT * FROM x ORDER BY x NULLS LAST;
TRUNCATE TABLE x;
INSERT INTO x (x) VALUES (1), (2);
COPY INTO x TO x;
COPY INTO x (x, x) TO x;
COPY INTO x FROM x;
SELECT * FROM x ORDER BY x NULLS LAST;
/* null values */ CREATE TABLE x (x INT PRIMARY KEY, x INT AS NULL);
INSERT INTO x VALUES (1);
SELECT * FROM x;
/* simple column reference for varlena types */ CREATE TABLE x (x VARCHAR, x VARCHAR AS x);
INSERT INTO x (x) VALUES ('01234567890123456789');
INSERT INTO x (x) VALUES (NULL);
SELECT * FROM x ORDER BY x NULLS LAST;
DROP TABLE x;
/* composite types */ CREATE TYPE double_int as (a int, b int);
CREATE TABLE x (x INT, x double_int AS (x * 2, x * 3));
INSERT INTO x VALUES (1), (6);
SELECT * FROM x;
DROP TABLE x;
DROP TYPE double_int;
INSERT INTO x VALUES (1), (2);
ALTER TABLE x ADD COLUMN x REGCLASS AS x;
SELECT * FROM x;
/* drop column behavior */ CREATE TABLE x (x INT PRIMARY KEY, x INT, x INT AS x * 2);
ALTER TABLE x DROP COLUMN x;
ALTER TABLE x DROP COLUMN x CASCADE /* fails */;
ALTER TABLE x DROP COLUMN x;
INSERT INTO x (x) VALUES (1);
/* privileges */ CREATE USER regress_user11;
CREATE TABLE x (x INT PRIMARY KEY, x INT, x INT AS x * 2);
INSERT INTO x VALUES (1, 10), (2, 20);
GRANT SELECT(x, x) ON x TO x;
CREATE FUNCTION x(x INT) RETURNS INT IMMUTABLE LANGUAGE SQL AS $$ SELECT a * 3 $$;
REVOKE ALL ON FUNCTION gf1(int) FROM PUBLIC;
CREATE TABLE x (x INT PRIMARY KEY, x INT, x INT AS GF1(x));
INSERT INTO x VALUES (1, 10), (2, 20);
GRANT SELECT(x, x), INSERT ON x TO x;
SET ROLE regress_user11;
SELECT x, x FROM x;
/* not allowed */ SELECT x, x FROM x;
/* allowed */ SELECT GF1(10);
/* not allowed */ INSERT INTO x VALUES (3, 30), (4, 40);
/* currently not allowed because of function permissions, should arguably be allowed */ SELECT x, x FROM x;
/* allowed (does not actually invoke the function) */ RESET ROLE;
DROP FUNCTION x (INT);
DROP FUNCTION x (INT);
DROP USER regress_user11;
/* check constraints */ CREATE TABLE x (x INT PRIMARY KEY, x INT AS x * 2 CHECK (x < 50));
INSERT INTO x (x) VALUES (10);
/* ok */ INSERT INTO x (x) VALUES (30);
ALTER TABLE x ALTER COLUMN x DROP DEFAULT, SET EXPRESSION AS (a * 100) /* violates constraint */;
ALTER TABLE x ALTER COLUMN x DROP DEFAULT, SET EXPRESSION AS (a * 3) /* violates constraint */;
/* ok */ CREATE TABLE x (x INT PRIMARY KEY, x INT AS x * 2);
INSERT INTO x (x) VALUES (10);
INSERT INTO x (x) VALUES (30);
ALTER TABLE x CHECK(x < 50);
ALTER TABLE x ADD COLUMN x DOUBLE DEFAULT RAND() CHECK (x < 50) /* fails on existing row */ /* table rewrite cases */;
ALTER TABLE x ADD COLUMN x DOUBLE DEFAULT RAND() CHECK (x < 61) /* fails on existing row */;
/* ok */ CREATE TABLE x (x INT PRIMARY KEY, x INT AS x * 2);
INSERT INTO x (x) VALUES (10);
INSERT INTO x (x) VALUES (30);
ALTER TABLE x ADD CONSTRAINT x CHECK (x < 50) NOT VALID;
ALTER TABLE gtest20b VALIDATE CONSTRAINT chk;
/* fails on existing row */ /* check with whole-row reference */ CREATE TABLE x (x INT, x INT AS x * 2);
ALTER TABLE x ADD CONSTRAINT x CHECK (NOT x IS NULL);
INSERT INTO x VALUES (1);
/* ok */ INSERT INTO x VALUES (NULL);
/* fails */ /* not-null constraints */ CREATE TABLE x (x INT PRIMARY KEY, x INT AS NULLIF(x, 0) NOT NULL);
INSERT INTO x (x) VALUES (1);
/* ok */ INSERT INTO x (x) VALUES (0);
/* violates constraint */ CREATE TABLE x (x INT PRIMARY KEY, x INT AS NULLIF(x, 0));
ALTER TABLE x ALTER COLUMN x SET NOT NULL;
INSERT INTO x (x) VALUES (1);
/* ok */ INSERT INTO x (x) VALUES (0);
ALTER TABLE x ALTER COLUMN x DROP NOT NULL /* violates constraint */;
INSERT INTO x (x) VALUES (0);
/* ok now */ /* index constraints */ CREATE TABLE x (x INT PRIMARY KEY, x INT AS x / 2 UNIQUE);
INSERT INTO x VALUES (2);
INSERT INTO x VALUES (3);
INSERT INTO x VALUES (4);
CREATE TABLE x (x INT, x INT AS x / 2, PRIMARY KEY (x NULLS LAST, x NULLS LAST));
INSERT INTO x VALUES (2);
INSERT INTO x VALUES (2);
/* indexes */ CREATE TABLE x (x INT, x INT AS x * 2);
CREATE INDEX x ON x(x NULLS LAST);
CREATE INDEX x ON x((x * 3) NULLS LAST);
CREATE INDEX x ON x(x NULLS LAST) WHERE x > 0;
SET x = off;
SET x = off;
EXPLAIN (COSTS OFF) SELECT * FROM gtest22c WHERE b = 4;
SELECT * FROM x WHERE x = 4;
EXPLAIN (COSTS OFF) SELECT * FROM gtest22c WHERE b * 3 = 6;
SELECT * FROM x WHERE x * 3 = 6;
EXPLAIN (COSTS OFF) SELECT * FROM gtest22c WHERE a = 1 AND b > 0;
SELECT * FROM x WHERE x = 1 AND x > 0;
ALTER TABLE x ALTER COLUMN x DROP DEFAULT, SET EXPRESSION AS (a * 4);
ANALYZE x;
EXPLAIN (COSTS OFF) SELECT * FROM gtest22c WHERE b = 8;
SELECT * FROM x WHERE x = 8;
EXPLAIN (COSTS OFF) SELECT * FROM gtest22c WHERE b * 3 = 12;
SELECT * FROM x WHERE x * 3 = 12;
EXPLAIN (COSTS OFF) SELECT * FROM gtest22c WHERE a = 1 AND b > 0;
SELECT * FROM x WHERE x = 1 AND x > 0;
RESET enable_seqscan;
RESET enable_bitmapscan;
/* foreign keys */ CREATE TABLE x (x INT PRIMARY KEY, x INT);
INSERT INTO x VALUES (1, 11), (2, 22), (3, 33);
CREATE TABLE x (x INT PRIMARY KEY, x INT AS x * 2 REFERENCES x (x) ON UPDATE CASCADE);
/* error */ CREATE TABLE x (x INT PRIMARY KEY, x INT AS x * 2 REFERENCES x (x) ON DELETE SET NULL);
/* error */ CREATE TABLE x (x INT PRIMARY KEY, x INT AS x * 2 REFERENCES x (x));
/* ok */ INSERT INTO x VALUES (5);
ALTER TABLE x ALTER COLUMN x DROP DEFAULT, SET EXPRESSION AS (a * 5) /* error */;
ALTER TABLE x ALTER COLUMN x DROP DEFAULT, SET EXPRESSION AS (a * 1) /* error */;
/* ok */ DROP TABLE x;
DROP TABLE x;
CREATE TABLE x (x INT, x INT AS x * 2, PRIMARY KEY (x NULLS LAST));
INSERT INTO x VALUES (1), (2), (3);
CREATE TABLE x (x INT PRIMARY KEY, x INT REFERENCES x (x));
INSERT INTO x VALUES (1, 2);
/* ok */ INSERT INTO x VALUES (2, 5);
/* error */ /* domains */ CREATE DOMAIN gtestdomain1 AS int CHECK (VALUE < 10);
CREATE TABLE x (x INT PRIMARY KEY, x gtestdomain1 AS x * 2);
INSERT INTO x (x) VALUES (4);
/* ok */ INSERT INTO x (x) VALUES (6);
/* error */ CREATE TYPE gtestdomain1range AS range (subtype = gtestdomain1);
CREATE TABLE x (x INT PRIMARY KEY, x gtestdomain1range AS GTESTDOMAIN1RANGE(x, x + 5));
INSERT INTO x (x) VALUES (4);
/* ok */ INSERT INTO x (x) VALUES (6);
/* error */ /* typed tables (currently not supported) */ CREATE TYPE gtest_type AS (f1 integer, f2 text, f3 bigint);
CREATE TABLE gtest28 OF gtest_type (f1 WITH OPTIONS GENERATED ALWAYS AS (f2 *2) STORED);
DROP TYPE gtest_type CASCADE;
/* partitioning cases */ CREATE TABLE x (x DATE NOT NULL, x BIGINT, x BIGINT) WITH (PARTITIONED_BY=RANGE(x));
/* error */ CREATE TABLE x (x DATE NOT NULL, x BIGINT, x BIGINT AS x * 2);
ALTER TABLE gtest_parent ATTACH PARTITION gtest_child FOR VALUES FROM ('2016-07-01') TO ('2016-08-01');
CREATE TABLE x (x DATE NOT NULL, x BIGINT, x BIGINT AS x * 2) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM ('2016-07-01') TO ('2016-08-01');
CREATE TABLE x PARTITION OF x (x DEFAULT 42 /* error */) FOR VALUES FROM ('2016-09-01') TO ('2016-10-01');
CREATE TABLE x (x DATE NOT NULL, x BIGINT, x BIGINT);
ALTER TABLE gtest_parent ATTACH PARTITION gtest_child3 FOR VALUES FROM ('2016-09-01') TO ('2016-10-01');
/* error */ DROP TABLE x;
CREATE TABLE x (x DATE NOT NULL, x BIGINT, x BIGINT DEFAULT 42);
ALTER TABLE gtest_parent ATTACH PARTITION gtest_child3 FOR VALUES FROM ('2016-09-01') TO ('2016-10-01');
/* error */ DROP TABLE x;
CREATE TABLE x (x DATE NOT NULL, x BIGINT, x BIGINT GENERATED ALWAYS AS IDENTITY);
ALTER TABLE gtest_parent ATTACH PARTITION gtest_child3 FOR VALUES FROM ('2016-09-01') TO ('2016-10-01');
/* error */ DROP TABLE x;
ALTER TABLE gtest_parent ATTACH PARTITION gtest_child3 FOR VALUES FROM ('2016-09-01') TO ('2016-10-01');
/* error */ DROP TABLE x;
CREATE TABLE x (x DATE NOT NULL, x BIGINT, x BIGINT AS x * 33);
ALTER TABLE gtest_parent ATTACH PARTITION gtest_child3 FOR VALUES FROM ('2016-09-01') TO ('2016-10-01');
INSERT INTO x (x, x) VALUES ('2016-07-15', 2);
INSERT INTO x (x, x) VALUES ('2016-08-15', 3);
SELECT CAST(x AS REGCLASS), * FROM x ORDER BY 1 NULLS LAST, 2 NULLS LAST, 3 NULLS LAST;
SELECT CAST(x AS REGCLASS), * FROM x ORDER BY 1 NULLS LAST, 2 NULLS LAST, 3 NULLS LAST;
SELECT CAST(x AS REGCLASS), * FROM x ORDER BY 1 NULLS LAST, 2 NULLS LAST, 3 NULLS LAST;
SELECT CAST(x AS REGCLASS), * FROM x ORDER BY 1 NULLS LAST, 2 NULLS LAST, 3 NULLS LAST;
UPDATE x SET x = x + 60 WHERE x = 1;
SELECT CAST(x AS REGCLASS), * FROM x ORDER BY 1 NULLS LAST, 2 NULLS LAST, 3 NULLS LAST;
ALTER TABLE ONLY x ALTER COLUMN x DROP DEFAULT, SET EXPRESSION AS (f2 * 4) /* alter only parent's and one child's generation expression */;
ALTER TABLE x ALTER COLUMN x DROP DEFAULT, SET EXPRESSION AS (f2 * 10);
ALTER TABLE x ALTER COLUMN x DROP DEFAULT, SET EXPRESSION AS (f2 * 2) /* alter generation expression of parent and all its children altogether */;
/* we leave these tables around for purposes of testing dump/reload/upgrade */ /* generated columns in partition key (not allowed) */ CREATE TABLE x (x DATE NOT NULL, x BIGINT, x BIGINT AS x * 2) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x (x DATE NOT NULL, x BIGINT, x BIGINT AS x * 2) WITH (PARTITIONED_BY=RANGE((x * 3)));
/* ALTER TABLE ... ADD COLUMN */ CREATE TABLE x (x INT PRIMARY KEY);
INSERT INTO x VALUES (3), (4);
ALTER TABLE gtest25 ADD COLUMN b int GENERATED ALWAYS AS (a * 2) STORED, ALTER COLUMN b SET EXPRESSION AS (a * 3);
SELECT * FROM x ORDER BY x NULLS LAST;
ALTER TABLE x ADD COLUMN x INT AS x * 4;
ALTER TABLE x ADD COLUMN x INT AS x * 4 /* error */;
ALTER TABLE x ADD COLUMN x INT DEFAULT 42, ADD COLUMN x INT AS x * 4 /* error */;
ALTER TABLE x ADD COLUMN x INT DEFAULT 101;
ALTER TABLE gtest25 ALTER COLUMN d SET DATA TYPE float8,   ADD COLUMN y float8 GENERATED ALWAYS AS (d * 4) STORED;
SELECT * FROM x ORDER BY x NULLS LAST;
INSERT INTO x (x, x) VALUES (3, 7), (4, 11);
ALTER TABLE x ALTER COLUMN x SET DATA TYPE TEXT;
ALTER TABLE x ALTER COLUMN x SET DATA TYPE DECIMAL /* error */;
ALTER TABLE x ALTER COLUMN x SET DATA TYPE BOOLEAN USING x <> 0;
ALTER TABLE x ALTER COLUMN x DROP DEFAULT /* error */;
/* error */ /* It's possible to alter the column types this way: */ ALTER TABLE gtest27   DROP COLUMN x,   ALTER COLUMN a TYPE bigint,   ALTER COLUMN b TYPE bigint,   ADD COLUMN x bigint GENERATED ALWAYS AS ((a + b) * 2) STORED;
/* ALTER TABLE ... ALTER COLUMN ... DROP EXPRESSION */ CREATE TABLE x (x INT, x INT AS x * 2);
INSERT INTO x (x) VALUES (3), (4);
SELECT * FROM x;
/* error */ ALTER TABLE gtest29 ALTER COLUMN a DROP EXPRESSION;
/* error */ ALTER TABLE gtest29 ALTER COLUMN a DROP EXPRESSION IF EXISTS;
ALTER TABLE x ALTER COLUMN x DROP DEFAULT, SET EXPRESSION AS (a * 3) /* notice */ /* Change the expression */;
SELECT * FROM x;
INSERT INTO x (x) VALUES (5);
INSERT INTO x (x, x) VALUES (6, 66);
SELECT * FROM x;
CREATE TABLE x INHERITS (x);
ALTER TABLE gtest30 ALTER COLUMN b DROP EXPRESSION;
CREATE TABLE x (x INT, x INT AS x * 2);
CREATE TABLE x INHERITS (x);
ALTER TABLE ONLY gtest30 ALTER COLUMN b DROP EXPRESSION;
/* error */ /* composite type dependencies */ CREATE TABLE x (x INT, x TEXT AS 'hello', x TEXT);
CREATE TABLE x (x INT, x gtest31_1);
ALTER TABLE x ALTER COLUMN x SET DATA TYPE VARCHAR;
/* Check it for a partitioned table, too */ CREATE TABLE x (x INT, x TEXT AS 'hello', x TEXT) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x (x INT, x gtest31_1);
ALTER TABLE x ALTER COLUMN x SET DATA TYPE VARCHAR;
/* triggers */ CREATE TABLE x (x INT PRIMARY KEY, x INT AS x * 2);
IF tg_op IN ('INSERT', 'UPDATE') THEN     RAISE INFO '%: %: new = %', TG_NAME, TG_WHEN, NEW;
IF tg_op = 'DELETE' THEN     RETURN OLD;
CREATE TRIGGER gtest1 BEFORE DELETE OR UPDATE ON gtest26   FOR EACH ROW   WHEN (OLD.b < 0)  -- ok   EXECUTE PROCEDURE gtest_trigger_func();
CREATE TRIGGER gtest2a BEFORE INSERT OR UPDATE ON gtest26   FOR EACH ROW   WHEN (NEW.b < 0)  -- error   EXECUTE PROCEDURE gtest_trigger_func();
CREATE TRIGGER gtest2b BEFORE INSERT OR UPDATE ON gtest26   FOR EACH ROW   WHEN (NEW.* IS NOT NULL)  -- error   EXECUTE PROCEDURE gtest_trigger_func();
CREATE TRIGGER gtest2 BEFORE INSERT ON gtest26   FOR EACH ROW   WHEN (NEW.a < 0)   EXECUTE PROCEDURE gtest_trigger_func();
CREATE TRIGGER gtest3 AFTER DELETE OR UPDATE ON gtest26   FOR EACH ROW   WHEN (OLD.b < 0)  -- ok   EXECUTE PROCEDURE gtest_trigger_func();
CREATE TRIGGER gtest4 AFTER INSERT OR UPDATE ON gtest26   FOR EACH ROW   WHEN (NEW.b < 0)  -- ok   EXECUTE PROCEDURE gtest_trigger_func();
INSERT INTO x (x) VALUES (-2), (0), (3);
SELECT * FROM x ORDER BY x NULLS LAST;
UPDATE x SET x = x * -2;
SELECT * FROM x ORDER BY x NULLS LAST;
DELETE FROM x WHERE x = -6;
SELECT * FROM x ORDER BY x NULLS LAST;
DROP TRIGGER gtest1 ON gtest26;
DROP TRIGGER gtest2 ON gtest26;
DROP TRIGGER gtest3 ON gtest26;
x AS x;
CREATE TRIGGER gtest11 BEFORE UPDATE OF b ON gtest26   FOR EACH ROW   EXECUTE PROCEDURE gtest_trigger_func3();
UPDATE x SET x = 1 WHERE x = 0;
DROP TRIGGER gtest11 ON gtest26;
TRUNCATE TABLE x;
x.x = 300;
x AS x;
COMMIT;
CREATE TRIGGER gtest12_01 BEFORE INSERT OR UPDATE ON gtest26   FOR EACH ROW   EXECUTE PROCEDURE gtest_trigger_func();
CREATE TRIGGER gtest12_02 BEFORE INSERT OR UPDATE ON gtest26   FOR EACH ROW   EXECUTE PROCEDURE gtest_trigger_func4();
CREATE TRIGGER gtest12_03 BEFORE INSERT OR UPDATE ON gtest26   FOR EACH ROW   EXECUTE PROCEDURE gtest_trigger_func();
INSERT INTO x (x) VALUES (1);
SELECT * FROM x ORDER BY x NULLS LAST;
UPDATE x SET x = 11 WHERE x = 10;
SELECT * FROM x ORDER BY x NULLS LAST;
/* LIKE INCLUDING GENERATED and dropped column handling */ CREATE TABLE x (x INT, x INT, x INT, x INT AS x * 2);
ALTER TABLE x DROP COLUMN x;
CREATE TABLE x (LIKE x INCLUDING GENERATED);
/* keep these tests aligned with generated_stored.sql */ CREATE SCHEMA x.x;
GRANT USAGE ON SCHEMA x TO x;
SET x = generated_virtual_tests;
SELECT x, x, x, x, x, x FROM x.x WHERE x = 'generated_virtual_tests' ORDER BY 1 NULLS LAST, 2 NULLS LAST;
SELECT x, x, x FROM x.x WHERE x = 'generated_virtual_tests' ORDER BY 1 NULLS LAST, 2 NULLS LAST, 3 NULLS LAST;
DROP TABLE x;
INSERT INTO x VALUES (1);
INSERT INTO x VALUES (2, DEFAULT);
/* ok */ INSERT INTO x VALUES (3, 33);
/* error */ INSERT INTO x VALUES (3, 33), (4, 44);
/* error */ INSERT INTO x VALUES (3, DEFAULT), (4, 44);
/* error */ INSERT INTO x VALUES (3, 33), (4, DEFAULT);
/* error */ INSERT INTO x VALUES (3, DEFAULT), (4, DEFAULT);
/* ok */ SELECT * FROM x ORDER BY x NULLS LAST;
SELECT x FROM x ORDER BY x NULLS LAST;
/* whole-row reference */ SELECT x, (SELECT x.x) FROM x ORDER BY x NULLS LAST;
/* sublink */ DELETE FROM x WHERE x >= 3;
UPDATE x SET x = x WHERE x = 1;
UPDATE x SET x = 11 WHERE x = 1;
/* error */ SELECT * FROM x ORDER BY x NULLS LAST;
SELECT x, x, x * 2 AS x FROM x ORDER BY x NULLS LAST;
SELECT x, x FROM x WHERE x = 4 ORDER BY x NULLS LAST;
/* test that overflow error happens on read */ INSERT INTO x VALUES (2000000000);
SELECT * FROM x;
DELETE FROM x WHERE x = 2000000000;
/* test with joins */ CREATE TABLE x (x INT, x INT);
INSERT INTO x VALUES (11, 1), (22, 2), (33, 3);
SELECT * FROM x, x WHERE x.x = x.x;
DROP TABLE x;
/* test UPDATE/DELETE quals */ SELECT * FROM x ORDER BY x NULLS LAST;
UPDATE x SET x = 3 WHERE x = 4 RETURNING x.*, x.*;
SELECT * FROM x ORDER BY x NULLS LAST;
DELETE FROM x WHERE x = 2;
SELECT * FROM x ORDER BY x NULLS LAST;
INSERT INTO x VALUES (1, 5, 100);
MERGE INTO x AS x USING (VALUES (1, 10), (2, 20)) AS x ON x.x = x.x WHEN MATCHED THEN UPDATE SET x = x.x WHEN NOT MATCHED THEN INSERT VALUES (x.x, x.x, 200) RETURNING MERGE_ACTION(), x.*, x.*;
SELECT * FROM x ORDER BY x NULLS LAST;
DROP TABLE x;
INSERT INTO x (x) SELECT x FROM x AS x;
MERGE INTO x AS x USING x AS x ON 2 * x.x = x.x WHEN MATCHED THEN DELETE RETURNING *;
DROP TABLE x;
/* views */ CREATE VIEW x AS SELECT * FROM x;
SELECT * FROM x;
INSERT INTO x VALUES (4, 8);
/* error */ INSERT INTO x VALUES (5, DEFAULT);
/* ok */ INSERT INTO x VALUES (6, 66), (7, 77);
/* error */ INSERT INTO x VALUES (6, DEFAULT), (7, 77);
/* error */ INSERT INTO x VALUES (6, 66), (7, DEFAULT);
/* error */ INSERT INTO x VALUES (6, DEFAULT), (7, DEFAULT);
ALTER VIEW x ALTER COLUMN x SET DEFAULT 100 /* ok */;
INSERT INTO x VALUES (8, DEFAULT);
/* error */ INSERT INTO x VALUES (8, DEFAULT), (9, DEFAULT);
/* error */ SELECT * FROM x;
DELETE FROM x WHERE x >= 5;
DROP VIEW x;
/* CTEs */ WITH x AS (SELECT * FROM x) SELECT * FROM x;
/* inheritance */ CREATE TABLE x INHERITS (x);
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
/* can't have generated column that is a child of normal column */ CREATE TABLE x (x INT, x INT);
ALTER TABLE gtest_normal_child INHERIT gtest_normal;
/* test inheritance mismatches between parent and child */ CREATE TABLE x (x INT, x INT DEFAULT 10) INHERITS (x);
/* error */ CREATE TABLE x (x INT, x INT GENERATED ALWAYS AS IDENTITY) INHERITS (x);
/* error */ CREATE TABLE x (x INT, x INT AS x * 22) INHERITS (x);
SELECT * FROM x;
SELECT * FROM x;
CREATE TABLE x (x INT NOT NULL, x INT);
ALTER TABLE gtestxx_1 INHERIT gtest1;
ALTER TABLE gtestxx_3 INHERIT gtest1;
ALTER TABLE gtestxx_4 INHERIT gtest1;
/* ok */ /* test multiple inheritance mismatches */ CREATE TABLE x (x INT, x INT DEFAULT 55);
CREATE TABLE x INHERITS (x, x);
/* error */ DROP TABLE x;
CREATE TABLE x (x INT, x INT);
CREATE TABLE x INHERITS (x, x);
/* error */ DROP TABLE x;
CREATE TABLE x INHERITS (x, x);
INSERT INTO x VALUES (42);
x AS x;
UPDATE x SET x = x * 10;
x AS x;
DROP TABLE x CASCADE;
INSERT INTO x (x) VALUES (1), (2), (3), (NULL);
SELECT * FROM x ORDER BY x NULLS LAST;
UPDATE x SET x = 22 WHERE x = 2;
SELECT * FROM x ORDER BY x NULLS LAST;
INSERT INTO x (x) VALUES ('a'), ('b'), ('c'), (NULL);
SELECT * FROM x ORDER BY x NULLS LAST;
UPDATE x SET x = 'bb' WHERE x = 'b';
SELECT * FROM x ORDER BY x NULLS LAST;
TRUNCATE TABLE x /* COPY */;
INSERT INTO x (x) VALUES (1), (2);
COPY INTO x TO x;
COPY INTO x (x, x) TO x;
COPY INTO x FROM x;
SELECT * FROM x ORDER BY x NULLS LAST;
TRUNCATE TABLE x;
INSERT INTO x (x) VALUES (1), (2);
COPY INTO x TO x;
COPY INTO x (x, x) TO x;
COPY INTO x FROM x;
SELECT * FROM x ORDER BY x NULLS LAST;
INSERT INTO x VALUES (1);
SELECT * FROM x;
INSERT INTO x (x) VALUES ('01234567890123456789');
INSERT INTO x (x) VALUES (NULL);
SELECT * FROM x ORDER BY x NULLS LAST;
DROP TABLE x;
/* composite types */ CREATE TYPE double_int as (a int, b int);
INSERT INTO x VALUES (1), (6);
SELECT * FROM x;
DROP TABLE x;
DROP TYPE double_int;
INSERT INTO x VALUES (1), (2);
ALTER TABLE gtest_tableoid ADD COLUMN   c regclass GENERATED ALWAYS AS (tableoid) VIRTUAL;
SELECT * FROM x;
ALTER TABLE x DROP COLUMN x;
ALTER TABLE x DROP COLUMN x CASCADE /* fails */;
ALTER TABLE x DROP COLUMN x;
INSERT INTO x (x) VALUES (1);
/* privileges */ CREATE USER regress_user11;
INSERT INTO x VALUES (1, 10), (2, 20);
GRANT SELECT(x, x) ON x TO x;
CREATE FUNCTION x(x INT) RETURNS INT IMMUTABLE LANGUAGE SQL AS $$ SELECT a * 3 $$;
REVOKE ALL ON FUNCTION gf1(int) FROM PUBLIC;
INSERT INTO x VALUES (1, 10), (2, 20);
GRANT SELECT(x, x), INSERT ON x TO x;
SET ROLE regress_user11;
SELECT x, x FROM x;
/* not allowed */ SELECT x, x FROM x;
/* allowed */ SELECT GF1(10);
/* not allowed */ INSERT INTO x VALUES (3, 30), (4, 40);
/* allowed (does not actually invoke the function) */ SELECT x, x FROM x;
/* currently not allowed because of function permissions, should arguably be allowed */ RESET ROLE;
DROP FUNCTION x (INT);
DROP FUNCTION x (INT);
DROP USER regress_user11;
INSERT INTO x (x) VALUES (10);
/* ok */ INSERT INTO x (x) VALUES (30);
ALTER TABLE x ALTER COLUMN x DROP DEFAULT, SET EXPRESSION AS (a * 100) /* violates constraint */;
ALTER TABLE x ALTER COLUMN x DROP DEFAULT, SET EXPRESSION AS (a * 3) /* violates constraint (currently not supported) */;
INSERT INTO x (x) VALUES (10);
INSERT INTO x (x) VALUES (30);
ALTER TABLE x CHECK(x < 50);
ALTER TABLE x ADD COLUMN x DOUBLE DEFAULT RAND() CHECK (x < 50) /* fails on existing row */ /* table rewrite cases */;
ALTER TABLE x ADD COLUMN x DOUBLE DEFAULT RAND() CHECK (x < 61) /* fails on existing row */;
INSERT INTO x (x) VALUES (10);
INSERT INTO x (x) VALUES (30);
ALTER TABLE x ADD CONSTRAINT x CHECK (x < 50) NOT VALID;
ALTER TABLE gtest20b VALIDATE CONSTRAINT chk;
ALTER TABLE x ADD CONSTRAINT x CHECK (NOT x IS NULL);
INSERT INTO x VALUES (1);
/* ok */ INSERT INTO x VALUES (NULL);
ALTER TABLE gtest21ax ADD CONSTRAINT cc NOT NULL b;
/* error */ DROP TABLE x;
ALTER TABLE x ALTER COLUMN x SET NOT NULL;
ALTER TABLE x ALTER COLUMN x DROP NOT NULL /* violates constraint */;
/* foreign keys */ CREATE TABLE x (x INT PRIMARY KEY, x INT);
CREATE TABLE x (x INT PRIMARY KEY, x INT REFERENCES x (x));
/* error */ /* domains */ CREATE DOMAIN gtestdomain1 AS int CHECK (VALUE < 10);
/* error */ CREATE TYPE gtestdomain1range AS range (subtype = gtestdomain1);
/* error */ /* typed tables (currently not supported) */ CREATE TYPE gtest_type AS (f1 integer, f2 text, f3 bigint);
CREATE TABLE gtest28 OF gtest_type (f1 WITH OPTIONS GENERATED ALWAYS AS (f2 *2) VIRTUAL);
DROP TYPE gtest_type CASCADE;
/* partitioning cases */ CREATE TABLE x (x DATE NOT NULL, x BIGINT, x BIGINT) WITH (PARTITIONED_BY=RANGE(x));
ALTER TABLE gtest_parent ATTACH PARTITION gtest_child FOR VALUES FROM ('2016-07-01') TO ('2016-08-01');
CREATE TABLE x PARTITION OF x FOR VALUES FROM ('2016-07-01') TO ('2016-08-01');
CREATE TABLE x PARTITION OF x (x DEFAULT 42 /* error */) FOR VALUES FROM ('2016-09-01') TO ('2016-10-01');
CREATE TABLE x (x DATE NOT NULL, x BIGINT, x BIGINT);
ALTER TABLE gtest_parent ATTACH PARTITION gtest_child3 FOR VALUES FROM ('2016-09-01') TO ('2016-10-01');
/* error */ DROP TABLE x;
CREATE TABLE x (x DATE NOT NULL, x BIGINT, x BIGINT DEFAULT 42);
ALTER TABLE gtest_parent ATTACH PARTITION gtest_child3 FOR VALUES FROM ('2016-09-01') TO ('2016-10-01');
/* error */ DROP TABLE x;
CREATE TABLE x (x DATE NOT NULL, x BIGINT, x BIGINT GENERATED ALWAYS AS IDENTITY);
ALTER TABLE gtest_parent ATTACH PARTITION gtest_child3 FOR VALUES FROM ('2016-09-01') TO ('2016-10-01');
/* error */ DROP TABLE x;
CREATE TABLE x (x DATE NOT NULL, x BIGINT, x BIGINT AS x * 33);
ALTER TABLE gtest_parent ATTACH PARTITION gtest_child3 FOR VALUES FROM ('2016-09-01') TO ('2016-10-01');
/* error */ DROP TABLE x;
ALTER TABLE gtest_parent ATTACH PARTITION gtest_child3 FOR VALUES FROM ('2016-09-01') TO ('2016-10-01');
INSERT INTO x (x, x) VALUES ('2016-07-15', 2);
INSERT INTO x (x, x) VALUES ('2016-08-15', 3);
SELECT CAST(x AS REGCLASS), * FROM x ORDER BY 1 NULLS LAST, 2 NULLS LAST, 3 NULLS LAST;
SELECT CAST(x AS REGCLASS), * FROM x ORDER BY 1 NULLS LAST, 2 NULLS LAST, 3 NULLS LAST;
SELECT CAST(x AS REGCLASS), * FROM x ORDER BY 1 NULLS LAST, 2 NULLS LAST, 3 NULLS LAST;
/* uses child's generation expression, not parent's */ SELECT CAST(x AS REGCLASS), * FROM x ORDER BY 1 NULLS LAST, 2 NULLS LAST, 3 NULLS LAST;
UPDATE x SET x = x + 60 WHERE x = 1;
SELECT CAST(x AS REGCLASS), * FROM x ORDER BY 1 NULLS LAST, 2 NULLS LAST, 3 NULLS LAST;
ALTER TABLE ONLY x ALTER COLUMN x DROP DEFAULT, SET EXPRESSION AS (f2 * 4) /* alter only parent's and one child's generation expression */;
ALTER TABLE x ALTER COLUMN x DROP DEFAULT, SET EXPRESSION AS (f2 * 10);
ALTER TABLE x ALTER COLUMN x DROP DEFAULT, SET EXPRESSION AS (f2 * 2) /* alter generation expression of parent and all its children altogether */;
/* ALTER TABLE ... ADD COLUMN */ CREATE TABLE x (x INT PRIMARY KEY);
INSERT INTO x VALUES (3), (4);
ALTER TABLE gtest25 ADD COLUMN b int GENERATED ALWAYS AS (a * 2) VIRTUAL, ALTER COLUMN b SET EXPRESSION AS (a * 3);
SELECT * FROM x ORDER BY x NULLS LAST;
ALTER TABLE gtest25 ADD COLUMN x int GENERATED ALWAYS AS (b * 4) VIRTUAL;
/* error */ ALTER TABLE gtest25 ADD COLUMN x int GENERATED ALWAYS AS (z * 4) VIRTUAL;
/* error */ ALTER TABLE gtest25 ADD COLUMN c int DEFAULT 42,   ADD COLUMN x int GENERATED ALWAYS AS (c * 4) VIRTUAL;
ALTER TABLE x ADD COLUMN x INT DEFAULT 101;
ALTER TABLE gtest25 ALTER COLUMN d SET DATA TYPE float8,   ADD COLUMN y float8 GENERATED ALWAYS AS (d * 4) VIRTUAL;
SELECT * FROM x ORDER BY x NULLS LAST;
INSERT INTO x (x, x) VALUES (3, 7), (4, 11);
ALTER TABLE x ALTER COLUMN x SET DATA TYPE TEXT;
ALTER TABLE x ALTER COLUMN x SET DATA TYPE DECIMAL /* error */;
ALTER TABLE x ALTER COLUMN x SET DATA TYPE BOOLEAN USING x <> 0;
ALTER TABLE x ALTER COLUMN x DROP DEFAULT /* error */;
/* error */ /* It's possible to alter the column types this way: */ ALTER TABLE gtest27   DROP COLUMN x,   ALTER COLUMN a TYPE bigint,   ALTER COLUMN b TYPE bigint,   ADD COLUMN x bigint GENERATED ALWAYS AS ((a + b) * 2) VIRTUAL;
INSERT INTO x (x) VALUES (3), (4);
SELECT * FROM x;
/* error */ ALTER TABLE gtest29 ALTER COLUMN a DROP EXPRESSION;
/* error */ ALTER TABLE gtest29 ALTER COLUMN a DROP EXPRESSION IF EXISTS;
ALTER TABLE x ALTER COLUMN x DROP DEFAULT, SET EXPRESSION AS (a * 3) /* notice */ /* Change the expression */;
SELECT * FROM x;
/* not supported */ INSERT INTO x (x) VALUES (5);
INSERT INTO x (x, x) VALUES (6, 66);
SELECT * FROM x;
CREATE TABLE x INHERITS (x);
ALTER TABLE gtest30 ALTER COLUMN b DROP EXPRESSION;
CREATE TABLE x INHERITS (x);
ALTER TABLE ONLY gtest30 ALTER COLUMN b DROP EXPRESSION;
CREATE TABLE x (x INT, x gtest31_1);
ALTER TABLE x ALTER COLUMN x SET DATA TYPE VARCHAR;
CREATE TABLE x (x INT, x gtest31_1);
ALTER TABLE x ALTER COLUMN x SET DATA TYPE VARCHAR;
IF tg_op IN ('INSERT', 'UPDATE') THEN     RAISE INFO '%: %: new = %', TG_NAME, TG_WHEN, NEW;
IF tg_op = 'DELETE' THEN     RETURN OLD;
CREATE TRIGGER gtest1 BEFORE DELETE OR UPDATE ON gtest26   FOR EACH ROW   WHEN (OLD.b < 0)  -- ok   EXECUTE PROCEDURE gtest_trigger_func();
CREATE TRIGGER gtest2a BEFORE INSERT OR UPDATE ON gtest26   FOR EACH ROW   WHEN (NEW.b < 0)  -- error   EXECUTE PROCEDURE gtest_trigger_func();
CREATE TRIGGER gtest2b BEFORE INSERT OR UPDATE ON gtest26   FOR EACH ROW   WHEN (NEW.* IS NOT NULL)  -- error   EXECUTE PROCEDURE gtest_trigger_func();
CREATE TRIGGER gtest2 BEFORE INSERT ON gtest26   FOR EACH ROW   WHEN (NEW.a < 0)   EXECUTE PROCEDURE gtest_trigger_func();
CREATE TRIGGER gtest3 AFTER DELETE OR UPDATE ON gtest26   FOR EACH ROW   WHEN (OLD.b < 0)  -- ok   EXECUTE PROCEDURE gtest_trigger_func();
CREATE TRIGGER gtest4 AFTER INSERT OR UPDATE ON gtest26   FOR EACH ROW   WHEN (NEW.b < 0)  -- ok   EXECUTE PROCEDURE gtest_trigger_func();
INSERT INTO x (x) VALUES (-2), (0), (3);
SELECT * FROM x ORDER BY x NULLS LAST;
UPDATE x SET x = x * -2;
SELECT * FROM x ORDER BY x NULLS LAST;
DELETE FROM x WHERE x = -6;
SELECT * FROM x ORDER BY x NULLS LAST;
DROP TRIGGER gtest1 ON gtest26;
DROP TRIGGER gtest2 ON gtest26;
DROP TRIGGER gtest3 ON gtest26;
x AS x;
CREATE TRIGGER gtest11 BEFORE UPDATE OF b ON gtest26   FOR EACH ROW   EXECUTE PROCEDURE gtest_trigger_func3();
UPDATE x SET x = 1 WHERE x = 0;
DROP TRIGGER gtest11 ON gtest26;
TRUNCATE TABLE x;
x.x = 300;
x AS x;
COMMIT;
CREATE TRIGGER gtest12_01 BEFORE INSERT OR UPDATE ON gtest26   FOR EACH ROW   EXECUTE PROCEDURE gtest_trigger_func();
CREATE TRIGGER gtest12_02 BEFORE INSERT OR UPDATE ON gtest26   FOR EACH ROW   EXECUTE PROCEDURE gtest_trigger_func4();
CREATE TRIGGER gtest12_03 BEFORE INSERT OR UPDATE ON gtest26   FOR EACH ROW   EXECUTE PROCEDURE gtest_trigger_func();
INSERT INTO x (x) VALUES (1);
SELECT * FROM x ORDER BY x NULLS LAST;
UPDATE x SET x = 11 WHERE x = 10;
SELECT * FROM x ORDER BY x NULLS LAST;
ALTER TABLE x DROP COLUMN x;
CREATE TABLE x (LIKE x INCLUDING GENERATED);
/* test the expansion of virtual generated columns */ /* these tests are specific to generated_virtual.sql */ CREATE TABLE x (x INT PRIMARY KEY, x INT GENERATED ALWAYS AS (x * 2), x INT GENERATED ALWAYS AS (10 + 10), x INT GENERATED ALWAYS AS (COALESCE(x, 100)));
INSERT INTO x VALUES (1), (2);
ANALYZE x;
/* Ensure that nullingrel bits are propagated into the generation expressions */ EXPLAIN (costs off) select sum(t2.b) over (partition by t2.a),        sum(t2.c) over (partition by t2.a),        sum(t2.d) over (partition by t2.a) from gtest32 as t1 left join gtest32 as t2 on (t1.a = t2.a) order by t1.a;
SELECT SUM(x.x) OVER (PARTITION BY x.x), SUM(x.x) OVER (PARTITION BY x.x), SUM(x.x) OVER (PARTITION BY x.x) FROM x AS x LEFT JOIN x AS x ON (x.x = x.x) ORDER BY x.x NULLS LAST;
/* Ensure that outer-join removal functions correctly after the propagation of nullingrel bits */ EXPLAIN (costs off) select t1.a from gtest32 t1 left join gtest32 t2 on t1.a = t2.a where coalesce(t2.b, 1) = 2;
SELECT x.x FROM x AS x LEFT JOIN x AS x ON x.x = x.x WHERE COALESCE(x.x, 1) = 2;
EXPLAIN (costs off) select t1.a from gtest32 t1 left join gtest32 t2 on t1.a = t2.a where coalesce(t2.b, 1) = 2 or t1.a is null;
SELECT x.x FROM x AS x LEFT JOIN x AS x ON x.x = x.x WHERE COALESCE(x.x, 1) = 2 OR x.x IS NULL;
/* Ensure that the generation expressions are wrapped into PHVs if needed */ EXPLAIN (verbose, costs off) select t2.* from gtest32 t1 left join gtest32 t2 on false;
SELECT x.* FROM x AS x LEFT JOIN x AS x ON FALSE;
EXPLAIN (verbose, costs off) select * from gtest32 t group by grouping sets (a, b, c, d) having c = 20;
SELECT * FROM x AS x GROUP BY GROUPING SETS (x, x, x, x) HAVING x = 20;
DROP TABLE x;
SET x = -3 /* GEOMETRY */ /* Back off displayed precision a little bit to reduce platform-to-platform */ /* variation in results. */;
/* Points */ SELECT CENTER(x) AS x FROM x;
SELECT (MATCH() AGAINST(x)) AS x FROM x;
SELECT POINT(x) AS x FROM x;
SELECT (MATCH() AGAINST(x)) AS x FROM x;
/* Slope */ SELECT x.x, x.x, SLOPE(x.x, x.x) FROM x AS x, x AS x;
/* Add point */ SELECT x.x, x.x, x.x + x.x FROM x AS x, x AS x;
/* Subtract point */ SELECT x.x, x.x, x.x - x.x FROM x AS x, x AS x;
/* Multiply with point */ SELECT x.x, x.x, x.x * x.x FROM x AS x, x AS x WHERE x.x[-1] BETWEEN 1 AND 1000;
/* Underflow error */ SELECT x.x, x.x, x.x * x.x FROM x AS x, x AS x WHERE x.x[-1] < 1;
/* Divide by point */ SELECT x.x, x.x, x.x / x.x FROM x AS x, x AS x WHERE x.x[-1] BETWEEN 1 AND 1000;
/* Overflow error */ SELECT x.x, x.x, x.x / x.x FROM x AS x, x AS x WHERE x.x[-1] > 1000;
/* Distance to line */ SELECT x.x, x.x, x.x <-> x.x AS x, x.x <-> x.x AS x FROM x AS x, x AS x;
/* Distance to line segment */ SELECT x.x, x.x, x.x <-> x.x AS x, x.x <-> x.x AS x FROM x AS x, x AS x;
/* Distance to box */ SELECT x.x, x.x, x.x <-> x.x AS x, x.x <-> x.x AS x FROM x AS x, x AS x;
/* Distance to path */ SELECT x.x, x.x, x.x <-> x.x AS x, x.x <-> x.x AS x FROM x AS x, x AS x;
/* Distance to polygon */ SELECT x.x, x.x, x.x <-> x.x AS x, x.x <-> x.x AS x FROM x AS x, x AS x;
/* Construct line through two points */ SELECT x.x, x.x, LINE(x.x, x.x) FROM x AS x, x AS x WHERE x.x <> x.x;
/* On line */ SELECT x.x, x.x FROM x AS x, x AS x WHERE x.x @> x.x;
/* On line segment */ SELECT x.x, x.x FROM x AS x, x AS x WHERE x.x @> x.x;
/* On path */ SELECT x.x, x.x FROM x AS x, x AS x WHERE x.x @> x.x;
/* Lines */ /* Vertical */ SELECT x FROM x WHERE ? | x;
/* Horizontal */ SELECT x FROM x WHERE ? - x;
/* Same as line */ SELECT x.x, x.x FROM x AS x, x AS x WHERE x.x = x.x;
/* Distance to line */ SELECT x.x, x.x, x.x <-> x.x FROM x AS x, x AS x;
/* Intersection point with line */ SELECT x.x, x.x, x.x ^ x.x FROM x AS x, x AS x;
/* Line segments */ /* intersection */ SELECT x.x, x.x, x.x ^ x.x AS x FROM x AS x, x AS x;
/* Vertical */ SELECT x FROM x WHERE ? | x;
/* Horizontal */ SELECT x FROM x WHERE ? - x;
/* Center */ SELECT x, MATCH() AGAINST(x) FROM x;
/* To point */ SELECT x, CAST(x AS point) FROM x;
/* Has points less than line segment */ SELECT x.x, x.x FROM x AS x, x AS x WHERE x.x < x.x;
/* Has points less than or equal to line segment */ SELECT x.x, x.x FROM x AS x, x AS x WHERE x.x <= x.x;
/* Has points equal to line segment */ SELECT x.x, x.x FROM x AS x, x AS x WHERE x.x = x.x;
/* Has points greater than or equal to line segment */ SELECT x.x, x.x FROM x AS x, x AS x WHERE x.x >= x.x;
/* Has points greater than line segment */ SELECT x.x, x.x FROM x AS x, x AS x WHERE x.x > x.x;
/* Has points not equal to line segment */ SELECT x.x, x.x FROM x AS x, x AS x WHERE x.x <> x.x;
/* Distance to line */ SELECT x.x, x.x, x.x <-> x.x AS x, x.x <-> x.x AS x FROM x AS x, x AS x;
/* Distance to line segment */ SELECT x.x, x.x, x.x <-> x.x FROM x AS x, x AS x;
/* Distance to box */ SELECT x.x, x.x, x.x <-> x.x AS x, x.x <-> x.x AS x FROM x AS x, x AS x;
/* Intersection point with line segment */ SELECT x.x, x.x, x.x ^ x.x FROM x AS x, x AS x;
/* On line */ SELECT x.x, x.x FROM x AS x, x AS x WHERE x.x @> x.x;
/* On box */ SELECT x.x, x.x FROM x AS x, x AS x WHERE x.x @> x.x;
/* Boxes */ SELECT BOX(x) AS x FROM x;
/* translation */ SELECT x.x + x.x AS x FROM x AS x, x AS x;
SELECT x.x - x.x AS x FROM x AS x, x AS x;
/* Multiply with point */ SELECT x.x, x.x, x.x * x.x FROM x AS x, x AS x WHERE x.x[-1] BETWEEN 1 AND 1000;
/* Overflow error */ SELECT x.x, x.x, x.x * x.x FROM x AS x, x AS x WHERE x.x[-1] > 1000;
/* Divide by point */ SELECT x.x, x.x, x.x / x.x FROM x AS x, x AS x WHERE x.x[-1] BETWEEN 1 AND 1000;
/* To box */ SELECT CAST(x AS box) FROM x;
SELECT BOUND_BOX(x.x, x.x) FROM x AS x, x AS x;
/* Intersection point with box */ SELECT x.x, x.x, x.x ^ x.x FROM x AS x, x AS x;
/* Diagonal */ SELECT x, DIAGONAL(x) FROM x;
/* Distance to box */ SELECT x.x, x.x, x.x <-> x.x FROM x AS x, x AS x;
/* Paths */ /* Points */ SELECT x, NPOINTS(x) FROM x;
/* Area */ SELECT x, AREA(x) FROM x;
/* To polygon */ SELECT x, CAST(x AS polygon) FROM x WHERE ISCLOSED(x);
/* Open path cannot be converted to polygon error */ SELECT x, CAST(x AS polygon) FROM x WHERE ISOPEN(x);
/* Has points less than path */ SELECT x.x, x.x FROM x AS x, x AS x WHERE x.x < x.x;
/* Has points less than or equal to path */ SELECT x.x, x.x FROM x AS x, x AS x WHERE x.x <= x.x;
/* Has points equal to path */ SELECT x.x, x.x FROM x AS x, x AS x WHERE x.x = x.x;
/* Has points greater than or equal to path */ SELECT x.x, x.x FROM x AS x, x AS x WHERE x.x >= x.x;
/* Has points greater than path */ SELECT x.x, x.x FROM x AS x, x AS x WHERE x.x > x.x;
/* Add path */ SELECT x.x, x.x, x.x + x.x FROM x AS x, x AS x;
/* Add point */ SELECT x.x, x.x, x.x + x.x FROM x AS x, x AS x;
/* Subtract point */ SELECT x.x, x.x, x.x - x.x FROM x AS x, x AS x;
/* Multiply with point */ SELECT x.x, x.x, x.x * x.x FROM x AS x, x AS x;
/* Divide by point */ SELECT x.x, x.x, x.x / x.x FROM x AS x, x AS x WHERE x.x[-1] BETWEEN 1 AND 1000;
/* Distance to path */ SELECT x.x, x.x, x.x <-> x.x FROM x AS x, x AS x;
/* Polygons */ /* containment */ SELECT x.x, x.x, x.x @> x.x AS x FROM x AS x, x AS x;
SELECT x.x, x.x, x.x @> x.x AS x FROM x AS x, x AS x;
SELECT NPOINTS(x) AS x, x AS x FROM x;
SELECT POLYGON(x) FROM x;
SELECT POLYGON(x) FROM x WHERE ISCLOSED(x);
SELECT x AS x, POLYGON(PCLOSE(x)) AS x FROM x WHERE ISOPEN(x);
/* To box */ SELECT x, CAST(x AS box) FROM x;
/* To path */ SELECT x, CAST(x AS path) FROM x;
/* Contained by polygon */ SELECT x.x, x.x FROM x AS x, x AS x WHERE x.x @> x.x;
/* Contains polygon */ SELECT x.x, x.x FROM x AS x, x AS x WHERE x.x @> x.x;
/* Overlap with polygon */ SELECT x.x, x.x FROM x AS x, x AS x WHERE x.x && x.x;
/* Left of polygon */ SELECT x.x, x.x FROM x AS x, x AS x WHERE x.x << x.x;
/* Right of polygon */ SELECT x.x, x.x FROM x AS x, x AS x WHERE x.x >> x.x;
/* Distance to polygon */ SELECT x.x, x.x, x.x <-> x.x FROM x AS x, x AS x;
/* Circles */ SELECT CIRCLE(x, 50.0) FROM x;
SELECT CIRCLE(x) FROM x;
SELECT x.x AS x, x.x AS x, (x.x <-> x.x) AS x FROM x AS x, x AS x WHERE (x.x <-> x.x) > 0 ORDER BY x NULLS LAST, AREA(x.x) NULLS LAST, x.x[-1] NULLS LAST;
/* To polygon */ SELECT x, CAST(x AS polygon) FROM x WHERE x >= '<(0,0),1>';
/* To polygon with less points */ SELECT x, POLYGON(8, x) FROM x WHERE x >= '<(0,0),1>';
/* Error for insufficient number of points */ SELECT x, POLYGON(1, x) FROM x WHERE x >= '<(0,0),1>';
/* Zero radius error */ SELECT x, POLYGON(10, x) FROM x WHERE x < '<(0,0),1>';
/* Overlap with circle */ SELECT x.x, x.x FROM x AS x, x AS x WHERE x.x && x.x;
/* Left of circle */ SELECT x.x, x.x FROM x AS x, x AS x WHERE x.x << x.x;
/* Right of circle */ SELECT x.x, x.x FROM x AS x, x AS x WHERE x.x >> x.x;
/* Contained by circle */ SELECT x.x, x.x FROM x AS x, x AS x WHERE x.x @> x.x;
/* Contain by circle */ SELECT x.x, x.x FROM x AS x, x AS x WHERE x.x @> x.x;
/* Area equal with circle */ SELECT x.x, x.x FROM x AS x, x AS x WHERE x.x = x.x;
/* Area not equal with circle */ SELECT x.x, x.x FROM x AS x, x AS x WHERE x.x <> x.x;
/* Area less than circle */ SELECT x.x, x.x FROM x AS x, x AS x WHERE x.x < x.x;
/* Area greater than circle */ SELECT x.x, x.x FROM x AS x, x AS x WHERE x.x > x.x;
/* Area less than or equal circle */ SELECT x.x, x.x FROM x AS x, x AS x WHERE x.x <= x.x;
/* Area greater than or equal circle */ SELECT x.x, x.x FROM x AS x, x AS x WHERE x.x >= x.x;
/* Area less than circle */ SELECT x.x, x.x FROM x AS x, x AS x WHERE x.x < x.x;
/* Area greater than circle */ SELECT x.x, x.x FROM x AS x, x AS x WHERE x.x < x.x;
/* Add point */ SELECT x.x, x.x, x.x + x.x FROM x AS x, x AS x;
/* Subtract point */ SELECT x.x, x.x, x.x - x.x FROM x AS x, x AS x;
/* Multiply with point */ SELECT x.x, x.x, x.x * x.x FROM x AS x, x AS x;
/* Divide by point */ SELECT x.x, x.x, x.x / x.x FROM x AS x, x AS x WHERE x.x[-1] BETWEEN 1 AND 1000;
/* Overflow error */ SELECT x.x, x.x, x.x / x.x FROM x AS x, x AS x WHERE x.x[-1] > 1000;
/* Distance to polygon */ SELECT x.x, x.x, x.x <-> x.x FROM x AS x, x AS x;
/* Check index behavior for circles */ CREATE INDEX x ON x USING gist(x NULLS LAST);
SELECT * FROM x WHERE x && CIRCLE(POINT(1, -2), 1) ORDER BY AREA(x) NULLS LAST;
EXPLAIN (COSTS OFF) SELECT * FROM circle_tbl WHERE f1 && circle(point(1,-2), 1)     ORDER BY area(f1);
SELECT * FROM x WHERE x && CIRCLE(POINT(1, -2), 1) ORDER BY AREA(x) NULLS LAST;
/* Check index behavior for polygons */ CREATE INDEX x ON x USING gist(x NULLS LAST);
SELECT * FROM x WHERE x @> CAST('((1,1),(2,2),(2,1))' AS polygon) ORDER BY (POLY_CENTER(x))[-1] NULLS LAST;
EXPLAIN (COSTS OFF) SELECT * FROM polygon_tbl WHERE f1 @> '((1,1),(2,2),(2,1))'::polygon     ORDER BY (poly_center(f1))[0];
SELECT * FROM x WHERE x @> CAST('((1,1),(2,2),(2,1))' AS polygon) ORDER BY (POLY_CENTER(x))[-1] NULLS LAST;
/* test non-error-throwing API for some core types */ SELECT PG_INPUT_IS_VALID('(1', 'circle');
SELECT * FROM x;
SELECT PG_INPUT_IS_VALID('(1,2),-1', 'circle');
SELECT * FROM x;
/* Test GIN indexes. */ /* There are other tests to test different GIN opclasses. This is for testing */ /* GIN itself. */ /* Create and populate a test table with a GIN index. */ CREATE TABLE x (x ARRAY<INT>) WITH (autovacuum_enabled=off);
CREATE INDEX x ON x USING gin(x NULLS LAST) WITH (fastupdate=on, gin_pending_list_limit=4096);
INSERT INTO x SELECT ARRAY(1, 2, x) FROM x AS x;
INSERT INTO x SELECT ARRAY(1, 3, x) FROM x AS x;
SELECT GIN_CLEAN_PENDING_LIST('gin_test_idx') > 10 AS x;
/* flush the fastupdate buffers */ INSERT INTO x SELECT ARRAY(3, 1, x) FROM x AS x;
VACUUM gin_test_tbl;
/* flush the fastupdate buffers */ SELECT GIN_CLEAN_PENDING_LIST('gin_test_idx');
/* nothing to flush */ /* Test vacuuming */ DELETE FROM x WHERE x @> ARRAY(2);
VACUUM gin_test_tbl;
ALTER INDEX x SET x = x /* Disable fastupdate, and do more insertions. With fastupdate enabled, most */ /* insertions (by flushing the list pages) cause page splits. Without */ /* fastupdate, we get more churn in the GIN data leaf pages, and exercise the */ /* recompression codepaths. */;
INSERT INTO x SELECT ARRAY(1, 2, x) FROM x AS x;
INSERT INTO x SELECT ARRAY(1, 3, x) FROM x AS x;
DELETE FROM x WHERE x @> ARRAY(2);
VACUUM gin_test_tbl;
/* Test for "rare && frequent" searches */ EXPLAIN (costs off) select count(*) from gin_test_tbl where i @> array[1, 999];
SELECT COUNT(*) FROM x WHERE x @> ARRAY(1, 999);
SET x = 1000 /* Very weak test for gin_fuzzy_search_limit */;
EXPLAIN (costs off) select count(*) > 0 as ok from gin_test_tbl where i @> array[1];
SELECT COUNT(*) > 0 AS x FROM x WHERE x @> ARRAY(1);
RESET gin_fuzzy_search_limit;
/* Test optimization of empty queries */ CREATE TEMPORARY TABLE x (x ARRAY<INT>, x ARRAY<INT>);
CREATE INDEX ON x USING gin(x NULLS LAST, x NULLS LAST);
INSERT INTO x VALUES (NULL, NULL), ('{}', NULL), ('{1}', NULL), ('{1,2}', NULL), (NULL, '{}'), (NULL, '{10}'), ('{1,2}', '{10}'), ('{2}', '{10}'), ('{1,3}', '{}'), ('{1,1}', '{10}');
SET x = off;
EXPLAIN (costs off) select * from t_gin_test_tbl where array[0] <@ i;
SELECT * FROM x WHERE x @> ARRAY(0);
SELECT * FROM x WHERE x @> ARRAY(0) AND x @> CAST('{}' AS ARRAY<INT>);
EXPLAIN (costs off) select * from t_gin_test_tbl where i @> '{}';
SELECT * FROM x WHERE x @> '{}';
SET x = on;
COMMIT;
SET x = on;
COMMIT;
SET x = off;
COMMIT;
/* check number of rows returned by index and removed by recheck */ SELECT x, JSON_EXTRACT(JSON_EXTRACT(JSON_EXTRACT(JSON_EXTRACT(JSON_EXTRACT(x, '$[0]'), '$.Plan'), '$.Plans'), '$[0]'), '$["Actual Rows"]') AS "x", JSON_EXTRACT(JSON_EXTRACT(JSON_EXTRACT(x, '$[0]'), '$.Plan'), '$["Rows Removed by Index Recheck"]') AS "x", (x = x) AS "x" FROM (VALUES (' i @> ''{}'' '), (' j @> ''{}'' '), (' i @> ''{}'' and j @> ''{}'' '), (' i @> ''{1}'' '), (' i @> ''{1}'' and j @> ''{}'' '), (' i @> ''{1}'' and i @> ''{}'' and j @> ''{}'' '), (' j @> ''{10}'' '), (' j @> ''{10}'' and i @> ''{}'' '), (' j @> ''{10}'' and j @> ''{}'' and i @> ''{}'' '), (' i @> ''{1}'' and j @> ''{10}'' ')) AS x, LATERAL EXPLAIN_QUERY_JSON('select * from t_gin_test_tbl where ' || x) AS x, LATERAL EXECUTE_TEXT_QUERY_INDEX('select string_agg((i, j)::text, '' '') from t_gin_test_tbl where ' || x) AS x, LATERAL EXECUTE_TEXT_QUERY_HEAP('select string_agg((i, j)::text, '' '') from t_gin_test_tbl where ' || x) AS x;
RESET enable_seqscan;
RESET enable_bitmapscan;
/* re-purpose t_gin_test_tbl to test scans involving posting trees */ INSERT INTO x SELECT ARRAY(1, x, x / 10), ARRAY(2, x, x / 10) FROM x AS x;
SELECT NOT GIN_CLEAN_PENDING_LIST('t_gin_test_tbl_i_j_idx') IS NULL;
ANALYZE x;
SET x = off;
SET x = on;
EXPLAIN (costs off) select count(*) from t_gin_test_tbl where j @> array[50];
SELECT COUNT(*) FROM x WHERE x @> ARRAY(50);
EXPLAIN (costs off) select count(*) from t_gin_test_tbl where j @> array[2];
SELECT COUNT(*) FROM x WHERE x @> ARRAY(2);
EXPLAIN (costs off) select count(*) from t_gin_test_tbl where j @> '{}'::int[];
SELECT COUNT(*) FROM x WHERE x @> CAST('{}' AS ARRAY<INT>);
/* test vacuuming of posting trees */ DELETE FROM x WHERE x @> ARRAY(2);
VACUUM t_gin_test_tbl;
SELECT COUNT(*) FROM x WHERE x @> ARRAY(50);
SELECT COUNT(*) FROM x WHERE x @> ARRAY(2);
SELECT COUNT(*) FROM x WHERE x @> CAST('{}' AS ARRAY<INT>);
RESET enable_seqscan;
RESET enable_bitmapscan;
DROP TABLE x;
/* test an unlogged table, mostly to get coverage of ginbuildempty */ CREATE UNLOGGED TABLE x (x ARRAY<INT>, x ARRAY<INT>);
CREATE INDEX ON x USING gin(x NULLS LAST, x NULLS LAST);
INSERT INTO x VALUES (NULL, NULL), ('{}', NULL), ('{1}', '{2,3}');
DROP TABLE x;
/* Test GiST indexes. */ /* There are other tests to test different GiST opclasses. This is for */ /* testing GiST code itself. Vacuuming in particular. */ CREATE TABLE x (x INT, x point);
CREATE INDEX x ON x USING gist(x NULLS LAST);
/* Verify the fillfactor and buffering options */ CREATE INDEX x ON x USING gist(x NULLS LAST) WITH (buffering=on, fillfactor=50);
CREATE INDEX x ON x USING gist(x NULLS LAST) WITH (buffering=off);
CREATE INDEX x ON x USING gist(x NULLS LAST) WITH (buffering=auto);
/* Make sure bad values are refused */ CREATE INDEX x ON x USING gist(x NULLS LAST) WITH (buffering=invalid_value);
CREATE INDEX x ON x USING gist(x NULLS LAST) WITH (fillfactor=9);
CREATE INDEX x ON x USING gist(x NULLS LAST) WITH (fillfactor=101);
/* Insert enough data to create a tree that's a couple of levels deep. */ INSERT INTO x (x, x) SELECT x, POINT(x * 10, x * 10) FROM x AS x;
INSERT INTO x (x, x) SELECT x + 100000, POINT(x * 10 + 1, x * 10 + 1) FROM x AS x;
/* To test vacuum, delete some entries from all over the index. */ DELETE FROM x WHERE x % 2 = 1;
/* And also delete some concentration of values. */ DELETE FROM x WHERE x > 5000;
VACUUM analyze gist_point_tbl;
ALTER INDEX x SET x = 40 /* rebuild the index with a different fillfactor */;
REINDEX index gist_pointidx;
/* Test Index-only plans on GiST indexes */ CREATE TABLE x (x box, x point, x circle);
INSERT INTO x SELECT BOX(POINT(0.05 * x, 0.05 * x), POINT(0.05 * x, 0.05 * x)), POINT(0.05 * x, 0.05 * x), CIRCLE(POINT(0.05 * x, 0.05 * x), 1.0) FROM x AS x;
VACUUM analyze gist_tbl;
SET x = off;
SET x = off;
SET x = on;
/* Test index-only scan with point opclass */ CREATE INDEX x ON x USING gist(x NULLS LAST);
/* check that the planner chooses an index-only scan */ EXPLAIN (costs off) select p from gist_tbl where p <@ box(point(0,0), point(0.5, 0.5));
/* execute the same */ SELECT x FROM x WHERE BOX(POINT(0, 0), POINT(0.5, 0.5)) @> x;
/* Also test an index-only knn-search */ EXPLAIN (costs off) select p from gist_tbl where p <@ box(point(0,0), point(0.5, 0.5)) order by p <-> point(0.201, 0.201);
SELECT x FROM x WHERE BOX(POINT(0, 0), POINT(0.5, 0.5)) @> x ORDER BY x <-> POINT(0.201, 0.201) NULLS LAST;
/* Check commuted case as well */ EXPLAIN (costs off) select p from gist_tbl where p <@ box(point(0,0), point(0.5, 0.5)) order by point(0.101, 0.101) <-> p;
SELECT x FROM x WHERE BOX(POINT(0, 0), POINT(0.5, 0.5)) @> x ORDER BY POINT(0.101, 0.101) <-> x NULLS LAST;
/* Check case with multiple rescans (bug #14641) */ EXPLAIN (costs off) select p from   (values (box(point(0,0), point(0.5,0.5))),           (box(point(0.5,0.5), point(0.75,0.75))),           (box(point(0.8,0.8), point(1.0,1.0)))) as v(bb) cross join lateral   (select p from gist_tbl where p <@ bb order by p <-> bb[0] limit 2) ss;
SELECT x FROM (VALUES (BOX(POINT(0, 0), POINT(0.5, 0.5))), (BOX(POINT(0.5, 0.5), POINT(0.75, 0.75))), (BOX(POINT(0.8, 0.8), POINT(1.0, 1.0)))) AS x CROSS JOIN LATERAL (SELECT x FROM x WHERE x @> x ORDER BY x <-> x[-1] NULLS LAST LIMIT 2) AS x;
DROP INDEX x;
/* Test index-only scan with box opclass */ CREATE INDEX x ON x USING gist(x NULLS LAST);
/* check that the planner chooses an index-only scan */ EXPLAIN (costs off) select b from gist_tbl where b <@ box(point(5,5), point(6,6));
/* execute the same */ SELECT x FROM x WHERE BOX(POINT(5, 5), POINT(6, 6)) @> x;
/* Also test an index-only knn-search */ EXPLAIN (costs off) select b from gist_tbl where b <@ box(point(5,5), point(6,6)) order by b <-> point(5.2, 5.91);
SELECT x FROM x WHERE BOX(POINT(5, 5), POINT(6, 6)) @> x ORDER BY x <-> POINT(5.2, 5.91) NULLS LAST;
/* Check commuted case as well */ EXPLAIN (costs off) select b from gist_tbl where b <@ box(point(5,5), point(6,6)) order by point(5.2, 5.91) <-> b;
SELECT x FROM x WHERE BOX(POINT(5, 5), POINT(6, 6)) @> x ORDER BY POINT(5.2, 5.91) <-> x NULLS LAST;
DROP INDEX x;
/* Test that an index-only scan is not chosen, when the query involves the */ /* circle column (the circle opclass does not support index-only scans). */ CREATE INDEX x ON x USING gist(x NULLS LAST, x NULLS LAST);
EXPLAIN (costs off) select p, c from gist_tbl where p <@ box(point(5,5), point(6, 6));
/* execute the same */ SELECT x, x FROM x WHERE BOX(POINT(4.5, 4.5), POINT(5.5, 5.5)) @> x AND BOX(POINT(5, 5), POINT(6, 6)) @> x;
DROP INDEX x;
/* Test that we don't try to return the value of a non-returnable */ /* column in an index-only scan.  (This isn't GIST-specific, but */ /* it only applies to index AMs that can return some columns and not */ /* others, so GIST with appropriate opclasses is a convenient test case.) */ CREATE INDEX x ON x USING gist(CIRCLE(x, 1) NULLS LAST, x NULLS LAST);
EXPLAIN (verbose, costs off) select circle(p,1) from gist_tbl where p <@ box(point(5, 5), point(5.3, 5.3));
SELECT CIRCLE(x, 1) FROM x WHERE BOX(POINT(5, 5), POINT(5.3, 5.3)) @> x;
/* Similarly, test that index rechecks involving a non-returnable column */ /* are done correctly. */ EXPLAIN (verbose, costs off) select p from gist_tbl where circle(p,1) @> circle(point(0,0),0.95);
SELECT x FROM x WHERE CIRCLE(x, 1) @> CIRCLE(POINT(0, 0), 0.95);
/* Also check that use_physical_tlist doesn't trigger in such cases. */ EXPLAIN (verbose, costs off) select count(*) from gist_tbl;
SELECT COUNT(*) FROM x;
/* This case isn't supported, but it should at least EXPLAIN correctly. */ EXPLAIN (verbose, costs off) select p from gist_tbl order by circle(p,1) <-> point(0,0) limit 1;
SELECT x FROM x ORDER BY CIRCLE(x, 1) <-> POINT(0, 0) NULLS LAST LIMIT 1;
/* Force an index build using buffering. */ CREATE INDEX x ON x USING gist(x NULLS LAST) WITH (buffering=on, fillfactor=50);
/* Clean up */ RESET enable_seqscan;
RESET enable_bitmapscan;
RESET enable_indexonlyscan;
DROP TABLE x;
/* test an unlogged table, mostly to get coverage of gistbuildempty */ CREATE UNLOGGED TABLE x (x box);
CREATE INDEX x ON x USING gist(x NULLS LAST);
INSERT INTO x SELECT BOX(POINT(0.05 * x, 0.05 * x)) FROM x AS x;
DROP TABLE x;
/* grouping sets */ /* test data sources */ CREATE TEMPORARY VIEW x (x, x, x) AS VALUES (1, 1, 10), (1, 1, 11), (1, 2, 12), (1, 2, 13), (1, 3, 14), (2, 3, 15), (3, 3, 16), (3, 4, 17), (4, 1, 18), (4, 1, 19);
CREATE TEMPORARY TABLE x (x INT, x INT, x INT, x INT, x INT, x INT, x INT, x INT);
COPY INTO x FROM x;
COPY INTO x FROM x;
CREATE TEMPORARY TABLE x (x INT, x INT, x BIT(4), x xid);
INSERT INTO x VALUES (1, 1, 0, '1'), (2, 2, 1, '1'), (3, 4, 2, '2'), (4, 8, 3, '2'), (5, 16, 0, '2'), (6, 32, 1, '2'), (7, 64, 2, '1'), (8, 128, 3, '1');
CREATE TEMPORARY TABLE x (x INT, x INT, x INT);
COMMIT;
SET x = FALSE /* basic functionality */;
/* test hashing explicitly later */ /* simple rollup with multiple plain aggregates, with and without ordering */ /* (and with ordering differing from grouping) */ SELECT x, x, GROUPING(x, x), SUM(x), COUNT(*), MAX(x) FROM x GROUP BY ROLLUP (x, x);
SELECT x, x, GROUPING(x, x), SUM(x), COUNT(*), MAX(x) FROM x GROUP BY ROLLUP (x, x) ORDER BY x NULLS LAST, x NULLS LAST;
SELECT x, x, GROUPING(x, x), SUM(x), COUNT(*), MAX(x) FROM x GROUP BY ROLLUP (x, x) ORDER BY x DESC NULLS FIRST, x NULLS LAST;
SELECT x, x, GROUPING(x, x), SUM(x), COUNT(*), MAX(x) FROM x GROUP BY ROLLUP (x, x) ORDER BY COALESCE(x, 0) + COALESCE(x, 0) NULLS LAST;
/* various types of ordered aggs */ SELECT x, x, GROUPING(x, x), ARRAY_AGG(x ORDER BY x NULLS LAST), GROUP_CONCAT(CAST(x AS TEXT), ':' ORDER BY x DESC NULLS FIRST), PERCENTILE_DISC(0.5) WITHIN GROUP (ORDER BY x NULLS LAST), RANK(1, 2, 12) WITHIN GROUP (ORDER BY x NULLS LAST, x NULLS LAST, x NULLS LAST) FROM x GROUP BY ROLLUP (x, x) ORDER BY x NULLS LAST, x NULLS LAST;
/* test usage of grouped columns in direct args of aggs */ SELECT GROUPING(x), x, ARRAY_AGG(x), RANK(x) WITHIN GROUP (ORDER BY x), RANK(x) WITHIN GROUP (ORDER BY x NULLS LAST) FROM (VALUES (1, 1), (1, 4), (1, 5), (3, 1), (3, 2)) AS x GROUP BY ROLLUP (x) ORDER BY x NULLS LAST;
/* nesting with window functions */ SELECT x, x, SUM(x), SUM(SUM(x)) OVER (ORDER BY x NULLS LAST, x NULLS LAST) AS x FROM x GROUP BY ROLLUP (x, x) ORDER BY x NULLS LAST, x NULLS LAST, x NULLS LAST;
/* empty input: first is 0 rows, second 1, third 3 etc. */ SELECT x, x, SUM(x), COUNT(*) FROM x GROUP BY GROUPING SETS ((x, x), x);
SELECT x, x, SUM(x), COUNT(*) FROM x GROUP BY GROUPING SETS ((x, x), ());
SELECT x, x, SUM(x), COUNT(*) FROM x GROUP BY GROUPING SETS ((x, x), (), (), ());
SELECT SUM(x), COUNT(*) FROM x GROUP BY GROUPING SETS ((), (), ());
/* empty input with joins tests some important code paths */ SELECT x.x, x.x, SUM(x.x), COUNT(*) FROM x AS x, x AS x GROUP BY GROUPING SETS ((x.x, x.x), ());
/* simple joins, var resolution, GROUPING on join vars */ SELECT x.x, x.x, GROUPING(x.x, x.x), SUM(x.x), MAX(x.x) FROM x AS x, x AS x GROUP BY GROUPING SETS ((x.x, x.x), ());
SELECT x.x, x.x, GROUPING(x.x, x.x), SUM(x.x), MAX(x.x) FROM x AS x JOIN x AS x ON (x.x = x.x) GROUP BY GROUPING SETS ((x.x, x.x), ());
SELECT x, x, GROUPING(x, x), SUM(x.x), MAX(x.x) FROM x AS x JOIN x AS x USING (x, x) GROUP BY GROUPING SETS ((x, x), ());
/* check that functionally dependent cols are not nulled */ SELECT x, x, GROUPING(x, x, x) FROM x GROUP BY GROUPING SETS ((x, x), (x, x));
/* check that distinct grouping columns are kept separate */ /* even if they are equal() */ EXPLAIN (costs off) select g as alias1, g as alias2   from generate_series(1,3) g  group by alias1, rollup(alias2);
SELECT x AS x, x AS x FROM x AS x GROUP BY x, ROLLUP (x);
/* check that pulled-up subquery outputs still go to null when appropriate */ SELECT x, x FROM (SELECT x, x, CAST('foo' AS TEXT) AS x FROM x) AS x GROUP BY GROUPING SETS (x, x) HAVING x = 'foo';
SELECT x, x || 'x' FROM (SELECT x, x, CAST('foo' AS TEXT) AS x FROM x) AS x GROUP BY GROUPING SETS (x, x) ORDER BY x NULLS LAST;
SELECT x, NOT x AS x, x FROM (SELECT *, x = 1 AS x FROM x AS x) AS x GROUP BY GROUPING SETS (x, x) ORDER BY x NULLS LAST, x NULLS LAST;
SELECT x, x FROM (SELECT x AS x, x AS x FROM x) AS x GROUP BY GROUPING SETS (x, x) HAVING x IS NULL ORDER BY 1 NULLS LAST, 2 NULLS LAST;
SELECT x, x || 'y' FROM (SELECT x AS x, x AS x FROM x) AS x GROUP BY GROUPING SETS (x, x) ORDER BY 1 NULLS LAST, 2 NULLS LAST;
/* check qual push-down rules for a subquery with grouping sets */ EXPLAIN (verbose, costs off) select * from (   select 1 as x, q1, sum(q2)   from int8_tbl i1   group by grouping sets(1, 2) ) ss where x = 1 and q1 = 123;
SELECT * FROM (SELECT 1 AS x, x, SUM(x) FROM x AS x GROUP BY GROUPING SETS (1, 2)) AS x WHERE x = 1 AND x = 123;
/* check handling of pulled-up SubPlan in GROUPING() argument (bug #17479) */ EXPLAIN (verbose, costs off) select grouping(ss.x) from int8_tbl i1 cross join lateral (select (select i1.q1) as x) ss group by ss.x;
SELECT GROUPING(x.x) FROM x AS x CROSS JOIN LATERAL (SELECT (SELECT x.x) AS x) AS x GROUP BY x.x;
EXPLAIN (verbose, costs off) select (select grouping(ss.x)) from int8_tbl i1 cross join lateral (select (select i1.q1) as x) ss group by ss.x;
SELECT (SELECT GROUPING(x.x)) FROM x AS x CROSS JOIN LATERAL (SELECT (SELECT x.x) AS x) AS x GROUP BY x.x;
/* simple rescan tests */ SELECT x, x, SUM(x.x) FROM (VALUES (1), (2)) AS x, x GROUP BY ROLLUP (x, x);
SELECT * FROM (VALUES (1), (2)) AS x, LATERAL (SELECT x, x, SUM(x.x) FROM x GROUP BY ROLLUP (x, x)) AS x;
/* min max optimization should still work with GROUP BY () */ EXPLAIN (costs off)   select min(unique1) from tenk1 GROUP BY ();
/* Views with GROUPING SET queries */ CREATE VIEW x AS SELECT x, x, GROUPING(x, x), SUM(x), COUNT(*), MAX(x) FROM x GROUP BY ROLLUP ((x, x, x), (x, x));
SELECT PG_GET_VIEWDEF(CAST('gstest_view' AS REGCLASS), TRUE);
/* Nested queries with 3 or more levels of nesting */ SELECT (SELECT (SELECT GROUPING(x, x) FROM (VALUES (1)) AS x) FROM (VALUES (1, 2)) AS x GROUP BY (x, x)) FROM (VALUES (6, 7)) AS x GROUP BY ROLLUP (x, x);
SELECT (SELECT (SELECT GROUPING(x, x) FROM (VALUES (1)) AS x) FROM (VALUES (1, 2)) AS x GROUP BY (x, x)) FROM (VALUES (6, 7)) AS x GROUP BY ROLLUP (x, x);
SELECT (SELECT (SELECT GROUPING(x) FROM (VALUES (1)) AS x GROUP BY x) FROM (VALUES (1, 2)) AS x GROUP BY (x, x)) FROM (VALUES (6, 7)) AS x GROUP BY ROLLUP (x, x);
/* Combinations of operations */ SELECT x, x, x, x FROM x GROUP BY GROUPING SETS (x, x), ROLLUP (x, x);
SELECT x, x FROM (VALUES (1, 2), (2, 3)) AS x GROUP BY x, x, GROUPING SETS (x);
SELECT (SELECT (SELECT GROUPING(x, x) FROM (VALUES (1)) AS x) FROM (VALUES (1, 2)) AS x GROUP BY (x, x)) FROM (VALUES (6, 7)) AS x GROUP BY ROLLUP ((x + 1), (x + 1));
SELECT (SELECT (SELECT GROUPING(x, x) FROM (VALUES (1)) AS x) FROM (VALUES (1, 2)) AS x GROUP BY (x, x)) FROM (VALUES (6, 7)) AS x GROUP BY CUBE ((x + 1), (x + 1)) ORDER BY (x + 1) NULLS LAST, (x + 1) NULLS LAST;
SELECT x, x, SUM(x), SUM(SUM(x)) OVER (ORDER BY x NULLS LAST, x NULLS LAST) AS x FROM x GROUP BY CUBE (x, x) ORDER BY x NULLS LAST, x NULLS LAST, x NULLS LAST;
SELECT x, x, SUM(x) FROM (VALUES (1, 1, 10), (1, 1, 11), (1, 2, 12), (1, 2, 13), (1, 3, 14), (2, 3, 15), (3, 3, 16), (3, 4, 17), (4, 1, 18), (4, 1, 19)) AS x GROUP BY ROLLUP (x, x);
SELECT x, x, SUM(x.x) FROM (VALUES (1), (2)) AS x, x GROUP BY CUBE (x, x) ORDER BY x NULLS LAST, x NULLS LAST;
/* Test reordering of grouping sets */ EXPLAIN (costs off) select * from gstest1 group by grouping sets((a,b,v),(v)) order by v,b,a;
/* Agg level check. This query should error out. */ SELECT (SELECT GROUPING(x, x) FROM x) FROM x GROUP BY x, x;
/* HAVING queries */ SELECT x, SUM(DISTINCT x) FROM x AS x GROUP BY GROUPING SETS ((x, x), (x)) HAVING EXISTS(SELECT 1 FROM x AS x WHERE SUM(DISTINCT x.x) = x.x);
/* Tests around pushdown of HAVING clauses, partially testing against previous bugs */ SELECT x, COUNT(*) FROM x GROUP BY ROLLUP (x) ORDER BY x NULLS LAST;
SELECT x, COUNT(*) FROM x GROUP BY ROLLUP (x) HAVING x IS DISTINCT FROM 1 ORDER BY x NULLS LAST;
EXPLAIN (costs off)   select a,count(*) from gstest2 group by rollup(a) having a is distinct from 1 order by a;
SELECT x.x, (SELECT COUNT(*) FROM x GROUP BY () HAVING x.x) FROM (VALUES (FALSE), (TRUE)) AS x ORDER BY x.x NULLS LAST;
EXPLAIN (costs off)   select v.c, (select count(*) from gstest2 group by () having v.c)     from (values (false),(true)) v(c) order by v.c;
/* test pushdown of HAVING clause that does not reference any columns that are nullable by grouping sets */ EXPLAIN (costs off) select a, b, count(*) from gstest2 group by grouping sets ((a, b), (a)) having a > 1 and b > 1;
SELECT x, x, COUNT(*) FROM x GROUP BY GROUPING SETS ((x, x), (x)) HAVING x > 1 AND x > 1;
/* HAVING with GROUPING queries */ SELECT x, GROUPING(x) FROM x GROUP BY GROUPING SETS (x) HAVING GROUPING(x) >= 0 ORDER BY 2 NULLS LAST, 1 NULLS LAST;
SELECT x, GROUPING(x) FROM x GROUP BY GROUPING SETS (x, x) HAVING GROUPING(x) > 0 ORDER BY 2 NULLS LAST, 1 NULLS LAST;
SELECT x, GROUPING(x) FROM x GROUP BY ROLLUP (x) HAVING GROUPING(x) > 0 ORDER BY 2 NULLS LAST, 1 NULLS LAST;
SELECT x, GROUPING(x) FROM x GROUP BY CUBE (x) HAVING GROUPING(x) > 0 ORDER BY 2 NULLS LAST, 1 NULLS LAST;
SELECT x, GROUPING(x) FROM x GROUP BY (x) HAVING GROUPING(x) >= 0 ORDER BY 2 NULLS LAST, 1 NULLS LAST;
/* FILTER queries */ SELECT x, SUM(DISTINCT x) FILTER(WHERE REGEXP_LIKE(CAST(x AS TEXT), '123')) FROM x AS x GROUP BY ROLLUP (x);
/* More rescan tests */ SELECT * FROM (VALUES (1), (2)) AS x LEFT JOIN LATERAL (SELECT x.x, x, x, COUNT(*) FROM x GROUP BY CUBE (x, x)) AS x ON TRUE ORDER BY x.x NULLS LAST, x NULLS LAST, x NULLS LAST;
SELECT ARRAY(SELECT ROW(x.x, x.*) FROM (SELECT x, x, COUNT(*) FROM x GROUP BY CUBE (x, x) ORDER BY x NULLS LAST, x NULLS LAST) AS x) FROM (VALUES (1), (2)) AS x;
/* Grouping on text columns */ SELECT SUM(x) FROM x GROUP BY x, ROLLUP (CAST(x AS TEXT)) ORDER BY 1 NULLS LAST;
SELECT SUM(x) FROM x GROUP BY x, ROLLUP (CAST(x AS TEXT)) ORDER BY 1 NULLS LAST;
SET x = TRUE /* hashing support */;
/* failure cases */ SELECT COUNT(*) FROM x GROUP BY ROLLUP (x, x);
SELECT ARRAY_AGG(x ORDER BY x NULLS LAST) FROM x GROUP BY GROUPING SETS ((x, x), (x));
/* simple cases */ SELECT x, x, GROUPING(x, x), SUM(x), COUNT(*), MAX(x) FROM x GROUP BY GROUPING SETS ((x), (x)) ORDER BY 3 NULLS LAST, 1 NULLS LAST, 2 NULLS LAST;
EXPLAIN (costs off) select a, b, grouping(a,b), sum(v), count(*), max(v)   from gstest1 group by grouping sets ((a),(b)) order by 3,1,2;
SELECT x, x, GROUPING(x, x), SUM(x), COUNT(*), MAX(x) FROM x GROUP BY CUBE (x, x) ORDER BY 3 NULLS LAST, 1 NULLS LAST, 2 NULLS LAST;
EXPLAIN (costs off) select a, b, grouping(a,b), sum(v), count(*), max(v)   from gstest1 group by cube(a,b) order by 3,1,2;
/* shouldn't try and hash */ EXPLAIN (costs off)   select a, b, grouping(a,b), array_agg(v order by v)     from gstest1 group by cube(a,b);
/* unsortable cases */ SELECT x, COUNT(*) FROM x GROUP BY GROUPING SETS ((x), (x)) ORDER BY CAST(x AS TEXT) NULLS LAST;
/* mixed hashable/sortable cases */ SELECT x, x, GROUPING(x, x), COUNT(*), SUM(x) FROM x GROUP BY GROUPING SETS ((x), (x)) ORDER BY 3 NULLS LAST, 5 NULLS LAST;
EXPLAIN (costs off)   select unhashable_col, unsortable_col,          grouping(unhashable_col, unsortable_col),          count(*), sum(v)     from gstest4 group by grouping sets ((unhashable_col),(unsortable_col))    order by 3,5;
SELECT x, x, GROUPING(x, x), COUNT(*), SUM(x) FROM x GROUP BY GROUPING SETS ((x, x), (x, x)) ORDER BY 3 NULLS LAST, 5 NULLS LAST;
EXPLAIN (costs off)   select unhashable_col, unsortable_col,          grouping(unhashable_col, unsortable_col),          count(*), sum(v)     from gstest4 group by grouping sets ((v,unhashable_col),(v,unsortable_col))    order by 3,5;
/* empty input: first is 0 rows, second 1, third 3 etc. */ SELECT x, x, SUM(x), COUNT(*) FROM x GROUP BY GROUPING SETS ((x, x), x);
EXPLAIN (costs off)   select a, b, sum(v), count(*) from gstest_empty group by grouping sets ((a,b),a);
SELECT x, x, SUM(x), COUNT(*) FROM x GROUP BY GROUPING SETS ((x, x), ());
SELECT x, x, SUM(x), COUNT(*) FROM x GROUP BY GROUPING SETS ((x, x), (), (), ());
EXPLAIN (costs off)   select a, b, sum(v), count(*) from gstest_empty group by grouping sets ((a,b),(),(),());
SELECT SUM(x), COUNT(*) FROM x GROUP BY GROUPING SETS ((), (), ());
EXPLAIN (costs off)   select sum(v), count(*) from gstest_empty group by grouping sets ((),(),());
/* check that functionally dependent cols are not nulled */ SELECT x, x, GROUPING(x, x, x) FROM x GROUP BY GROUPING SETS ((x, x), (x, x));
EXPLAIN (costs off)   select a, d, grouping(a,b,c)     from gstest3    group by grouping sets ((a,b), (a,c));
/* simple rescan tests */ SELECT x, x, SUM(x.x) FROM (VALUES (1), (2)) AS x, x GROUP BY GROUPING SETS (x, x) ORDER BY 1 NULLS LAST, 2 NULLS LAST, 3 NULLS LAST;
EXPLAIN (costs off)   select a, b, sum(v.x)     from (values (1),(2)) v(x), gstest_data(v.x)    group by grouping sets (a,b)    order by 3, 1, 2;
SELECT * FROM (VALUES (1), (2)) AS x, LATERAL (SELECT x, x, SUM(x.x) FROM x GROUP BY GROUPING SETS (x, x)) AS x;
EXPLAIN (costs off)   select *     from (values (1),(2)) v(x),          lateral (select a, b, sum(v.x) from gstest_data(v.x) group by grouping sets (a,b)) s;
EXPLAIN (costs off)   select a, b, grouping(a,b), sum(v), count(*), max(v)     from gstest1 group by grouping sets ((a,b),(a+1,b+1),(a+2,b+2)) order by 3,6;
SELECT x, x, SUM(x), SUM(SUM(x)) OVER (ORDER BY x NULLS LAST, x NULLS LAST) AS x FROM x GROUP BY CUBE (x, x) ORDER BY x NULLS LAST, x NULLS LAST, x NULLS LAST;
EXPLAIN (costs off)   select a, b, sum(c), sum(sum(c)) over (order by a,b) as rsum     from gstest2 group by cube (a,b) order by rsum, a, b;
SELECT x, x, SUM(x.x) FROM (VALUES (1), (2)) AS x, x GROUP BY CUBE (x, x) ORDER BY x NULLS LAST, x NULLS LAST;
EXPLAIN (costs off)   select a, b, sum(v.x)     from (values (1),(2)) v(x), gstest_data(v.x)    group by cube (a,b) order by a,b;
/* Verify that we correctly handle the child node returning a */ /* non-minimal slot, which happens if the input is pre-sorted, */ /* e.g. due to an index scan. */ BEGIN;
SET LOCAL x = FALSE;
EXPLAIN (COSTS OFF) SELECT a, b, count(*), max(a), max(b) FROM gstest3 GROUP BY GROUPING SETS(a, b,()) ORDER BY a, b;
SELECT x, x, COUNT(*), MAX(x), MAX(x) FROM x GROUP BY GROUPING SETS (x, x, ()) ORDER BY x NULLS LAST, x NULLS LAST;
SET LOCAL x = FALSE;
EXPLAIN (COSTS OFF) SELECT a, b, count(*), max(a), max(b) FROM gstest3 GROUP BY GROUPING SETS(a, b,()) ORDER BY a, b;
SELECT x, x, COUNT(*), MAX(x), MAX(x) FROM x GROUP BY GROUPING SETS (x, x, ()) ORDER BY x NULLS LAST, x NULLS LAST;
COMMIT;
/* More rescan tests */ SELECT * FROM (VALUES (1), (2)) AS x LEFT JOIN LATERAL (SELECT x.x, x, x, COUNT(*) FROM x GROUP BY CUBE (x, x)) AS x ON TRUE ORDER BY x.x NULLS LAST, x NULLS LAST, x NULLS LAST;
SELECT ARRAY(SELECT ROW(x.x, x.*) FROM (SELECT x, x, COUNT(*) FROM x GROUP BY CUBE (x, x) ORDER BY x NULLS LAST, x NULLS LAST) AS x) FROM (VALUES (1), (2)) AS x;
/* Rescan logic changes when there are no empty grouping sets, so test */ /* that too: */ SELECT * FROM (VALUES (1), (2)) AS x LEFT JOIN LATERAL (SELECT x.x, x, x, COUNT(*) FROM x GROUP BY GROUPING SETS (x, x)) AS x ON TRUE ORDER BY x.x NULLS LAST, x NULLS LAST, x NULLS LAST;
SELECT ARRAY(SELECT ROW(x.x, x.*) FROM (SELECT x, x, COUNT(*) FROM x GROUP BY GROUPING SETS (x, x) ORDER BY x NULLS LAST, x NULLS LAST) AS x) FROM (VALUES (1), (2)) AS x;
SET x = FALSE /* test the knapsack */;
SET x = 1.0;
SET x = '64kB';
EXPLAIN (costs off)   select unique1,          count(two), count(four), count(ten),          count(hundred), count(thousand), count(twothousand),          count(*)     from tenk1 group by grouping sets (unique1,twothousand,thousand,hundred,ten,four,two);
EXPLAIN (costs off)   select unique1,          count(two), count(four), count(ten),          count(hundred), count(thousand), count(twothousand),          count(*)     from tenk1 group by grouping sets (unique1,hundred,ten,four,two);
SET x = '384kB';
EXPLAIN (costs off)   select unique1,          count(two), count(four), count(ten),          count(hundred), count(thousand), count(twothousand),          count(*)     from tenk1 group by grouping sets (unique1,twothousand,thousand,hundred,ten,four,two);
/* Bug #16784 */ CREATE TABLE x (x INT, x INT);
ANALYZE x;
ALTER TABLE x SET x = 'false';
UPDATE x SET x = 10 WHERE x = 'bug_16784';
INSERT INTO x SELECT x / 10, x FROM x AS x;
SET x = '64kB';
SET x = FALSE;
SELECT * FROM (VALUES (1), (2)) AS x, LATERAL (SELECT x, x, x, COUNT(*) FROM x GROUP BY CUBE (x, x)) AS x ORDER BY x.x NULLS LAST, x NULLS LAST, x NULLS LAST;
/* Compare results between plans using sorting and plans using hash */ /* aggregation. Force spilling in both cases by setting work_mem low */ /* and altering the statistics. */ CREATE TABLE x AS SELECT x % 1000 AS x, x % 100 AS x, x % 10 AS x, x FROM x AS x;
ANALYZE x;
ALTER TABLE x SET x = 'false';
UPDATE x SET x = 10 WHERE x = 'gs_data_1';
SET x = '64kB';
SET x = TRUE /* Produce results with sorting. */;
SET x = FALSE;
SET x = 0;
EXPLAIN (costs off) select g100, g10, sum(g::numeric), count(*), max(g::text) from gs_data_1 group by cube (g1000, g100,g10);
CREATE TABLE x AS SELECT x, x, SUM(CAST(x AS DECIMAL)), COUNT(*), MAX(CAST(x AS TEXT)) FROM x GROUP BY CUBE (x, x, x);
SET x = TRUE /* Produce results with hash aggregation. */;
SET x = FALSE;
EXPLAIN (costs off) select g100, g10, sum(g::numeric), count(*), max(g::text) from gs_data_1 group by cube (g1000, g100,g10);
CREATE TABLE x AS SELECT x, x, SUM(CAST(x AS DECIMAL)), COUNT(*), MAX(CAST(x AS TEXT)) FROM x GROUP BY CUBE (x, x, x);
SET x = TRUE;
SET x = default;
SET x = default;
(SELECT * FROM x EXCEPT SELECT * FROM x) /* Compare results */ UNION ALL (SELECT * FROM x EXCEPT SELECT * FROM x);
DROP TABLE x;
DROP TABLE x;
/* GROUP BY DISTINCT */ /* "normal" behavior... */ SELECT x, x, x FROM (VALUES (1, 2, 3), (4, NULL, 6), (7, 8, 9)) AS x GROUP BY ALL ROLLUP (x, x), ROLLUP (x, x) ORDER BY x NULLS LAST, x NULLS LAST, x NULLS LAST;
/* ...which is also the default */ SELECT x, x, x FROM (VALUES (1, 2, 3), (4, NULL, 6), (7, 8, 9)) AS x GROUP BY ROLLUP (x, x), ROLLUP (x, x) ORDER BY x NULLS LAST, x NULLS LAST, x NULLS LAST;
/* "group by distinct" behavior... */ SELECT x, x, x FROM (VALUES (1, 2, 3), (4, NULL, 6), (7, 8, 9)) AS x GROUP BY DISTINCT ROLLUP (x, x), ROLLUP (x, x) ORDER BY x NULLS LAST, x NULLS LAST, x NULLS LAST;
/* ...which is not the same as "select distinct" */ SELECT DISTINCT x, x, x FROM (VALUES (1, 2, 3), (4, NULL, 6), (7, 8, 9)) AS x GROUP BY ROLLUP (x, x), ROLLUP (x, x) ORDER BY x NULLS LAST, x NULLS LAST, x NULLS LAST;
/* test handling of outer GroupingFunc within subqueries */ EXPLAIN (costs off) select (select grouping(v1)) from (values ((select 1))) v(v1) group by cube(v1);
SELECT (SELECT GROUPING(x)) FROM (VALUES ((SELECT 1))) AS x GROUP BY CUBE (x);
EXPLAIN (costs off) select (select grouping(v1)) from (values ((select 1))) v(v1) group by v1;
SELECT (SELECT GROUPING(x)) FROM (VALUES ((SELECT 1))) AS x GROUP BY x;
/* test handling of subqueries in grouping sets */ CREATE TEMPORARY TABLE x (x INT PRIMARY KEY, x INT);
INSERT INTO x SELECT x, x FROM x AS x;
EXPLAIN (verbose, costs off) select grouping((select t1.v from gstest5 t2 where id = t1.id)),        (select t1.v from gstest5 t2 where id = t1.id) as s from gstest5 t1 group by grouping sets(v, s) order by case when grouping((select t1.v from gstest5 t2 where id = t1.id)) = 0               then (select t1.v from gstest5 t2 where id = t1.id)               else null end          nulls first;
SELECT GROUPING((SELECT x.x FROM x AS x WHERE x = x.x)), (SELECT x.x FROM x AS x WHERE x = x.x) AS x FROM x AS x GROUP BY GROUPING SETS (x, x) ORDER BY CASE WHEN GROUPING((SELECT x.x FROM x AS x WHERE x = x.x)) = 0 THEN (SELECT x.x FROM x AS x WHERE x = x.x) ELSE NULL END;
EXPLAIN (verbose, costs off) select grouping((select t1.v from gstest5 t2 where id = t1.id)),        (select t1.v from gstest5 t2 where id = t1.id) as s,        case when grouping((select t1.v from gstest5 t2 where id = t1.id)) = 0             then (select t1.v from gstest5 t2 where id = t1.id)             else null end as o from gstest5 t1 group by grouping sets(v, s) order by o nulls first;
SELECT GROUPING((SELECT x.x FROM x AS x WHERE x = x.x)), (SELECT x.x FROM x AS x WHERE x = x.x) AS x, CASE WHEN GROUPING((SELECT x.x FROM x AS x WHERE x = x.x)) = 0 THEN (SELECT x.x FROM x AS x WHERE x = x.x) ELSE NULL END AS x FROM x AS x GROUP BY GROUPING SETS (x, x) ORDER BY x;
/* test handling of expressions that should match lower target items */ EXPLAIN (costs off) select a < b and b < 3 from (values (1, 2)) t(a, b) group by rollup(a < b and b < 3) having a < b and b < 3;
EXPLAIN (costs off) select not a from (values(true)) t(a) group by rollup(not a) having not not a;
/* test handling of expressions nullable by grouping sets */ EXPLAIN (costs off) select distinct on (a, b) a, b from (values (1, 1), (2, 2)) as t (a, b) where a = b group by grouping sets((a, b), (a)) order by a, b;
SELECT DISTINCT ON (x, x) x, x FROM (VALUES (1, 1), (2, 2)) AS x WHERE x = x GROUP BY GROUPING SETS ((x, x), (x)) ORDER BY x NULLS LAST, x NULLS LAST;
EXPLAIN (costs off) select distinct on (a, b+1) a, b+1 from (values (1, 0), (2, 1)) as t (a, b) where a = b+1 group by grouping sets((a, b+1), (a)) order by a, b+1;
EXPLAIN (costs off) select a, b from (values (1, 1), (2, 2)) as t (a, b) where a = b group by grouping sets((a, b), (a)) order by a, b nulls first;
SELECT x, x FROM (VALUES (1, 1), (2, 2)) AS x WHERE x = x GROUP BY GROUPING SETS ((x, x), (x)) ORDER BY x NULLS LAST, x;
EXPLAIN (costs off) select 1 as one group by rollup(one) order by one nulls first;
SELECT 1 AS x GROUP BY ROLLUP (x) ORDER BY x;
EXPLAIN (costs off) select a, b, row_number() over (order by a, b nulls first) from (values (1, 1), (2, 2)) as t (a, b) where a = b group by grouping sets((a, b), (a));
SELECT x, x, ROW_NUMBER() OVER (ORDER BY x NULLS LAST, x) FROM (VALUES (1, 1), (2, 2)) AS x WHERE x = x GROUP BY GROUPING SETS ((x, x), (x));
SET x = 'asd' /* Check output style of CamelCase enum options */;
SET x = 40 /* SET to some nondefault value */;
SET x = 'ISO, YMD';
SHOW vacuum_cost_delay;
SHOW datestyle;
SELECT CAST('2006-08-13 12:34:56' AS TIMESTAMPTZ);
SET LOCAL x = 50 /* SET LOCAL has no effect outside of a transaction */;
SHOW vacuum_cost_delay;
SET LOCAL x = 'SQL';
SHOW datestyle;
SELECT CAST('2006-08-13 12:34:56' AS TIMESTAMPTZ);
/* SET LOCAL within a transaction that commits */ BEGIN;
SET LOCAL x = 50;
SHOW vacuum_cost_delay;
SET LOCAL x = 'SQL';
SHOW datestyle;
SELECT CAST('2006-08-13 12:34:56' AS TIMESTAMPTZ);
COMMIT;
SHOW vacuum_cost_delay;
SHOW datestyle;
SELECT CAST('2006-08-13 12:34:56' AS TIMESTAMPTZ);
/* SET should be reverted after ROLLBACK */ BEGIN;
SET x = 60;
SHOW vacuum_cost_delay;
SET x = 'German';
SHOW datestyle;
SELECT CAST('2006-08-13 12:34:56' AS TIMESTAMPTZ);
ROLLBACK;
SHOW vacuum_cost_delay;
SHOW datestyle;
SELECT CAST('2006-08-13 12:34:56' AS TIMESTAMPTZ);
/* Some tests with subtransactions */ BEGIN;
SET x = 70;
SET x = 'MDY';
SHOW datestyle;
SELECT CAST('2006-08-13 12:34:56' AS TIMESTAMPTZ);
x AS x;
SET x = 80.1;
SHOW vacuum_cost_delay;
SET x = 'German, DMY';
SHOW datestyle;
SELECT CAST('2006-08-13 12:34:56' AS TIMESTAMPTZ);
ROLLBACK TO x;
SHOW datestyle;
SELECT CAST('2006-08-13 12:34:56' AS TIMESTAMPTZ);
x AS x;
SET x = '900us';
SET x = 'SQL, YMD';
SHOW datestyle;
SELECT CAST('2006-08-13 12:34:56' AS TIMESTAMPTZ);
x AS x;
SET x = 100;
SHOW vacuum_cost_delay;
SET x = 'Postgres, MDY';
SHOW datestyle;
SELECT CAST('2006-08-13 12:34:56' AS TIMESTAMPTZ);
ROLLBACK TO x;
SHOW vacuum_cost_delay;
SHOW datestyle;
SELECT CAST('2006-08-13 12:34:56' AS TIMESTAMPTZ);
ROLLBACK TO x;
SHOW vacuum_cost_delay;
SHOW datestyle;
SELECT CAST('2006-08-13 12:34:56' AS TIMESTAMPTZ);
ROLLBACK;
SHOW vacuum_cost_delay;
SHOW datestyle;
SELECT CAST('2006-08-13 12:34:56' AS TIMESTAMPTZ);
/* SET LOCAL with Savepoints */ BEGIN;
SHOW vacuum_cost_delay;
SHOW datestyle;
SELECT CAST('2006-08-13 12:34:56' AS TIMESTAMPTZ);
x AS x;
SET LOCAL x = 30;
SHOW vacuum_cost_delay;
SET LOCAL x = 'Postgres, MDY';
SHOW datestyle;
SELECT CAST('2006-08-13 12:34:56' AS TIMESTAMPTZ);
ROLLBACK TO x;
SHOW vacuum_cost_delay;
SHOW datestyle;
SELECT CAST('2006-08-13 12:34:56' AS TIMESTAMPTZ);
ROLLBACK;
SHOW vacuum_cost_delay;
SHOW datestyle;
SELECT CAST('2006-08-13 12:34:56' AS TIMESTAMPTZ);
/* SET LOCAL persists through RELEASE (which was not true in 8.0-8.2) */ BEGIN;
SHOW vacuum_cost_delay;
SHOW datestyle;
SELECT CAST('2006-08-13 12:34:56' AS TIMESTAMPTZ);
x AS x;
SET LOCAL x = 30;
SHOW vacuum_cost_delay;
SET LOCAL x = 'Postgres, MDY';
SHOW datestyle;
SELECT CAST('2006-08-13 12:34:56' AS TIMESTAMPTZ);
SHOW vacuum_cost_delay;
SHOW datestyle;
SELECT CAST('2006-08-13 12:34:56' AS TIMESTAMPTZ);
ROLLBACK;
SHOW vacuum_cost_delay;
SHOW datestyle;
SELECT CAST('2006-08-13 12:34:56' AS TIMESTAMPTZ);
/* SET followed by SET LOCAL */ BEGIN;
SET x = 40;
SET LOCAL x = 50;
SHOW vacuum_cost_delay;
SET x = 'ISO, DMY';
SET LOCAL x = 'Postgres, MDY';
SHOW datestyle;
SELECT CAST('2006-08-13 12:34:56' AS TIMESTAMPTZ);
COMMIT;
SHOW vacuum_cost_delay;
SHOW datestyle;
SELECT CAST('2006-08-13 12:34:56' AS TIMESTAMPTZ);
/* Test RESET.  We use datestyle because the reset value is forced by */ /* pg_regress, so it doesn't depend on the installation's configuration. */ SET datestyle = iso, ymd;
SHOW datestyle;
SELECT CAST('2006-08-13 12:34:56' AS TIMESTAMPTZ);
RESET datestyle;
SHOW datestyle;
SELECT CAST('2006-08-13 12:34:56' AS TIMESTAMPTZ);
SET x = 'NaN' /* Test some simple error cases */;
SET x = '10s';
SET x = 42;
/* Test "custom" GUCs created on the fly (which aren't really an */ /* intended feature, but many people use them). */ SHOW custom.my_guc;
SET x.x = 42 /* error, not known yet */;
SHOW custom.my_guc;
RESET custom.my_guc;
/* this makes it go to empty, not become unknown again */ SHOW custom.my_guc;
SET x.x.x.x = 'foo';
SHOW custom.my.qualified.guc;
SET x."x" = 42;
/* disallowed because -c cannot set this name */ SHOW custom."bad-guc";
SET x."x" = 'foo';
/* could be allowed, but we choose not to */ SHOW special."weird name";
SET x.x = TRUE /* Check what happens when you try to set a "custom" GUC within the */ /* namespace of an extension. */;
/* allowed if plpgsql is not loaded yet */ LOAD 'plpgsql';
SET x.x = TRUE /* this will throw a warning and delete the variable */;
/* now, it's an error */ SHOW plpgsql.extra_foo_warnings;
/* Test DISCARD TEMP */ CREATE TEMPORARY TABLE x (x TEXT) ON COMMIT DELETE ROWS;
SELECT x FROM x WHERE x = 'reset_test';
x AS x;
SELECT x FROM x WHERE x = 'reset_test';
/* Test DISCARD ALL */ /* do changes */ DECLARE foo CURSOR WITH HOLD FOR SELECT 1;
PREPARE foo AS SELECT 1;
x AS x;
SET x = 13;
CREATE TEMPORARY TABLE x (x TEXT) ON COMMIT DELETE ROWS;
CREATE ROLE regress_guc_user;
SET SESSION AUTHORIZATION regress_guc_user;
/* look changes */ SELECT PG_LISTENING_CHANNELS();
SELECT x FROM x;
SELECT x FROM x;
SHOW vacuum_cost_delay;
SELECT x FROM x WHERE x = 'tmp_foo';
SELECT CURRENT_USER() = 'regress_guc_user';
x AS x /* discard everything */;
/* look again */ SELECT PG_LISTENING_CHANNELS();
SELECT x FROM x;
SELECT x FROM x;
SHOW vacuum_cost_delay;
SELECT x FROM x WHERE x = 'tmp_foo';
SELECT CURRENT_USER() = 'regress_guc_user';
DROP ROLE regress_guc_user;
/* search_path should react to changes in pg_namespace */ set search_path = foo, public, not_there_initially;
SELECT CURRENT_SCHEMAS(FALSE);
CREATE SCHEMA x.x;
SELECT CURRENT_SCHEMAS(FALSE);
DROP SCHEMA x.x;
SELECT CURRENT_SCHEMAS(FALSE);
RESET search_path;
SET x = '3MB' /* Tests for function-local GUC settings */;
CREATE FUNCTION x(x) RETURNS TEXT LANGUAGE sql SET x = '1MB' AS $$ select current_setting($1) $$;
SELECT REPORT_GUC('work_mem'), CURRENT_SETTING('work_mem');
alter function report_guc(text) set work_mem = '2MB';
SELECT REPORT_GUC('work_mem'), CURRENT_SETTING('work_mem');
alter function report_guc(text) reset all;
SELECT REPORT_GUC('work_mem'), CURRENT_SETTING('work_mem');
SELECT MYFUNC(0), CURRENT_SETTING('work_mem');
alter function myfunc(int) reset all;
SELECT MYFUNC(0), CURRENT_SETTING('work_mem');
SET x = '3MB';
SELECT MYFUNC(0), CURRENT_SETTING('work_mem');
SET x = '3MB';
SELECT MYFUNC(0);
SELECT CURRENT_SETTING('work_mem');
SELECT MYFUNC(1), CURRENT_SETTING('work_mem');
/* check current_setting()'s behavior with invalid setting name */ SELECT CURRENT_SETTING('nosuch.setting');
/* FAIL */ SELECT CURRENT_SETTING('nosuch.setting', FALSE);
/* FAIL */ SELECT CURRENT_SETTING('nosuch.setting', TRUE) IS NULL;
SET x.x = 'nada' /* after this, all three cases should yield 'nada' */;
SELECT CURRENT_SETTING('nosuch.setting');
SELECT CURRENT_SETTING('nosuch.setting', FALSE);
SELECT CURRENT_SETTING('nosuch.setting', TRUE);
SET x = off;
CREATE FUNCTION x() RETURNS INT LANGUAGE sql SET x = no_such_config AS $$ select 1 $$;
SELECT FUNC_WITH_BAD_SET();
RESET check_function_bodies;
SET x = f;
SET x = t /* Should not allow to set it to true. */;
SET x = on /* Test that disabling track_activities disables query ID reporting in */ /* pg_stat_activity. */;
SET x = on;
SELECT NOT x IS NULL AS x FROM x WHERE x = PG_BACKEND_PID();
SET x = off;
SELECT NOT x IS NULL AS x FROM x WHERE x = PG_BACKEND_PID();
RESET track_activities;
RESET compute_query_id;
/* Test GUC categories and flag patterns */ SELECT PG_SETTINGS_GET_FLAGS(NULL);
SELECT PG_SETTINGS_GET_FLAGS('does_not_exist');
CREATE TABLE x AS SELECT x, x, 'EXPLAIN' = ANY(x) AS x, 'NO_RESET' = ANY(x) AS x, 'NO_RESET_ALL' = ANY(x) AS x, 'NOT_IN_SAMPLE' = ANY(x) AS x, 'RUNTIME_COMPUTED' = ANY(x) AS x FROM x AS x, x AS x;
/* Developer GUCs should be flagged with GUC_NOT_IN_SAMPLE: */ SELECT x FROM x WHERE x = 'Developer Options' AND NOT x ORDER BY 1 NULLS LAST;
/* Most query-tuning GUCs are flagged as valid for EXPLAIN. */ /* default_statistics_target is an exception. */ SELECT x FROM x WHERE REGEXP_LIKE(x, '^Query Tuning') AND NOT x ORDER BY 1 NULLS LAST;
/* Runtime-computed GUCs should be part of the preset category. */ SELECT x FROM x WHERE NOT x = 'Preset Options' AND x ORDER BY 1 NULLS LAST;
/* Preset GUCs are flagged as NOT_IN_SAMPLE. */ SELECT x FROM x WHERE x = 'Preset Options' AND NOT x ORDER BY 1 NULLS LAST;
/* NO_RESET implies NO_RESET_ALL. */ SELECT x FROM x WHERE x AND NOT x ORDER BY 1 NULLS LAST;
DROP TABLE x;
/* Test hash functions */ /* When the salt is 0, the extended hash function should produce a result */ /* whose low 32 bits match the standard hash function.  When the salt is */ /* not 0, we should get a different result. */ SELECT x AS x, CAST(HASHINT2(x) AS BIT(32)) AS x, CAST(HASHINT2EXTENDED(x, 0) AS BIT(32)) AS x, CAST(HASHINT2EXTENDED(x, 1) AS BIT(32)) AS x FROM (VALUES (CAST(0 AS SMALLINT)), (CAST(1 AS SMALLINT)), (CAST(17 AS SMALLINT)), (CAST(42 AS SMALLINT))) AS x WHERE CAST(HASHINT2(x) AS BIT(32)) <> CAST(HASHINT2EXTENDED(x, 0) AS BIT(32)) OR CAST(HASHINT2(x) AS BIT(32)) = CAST(HASHINT2EXTENDED(x, 1) AS BIT(32));
SELECT x AS x, CAST(HASHINT4(x) AS BIT(32)) AS x, CAST(HASHINT4EXTENDED(x, 0) AS BIT(32)) AS x, CAST(HASHINT4EXTENDED(x, 1) AS BIT(32)) AS x FROM (VALUES (0), (1), (17), (42), (550273), (207112489)) AS x WHERE CAST(HASHINT4(x) AS BIT(32)) <> CAST(HASHINT4EXTENDED(x, 0) AS BIT(32)) OR CAST(HASHINT4(x) AS BIT(32)) = CAST(HASHINT4EXTENDED(x, 1) AS BIT(32));
SELECT x AS x, CAST(HASHINT8(x) AS BIT(32)) AS x, CAST(HASHINT8EXTENDED(x, 0) AS BIT(32)) AS x, CAST(HASHINT8EXTENDED(x, 1) AS BIT(32)) AS x FROM (VALUES (0), (1), (17), (42), (550273), (207112489)) AS x WHERE CAST(HASHINT8(x) AS BIT(32)) <> CAST(HASHINT8EXTENDED(x, 0) AS BIT(32)) OR CAST(HASHINT8(x) AS BIT(32)) = CAST(HASHINT8EXTENDED(x, 1) AS BIT(32));
SELECT x AS x, CAST(HASHFLOAT4(x) AS BIT(32)) AS x, CAST(HASHFLOAT4EXTENDED(x, 0) AS BIT(32)) AS x, CAST(HASHFLOAT4EXTENDED(x, 1) AS BIT(32)) AS x FROM (VALUES (0), (1), (17), (42), (550273), (207112489)) AS x WHERE CAST(HASHFLOAT4(x) AS BIT(32)) <> CAST(HASHFLOAT4EXTENDED(x, 0) AS BIT(32)) OR CAST(HASHFLOAT4(x) AS BIT(32)) = CAST(HASHFLOAT4EXTENDED(x, 1) AS BIT(32));
SELECT x AS x, CAST(HASHFLOAT8(x) AS BIT(32)) AS x, CAST(HASHFLOAT8EXTENDED(x, 0) AS BIT(32)) AS x, CAST(HASHFLOAT8EXTENDED(x, 1) AS BIT(32)) AS x FROM (VALUES (0), (1), (17), (42), (550273), (207112489)) AS x WHERE CAST(HASHFLOAT8(x) AS BIT(32)) <> CAST(HASHFLOAT8EXTENDED(x, 0) AS BIT(32)) OR CAST(HASHFLOAT8(x) AS BIT(32)) = CAST(HASHFLOAT8EXTENDED(x, 1) AS BIT(32));
SELECT x AS x, CAST(HASHOID(x) AS BIT(32)) AS x, CAST(HASHOIDEXTENDED(x, 0) AS BIT(32)) AS x, CAST(HASHOIDEXTENDED(x, 1) AS BIT(32)) AS x FROM (VALUES (0), (1), (17), (42), (550273), (207112489)) AS x WHERE CAST(HASHOID(x) AS BIT(32)) <> CAST(HASHOIDEXTENDED(x, 0) AS BIT(32)) OR CAST(HASHOID(x) AS BIT(32)) = CAST(HASHOIDEXTENDED(x, 1) AS BIT(32));
SELECT x AS x, CAST(HASHCHAR(x) AS BIT(32)) AS x, CAST(HASHCHAREXTENDED(x, 0) AS BIT(32)) AS x, CAST(HASHCHAREXTENDED(x, 1) AS BIT(32)) AS x FROM (VALUES (CAST(NULL AS CHAR)), ('1'), ('x'), ('X'), ('p'), ('N')) AS x WHERE CAST(HASHCHAR(x) AS BIT(32)) <> CAST(HASHCHAREXTENDED(x, 0) AS BIT(32)) OR CAST(HASHCHAR(x) AS BIT(32)) = CAST(HASHCHAREXTENDED(x, 1) AS BIT(32));
SELECT x AS x, CAST(HASHNAME(x) AS BIT(32)) AS x, CAST(HASHNAMEEXTENDED(x, 0) AS BIT(32)) AS x, CAST(HASHNAMEEXTENDED(x, 1) AS BIT(32)) AS x FROM (VALUES (NULL), ('PostgreSQL'), ('eIpUEtqmY89'), ('AXKEJBTK'), ('muop28x03'), ('yi3nm0d73')) AS x WHERE CAST(HASHNAME(x) AS BIT(32)) <> CAST(HASHNAMEEXTENDED(x, 0) AS BIT(32)) OR CAST(HASHNAME(x) AS BIT(32)) = CAST(HASHNAMEEXTENDED(x, 1) AS BIT(32));
SELECT x AS x, CAST(HASHTEXT(x) AS BIT(32)) AS x, CAST(HASHTEXTEXTENDED(x, 0) AS BIT(32)) AS x, CAST(HASHTEXTEXTENDED(x, 1) AS BIT(32)) AS x FROM (VALUES (NULL), ('PostgreSQL'), ('eIpUEtqmY89'), ('AXKEJBTK'), ('muop28x03'), ('yi3nm0d73')) AS x WHERE CAST(HASHTEXT(x) AS BIT(32)) <> CAST(HASHTEXTEXTENDED(x, 0) AS BIT(32)) OR CAST(HASHTEXT(x) AS BIT(32)) = CAST(HASHTEXTEXTENDED(x, 1) AS BIT(32));
SELECT x AS x, CAST(HASHOIDVECTOR(x) AS BIT(32)) AS x, CAST(HASHOIDVECTOREXTENDED(x, 0) AS BIT(32)) AS x, CAST(HASHOIDVECTOREXTENDED(x, 1) AS BIT(32)) AS x FROM (VALUES (CAST(NULL AS oidvector)), ('0 1 2 3 4'), ('17 18 19 20'), ('42 43 42 45'), ('550273 550273 570274'), ('207112489 207112499 21512 2155 372325 1363252')) AS x WHERE CAST(HASHOIDVECTOR(x) AS BIT(32)) <> CAST(HASHOIDVECTOREXTENDED(x, 0) AS BIT(32)) OR CAST(HASHOIDVECTOR(x) AS BIT(32)) = CAST(HASHOIDVECTOREXTENDED(x, 1) AS BIT(32));
SELECT x AS x, CAST(HASH_ACLITEM(x) AS BIT(32)) AS x, CAST(HASH_ACLITEM_EXTENDED(x, 0) AS BIT(32)) AS x, CAST(HASH_ACLITEM_EXTENDED(x, 1) AS BIT(32)) AS x FROM (SELECT DISTINCT (x[0]) FROM x LIMIT 10) AS x WHERE CAST(HASH_ACLITEM(x) AS BIT(32)) <> CAST(HASH_ACLITEM_EXTENDED(x, 0) AS BIT(32)) OR CAST(HASH_ACLITEM(x) AS BIT(32)) = CAST(HASH_ACLITEM_EXTENDED(x, 1) AS BIT(32));
SELECT x AS x, CAST(HASHMACADDR(x) AS BIT(32)) AS x, CAST(HASHMACADDREXTENDED(x, 0) AS BIT(32)) AS x, CAST(HASHMACADDREXTENDED(x, 1) AS BIT(32)) AS x FROM (VALUES (CAST(NULL AS macaddr)), ('08:00:2b:01:02:04'), ('08:00:2b:01:02:04'), ('e2:7f:51:3e:70:49'), ('d6:a9:4a:78:1c:d5'), ('ea:29:b1:5e:1f:a5')) AS x WHERE CAST(HASHMACADDR(x) AS BIT(32)) <> CAST(HASHMACADDREXTENDED(x, 0) AS BIT(32)) OR CAST(HASHMACADDR(x) AS BIT(32)) = CAST(HASHMACADDREXTENDED(x, 1) AS BIT(32));
SELECT x AS x, CAST(HASHINET(x) AS BIT(32)) AS x, CAST(HASHINETEXTENDED(x, 0) AS BIT(32)) AS x, CAST(HASHINETEXTENDED(x, 1) AS BIT(32)) AS x FROM (VALUES (CAST(NULL AS INET)), ('192.168.100.128/25'), ('192.168.100.0/8'), ('172.168.10.126/16'), ('172.18.103.126/24'), ('192.188.13.16/32')) AS x WHERE CAST(HASHINET(x) AS BIT(32)) <> CAST(HASHINETEXTENDED(x, 0) AS BIT(32)) OR CAST(HASHINET(x) AS BIT(32)) = CAST(HASHINETEXTENDED(x, 1) AS BIT(32));
SELECT x AS x, CAST(HASH_NUMERIC(x) AS BIT(32)) AS x, CAST(HASH_NUMERIC_EXTENDED(x, 0) AS BIT(32)) AS x, CAST(HASH_NUMERIC_EXTENDED(x, 1) AS BIT(32)) AS x FROM (VALUES (0), (1.149484958), (17.149484958), (42.149484958), (149484958.550273), (2071124898672)) AS x WHERE CAST(HASH_NUMERIC(x) AS BIT(32)) <> CAST(HASH_NUMERIC_EXTENDED(x, 0) AS BIT(32)) OR CAST(HASH_NUMERIC(x) AS BIT(32)) = CAST(HASH_NUMERIC_EXTENDED(x, 1) AS BIT(32));
SELECT x AS x, CAST(HASHMACADDR8(x) AS BIT(32)) AS x, CAST(HASHMACADDR8EXTENDED(x, 0) AS BIT(32)) AS x, CAST(HASHMACADDR8EXTENDED(x, 1) AS BIT(32)) AS x FROM (VALUES (CAST(NULL AS macaddr8)), ('08:00:2b:01:02:04:36:49'), ('08:00:2b:01:02:04:f0:e8'), ('e2:7f:51:3e:70:49:16:29'), ('d6:a9:4a:78:1c:d5:47:32'), ('ea:29:b1:5e:1f:a5')) AS x WHERE CAST(HASHMACADDR8(x) AS BIT(32)) <> CAST(HASHMACADDR8EXTENDED(x, 0) AS BIT(32)) OR CAST(HASHMACADDR8(x) AS BIT(32)) = CAST(HASHMACADDR8EXTENDED(x, 1) AS BIT(32));
SELECT x AS x, CAST(HASH_ARRAY(x) AS BIT(32)) AS x, CAST(HASH_ARRAY_EXTENDED(x, 0) AS BIT(32)) AS x, CAST(HASH_ARRAY_EXTENDED(x, 1) AS BIT(32)) AS x FROM (VALUES (CAST('{0}' AS ARRAY<INT>)), ('{0,1,2,3,4}'), ('{17,18,19,20}'), ('{42,34,65,98}'), ('{550273,590027, 870273}'), ('{207112489, 807112489}')) AS x WHERE CAST(HASH_ARRAY(x) AS BIT(32)) <> CAST(HASH_ARRAY_EXTENDED(x, 0) AS BIT(32)) OR CAST(HASH_ARRAY(x) AS BIT(32)) = CAST(HASH_ARRAY_EXTENDED(x, 1) AS BIT(32));
/* array hashing with non-hashable element type */ SELECT x AS x, CAST(HASH_ARRAY(x) AS BIT(32)) AS x FROM (VALUES (CAST('{101}' AS ARRAY<varbit>))) AS x;
SELECT x AS x, CAST(HASH_ARRAY_EXTENDED(x, 0) AS BIT(32)) AS x FROM (VALUES (CAST('{101}' AS ARRAY<varbit>))) AS x;
SELECT x AS x, CAST(HASHBPCHAR(x) AS BIT(32)) AS x, CAST(HASHBPCHAREXTENDED(x, 0) AS BIT(32)) AS x, CAST(HASHBPCHAREXTENDED(x, 1) AS BIT(32)) AS x FROM (VALUES (NULL), ('PostgreSQL'), ('eIpUEtqmY89'), ('AXKEJBTK'), ('muop28x03'), ('yi3nm0d73')) AS x WHERE CAST(HASHBPCHAR(x) AS BIT(32)) <> CAST(HASHBPCHAREXTENDED(x, 0) AS BIT(32)) OR CAST(HASHBPCHAR(x) AS BIT(32)) = CAST(HASHBPCHAREXTENDED(x, 1) AS BIT(32));
SELECT x AS x, CAST(TIME_HASH(x) AS BIT(32)) AS x, CAST(TIME_HASH_EXTENDED(x, 0) AS BIT(32)) AS x, CAST(TIME_HASH_EXTENDED(x, 1) AS BIT(32)) AS x FROM (VALUES (CAST(NULL AS TIME)), ('11:09:59'), ('1:09:59'), ('11:59:59'), ('7:9:59'), ('5:15:59')) AS x WHERE CAST(TIME_HASH(x) AS BIT(32)) <> CAST(TIME_HASH_EXTENDED(x, 0) AS BIT(32)) OR CAST(TIME_HASH(x) AS BIT(32)) = CAST(TIME_HASH_EXTENDED(x, 1) AS BIT(32));
SELECT x AS x, CAST(TIMETZ_HASH(x) AS BIT(32)) AS x, CAST(TIMETZ_HASH_EXTENDED(x, 0) AS BIT(32)) AS x, CAST(TIMETZ_HASH_EXTENDED(x, 1) AS BIT(32)) AS x FROM (VALUES (CAST(NULL AS TIMETZ)), ('00:11:52.518762-07'), ('00:11:52.51762-08'), ('00:11:52.62-01'), ('00:11:52.62+01'), ('11:59:59+04')) AS x WHERE CAST(TIMETZ_HASH(x) AS BIT(32)) <> CAST(TIMETZ_HASH_EXTENDED(x, 0) AS BIT(32)) OR CAST(TIMETZ_HASH(x) AS BIT(32)) = CAST(TIMETZ_HASH_EXTENDED(x, 1) AS BIT(32));
SELECT x AS x, CAST(INTERVAL_HASH(x) AS BIT(32)) AS x, CAST(INTERVAL_HASH_EXTENDED(x, 0) AS BIT(32)) AS x, CAST(INTERVAL_HASH_EXTENDED(x, 1) AS BIT(32)) AS x FROM (VALUES (CAST(NULL AS INTERVAL)), ('5 month 7 day 46 minutes'), ('1 year 7 day 46 minutes'), ('1 year 7 month 20 day 46 minutes'), ('5 month'), ('17 year 11 month 7 day 9 hours 46 minutes 5 seconds')) AS x WHERE CAST(INTERVAL_HASH(x) AS BIT(32)) <> CAST(INTERVAL_HASH_EXTENDED(x, 0) AS BIT(32)) OR CAST(INTERVAL_HASH(x) AS BIT(32)) = CAST(INTERVAL_HASH_EXTENDED(x, 1) AS BIT(32));
SELECT x AS x, CAST(TIMESTAMP_HASH(x) AS BIT(32)) AS x, CAST(TIMESTAMP_HASH_EXTENDED(x, 0) AS BIT(32)) AS x, CAST(TIMESTAMP_HASH_EXTENDED(x, 1) AS BIT(32)) AS x FROM (VALUES (CAST(NULL AS TIMESTAMP)), ('2017-08-22 00:09:59.518762'), ('2015-08-20 00:11:52.51762-08'), ('2017-05-22 00:11:52.62-01'), ('2013-08-22 00:11:52.62+01'), ('2013-08-22 11:59:59+04')) AS x WHERE CAST(TIMESTAMP_HASH(x) AS BIT(32)) <> CAST(TIMESTAMP_HASH_EXTENDED(x, 0) AS BIT(32)) OR CAST(TIMESTAMP_HASH(x) AS BIT(32)) = CAST(TIMESTAMP_HASH_EXTENDED(x, 1) AS BIT(32));
SELECT x AS x, CAST(UUID_HASH(x) AS BIT(32)) AS x, CAST(UUID_HASH_EXTENDED(x, 0) AS BIT(32)) AS x, CAST(UUID_HASH_EXTENDED(x, 1) AS BIT(32)) AS x FROM (VALUES (CAST(NULL AS UUID)), ('a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11'), ('5a9ba4ac-8d6f-11e7-bb31-be2e44b06b34'), ('99c6705c-d939-461c-a3c9-1690ad64ed7b'), ('7deed3ca-8d6f-11e7-bb31-be2e44b06b34'), ('9ad46d4f-6f2a-4edd-aadb-745993928e1e')) AS x WHERE CAST(UUID_HASH(x) AS BIT(32)) <> CAST(UUID_HASH_EXTENDED(x, 0) AS BIT(32)) OR CAST(UUID_HASH(x) AS BIT(32)) = CAST(UUID_HASH_EXTENDED(x, 1) AS BIT(32));
SELECT x AS x, CAST(PG_LSN_HASH(x) AS BIT(32)) AS x, CAST(PG_LSN_HASH_EXTENDED(x, 0) AS BIT(32)) AS x, CAST(PG_LSN_HASH_EXTENDED(x, 1) AS BIT(32)) AS x FROM (VALUES (CAST(NULL AS pg_lsn)), ('16/B374D84'), ('30/B374D84'), ('255/B374D84'), ('25/B379D90'), ('900/F37FD90')) AS x WHERE CAST(PG_LSN_HASH(x) AS BIT(32)) <> CAST(PG_LSN_HASH_EXTENDED(x, 0) AS BIT(32)) OR CAST(PG_LSN_HASH(x) AS BIT(32)) = CAST(PG_LSN_HASH_EXTENDED(x, 1) AS BIT(32));
CREATE TYPE mood AS ENUM ('sad', 'ok', 'happy');
SELECT x AS x, CAST(HASHENUM(x) AS BIT(32)) AS x, CAST(HASHENUMEXTENDED(x, 0) AS BIT(32)) AS x, CAST(HASHENUMEXTENDED(x, 1) AS BIT(32)) AS x FROM (VALUES (CAST('sad' AS mood)), ('ok'), ('happy')) AS x WHERE CAST(HASHENUM(x) AS BIT(32)) <> CAST(HASHENUMEXTENDED(x, 0) AS BIT(32)) OR CAST(HASHENUM(x) AS BIT(32)) = CAST(HASHENUMEXTENDED(x, 1) AS BIT(32));
DROP TYPE mood;
SELECT x AS x, CAST(JSONB_HASH(x) AS BIT(32)) AS x, CAST(JSONB_HASH_EXTENDED(x, 0) AS BIT(32)) AS x, CAST(JSONB_HASH_EXTENDED(x, 1) AS BIT(32)) AS x FROM (VALUES (CAST(NULL AS JSONB)), ('{"a": "aaa bbb ddd ccc", "b": ["eee fff ggg"], "c": {"d": "hhh iii"}}'), ('{"foo": [true, "bar"], "tags": {"e": 1, "f": null}}'), ('{"g": {"h": "value"}}')) AS x WHERE CAST(JSONB_HASH(x) AS BIT(32)) <> CAST(JSONB_HASH_EXTENDED(x, 0) AS BIT(32)) OR CAST(JSONB_HASH(x) AS BIT(32)) = CAST(JSONB_HASH_EXTENDED(x, 1) AS BIT(32));
SELECT x AS x, CAST(HASH_RANGE(x) AS BIT(32)) AS x, CAST(HASH_RANGE_EXTENDED(x, 0) AS BIT(32)) AS x, CAST(HASH_RANGE_EXTENDED(x, 1) AS BIT(32)) AS x FROM (VALUES (INT4RANGE(10, 20)), (INT4RANGE(23, 43)), (INT4RANGE(5675, 550273)), (INT4RANGE(550274, 1550274)), (INT4RANGE(1550275, 208112489))) AS x WHERE CAST(HASH_RANGE(x) AS BIT(32)) <> CAST(HASH_RANGE_EXTENDED(x, 0) AS BIT(32)) OR CAST(HASH_RANGE(x) AS BIT(32)) = CAST(HASH_RANGE_EXTENDED(x, 1) AS BIT(32));
SELECT x AS x, CAST(HASH_MULTIRANGE(x) AS BIT(32)) AS x, CAST(HASH_MULTIRANGE_EXTENDED(x, 0) AS BIT(32)) AS x, CAST(HASH_MULTIRANGE_EXTENDED(x, 1) AS BIT(32)) AS x FROM (VALUES (CAST('{[10,20)}' AS INT4MULTIRANGE)), (CAST('{[23, 43]}' AS INT4MULTIRANGE)), (CAST('{[5675, 550273)}' AS INT4MULTIRANGE)), (CAST('{[550274, 1550274)}' AS INT4MULTIRANGE)), (CAST('{[1550275, 208112489)}' AS INT4MULTIRANGE))) AS x WHERE CAST(HASH_MULTIRANGE(x) AS BIT(32)) <> CAST(HASH_MULTIRANGE_EXTENDED(x, 0) AS BIT(32)) OR CAST(HASH_MULTIRANGE(x) AS BIT(32)) = CAST(HASH_MULTIRANGE_EXTENDED(x, 1) AS BIT(32));
CREATE TYPE hash_test_t1 AS (a int, b text);
SELECT x AS x, CAST(HASH_RECORD(x) AS BIT(32)) AS x, CAST(HASH_RECORD_EXTENDED(x, 0) AS BIT(32)) AS x, CAST(HASH_RECORD_EXTENDED(x, 1) AS BIT(32)) AS x FROM (VALUES (CAST(ROW(1, 'aaa') AS hash_test_t1), ROW(2, 'bbb'), ROW(-1, 'ccc'))) AS x WHERE CAST(HASH_RECORD(x) AS BIT(32)) <> CAST(HASH_RECORD_EXTENDED(x, 0) AS BIT(32)) OR CAST(HASH_RECORD(x) AS BIT(32)) = CAST(HASH_RECORD_EXTENDED(x, 1) AS BIT(32));
DROP TYPE hash_test_t1;
/* record hashing with non-hashable field type */ CREATE TYPE hash_test_t2 AS (a varbit, b text);
SELECT x AS x, CAST(HASH_RECORD(x) AS BIT(32)) AS x FROM (VALUES (CAST(ROW(CAST('10' AS varbit), 'aaa') AS hash_test_t2))) AS x;
SELECT x AS x, CAST(HASH_RECORD_EXTENDED(x, 0) AS BIT(32)) AS x FROM (VALUES (CAST(ROW(CAST('11' AS varbit), 'aaa') AS hash_test_t2))) AS x;
DROP TYPE hash_test_t2;
/* Check special cases for specific data types */ SELECT HASHFLOAT4(CAST('0' AS FLOAT)) = HASHFLOAT4(CAST('-0' AS FLOAT)) AS x;
SELECT HASHFLOAT4(CAST('NaN' AS FLOAT)) = HASHFLOAT4(-CAST('NaN' AS FLOAT)) AS x;
SELECT HASHFLOAT8(CAST('0' AS DOUBLE)) = HASHFLOAT8(CAST('-0' AS DOUBLE)) AS x;
SELECT HASHFLOAT8(CAST('NaN' AS DOUBLE)) = HASHFLOAT8(-CAST('NaN' AS DOUBLE)) AS x;
SELECT HASHFLOAT4(CAST('NaN' AS FLOAT)) = HASHFLOAT8(CAST('NaN' AS DOUBLE)) AS x;
CREATE TABLE x (x INT, x NAME);
CREATE TABLE x (x INT, x TEXT);
CREATE TABLE x (x INT, x DOUBLE);
ANALYZE x;
ANALYZE x;
ANALYZE x;
ANALYZE x;
CREATE INDEX x ON x USING hash(x x NULLS LAST);
CREATE INDEX x ON x USING hash(x x NULLS LAST);
CREATE INDEX x ON x USING hash(x x NULLS LAST);
CREATE INDEX x ON x USING hash(x x NULLS LAST) WITH (fillfactor=60);
/* Also try building functional, expressional, and partial indexes on */ /* tables that already contain data. */ CREATE UNIQUE INDEX x ON x(ABS(x) NULLS LAST);
CREATE UNIQUE INDEX x ON x((x + 1) NULLS LAST, x NULLS LAST);
CREATE UNIQUE INDEX x ON x(x NULLS LAST) WHERE x > 1000;
/* hash index */ /* grep 843938989 hash.data */ SELECT * FROM x WHERE x.x = 843938989;
/* hash index */ /* grep 66766766 hash.data */ SELECT * FROM x WHERE x.x = 66766766;
/* hash index */ /* grep 1505703298 hash.data */ SELECT * FROM x WHERE x.x = CAST('1505703298' AS NAME);
/* hash index */ /* grep 7777777 hash.data */ SELECT * FROM x WHERE x.x = CAST('7777777' AS NAME);
/* hash index */ /* grep 1351610853 hash.data */ SELECT * FROM x WHERE x.x = CAST('1351610853' AS TEXT);
/* hash index */ /* grep 111111112222222233333333 hash.data */ SELECT * FROM x WHERE x.x = CAST('111111112222222233333333' AS TEXT);
/* hash index */ /* grep 444705537 hash.data */ SELECT * FROM x WHERE x.x = CAST('444705537' AS DOUBLE);
/* hash index */ /* grep 88888888 hash.data */ SELECT * FROM x WHERE x.x = CAST('88888888' AS DOUBLE);
/* HASH */ UPDATE x SET x = 1 WHERE x.x = 1492;
SELECT x.x AS x, x.x AS x FROM x AS x WHERE x.x = 1;
UPDATE x SET x = 20000 WHERE x.x = 1492795354;
SELECT x.x AS x FROM x AS x WHERE x.x = 1492795354;
UPDATE x SET x = CAST('0123456789abcdef' AS NAME) WHERE x.x = 6543;
SELECT x.x AS x, x.x AS x FROM x AS x WHERE x.x = CAST('0123456789abcdef' AS NAME);
UPDATE x SET x = 20000 WHERE x.x = CAST('76652222' AS NAME);
UPDATE x SET x = CAST('0123456789abcdefghijklmnop' AS TEXT) WHERE x.x = 4002;
SELECT x.x AS x, x.x AS x FROM x AS x WHERE x.x = CAST('0123456789abcdefghijklmnop' AS TEXT);
UPDATE x SET x = 20000 WHERE x.x = CAST('959363399' AS TEXT);
SELECT x.x AS x FROM x AS x WHERE x.x = CAST('959363399' AS TEXT);
UPDATE x SET x = CAST('-1234.1234' AS DOUBLE) WHERE x.x = 8906;
SELECT x.x AS x, x.x AS x FROM x AS x WHERE x.x = CAST('-1234.1234' AS DOUBLE);
UPDATE x SET x = 20000 WHERE x.x = CAST('488912369' AS DOUBLE);
SELECT x.x AS x FROM x AS x WHERE x.x = CAST('488912369' AS DOUBLE);
/* Cause some overflow insert and splits. */ CREATE TABLE x (x INT);
INSERT INTO x SELECT 1 FROM x AS x;
CREATE INDEX x ON x USING HASH(x NULLS LAST);
INSERT INTO x SELECT 1 FROM x AS x;
/* Let's do a backward scan. */ BEGIN;
SET x = OFF;
SET x = OFF;
DECLARE c CURSOR FOR SELECT * from hash_split_heap WHERE keycol = 1;
x AS x;
COMMIT;
/* DELETE, INSERT, VACUUM. */ DELETE FROM x WHERE x = 1;
INSERT INTO x SELECT x / 2 FROM x AS x;
VACUUM hash_split_heap;
ALTER INDEX x SET x = 10 /* Rebuild the index using a different fillfactor */;
REINDEX INDEX hash_split_index;
/* Clean up. */ DROP TABLE x;
/* Testcases for removing overflow pages. */ CREATE TABLE x (x INT);
CREATE INDEX x ON x USING HASH(x NULLS LAST);
/* Insert tuples to both the primary bucket page and overflow pages. */ INSERT INTO x SELECT 1 FROM x AS x;
/* Fill overflow pages by "dead" tuples. */ BEGIN;
INSERT INTO x SELECT 1 FROM x AS x;
ROLLBACK;
x /* Checkpoint will ensure that all hash buffers are cleaned before we try */ /* to remove overflow pages. */;
/* This will squeeze the bucket and remove overflow pages. */ VACUUM hash_cleanup_heap;
TRUNCATE TABLE x;
/* Insert a few tuples so that the primary bucket page doesn't get full and */ /* tuples can be moved to it. */ INSERT INTO x SELECT 1 FROM x AS x;
/* Fill overflow pages by "dead" tuples. */ BEGIN;
INSERT INTO x SELECT 1 FROM x AS x;
ROLLBACK;
/* And insert some tuples again. During squeeze operation, these will be moved */ /* to the primary bucket allowing to test freeing intermediate overflow pages. */ INSERT INTO x SELECT 1 FROM x AS x;
x;
VACUUM hash_cleanup_heap;
TRUNCATE TABLE x;
/* Insert tuples to both the primary bucket page and overflow pages. */ INSERT INTO x SELECT 1 FROM x AS x;
/* Fill overflow pages by "dead" tuples. */ BEGIN;
INSERT INTO x SELECT 1 FROM x AS x;
ROLLBACK;
/* And insert some tuples again. During squeeze operation, these will be moved */ /* to other overflow pages and also allow overflow pages filled by dead tuples */ /* to be freed. Note the main purpose of this test is to test the case where */ /* we don't need to move any tuple from the overflow page being freed. */ INSERT INTO x SELECT 1 FROM x AS x;
x;
VACUUM hash_cleanup_heap;
/* Clean up. */ DROP TABLE x;
/* Index on temp table. */ CREATE TEMPORARY TABLE x (x INT, x INT);
INSERT INTO x VALUES (1, 1);
CREATE INDEX x ON x USING hash(x NULLS LAST);
DROP TABLE x CASCADE;
/* Float4 type. */ CREATE TABLE x (x FLOAT, x INT);
INSERT INTO x VALUES (1.1, 1);
CREATE INDEX x ON x USING hash(x NULLS LAST);
DROP TABLE x CASCADE;
/* Test out-of-range fillfactor values */ CREATE INDEX x ON x USING hash(x x NULLS LAST) WITH (fillfactor=9);
CREATE INDEX x ON x USING hash(x x NULLS LAST) WITH (fillfactor=101);
CREATE TABLE x PARTITION OF x FOR VALUES WITH (MODULUS 4, REMAINDER 0);
/* invalid OID, no such table */ SELECT SATISFIES_HASH_PARTITION(0, 4, 0, NULL);
/* not partitioned */ SELECT SATISFIES_HASH_PARTITION(CAST('tenk1' AS REGCLASS), 4, 0, NULL);
/* partition rather than the parent */ SELECT SATISFIES_HASH_PARTITION(CAST('mchash1' AS REGCLASS), 4, 0, NULL);
/* invalid modulus */ SELECT SATISFIES_HASH_PARTITION(CAST('mchash' AS REGCLASS), 0, 0, NULL);
/* remainder too small */ SELECT SATISFIES_HASH_PARTITION(CAST('mchash' AS REGCLASS), 1, -1, NULL);
/* remainder too large */ SELECT SATISFIES_HASH_PARTITION(CAST('mchash' AS REGCLASS), 1, 1, NULL);
/* modulus is null */ SELECT SATISFIES_HASH_PARTITION(CAST('mchash' AS REGCLASS), NULL, 0, NULL);
/* remainder is null */ SELECT SATISFIES_HASH_PARTITION(CAST('mchash' AS REGCLASS), 4, NULL, NULL);
/* too many arguments */ SELECT SATISFIES_HASH_PARTITION(CAST('mchash' AS REGCLASS), 4, 0, CAST(NULL AS INT), CAST(NULL AS TEXT), CAST(NULL AS JSON));
/* too few arguments */ SELECT SATISFIES_HASH_PARTITION(CAST('mchash' AS REGCLASS), 3, 1, CAST(NULL AS INT));
/* wrong argument type */ SELECT SATISFIES_HASH_PARTITION(CAST('mchash' AS REGCLASS), 2, 1, CAST(NULL AS INT), CAST(NULL AS INT));
/* ok, should be false */ SELECT SATISFIES_HASH_PARTITION(CAST('mchash' AS REGCLASS), 4, 0, 0, CAST('' AS TEXT));
/* ok, should be true */ SELECT SATISFIES_HASH_PARTITION(CAST('mchash' AS REGCLASS), 4, 0, 2, CAST('' AS TEXT));
/* check satisfies_hash_partition passes correct collation */ CREATE TABLE x (x TEXT) WITH (PARTITIONED_BY=HASH(x));
CREATE TABLE x PARTITION OF x FOR VALUES WITH (MODULUS 2, REMAINDER 0);
CREATE TABLE x PARTITION OF x FOR VALUES WITH (MODULUS 2, REMAINDER 1);
/* The result here should always be true, because 'xxx' must belong to */ /* one of the two defined partitions */ SELECT SATISFIES_HASH_PARTITION(CAST('text_hashp' AS REGCLASS), 2, 0, CAST('xxx' AS TEXT)) OR SATISFIES_HASH_PARTITION(CAST('text_hashp' AS REGCLASS), 2, 1, CAST('xxx' AS TEXT)) AS x;
/* cleanup */ DROP TABLE x;
DROP TABLE x;
DROP TABLE x;
/* HOROLOGY */ SHOW TimeZone;
/* Many of these tests depend on the prevailing settings */ SHOW DateStyle;
/* Test various input formats */ SELECT CAST('20011227 040506+08' AS TIMESTAMPTZ);
SELECT CAST('20011227 040506-08' AS TIMESTAMPTZ);
SELECT CAST('20011227 040506.789+08' AS TIMESTAMPTZ);
SELECT CAST('20011227 040506.789-08' AS TIMESTAMPTZ);
SELECT CAST('20011227T040506+08' AS TIMESTAMPTZ);
SELECT CAST('20011227T040506-08' AS TIMESTAMPTZ);
SELECT CAST('20011227T040506.789+08' AS TIMESTAMPTZ);
SELECT CAST('20011227T040506.789-08' AS TIMESTAMPTZ);
SELECT CAST('2001-12-27 04:05:06.789-08' AS TIMESTAMPTZ);
SELECT CAST('2001.12.27 04:05:06.789-08' AS TIMESTAMPTZ);
SELECT CAST('2001/12/27 04:05:06.789-08' AS TIMESTAMPTZ);
SELECT CAST('12/27/2001 04:05:06.789-08' AS TIMESTAMPTZ);
SELECT CAST('2001-12-27 04:05:06.789 MET DST' AS TIMESTAMPTZ);
SELECT CAST('2001-12-27 allballs' AS TIMESTAMPTZ);
/* should fail in mdy mode: */ SELECT CAST('27/12/2001 04:05:06.789-08' AS TIMESTAMPTZ);
SET x = dmy;
SELECT CAST('27/12/2001 04:05:06.789-08' AS TIMESTAMPTZ);
RESET datestyle;
SELECT CAST('J2452271+08' AS TIMESTAMPTZ);
SELECT CAST('J2452271-08' AS TIMESTAMPTZ);
SELECT CAST('J2452271.5+08' AS TIMESTAMPTZ);
SELECT CAST('J2452271.5-08' AS TIMESTAMPTZ);
SELECT CAST('J2452271 04:05:06+08' AS TIMESTAMPTZ);
SELECT CAST('J2452271 04:05:06-08' AS TIMESTAMPTZ);
SELECT CAST('J2452271T040506+08' AS TIMESTAMPTZ);
SELECT CAST('J2452271T040506-08' AS TIMESTAMPTZ);
SELECT CAST('J2452271T040506.789+08' AS TIMESTAMPTZ);
SELECT CAST('J2452271T040506.789-08' AS TIMESTAMPTZ);
/* German/European-style dates with periods as delimiters */ SELECT CAST('12.27.2001 04:05:06.789+08' AS TIMESTAMPTZ);
SELECT CAST('12.27.2001 04:05:06.789-08' AS TIMESTAMPTZ);
SET x = 'German';
SELECT CAST('27.12.2001 04:05:06.789+08' AS TIMESTAMPTZ);
SELECT CAST('27.12.2001 04:05:06.789-08' AS TIMESTAMPTZ);
SET x = 'ISO';
/* As of 7.4, allow time without time zone having a time zone specified */ SELECT CAST('040506.789+08' AS TIME);
SELECT CAST('040506.789-08' AS TIME);
SELECT CAST('T040506.789+08' AS TIME);
SELECT CAST('T040506.789-08' AS TIME);
SELECT CAST('040506.789+08' AS TIMETZ);
SELECT CAST('040506.789-08' AS TIMETZ);
SELECT CAST('T040506.789+08' AS TIMETZ);
SELECT CAST('T040506.789-08' AS TIMETZ);
SELECT CAST('T040506.789 +08' AS TIMETZ);
SELECT CAST('T040506.789 -08' AS TIMETZ);
/* time with time zone should accept a date for DST resolution purposes */ SELECT CAST('T040506.789 America/Los_Angeles' AS TIMETZ);
SELECT CAST('2001-12-27 T040506.789 America/Los_Angeles' AS TIMETZ);
SELECT CAST('J2452271 T040506.789 America/Los_Angeles' AS TIMETZ);
/* Check time formats required by ISO 8601 */ SELECT CAST('040506.07' AS TIME);
SELECT CAST('04:05:06.07' AS TIME);
SELECT CAST('040506' AS TIME);
SELECT CAST('04:05:06' AS TIME);
SELECT CAST('0405' AS TIME);
SELECT CAST('04:05' AS TIME);
SELECT CAST('T040506.07' AS TIME);
SELECT CAST('T04:05:06.07' AS TIME);
SELECT CAST('T040506' AS TIME);
SELECT CAST('T04:05:06' AS TIME);
SELECT CAST('T0405' AS TIME);
SELECT CAST('T04:05' AS TIME);
/* 8601 says "Thh" is allowed, but we intentionally reject it as too vague */ SELECT CAST('T04' AS TIME);
SELECT CAST('040506.07+08' AS TIMETZ);
SELECT CAST('04:05:06.07+08' AS TIMETZ);
SELECT CAST('040506+08' AS TIMETZ);
SELECT CAST('04:05:06+08' AS TIMETZ);
SELECT CAST('0405+08' AS TIMETZ);
SELECT CAST('04:05+08' AS TIMETZ);
SELECT CAST('T040506.07+08' AS TIMETZ);
SELECT CAST('T04:05:06.07+08' AS TIMETZ);
SELECT CAST('T040506+08' AS TIMETZ);
SELECT CAST('T04:05:06+08' AS TIMETZ);
SELECT CAST('T0405+08' AS TIMETZ);
SELECT CAST('T04:05+08' AS TIMETZ);
/* 8601 says "Thh" is allowed, but we intentionally reject it as too vague */ SELECT CAST('T04+08' AS TIMETZ);
SET x = 'Postgres, MDY';
/* Check Julian dates BC */ SELECT CAST('J1520447' AS DATE) AS "x";
SELECT CAST('J0' AS DATE) AS "x";
/* test error on dangling Julian units */ SELECT CAST('1995-08-06  J J J' AS DATE);
SELECT CAST('J J 1520447' AS DATE);
/* We used to accept this input style, but it was based on a misreading */ /* of ISO8601, and it was never documented anyway */ SELECT CAST('Y2001M12D27H04M05S06.789+08' AS TIMESTAMPTZ);
SELECT CAST('Y2001M12D27H04MM05S06.789-08' AS TIMESTAMPTZ);
/* conflicting fields should throw errors */ SELECT CAST('1995-08-06 epoch' AS DATE);
SELECT CAST('1995-08-06 infinity' AS DATE);
SELECT CAST('1995-08-06 -infinity' AS DATE);
SELECT CAST('today infinity' AS DATE);
SELECT CAST('-infinity infinity' AS DATE);
SELECT CAST('1995-08-06 epoch' AS TIMESTAMP);
SELECT CAST('1995-08-06 infinity' AS TIMESTAMP);
SELECT CAST('1995-08-06 -infinity' AS TIMESTAMP);
SELECT CAST('epoch 01:01:01' AS TIMESTAMP);
SELECT CAST('infinity 01:01:01' AS TIMESTAMP);
SELECT CAST('-infinity 01:01:01' AS TIMESTAMP);
SELECT CAST('now epoch' AS TIMESTAMP);
SELECT CAST('-infinity infinity' AS TIMESTAMP);
SELECT CAST('1995-08-06 epoch' AS TIMESTAMPTZ);
SELECT CAST('1995-08-06 infinity' AS TIMESTAMPTZ);
SELECT CAST('1995-08-06 -infinity' AS TIMESTAMPTZ);
SELECT CAST('epoch 01:01:01' AS TIMESTAMPTZ);
SELECT CAST('infinity 01:01:01' AS TIMESTAMPTZ);
SELECT CAST('-infinity 01:01:01' AS TIMESTAMPTZ);
SELECT CAST('now epoch' AS TIMESTAMPTZ);
SELECT CAST('-infinity infinity' AS TIMESTAMPTZ);
/* date, time arithmetic */ SELECT CAST('1981-02-03' AS DATE) + CAST('04:05:06' AS TIME) AS "x";
SELECT CAST('1991-02-03' AS DATE) + CAST('04:05:06 PST' AS TIMETZ) AS "x";
SELECT CAST('2001-02-03' AS DATE) + CAST('04:05:06 UTC' AS TIMETZ) AS "x";
SELECT CAST('1991-02-03' AS DATE) + INTERVAL '2' YEARS AS "x";
SELECT CAST('2001-12-13' AS DATE) - INTERVAL '2' YEARS AS "x";
SELECT CAST('1991-02-03' AS DATE) - CAST('04:05:06 UTC' AS TIMETZ) AS "x";
/* timestamp, interval arithmetic */ SELECT CAST('1996-03-01' AS TIMESTAMP) - INTERVAL '1' SECOND AS "x";
SELECT CAST('1999-03-01' AS TIMESTAMP) - INTERVAL '1' SECOND AS "x";
SELECT CAST('2000-03-01' AS TIMESTAMP) - INTERVAL '1' SECOND AS "x";
SELECT CAST('1999-12-01' AS TIMESTAMP) + INTERVAL '1 month - 1 second' AS "x";
SELECT CAST('Jan 1, 4713 BC' AS TIMESTAMP) + INTERVAL '106000000' DAYS AS "x";
SELECT CAST('Jan 1, 4713 BC' AS TIMESTAMP) + INTERVAL '107000000' DAYS AS "x";
SELECT CAST('Jan 1, 4713 BC' AS TIMESTAMP) + INTERVAL '109203489' DAYS AS "x";
SELECT CAST('2000-01-01' AS TIMESTAMP) - INTERVAL '2483590' DAYS AS "x";
SELECT CAST('294276-12-31 23:59:59' AS TIMESTAMP) + INTERVAL '9223372036854775807' MICROSECONDS AS "x";
SELECT CAST('12/31/294276' AS TIMESTAMP) - CAST('12/23/1999' AS TIMESTAMP) AS "x";
/* Shorthand values */ /* Not directly usable for regression testing since these are not constants. */ /* So, just try to test parser and hope for the best - thomas 97/04/26 */ SELECT (CAST('today' AS TIMESTAMP) = (CAST('yesterday' AS TIMESTAMP) + INTERVAL '1' DAY)) AS "x";
SELECT (CAST('today' AS TIMESTAMP) = (CAST('tomorrow' AS TIMESTAMP) - INTERVAL '1' DAY)) AS "x";
SELECT (CAST('today 10:30' AS TIMESTAMP) = (CAST('yesterday' AS TIMESTAMP) + INTERVAL '1 day 10 hr 30 min')) AS "x";
SELECT (CAST('10:30 today' AS TIMESTAMP) = (CAST('yesterday' AS TIMESTAMP) + INTERVAL '1 day 10 hr 30 min')) AS "x";
SELECT (CAST('tomorrow' AS TIMESTAMP) = (CAST('yesterday' AS TIMESTAMP) + INTERVAL '2' DAYS)) AS "x";
SELECT (CAST('tomorrow 16:00:00' AS TIMESTAMP) = (CAST('today' AS TIMESTAMP) + INTERVAL '1 day 16 hours')) AS "x";
SELECT (CAST('16:00:00 tomorrow' AS TIMESTAMP) = (CAST('today' AS TIMESTAMP) + INTERVAL '1 day 16 hours')) AS "x";
SELECT (CAST('yesterday 12:34:56' AS TIMESTAMP) = (CAST('tomorrow' AS TIMESTAMP) - INTERVAL '2' DAYS)) AS "x";
SELECT (CAST('12:34:56 yesterday' AS TIMESTAMP) = (CAST('tomorrow' AS TIMESTAMP) - INTERVAL '2' DAYS)) AS "x";
SELECT (CAST('tomorrow' AS TIMESTAMP) > 'now') AS "x";
/* Convert from date and time to timestamp */ /* This test used to be timestamp(date,time) but no longer allowed by grammar */ /* to enable support for SQL99 timestamp type syntax. */ SELECT CAST('1994-01-01' AS DATE) + CAST('11:00' AS TIME) AS "x";
SELECT CAST('1994-01-01' AS DATE) + CAST('10:00' AS TIME) AS "x";
SELECT CAST('1994-01-01' AS DATE) + CAST('11:00-5' AS TIMETZ) AS "x";
SELECT TIMESTAMPTZ(CAST('1994-01-01' AS DATE), CAST('11:00-5' AS TIMETZ)) AS "x";
SELECT x + INTERVAL '1' YEAR AS x FROM x;
SELECT x - INTERVAL '1' YEAR AS x FROM x;
SELECT CAST('1996-03-01' AS TIMESTAMPTZ) - INTERVAL '1' SECOND AS "x";
SELECT CAST('1999-03-01' AS TIMESTAMPTZ) - INTERVAL '1' SECOND AS "x";
SELECT CAST('2000-03-01' AS TIMESTAMPTZ) - INTERVAL '1' SECOND AS "x";
SELECT CAST('1999-12-01' AS TIMESTAMPTZ) + INTERVAL '1 month - 1 second' AS "x";
SELECT CAST('2000-01-01' AS TIMESTAMPTZ) - INTERVAL '2483590' DAYS AS "x";
SELECT CAST('294276-12-31 23:59:59 UTC' AS TIMESTAMPTZ) + INTERVAL '9223372036854775807' MICROSECONDS AS "x";
SELECT (CAST('today' AS TIMESTAMPTZ) = (CAST('yesterday' AS TIMESTAMPTZ) + INTERVAL '1' DAY)) AS "x";
SELECT (CAST('today' AS TIMESTAMPTZ) = (CAST('tomorrow' AS TIMESTAMPTZ) - INTERVAL '1' DAY)) AS "x";
SELECT (CAST('tomorrow' AS TIMESTAMPTZ) = (CAST('yesterday' AS TIMESTAMPTZ) + INTERVAL '2' DAYS)) AS "x";
SELECT (CAST('tomorrow' AS TIMESTAMPTZ) > 'now') AS "x";
/* timestamp with time zone, interval arithmetic around DST change */ /* (just for fun, let's use an intentionally nonstandard POSIX zone spec) */ SET TIME ZONE 'CST7CDT,M4.1.0,M10.5.0';
SELECT CAST('2005-04-02 12:00-07' AS TIMESTAMPTZ) + INTERVAL '1' DAY AS "x";
SELECT CAST('2005-04-02 12:00-07' AS TIMESTAMPTZ) + INTERVAL '24' HOURS AS "x";
SELECT CAST('2005-04-03 12:00-06' AS TIMESTAMPTZ) - INTERVAL '1' DAY AS "x";
SELECT CAST('2005-04-03 12:00-06' AS TIMESTAMPTZ) - INTERVAL '24' HOURS AS "x";
RESET TIME ZONE;
SELECT TIMESTAMPTZ(CAST('1994-01-01' AS DATE), CAST('11:00' AS TIME)) AS "x";
SELECT TIMESTAMPTZ(CAST('1994-01-01' AS DATE), CAST('10:00' AS TIME)) AS "x";
SELECT TIMESTAMPTZ(CAST('1994-01-01' AS DATE), CAST('11:00-8' AS TIMETZ)) AS "x";
SELECT TIMESTAMPTZ(CAST('1994-01-01' AS DATE), CAST('10:00-8' AS TIMETZ)) AS "x";
SELECT TIMESTAMPTZ(CAST('1994-01-01' AS DATE), CAST('11:00-5' AS TIMETZ)) AS "x";
SELECT x + INTERVAL '1' YEAR AS x FROM x;
SELECT x - INTERVAL '1' YEAR AS x FROM x;
/* time, interval arithmetic */ SELECT CAST(CAST('01:02' AS TIME) AS INTERVAL) AS "x";
SELECT CAST(INTERVAL '02:03' AS TIME) AS "x";
SELECT CAST(INTERVAL '-02:03' AS TIME) AS "x";
SELECT CAST(INTERVAL '9223372022400000000' MICROSECOND AS TIME) AS "x";
SELECT CAST('01:30' AS TIME) + INTERVAL '02:01' AS "x";
SELECT CAST('01:30' AS TIME) - INTERVAL '02:01' AS "x";
SELECT CAST('02:30' AS TIME) + INTERVAL '36:01' AS "x";
SELECT CAST('03:30' AS TIME) + INTERVAL '1' MONTH AS "x";
SELECT CAST(CAST('01:02-08' AS TIMETZ) AS INTERVAL) AS "x";
SELECT CAST(INTERVAL '02:03' AS TIMETZ) AS "x";
SELECT CAST('01:30-08' AS TIMETZ) - INTERVAL '02:01' AS "x";
SELECT CAST('02:30-08' AS TIMETZ) + INTERVAL '36:01' AS "x";
/* Try the following two tests instead, as a poor substitute */ SELECT CAST(CAST(CAST('today' AS DATE) + CAST('05:30' AS TIMETZ) + INTERVAL '02:01' AS TIMETZ) AS TIME) AS "x";
SELECT CAST(CAST(CAST('today' AS DATE) + CAST('03:30' AS TIMETZ) + INTERVAL '1' MONTH AS TIMESTAMP) AS TIME) AS "x";
SELECT x.x AS x, x.x AS x, x.x + x.x AS "x", x.x - x.x AS "x" FROM x AS x, x AS x WHERE x.x BETWEEN '1990-01-01' AND '2001-01-01' AND x.x BETWEEN '00:00' AND '23:00' ORDER BY 1 NULLS LAST, 2 NULLS LAST;
SELECT x.x AS x, x.x AS x, x.x + x.x AS "x", x.x - x.x AS "x" FROM x AS x, x AS x WHERE ISFINITE(x.x) ORDER BY 1 NULLS LAST, 2 NULLS LAST;
SELECT x.x AS x, x.x AS x, x.x + x.x AS "x", x.x - x.x AS "x" FROM x AS x, x AS x WHERE ISFINITE(x.x) ORDER BY 1 NULLS LAST, 2 NULLS LAST;
/* SQL9x OVERLAPS operator */ /* test with time zone */ SELECT (CAST('2000-11-27' AS TIMESTAMPTZ), CAST('2000-11-28' AS TIMESTAMPTZ)) OVERLAPS (CAST('2000-11-27 12:00' AS TIMESTAMPTZ), CAST('2000-11-30' AS TIMESTAMPTZ)) AS "x";
SELECT (CAST('2000-11-26' AS TIMESTAMPTZ), CAST('2000-11-27' AS TIMESTAMPTZ)) OVERLAPS (CAST('2000-11-27 12:00' AS TIMESTAMPTZ), CAST('2000-11-30' AS TIMESTAMPTZ)) AS "x";
SELECT (CAST('2000-11-27' AS TIMESTAMPTZ), CAST('2000-11-28' AS TIMESTAMPTZ)) OVERLAPS (CAST('2000-11-27 12:00' AS TIMESTAMPTZ), INTERVAL '1' DAY) AS "x";
SELECT (CAST('2000-11-27' AS TIMESTAMPTZ), INTERVAL '12' HOURS) OVERLAPS (CAST('2000-11-27 12:00' AS TIMESTAMPTZ), CAST('2000-11-30' AS TIMESTAMPTZ)) AS "x";
SELECT (CAST('2000-11-27' AS TIMESTAMPTZ), INTERVAL '12' HOURS) OVERLAPS (CAST('2000-11-27' AS TIMESTAMPTZ), INTERVAL '12' HOURS) AS "x";
SELECT (CAST('2000-11-27' AS TIMESTAMPTZ), INTERVAL '12' HOURS) OVERLAPS (CAST('2000-11-27 12:00' AS TIMESTAMPTZ), INTERVAL '12' HOURS) AS "x";
/* test without time zone */ SELECT (CAST('2000-11-27' AS TIMESTAMP), CAST('2000-11-28' AS TIMESTAMP)) OVERLAPS (CAST('2000-11-27 12:00' AS TIMESTAMP), CAST('2000-11-30' AS TIMESTAMP)) AS "x";
SELECT (CAST('2000-11-26' AS TIMESTAMP), CAST('2000-11-27' AS TIMESTAMP)) OVERLAPS (CAST('2000-11-27 12:00' AS TIMESTAMP), CAST('2000-11-30' AS TIMESTAMP)) AS "x";
SELECT (CAST('2000-11-27' AS TIMESTAMP), CAST('2000-11-28' AS TIMESTAMP)) OVERLAPS (CAST('2000-11-27 12:00' AS TIMESTAMP), INTERVAL '1' DAY) AS "x";
SELECT (CAST('2000-11-27' AS TIMESTAMP), INTERVAL '12' HOURS) OVERLAPS (CAST('2000-11-27 12:00' AS TIMESTAMP), CAST('2000-11-30' AS TIMESTAMP)) AS "x";
SELECT (CAST('2000-11-27' AS TIMESTAMP), INTERVAL '12' HOURS) OVERLAPS (CAST('2000-11-27' AS TIMESTAMP), INTERVAL '12' HOURS) AS "x";
SELECT (CAST('2000-11-27' AS TIMESTAMP), INTERVAL '12' HOURS) OVERLAPS (CAST('2000-11-27 12:00' AS TIMESTAMP), INTERVAL '12' HOURS) AS "x";
/* test time and interval */ SELECT (CAST('00:00' AS TIME), CAST('01:00' AS TIME)) OVERLAPS (CAST('00:30' AS TIME), CAST('01:30' AS TIME)) AS "x";
SELECT (CAST('00:00' AS TIME), INTERVAL '1' HOUR) OVERLAPS (CAST('00:30' AS TIME), INTERVAL '1' HOUR) AS "x";
SELECT (CAST('00:00' AS TIME), INTERVAL '1' HOUR) OVERLAPS (CAST('01:30' AS TIME), INTERVAL '1' HOUR) AS "x";
/* SQL99 seems to want this to be false (and we conform to the spec). */ /* istm that this *should* return true, on the theory that time */ /* intervals can wrap around the day boundary - thomas 2001-09-25 */ SELECT (CAST('00:00' AS TIME), INTERVAL '1' HOUR) OVERLAPS (CAST('01:30' AS TIME), INTERVAL '1' DAY) AS "x";
CREATE TABLE x (x TIMESTAMPTZ);
/* get some candidate input values */ INSERT INTO x (x) SELECT x FROM x WHERE x BETWEEN '13-jun-1957' AND '1-jan-1997' OR x BETWEEN '1-jan-1999' AND '1-jan-2010';
SELECT x AS "x" FROM x ORDER BY "x" NULLS LAST;
SELECT x.x AS "x", x.x AS "x", x.x + x.x AS x FROM x AS x, x AS x ORDER BY x NULLS LAST, "x" NULLS LAST, "x" NULLS LAST;
SELECT x.x AS "x", x.x AS "x", x.x - x.x AS x FROM x AS x, x AS x ORDER BY x NULLS LAST, "x" NULLS LAST, "x" NULLS LAST;
SELECT x.x AS "x", CAST('1980-01-06 00:00 GMT' AS TIMESTAMPTZ) AS x, x.x - CAST('1980-01-06 00:00 GMT' AS TIMESTAMPTZ) AS x FROM x AS x ORDER BY x NULLS LAST;
SELECT x.x AS x, x.x AS x, x.x - x.x AS x FROM x AS x, x AS x ORDER BY x NULLS LAST, x NULLS LAST, x NULLS LAST;
/* Conversions */ SELECT x AS "x", DATE(x) AS x FROM x WHERE x <> CAST('now' AS TIMESTAMP) ORDER BY x NULLS LAST, "x" NULLS LAST;
DROP TABLE x;
/* Comparisons between datetime types, especially overflow cases */ /* - */ SELECT CAST(CAST('2202020-10-05' AS DATE) AS TIMESTAMP);
/* fail */ SELECT CAST('2202020-10-05' AS DATE) > CAST('2020-10-05' AS TIMESTAMP) AS x;
SELECT CAST('2020-10-05' AS TIMESTAMP) > CAST('2202020-10-05' AS DATE) AS x;
SELECT CAST(CAST('2202020-10-05' AS DATE) AS TIMESTAMPTZ);
/* fail */ SELECT CAST('2202020-10-05' AS DATE) > CAST('2020-10-05' AS TIMESTAMPTZ) AS x;
SELECT CAST('2020-10-05' AS TIMESTAMPTZ) > CAST('2202020-10-05' AS DATE) AS x;
/* This conversion may work depending on timezone */ SELECT CAST(CAST('4714-11-24 BC' AS DATE) AS TIMESTAMPTZ);
SET x = 'UTC-2';
SELECT CAST(CAST('4714-11-24 BC' AS DATE) AS TIMESTAMPTZ);
/* fail */ SELECT CAST('4714-11-24 BC' AS DATE) < CAST('2020-10-05' AS TIMESTAMPTZ) AS x;
SELECT CAST('2020-10-05' AS TIMESTAMPTZ) >= CAST('4714-11-24 BC' AS DATE) AS x;
SELECT CAST('4714-11-24 BC' AS TIMESTAMP) < CAST('2020-10-05' AS TIMESTAMPTZ) AS x;
SELECT CAST('2020-10-05' AS TIMESTAMPTZ) >= CAST('4714-11-24 BC' AS TIMESTAMP) AS x;
RESET TimeZone;
/* Tests for BETWEEN */ EXPLAIN (costs off) select count(*) from date_tbl   where f1 between '1997-01-01' and '1998-01-01';
SELECT COUNT(*) FROM x WHERE x BETWEEN '1997-01-01' AND '1998-01-01';
EXPLAIN (costs off) select count(*) from date_tbl   where f1 not between '1997-01-01' and '1998-01-01';
SELECT COUNT(*) FROM x WHERE NOT x BETWEEN '1997-01-01' AND '1998-01-01';
EXPLAIN (costs off) select count(*) from date_tbl   where f1 between symmetric '1997-01-01' and '1998-01-01';
SELECT COUNT(*) FROM x WHERE x BETWEEN x AND '1997-01-01' AND '1998-01-01';
EXPLAIN (costs off) select count(*) from date_tbl   where f1 not between symmetric '1997-01-01' and '1998-01-01';
SELECT COUNT(*) FROM x WHERE NOT x BETWEEN x AND '1997-01-01' AND '1998-01-01';
SET x = 'US,Postgres' /* Formats */;
SHOW DateStyle;
SELECT x AS x FROM x;
SET x = 'US,ISO';
SELECT x AS x FROM x;
SET x = 'US,SQL';
SHOW DateStyle;
SELECT x AS x FROM x;
SET x = 'European,Postgres';
SHOW DateStyle;
INSERT INTO x VALUES ('13/06/1957');
SELECT COUNT(*) AS x FROM x WHERE x = 'Jun 13 1957';
SELECT x AS x FROM x;
SET x = 'European,ISO';
SHOW DateStyle;
SELECT x AS x FROM x;
SET x = 'European,SQL';
SHOW DateStyle;
SELECT x AS x FROM x;
RESET DateStyle;
/* to_timestamp() */ SELECT STR_TO_TIME('0097/Feb/16 --> 08:14:30', '%Y/Mon/%d --> HH:%M:%S');
SELECT STR_TO_TIME('97/2/16 8:14:30', 'FM%Y/%-m/%-d FMHH:%-M:%-S');
SELECT STR_TO_TIME('2011$03!18 23_38_15', '%Y-%m-%d %H:%M:%S');
SELECT STR_TO_TIME('1985 January 12', '%Y F%month %d');
SELECT STR_TO_TIME('1985 FMMonth 12', '%Y "F%month" %d');
SELECT STR_TO_TIME('1985 \ 12', '%Y \\ %d');
SELECT STR_TO_TIME('My birthday-> Year: 1976, Month: May, Day: 16', '"My birthday-> Year:" %Y, "Month:" F%month, "%uay:" %d');
SELECT STR_TO_TIME('1,582nd VIII 21', 'Y,%yYth FMRM %d');
SELECT STR_TO_TIME('15 "text between quote marks" 98 54 45', HH24 "\\"text between quote marks\\"" YY MI SS);
SELECT STR_TO_TIME('05121445482000', '%m%d%H%M%S%Y');
SELECT STR_TO_TIME('2000January09Sunday', '%YF%month%dFM%uay');
SELECT STR_TO_TIME('97/Feb/16', '%yMon%d');
SELECT STR_TO_TIME('97/Feb/16', '%y:Mon:%d');
SELECT STR_TO_TIME('97/Feb/16', 'FX%y:Mon:%d');
SELECT STR_TO_TIME('97/Feb/16', 'FX%y/Mon/%d');
SELECT STR_TO_TIME('19971116', '%Y%m%d');
SELECT STR_TO_TIME('20000-1116', '%Y-%m%d');
SELECT STR_TO_TIME('1997 AD 11 16', '%Y BC %m %d');
SELECT STR_TO_TIME('1997 BC 11 16', '%Y BC %m %d');
SELECT STR_TO_TIME('1997 A.D. 11 16', '%Y B.C. %m %d');
SELECT STR_TO_TIME('1997 B.C. 11 16', '%Y B.C. %m %d');
SELECT STR_TO_TIME('9-1116', 'Y-%m%d');
SELECT STR_TO_TIME('95-1116', '%y-%m%d');
SELECT STR_TO_TIME('995-1116', '%yY-%m%d');
SELECT STR_TO_TIME('2005426', '%Y%U%u');
SELECT STR_TO_TIME('2005300', '%Y%j');
SELECT STR_TO_TIME('2005527', 'I%yYIWI%u');
SELECT STR_TO_TIME('005527', 'I%yIWI%u');
SELECT STR_TO_TIME('05527', 'IYIWI%u');
SELECT STR_TO_TIME('5527', 'IIWI%u');
SELECT STR_TO_TIME('2005364', 'I%yYI%j');
SELECT STR_TO_TIME('20050302', '%Y%m%d');
SELECT STR_TO_TIME('2005 03 02', '%Y%m%d');
SELECT STR_TO_TIME(' 2005 03 02', '%Y%m%d');
SELECT STR_TO_TIME('  20050302', '%Y%m%d');
SELECT STR_TO_TIME('2011-12-18 11:38 AM', '%Y-%m-%d %I:%M %p');
SELECT STR_TO_TIME('2011-12-18 11:38 PM', '%Y-%m-%d %I:%M %p');
SELECT STR_TO_TIME('2011-12-18 11:38 A.M.', '%Y-%m-%d %I:%M P.M.');
SELECT STR_TO_TIME('2011-12-18 11:38 P.M.', '%Y-%m-%d %I:%M P.M.');
SELECT STR_TO_TIME('2011-12-18 11:38 +05', '%Y-%m-%d %I:%M %ZH');
SELECT STR_TO_TIME('2011-12-18 11:38 -05', '%Y-%m-%d %I:%M %ZH');
SELECT STR_TO_TIME('2011-12-18 11:38 +05:20', '%Y-%m-%d %I:%M %ZH:%ZM');
SELECT STR_TO_TIME('2011-12-18 11:38 -05:20', '%Y-%m-%d %I:%M %ZH:%ZM');
SELECT STR_TO_TIME('2011-12-18 11:38 20', '%Y-%m-%d %I:%M %ZM');
SELECT STR_TO_TIME('2011-12-18 11:38 EST', '%Y-%m-%d %I:%M %Z');
SELECT STR_TO_TIME('2011-12-18 11:38 -05', '%Y-%m-%d %I:%M %Z');
SELECT STR_TO_TIME('2011-12-18 11:38 +01:30', '%Y-%m-%d %I:%M %Z');
SELECT STR_TO_TIME('2011-12-18 11:38 MSK', '%Y-%m-%d %I:%M %Z');
/* dyntz */ SELECT STR_TO_TIME('2011-12-18 00:00 LMT', '%Y-%m-%d %H:%M %Z');
/* dyntz */ SELECT STR_TO_TIME('2011-12-18 11:38ESTFOO24', '%Y-%m-%d %I:%M%ZFOO%S');
SELECT STR_TO_TIME('2011-12-18 11:38-05FOO24', '%Y-%m-%d %I:%M%ZFOO%S');
SELECT STR_TO_TIME('2011-12-18 11:38 JUNK', '%Y-%m-%d %I:%M %Z');
/* error */ SELECT STR_TO_TIME('2011-12-18 11:38 ...', '%Y-%m-%d %I:%M %Z');
/* error */ SELECT STR_TO_TIME('2011-12-18 11:38 -05', '%Y-%m-%d %I:%M %z');
SELECT STR_TO_TIME('2011-12-18 11:38 +01:30', '%Y-%m-%d %I:%M %z');
SELECT STR_TO_TIME('2011-12-18 11:38 +xyz', '%Y-%m-%d %I:%M %z');
/* error */ SELECT STR_TO_TIME('2011-12-18 11:38 +01:xyz', '%Y-%m-%d %I:%M %z');
/* error */ SELECT STR_TO_TIME('2018-11-02 12:34:56.025', '%Y-%m-%d %H:%M:%S.MS');
SELECT x, STR_TO_TIME('2018-11-02 12:34:56', 'YYYY-MM-DD HH24:MI:SS.FF' || x) FROM x AS x;
SELECT x, STR_TO_TIME('2018-11-02 12:34:56.1', 'YYYY-MM-DD HH24:MI:SS.FF' || x) FROM x AS x;
SELECT x, STR_TO_TIME('2018-11-02 12:34:56.12', 'YYYY-MM-DD HH24:MI:SS.FF' || x) FROM x AS x;
SELECT x, STR_TO_TIME('2018-11-02 12:34:56.123', 'YYYY-MM-DD HH24:MI:SS.FF' || x) FROM x AS x;
SELECT x, STR_TO_TIME('2018-11-02 12:34:56.1234', 'YYYY-MM-DD HH24:MI:SS.FF' || x) FROM x AS x;
SELECT x, STR_TO_TIME('2018-11-02 12:34:56.12345', 'YYYY-MM-DD HH24:MI:SS.FF' || x) FROM x AS x;
SELECT x, STR_TO_TIME('2018-11-02 12:34:56.123456', 'YYYY-MM-DD HH24:MI:SS.FF' || x) FROM x AS x;
SELECT x, STR_TO_TIME('2018-11-02 12:34:56.123456789', 'YYYY-MM-DD HH24:MI:SS.FF' || x) FROM x AS x;
SELECT x, STR_TO_TIME('20181102123456123456', 'YYYYMMDDHH24MISSFF' || x) FROM x AS x;
SELECT STR_TO_DATE('1 4 1902', 'Q %m %Y');
/* Q is ignored */ SELECT STR_TO_DATE('3 4 21 01', 'W %m CC %y');
SELECT STR_TO_DATE('2458872', 'J');
/* Check handling of BC dates */ SELECT STR_TO_DATE('44-02-01 BC', '%Y-%m-%d BC');
SELECT STR_TO_DATE('-44-02-01', '%Y-%m-%d');
SELECT STR_TO_DATE('-44-02-01 BC', '%Y-%m-%d BC');
SELECT STR_TO_TIME('44-02-01 11:12:13 BC', '%Y-%m-%d %H:%M:%S BC');
SELECT STR_TO_TIME('-44-02-01 11:12:13', '%Y-%m-%d %H:%M:%S');
SELECT STR_TO_TIME('-44-02-01 11:12:13 BC', '%Y-%m-%d %H:%M:%S BC');
/* Check handling of multiple spaces in format and/or input */ SELECT STR_TO_TIME('2011-12-18 23:38:15', '%Y-%m-%d  %H:%M:%S');
SELECT STR_TO_TIME('2011-12-18  23:38:15', '%Y-%m-%d  %H:%M:%S');
SELECT STR_TO_TIME('2011-12-18   23:38:15', '%Y-%m-%d  %H:%M:%S');
SELECT STR_TO_TIME('2011-12-18  23:38:15', '%Y-%m-%d %H:%M:%S');
SELECT STR_TO_TIME('2011-12-18  23:38:15', '%Y-%m-%d  %H:%M:%S');
SELECT STR_TO_TIME('2011-12-18  23:38:15', '%Y-%m-%d   %H:%M:%S');
SELECT STR_TO_TIME('2000+   JUN', '%Y/MON');
SELECT STR_TO_TIME('  2000 +JUN', '%Y/MON');
SELECT STR_TO_TIME(' 2000 +JUN', '%Y//MON');
SELECT STR_TO_TIME('2000  +JUN', '%Y//MON');
SELECT STR_TO_TIME('2000 + JUN', '%Y MON');
SELECT STR_TO_TIME('2000 ++ JUN', '%Y  MON');
SELECT STR_TO_TIME('2000 + + JUN', '%Y  MON');
SELECT STR_TO_TIME('2000 + + JUN', '%Y   MON');
SELECT STR_TO_TIME('2000 -10', '%Y %ZH');
SELECT STR_TO_TIME('2000 -10', '%Y  %ZH');
SELECT STR_TO_DATE('2011 12  18', '%Y %m %d');
SELECT STR_TO_DATE('2011 12  18', '%Y %m  %d');
SELECT STR_TO_DATE('2011 12  18', '%Y %m   %d');
SELECT STR_TO_DATE('2011 12 18', '%Y  %m %d');
SELECT STR_TO_DATE('2011  12 18', '%Y  %m %d');
SELECT STR_TO_DATE('2011   12 18', '%Y  %m %d');
SELECT STR_TO_DATE('2011 12 18', '%Yx%mx%d');
SELECT STR_TO_DATE('2011x 12x 18', '%Yx%mx%d');
SELECT STR_TO_DATE('2011 x12 x18', '%Yx%mx%d');
/* Check errors for some incorrect usages of to_timestamp() and to_date() */ /* Mixture of date conventions (ISO week and Gregorian): */ SELECT STR_TO_TIME('2005527', '%YIWI%u');
/* Insufficient characters in the source string: */ SELECT STR_TO_TIME('19971', '%Y%m%d');
/* Insufficient digit characters for a single node: */ SELECT STR_TO_TIME('19971)24', '%Y%m%d');
/* We don't accept full-length day or month names if short form is specified: */ SELECT STR_TO_TIME('Friday 1-January-1999', '%uY %d MON %Y');
SELECT STR_TO_TIME('Fri 1-January-1999', '%uY %d MON %Y');
SELECT STR_TO_TIME('Fri 1-Jan-1999', '%uY %d MON %Y');
/* ok */ /* Value clobbering: */ SELECT STR_TO_TIME('1997-11-Jan-16', '%Y-%m-Mon-%d');
/* Non-numeric input: */ SELECT STR_TO_TIME('199711xy', '%Y%m%d');
/* Input that doesn't fit in an int: */ SELECT STR_TO_TIME('10000000000', 'FM%Y');
/* Out-of-range and not-quite-out-of-range fields: */ SELECT STR_TO_TIME('2016-06-13 25:00:00', '%Y-%m-%d %H:%M:%S');
SELECT STR_TO_TIME('2016-06-13 15:60:00', '%Y-%m-%d %H:%M:%S');
SELECT STR_TO_TIME('2016-06-13 15:50:60', '%Y-%m-%d %H:%M:%S');
SELECT STR_TO_TIME('2016-06-13 15:50:55', '%Y-%m-%d %H:%M:%S');
/* ok */ SELECT STR_TO_TIME('2016-06-13 15:50:55', '%Y-%m-%d HH:%M:%S');
SELECT STR_TO_TIME('2016-13-01 15:50:55', '%Y-%m-%d %H:%M:%S');
SELECT STR_TO_TIME('2016-02-30 15:50:55', '%Y-%m-%d %H:%M:%S');
SELECT STR_TO_TIME('2016-02-29 15:50:55', '%Y-%m-%d %H:%M:%S');
/* ok */ SELECT STR_TO_TIME('2015-02-29 15:50:55', '%Y-%m-%d %H:%M:%S');
SELECT STR_TO_TIME('2015-02-11 86000', '%Y-%m-%d %S%S');
/* ok */ SELECT STR_TO_TIME('2015-02-11 86400', '%Y-%m-%d %S%S');
SELECT STR_TO_TIME('2015-02-11 86000', '%Y-%m-%d %S%SS');
/* ok */ SELECT STR_TO_TIME('2015-02-11 86400', '%Y-%m-%d %S%SS');
SELECT STR_TO_TIME('1000000000,999', 'Y,YYY');
SELECT STR_TO_TIME('0.-2147483648', '%S.MS');
SELECT STR_TO_TIME('613566758', 'W');
SELECT STR_TO_TIME('2024 613566758 1', '%Y %U %u');
SELECT STR_TO_DATE('2016-13-10', '%Y-%m-%d');
SELECT STR_TO_DATE('2016-02-30', '%Y-%m-%d');
SELECT STR_TO_DATE('2016-02-29', '%Y-%m-%d');
/* ok */ SELECT STR_TO_DATE('2015-02-29', '%Y-%m-%d');
SELECT STR_TO_DATE('2015 365', '%Y %j');
/* ok */ SELECT STR_TO_DATE('2015 366', '%Y %j');
SELECT STR_TO_DATE('2016 365', '%Y %j');
/* ok */ SELECT STR_TO_DATE('2016 366', '%Y %j');
/* ok */ SELECT STR_TO_DATE('2016 367', '%Y %j');
SELECT STR_TO_DATE('0000-02-01', '%Y-%m-%d');
/* allowed, though it shouldn't be */ SELECT STR_TO_DATE('100000000', 'CC');
SELECT STR_TO_DATE('-100000000', 'CC');
SELECT STR_TO_DATE('-2147483648 01', 'CC %y');
SELECT STR_TO_DATE('2147483647 01', 'CC %y');
/* to_char's TZ format code produces zone abbrev if known */ SELECT TIME_TO_STR(CAST('2012-12-12 12:00' AS TIMESTAMPTZ), '%Y-%m-%d HH:%M:%S %Z');
SELECT TIME_TO_STR(CAST('2012-12-12 12:00' AS TIMESTAMPTZ), '%Y-%m-%d HH:%M:%S tz');
/* Check behavior with SQL-style fixed-GMT-offset time zone (cf bug #8572) */ SET TIME ZONE 'America/New_York';
SET TIME ZONE '-1.5';
SHOW TIME ZONE;
SELECT CAST('2012-12-12 12:00' AS TIMESTAMPTZ);
SELECT CAST('2012-12-12 12:00 America/New_York' AS TIMESTAMPTZ);
SELECT TIME_TO_STR(CAST('2012-12-12 12:00' AS TIMESTAMPTZ), '%Y-%m-%d HH:%M:%S %Z');
SELECT TIME_TO_STR(CAST('2012-12-12 12:00' AS TIMESTAMPTZ), '%Y-%m-%d %S%S');
SELECT TIME_TO_STR(CAST('2012-12-12 12:00' AS TIMESTAMPTZ), '%Y-%m-%d %S%SS');
SET TIME ZONE '+2';
SELECT TIME_TO_STR(CAST('2012-12-12 12:00' AS TIMESTAMPTZ), '%Y-%m-%d HH:%M:%S %Z');
RESET TIME ZONE;
/* sanity check of system catalog */ SELECT x, x, x FROM x WHERE NOT x IN ('', 'a', 'd');
CREATE TABLE x (x INT GENERATED BY DEFAULT AS IDENTITY, x TEXT);
CREATE TABLE x (x BIGINT GENERATED ALWAYS AS IDENTITY, x TEXT);
CREATE TABLE x (x SMALLINT GENERATED BY DEFAULT AS IDENTITY (START WITH 7 INCREMENT BY 5), x TEXT);
ALTER TABLE itest3 ALTER COLUMN a ADD GENERATED ALWAYS AS IDENTITY;
/* error */ SELECT x, x, x, x, x, x, x, x, x, x, x FROM x.x WHERE x LIKE 'itest_' ORDER BY 1 NULLS LAST, 2 NULLS LAST;
/* internal sequences should not be shown here */ SELECT x FROM x.x WHERE x LIKE 'itest%';
SELECT PG_GET_SERIAL_SEQUENCE('itest1', 'a');
ALTER TABLE itest4 ALTER COLUMN a ADD GENERATED ALWAYS AS IDENTITY;
ALTER TABLE x ALTER COLUMN x SET NOT NULL /* error, requires NOT NULL */;
ALTER TABLE itest4 ALTER COLUMN c ADD GENERATED ALWAYS AS IDENTITY;
/* error, column c does not exist */ ALTER TABLE itest4 ALTER COLUMN a ADD GENERATED ALWAYS AS IDENTITY;
ALTER TABLE x ALTER COLUMN x DROP NOT NULL /* ok */;
/* error, disallowed */ ALTER TABLE itest4 ALTER COLUMN a ADD GENERATED ALWAYS AS IDENTITY;
/* error, already set */ ALTER TABLE itest4 ALTER COLUMN b ADD GENERATED ALWAYS AS IDENTITY;
ALTER TABLE x ALTER COLUMN x SET DEFAULT '' /* error, wrong data type */ /* for later */;
/* invalid column type */ CREATE TABLE x (x TEXT GENERATED BY DEFAULT AS IDENTITY);
/* duplicate identity */ CREATE TABLE x (x INT GENERATED ALWAYS AS IDENTITY GENERATED BY DEFAULT AS IDENTITY);
/* cannot have default and identity */ CREATE TABLE x (x INT DEFAULT 5 GENERATED BY DEFAULT AS IDENTITY);
/* cannot combine serial and identity */ CREATE TABLE x (x SERIAL GENERATED BY DEFAULT AS IDENTITY);
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
/* VALUES RTEs */ CREATE TABLE x (x INT GENERATED ALWAYS AS IDENTITY, x TEXT);
INSERT INTO x VALUES (1, 'a');
/* error */ INSERT INTO x VALUES (DEFAULT, 'a');
/* ok */ INSERT INTO x VALUES (2, 'b'), (3, 'c');
/* error */ INSERT INTO x VALUES (DEFAULT, 'b'), (3, 'c');
/* error */ INSERT INTO x VALUES (2, 'b'), (DEFAULT, 'c');
/* error */ INSERT INTO x VALUES (DEFAULT, 'b'), (DEFAULT, 'c');
SELECT * FROM x;
DROP TABLE x;
INSERT INTO x VALUES (DEFAULT, 'a');
INSERT INTO x VALUES (DEFAULT, 'b'), (DEFAULT, 'c');
SELECT * FROM x;
/* OVERRIDING tests */ /* GENERATED BY DEFAULT */ /* This inserts the row as presented: */ INSERT INTO x VALUES (10, 'xyz');
SELECT * FROM x;
/* GENERATED ALWAYS */ /* This is an error: */ INSERT INTO x VALUES (10, 'xyz');
SELECT * FROM x;
/* UPDATE tests */ /* GENERATED BY DEFAULT is not restricted. */ UPDATE x SET x = 101 WHERE x = 1;
UPDATE x SET x = x WHERE x = 2;
SELECT * FROM x;
/* GENERATED ALWAYS allows only DEFAULT. */ UPDATE x SET x = 101 WHERE x = 1;
/* error */ UPDATE x SET x = x WHERE x = 2;
/* ok */ SELECT * FROM x;
/* COPY tests */ CREATE TABLE x (x INT GENERATED ALWAYS AS IDENTITY, x TEXT, x BIGINT);
COPY INTO x FROM x;
/* DROP IDENTITY tests */ ALTER TABLE itest4 ALTER COLUMN a DROP IDENTITY;
ALTER TABLE itest4 ALTER COLUMN a DROP IDENTITY;
/* error */ ALTER TABLE itest4 ALTER COLUMN a DROP IDENTITY IF EXISTS;
ALTER TABLE x ALTER COLUMN x DROP NOT NULL /* fails because NOT NULL is not dropped */;
SELECT * FROM x;
/* check that sequence is removed */ SELECT x FROM x;
/* test views */ CREATE TABLE x (x INT GENERATED BY DEFAULT AS IDENTITY, x TEXT);
CREATE TABLE x (x INT GENERATED ALWAYS AS IDENTITY, x TEXT);
CREATE VIEW x AS SELECT * FROM x;
CREATE VIEW x AS SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
INSERT INTO x VALUES (10, 'xyz');
SELECT * FROM x;
INSERT INTO x VALUES (10, 'xyz');
SELECT * FROM x;
/* ADD COLUMN */ CREATE TABLE x (x INT);
ALTER TABLE x ADD COLUMN x INT GENERATED BY DEFAULT AS IDENTITY /* add column to empty table */;
INSERT INTO x VALUES (1), (2), (3);
ALTER TABLE x ADD COLUMN x INT GENERATED BY DEFAULT AS IDENTITY /* add column to populated table */;
SELECT * FROM x;
ALTER TABLE x ALTER COLUMN x SET DEFAULT 1 /* various ALTER COLUMN tests */ /* fail, not allowed for identity columns */;
/* fail, not allowed, already has a default */ CREATE TABLE x (x SERIAL, x TEXT);
ALTER TABLE itest5 ALTER COLUMN a ADD GENERATED ALWAYS AS IDENTITY;
ALTER TABLE x ALTER COLUMN x SET DATA TYPE INT;
SELECT CAST(x AS REGTYPE) FROM x WHERE x = CAST('itest3_a_seq' AS REGCLASS);
/* error */ /* check that unlogged propagates to sequence */ CREATE UNLOGGED TABLE x (x INT NOT NULL, x TEXT);
ALTER TABLE itest17 ALTER COLUMN a ADD GENERATED ALWAYS AS IDENTITY;
ALTER TABLE x ADD COLUMN x INT GENERATED ALWAYS AS IDENTITY;
ALTER TABLE itest18 SET UNLOGGED, ALTER COLUMN a ADD GENERATED ALWAYS AS IDENTITY;
ALTER TABLE x ALTER COLUMN x DROP DEFAULT, SET GENERATED BY DEFAULT SET INCREMENT BY 2 SET START WITH 100 RESTART;
SELECT * FROM x;
SELECT x, x, x, x FROM x.x WHERE x = 'itest6' ORDER BY 1 NULLS LAST, 2 NULLS LAST;
ALTER TABLE x ALTER COLUMN x DROP DEFAULT, SET INCREMENT BY 2;
/* fail, not identity */ /* prohibited direct modification of sequence */ ALTER SEQUENCE itest6_a_seq OWNED BY NONE;
/* inheritance */ CREATE TABLE x (x INT GENERATED ALWAYS AS IDENTITY);
SELECT * FROM x;
/* identity property is not inherited */ CREATE TABLE x (x TEXT) INHERITS (x);
/* make column identity in child table */ CREATE TABLE x (x INT);
CREATE TABLE x (x INT GENERATED ALWAYS AS IDENTITY) INHERITS (x);
SELECT * FROM x;
CREATE TABLE x (x INT NOT NULL);
CREATE TABLE x INHERITS (x);
ALTER TABLE itest7d ALTER COLUMN a ADD GENERATED ALWAYS AS IDENTITY;
ALTER TABLE x ADD COLUMN x INT GENERATED ALWAYS AS IDENTITY;
/* error */ SELECT x, x, x, x, x FROM x.x WHERE x LIKE 'itest7%' ORDER BY 1 NULLS LAST, 2 NULLS LAST;
ALTER TABLE x ALTER COLUMN x DROP DEFAULT, SET GENERATED BY DEFAULT /* These ALTER TABLE variants will not recurse. */;
ALTER TABLE x ALTER COLUMN x SET DATA TYPE RESTART;
ALTER TABLE itest7 ALTER COLUMN a DROP IDENTITY;
/* privileges */ CREATE USER regress_identity_user1;
CREATE TABLE x (x INT GENERATED ALWAYS AS IDENTITY, x TEXT);
GRANT SELECT, INSERT ON x TO x;
SET ROLE regress_identity_user1;
SELECT * FROM x;
RESET ROLE;
DROP TABLE x;
DROP USER regress_identity_user1;
/* multiple steps in ALTER TABLE */ CREATE TABLE x (x INT);
ALTER TABLE itest8   ADD COLUMN f2 int NOT NULL,   ALTER COLUMN f2 ADD GENERATED ALWAYS AS IDENTITY;
ALTER TABLE itest8   ADD COLUMN f3 int NOT NULL,   ALTER COLUMN f3 ADD GENERATED ALWAYS AS IDENTITY,   ALTER COLUMN f3 SET GENERATED BY DEFAULT SET INCREMENT 10;
ALTER TABLE x ADD COLUMN x INT;
ALTER TABLE itest8   ALTER COLUMN f4 SET NOT NULL,   ALTER COLUMN f4 ADD GENERATED ALWAYS AS IDENTITY,   ALTER COLUMN f4 SET DATA TYPE bigint;
ALTER TABLE x ADD COLUMN x INT GENERATED ALWAYS AS IDENTITY;
ALTER TABLE itest8   ALTER COLUMN f5 DROP IDENTITY,   ALTER COLUMN f5 DROP NOT NULL,   ALTER COLUMN f5 SET DATA TYPE bigint;
INSERT INTO x VALUES (0), (1);
/* This does not work when the table isn't empty.  That's intentional, */ /* since ADD GENERATED should only affect later insertions: */ ALTER TABLE itest8   ADD COLUMN f22 int NOT NULL,   ALTER COLUMN f22 ADD GENERATED ALWAYS AS IDENTITY;
x AS x;
/* typed tables (currently not supported) */ CREATE TYPE itest_type AS (f1 integer, f2 text, f3 bigint);
CREATE TABLE itest12 OF itest_type (f1 WITH OPTIONS GENERATED ALWAYS AS IDENTITY);
/* error */ DROP TYPE itest_type CASCADE;
/* table partitions */ /* partitions inherit identity column and share sequence */ CREATE TABLE x (x DATE NOT NULL, x TEXT, x BIGINT GENERATED ALWAYS AS IDENTITY) WITH (PARTITIONED_BY=RANGE(x));
/* new partition */ CREATE TABLE x PARTITION OF x FOR VALUES FROM ('2016-07-01') TO ('2016-08-01');
INSERT INTO x (x, x) VALUES ('2016-07-2', 'from pitest1');
INSERT INTO x (x, x) VALUES ('2016-07-3', 'from pitest1_p1');
/* attached partition */ CREATE TABLE x (x BIGINT, x TEXT, x DATE NOT NULL);
INSERT INTO x (x, x, x) VALUES ('2016-08-2', 'before attaching', 100);
ALTER TABLE pitest1 ATTACH PARTITION pitest1_p2 FOR VALUES FROM ('2016-08-01') TO ('2016-09-01');
ALTER TABLE x ALTER COLUMN x SET NOT NULL /* requires NOT NULL constraint */;
ALTER TABLE pitest1 ATTACH PARTITION pitest1_p2 FOR VALUES FROM ('2016-08-01') TO ('2016-09-01');
INSERT INTO x (x, x) VALUES ('2016-08-3', 'from pitest1_p2');
INSERT INTO x (x, x) VALUES ('2016-08-4', 'from pitest1');
/* LIKE INCLUDING on partition */ CREATE TABLE x (LIKE x INCLUDING IDENTITY);
INSERT INTO x (x, x) VALUES ('2016-07-2', 'from pitest1_p1_like');
SELECT CAST(x AS REGCLASS), x, x, x FROM x;
SELECT CAST(x AS REGCLASS), x, x, x FROM x;
ALTER TABLE x ALTER COLUMN x SET DATA TYPE BIGINT;
SELECT CAST(x AS REGCLASS), x, x, x, PG_TYPEOF(x) FROM x;
SELECT CAST(x AS REGCLASS), x, x, x, PG_TYPEOF(x) FROM x;
/* add identity column */ CREATE TABLE x (x DATE NOT NULL, x TEXT) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM ('2016-07-01') TO ('2016-08-01');
CREATE TABLE x PARTITION OF x FOR VALUES FROM ('2016-08-01') TO ('2016-09-01');
INSERT INTO x (x, x) VALUES ('2016-07-2', 'from pitest2');
INSERT INTO x (x, x) VALUES ('2016-08-2', 'from pitest2');
ALTER TABLE x ADD COLUMN x INT GENERATED ALWAYS AS IDENTITY;
INSERT INTO x (x, x) VALUES ('2016-07-3', 'from pitest2_p1');
INSERT INTO x (x, x) VALUES ('2016-08-3', 'from pitest2_p2');
INSERT INTO x (x, x) VALUES ('2016-07-4', 'from pitest2');
INSERT INTO x (x, x) VALUES ('2016-08-4', 'from pitest2');
SELECT CAST(x AS REGCLASS), x, x, x FROM x;
ALTER TABLE x ALTER COLUMN x DROP DEFAULT, SET GENERATED BY DEFAULT /* SET identity column */;
ALTER TABLE x ALTER COLUMN x DROP DEFAULT, SET INCREMENT BY 2 /* fails */;
ALTER TABLE ONLY x ALTER COLUMN x DROP DEFAULT, SET GENERATED BY DEFAULT SET INCREMENT BY 2 SET START WITH 1000 RESTART /* fails */;
ALTER TABLE x ALTER COLUMN x DROP DEFAULT, SET GENERATED BY DEFAULT SET INCREMENT BY 2 SET START WITH 1000 RESTART /* fails */;
INSERT INTO x (x, x, x) VALUES ('2016-07-5', 'from pitest2', 200);
INSERT INTO x (x, x) VALUES ('2016-08-5', 'from pitest2');
INSERT INTO x (x, x) VALUES ('2016-07-6', 'from pitest2_p1');
INSERT INTO x (x, x, x) VALUES ('2016-08-6', 'from pitest2_p2', 300);
SELECT CAST(x AS REGCLASS), x, x, x FROM x;
/* detaching a partition removes identity property */ ALTER TABLE pitest2 DETACH PARTITION pitest2_p1;
INSERT INTO x (x, x) VALUES ('2016-08-7', 'from pitest2');
INSERT INTO x (x, x) VALUES ('2016-07-7', 'from pitest2_p1');
/* error */ INSERT INTO x (x, x, x) VALUES ('2016-07-7', 'from pitest2_p1', 2000);
SELECT CAST(x AS REGCLASS), x, x, x FROM x;
SELECT CAST(x AS REGCLASS), x, x, x FROM x;
DROP TABLE x;
/* changing a regular column to identity column in a partitioned table */ CREATE TABLE x (x DATE NOT NULL, x TEXT, x INT) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM ('2016-07-01') TO ('2016-08-01');
INSERT INTO x VALUES ('2016-07-2', 'from pitest3', 1);
INSERT INTO x VALUES ('2016-07-3', 'from pitest3_p1', 2);
/* fails, changing only a partition not allowed */ ALTER TABLE pitest3_p1             ALTER COLUMN f3 SET NOT NULL,             ALTER COLUMN f3 ADD GENERATED ALWAYS AS IDENTITY (START WITH 3);
/* fails, changing only the partitioned table not allowed */ BEGIN;
ALTER TABLE x ALTER COLUMN x SET NOT NULL;
ALTER TABLE ONLY pitest3             ALTER COLUMN f3 ADD GENERATED ALWAYS AS IDENTITY (START WITH 3);
ROLLBACK;
ALTER TABLE pitest3             ALTER COLUMN f3 SET NOT NULL,             ALTER COLUMN f3 ADD GENERATED ALWAYS AS IDENTITY (START WITH 3);
INSERT INTO x (x, x) VALUES ('2016-07-4', 'from pitest3');
INSERT INTO x (x, x) VALUES ('2016-07-5', 'from pitest3_p1');
SELECT CAST(x AS REGCLASS), x, x, x FROM x;
/* changing an identity column to a non-identity column in a partitioned table */ ALTER TABLE pitest3_p1 ALTER COLUMN f3 DROP IDENTITY;
/* fails */ ALTER TABLE ONLY pitest3 ALTER COLUMN f3 DROP IDENTITY;
/* fails */ ALTER TABLE pitest3 ALTER COLUMN f3 DROP IDENTITY;
INSERT INTO x (x, x) VALUES ('2016-07-4', 'from pitest3');
/* fails */ INSERT INTO x (x, x) VALUES ('2016-07-5', 'from pitest3_p1');
/* fails */ INSERT INTO x (x, x, x) VALUES ('2016-07-6', 'from pitest3', 5);
INSERT INTO x (x, x, x) VALUES ('2016-07-7', 'from pitest3_p1', 6);
SELECT CAST(x AS REGCLASS), x, x, x FROM x;
ALTER TABLE x ALTER COLUMN x DROP NOT NULL /* Changing NOT NULL constraint of identity columns is not allowed */;
ALTER TABLE x ALTER COLUMN x DROP NOT NULL;
ALTER TABLE x ALTER COLUMN x SET DEFAULT 10000 /* Identity columns have their own default */;
ALTER TABLE x ALTER COLUMN x SET DEFAULT 10000;
/* Adding identity to an identity column is not allowed */ ALTER TABLE pitest1_p2 ALTER COLUMN f3 ADD GENERATED BY DEFAULT AS IDENTITY;
ALTER TABLE pitest1 ALTER COLUMN f3 ADD GENERATED BY DEFAULT AS IDENTITY;
CREATE TABLE x (x DATE NOT NULL, x TEXT, x BIGINT GENERATED ALWAYS AS IDENTITY);
ALTER TABLE pitest1 ATTACH PARTITION pitest1_pfail FOR VALUES FROM ('2016-11-01') TO ('2016-12-01');
ALTER TABLE pitest3 ATTACH PARTITION pitest1_pfail FOR VALUES FROM ('2016-11-01') TO ('2016-12-01');
DROP TABLE x;
DROP TABLE x;
/* test that sequence of half-dropped serial column is properly ignored */ CREATE TABLE x (x SERIAL);
ALTER TABLE x ALTER COLUMN x DROP DEFAULT;
ALTER TABLE itest14 ALTER id ADD GENERATED BY DEFAULT AS IDENTITY;
INSERT INTO x (x) VALUES (DEFAULT);
/* Identity columns must be NOT NULL (cf bug #16913) */ CREATE TABLE x (x INT GENERATED ALWAYS AS IDENTITY NULL);
/* fail */ CREATE TABLE x (x INT NULL GENERATED ALWAYS AS IDENTITY);
/* fail */ CREATE TABLE x (x INT GENERATED ALWAYS AS IDENTITY NOT NULL);
DROP TABLE x;
CREATE TABLE x (x INT NOT NULL GENERATED ALWAYS AS IDENTITY);
DROP TABLE x;
/* MERGE tests */ CREATE TABLE x (x INT GENERATED ALWAYS AS IDENTITY, x TEXT);
CREATE TABLE x (x INT GENERATED BY DEFAULT AS IDENTITY, x TEXT);
MERGE INTO x AS x USING (SELECT 10 AS x, 'inserted by merge' AS x) AS x ON x.x = x.x WHEN NOT MATCHED THEN INSERT (x, x) VALUES (x.x, x.x);
MERGE INTO x AS x USING (SELECT 10 AS x, 'inserted by merge' AS x) AS x ON x.x = x.x WHEN NOT MATCHED THEN INSERT (x, x) VALUES (x.x, x.x);
SELECT * FROM x;
SELECT * FROM x;
DROP TABLE x;
DROP TABLE x;
/* For testing of pg_dump and pg_upgrade, leave behind some identity */ /* sequences whose logged-ness doesn't match their owning table's. */ CREATE TABLE x (x INT GENERATED ALWAYS AS IDENTITY);
ALTER SEQUENCE identity_dump_logged_a_seq SET UNLOGGED;
CREATE UNLOGGED TABLE x (x INT GENERATED ALWAYS AS IDENTITY);
ALTER SEQUENCE identity_dump_unlogged_a_seq SET LOGGED;
SELECT x, x FROM x WHERE REGEXP_LIKE(x, '^identity_dump_') ORDER BY 1 NULLS LAST;
/* When there is a LIMIT clause, incremental sort is beneficial because */ /* it only has to sort some of the groups, and not the entire table. */ EXPLAIN (costs off) select * from (select * from tenk1 order by four) t order by four, ten limit 1;
SET x = '2MB' /* When work_mem is not enough to sort the entire table, incremental sort */ /* may be faster if individual groups still fit into work_mem. */;
EXPLAIN (costs off) select * from (select * from tenk1 order by four) t order by four, ten;
RESET work_mem;
CREATE TABLE x (x INT, x INT);
BEGIN for line in     execute 'explain (analyze, costs off, summary off, timing off, buffers off) ' || query   loop     out_line := regexp_replace(line, '\d+kB', 'NNkB', 'g');
x AS x;
COMMIT;
x AS x;
BEGIN execute 'explain (analyze, costs off, summary off, timing off, buffers off, format ''json'') ' || query into strict elements;
x := x - 0;
x := x - 'Plan';
x := x - 'Plans';
x AS x;
COMMIT;
x AS x;
x AS x;
x AS x;
BEGIN for node in select * from jsonb_array_elements(explain_analyze_inc_sort_nodes(query)) t loop     for group_key in select unnest(array['Full-sort Groups', 'Pre-sorted Groups']::text[]) t loop       for space_key in select unnest(array['Sort Space Memory', 'Sort Space Disk']::text[]) t loop         node := jsonb_set(node, array[group_key, space_key, 'Average Sort Space Used'], '"NN"', false);
x := JSONB_SET(x, ARRAY(x, x, 'Peak Sort Space Used'), '"NN"', FALSE);
x := x || x;
x AS x;
COMMIT;
x AS x;
x AS x;
x AS x;
BEGIN for node in select * from jsonb_array_elements(explain_analyze_inc_sort_nodes(query)) t loop     for group_key in select unnest(array['Full-sort Groups', 'Pre-sorted Groups']::text[]) t loop       group_stats := node->group_key;
x AS x;
COMMIT;
/* A single large group tested around each mode transition point. */ INSERT INTO x (x, x) SELECT x / 100 + 1, x + 1 FROM x AS x;
ANALYZE x;
EXPLAIN (costs off) select * from (select * from t order by a) s order by a, b limit 31;
SELECT * FROM (SELECT * FROM x ORDER BY x NULLS LAST) AS x ORDER BY x NULLS LAST, x NULLS LAST LIMIT 31;
EXPLAIN (costs off) select * from (select * from t order by a) s order by a, b limit 32;
SELECT * FROM (SELECT * FROM x ORDER BY x NULLS LAST) AS x ORDER BY x NULLS LAST, x NULLS LAST LIMIT 32;
EXPLAIN (costs off) select * from (select * from t order by a) s order by a, b limit 33;
SELECT * FROM (SELECT * FROM x ORDER BY x NULLS LAST) AS x ORDER BY x NULLS LAST, x NULLS LAST LIMIT 33;
EXPLAIN (costs off) select * from (select * from t order by a) s order by a, b limit 65;
SELECT * FROM (SELECT * FROM x ORDER BY x NULLS LAST) AS x ORDER BY x NULLS LAST, x NULLS LAST LIMIT 65;
EXPLAIN (costs off) select * from (select * from t order by a) s order by a, b limit 66;
SELECT * FROM (SELECT * FROM x ORDER BY x NULLS LAST) AS x ORDER BY x NULLS LAST, x NULLS LAST LIMIT 66;
DELETE FROM x;
/* An initial large group followed by a small group. */ INSERT INTO x (x, x) SELECT x / 50 + 1, x + 1 FROM x AS x;
ANALYZE x;
EXPLAIN (costs off) select * from (select * from t order by a) s order by a, b limit 55;
SELECT * FROM (SELECT * FROM x ORDER BY x NULLS LAST) AS x ORDER BY x NULLS LAST, x NULLS LAST LIMIT 55;
/* Test EXPLAIN ANALYZE with only a fullsort group. */ SELECT EXPLAIN_ANALYZE_WITHOUT_MEMORY('select * from (select * from t order by a) s order by a, b limit 55');
SELECT JSONB_PRETTY(EXPLAIN_ANALYZE_INC_SORT_NODES_WITHOUT_MEMORY('select * from (select * from t order by a) s order by a, b limit 55'));
SELECT EXPLAIN_ANALYZE_INC_SORT_NODES_VERIFY_INVARIANTS('select * from (select * from t order by a) s order by a, b limit 55');
DELETE FROM x;
/* An initial small group followed by a large group. */ INSERT INTO x (x, x) SELECT (CASE WHEN x < 5 THEN x ELSE 9 END), x FROM x AS x;
ANALYZE x;
EXPLAIN (costs off) select * from (select * from t order by a) s order by a, b limit 70;
SELECT * FROM (SELECT * FROM x ORDER BY x NULLS LAST) AS x ORDER BY x NULLS LAST, x NULLS LAST LIMIT 70;
/* Checks case where we hit a group boundary at the last tuple of a batch. */ /* Because the full sort state is bounded, we scan 64 tuples (the mode */ /* transition point) but only retain 5. Thus when we transition modes, all */ /* tuples in the full sort state have different prefix keys. */ EXPLAIN (costs off) select * from (select * from t order by a) s order by a, b limit 5;
SELECT * FROM (SELECT * FROM x ORDER BY x NULLS LAST) AS x ORDER BY x NULLS LAST, x NULLS LAST LIMIT 5;
/* Test rescan. */ BEGIN;
SET LOCAL x = off /* We force the planner to choose a plan with incremental sort on the right side */ /* of a nested loop join node. That way we trigger the rescan code path. */;
SET LOCAL x = off;
SET LOCAL x = off;
SET LOCAL x = off;
EXPLAIN (costs off) select * from t left join (select * from (select * from t order by a) v order by a, b) s on s.a = t.a where t.a in (1, 2);
SELECT * FROM x LEFT JOIN (SELECT * FROM (SELECT * FROM x ORDER BY x NULLS LAST) AS x ORDER BY x NULLS LAST, x NULLS LAST) AS x ON x.x = x.x WHERE x.x IN (1, 2);
ROLLBACK;
/* Test EXPLAIN ANALYZE with both fullsort and presorted groups. */ SELECT EXPLAIN_ANALYZE_WITHOUT_MEMORY('select * from (select * from t order by a) s order by a, b limit 70');
SELECT JSONB_PRETTY(EXPLAIN_ANALYZE_INC_SORT_NODES_WITHOUT_MEMORY('select * from (select * from t order by a) s order by a, b limit 70'));
SELECT EXPLAIN_ANALYZE_INC_SORT_NODES_VERIFY_INVARIANTS('select * from (select * from t order by a) s order by a, b limit 70');
DELETE FROM x;
/* Small groups of 10 tuples each tested around each mode transition point. */ INSERT INTO x (x, x) SELECT x / 10, x FROM x AS x;
ANALYZE x;
EXPLAIN (costs off) select * from (select * from t order by a) s order by a, b limit 31;
SELECT * FROM (SELECT * FROM x ORDER BY x NULLS LAST) AS x ORDER BY x NULLS LAST, x NULLS LAST LIMIT 31;
EXPLAIN (costs off) select * from (select * from t order by a) s order by a, b limit 32;
SELECT * FROM (SELECT * FROM x ORDER BY x NULLS LAST) AS x ORDER BY x NULLS LAST, x NULLS LAST LIMIT 32;
EXPLAIN (costs off) select * from (select * from t order by a) s order by a, b limit 33;
SELECT * FROM (SELECT * FROM x ORDER BY x NULLS LAST) AS x ORDER BY x NULLS LAST, x NULLS LAST LIMIT 33;
EXPLAIN (costs off) select * from (select * from t order by a) s order by a, b limit 65;
SELECT * FROM (SELECT * FROM x ORDER BY x NULLS LAST) AS x ORDER BY x NULLS LAST, x NULLS LAST LIMIT 65;
EXPLAIN (costs off) select * from (select * from t order by a) s order by a, b limit 66;
SELECT * FROM (SELECT * FROM x ORDER BY x NULLS LAST) AS x ORDER BY x NULLS LAST, x NULLS LAST LIMIT 66;
DELETE FROM x;
/* Small groups of only 1 tuple each tested around each mode transition point. */ INSERT INTO x (x, x) SELECT x, x FROM x AS x;
ANALYZE x;
EXPLAIN (costs off) select * from (select * from t order by a) s order by a, b limit 31;
SELECT * FROM (SELECT * FROM x ORDER BY x NULLS LAST) AS x ORDER BY x NULLS LAST, x NULLS LAST LIMIT 31;
EXPLAIN (costs off) select * from (select * from t order by a) s order by a, b limit 32;
SELECT * FROM (SELECT * FROM x ORDER BY x NULLS LAST) AS x ORDER BY x NULLS LAST, x NULLS LAST LIMIT 32;
EXPLAIN (costs off) select * from (select * from t order by a) s order by a, b limit 33;
SELECT * FROM (SELECT * FROM x ORDER BY x NULLS LAST) AS x ORDER BY x NULLS LAST, x NULLS LAST LIMIT 33;
EXPLAIN (costs off) select * from (select * from t order by a) s order by a, b limit 65;
SELECT * FROM (SELECT * FROM x ORDER BY x NULLS LAST) AS x ORDER BY x NULLS LAST, x NULLS LAST LIMIT 65;
EXPLAIN (costs off) select * from (select * from t order by a) s order by a, b limit 66;
SELECT * FROM (SELECT * FROM x ORDER BY x NULLS LAST) AS x ORDER BY x NULLS LAST, x NULLS LAST LIMIT 66;
DELETE FROM x;
DROP TABLE x;
SET x = '1kB' /* Incremental sort vs. parallel queries */;
SET x = '1kB';
SET x = 0;
SET x = 0;
SET x = 2;
CREATE TABLE x (x INT, x INT, x INT);
INSERT INTO x SELECT x % 10, x % 10, x FROM x AS x;
CREATE INDEX ON x(x NULLS LAST);
ANALYZE x;
SET x = off;
EXPLAIN (costs off) select a,b,sum(c) from t group by 1,2 order by 1,2,3 limit 1;
SET x = on;
EXPLAIN (costs off) select a,b,sum(c) from t group by 1,2 order by 1,2,3 limit 1;
SET x = off /* Incremental sort vs. set operations with varno 0 */;
EXPLAIN (costs off) select * from t union select * from t order by 1,3;
/* Full sort, not just incremental sort can be pushed below a gather merge path */ /* by generate_useful_gather_paths. */ EXPLAIN (costs off) select distinct a,b from t;
DROP TABLE x;
SET x = off /* Sort pushdown can't go below where expressions are part of the rel target. */ /* In particular this is interesting for volatile expressions which have to */ /* go above joins since otherwise we'll incorrectly use expression evaluations */ /* across multiple rows. */;
SET x = off;
SET x = off;
SET x = 0;
SET x = 0;
SET x = 0;
SET x = 0;
/* Parallel sort below join. */ EXPLAIN (costs off) select distinct sub.unique1, stringu1 from tenk1, lateral (select tenk1.unique1 from generate_series(1, 1000)) as sub;
EXPLAIN (costs off) select sub.unique1, stringu1 from tenk1, lateral (select tenk1.unique1 from generate_series(1, 1000)) as sub order by 1, 2;
/* Parallel sort but with expression that can be safely generated at the base rel. */ EXPLAIN (costs off) select distinct sub.unique1, md5(stringu1) from tenk1, lateral (select tenk1.unique1 from generate_series(1, 1000)) as sub;
EXPLAIN (costs off) select sub.unique1, md5(stringu1) from tenk1, lateral (select tenk1.unique1 from generate_series(1, 1000)) as sub order by 1, 2;
/* Parallel sort with an aggregate that can be safely generated in parallel, */ /* but we can't sort by partial aggregate values. */ EXPLAIN (costs off) select count(*) from tenk1 t1 join tenk1 t2 on t1.unique1 = t2.unique2 join tenk1 t3 on t2.unique1 = t3.unique1 order by count(*);
/* Parallel sort but with expression (correlated subquery) that */ /* is prohibited in parallel plans. */ EXPLAIN (costs off) select distinct   unique1,   (select t.unique1 from tenk1 where tenk1.unique1 = t.unique1) from tenk1 t, generate_series(1, 1000);
EXPLAIN (costs off) select   unique1,   (select t.unique1 from tenk1 where tenk1.unique1 = t.unique1) from tenk1 t, generate_series(1, 1000) order by 1, 2;
/* Parallel sort but with expression not available until the upper rel. */ EXPLAIN (costs off) select distinct sub.unique1, stringu1 || random()::text from tenk1, lateral (select tenk1.unique1 from generate_series(1, 1000)) as sub;
EXPLAIN (costs off) select sub.unique1, stringu1 || random()::text from tenk1, lateral (select tenk1.unique1 from generate_series(1, 1000)) as sub order by 1, 2;
RESET enable_hashagg;
RESET enable_seqscan;
RESET enable_incremental_sort;
RESET parallel_tuple_cost;
RESET parallel_setup_cost;
RESET min_parallel_table_scan_size;
RESET min_parallel_index_scan_size;
/* Ensure incremental sorts work for amcanorderbyop type indexes */ CREATE TABLE x (x point, x INT);
CREATE INDEX x ON x USING gist(x NULLS LAST);
/* Ensure we get an incremental sort plan for both of the following queries */ EXPLAIN (costs off) select a, b, a <-> point(5, 5) dist from point_table order by dist, b limit 1;
EXPLAIN (costs off) select a, b, a <-> point(5, 5) dist from point_table order by dist, b desc limit 1;
/* Ensure we get an incremental sort on the outer side of the mergejoin */ EXPLAIN (costs off) select * from   (select * from tenk1 order by four) t1 join tenk1 t2 on t1.four = t2.four and t1.two = t2.two order by t1.four, t1.two limit 1;
/* Creating an index on a partitioned table makes the partitions */ /* automatically get the index */ CREATE TABLE x (x INT, x INT, x TEXT) WITH (PARTITIONED_BY=RANGE(x));
/* relhassubclass of a partitioned index is false before creating any partition. */ /* It will be set after the first partition is created. */ CREATE INDEX x ON x(x NULLS LAST);
SELECT x FROM x WHERE x = 'idxpart_idx';
/* Check that partitioned indexes are present in pg_indexes. */ SELECT x FROM x WHERE x LIKE 'idxpart_idx%';
DROP INDEX x;
CREATE TABLE x PARTITION OF x FOR VALUES FROM (0) TO (10);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (10) TO (100) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (0) TO (100);
SELECT x FROM x WHERE x = 'idxpart_idx';
DROP INDEX x;
CREATE INDEX ON x(x NULLS LAST);
SELECT x, x, x, CAST(x AS REGCLASS) FROM x LEFT JOIN x AS x ON (x = x) LEFT JOIN x ON (x.x = x) WHERE x LIKE 'idxpart%' ORDER BY x NULLS LAST;
DROP TABLE x;
/* Some unsupported features */ CREATE TABLE x (x INT, x INT, x TEXT) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (0) TO (10);
CREATE INDEX CONCURRENTLY ON x(x NULLS LAST);
DROP TABLE x;
/* Verify bugfix with query on indexed partitioned table with no partitions */ /* https://postgr.es/m/20180124162006.pmapfiznhgngwtjf@alvherre.pgsql */ CREATE TABLE x (x INT) WITH (PARTITIONED_BY=RANGE(x));
CREATE INDEX ON x(x NULLS LAST);
CREATE TABLE x (x INT);
SELECT x FROM x AS x LEFT OUTER JOIN x AS x ON (x = x);
/* Verify bugfix with index rewrite on ALTER TABLE / SET DATA TYPE */ /* https://postgr.es/m/CAKcux6mxNCGsgATwf5CGMF8g4WSupCXicCVMeKUTuWbyxHOMsQ@mail.gmail.com */ CREATE TABLE x (x INT, x TEXT, x INT) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (MINVALUE) TO (MAXVALUE);
CREATE INDEX x ON x(x NULLS LAST, x NULLS LAST, x NULLS LAST);
INSERT INTO x (x, x, x) SELECT x, x, x FROM x AS x;
ALTER TABLE x ALTER COLUMN x SET DATA TYPE DECIMAL;
DROP TABLE x;
/* If a table without index is attached as partition to a table with */ /* an index, the index is automatically created */ CREATE TABLE x (x INT, x INT, x TEXT) WITH (PARTITIONED_BY=RANGE(x));
CREATE INDEX x ON x(x NULLS LAST);
CREATE INDEX x ON x(x NULLS LAST, x NULLS LAST);
CREATE TABLE x (LIKE x);
CREATE INDEX x ON x(x NULLS LAST);
alter table idxpart_c attach partition idxpart1_c for values from (10) to (20);
alter index idxpart_c attach partition idxpart1_c;
SELECT x, x FROM x WHERE x IN ('idxpart_c', 'idxpart1_c') ORDER BY x NULLS LAST;
alter table idxpart_c detach partition idxpart1_c;
DROP TABLE x;
/* If a partition already has an index, don't create a duplicative one */ CREATE TABLE x (x INT, x INT) WITH (PARTITIONED_BY=RANGE(x, x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (0, 0) TO (10, 10);
CREATE INDEX ON x(x NULLS LAST, x NULLS LAST);
CREATE INDEX ON x(x NULLS LAST, x NULLS LAST);
DROP TABLE x;
/* DROP behavior for partitioned indexes */ CREATE TABLE x (x INT) WITH (PARTITIONED_BY=RANGE(x));
CREATE INDEX ON x(x NULLS LAST);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (0) TO (10);
DROP INDEX x;
/* no way */ DROP INDEX CONCURRENTLY x;
/* unsupported */ DROP INDEX x;
/* both indexes go away */ SELECT x, x FROM x WHERE x LIKE 'idxpart%' ORDER BY x NULLS LAST;
CREATE INDEX ON x(x NULLS LAST);
DROP TABLE x;
/* the index on partition goes away too */ SELECT x, x FROM x WHERE x LIKE 'idxpart%' ORDER BY x NULLS LAST;
DROP TABLE x;
/* DROP behavior with temporary partitioned indexes */ CREATE TEMPORARY TABLE x (x INT) WITH (PARTITIONED_BY=RANGE(x));
CREATE INDEX ON x(x NULLS LAST);
CREATE TEMPORARY TABLE x PARTITION OF x FOR VALUES FROM (0) TO (10);
DROP INDEX x;
/* error */ /* non-concurrent drop is enforced here, so it is a valid case. */ DROP INDEX CONCURRENTLY x;
SELECT x, x FROM x WHERE x LIKE 'idxpart_temp%' ORDER BY x NULLS LAST;
DROP TABLE x;
/* ALTER INDEX .. ATTACH, error cases */ CREATE TABLE x (x INT, x INT) WITH (PARTITIONED_BY=RANGE(x, x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (0, 0) TO (10, 10);
CREATE INDEX x ON x(x NULLS LAST, x NULLS LAST);
CREATE INDEX x ON x(x NULLS LAST, x NULLS LAST);
CREATE INDEX x ON x USING hash(x NULLS LAST);
CREATE INDEX x ON x(x NULLS LAST, x NULLS LAST) WHERE x > 10;
alter index idxpart attach partition idxpart1;
alter index idxpart_a_b_idx attach partition idxpart1;
alter index idxpart_a_b_idx attach partition idxpart_a_b_idx;
alter index idxpart_a_b_idx attach partition idxpart1_b_idx;
alter index idxpart_a_b_idx attach partition idxpart1_tst1;
alter index idxpart_a_b_idx attach partition idxpart1_tst2;
alter index idxpart_a_b_idx attach partition idxpart1_tst3;
/* OK */ alter index idxpart_a_b_idx attach partition idxpart1_a_b_idx;
alter index idxpart_a_b_idx attach partition idxpart1_a_b_idx;
/* quiet */ /* reject dupe */ CREATE INDEX x ON x(x NULLS LAST, x NULLS LAST);
alter index idxpart_a_b_idx attach partition idxpart1_2_a_b;
DROP TABLE x;
/* make sure everything's gone */ SELECT CAST(x AS REGCLASS), CAST(x AS REGCLASS) FROM x WHERE CAST(CAST(x AS REGCLASS) AS TEXT) LIKE 'idxpart%';
/* Don't auto-attach incompatible indexes */ CREATE TABLE x (x INT, x INT) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x (x INT, x INT);
CREATE INDEX ON x USING hash(x NULLS LAST);
CREATE INDEX ON x(x NULLS LAST) WHERE x > 1;
CREATE INDEX ON x((x + 0) NULLS LAST);
CREATE INDEX ON x(x NULLS LAST, x NULLS LAST);
CREATE INDEX ON x(x NULLS LAST);
alter table idxpart attach partition idxpart1 for values from (0) to (1000);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (0) TO (100);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (100) TO (1000) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (100) TO (200);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (200) TO (300);
CREATE INDEX ON x(x NULLS LAST);
CREATE INDEX ON x(x NULLS LAST);
alter index idxpart2_a_idx attach partition idxpart22_a_idx;
SELECT CAST(x AS REGCLASS), CAST(x AS REGCLASS), CAST(x AS REGCLASS) FROM x AS x LEFT JOIN x AS x ON (x.x = x.x) WHERE CAST(CAST(x AS REGCLASS) AS TEXT) LIKE 'idxpart%' ORDER BY CAST(CAST(x AS REGCLASS) AS TEXT) COLLATE "x" NULLS LAST;
/* attaching idxpart22 is not enough to set idxpart22_a_idx valid ... */ alter index idxpart2_a_idx attach partition idxpart22_a_idx;
alter index idxpart2_a_idx attach partition idxpart21_a_idx;
/* When a table is attached a partition and it already has an index, a */ /* duplicate index should not get created, but rather the index becomes */ /* attached to the parent's index. */ CREATE TABLE x (x INT, x INT, x TEXT, x BOOLEAN) WITH (PARTITIONED_BY=RANGE(x));
CREATE INDEX x ON x(x NULLS LAST);
CREATE INDEX x ON x(x NULLS LAST, x NULLS LAST);
CREATE TABLE x (LIKE x INCLUDING INDEXES);
alter table idxpart attach partition idxpart1 for values from (0) to (10);
/* While here, also check matching when creating an index after the fact. */ CREATE INDEX ON x((x + x) NULLS LAST) WHERE x = TRUE;
CREATE INDEX x ON x((x + x) NULLS LAST) WHERE x = TRUE;
DROP TABLE x;
/* Verify that attaching an invalid index does not mark the parent index valid. */ /* On the other hand, attaching a valid index marks not only its direct */ /* ancestor valid, but also any indirect ancestor that was only missing the one */ /* that was just made valid */ CREATE TABLE x (x INT, x INT) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (1) TO (1000) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (1) TO (100);
/* this results in two invalid indexes: */ SELECT x, x FROM x JOIN x ON x = x WHERE x LIKE 'idxpart%' ORDER BY x NULLS LAST;
/* idxpart1_a_idx is not valid, so idxpart_a_idx should not become valid: */ alter index idxpart_a_idx attach partition idxpart1_a_idx;
SELECT x, x FROM x JOIN x ON x = x WHERE x LIKE 'idxpart%' ORDER BY x NULLS LAST;
/* after creating and attaching this, both idxpart1_a_idx and idxpart_a_idx */ /* should become valid */ CREATE INDEX ON x(x NULLS LAST);
alter index idxpart1_a_idx attach partition idxpart11_a_idx;
SELECT x, x FROM x JOIN x ON x = x WHERE x LIKE 'idxpart%' ORDER BY x NULLS LAST;
DROP TABLE x;
/* verify dependency handling during ALTER TABLE DETACH PARTITION */ CREATE TABLE x (x INT) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x (LIKE x);
CREATE INDEX ON x(x NULLS LAST);
CREATE INDEX ON x(x NULLS LAST);
CREATE TABLE x (LIKE x);
alter table idxpart attach partition idxpart1 for values from (0000) to (1000);
alter table idxpart attach partition idxpart2 for values from (1000) to (2000);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (2000) TO (3000);
SELECT x, x FROM x WHERE x LIKE 'idxpart%' ORDER BY x NULLS LAST;
/* a) after detaching partitions, the indexes can be dropped independently */ alter table idxpart detach partition idxpart1;
alter table idxpart detach partition idxpart2;
alter table idxpart detach partition idxpart3;
DROP INDEX x;
DROP INDEX x;
DROP INDEX x;
SELECT x, x FROM x WHERE x LIKE 'idxpart%' ORDER BY x NULLS LAST;
SELECT x, x FROM x WHERE x LIKE 'idxpart%' ORDER BY x NULLS LAST;
CREATE TABLE x (x INT) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x (LIKE x);
CREATE INDEX ON x(x NULLS LAST);
CREATE INDEX ON x(x NULLS LAST);
CREATE TABLE x (LIKE x);
alter table idxpart attach partition idxpart1 for values from (0000) to (1000);
alter table idxpart attach partition idxpart2 for values from (1000) to (2000);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (2000) TO (3000);
/* b) after detaching, dropping the index on parent does not remove the others */ SELECT x, x FROM x WHERE x LIKE 'idxpart%' ORDER BY x NULLS LAST;
alter table idxpart detach partition idxpart1;
alter table idxpart detach partition idxpart2;
alter table idxpart detach partition idxpart3;
DROP INDEX x;
SELECT x, x FROM x WHERE x LIKE 'idxpart%' ORDER BY x NULLS LAST;
SELECT x, x FROM x WHERE x LIKE 'idxpart%' ORDER BY x NULLS LAST;
CREATE TABLE x (x INT, x INT, x INT) WITH (PARTITIONED_BY=RANGE(x));
CREATE INDEX ON x(x NULLS LAST);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (0) TO (250);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (250) TO (500);
alter table idxpart detach partition idxpart2;
/* Verify that expression indexes inherit correctly */ CREATE TABLE x (x INT, x INT) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x (LIKE x);
CREATE INDEX ON x((x + x) NULLS LAST);
CREATE INDEX ON x((x + x) NULLS LAST);
CREATE TABLE x (LIKE x);
alter table idxpart attach partition idxpart1 for values from (0000) to (1000);
alter table idxpart attach partition idxpart2 for values from (1000) to (2000);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (2000) TO (3000);
SELECT x AS x, CAST(x AS REGCLASS) AS x, x AS x FROM x JOIN x ON x = x, LATERAL PG_GET_INDEXDEF(x.x) WHERE x IN ('i', 'I') AND x LIKE 'idxpart%' ORDER BY x NULLS LAST;
DROP TABLE x;
/* Verify behavior for collation (mis)matches */ CREATE TABLE x (x TEXT) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x (LIKE x);
CREATE TABLE x (LIKE x);
CREATE INDEX ON x(x COLLATE "x" NULLS LAST);
CREATE INDEX ON x(x NULLS LAST);
CREATE INDEX ON x(x COLLATE "x" NULLS LAST);
alter table idxpart attach partition idxpart1 for values from ('aaa') to ('bbb');
alter table idxpart attach partition idxpart2 for values from ('bbb') to ('ccc');
CREATE TABLE x PARTITION OF x FOR VALUES FROM ('ccc') TO ('ddd');
CREATE INDEX ON x(x COLLATE "x" NULLS LAST);
CREATE TABLE x PARTITION OF x FOR VALUES FROM ('ddd') TO ('eee');
SELECT x AS x, CAST(x AS REGCLASS) AS x, x AS x FROM x LEFT JOIN x ON x = x, LATERAL PG_GET_INDEXDEF(x.x) WHERE x IN ('i', 'I') AND x LIKE 'idxpart%' ORDER BY x NULLS LAST;
DROP TABLE x;
/* Verify behavior for opclass (mis)matches */ CREATE TABLE x (x TEXT) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x (LIKE x);
CREATE TABLE x (LIKE x);
CREATE INDEX ON x(x NULLS LAST);
alter table idxpart attach partition idxpart1 for values from ('aaa') to ('bbb');
alter table idxpart attach partition idxpart2 for values from ('bbb') to ('ccc');
CREATE TABLE x PARTITION OF x FOR VALUES FROM ('ccc') TO ('ddd');
CREATE INDEX ON x(x x NULLS LAST);
CREATE TABLE x PARTITION OF x FOR VALUES FROM ('ddd') TO ('eee');
/* must *not* have attached the index we created on idxpart2 */ SELECT x AS x, CAST(x AS REGCLASS) AS x, x AS x FROM x LEFT JOIN x ON x = x, LATERAL PG_GET_INDEXDEF(x.x) WHERE x IN ('i', 'I') AND x LIKE 'idxpart%' ORDER BY x NULLS LAST;
DROP INDEX x;
/* must reject */ alter index idxpart_a_idx attach partition idxpart2_a_idx;
DROP TABLE x;
/* Verify that attaching indexes maps attribute numbers correctly */ CREATE TABLE x (x INT, x INT, x INT, x INT) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x (x INT, x INT, x INT, x INT, x INT);
ALTER TABLE x DROP COLUMN x, DROP COLUMN x;
ALTER TABLE x DROP COLUMN x, DROP COLUMN x, DROP COLUMN x;
alter table idxpart attach partition idxpart1 for values from (0) to (1000);
CREATE INDEX x ON x(x NULLS LAST, x NULLS LAST);
CREATE INDEX x ON x(x NULLS LAST);
CREATE INDEX x ON x((x + x) NULLS LAST) WHERE x > 1;
CREATE INDEX x ON x((x + x) NULLS LAST) WHERE x > 1;
CREATE INDEX x ON x((x + x) NULLS LAST) WHERE x > 1;
alter index idxpart_1_idx attach partition idxpart1_1b_idx;
/* fail */ alter index idxpart_1_idx attach partition idxpart1_1_idx;
alter index idxpart_2_idx attach partition idxpart1_2b_idx;
/* fail */ alter index idxpart_2_idx attach partition idxpart1_2c_idx;
/* fail */ alter index idxpart_2_idx attach partition idxpart1_2_idx;
/* ok */ SELECT x AS x, CAST(x AS REGCLASS) AS x, x AS x FROM x LEFT JOIN x ON x = x, LATERAL PG_GET_INDEXDEF(x.x) WHERE x IN ('i', 'I') AND x LIKE 'idxpart%' ORDER BY x NULLS LAST;
DROP TABLE x;
/* Make sure the partition columns are mapped correctly */ CREATE TABLE x (x INT, x INT, x TEXT) WITH (PARTITIONED_BY=RANGE(x));
CREATE INDEX x ON x(x NULLS LAST);
CREATE INDEX x ON x(x NULLS LAST, x NULLS LAST);
CREATE TABLE x (x TEXT, x INT, x INT);
alter table idxpart attach partition idxpart1 for values from (0) to (10);
CREATE TABLE x (x TEXT, x INT, x INT);
CREATE INDEX ON x(x NULLS LAST);
CREATE INDEX ON x(x NULLS LAST, x NULLS LAST);
alter table idxpart attach partition idxpart2 for values from (10) to (20);
SELECT x.x, PG_GET_INDEXDEF(x) FROM x AS x JOIN x AS x ON x.x = x.x WHERE CAST(CAST(x AS REGCLASS) AS TEXT) LIKE 'idxpart%' ORDER BY CAST(CAST(x AS REGCLASS) AS TEXT) COLLATE "x" NULLS LAST;
DROP TABLE x;
/* Verify that columns are mapped correctly in expression indexes */ CREATE TABLE x (x INT, x INT, x INT, x INT) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x (x INT, x INT, x INT, x INT);
CREATE TABLE x (x INT, x INT, x INT, x INT);
ALTER TABLE x DROP COLUMN x, DROP COLUMN x;
ALTER TABLE x DROP COLUMN x, DROP COLUMN x;
ALTER TABLE x DROP COLUMN x, DROP COLUMN x;
CREATE INDEX ON x(ABS(x) NULLS LAST);
alter table idxpart attach partition idxpart2 for values from (0) to (1);
CREATE INDEX ON x(ABS(x) NULLS LAST);
CREATE INDEX ON x((x + 1) NULLS LAST);
alter table idxpart attach partition idxpart1 for values from (1) to (2);
SELECT x.x, PG_GET_INDEXDEF(x) FROM x AS x JOIN x AS x ON x.x = x.x WHERE CAST(CAST(x AS REGCLASS) AS TEXT) LIKE 'idxpart%' ORDER BY CAST(CAST(x AS REGCLASS) AS TEXT) COLLATE "x" NULLS LAST;
DROP TABLE x;
/* Verify that columns are mapped correctly for WHERE in a partial index */ CREATE TABLE x (x INT, x INT, x INT, x INT) WITH (PARTITIONED_BY=RANGE(x));
ALTER TABLE x DROP COLUMN x, DROP COLUMN x;
CREATE TABLE x (x INT, x INT, x INT, x INT, x INT, x INT);
ALTER TABLE x DROP COLUMN x, DROP COLUMN x, DROP COLUMN x, DROP COLUMN x;
alter table idxpart attach partition idxpart1 for values from (0) to (1000);
CREATE TABLE x (x INT, x INT, x INT, x INT);
CREATE INDEX ON x(x NULLS LAST) WHERE x > 1000;
ALTER TABLE x DROP COLUMN x, DROP COLUMN x;
alter table idxpart attach partition idxpart2 for values from (1000) to (2000);
CREATE INDEX ON x(x NULLS LAST) WHERE x > 1000;
SELECT x.x, PG_GET_INDEXDEF(x) FROM x AS x JOIN x AS x ON x.x = x.x WHERE CAST(CAST(x AS REGCLASS) AS TEXT) LIKE 'idxpart%' ORDER BY CAST(CAST(x AS REGCLASS) AS TEXT) COLLATE "x" NULLS LAST;
DROP TABLE x;
/* Column number mapping: dropped columns in the partition */ CREATE TABLE x (x INT, x INT, x INT, x INT);
ALTER TABLE x DROP COLUMN x;
ALTER TABLE x DROP COLUMN x;
ALTER TABLE x DROP COLUMN x;
CREATE INDEX ON x(x NULLS LAST);
CREATE TABLE x (x INT) WITH (PARTITIONED_BY=RANGE(x));
CREATE INDEX ON x(x NULLS LAST);
alter table idxpart attach partition idxpart1 for values from (0) to (1000);
DROP TABLE x;
/* Column number mapping: dropped columns in the parent table */ CREATE TABLE x (x INT, x INT, x INT, x INT) WITH (PARTITIONED_BY=RANGE(x));
ALTER TABLE x DROP COLUMN x;
ALTER TABLE x DROP COLUMN x;
ALTER TABLE x DROP COLUMN x;
CREATE TABLE x (x INT);
CREATE INDEX ON x(x NULLS LAST);
CREATE INDEX ON x(x NULLS LAST);
alter table idxpart attach partition idxpart1 for values from (0) to (1000);
DROP TABLE x;
/* Constraint-related indexes */ /* Verify that it works to add primary key / unique to partitioned tables */ CREATE TABLE x (x INT PRIMARY KEY, x INT) WITH (PARTITIONED_BY=RANGE(x));
DROP TABLE x;
/* primary key on child is okay if there's no PK in the parent, though */ CREATE TABLE x (x INT) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x (x PRIMARY KEY) FOR VALUES FROM (0) TO (100);
/* Failing to use the full partition key is not allowed */ CREATE TABLE x (x INT UNIQUE, x INT) WITH (PARTITIONED_BY=RANGE(x, x));
CREATE TABLE x (x INT, x INT UNIQUE) WITH (PARTITIONED_BY=RANGE(x, x));
CREATE TABLE x (x INT PRIMARY KEY, x INT) WITH (PARTITIONED_BY=RANGE(x, x));
CREATE TABLE x (x INT, x INT PRIMARY KEY) WITH (PARTITIONED_BY=RANGE(x, x));
/* OK if you use them in some other order */ CREATE TABLE x (x INT, x INT, x TEXT, PRIMARY KEY (x NULLS LAST, x NULLS LAST, x NULLS LAST)) WITH (PARTITIONED_BY=RANGE(x, x, x));
DROP TABLE x;
DROP TABLE x;
DROP TABLE x;
DROP TABLE x;
DROP TABLE x;
DROP TABLE x;
/* no expressions in partition key for PK/UNIQUE */ CREATE TABLE x (x INT PRIMARY KEY, x INT) WITH (PARTITIONED_BY=RANGE((x + x)));
CREATE TABLE x (x INT UNIQUE, x INT) WITH (PARTITIONED_BY=RANGE((x + x)));
/* use ALTER TABLE to add a primary key */ CREATE TABLE x (x INT, x INT, x TEXT) WITH (PARTITIONED_BY=RANGE(x, x));
ALTER TABLE x ADD PRIMARY KEY (x NULLS LAST);
ALTER TABLE x ADD PRIMARY KEY (x NULLS LAST, x NULLS LAST) /* not an incomplete one though */;
/* use ALTER TABLE to add a unique constraint */ CREATE TABLE x (x INT, x INT) WITH (PARTITIONED_BY=RANGE(x, x));
ALTER TABLE x ADD UNIQUE (x);
ALTER TABLE x ADD UNIQUE (x, x) /* not an incomplete one though */;
/* Exclusion constraints can be added if partitioning by their equal column */ CREATE TABLE x (x INT4RANGE, x INT4RANGE) WITH (PARTITIONED_BY=RANGE(x));
DROP TABLE x;
/* OK more than one equal column */ CREATE TABLE x (x INT4RANGE, x INT4RANGE) WITH (PARTITIONED_BY=RANGE(x, x));
DROP TABLE x;
/* OK with more than one equal column: constraint is a proper superset of partition key */ CREATE TABLE x (x INT4RANGE, x INT4RANGE) WITH (PARTITIONED_BY=RANGE(x));
DROP TABLE x;
/* Not OK more than one equal column: partition keys are a proper superset of constraint */ CREATE TABLE x (x INT4RANGE, x INT4RANGE) WITH (PARTITIONED_BY=RANGE(x, x));
DROP TABLE x;
/* Not OK with just -|- */ CREATE TABLE x (x INT4RANGE, x INT4RANGE) WITH (PARTITIONED_BY=RANGE(x, x));
DROP TABLE x;
/* OK with equals and &&, and equals is the partition key */ CREATE TABLE x (x INT4RANGE, x INT4RANGE) WITH (PARTITIONED_BY=RANGE(x));
DROP TABLE x;
/* Not OK with equals and &&, and equals is not the partition key */ CREATE TABLE x (x INT4RANGE, x INT4RANGE, x INT4RANGE) WITH (PARTITIONED_BY=RANGE(x));
DROP TABLE x;
/* OK more than one equal column and a && column */ CREATE TABLE x (x INT4RANGE, x INT4RANGE, x INT4RANGE) WITH (PARTITIONED_BY=RANGE(x, x));
DROP TABLE x;
/* When (sub)partitions are created, they also contain the constraint */ CREATE TABLE x (x INT, x INT, PRIMARY KEY (x NULLS LAST, x NULLS LAST)) WITH (PARTITIONED_BY=RANGE(x, x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (1, 1) TO (10, 10);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (10, 10) TO (20, 20) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (10) TO (15);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (15) TO (20);
CREATE TABLE x (x INT NOT NULL, x INT NOT NULL);
alter table idxpart attach partition idxpart3 for values from (20, 20) to (30, 30);
SELECT x, x, CAST(x AS REGCLASS), CAST(x AS REGCLASS), x FROM x WHERE CAST(CAST(x AS REGCLASS) AS TEXT) LIKE 'idxpart%' ORDER BY CAST(CAST(x AS REGCLASS) AS TEXT) NULLS LAST, x NULLS LAST;
DROP TABLE x;
/* Verify that multi-layer partitioning honors the requirement that all */ /* columns in the partition key must appear in primary/unique key */ CREATE TABLE x (x INT, x INT, PRIMARY KEY (x NULLS LAST)) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (0) TO (1000) WITH (PARTITIONED_BY=RANGE(x));
/* fail */ DROP TABLE x;
/* Ditto for the ATTACH PARTITION case */ CREATE TABLE x (x INT UNIQUE, x INT) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x (x INT NOT NULL, x INT, UNIQUE (x, x)) WITH (PARTITIONED_BY=RANGE(x, x));
alter table idxpart attach partition idxpart1 for values from (1) to (1000);
/* Multi-layer partitioning works correctly in this case: */ CREATE TABLE x (x INT, x INT, PRIMARY KEY (x NULLS LAST, x NULLS LAST)) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (0) TO (1000) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (0) TO (1000);
SELECT x, x, CAST(x AS REGCLASS), CAST(x AS REGCLASS), x FROM x WHERE CAST(CAST(x AS REGCLASS) AS TEXT) LIKE 'idxpart%' ORDER BY CAST(CAST(x AS REGCLASS) AS TEXT) NULLS LAST, x NULLS LAST;
DROP TABLE x;
CREATE TABLE x PARTITION OF x (x) FOR VALUES WITH (MODULUS 2, REMAINDER 0);
CREATE TABLE x PARTITION OF x (x) FOR VALUES WITH (MODULUS 2, REMAINDER 1);
ALTER TABLE x ADD PRIMARY KEY (x NULLS LAST);
ALTER TABLE x ADD PRIMARY KEY (x NULLS LAST);
SELECT CAST(x AS REGCLASS), CAST(x AS REGCLASS), CAST(x AS REGCLASS), x, x, x, x, x, x FROM x AS x LEFT JOIN x AS x ON (x.x = x.x) LEFT JOIN x AS x ON (x.x = x.x) WHERE CAST(CAST(x AS REGCLASS) AS TEXT) LIKE 'idxpart%' ORDER BY CAST(CAST(x AS REGCLASS) AS TEXT) COLLATE "x" NULLS LAST;
DROP INDEX x;
/* fail */ DROP INDEX x;
ALTER TABLE x DROP CONSTRAINT x /* fail */;
ALTER TABLE x DROP CONSTRAINT x /* fail */;
ALTER TABLE x DROP CONSTRAINT x /* fail */;
/* ok */ SELECT CAST(x AS REGCLASS), CAST(x AS REGCLASS), CAST(x AS REGCLASS), x, x, x, x, x, x FROM x AS x LEFT JOIN x AS x ON (x.x = x.x) LEFT JOIN x AS x ON (x.x = x.x) WHERE CAST(CAST(x AS REGCLASS) AS TEXT) LIKE 'idxpart%' ORDER BY CAST(CAST(x AS REGCLASS) AS TEXT) COLLATE "x" NULLS LAST;
DROP TABLE x;
/* If the partition to be attached already has a primary key, fail if */ /* it doesn't match the parent's PK. */ CREATE TABLE x (x INT PRIMARY KEY, x INT, x VARCHAR(10)) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x (LIKE x);
ALTER TABLE x ADD PRIMARY KEY (x NULLS LAST, x NULLS LAST);
ALTER TABLE idxpart ATTACH PARTITION idxpart1 FOR VALUES FROM (100) TO (200);
/* Ditto if there is some distance between the PKs (subpartitioning) */ CREATE TABLE x (x INT, x INT, PRIMARY KEY (x NULLS LAST)) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x (x INT NOT NULL, x INT) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x (x INT NOT NULL, x INT PRIMARY KEY);
alter table idxpart1 attach partition idxpart11 for values from (0) to (1000);
alter table idxpart attach partition idxpart1 for values from (0) to (10000);
/* If a partitioned table has a constraint whose index is not valid, */ /* attaching a missing partition makes it valid. */ CREATE TABLE x (x INT) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x (LIKE x);
ALTER TABLE x ADD PRIMARY KEY (x NULLS LAST);
alter table idxpart attach partition idxpart0 for values from (0) to (1000);
ALTER TABLE ONLY x ADD PRIMARY KEY (x NULLS LAST);
SELECT CAST(x AS REGCLASS), CAST(x AS REGCLASS), CAST(x AS REGCLASS), x, x, x, x, x, x FROM x AS x LEFT JOIN x AS x ON (x.x = x.x) LEFT JOIN x AS x ON (x.x = x.x) WHERE CAST(CAST(x AS REGCLASS) AS TEXT) LIKE 'idxpart%' ORDER BY CAST(CAST(x AS REGCLASS) AS TEXT) COLLATE "x" NULLS LAST;
alter index idxpart_pkey attach partition idxpart0_pkey;
SELECT CAST(x AS REGCLASS), CAST(x AS REGCLASS), CAST(x AS REGCLASS), x, x, x, x, x, x FROM x AS x LEFT JOIN x AS x ON (x.x = x.x) LEFT JOIN x AS x ON (x.x = x.x) WHERE CAST(CAST(x AS REGCLASS) AS TEXT) LIKE 'idxpart%' ORDER BY CAST(CAST(x AS REGCLASS) AS TEXT) COLLATE "x" NULLS LAST;
DROP TABLE x;
/* Related to the above scenario: ADD PRIMARY KEY on the parent mustn't */ /* automatically propagate NOT NULL to child columns. */ CREATE TABLE x (x INT) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x (LIKE x);
ALTER TABLE x ADD UNIQUE (x);
alter table idxpart attach partition idxpart0 default;
ALTER TABLE ONLY x ADD PRIMARY KEY (x NULLS LAST);
ALTER TABLE x ALTER COLUMN x SET NOT NULL /* fail, no not-null constraint */;
ALTER TABLE ONLY x ADD PRIMARY KEY (x NULLS LAST);
/* now it works */ alter index idxpart_pkey attach partition idxpart0_a_key;
DROP TABLE x;
CREATE TABLE x (x INT NOT NULL, x INT);
CREATE UNIQUE INDEX ON x(x NULLS LAST);
ALTER TABLE x ADD PRIMARY KEY (x NULLS LAST);
alter table idxpart attach partition idxpart1 for values from (1) to (1000);
SELECT CAST(x AS REGCLASS), CAST(x AS REGCLASS), CAST(x AS REGCLASS), x, x, x, x, x, x FROM x AS x LEFT JOIN x AS x ON (x.x = x.x) LEFT JOIN x AS x ON (x.x = x.x) WHERE CAST(CAST(x AS REGCLASS) AS TEXT) LIKE 'idxpart%' ORDER BY CAST(CAST(x AS REGCLASS) AS TEXT) COLLATE "x" NULLS LAST;
DROP TABLE x;
/* Can't attach an index without a corresponding constraint */ CREATE TABLE x (x INT, x INT) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x (x INT NOT NULL, x INT);
CREATE UNIQUE INDEX ON x(x NULLS LAST);
alter table idxpart attach partition idxpart1 for values from (1) to (1000);
ALTER TABLE ONLY x ADD PRIMARY KEY (x NULLS LAST);
alter index idxpart_pkey attach partition idxpart1_a_idx;
/* fail */ DROP TABLE x;
/* Test that unique constraints are working */ CREATE TABLE x (x INT, x TEXT, PRIMARY KEY (x NULLS LAST, x NULLS LAST)) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (0) TO (100000);
CREATE TABLE x (x INT, LIKE x);
INSERT INTO x (x, x, x) VALUES (42, 572814, 'inserted first');
ALTER TABLE x DROP COLUMN x;
CREATE UNIQUE INDEX ON x(x NULLS LAST);
alter table idxpart attach partition idxpart2 for values from (100000) to (1000000);
INSERT INTO x VALUES (0, 'zero'), (42, 'life'), (POWER(2, 16), 'sixteen');
INSERT INTO x SELECT POWER(2, x), FORMAT('two to power of %s', x) FROM x AS x;
INSERT INTO x VALUES (16, 'sixteen');
INSERT INTO x (x, x) VALUES ('one', 142857), ('two', 285714);
INSERT INTO x SELECT x * 2, x || x FROM x WHERE x BETWEEN POWER(2, 16) AND POWER(2, 19);
INSERT INTO x VALUES (572814, 'five');
INSERT INTO x VALUES (857142, 'six');
SELECT CAST(x AS REGCLASS), * FROM x ORDER BY x NULLS LAST;
DROP TABLE x;
/* Test some other non-btree index types */ CREATE TABLE x (x INT, x TEXT, x ARRAY<INT>) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (0) TO (100000);
SET x = off;
CREATE INDEX x ON x USING brin(x NULLS LAST);
EXPLAIN (costs off) select * from idxpart where b = 'abcd';
DROP INDEX x;
CREATE INDEX x ON x USING spgist(x NULLS LAST);
EXPLAIN (costs off) select * from idxpart where b = 'abcd';
DROP INDEX x;
CREATE INDEX x ON x USING gin(x NULLS LAST);
EXPLAIN (costs off) select * from idxpart where c @> array[42];
DROP INDEX x;
RESET enable_seqscan;
DROP TABLE x;
/* intentionally leave some objects around */ CREATE TABLE x (x INT) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (0) TO (100);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (100) TO (1000) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (100) TO (200);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (200) TO (300);
CREATE INDEX ON x(x NULLS LAST);
alter index idxpart2_a_idx attach partition idxpart22_a_idx;
CREATE INDEX ON x(x NULLS LAST);
CREATE TABLE x (x INT, x INT, PRIMARY KEY (x NULLS LAST, x NULLS LAST)) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (0) TO (100);
CREATE TABLE x (x INT, x INT, x INT) WITH (PARTITIONED_BY=RANGE(x));
ALTER TABLE x DROP COLUMN x, DROP COLUMN x;
CREATE TABLE x PARTITION OF x FOR VALUES FROM (1000) TO (1200);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (1200) TO (1400);
alter table idxpart attach partition idxpart3 for values from (1000) to (2000);
SET x = regress_indexing;
CREATE TABLE x (x INT PRIMARY KEY) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (0) TO (1000);
CREATE TABLE x (x INT, x INT);
ALTER TABLE x DROP COLUMN x;
ALTER TABLE x ALTER COLUMN x SET NOT NULL;
alter table pk attach partition pk2 for values from (1000) to (2000);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (2000) TO (3000);
CREATE TABLE x (LIKE x);
alter table pk attach partition pk4 for values from (3000) to (4000);
CREATE TABLE x (LIKE x) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (4000) TO (4500);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (4500) TO (5000);
alter table pk attach partition pk5 for values from (4000) to (5000);
RESET search_path;
/* Test that covering partitioned indexes work in various cases */ CREATE TABLE x (x INT, x INT) WITH (PARTITIONED_BY=LIST(x));
CREATE UNIQUE INDEX ON x(x NULLS LAST) INCLUDE (x);
CREATE TABLE x PARTITION OF x FOR VALUES IN (1);
CREATE TABLE x PARTITION OF x FOR VALUES IN (2);
INSERT INTO x VALUES (1, 1);
INSERT INTO x VALUES (1, 1);
CREATE TABLE x (x INT, x INT, x INT);
ALTER TABLE x drop c;
alter table covidxpart attach partition covidxpart3 for values in (3);
INSERT INTO x VALUES (3, 1);
INSERT INTO x VALUES (3, 1);
CREATE TABLE x (x INT, x INT);
CREATE UNIQUE INDEX ON x(x NULLS LAST) INCLUDE (x);
CREATE UNIQUE INDEX ON x(x NULLS LAST);
alter table covidxpart attach partition covidxpart4 for values in (4);
INSERT INTO x VALUES (4, 1);
INSERT INTO x VALUES (4, 1);
CREATE UNIQUE INDEX ON x(x NULLS LAST) INCLUDE (x);
/* should fail */ /* check that detaching a partition also detaches the primary key constraint */ CREATE TABLE x (x INT PRIMARY KEY) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN (1);
ALTER TABLE x DROP CONSTRAINT x;
/* should fail */ alter table parted_pk_detach_test detach partition parted_pk_detach_test1;
ALTER TABLE x DROP CONSTRAINT x;
CREATE TABLE x (x INT UNIQUE) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN (1);
ALTER TABLE x DROP CONSTRAINT x;
/* should fail */ alter table parted_uniq_detach_test detach partition parted_uniq_detach_test1;
ALTER TABLE x DROP CONSTRAINT x;
/* check that dropping a column takes with it any partitioned indexes */ /* depending on it. */ CREATE TABLE x (x INT, x INT, x INT) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN (1) WITH (PARTITIONED_BY=LIST(x));
/* leave this partition without children. */ CREATE TABLE x PARTITION OF x FOR VALUES IN (2) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN (1);
CREATE INDEX ON x(x NULLS LAST);
CREATE INDEX ON x(x NULLS LAST);
CREATE INDEX ON x(x NULLS LAST, x NULLS LAST);
ALTER TABLE x DROP COLUMN x;
/* Check that invalid indexes are not selected when attaching a partition. */ CREATE TABLE x (x INT) WITH (PARTITIONED_BY=RANGE(x));
CREATE INDEX x ON x(x NULLS LAST);
CREATE TABLE x (x INT) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (0) TO (10);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (10) TO (20);
/* this creates new indexes for all the partitions of parted_inval_tab_1, */ /* discarding the invalid index created previously as what is chosen. */ alter table parted_inval_tab attach partition parted_inval_tab_1   for values from (1) to (100);
SELECT CAST(x AS REGCLASS), x, CAST(x AS REGCLASS), CAST(x AS REGCLASS) FROM x AS x LEFT JOIN x AS x ON (x.x = x.x) WHERE CAST(CAST(x AS REGCLASS) AS TEXT) LIKE 'parted_inval%' ORDER BY CAST(CAST(x AS REGCLASS) AS TEXT) COLLATE "x" NULLS LAST;
DROP TABLE x;
/* Check setup of indisvalid across a complex partition tree on index */ /* creation.  If one index in a partition index is invalid, so should its */ /* partitioned index. */ CREATE TABLE x (x INT, x INT) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (1) TO (10) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (10) TO (20) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (1) TO (5);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (5) TO (10);
/* create an invalid index on one of the partitions. */ INSERT INTO x VALUES (1, 0);
CREATE INDEX CONCURRENTLY x ON x((x / x) NULLS LAST);
/* The previous invalid index is selected, invalidating all the indexes up to */ /* the top-most parent. */ CREATE INDEX x ON x((x / x) NULLS LAST);
SELECT CAST(x AS REGCLASS), x, CAST(x AS REGCLASS), CAST(x AS REGCLASS) FROM x AS x LEFT JOIN x AS x ON (x.x = x.x) WHERE CAST(CAST(x AS REGCLASS) AS TEXT) LIKE 'parted_isvalid%' ORDER BY CAST(CAST(x AS REGCLASS) AS TEXT) COLLATE "x" NULLS LAST;
DROP TABLE x;
/* Check state of replica indexes when attaching a partition. */ BEGIN;
CREATE TABLE x (x INT NOT NULL) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (1) TO (10) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (1) TO (5);
/* This triggers an update of pg_index.indisreplident for parted_replica_idx. */ alter table only parted_replica_tab_1 replica identity   using index parted_replica_idx_1;
CREATE UNIQUE INDEX x ON x USING btree(x NULLS LAST);
SELECT CAST(x AS REGCLASS), x, x, CAST(x AS REGCLASS), CAST(x AS REGCLASS) FROM x AS x LEFT JOIN x AS x ON (x.x = x.x) WHERE CAST(CAST(x AS REGCLASS) AS TEXT) LIKE 'parted_replica%' ORDER BY CAST(CAST(x AS REGCLASS) AS TEXT) COLLATE "x" NULLS LAST;
/* parted_replica_idx is not valid yet here, because parted_replica_idx_1 */ /* is not valid. */ alter index parted_replica_idx ATTACH PARTITION parted_replica_idx_1;
SELECT CAST(x AS REGCLASS), x, x, CAST(x AS REGCLASS), CAST(x AS REGCLASS) FROM x AS x LEFT JOIN x AS x ON (x.x = x.x) WHERE CAST(CAST(x AS REGCLASS) AS TEXT) LIKE 'parted_replica%' ORDER BY CAST(CAST(x AS REGCLASS) AS TEXT) COLLATE "x" NULLS LAST;
/* parted_replica_idx becomes valid here. */ alter index parted_replica_idx_1 ATTACH PARTITION parted_replica_idx_11;
alter table only parted_replica_tab_1 replica identity   using index parted_replica_idx_1;
COMMIT;
SELECT CAST(x AS REGCLASS), x, x, CAST(x AS REGCLASS), CAST(x AS REGCLASS) FROM x AS x LEFT JOIN x AS x ON (x.x = x.x) WHERE CAST(CAST(x AS REGCLASS) AS TEXT) LIKE 'parted_replica%' ORDER BY CAST(CAST(x AS REGCLASS) AS TEXT) COLLATE "x" NULLS LAST;
DROP TABLE x;
/* test that indexing commands work with TOASTed values in pg_index */ CREATE TABLE x (x INT);
CREATE OR REPLACE FUNCTION x(x INT, x ARRAY<INT>) RETURNS BOOLEAN LANGUAGE sql IMMUTABLE AS $$ select true $$;
REINDEX index concurrently test_pg_index_toast_index;
DROP INDEX CONCURRENTLY x;
REINDEX index test_pg_index_toast_index;
DROP INDEX x;
DROP FUNCTION x;
DROP TABLE x;
/*  * 1.test CREATE INDEX  *  * Deliberately avoid dropping objects in this section, to get some pg_dump  * coverage.  */ /* Regular index with included columns */ CREATE TABLE x (x INT, x INT, x INT, x box);
INSERT INTO x SELECT x, 2 * x, 3 * x, BOX('4,4,4,4') FROM x AS x;
CREATE INDEX x ON x(x NULLS LAST, x NULLS LAST) INCLUDE (x, x);
/* duplicate column is pretty pointless, but we allow it anyway */ CREATE INDEX ON x(x NULLS LAST, x NULLS LAST) INCLUDE (x, x);
SELECT PG_GET_INDEXDEF(x.x) FROM x AS x JOIN x AS x ON x.x = x.x WHERE x.x = CAST('tbl_include_reg' AS REGCLASS) ORDER BY x.x NULLS LAST;
INSERT INTO x SELECT x, 2 * x, 3 * x, BOX('4,4,4,4') FROM x AS x;
CREATE UNIQUE INDEX x ON x USING btree(x NULLS LAST, x NULLS LAST) INCLUDE (x, x);
ALTER TABLE tbl_include_unique1 add UNIQUE USING INDEX tbl_include_unique1_idx_unique;
ALTER TABLE tbl_include_unique1 add UNIQUE (c1, c2) INCLUDE (c3, c4);
SELECT PG_GET_INDEXDEF(x.x) FROM x AS x JOIN x AS x ON x.x = x.x WHERE x.x = CAST('tbl_include_unique1' AS REGCLASS) ORDER BY x.x NULLS LAST;
/* Unique index and unique constraint. Both must fail. */ CREATE TABLE x (x INT, x INT, x INT, x box);
INSERT INTO x SELECT 1, 2, 3 * x, BOX('4,4,4,4') FROM x AS x;
CREATE UNIQUE INDEX x ON x USING btree(x NULLS LAST, x NULLS LAST) INCLUDE (x, x);
ALTER TABLE tbl_include_unique2 add UNIQUE (c1, c2) INCLUDE (c3, c4);
/* PK constraint */ CREATE TABLE x (x INT, x INT, x INT, x box);
INSERT INTO x SELECT 1, 2 * x, 3 * x, BOX('4,4,4,4') FROM x AS x;
ALTER TABLE tbl_include_pk add PRIMARY KEY (c1, c2) INCLUDE (c3, c4);
SELECT PG_GET_INDEXDEF(x.x) FROM x AS x JOIN x AS x ON x.x = x.x WHERE x.x = CAST('tbl_include_pk' AS REGCLASS) ORDER BY x.x NULLS LAST;
CREATE TABLE x (x INT, x INT, x INT, x box);
INSERT INTO x SELECT 1, 2 * x, 3 * x, BOX('4,4,4,4') FROM x AS x;
CREATE UNIQUE INDEX x ON x USING btree(x NULLS LAST, x NULLS LAST) INCLUDE (x, x);
ALTER TABLE tbl_include_box add PRIMARY KEY USING INDEX tbl_include_box_idx_unique;
SELECT PG_GET_INDEXDEF(x.x) FROM x AS x JOIN x AS x ON x.x = x.x WHERE x.x = CAST('tbl_include_box' AS REGCLASS) ORDER BY x.x NULLS LAST;
/* PK constraint. Must fail. */ CREATE TABLE x (x INT, x INT, x INT, x box);
INSERT INTO x SELECT 1, 2, 3 * x, BOX('4,4,4,4') FROM x AS x;
ALTER TABLE tbl_include_box_pk add PRIMARY KEY (c1, c2) INCLUDE (c3, c4);
/*  * 2. Test CREATE TABLE with constraint  */ CREATE TABLE x (x INT, x INT, x INT, x box, CONSTRAINT x UNIQUE (x, x), INCLUDE(x, x));
SELECT CAST(x AS REGCLASS), x, x, x, x, x, x FROM x WHERE x = CAST(CAST('tbl' AS REGCLASS) AS OID);
SELECT PG_GET_CONSTRAINTDEF(x), x, x FROM x WHERE x = CAST(CAST('tbl' AS REGCLASS) AS OID);
/* ensure that constraint works */ INSERT INTO x SELECT 1, 2, 3 * x, BOX('4,4,4,4') FROM x AS x;
DROP TABLE x;
CREATE TABLE x (x INT, x INT, x INT, x box, CONSTRAINT x PRIMARY KEY (x NULLS LAST, x NULLS LAST), INCLUDE(x, x));
SELECT CAST(x AS REGCLASS), x, x, x, x, x, x FROM x WHERE x = CAST(CAST('tbl' AS REGCLASS) AS OID);
SELECT PG_GET_CONSTRAINTDEF(x), x, x FROM x WHERE x = CAST(CAST('tbl' AS REGCLASS) AS OID) AND x = 'p';
/* ensure that constraint works */ INSERT INTO x SELECT 1, 2, 3 * x, BOX('4,4,4,4') FROM x AS x;
INSERT INTO x SELECT 1, NULL, 3 * x, BOX('4,4,4,4') FROM x AS x;
INSERT INTO x SELECT x, 2 * x, NULL, NULL FROM x AS x;
EXPLAIN (costs off) select * from tbl where (c1,c2,c3) < (2,5,1);
SELECT * FROM x WHERE (x, x, x) < (2, 5, 1);
SET x = off /* row comparison that compares high key at page boundary */;
EXPLAIN (costs off) select * from tbl where (c1,c2,c3) < (262,1,1) limit 1;
SELECT * FROM x WHERE (x, x, x) < (262, 1, 1) LIMIT 1;
DROP TABLE x;
RESET enable_seqscan;
SELECT CAST(x AS REGCLASS), x, x, x, x, x, x FROM x WHERE x = CAST(CAST('tbl' AS REGCLASS) AS OID);
SELECT PG_GET_CONSTRAINTDEF(x), x, x FROM x WHERE x = CAST(CAST('tbl' AS REGCLASS) AS OID);
/* ensure that constraint works */ INSERT INTO x SELECT 1, 2, 3 * x, BOX('4,4,4,4') FROM x AS x;
DROP TABLE x;
SELECT CAST(x AS REGCLASS), x, x, x, x, x, x FROM x WHERE x = CAST(CAST('tbl' AS REGCLASS) AS OID);
SELECT PG_GET_CONSTRAINTDEF(x), x, x FROM x WHERE x = CAST(CAST('tbl' AS REGCLASS) AS OID) AND x = 'p';
/* ensure that constraint works */ INSERT INTO x SELECT 1, 2, 3 * x, BOX('4,4,4,4') FROM x AS x;
INSERT INTO x SELECT 1, NULL, 3 * x, BOX('4,4,4,4') FROM x AS x;
INSERT INTO x SELECT x, 2 * x, NULL, NULL FROM x AS x;
DROP TABLE x;
SELECT CAST(x AS REGCLASS), x, x, x, x, x, x FROM x WHERE x = CAST(CAST('tbl' AS REGCLASS) AS OID);
SELECT PG_GET_CONSTRAINTDEF(x), x, x FROM x WHERE x = CAST(CAST('tbl' AS REGCLASS) AS OID);
/* ensure that constraint works */ INSERT INTO x SELECT 1, 2, 3 * x, BOX('4,4,4,4') FROM x AS x;
INSERT INTO x SELECT x, 2 * x, NULL, NULL FROM x AS x;
DROP TABLE x;
/*  * 3.0 Test ALTER TABLE DROP COLUMN.  * Any column deletion leads to index deletion.  */ CREATE TABLE x (x INT, x INT, x INT, x INT);
CREATE UNIQUE INDEX x ON x USING btree(x NULLS LAST, x NULLS LAST, x NULLS LAST, x NULLS LAST);
SELECT x FROM x WHERE x = 'tbl' ORDER BY x NULLS LAST;
ALTER TABLE x DROP COLUMN x;
SELECT x FROM x WHERE x = 'tbl' ORDER BY x NULLS LAST;
DROP TABLE x;
/*  * 3.1 Test ALTER TABLE DROP COLUMN.  * Included column deletion leads to the index deletion,  * AS well AS key columns deletion. It's explained in documentation.  */ CREATE TABLE x (x INT, x INT, x INT, x box);
CREATE UNIQUE INDEX x ON x USING btree(x NULLS LAST, x NULLS LAST) INCLUDE (x, x);
SELECT x FROM x WHERE x = 'tbl' ORDER BY x NULLS LAST;
ALTER TABLE x DROP COLUMN x;
SELECT x FROM x WHERE x = 'tbl' ORDER BY x NULLS LAST;
DROP TABLE x;
SELECT x FROM x WHERE x = 'tbl' ORDER BY x NULLS LAST;
ALTER TABLE x DROP COLUMN x;
SELECT x FROM x WHERE x = 'tbl' ORDER BY x NULLS LAST;
ALTER TABLE x DROP COLUMN x;
SELECT x FROM x WHERE x = 'tbl' ORDER BY x NULLS LAST;
DROP TABLE x;
/*  * 3.3 Test ALTER TABLE SET STATISTICS  */ CREATE TABLE x (x INT, x INT);
CREATE INDEX x ON x(x NULLS LAST, (x + 0) NULLS LAST) INCLUDE (x);
ALTER INDEX x ALTER COLUMN 1 DROP DEFAULT, SET STATISTICS 1000;
ALTER INDEX x ALTER COLUMN 2 DROP DEFAULT, SET STATISTICS 1000;
ALTER INDEX x ALTER COLUMN 3 DROP DEFAULT, SET STATISTICS 1000;
ALTER INDEX x ALTER COLUMN 4 DROP DEFAULT, SET STATISTICS 1000;
DROP TABLE x;
INSERT INTO x SELECT x, 2 * x, 3 * x, BOX('4,4,4,4') FROM x AS x;
CREATE UNIQUE INDEX CONCURRENTLY ON x(x NULLS LAST, x NULLS LAST) INCLUDE (x, x);
SELECT x FROM x WHERE x = 'tbl' ORDER BY x NULLS LAST;
DROP TABLE x;
SELECT x FROM x WHERE x = 'tbl' ORDER BY x NULLS LAST;
ALTER TABLE x DROP COLUMN x;
SELECT x FROM x WHERE x = 'tbl' ORDER BY x NULLS LAST;
REINDEX INDEX tbl_c1_c2_c3_c4_key;
SELECT x FROM x WHERE x = 'tbl' ORDER BY x NULLS LAST;
ALTER TABLE x DROP COLUMN x;
SELECT x FROM x WHERE x = 'tbl' ORDER BY x NULLS LAST;
DROP TABLE x;
/*  * 7. Check various AMs. All but btree, gist and spgist must fail.  */ CREATE TABLE x (x INT, x INT, x box, x box);
CREATE INDEX ON x USING brin(x NULLS LAST, x NULLS LAST) INCLUDE (x, x);
CREATE INDEX ON x USING gist(x NULLS LAST) INCLUDE (x, x);
CREATE INDEX ON x USING spgist(x NULLS LAST) INCLUDE (x);
CREATE INDEX ON x USING gin(x NULLS LAST, x NULLS LAST) INCLUDE (x, x);
CREATE INDEX ON x USING hash(x NULLS LAST, x NULLS LAST) INCLUDE (x, x);
CREATE INDEX ON x USING rtree(x NULLS LAST) INCLUDE (x, x);
CREATE INDEX ON x USING btree(x NULLS LAST, x NULLS LAST) INCLUDE (x, x);
DROP TABLE x;
/*  * 8. Update, delete values in indexed table.  */ CREATE TABLE x (x INT, x INT, x INT, x box);
INSERT INTO x SELECT x, 2 * x, 3 * x, BOX('4,4,4,4') FROM x AS x;
CREATE UNIQUE INDEX x ON x USING btree(x NULLS LAST, x NULLS LAST) INCLUDE (x, x);
UPDATE x SET x = 100 WHERE x = 2;
UPDATE x SET x = 1 WHERE x = 3;
/* should fail */ UPDATE x SET x = 2 WHERE x = 1;
UPDATE x SET x = 1;
DELETE FROM x WHERE x = 5 OR x = 12;
DROP TABLE x;
INSERT INTO x SELECT x, 2 * x, 3 * x, BOX('4,4,4,4') FROM x AS x;
ALTER TABLE x ALTER COLUMN x SET DATA TYPE BIGINT;
ALTER TABLE x ALTER COLUMN x SET DATA TYPE BIGINT;
/*  * 10. Test coverage for names stored as cstrings in indexes  */ CREATE TABLE x (x INT, x NAME, x DOUBLE);
CREATE INDEX x ON x(x NULLS LAST, x NULLS LAST) INCLUDE (x);
INSERT INTO x VALUES (1, 'two', 3.0);
VACUUM nametbl;
SET x = 0;
/* Ensure we get an index only scan plan */ EXPLAIN (COSTS OFF) SELECT c2, c1, c3 FROM nametbl WHERE c2 = 'two' AND c1 = 1;
/* Validate the results look sane */ SELECT x, x, x FROM x WHERE x = 'two' AND x = 1;
RESET enable_seqscan;
DROP TABLE x;
/*  * 1.1. test CREATE INDEX with buffered build  */ /* Regular index with included columns */ CREATE TABLE x (x INT, x INT, x INT, x box);
/* size is chosen to exceed page size and trigger actual truncation */ INSERT INTO x SELECT x, 2 * x, 3 * x, BOX(POINT(x, x + 1), POINT(2 * x, 2 * x + 1)) FROM x AS x;
CREATE INDEX x ON x USING gist(x NULLS LAST) INCLUDE (x, x, x);
SELECT PG_GET_INDEXDEF(x.x) FROM x AS x JOIN x AS x ON x.x = x.x WHERE x.x = CAST('tbl_gist' AS REGCLASS) ORDER BY x.x NULLS LAST;
SELECT * FROM x WHERE BOX(POINT(1, 1), POINT(10, 10)) @> x;
SET x = off;
EXPLAIN (costs off) SELECT * FROM tbl_gist where c4 <@ box(point(1,1),point(10,10));
SET x = default;
DROP TABLE x;
/*  * 1.2. test CREATE INDEX with inserts  */ /* Regular index with included columns */ CREATE TABLE x (x INT, x INT, x INT, x box);
/* size is chosen to exceed page size and trigger actual truncation */ CREATE INDEX x ON x USING gist(x NULLS LAST) INCLUDE (x, x, x);
INSERT INTO x SELECT x, 2 * x, 3 * x, BOX(POINT(x, x + 1), POINT(2 * x, 2 * x + 1)) FROM x AS x;
SELECT PG_GET_INDEXDEF(x.x) FROM x AS x JOIN x AS x ON x.x = x.x WHERE x.x = CAST('tbl_gist' AS REGCLASS) ORDER BY x.x NULLS LAST;
SELECT * FROM x WHERE BOX(POINT(1, 1), POINT(10, 10)) @> x;
SET x = off;
EXPLAIN (costs off) SELECT * FROM tbl_gist where c4 <@ box(point(1,1),point(10,10));
SET x = default;
DROP TABLE x;
/*  * 2. CREATE INDEX CONCURRENTLY  */ CREATE TABLE x (x INT, x INT, x INT, x box);
INSERT INTO x SELECT x, 2 * x, 3 * x, BOX(POINT(x, x + 1), POINT(2 * x, 2 * x + 1)) FROM x AS x;
CREATE INDEX CONCURRENTLY x ON x USING gist(x NULLS LAST) INCLUDE (x, x, x);
SELECT x FROM x WHERE x = 'tbl_gist' ORDER BY x NULLS LAST;
DROP TABLE x;
/*  * 3. REINDEX  */ CREATE TABLE x (x INT, x INT, x INT, x box);
INSERT INTO x SELECT x, 2 * x, 3 * x, BOX(POINT(x, x + 1), POINT(2 * x, 2 * x + 1)) FROM x AS x;
CREATE INDEX x ON x USING gist(x NULLS LAST) INCLUDE (x, x);
SELECT x FROM x WHERE x = 'tbl_gist' ORDER BY x NULLS LAST;
REINDEX INDEX tbl_gist_idx;
SELECT x FROM x WHERE x = 'tbl_gist' ORDER BY x NULLS LAST;
ALTER TABLE x DROP COLUMN x;
SELECT x FROM x WHERE x = 'tbl_gist' ORDER BY x NULLS LAST;
DROP TABLE x;
/*  * 4. Update, delete values in indexed table.  */ CREATE TABLE x (x INT, x INT, x INT, x box);
INSERT INTO x SELECT x, 2 * x, 3 * x, BOX(POINT(x, x + 1), POINT(2 * x, 2 * x + 1)) FROM x AS x;
CREATE INDEX x ON x USING gist(x NULLS LAST) INCLUDE (x, x);
UPDATE x SET x = 100 WHERE x = 2;
UPDATE x SET x = 1 WHERE x = 3;
DELETE FROM x WHERE x = 5 OR x = 12;
DROP TABLE x;
/*  * 5. Alter column type.  */ CREATE TABLE x (x INT, x INT, x INT, x box);
INSERT INTO x SELECT x, 2 * x, 3 * x, BOX(POINT(x, x + 1), POINT(2 * x, 2 * x + 1)) FROM x AS x;
CREATE INDEX x ON x USING gist(x NULLS LAST) INCLUDE (x, x);
ALTER TABLE x ALTER COLUMN x SET DATA TYPE BIGINT;
ALTER TABLE x ALTER COLUMN x SET DATA TYPE BIGINT;
/*  * 6. EXCLUDE constraint.  */ CREATE TABLE x (x INT, x INT, x INT, x box, EXCLUDE USING gist(x NULLS LAST WITH &&) INCLUDE (x, x, x));
INSERT INTO x SELECT x, 2 * x, 3 * x, BOX(POINT(x, x + 1), POINT(2 * x, 2 * x + 1)) FROM x AS x;
INSERT INTO x SELECT x, 2 * x, 3 * x, BOX(POINT(3 * x, 2 * x), POINT(3 * x + 1, 2 * x + 1)) FROM x AS x;
EXPLAIN (costs off) SELECT * FROM tbl_gist where c4 <@ box(point(1,1),point(10,10));
SET x = 'pglz' /* Other compression algorithms may cause the compressed data to be stored */ /* inline.  pglz guarantees that the data is externalized, so stick to it. */;
CREATE TABLE x (x TEXT, x INT DEFAULT 0, x TEXT, x TEXT);
INSERT INTO x (x, x, x) VALUES ('two-compressed', REPEAT('1234567890', 1000), REPEAT('1234567890', 1000));
INSERT INTO x (x, x, x) VALUES ('two-toasted', REPEAT('1234567890', 30000), REPEAT('1234567890', 50000));
INSERT INTO x (x, x, x) VALUES ('one-compressed,one-null', NULL, REPEAT('1234567890', 1000));
INSERT INTO x (x, x, x) VALUES ('one-toasted,one-null', NULL, REPEAT('1234567890', 50000));
/* check whether indirect tuples works on the most basic level */ SELECT x, SUBSTRING(CAST(MAKE_TUPLE_INDIRECT(x) AS TEXT), 1, 200) FROM x;
/* modification without changing varlenas */ UPDATE x SET x = x + 1 RETURNING SUBSTRING(CAST(x AS TEXT), 1, 200);
/* modification without modifying assigned value */ UPDATE x SET x = x + 1, x = x RETURNING SUBSTRING(CAST(x AS TEXT), 1, 200);
/* modification modifying, but effectively not changing */ UPDATE x SET x = x + 1, x = x || '' RETURNING SUBSTRING(CAST(x AS TEXT), 1, 200);
UPDATE x SET x = x + 1, x = '-' || x || '-' RETURNING SUBSTRING(CAST(x AS TEXT), 1, 200);
SELECT SUBSTRING(CAST(x AS TEXT), 1, 200) FROM x;
/* check we didn't screw with main/toast tuple visibility */ VACUUM FREEZE indtoasttest;
SELECT SUBSTRING(CAST(x AS TEXT), 1, 200) FROM x;
x AS x;
x;
CREATE TRIGGER indtoasttest_update_indirect         BEFORE INSERT OR UPDATE         ON indtoasttest         FOR EACH ROW         EXECUTE PROCEDURE update_using_indirect();
/* modification without changing varlenas */ UPDATE x SET x = x + 1 RETURNING SUBSTRING(CAST(x AS TEXT), 1, 200);
/* modification without modifying assigned value */ UPDATE x SET x = x + 1, x = x RETURNING SUBSTRING(CAST(x AS TEXT), 1, 200);
/* modification modifying, but effectively not changing */ UPDATE x SET x = x + 1, x = x || '' RETURNING SUBSTRING(CAST(x AS TEXT), 1, 200);
UPDATE x SET x = x + 1, x = '-' || x || '-' RETURNING SUBSTRING(CAST(x AS TEXT), 1, 200);
INSERT INTO x (x, x, x) VALUES ('one-toasted,one-null, via indirect', REPEAT('1234567890', 30000), NULL);
SELECT SUBSTRING(CAST(x AS TEXT), 1, 200) FROM x;
/* check we didn't screw with main/toast tuple visibility */ VACUUM FREEZE indtoasttest;
SELECT SUBSTRING(CAST(x AS TEXT), 1, 200) FROM x;
DROP TABLE x;
DROP FUNCTION x;
RESET default_toast_compression;
/* INET */ /* prepare the table... */ DROP TABLE x;
CREATE TABLE x (x cidr, x INET);
INSERT INTO x (x, x) VALUES ('192.168.1', '192.168.1.226/24');
INSERT INTO x (x, x) VALUES ('192.168.1.0/26', '192.168.1.226');
INSERT INTO x (x, x) VALUES ('192.168.1', '192.168.1.0/24');
INSERT INTO x (x, x) VALUES ('192.168.1', '192.168.1.0/25');
INSERT INTO x (x, x) VALUES ('192.168.1', '192.168.1.255/24');
INSERT INTO x (x, x) VALUES ('192.168.1', '192.168.1.255/25');
INSERT INTO x (x, x) VALUES ('10', '10.1.2.3/8');
INSERT INTO x (x, x) VALUES ('10.0.0.0', '10.1.2.3/8');
INSERT INTO x (x, x) VALUES ('10.1.2.3', '10.1.2.3/32');
INSERT INTO x (x, x) VALUES ('10.1.2', '10.1.2.3/24');
INSERT INTO x (x, x) VALUES ('10.1', '10.1.2.3/16');
INSERT INTO x (x, x) VALUES ('10', '10.1.2.3/8');
INSERT INTO x (x, x) VALUES ('10', '11.1.2.3/8');
INSERT INTO x (x, x) VALUES ('10', '9.1.2.3/8');
INSERT INTO x (x, x) VALUES ('10:23::f1', '10:23::f1/64');
INSERT INTO x (x, x) VALUES ('10:23::8000/113', '10:23::ffff');
INSERT INTO x (x, x) VALUES ('::ffff:1.2.3.4', '::4.3.2.1/24');
/* check that CIDR rejects invalid input: */ INSERT INTO x (x, x) VALUES ('192.168.1.2/30', '192.168.1.226');
INSERT INTO x (x, x) VALUES ('1234::1234::1234', '::1.2.3.4');
/* check that CIDR rejects invalid input when converting from text: */ INSERT INTO x (x, x) VALUES (CIDR('192.168.1.2/30'), '192.168.1.226');
INSERT INTO x (x, x) VALUES (CIDR('ffff:ffff:ffff:ffff::/24'), '::192.168.1.226');
SELECT x AS x, x AS x FROM x;
/* now test some support functions */ SELECT x AS x, HOST(x), TEXT(x), FAMILY(x) FROM x;
SELECT x AS x, ABBREV(x) AS "x", x AS x, ABBREV(x) AS "x" FROM x;
SELECT x AS x, BROADCAST(x) AS "x", x AS x, BROADCAST(x) AS "x" FROM x;
SELECT x AS x, NETWORK(x) AS "x", x AS x, NETWORK(x) AS "x" FROM x;
SELECT x AS x, MASKLEN(x) AS "x", x AS x, MASKLEN(x) AS "x" FROM x;
SELECT x AS x, MASKLEN(x) AS "x", x AS x, MASKLEN(x) AS "x" FROM x WHERE MASKLEN(x) <= 8;
SELECT x AS x, NETMASK(x) AS "x" FROM x;
SELECT x AS x, HOSTMASK(x) AS "x" FROM x;
SELECT x AS x, x AS x FROM x WHERE x = x;
SELECT MAX(x) AS x, MIN(x) AS x FROM x;
SELECT MAX(x) AS x, MIN(x) AS x FROM x;
/* check the conversion to/from text and setting netmask */ SELECT x AS x, SET_MASKLEN(CIDR(TEXT(x)), 24) AS "x", x AS x, SET_MASKLEN(INET(TEXT(x)), 24) AS "x" FROM x;
/* check that netmask is treated as maximum value when set to -1 */ SELECT x AS x, SET_MASKLEN(CIDR(TEXT(x)), -1) AS "x", x AS x, SET_MASKLEN(INET(TEXT(x)), -1) AS "x" FROM x;
/* check that invalid netmask is rejected */ SELECT SET_MASKLEN(INET(TEXT(x)), 33) FROM x;
SELECT SET_MASKLEN(CIDR(TEXT(x)), 33) FROM x;
/* check that btree index works correctly */ CREATE INDEX x ON x(x NULLS LAST);
SET x = off;
EXPLAIN (COSTS OFF) SELECT * FROM inet_tbl WHERE i<<'192.168.1.0/24'::cidr;
SELECT * FROM x WHERE x << CAST('192.168.1.0/24' AS cidr);
EXPLAIN (COSTS OFF) SELECT * FROM inet_tbl WHERE i<<='192.168.1.0/24'::cidr;
EXPLAIN (COSTS OFF) SELECT * FROM inet_tbl WHERE '192.168.1.0/24'::cidr >>= i;
EXPLAIN (COSTS OFF) SELECT * FROM inet_tbl WHERE '192.168.1.0/24'::cidr >> i;
SELECT * FROM x WHERE CAST('192.168.1.0/24' AS cidr) >> x;
SET x = on;
DROP INDEX x;
/* check that gist index works correctly */ CREATE INDEX x ON x USING gist(x x NULLS LAST);
SET x = off;
SELECT * FROM x WHERE x << CAST('192.168.1.0/24' AS cidr) ORDER BY x NULLS LAST;
SELECT * FROM x WHERE x && CAST('192.168.1.0/24' AS cidr) ORDER BY x NULLS LAST;
SELECT * FROM x WHERE x >> CAST('192.168.1.0/24' AS cidr) ORDER BY x NULLS LAST;
SELECT * FROM x WHERE x < CAST('192.168.1.0/24' AS cidr) ORDER BY x NULLS LAST;
SELECT * FROM x WHERE x <= CAST('192.168.1.0/24' AS cidr) ORDER BY x NULLS LAST;
SELECT * FROM x WHERE x = CAST('192.168.1.0/24' AS cidr) ORDER BY x NULLS LAST;
SELECT * FROM x WHERE x >= CAST('192.168.1.0/24' AS cidr) ORDER BY x NULLS LAST;
SELECT * FROM x WHERE x > CAST('192.168.1.0/24' AS cidr) ORDER BY x NULLS LAST;
SELECT * FROM x WHERE x <> CAST('192.168.1.0/24' AS cidr) ORDER BY x NULLS LAST;
/* test index-only scans */ EXPLAIN (COSTS OFF) SELECT i FROM inet_tbl WHERE i << '192.168.1.0/24'::cidr ORDER BY i;
SELECT x FROM x WHERE x << CAST('192.168.1.0/24' AS cidr) ORDER BY x NULLS LAST;
SET x = on;
DROP INDEX x;
/* check that spgist index works correctly */ CREATE INDEX x ON x USING spgist(x NULLS LAST);
SET x = off;
SELECT * FROM x WHERE x << CAST('192.168.1.0/24' AS cidr) ORDER BY x NULLS LAST;
SELECT * FROM x WHERE x && CAST('192.168.1.0/24' AS cidr) ORDER BY x NULLS LAST;
SELECT * FROM x WHERE x >> CAST('192.168.1.0/24' AS cidr) ORDER BY x NULLS LAST;
SELECT * FROM x WHERE x < CAST('192.168.1.0/24' AS cidr) ORDER BY x NULLS LAST;
SELECT * FROM x WHERE x <= CAST('192.168.1.0/24' AS cidr) ORDER BY x NULLS LAST;
SELECT * FROM x WHERE x = CAST('192.168.1.0/24' AS cidr) ORDER BY x NULLS LAST;
SELECT * FROM x WHERE x >= CAST('192.168.1.0/24' AS cidr) ORDER BY x NULLS LAST;
SELECT * FROM x WHERE x > CAST('192.168.1.0/24' AS cidr) ORDER BY x NULLS LAST;
SELECT * FROM x WHERE x <> CAST('192.168.1.0/24' AS cidr) ORDER BY x NULLS LAST;
/* test index-only scans */ EXPLAIN (COSTS OFF) SELECT i FROM inet_tbl WHERE i << '192.168.1.0/24'::cidr ORDER BY i;
SELECT x FROM x WHERE x << CAST('192.168.1.0/24' AS cidr) ORDER BY x NULLS LAST;
SET x = on;
DROP INDEX x;
SELECT x, x, x & x AS "x" FROM x;
SELECT x, x, x | x AS "x" FROM x;
SELECT x, x + 500 AS "x" FROM x;
SELECT x, x - 500 AS "x" FROM x;
SELECT x, x, x - x AS "x" FROM x;
SELECT CAST('127.0.0.1' AS INET) + 257;
SELECT (CAST('127.0.0.1' AS INET) + 257) - 257;
SELECT CAST('127::1' AS INET) + 257;
SELECT (CAST('127::1' AS INET) + 257) - 257;
SELECT CAST('127.0.0.2' AS INET) - (CAST('127.0.0.2' AS INET) + 500);
SELECT CAST('127.0.0.2' AS INET) - (CAST('127.0.0.2' AS INET) - 500);
SELECT CAST('127::2' AS INET) - (CAST('127::2' AS INET) + 500);
SELECT CAST('127::2' AS INET) - (CAST('127::2' AS INET) - 500);
/* these should give overflow errors: */ SELECT CAST('127.0.0.1' AS INET) + 10000000000;
SELECT CAST('127.0.0.1' AS INET) - 10000000000;
SELECT CAST('126::1' AS INET) - CAST('127::2' AS INET);
SELECT CAST('127::1' AS INET) - CAST('126::2' AS INET);
/* but not these */ SELECT CAST('127::1' AS INET) + 10000000000;
SELECT CAST('127::1' AS INET) - CAST('127::2' AS INET);
/* insert one more row with addressed from different families */ INSERT INTO x (x, x) VALUES ('10', '10::/8');
/* now, this one should fail */ SELECT INET_MERGE(x, x) FROM x;
/* fix it by inet_same_family() condition */ SELECT INET_MERGE(x, x) FROM x WHERE INET_SAME_FAMILY(x, x);
/* Test inet sortsupport with a variety of boundary inputs: */ SELECT x FROM (VALUES (CAST('0.0.0.0/0' AS INET)), (CAST('0.0.0.0/1' AS INET)), (CAST('0.0.0.0/32' AS INET)), (CAST('0.0.0.1/0' AS INET)), (CAST('0.0.0.1/1' AS INET)), (CAST('127.126.127.127/0' AS INET)), (CAST('127.127.127.127/0' AS INET)), (CAST('127.128.127.127/0' AS INET)), (CAST('192.168.1.0/24' AS INET)), (CAST('192.168.1.0/25' AS INET)), (CAST('192.168.1.1/23' AS INET)), (CAST('192.168.1.1/5' AS INET)), (CAST('192.168.1.1/6' AS INET)), (CAST('192.168.1.1/25' AS INET)), (CAST('192.168.1.2/25' AS INET)), (CAST('192.168.1.1/26' AS INET)), (CAST('192.168.1.2/26' AS INET)), (CAST('192.168.1.2/23' AS INET)), (CAST('192.168.1.255/5' AS INET)), (CAST('192.168.1.255/6' AS INET)), (CAST('192.168.1.3/1' AS INET)), (CAST('192.168.1.3/23' AS INET)), (CAST('192.168.1.4/0' AS INET)), (CAST('192.168.1.5/0' AS INET)), (CAST('255.0.0.0/0' AS INET)), (CAST('255.1.0.0/0' AS INET)), (CAST('255.2.0.0/0' AS INET)), (CAST('255.255.000.000/0' AS INET)), (CAST('255.255.000.000/0' AS INET)), (CAST('255.255.000.000/15' AS INET)), (CAST('255.255.000.000/16' AS INET)), (CAST('255.255.255.254/32' AS INET)), (CAST('255.255.255.000/32' AS INET)), (CAST('255.255.255.001/31' AS INET)), (CAST('255.255.255.002/31' AS INET)), (CAST('255.255.255.003/31' AS INET)), (CAST('255.255.255.003/32' AS INET)), (CAST('255.255.255.001/32' AS INET)), (CAST('255.255.255.255/0' AS INET)), (CAST('255.255.255.255/0' AS INET)), (CAST('255.255.255.255/0' AS INET)), (CAST('255.255.255.255/1' AS INET)), (CAST('255.255.255.255/16' AS INET)), (CAST('255.255.255.255/16' AS INET)), (CAST('255.255.255.255/31' AS INET)), (CAST('255.255.255.255/32' AS INET)), (CAST('255.255.255.253/32' AS INET)), (CAST('255.255.255.252/32' AS INET)), (CAST('255.3.0.0/0' AS INET)), (CAST('0000:0000:0000:0000:0000:0000:0000:0000/0' AS INET)), (CAST('0000:0000:0000:0000:0000:0000:0000:0000/128' AS INET)), (CAST('0000:0000:0000:0000:0000:0000:0000:0001/128' AS INET)), (CAST('10:23::f1/64' AS INET)), (CAST('10:23::f1/65' AS INET)), (CAST('10:23::ffff' AS INET)), (CAST('127::1' AS INET)), (CAST('127::2' AS INET)), (CAST('8000:0000:0000:0000:0000:0000:0000:0000/1' AS INET)), (CAST('::1:ffff:ffff:ffff:ffff/128' AS INET)), (CAST('::2:ffff:ffff:ffff:ffff/128' AS INET)), (CAST('::4:3:2:0/24' AS INET)), (CAST('::4:3:2:1/24' AS INET)), (CAST('::4:3:2:2/24' AS INET)), (CAST('ffff:83e7:f118:57dc:6093:6d92:689d:58cf/70' AS INET)), (CAST('ffff:84b0:4775:536e:c3ed:7116:a6d6:34f0/44' AS INET)), (CAST('ffff:8566:f84:5867:47f1:7867:d2ba:8a1a/69' AS INET)), (CAST('ffff:8883:f028:7d2:4d68:d510:7d6b:ac43/73' AS INET)), (CAST('ffff:8ae8:7c14:65b3:196:8e4a:89ae:fb30/89' AS INET)), (CAST('ffff:8dd0:646:694c:7c16:7e35:6a26:171/104' AS INET)), (CAST('ffff:8eef:cbf:700:eda3:ae32:f4b4:318b/121' AS INET)), (CAST('ffff:90e7:e744:664:a93:8efe:1f25:7663/122' AS INET)), (CAST('ffff:9597:c69c:8b24:57a:8639:ec78:6026/111' AS INET)), (CAST('ffff:9e86:79ea:f16e:df31:8e4d:7783:532e/88' AS INET)), (CAST('ffff:a0c7:82d3:24de:f762:6e1f:316d:3fb2/23' AS INET)), (CAST('ffff:fffa:ffff:ffff:ffff:ffff:ffff:ffff/0' AS INET)), (CAST('ffff:fffb:ffff:ffff:ffff:ffff:ffff:ffff/0' AS INET)), (CAST('ffff:fffc:ffff:ffff:ffff:ffff:ffff:ffff/0' AS INET)), (CAST('ffff:fffd:ffff:ffff:ffff:ffff:ffff:ffff/0' AS INET)), (CAST('ffff:fffe:ffff:ffff:ffff:ffff:ffff:ffff/0' AS INET)), (CAST('ffff:ffff:ffff:fffa:ffff:ffff:ffff:ffff/0' AS INET)), (CAST('ffff:ffff:ffff:fffb:ffff:ffff:ffff:ffff/0' AS INET)), (CAST('ffff:ffff:ffff:fffc:ffff:ffff:ffff:ffff/0' AS INET)), (CAST('ffff:ffff:ffff:fffd::/128' AS INET)), (CAST('ffff:ffff:ffff:fffd:ffff:ffff:ffff:ffff/0' AS INET)), (CAST('ffff:ffff:ffff:fffe::/128' AS INET)), (CAST('ffff:ffff:ffff:fffe:ffff:ffff:ffff:ffff/0' AS INET)), (CAST('ffff:ffff:ffff:ffff:4:3:2:0/24' AS INET)), (CAST('ffff:ffff:ffff:ffff:4:3:2:1/24' AS INET)), (CAST('ffff:ffff:ffff:ffff:4:3:2:2/24' AS INET)), (CAST('ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff/0' AS INET)), (CAST('ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff/128' AS INET))) AS x ORDER BY x NULLS LAST;
/* test non-error-throwing API for some core types */ SELECT PG_INPUT_IS_VALID('1234', 'cidr');
SELECT * FROM x;
SELECT PG_INPUT_IS_VALID('192.168.198.200/24', 'cidr');
SELECT * FROM x;
SELECT PG_INPUT_IS_VALID('1234', 'inet');
SELECT * FROM x;
/* Check that stack depth detection mechanism works and */ /* max_stack_depth is not set too high. */ CREATE FUNCTION x() RETURNS INT LANGUAGE sql AS 'select infinite_recurse()';
/* Test inheritance features */ CREATE TABLE x (x TEXT);
CREATE TABLE x (x TEXT) INHERITS (x);
CREATE TABLE x (x TEXT) INHERITS (x);
CREATE TABLE x (x TEXT) INHERITS (x, x, x);
INSERT INTO x (x) VALUES ('aaa');
INSERT INTO x (x) VALUES ('aaaa');
INSERT INTO x (x) VALUES ('aaaaa');
INSERT INTO x (x) VALUES ('aaaaaa');
INSERT INTO x (x) VALUES ('aaaaaaa');
INSERT INTO x (x) VALUES ('aaaaaaaa');
INSERT INTO x (x) VALUES ('bbb');
INSERT INTO x (x) VALUES ('bbbb');
INSERT INTO x (x) VALUES ('bbbbb');
INSERT INTO x (x) VALUES ('bbbbbb');
INSERT INTO x (x) VALUES ('bbbbbbb');
INSERT INTO x (x) VALUES ('bbbbbbbb');
INSERT INTO x (x) VALUES ('ccc');
INSERT INTO x (x) VALUES ('cccc');
INSERT INTO x (x) VALUES ('ccccc');
INSERT INTO x (x) VALUES ('cccccc');
INSERT INTO x (x) VALUES ('ccccccc');
INSERT INTO x (x) VALUES ('cccccccc');
INSERT INTO x (x) VALUES ('ddd');
INSERT INTO x (x) VALUES ('dddd');
INSERT INTO x (x) VALUES ('ddddd');
INSERT INTO x (x) VALUES ('dddddd');
INSERT INTO x (x) VALUES ('ddddddd');
INSERT INTO x (x) VALUES ('dddddddd');
SELECT x, x.* FROM x, x WHERE x.x = x.x;
SELECT x, x.* FROM x, x WHERE x.x = x.x;
SELECT x, x.* FROM x, x WHERE x.x = x.x;
SELECT x, x.* FROM x, x WHERE x.x = x.x;
SELECT x, x.* FROM ONLY x, x WHERE x.x = x.x;
SELECT x, x.* FROM ONLY x, x WHERE x.x = x.x;
SELECT x, x.* FROM ONLY x, x WHERE x.x = x.x;
SELECT x, x.* FROM ONLY x, x WHERE x.x = x.x;
UPDATE x SET x = 'zzzz' WHERE x = 'aaaa';
UPDATE ONLY x SET x = 'zzzzz' WHERE x = 'aaaaa';
UPDATE x SET x = 'zzz' WHERE x = 'aaa';
UPDATE ONLY x SET x = 'zzz' WHERE x = 'aaa';
UPDATE x SET x = 'zzzzzz' WHERE x LIKE 'aaa%';
SELECT x, x.* FROM x, x WHERE x.x = x.x;
SELECT x, x.* FROM x, x WHERE x.x = x.x;
SELECT x, x.* FROM x, x WHERE x.x = x.x;
SELECT x, x.* FROM x, x WHERE x.x = x.x;
SELECT x, x.* FROM ONLY x, x WHERE x.x = x.x;
SELECT x, x.* FROM ONLY x, x WHERE x.x = x.x;
SELECT x, x.* FROM ONLY x, x WHERE x.x = x.x;
SELECT x, x.* FROM ONLY x, x WHERE x.x = x.x;
UPDATE x SET x = 'new';
SELECT x, x.* FROM x, x WHERE x.x = x.x;
SELECT x, x.* FROM x, x WHERE x.x = x.x;
SELECT x, x.* FROM x, x WHERE x.x = x.x;
SELECT x, x.* FROM x, x WHERE x.x = x.x;
SELECT x, x.* FROM ONLY x, x WHERE x.x = x.x;
SELECT x, x.* FROM ONLY x, x WHERE x.x = x.x;
SELECT x, x.* FROM ONLY x, x WHERE x.x = x.x;
SELECT x, x.* FROM ONLY x, x WHERE x.x = x.x;
UPDATE x SET x = 'new';
DELETE FROM ONLY x WHERE x = 'new';
SELECT x, x.* FROM x, x WHERE x.x = x.x;
SELECT x, x.* FROM x, x WHERE x.x = x.x;
SELECT x, x.* FROM x, x WHERE x.x = x.x;
SELECT x, x.* FROM x, x WHERE x.x = x.x;
SELECT x, x.* FROM ONLY x, x WHERE x.x = x.x;
SELECT x, x.* FROM ONLY x, x WHERE x.x = x.x;
SELECT x, x.* FROM ONLY x, x WHERE x.x = x.x;
SELECT x, x.* FROM ONLY x, x WHERE x.x = x.x;
DELETE FROM x;
SELECT x, x.* FROM x, x WHERE x.x = x.x;
SELECT x, x.* FROM x, x WHERE x.x = x.x;
SELECT x, x.* FROM x, x WHERE x.x = x.x;
SELECT x, x.* FROM x, x WHERE x.x = x.x;
SELECT x, x.* FROM ONLY x, x WHERE x.x = x.x;
SELECT x, x.* FROM ONLY x, x WHERE x.x = x.x;
SELECT x, x.* FROM ONLY x, x WHERE x.x = x.x;
SELECT x, x.* FROM ONLY x, x WHERE x.x = x.x;
/* Confirm PRIMARY KEY adds NOT NULL constraint to child table */ CREATE TEMPORARY TABLE x (x TEXT, PRIMARY KEY (x NULLS LAST, x NULLS LAST)) INHERITS (x);
INSERT INTO x VALUES (NULL, 'text');
/* should fail */ /* ... but not UNIQUE. */ CREATE TEMPORARY TABLE x (x TEXT, UNIQUE (x, x)) INHERITS (x);
INSERT INTO x VALUES (NULL, 'text');
CREATE TABLE x INHERITS (x);
INSERT INTO x SELECT x, x + 1, 0 FROM x AS x;
CREATE INDEX ON x(x NULLS LAST, x NULLS LAST);
x AS x;
COMMIT;
create trigger some_tab_stmt_trig   before update on some_tab execute function some_tab_stmt_trig_func();
EXPLAIN (costs off) update some_tab set f3 = 11 where f1 = 12 and f2 = 13;
UPDATE x SET x = 11 WHERE x = 12 AND x = 13;
DROP TABLE x CASCADE;
DROP FUNCTION x;
/* Check inherited UPDATE with all children excluded */ CREATE TABLE x (x INT, x INT);
CREATE TABLE x INHERITS (x);
INSERT INTO x VALUES (1, 2);
EXPLAIN (verbose, costs off) update some_tab set a = a + 1 where false;
UPDATE x SET x = x + 1 WHERE FALSE;
EXPLAIN (verbose, costs off) update some_tab set a = a + 1 where false returning b, a;
UPDATE x SET x = x + 1 WHERE FALSE RETURNING x, x;
x AS x;
DROP TABLE x CASCADE;
/* Check UPDATE with inherited target and an inherited source table */ CREATE TEMPORARY TABLE x (x INT, x INT);
CREATE TEMPORARY TABLE x (x INT) INHERITS (x);
CREATE TEMPORARY TABLE x (x INT, x INT);
CREATE TEMPORARY TABLE x (x INT) INHERITS (x);
INSERT INTO x VALUES (1, 1);
INSERT INTO x VALUES (3, 3);
INSERT INTO x VALUES (2, 2, 2);
INSERT INTO x VALUES (3, 3, 3);
INSERT INTO x VALUES (1, 1);
INSERT INTO x VALUES (2, 2);
INSERT INTO x VALUES (3, 3);
INSERT INTO x VALUES (4, 4);
INSERT INTO x VALUES (1, 1, 1);
INSERT INTO x VALUES (2, 2, 2);
INSERT INTO x VALUES (3, 3, 3);
INSERT INTO x VALUES (4, 4, 4);
UPDATE x SET x = x + 100 WHERE x IN (SELECT x FROM x);
SELECT CAST(CAST(x AS REGCLASS) AS TEXT) AS x, x.* FROM x ORDER BY 1 NULLS LAST, 2 NULLS LAST;
/* Check UPDATE with inherited target and an appendrel subquery */ UPDATE x SET x = x + 100 FROM (SELECT x FROM x UNION ALL SELECT x + 3 FROM x) AS x WHERE x.x = x.x;
SELECT CAST(CAST(x AS REGCLASS) AS TEXT) AS x, x.* FROM x ORDER BY 1 NULLS LAST, 2 NULLS LAST;
/* Check UPDATE with *partitioned* inherited target and an appendrel subquery */ CREATE TABLE x (x INT);
INSERT INTO x VALUES (0);
CREATE TABLE x INHERITS (x);
INSERT INTO x VALUES (1);
CREATE TABLE x (x INT, x CHAR) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN (1);
CREATE TABLE x PARTITION OF x FOR VALUES IN (2);
CREATE TABLE x PARTITION OF x FOR VALUES IN (3);
INSERT INTO x VALUES (1, 'a'), (2, 'a'), (3, 'a');
UPDATE x SET x = 'b' FROM (SELECT x FROM x UNION ALL SELECT x + 1 FROM x) AS x WHERE x.x = x.x;
SELECT CAST(CAST(x AS REGCLASS) AS TEXT) AS x, x.* FROM x ORDER BY 1 NULLS LAST, 2 NULLS LAST;
TRUNCATE TABLE x;
INSERT INTO x VALUES (1, 'a'), (2, 'a'), (3, 'a');
UPDATE x SET x = 'b' FROM (SELECT 0 FROM x UNION ALL SELECT 1 FROM x) AS x WHERE x.x = x.x;
SELECT CAST(CAST(x AS REGCLASS) AS TEXT) AS x, x.* FROM x ORDER BY 1 NULLS LAST, 2 NULLS LAST;
/* modifies partition key, but no rows will actually be updated */ EXPLAIN update parted_tab set a = 2 where false;
DROP TABLE x;
/* Check UPDATE with multi-level partitioned inherited target */ CREATE TABLE x (x INT, x CHAR, x TEXT) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN (1);
CREATE TABLE x PARTITION OF x FOR VALUES IN (2) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN (3);
CREATE TABLE x PARTITION OF x FOR VALUES IN ('a');
CREATE TABLE x PARTITION OF x FOR VALUES IN ('b');
INSERT INTO x VALUES (1, 'a'), (2, 'a'), (2, 'b'), (3, 'a');
UPDATE x AS x SET x = 'xxx' FROM (SELECT x FROM x UNION ALL SELECT x + 1 FROM x) AS x WHERE (x.x = x.x AND x.x = 'b') OR x.x = 3;
SELECT CAST(CAST(x AS REGCLASS) AS TEXT) AS x, x.* FROM x ORDER BY 1 NULLS LAST, 2 NULLS LAST;
DROP TABLE x;
DROP TABLE x CASCADE;
/* Test multiple inheritance of column defaults */ CREATE TABLE x (x DATE DEFAULT CAST(CURRENT_TIMESTAMP() AS DATE) + 1);
CREATE TABLE x (x DATE DEFAULT CAST(CURRENT_TIMESTAMP() AS DATE) + 1);
CREATE TABLE x INHERITS (x, x);
/* ok */ CREATE TABLE x (x DATE DEFAULT CAST(CURRENT_TIMESTAMP() AS DATE) - 1);
CREATE TABLE x INHERITS (x, x);
/* not ok */ CREATE TABLE x (x DATE DEFAULT CURRENT_TIMESTAMP()) INHERITS (x, x);
/* Test changing the type of inherited columns */ INSERT INTO x VALUES ('test', 'one', 'two', 'three');
ALTER TABLE x ALTER COLUMN x SET DATA TYPE INT USING BIT_LENGTH(x);
SELECT * FROM x;
CREATE TEMPORARY TABLE x (x INT, x BIGINT);
CREATE TEMPORARY TABLE x (x INT) INHERITS (x, x);
ALTER TABLE x ALTER COLUMN x SET DATA TYPE BIGINT;
ALTER TABLE x ALTER COLUMN x SET DATA TYPE BIGINT /* fail, conflict w/parent2 */;
/* ok */ /* Test non-inheritable parent constraints */ CREATE TABLE x (x INT);
alter table p1 add constraint p1chk check (ff1 > 0) no inherit;
ALTER TABLE x ADD CONSTRAINT x CHECK (x > 10);
/* connoinherit should be true for NO INHERIT constraint */ SELECT x.x, x.x, x.x, x.x, x.x, x.x FROM x AS x INNER JOIN x AS x ON (x.x = x.x) WHERE x.x = 'p1' ORDER BY 1 NULLS LAST, 2 NULLS LAST;
/* Test that child does not inherit NO INHERIT constraints */ CREATE TABLE x INHERITS (x);
/* fails */ DROP TABLE x CASCADE;
/* Tests for casting between the rowtypes of parent and child */ /* tables. See the pgsql-hackers thread beginning Dec. 4/04 */ CREATE TABLE x (x INT);
CREATE TABLE x INHERITS (x);
CREATE TABLE x (LIKE x, x INT) INHERITS (x);
INSERT INTO x (x) VALUES (0);
SELECT CAST(x AS base) FROM x;
SELECT CAST(CAST(NULL AS derived) AS base);
/* remove redundant conversions. */ EXPLAIN (verbose on, costs off) select row(i, b)::more_derived::derived::base from more_derived;
EXPLAIN (verbose on, costs off) select (1, 2)::more_derived::derived::base;
DROP TABLE x;
DROP TABLE x;
DROP TABLE x;
CREATE TABLE x (x INT);
CREATE TABLE x (x TEXT);
CREATE FUNCTION x(x) RETURNS TEXT LANGUAGE sql AS 'select $1.f1';
CREATE TABLE x (x INT) INHERITS (x, x);
INSERT INTO x VALUES (123456789, 'hi', 42);
SELECT P2TEXT(x.*) FROM x;
DROP FUNCTION x (p2);
DROP TABLE x;
DROP TABLE x;
DROP TABLE x;
CREATE TABLE x (x TEXT);
ALTER TABLE x ADD CONSTRAINT x CHECK (NOT x IS NULL);
CREATE TABLE x (x TEXT) INHERITS (x);
SELECT x.x, x.x, x.x, x.x, x.x, PG_GET_EXPR(x.x, x.x) AS x FROM x AS x INNER JOIN x AS x ON (x.x = x.x) WHERE x.x IN ('ac', 'bc') ORDER BY 1 NULLS LAST, 2 NULLS LAST;
INSERT INTO x (x) VALUES (NULL);
INSERT INTO x (x) VALUES (NULL);
ALTER TABLE x DROP CONSTRAINT x;
ALTER TABLE x DROP CONSTRAINT x /* fail, disallowed */;
SELECT x.x, x.x, x.x, x.x, x.x, PG_GET_EXPR(x.x, x.x) AS x FROM x AS x INNER JOIN x AS x ON (x.x = x.x) WHERE x.x IN ('ac', 'bc') ORDER BY 1 NULLS LAST, 2 NULLS LAST;
ALTER TABLE x CHECK(NOT x IS NULL) /* try the unnamed-constraint case */;
SELECT x.x, x.x, x.x, x.x, x.x, PG_GET_EXPR(x.x, x.x) AS x FROM x AS x INNER JOIN x AS x ON (x.x = x.x) WHERE x.x IN ('ac', 'bc') ORDER BY 1 NULLS LAST, 2 NULLS LAST;
INSERT INTO x (x) VALUES (NULL);
INSERT INTO x (x) VALUES (NULL);
ALTER TABLE x DROP CONSTRAINT x;
ALTER TABLE x DROP CONSTRAINT x /* fail, disallowed */;
SELECT x.x, x.x, x.x, x.x, x.x, PG_GET_EXPR(x.x, x.x) AS x FROM x AS x INNER JOIN x AS x ON (x.x = x.x) WHERE x.x IN ('ac', 'bc') ORDER BY 1 NULLS LAST, 2 NULLS LAST;
ALTER TABLE x ADD CONSTRAINT x CHECK (NOT x IS NULL);
alter table bc no inherit ac;
SELECT x.x, x.x, x.x, x.x, x.x, PG_GET_EXPR(x.x, x.x) AS x FROM x AS x INNER JOIN x AS x ON (x.x = x.x) WHERE x.x IN ('ac', 'bc') ORDER BY 1 NULLS LAST, 2 NULLS LAST;
ALTER TABLE x DROP CONSTRAINT x;
SELECT x.x, x.x, x.x, x.x, x.x, PG_GET_EXPR(x.x, x.x) AS x FROM x AS x INNER JOIN x AS x ON (x.x = x.x) WHERE x.x IN ('ac', 'bc') ORDER BY 1 NULLS LAST, 2 NULLS LAST;
ALTER TABLE x DROP CONSTRAINT x;
SELECT x.x, x.x, x.x, x.x, x.x, PG_GET_EXPR(x.x, x.x) AS x FROM x AS x INNER JOIN x AS x ON (x.x = x.x) WHERE x.x IN ('ac', 'bc') ORDER BY 1 NULLS LAST, 2 NULLS LAST;
DROP TABLE x;
DROP TABLE x;
CREATE TABLE x (x INT CONSTRAINT x CHECK (x <> 0));
CREATE TABLE x (x INT CONSTRAINT x CHECK (x <> 0), x INT CONSTRAINT x CHECK (x <> 0)) INHERITS (x);
SELECT x.x, x.x, x.x, x.x, x.x, PG_GET_EXPR(x.x, x.x) AS x FROM x AS x INNER JOIN x AS x ON (x.x = x.x) WHERE x.x IN ('ac', 'bc') ORDER BY 1 NULLS LAST, 2 NULLS LAST;
DROP TABLE x;
DROP TABLE x;
CREATE TABLE x (x INT CONSTRAINT x CHECK (x <> 0));
CREATE TABLE x (x INT CONSTRAINT x CHECK (x <> 0));
CREATE TABLE x (x INT CONSTRAINT x CHECK (x <> 0)) INHERITS (x, x);
SELECT x.x, x.x, x.x, x.x, x.x, PG_GET_EXPR(x.x, x.x) AS x FROM x AS x INNER JOIN x AS x ON (x.x = x.x) WHERE x.x IN ('ac', 'bc', 'cc') ORDER BY 1 NULLS LAST, 2 NULLS LAST;
alter table cc no inherit bc;
SELECT x.x, x.x, x.x, x.x, x.x, PG_GET_EXPR(x.x, x.x) AS x FROM x AS x INNER JOIN x AS x ON (x.x = x.x) WHERE x.x IN ('ac', 'bc', 'cc') ORDER BY 1 NULLS LAST, 2 NULLS LAST;
DROP TABLE x;
DROP TABLE x;
DROP TABLE x;
CREATE TABLE x (x INT);
CREATE TABLE x (x INT);
CREATE TABLE x (x INT) INHERITS (x, x);
INSERT INTO x VALUES (1, -1, 2);
ALTER TABLE x ADD CONSTRAINT x CHECK (x > 0);
ALTER TABLE x CHECK(x > 0) /* fail */;
/* check it without a name, too */ DELETE FROM x;
INSERT INTO x VALUES (1, 1, 2);
ALTER TABLE x CHECK(x > 0);
INSERT INTO x VALUES (1, -1, 2);
/* fail */ CREATE TABLE x (x INT) INHERITS (x, x);
DROP TABLE x CASCADE;
CREATE TABLE x (x INT);
CREATE TABLE x (x TEXT, x INT) INHERITS (x);
ALTER TABLE x ADD COLUMN x INT CHECK (x > 0);
/* Test for renaming in simple multiple inheritance */ CREATE TABLE x (x INT, x INT);
CREATE TABLE x (x INT, x INT);
CREATE TABLE x (x INT) INHERITS (x, x);
ALTER TABLE x RENAME TO x, TO x;
ALTER TABLE x RENAME TO x, TO x;
ALTER TABLE x RENAME TO x, TO x /* to be failed */;
ALTER TABLE x RENAME TO x, TO x /* to be failed */;
/* Test for adding a column to a parent table with complex inheritance */ CREATE TABLE x;
CREATE TABLE x INHERITS (x);
CREATE TABLE x INHERITS (x);
CREATE TABLE x INHERITS (x, x, x);
ALTER TABLE x ADD COLUMN x INT;
/* Test for renaming in diamond inheritance */ CREATE TABLE x (x INT) INHERITS (x);
CREATE TABLE x (x INT) INHERITS (x);
CREATE TABLE x (x INT) INHERITS (x, x);
ALTER TABLE x RENAME TO x, TO x;
ALTER TABLE x RENAME TO x, TO x;
ALTER TABLE x RENAME TO x, TO x;
/* Test non-inheritable indices [UNIQUE, EXCLUDE] constraints */ CREATE TABLE x (x INT, x VARCHAR, x INT, UNIQUE (x, x));
CREATE TABLE x INHERITS (x);
DROP TABLE x;
CREATE TABLE x (x circle, EXCLUDE USING gist(x NULLS LAST WITH &&));
CREATE TABLE x INHERITS (x);
DROP TABLE x;
/* Test non-inheritable foreign key constraints */ CREATE TABLE x (x INT PRIMARY KEY);
CREATE TABLE x (x INT REFERENCES x (x));
CREATE TABLE x INHERITS (x);
DROP TABLE x;
DROP TABLE x;
/* Test foreign key behavior */ CREATE TABLE x (x INT PRIMARY KEY);
INSERT INTO x VALUES (1), (2), (3);
CREATE TABLE x (x INT PRIMARY KEY, x INT REFERENCES x ON delete CASCADE);
INSERT INTO x VALUES (11, 1), (22, 2), (33, 3);
CREATE TABLE x INHERITS (x);
INSERT INTO x VALUES (111, 1), (222, 2);
DELETE FROM x WHERE x = 1;
SELECT * FROM x ORDER BY 1 NULLS LAST;
SELECT * FROM x ORDER BY 1 NULLS LAST, 2 NULLS LAST;
/* Test that parent and child CHECK constraints can be created in either order */ CREATE TABLE x (x INT);
CREATE TABLE x INHERITS (x);
ALTER TABLE x ADD CONSTRAINT x CHECK (x > 0);
ALTER TABLE x ADD CONSTRAINT x CHECK (x > 0);
ALTER TABLE x ADD CONSTRAINT x CHECK (x < 10);
ALTER TABLE x ADD CONSTRAINT x CHECK (x < 10);
alter table p1 add constraint inh_check_constraint3 check (f1 > 0) not enforced;
alter table p1_c1 add constraint inh_check_constraint3 check (f1 > 0) not enforced;
alter table p1_c1 add constraint inh_check_constraint4 check (f1 < 10) not enforced;
alter table p1 add constraint inh_check_constraint4 check (f1 < 10) not enforced;
ALTER TABLE x ADD CONSTRAINT x CHECK (x < 10) ENFORCED /* allowed to merge enforced constraint with parent's not enforced constraint */;
alter table p1 add constraint inh_check_constraint5 check (f1 < 10) not enforced;
alter table p1 add constraint inh_check_constraint6 check (f1 < 10) not enforced;
ALTER TABLE x ADD CONSTRAINT x CHECK (x < 10) ENFORCED;
CREATE TABLE x (x INT CONSTRAINT x CHECK (x < 10)) INHERITS (x);
/* but reverse is not allowed */ alter table p1_c1 add constraint inh_check_constraint7 check (f1 < 10) not enforced;
ALTER TABLE x ADD CONSTRAINT x CHECK (x < 10) ENFORCED;
ALTER TABLE x ADD CONSTRAINT x CHECK (x < 10) ENFORCED;
alter table p1_c1 add constraint inh_check_constraint8 check (f1 < 10) not enforced;
/* constraints with different enforceability can be merged by marking them as ENFORCED */ CREATE TABLE x INHERITS (x, x);
SELECT CAST(CAST(x AS REGCLASS) AS TEXT) AS x, x, x, x, x FROM x WHERE x LIKE 'inh\_check\_constraint%' ORDER BY 1 NULLS LAST, 2 NULLS LAST;
DROP TABLE x CASCADE;
CREATE TABLE x (x INT CONSTRAINT x CHECK (x > 0) ENFORCED);
alter table p1_c1 inherit p1;
DROP TABLE x CASCADE;
CREATE TABLE x (x INT CONSTRAINT x CHECK (x > 0) ENFORCED);
alter table p1_c1 inherit p1;
/* Test DROP behavior of multiply-defined CHECK constraints */ CREATE TABLE x (x INT CONSTRAINT x CHECK (x > 0));
CREATE TABLE x (x INT CONSTRAINT x CHECK (x > 0)) INHERITS (x);
ALTER TABLE x DROP CONSTRAINT x;
ALTER TABLE x DROP CONSTRAINT x;
CREATE TABLE x (x INT CONSTRAINT x CHECK (x > 0));
CREATE TABLE x (x INT CONSTRAINT x CHECK (x > 0));
CREATE TABLE x (x INT) INHERITS (x, x);
CREATE TABLE x (x INT CONSTRAINT x CHECK (x > 0)) INHERITS (x, x);
ALTER TABLE x DROP CONSTRAINT x;
ALTER TABLE x DROP CONSTRAINT x;
CREATE TABLE x (x INT CONSTRAINT x CHECK (x > 0));
CREATE TABLE x INHERITS (x);
CREATE TABLE x INHERITS (x);
CREATE TABLE x INHERITS (x, x);
CREATE TABLE x (x INT CONSTRAINT x CHECK (x > 0));
CREATE TABLE x INHERITS (x);
CREATE TABLE x (CONSTRAINT x CHECK (x > 0)) INHERITS (x);
CREATE TABLE x INHERITS (x, x, x);
ALTER TABLE x DROP CONSTRAINT x;
ALTER TABLE x DROP CONSTRAINT x;
ALTER TABLE x DROP CONSTRAINT x;
ALTER TABLE x DROP CONSTRAINT x;
/* Test that a valid child can have not-valid parent, but not vice versa */ CREATE TABLE x (x INT);
CREATE TABLE x INHERITS (x);
ALTER TABLE x ADD CONSTRAINT x CHECK (x > 0) NOT VALID;
ALTER TABLE x ADD CONSTRAINT x CHECK (x > 0);
ALTER TABLE x DROP CONSTRAINT x /* fail */;
INSERT INTO x VALUES (0);
ALTER TABLE x ADD CONSTRAINT x CHECK (x > 0);
ALTER TABLE x ADD CONSTRAINT x CHECK (x > 0) NOT VALID;
INSERT INTO x VALUES (0);
/* fail */ INSERT INTO x VALUES (0);
/* fail */ SELECT CAST(CAST(x AS REGCLASS) AS TEXT) AS x, x, x, x, x, x FROM x WHERE x LIKE 'inh\_check\_constraint%' ORDER BY 1 NULLS LAST, 2 NULLS LAST;
/* We don't drop the invalid_check_con* tables, to test dump/reload with */ /* Test parameterized append plans for inheritance trees */ CREATE TEMPORARY TABLE x (x, x) AS SELECT x, x FROM x AS x;
CREATE TEMPORARY TABLE x INHERITS (x);
INSERT INTO x SELECT x, x FROM x AS x;
CREATE TEMPORARY TABLE x INHERITS (x);
INSERT INTO x SELECT x, x FROM x AS x;
CREATE INDEX x ON x(x NULLS LAST);
CREATE INDEX x ON x(x NULLS LAST);
CREATE INDEX x ON x(x NULLS LAST);
ANALYZE x;
ANALYZE x;
ANALYZE x;
EXPLAIN (costs off) select * from patest0 join (select f1 from int4_tbl limit 1) ss on id = f1;
SELECT * FROM x JOIN (SELECT x FROM x LIMIT 1) AS x ON x = x;
DROP INDEX x;
EXPLAIN (costs off) select * from patest0 join (select f1 from int4_tbl limit 1) ss on id = f1;
SELECT * FROM x JOIN (SELECT x FROM x LIMIT 1) AS x ON x = x;
DROP TABLE x CASCADE;
/* Test merge-append plans for inheritance trees */ CREATE TABLE x (x SERIAL PRIMARY KEY, x TEXT);
CREATE TABLE x (x INT PRIMARY KEY) INHERITS (x);
CREATE TABLE x (x INT PRIMARY KEY) INHERITS (x);
CREATE TABLE x (x INT PRIMARY KEY) INHERITS (x);
CREATE INDEX x ON x((1 - x) NULLS LAST);
CREATE INDEX x ON x((1 - x) NULLS LAST);
/* intentionally missing */ CREATE INDEX x ON x((1 - x) NULLS LAST);
INSERT INTO x (x) VALUES ('Test 1');
INSERT INTO x (x) VALUES ('Test 2');
INSERT INTO x (x) VALUES ('Test 3');
INSERT INTO x (x) VALUES ('Test 4');
INSERT INTO x (x) VALUES ('Test 5');
INSERT INTO x (x) VALUES ('Test 6');
SET x = off;
/* force use of seqscan/sort, so no merge */ EXPLAIN (verbose, costs off) select * from matest0 order by 1-id;
SELECT * FROM x ORDER BY 1 - x NULLS LAST;
EXPLAIN (verbose, costs off) select min(1-id) from matest0;
SELECT MIN(1 - x) FROM x;
RESET enable_indexscan;
SET x = off;
SET x = off /* plan with fewest seqscans should be merge */;
/* Don't let parallel-append interfere */ EXPLAIN (verbose, costs off) select * from matest0 order by 1-id;
SELECT * FROM x ORDER BY 1 - x NULLS LAST;
EXPLAIN (verbose, costs off) select min(1-id) from matest0;
SELECT MIN(1 - x) FROM x;
RESET enable_seqscan;
RESET enable_parallel_append;
EXPLAIN (verbose, costs off)  -- bug #18652 select 1 - id as c from (select id from matest3 t1 union all select id * 2 from matest3 t2) ss order by c;
SELECT 1 - x AS x FROM (SELECT x FROM x AS x UNION ALL SELECT x * 2 FROM x AS x) AS x ORDER BY x NULLS LAST;
DROP TABLE x CASCADE;
/* Check that use of an index with an extraneous column doesn't produce */ /* a plan with extraneous sorting */ CREATE TABLE x (x INT, x INT, x INT, x INT);
CREATE TABLE x INHERITS (x);
CREATE INDEX x ON x(x NULLS LAST, x NULLS LAST);
CREATE INDEX x ON x(x NULLS LAST, x NULLS LAST);
SET x = off;
/* we want a plan with two MergeAppends */ EXPLAIN (costs off) select t1.* from matest0 t1, matest0 t2 where t1.b = t2.b and t2.c = t2.d order by t1.b limit 10;
RESET enable_nestloop;
DROP TABLE x CASCADE;
/* Test a MergeAppend plan where one child requires a sort */ CREATE TABLE x (x INT PRIMARY KEY);
CREATE TABLE x INHERITS (x);
INSERT INTO x SELECT UNNEST(GENERATE_SERIES(1, 400));
INSERT INTO x SELECT UNNEST(GENERATE_SERIES(1, 200));
ANALYZE x;
ANALYZE x;
EXPLAIN (costs off) select * from matest0 where a < 100 order by a;
DROP TABLE x CASCADE;
SET x = off /* Test merge-append for UNION ALL append relations */;
SET x = on;
SET x = off;
/* Check handling of duplicated, constant, or volatile targetlist items */ EXPLAIN (costs off) SELECT thousand, tenthous FROM tenk1 UNION ALL SELECT thousand, thousand FROM tenk1 ORDER BY thousand, tenthous;
EXPLAIN (costs off) SELECT thousand, tenthous, thousand+tenthous AS x FROM tenk1 UNION ALL SELECT 42, 42, hundred FROM tenk1 ORDER BY thousand, tenthous;
EXPLAIN (costs off) SELECT thousand, tenthous FROM tenk1 UNION ALL SELECT thousand, random()::integer FROM tenk1 ORDER BY thousand, tenthous;
/* Check min/max aggregate optimization */ EXPLAIN (costs off) SELECT min(x) FROM   (SELECT unique1 AS x FROM tenk1 a    UNION ALL    SELECT unique2 AS x FROM tenk1 b) s;
EXPLAIN (costs off) SELECT min(y) FROM   (SELECT unique1 AS x, unique1 AS y FROM tenk1 a    UNION ALL    SELECT unique2 AS x, unique2 AS y FROM tenk1 b) s;
/* XXX planner doesn't recognize that index on unique2 is sufficiently sorted */ EXPLAIN (costs off) SELECT x, y FROM   (SELECT thousand AS x, tenthous AS y FROM tenk1 a    UNION ALL    SELECT unique2 AS x, unique2 AS y FROM tenk1 b) s ORDER BY x, y;
/* exercise rescan code path via a repeatedly-evaluated subquery */ EXPLAIN (costs off) SELECT     ARRAY(SELECT f.i FROM (         (SELECT d + g.i FROM generate_series(4, 30, 3) d ORDER BY 1)         UNION ALL         (SELECT d + g.i FROM generate_series(0, 30, 5) d ORDER BY 1)     ) f(i)     ORDER BY f.i LIMIT 10) FROM generate_series(1, 3) g(i);
SELECT ARRAY(SELECT x.x FROM ((SELECT x + x.x FROM x AS x ORDER BY 1 NULLS LAST) UNION ALL (SELECT x + x.x FROM x AS x ORDER BY 1 NULLS LAST)) AS x ORDER BY x.x NULLS LAST LIMIT 10) FROM x AS x;
RESET enable_seqscan;
RESET enable_indexscan;
RESET enable_bitmapscan;
/* Check handling of MULTIEXPR SubPlans in inherited updates */ CREATE TABLE x (x INT, x NAME);
CREATE TABLE x (x NAME, x INT);
alter table inhcld inherit inhpar;
INSERT INTO x SELECT x, CAST(x AS TEXT) FROM x AS x;
INSERT INTO x SELECT CAST(x AS TEXT), x FROM x AS x;
EXPLAIN (verbose, costs off) update inhpar i set (f1, f2) = (select i.f1, i.f2 || '-' from int4_tbl limit 1);
UPDATE x AS x SET (x, x) = (SELECT x.x, x.x || '-' FROM x LIMIT 1);
SELECT * FROM x;
DROP TABLE x CASCADE;
/* And the same for partitioned cases */ CREATE TABLE x (x INT PRIMARY KEY, x NAME) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x (x NAME, x INT PRIMARY KEY);
CREATE TABLE x (x INT PRIMARY KEY, x NAME);
alter table inhpar attach partition inhcld1 for values from (1) to (5);
alter table inhpar attach partition inhcld2 for values from (5) to (100);
INSERT INTO x SELECT x, CAST(x AS TEXT) FROM x AS x;
EXPLAIN (verbose, costs off) update inhpar i set (f1, f2) = (select i.f1, i.f2 || '-' from int4_tbl limit 1);
UPDATE x AS x SET (x, x) = (SELECT x.x, x.x || '-' FROM x LIMIT 1);
SELECT * FROM x;
/* Also check ON CONFLICT */ INSERT INTO x AS x VALUES (3), (7) ON CONFLICT(x) DO UPDATE SET (x, x) = (SELECT x.x, x.x || '+');
SELECT * FROM x ORDER BY x NULLS LAST;
/* tuple order might be unstable here */ DROP TABLE x CASCADE;
/* Check handling of a constant-null CHECK constraint */ CREATE TABLE x (x INT);
CREATE TABLE x (CHECK (x = 1 OR x = NULL)) INHERITS (x);
INSERT INTO x VALUES (1);
INSERT INTO x VALUES (2);
INSERT INTO x VALUES (NULL);
SELECT * FROM x;
SELECT * FROM x WHERE x = 2;
DROP TABLE x CASCADE;
/* Test inheritance of NOT NULL constraints */ CREATE TABLE x (x INT);
CREATE TABLE x (x TEXT, x INT) INHERITS (x);
CREATE TABLE x (x DOUBLE) INHERITS (x, x);
CREATE TABLE x INHERITS (x, x, x);
ALTER TABLE x ALTER COLUMN x SET NOT NULL;
alter table cc3 no inherit cc1;
alter table cc3 no inherit cc2;
ALTER TABLE x ADD COLUMN x INT CONSTRAINT x NOT NULL /* named NOT NULL constraint */;
ALTER TABLE x ALTER COLUMN x DROP NOT NULL /* remove constraint from cc2: no dice, it's inherited */;
ALTER TABLE x ALTER COLUMN x DROP NOT NULL /* remove constraint from cc1, should succeed */;
ALTER TABLE x ALTER COLUMN x DROP NOT NULL /* remove from pp1, should succeed */;
alter table inh_child inherit inh_parent;
alter table inh_child no inherit inh_parent;
/* test that inhcount is updated correctly through multiple inheritance */ CREATE TABLE x (x INT);
CREATE TABLE x (x TEXT, x INT) INHERITS (x);
CREATE TABLE x (x DOUBLE) INHERITS (x, x);
ALTER TABLE x ALTER COLUMN x SET NOT NULL;
alter table inh_cc2 no inherit inh_pp1;
alter table inh_cc2 no inherit inh_cc1;
CREATE TABLE x (x INT NOT NULL);
CREATE TABLE x (x TEXT, x INT) INHERITS (x);
CREATE TABLE x (x DOUBLE) INHERITS (x, x);
ALTER TABLE x ALTER COLUMN x DROP NOT NULL;
/* Test a not-null addition that must walk down the hierarchy */ CREATE TABLE x;
CREATE TABLE x (x INT) INHERITS (x);
CREATE TABLE x INHERITS (x, x);
ALTER TABLE x ADD COLUMN x INT NOT NULL;
/* Test the same constraint name for different columns in different parents */ CREATE TABLE x (x INT CONSTRAINT x NOT NULL);
CREATE TABLE x (x INT CONSTRAINT x NOT NULL);
CREATE TABLE x INHERITS (x, x);
alter table inh_child2 no inherit inh_parent2;
/* Test multiple parents with overlapping primary keys */ CREATE TABLE x (x INT, x INT, x INT, PRIMARY KEY (x NULLS LAST, x NULLS LAST));
CREATE TABLE x (x INT, x INT, x INT, PRIMARY KEY (x NULLS LAST, x NULLS LAST));
CREATE TABLE x INHERITS (x, x);
SELECT CAST(x AS REGCLASS), x, x, x, x, x, x FROM x WHERE x IN ('n', 'p') AND CAST(CAST(x AS REGCLASS) AS TEXT) IN ('inh_child', 'inh_parent1', 'inh_parent2') ORDER BY 1 NULLS LAST, 2 NULLS LAST;
/* NOT NULL NO INHERIT */ CREATE TABLE x (x INT);
CREATE TABLE x INHERITS (x);
CREATE TABLE x INHERITS (x);
SELECT CAST(x AS REGCLASS), x, x, x, (SELECT x FROM x WHERE x = x AND x = x[0]), x, x, x FROM x WHERE x = 'n' AND CAST(CAST(x AS REGCLASS) AS TEXT) LIKE 'inh\_nn\_%' ORDER BY 2 NULLS LAST, 1 NULLS LAST;
CREATE TABLE x INHERITS (x);
ALTER TABLE inh_nn_parent ADD CONSTRAINT nna NOT NULL a;
ALTER TABLE x ALTER COLUMN x SET NOT NULL;
DROP TABLE x CASCADE;
/* Adding a PK at the top level of a hierarchy should cause all descendants */ /* to be checked for nulls, even past a no-inherit constraint */ CREATE TABLE x (x INT);
CREATE TABLE x INHERITS (x);
ALTER TABLE x ADD PRIMARY KEY (x NULLS LAST);
CREATE TABLE x (x INT NOT NULL);
/* test inherit/deinherit */ CREATE TABLE x (x INT);
CREATE TABLE x (x INT NOT NULL);
CREATE TABLE x (x INT);
/* inh_child1 should have not null constraint */ alter table inh_child1 inherit inh_parent;
/* should fail, missing NOT NULL constraint */ alter table inh_child2 inherit inh_child1;
ALTER TABLE x ALTER COLUMN x SET NOT NULL;
alter table inh_child2 inherit inh_child1;
ALTER TABLE x ALTER COLUMN x SET NOT NULL /* add NOT NULL constraint recursively */;
/* test deinherit procedure */ /* deinherit inh_child1 */ CREATE TABLE x INHERITS (x);
alter table inh_child1 no inherit inh_parent;
/* ALTER TABLE INHERIT ensures that the child has not-null constraints */ CREATE TABLE x (x INT NOT NULL);
CREATE TABLE x (x INT);
alter table inh_child inherit inh_parent;
/* Can't merge a NO INHERIT constraint with a normal one */ CREATE TABLE x (x INT NOT NULL);
alter table inh_child inherit inh_parent;
/* don't interfere with other types of constraints */ CREATE TABLE x (x INT PRIMARY KEY);
CREATE TABLE x (x INT PRIMARY KEY) INHERITS (x);
ALTER TABLE x ADD CONSTRAINT x UNIQUE (x);
ALTER TABLE x ADD CONSTRAINT x FOREIGN KEY (x) REFERENCES x (x);
CREATE TABLE x INHERITS (x);
CREATE TABLE x (LIKE x);
alter table inh_child3 inherit inh_parent;
SELECT CAST(x AS REGCLASS), x, x, x, x FROM x WHERE CAST(CAST(x AS REGCLASS) AS TEXT) IN ('inh_parent', 'inh_child', 'inh_child2', 'inh_child3') ORDER BY 2 NULLS LAST, 1 NULLS LAST;
/* test multi inheritance tree */ CREATE TABLE x (x INT NOT NULL);
CREATE TABLE x INHERITS (x);
CREATE TABLE x INHERITS (x);
CREATE TABLE x INHERITS (x, x);
/* show constraint info */ SELECT CAST(x AS REGCLASS), x, x, x, x FROM x WHERE x = 'n' AND x IN (CAST('inh_parent' AS REGCLASS), CAST('inh_child1' AS REGCLASS), CAST('inh_child2' AS REGCLASS), CAST('inh_child3' AS REGCLASS)) ORDER BY 2 NULLS LAST, CAST(CAST(x AS REGCLASS) AS TEXT) NULLS LAST;
DROP TABLE x CASCADE;
/* test child table with inherited columns and */ /* with explicitly specified not null constraints */ CREATE TABLE x (x INT);
CREATE TABLE x (x TEXT);
CREATE TABLE x (x INT NOT NULL, x TEXT NOT NULL) INHERITS (x, x);
/* show constraint info */ SELECT CAST(x AS REGCLASS), x, x, x, x FROM x WHERE x = 'n' AND x IN (CAST('inh_parent_1' AS REGCLASS), CAST('inh_parent_2' AS REGCLASS), CAST('inh_child' AS REGCLASS)) ORDER BY 2 NULLS LAST, CAST(CAST(x AS REGCLASS) AS TEXT) NULLS LAST;
/* also drops inh_child table */ DROP TABLE x CASCADE;
DROP TABLE x;
/* test multi layer inheritance tree */ CREATE TABLE x (x INT NOT NULL);
CREATE TABLE x (x INT NOT NULL);
CREATE TABLE x (x INT);
CREATE TABLE x (x INT NOT NULL, x TEXT NOT NULL);
CREATE TABLE x INHERITS (x, x, x, x);
/* constraint on f1 should have three parents */ SELECT CAST(x AS REGCLASS), x, x, (SELECT x FROM x WHERE x = x AND x = x[0]), x, x FROM x WHERE x = 'n' AND CAST(x AS REGCLASS) IN ('inh_p1', 'inh_p2', 'inh_p3', 'inh_p4', 'inh_multiparent') ORDER BY CAST(CAST(x AS REGCLASS) AS TEXT) NULLS LAST, x NULLS LAST;
CREATE TABLE x (x INT NOT NULL, x INT) INHERITS (x, x);
SELECT CAST(x AS REGCLASS), x, x, (SELECT x FROM x WHERE x = x AND x = x[0]), x, x FROM x WHERE x = 'n' AND CAST(x AS REGCLASS) IN ('inh_p3', 'inh_multiparent', 'inh_multiparent2') ORDER BY CAST(CAST(x AS REGCLASS) AS TEXT) NULLS LAST, x NULLS LAST;
CREATE TABLE x (x TEXT, x INT, x INT);
alter table inh_nn2 inherit inh_nn1;
CREATE TABLE x (x DOUBLE) INHERITS (x);
CREATE TABLE x (x INT, x DOUBLE, x TEXT, x INT, x INT);
alter table inh_nn4 inherit inh_nn2, inherit inh_nn1, inherit inh_nn3;
ALTER TABLE x ALTER COLUMN x SET DATA TYPE inh_nn1_f1_not_null, set inherit;
SELECT CAST(x AS REGCLASS), x, x, x, x, x FROM x WHERE x = 'n' AND CAST(CAST(x AS REGCLASS) AS TEXT) IN ('inh_nn1', 'inh_nn2', 'inh_nn3', 'inh_nn4') ORDER BY 2 NULLS LAST, 1 NULLS LAST;
ALTER TABLE x ALTER COLUMN x SET DATA TYPE inh_nn1_f1_not_null, set no inherit /* ALTER CONSTRAINT SET NO INHERIT should work on top-level constraints */;
SELECT CAST(x AS REGCLASS), x, x, x, x, x FROM x WHERE x = 'n' AND CAST(CAST(x AS REGCLASS) AS TEXT) IN ('inh_nn1', 'inh_nn2', 'inh_nn3', 'inh_nn4') ORDER BY 2 NULLS LAST, 1 NULLS LAST;
ALTER TABLE x DROP CONSTRAINT x /* A constraint that's NO INHERIT can be dropped without damaging children */;
SELECT CAST(x AS REGCLASS), x, x, x, x FROM x WHERE x = 'n' AND CAST(CAST(x AS REGCLASS) AS TEXT) IN ('inh_nn1', 'inh_nn2', 'inh_nn3', 'inh_nn4') ORDER BY 2 NULLS LAST, 1 NULLS LAST;
CREATE TABLE x (x TEXT, x INT) INHERITS (x);
INSERT INTO x VALUES (NULL, 'sample', 1);
ALTER TABLE x ALTER COLUMN x SET DATA TYPE inh_nn1_f1_not_null, set inherit;
DELETE FROM x;
CREATE TABLE x INHERITS (x);
CREATE TABLE x INHERITS (x, x);
ALTER TABLE x /* test multicommand alter table while at it */ ALTER COLUMN x SET DATA TYPE inh_nn1_f1_not_null, set inherit,    alter constraint inh_nn1_f1_not_null set no inherit;
SELECT CAST(x AS REGCLASS), x, x, x, x FROM x WHERE x = 'n' AND CAST(CAST(x AS REGCLASS) AS TEXT) IN ('inh_nn1', 'inh_nn2', 'inh_nn3', 'inh_nn4') ORDER BY 2 NULLS LAST, 1 NULLS LAST;
CREATE TABLE x (x TEXT, x INT) INHERITS (x);
SELECT CAST(x AS REGCLASS), x, x, x, x, x FROM x WHERE x = 'n' AND CAST(CAST(x AS REGCLASS) AS TEXT) IN ('inh_nn1', 'inh_nn2', 'inh_nn3') ORDER BY 2 NULLS LAST, 1 NULLS LAST;
ALTER TABLE x ALTER COLUMN x SET DATA TYPE inh_nn1_f1_not_null, set inherit /* error: inh_nn3 has an incompatible NO INHERIT constraint */;
ALTER TABLE x ALTER COLUMN x SET DATA TYPE nn3_f1, set inherit;
ALTER TABLE x ALTER COLUMN x SET DATA TYPE inh_nn1_f1_not_null, set inherit;
/* now it works */ SELECT CAST(x AS REGCLASS), x, x, x, x, x FROM x WHERE x = 'n' AND CAST(CAST(x AS REGCLASS) AS TEXT) IN ('inh_nn1', 'inh_nn2', 'inh_nn3') ORDER BY 2 NULLS LAST, 1 NULLS LAST;
/* Negative scenarios for alter constraint .. set inherit. */ CREATE TABLE x (x INT CHECK (x > 5) PRIMARY KEY REFERENCES x, x INT NOT NULL);
ALTER TABLE x ALTER COLUMN x SET DATA TYPE inh_nn1_f1_check, set inherit /* constraints other than not-null are not supported */;
ALTER TABLE x ALTER COLUMN x SET DATA TYPE inh_nn1_pkey, set inherit;
ALTER TABLE x ALTER COLUMN x SET DATA TYPE inh_nn1_f1_fkey, set inherit;
ALTER TABLE x ALTER COLUMN x SET DATA TYPE foo, set inherit /* try to drop a nonexistant constraint */;
/* Can't modify inheritability of inherited constraints */ CREATE TABLE x INHERITS (x);
ALTER TABLE x ALTER COLUMN x SET DATA TYPE inh_nn1_f2_not_null, set no inherit;
/* Mixed ownership inheritance tree */ create role regress_alice;
create role regress_bob;
GRANT ALL ON SCHEMA x TO x, x;
grant regress_alice to regress_bob;
set session authorization regress_alice;
CREATE TABLE x (x INT NOT NULL);
set session authorization regress_bob;
CREATE TABLE x INHERITS (x);
set session authorization regress_alice;
ALTER TABLE x ALTER COLUMN x DROP NOT NULL /* alice can't do this: she doesn't own inh_child */;
set session authorization regress_bob;
ALTER TABLE x ALTER COLUMN x DROP NOT NULL;
RESET session authorization;
REVOKE all on schema public from regress_alice, regress_bob;
drop role regress_alice, regress_bob;
/* Check use of temporary tables with inheritance trees */ CREATE TABLE x (x INT);
CREATE TEMPORARY TABLE x (x INT);
CREATE TEMPORARY TABLE x INHERITS (x);
/* ok */ CREATE TABLE x INHERITS (x);
/* error */ CREATE TEMPORARY TABLE x INHERITS (x);
/* ok */ INSERT INTO x VALUES (1);
INSERT INTO x VALUES (2);
INSERT INTO x VALUES (3);
INSERT INTO x VALUES (4);
SELECT CAST(x AS REGCLASS), x FROM x;
SELECT CAST(x AS REGCLASS), x FROM x;
DROP TABLE x CASCADE;
DROP TABLE x CASCADE;
/* Check that constraint exclusion works correctly with partitions using */ /* implicit constraints generated from the partition bound information. */ CREATE TABLE x (x VARCHAR) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN ('ab', 'cd');
CREATE TABLE x PARTITION OF x FOR VALUES IN ('ef', 'gh');
CREATE TABLE x PARTITION OF x FOR VALUES IN (NULL, 'xy');
EXPLAIN (costs off) select * from list_parted;
EXPLAIN (costs off) select * from list_parted where a is null;
EXPLAIN (costs off) select * from list_parted where a is not null;
EXPLAIN (costs off) select * from list_parted where a in ('ab', 'cd', 'ef');
EXPLAIN (costs off) select * from list_parted where a = 'ab' or a in (null, 'cd');
EXPLAIN (costs off) select * from list_parted where a = 'ab';
CREATE TABLE x (x INT, x CHAR(2)) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (1) TO (10) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN ('ab');
CREATE TABLE x PARTITION OF x FOR VALUES IN ('cd');
CREATE TABLE x PARTITION OF x FOR VALUES FROM (10) TO (20) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN ('ab');
CREATE TABLE x PARTITION OF x FOR VALUES IN ('cd');
CREATE TABLE x PARTITION OF x FOR VALUES FROM (21) TO (30) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN ('ab');
CREATE TABLE x PARTITION OF x FOR VALUES IN ('cd');
CREATE TABLE x PARTITION OF x FOR VALUES FROM (40) TO (MAXVALUE) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN ('ab');
CREATE TABLE x PARTITION OF x FOR VALUES IN ('cd');
CREATE TABLE x PARTITION OF x FOR VALUES IN (NULL);
EXPLAIN (costs off) select * from range_list_parted;
EXPLAIN (costs off) select * from range_list_parted where a = 5;
EXPLAIN (costs off) select * from range_list_parted where b = 'ab';
EXPLAIN (costs off) select * from range_list_parted where a between 3 and 23 and b in ('ab');
/* Should select no rows because range partition key cannot be null */ EXPLAIN (costs off) select * from range_list_parted where a is null;
/* Should only select rows from the null-accepting partition */ EXPLAIN (costs off) select * from range_list_parted where b is null;
EXPLAIN (costs off) select * from range_list_parted where a is not null and a < 67;
EXPLAIN (costs off) select * from range_list_parted where a >= 30;
DROP TABLE x;
DROP TABLE x;
/* check that constraint exclusion is able to cope with the partition */ /* constraint emitted for multi-column range partitioned tables */ CREATE TABLE x (x INT, x INT, x INT) WITH (PARTITIONED_BY=RANGE(x, ABS(x), x));
CREATE TABLE x PARTITION OF x DEFAULT;
CREATE TABLE x PARTITION OF x FOR VALUES FROM (MINVALUE, MINVALUE, MINVALUE) TO (1, 1, 1);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (1, 1, 1) TO (10, 5, 10);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (10, 5, 10) TO (10, 10, 10);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (11, 1, 1) TO (20, 10, 10);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (20, 10, 10) TO (20, 20, 20);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (20, 20, 20) TO (MAXVALUE, MAXVALUE, MAXVALUE);
EXPLAIN (costs off) select * from mcrparted where a = 0;
/* scans mcrparted0, mcrparted_def */ EXPLAIN (costs off) select * from mcrparted where a = 10 and abs(b) < 5;
/* scans mcrparted1, mcrparted_def */ EXPLAIN (costs off) select * from mcrparted where a = 10 and abs(b) = 5;
/* scans mcrparted1, mcrparted2, mcrparted_def */ EXPLAIN (costs off) select * from mcrparted where abs(b) = 5;
/* scans all partitions */ EXPLAIN (costs off) select * from mcrparted where a > -1;
/* scans all partitions */ EXPLAIN (costs off) select * from mcrparted where a = 20 and abs(b) = 10 and c > 10;
/* scans mcrparted4 */ EXPLAIN (costs off) select * from mcrparted where a = 20 and c > 20;
/* scans mcrparted3, mcrparte4, mcrparte5, mcrparted_def */ /* check that partitioned table Appends cope with being referenced in */ /* subplans */ CREATE TABLE x (x INT, x VARCHAR(16)) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (1) TO (10);
CREATE INDEX x ON x(x NULLS LAST, x NULLS LAST);
INSERT INTO x VALUES (1, '12345');
EXPLAIN (costs off) select min(a), max(a) from parted_minmax where b = '12345';
SELECT MIN(x), MAX(x) FROM x WHERE x = '12345';
DROP TABLE x;
/* Test code that uses Append nodes in place of MergeAppend when the */ /* partition ordering matches the desired ordering. */ CREATE INDEX x ON x(x NULLS LAST, ABS(x) NULLS LAST, x NULLS LAST);
/* MergeAppend must be used when a default partition exists */ EXPLAIN (costs off) select * from mcrparted order by a, abs(b), c;
DROP TABLE x;
/* Append is used for a RANGE partitioned table with no default */ /* and no subpartitions */ EXPLAIN (costs off) select * from mcrparted order by a, abs(b), c;
/* Append is used with subpaths in reverse order with backwards index scans */ EXPLAIN (costs off) select * from mcrparted order by a desc, abs(b) desc, c desc;
/* check that Append plan is used containing a MergeAppend for sub-partitions */ /* that are unordered. */ DROP TABLE x;
CREATE TABLE x PARTITION OF x FOR VALUES FROM (20, 20, 20) TO (MAXVALUE, MAXVALUE, MAXVALUE) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN (20);
CREATE TABLE x PARTITION OF x DEFAULT;
EXPLAIN (costs off) select * from mcrparted order by a, abs(b), c;
DROP TABLE x;
/* check that an Append plan is used and the sub-partitions are flattened */ /* into the main Append when the sub-partition is unordered but contains */ /* just a single sub-partition. */ EXPLAIN (costs off) select a, abs(b) from mcrparted order by a, abs(b), c;
/* check that Append is used when the sub-partitioned tables are pruned */ /* during planning. */ EXPLAIN (costs off) select * from mcrparted where a < 20 order by a, abs(b), c;
SET x = off;
SET x = off;
CREATE TABLE x (x INT) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN (1);
CREATE TABLE x PARTITION OF x FOR VALUES IN (2);
CREATE INDEX ON x(x NULLS LAST);
/* Ensure an Append is used for a list partition with an order by. */ EXPLAIN (costs off) select * from mclparted order by a;
/* Ensure a MergeAppend is used when a partition exists with interleaved */ /* datums in the partition bound. */ CREATE TABLE x PARTITION OF x FOR VALUES IN (3, 5);
CREATE TABLE x PARTITION OF x FOR VALUES IN (4);
EXPLAIN (costs off) select * from mclparted order by a;
EXPLAIN (costs off) select * from mclparted where a in(3,4,5) order by a;
/* Introduce a NULL and DEFAULT partition so we can test more complex cases */ CREATE TABLE x PARTITION OF x FOR VALUES IN (NULL);
CREATE TABLE x PARTITION OF x DEFAULT;
/* Append can be used providing we don't scan the interleaved partition */ EXPLAIN (costs off) select * from mclparted where a in(1,2,4) order by a;
EXPLAIN (costs off) select * from mclparted where a in(1,2,4) or a is null order by a;
/* Test a more complex case where the NULL partition allows some other value */ DROP TABLE x;
CREATE TABLE x PARTITION OF x FOR VALUES IN (0, NULL);
/* Ensure MergeAppend is used since 0 and NULLs are in the same partition. */ EXPLAIN (costs off) select * from mclparted where a in(1,2,4) or a is null order by a;
EXPLAIN (costs off) select * from mclparted where a in(0,1,2,4) order by a;
/* Ensure Append is used when the null partition is pruned */ EXPLAIN (costs off) select * from mclparted where a in(1,2,4) order by a;
/* Ensure MergeAppend is used when the default partition is not pruned */ EXPLAIN (costs off) select * from mclparted where a in(1,2,4,100) order by a;
DROP TABLE x;
RESET enable_sort;
RESET enable_bitmapscan;
/* Ensure subplans which don't have a path with the correct pathkeys get */ /* sorted correctly. */ DROP INDEX x;
CREATE INDEX ON x(x NULLS LAST, ABS(x) NULLS LAST, x NULLS LAST);
CREATE INDEX ON x(x NULLS LAST, ABS(x) NULLS LAST, x NULLS LAST);
CREATE INDEX ON x(x NULLS LAST, ABS(x) NULLS LAST, x NULLS LAST);
CREATE INDEX ON x(x NULLS LAST, ABS(x) NULLS LAST, x NULLS LAST);
EXPLAIN (costs off) select * from mcrparted where a < 20 order by a, abs(b), c limit 1;
SET x = 0;
/* Ensure Append node can be used when the partition is ordered by some */ /* pathkeys which were deemed redundant. */ EXPLAIN (costs off) select * from mcrparted where a = 10 order by a, abs(b), c;
RESET enable_bitmapscan;
DROP TABLE x;
/* Ensure LIST partitions allow an Append to be used instead of a MergeAppend */ CREATE TABLE x (x BOOLEAN) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN (TRUE);
CREATE TABLE x PARTITION OF x FOR VALUES IN (FALSE);
CREATE INDEX ON x(x NULLS LAST);
EXPLAIN (costs off) select * from bool_lp order by b;
DROP TABLE x;
/* Ensure const bool quals can be properly detected as redundant */ CREATE TABLE x (x BOOLEAN, x INT) WITH (PARTITIONED_BY=RANGE(x, x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (FALSE, 0) TO (FALSE, 1000);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (TRUE, 0) TO (TRUE, 1000);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (FALSE, 1000) TO (FALSE, 2000);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (TRUE, 1000) TO (TRUE, 2000);
CREATE INDEX ON x(x NULLS LAST, x NULLS LAST);
EXPLAIN (costs off) select * from bool_rp where b = true order by b,a;
EXPLAIN (costs off) select * from bool_rp where b = false order by b,a;
EXPLAIN (costs off) select * from bool_rp where b = true order by a;
EXPLAIN (costs off) select * from bool_rp where b = false order by a;
DROP TABLE x;
/* Ensure an Append scan is chosen when the partition order is a subset of */ /* the required order. */ CREATE TABLE x (x INT, x INT, x INT) WITH (PARTITIONED_BY=RANGE(x, x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (0, 0) TO (10, 10);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (10, 10) TO (20, 20);
CREATE INDEX ON x(x NULLS LAST, x NULLS LAST, x NULLS LAST);
EXPLAIN (costs off) select * from range_parted order by a,b,c;
EXPLAIN (costs off) select * from range_parted order by a desc,b desc,c desc;
DROP TABLE x;
/* Check that we allow access to a child table's statistics when the user */ /* has permissions only for the parent table. */ CREATE TABLE x (x INT, x TEXT, x TEXT) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x (x TEXT, x TEXT, x INT) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x (x TEXT, x TEXT, x INT);
alter table permtest_child attach partition permtest_grandchild for values in ('a');
alter table permtest_parent attach partition permtest_child for values in (1);
CREATE INDEX ON x(LEFT(x, 3) NULLS LAST);
INSERT INTO x SELECT 1, 'a', LEFT(FIPSHASH(CAST(x AS TEXT)), 5) FROM x AS x;
ANALYZE x;
create role regress_no_child_access;
REVOKE all on permtest_grandchild from regress_no_child_access;
GRANT SELECT ON x TO x;
set session authorization regress_no_child_access;
/* without stats access, these queries would produce hash join plans: */ EXPLAIN (costs off)   select * from permtest_parent p1 inner join permtest_parent p2   on p1.a = p2.a and p1.c ~ 'a1$';
EXPLAIN (costs off)   select * from permtest_parent p1 inner join permtest_parent p2   on p1.a = p2.a and left(p1.c, 3) ~ 'a1$';
RESET session authorization;
REVOKE all on permtest_parent from regress_no_child_access;
GRANT SELECT(x, x) ON x TO x;
set session authorization regress_no_child_access;
EXPLAIN (costs off)   select p2.a, p1.c from permtest_parent p1 inner join permtest_parent p2   on p1.a = p2.a and p1.c ~ 'a1$';
/* we will not have access to the expression index's stats here: */ EXPLAIN (costs off)   select p2.a, p1.c from permtest_parent p1 inner join permtest_parent p2   on p1.a = p2.a and left(p1.c, 3) ~ 'a1$';
RESET session authorization;
REVOKE all on permtest_parent from regress_no_child_access;
drop role regress_no_child_access;
DROP TABLE x;
/* Verify that constraint errors across partition root / child are */ /* handled correctly (Bug #16293) */ CREATE TABLE x (x INT NOT NULL, x INT NOT NULL, x INT NOT NULL DEFAULT 0, CONSTRAINT x CHECK (x < 3)) WITH (PARTITIONED_BY=RANGE(x));
/* fast defaults lead to attribute mapping being used in one */ /* direction, but not the other */ CREATE TABLE x (x INT NOT NULL, x INT NOT NULL, CONSTRAINT x CHECK (x < 3));
/* no remapping in either direction necessary */ CREATE TABLE x (x INT NOT NULL, x INT NOT NULL, x INT NOT NULL DEFAULT 0, CONSTRAINT x CHECK (x < 3), CHECK (x < 10));
/* remapping in both direction */ CREATE TABLE x (x INT NOT NULL DEFAULT 0, x INT NOT NULL, x INT NOT NULL, CONSTRAINT x CHECK (x < 3), CHECK (x < 10));
ALTER TABLE x ADD COLUMN x INT NOT NULL DEFAULT 0;
ALTER TABLE x ADD CONSTRAINT x CHECK (x < 10);
ALTER TABLE errtst_parent ATTACH PARTITION errtst_child_fastdef FOR VALUES FROM (0) TO (10);
ALTER TABLE errtst_parent ATTACH PARTITION errtst_child_plaindef FOR VALUES FROM (10) TO (20);
ALTER TABLE errtst_parent ATTACH PARTITION errtst_child_reorder FOR VALUES FROM (20) TO (30);
/* insert without child check constraint error */ INSERT INTO x (x, x, x) VALUES ('0', '1', '5');
INSERT INTO x (x, x, x) VALUES ('10', '1', '5');
INSERT INTO x (x, x, x) VALUES ('20', '1', '5');
/* insert with child check constraint error */ INSERT INTO x (x, x, x) VALUES ('0', '1', '10');
INSERT INTO x (x, x, x) VALUES ('10', '1', '10');
INSERT INTO x (x, x, x) VALUES ('20', '1', '10');
/* insert with child not null constraint error */ INSERT INTO x (x, x, x) VALUES ('0', '1', NULL);
INSERT INTO x (x, x, x) VALUES ('10', '1', NULL);
INSERT INTO x (x, x, x) VALUES ('20', '1', NULL);
/* insert with shared check constraint error */ INSERT INTO x (x, x, x) VALUES ('0', '5', '5');
INSERT INTO x (x, x, x) VALUES ('10', '5', '5');
INSERT INTO x (x, x, x) VALUES ('20', '5', '5');
/* within partition update without child check constraint violation */ BEGIN;
UPDATE x SET x = x + 1 WHERE x = 0;
UPDATE x SET x = x + 1 WHERE x = 10;
UPDATE x SET x = x + 1 WHERE x = 20;
ROLLBACK;
/* within partition update with child check constraint violation */ UPDATE x SET x = x + 10 WHERE x = 0;
UPDATE x SET x = x + 10 WHERE x = 10;
UPDATE x SET x = x + 10 WHERE x = 20;
/* direct leaf partition update, without partition id violation */ BEGIN;
UPDATE x SET x = 1 WHERE x = 0;
UPDATE x SET x = 11 WHERE x = 10;
UPDATE x SET x = 21 WHERE x = 20;
ROLLBACK;
/* direct leaf partition update, with partition id violation */ UPDATE x SET x = x + 10 WHERE x = 0;
UPDATE x SET x = x + 10 WHERE x = 10;
UPDATE x SET x = x + 10 WHERE x = 20;
/* partition move, without child check constraint violation */ BEGIN;
UPDATE x SET x = 10, x = x + 1 WHERE x = 0;
UPDATE x SET x = 20, x = x + 1 WHERE x = 10;
UPDATE x SET x = 0, x = x + 1 WHERE x = 20;
ROLLBACK;
/* partition move, with child check constraint violation */ UPDATE x SET x = 10, x = x + 10 WHERE x = 0;
UPDATE x SET x = 20, x = x + 10 WHERE x = 10;
UPDATE x SET x = 0, x = x + 10 WHERE x = 20;
/* partition move, without target partition */ UPDATE x SET x = 30, x = x + 10 WHERE x = 20;
DROP TABLE x;
/* Check that we have the correct tuples estimate for an appendrel */ CREATE TABLE x (x INT, x INT, x DOUBLE) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (0) TO (100);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (100) TO (200);
CREATE TABLE x (x INT, x INT);
INSERT INTO x SELECT x % 200, x % 300, x % 400 FROM x AS x;
INSERT INTO x SELECT x, x FROM x AS x;
ANALYZE x;
ANALYZE x;
EXPLAIN (costs off) select * from tuplesest_tab join   (select b from tuplesest_parted where c < 100 group by b) sub   on tuplesest_tab.a = sub.b;
DROP TABLE x;
DROP TABLE x;
/* Test initial privileges */ /* There should always be some initial privileges, set up by initdb */ SELECT COUNT(*) > 0 FROM x;
GRANT SELECT ON x TO x /* Intentionally include some non-initial privs for pg_dump to dump out */;
GRANT SELECT(x) ON x TO x;
GRANT SELECT(x, x) ON x TO x;
/* insert with DEFAULT in the target_list */ CREATE TABLE x (x INT, x INT NOT NULL, x TEXT DEFAULT 'testing');
INSERT INTO x (x, x, x) VALUES (DEFAULT, DEFAULT, DEFAULT);
INSERT INTO x (x, x) VALUES (3, DEFAULT);
INSERT INTO x (x, x, x) VALUES (DEFAULT, 5, DEFAULT);
INSERT INTO x VALUES (DEFAULT, 5, 'test');
INSERT INTO x VALUES (DEFAULT, 7);
SELECT * FROM x;
/* insert with similar expression / target_list values (all fail) */ INSERT INTO x (x, x, x) VALUES (DEFAULT, DEFAULT);
INSERT INTO x (x, x, x) VALUES (1, 2);
INSERT INTO x (x) VALUES (1, 2);
INSERT INTO x (x) VALUES (DEFAULT, DEFAULT);
SELECT * FROM x;
/* VALUES test */ INSERT INTO x VALUES (10, 20, '40'), (-1, 2, DEFAULT), ((SELECT 2), (SELECT x FROM (VALUES (3)) AS x), 'values are fun!');
SELECT * FROM x;
/* TOASTed value test */ INSERT INTO x VALUES (30, 50, REPEAT('x', 10000));
SELECT x, x, LENGTH(x) FROM x;
DROP TABLE x;
/* tuple larger than fillfactor */ CREATE TABLE x (x INT, x TEXT) WITH (fillfactor=10);
ALTER TABLE x ALTER COLUMN x DROP DEFAULT, SET STORAGE plain;
/* create page w/ free space in range [nearlyEmptyFreeSpace, MaxHeapTupleSize) */ INSERT INTO x (SELECT 1, NULL);
/* should still fit on the page */ INSERT INTO x (SELECT 2, REPEAT('a', 1000));
SELECT PG_SIZE_PRETTY(PG_RELATION_SIZE(CAST('large_tuple_test' AS REGCLASS), 'main'));
/* add small record to the second page */ INSERT INTO x (SELECT 3, NULL);
/* now this tuple won't fit on the second page, but the insert should */ /* still succeed by extending the relation */ INSERT INTO x (SELECT 4, REPEAT('a', 8126));
DROP TABLE x;
/* check indirection (field/array assignment), cf bug #14265 */ /* these tests are aware that transformInsertStmt has 3 separate code paths */ create type insert_test_type as (if1 int, if2 text[]);
CREATE TABLE x (x INT, x ARRAY<INT>, x insert_test_type, x ARRAY<insert_test_type>);
SELECT * FROM x;
/* also check reverse-listing */ CREATE TABLE x (x BIGINT, x TEXT);
create rule irule1 as on insert to inserttest2 do also   insert into inserttest (f3.if2[1], f3.if2[2])   values (new.f1,new.f2);
create rule irule2 as on insert to inserttest2 do also   insert into inserttest (f4[1].if1, f4[1].if2[2])   values (1,'fool'),(new.f1,new.f2);
create rule irule3 as on insert to inserttest2 do also   insert into inserttest (f4[1].if1, f4[1].if2[2])   select new.f1, new.f2;
DROP TABLE x;
/* Make the same tests with domains over the array and composite fields */ create domain insert_pos_ints as int[] check (value[1] > 0);
create domain insert_test_domain as insert_test_type   check ((value).if2[1] is not null);
CREATE TABLE x (x INT, x insert_pos_ints);
CREATE TABLE x (x insert_test_domain, x ARRAY<insert_test_domain>);
SELECT * FROM x;
SELECT * FROM x;
/* also check reverse-listing */ CREATE TABLE x (x BIGINT, x TEXT);
create rule irule1 as on insert to inserttest2 do also   insert into inserttestb (f3.if2[1], f3.if2[2])   values (new.f1,new.f2);
create rule irule2 as on insert to inserttest2 do also   insert into inserttestb (f4[1].if1, f4[1].if2[2])   values (1,'fool'),(new.f1,new.f2);
create rule irule3 as on insert to inserttest2 do also   insert into inserttestb (f4[1].if1, f4[1].if2[2])   select new.f1, new.f2;
DROP TABLE x;
DROP TABLE x;
drop domain insert_pos_ints;
drop domain insert_test_domain;
/* Verify that multiple inserts to subfields of a domain-over-container */ /* check the domain constraints only on the finished value */ create domain insert_nnarray as int[]   check (value[1] is not null and value[2] is not null);
create domain insert_test_domain as insert_test_type   check ((value).if1 is not null and (value).if2 is not null);
CREATE TABLE x (x insert_nnarray);
CREATE TABLE x (x insert_test_domain);
DROP TABLE x;
DROP TABLE x;
drop domain insert_nnarray;
drop type insert_test_type cascade;
/* direct partition inserts should check partition bound constraint */ CREATE TABLE x (x TEXT, x INT) WITH (PARTITIONED_BY=RANGE(x, (x + 0)));
/* no partitions, so fail */ INSERT INTO x VALUES ('a', 11);
CREATE TABLE x PARTITION OF x FOR VALUES FROM ('a', 1) TO ('a', 10);
CREATE TABLE x PARTITION OF x FOR VALUES FROM ('a', 10) TO ('a', 20);
CREATE TABLE x PARTITION OF x FOR VALUES FROM ('b', 1) TO ('b', 10);
CREATE TABLE x PARTITION OF x FOR VALUES FROM ('b', 10) TO ('b', 20);
/* fail */ INSERT INTO x VALUES ('a', 11);
INSERT INTO x VALUES ('b', 1);
/* ok */ INSERT INTO x VALUES ('a', 1);
/* fail */ INSERT INTO x VALUES ('b', 21);
INSERT INTO x VALUES ('a', 10);
/* ok */ INSERT INTO x VALUES ('b', 10);
/* fail (partition key a has a NOT NULL constraint) */ INSERT INTO x VALUES (NULL);
/* fail (expression key (b+0) cannot be null either) */ INSERT INTO x VALUES (1);
CREATE TABLE x (x TEXT, x INT) WITH (PARTITIONED_BY=LIST(LOWER(x)));
CREATE TABLE x PARTITION OF x FOR VALUES IN ('aa', 'bb');
CREATE TABLE x PARTITION OF x FOR VALUES IN ('cc', 'dd');
CREATE TABLE x PARTITION OF x FOR VALUES IN (NULL);
/* fail */ INSERT INTO x VALUES ('cc', 1);
INSERT INTO x VALUES ('AAa', 1);
INSERT INTO x VALUES (NULL);
/* ok */ INSERT INTO x VALUES ('cC', 1);
INSERT INTO x VALUES (NULL, 0);
/* check in case of multi-level partitioned table */ CREATE TABLE x PARTITION OF x FOR VALUES IN ('ee', 'ff') WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (1) TO (10);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (10) TO (20);
/* test default partition */ CREATE TABLE x PARTITION OF x DEFAULT;
/* Negative test: a row, which would fit in other partition, does not fit */ /* default partition, even when inserted directly */ INSERT INTO x VALUES ('aa', 2);
INSERT INTO x VALUES (NULL, 2);
/* ok */ INSERT INTO x VALUES ('Zz', 2);
/* test if default partition works as expected for multi-level partitioned */ /* table as well as when default partition itself is further partitioned */ DROP TABLE x;
CREATE TABLE x PARTITION OF x FOR VALUES IN ('xx', 'yy') WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN ('xx');
CREATE TABLE x PARTITION OF x DEFAULT;
CREATE TABLE x PARTITION OF x DEFAULT WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (20) TO (30);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (30) TO (40);
/* fail */ INSERT INTO x VALUES ('EE', 11);
INSERT INTO x VALUES ('gg', 43);
/* fail (even the parent's, ie, part_ee_ff's partition constraint applies) */ INSERT INTO x VALUES ('cc', 1);
INSERT INTO x VALUES ('gg', 43);
/* ok */ INSERT INTO x VALUES ('ff', 1);
INSERT INTO x VALUES ('ff', 11);
INSERT INTO x VALUES ('cd', 25);
INSERT INTO x VALUES ('de', 35);
INSERT INTO x VALUES ('ab', 21);
INSERT INTO x VALUES ('xx', 1);
INSERT INTO x VALUES ('yy', 2);
SELECT CAST(x AS REGCLASS), * FROM x;
/* Check tuple routing for partitioned tables */ /* fail */ INSERT INTO x VALUES ('a', 0);
/* ok */ INSERT INTO x VALUES ('a', 1);
INSERT INTO x VALUES ('a', 10);
/* fail */ INSERT INTO x VALUES ('a', 20);
/* ok */ INSERT INTO x VALUES ('b', 1);
INSERT INTO x VALUES ('b', 10);
/* fail (partition key (b+0) is null) */ INSERT INTO x VALUES ('a');
/* Check default partition */ CREATE TABLE x PARTITION OF x DEFAULT;
/* fail */ INSERT INTO x VALUES ('b', 10);
/* ok */ INSERT INTO x VALUES ('c', 10);
INSERT INTO x VALUES (NULL, NULL);
INSERT INTO x VALUES ('a', NULL);
INSERT INTO x VALUES (NULL, 19);
INSERT INTO x VALUES ('b', 20);
SELECT CAST(x AS REGCLASS), * FROM x;
/* ok */ INSERT INTO x VALUES (NULL, 1);
INSERT INTO x (x) VALUES ('aA');
/* fail (partition of part_ee_ff not found in both cases) */ INSERT INTO x VALUES ('EE', 0);
INSERT INTO x VALUES ('EE', 0);
/* ok */ INSERT INTO x VALUES ('EE', 1);
INSERT INTO x VALUES ('EE', 10);
SELECT CAST(x AS REGCLASS), * FROM x;
/* some more tests to exercise tuple-routing with multi-level partitioning */ CREATE TABLE x PARTITION OF x FOR VALUES IN ('gg') WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (MINVALUE) TO (1);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (1) TO (10) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (1) TO (5);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (5) TO (10);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (20) TO (30) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (20) TO (25);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (25) TO (30);
TRUNCATE TABLE x;
INSERT INTO x VALUES ('aa'), ('cc');
INSERT INTO x SELECT 'Ff', x.x FROM x AS x;
INSERT INTO x SELECT 'gg', x.x FROM x AS x;
INSERT INTO x (x) VALUES (1);
SELECT CAST(CAST(x AS REGCLASS) AS TEXT), x, MIN(x) AS x, MAX(x) AS x FROM x GROUP BY 1, 2 ORDER BY 1 NULLS LAST;
CREATE TABLE x PARTITION OF x FOR VALUES WITH (MODULUS 4, REMAINDER 0);
CREATE TABLE x PARTITION OF x FOR VALUES WITH (MODULUS 4, REMAINDER 1);
CREATE TABLE x PARTITION OF x FOR VALUES WITH (MODULUS 4, REMAINDER 2);
CREATE TABLE x PARTITION OF x FOR VALUES WITH (MODULUS 4, REMAINDER 3);
INSERT INTO x VALUES (UNNEST(GENERATE_SERIES(1, 10)));
INSERT INTO x VALUES (12), (16);
INSERT INTO x VALUES (11);
/* 11 % 4 -> 3 remainder i.e. valid data for hpart3 partition */ INSERT INTO x VALUES (11);
/* view data */ SELECT CAST(x AS REGCLASS) AS x, x, x % 4 AS "x" FROM x ORDER BY x NULLS LAST;
DROP TABLE x;
/* test that a default partition added as the first partition accepts any value */ /* including null */ CREATE TABLE x (x INT) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x DEFAULT;
INSERT INTO x VALUES (1);
INSERT INTO x VALUES (-1);
SELECT CAST(x AS REGCLASS), x FROM x;
/* cleanup */ DROP TABLE x;
/* more tests for certain multi-level partitioning scenarios */ CREATE TABLE x (x INT, x INT) WITH (PARTITIONED_BY=RANGE(x, x));
CREATE TABLE x (x INT NOT NULL, x INT NOT NULL) WITH (PARTITIONED_BY=RANGE((x + 0)));
CREATE TABLE x (LIKE x);
ALTER TABLE x drop a;
ALTER TABLE x ADD COLUMN x INT;
ALTER TABLE x drop a;
ALTER TABLE x ADD COLUMN x INT NOT NULL;
/* attnum for key attribute 'a' is different in mlparted, mlparted1, and mlparted11 */ SELECT CAST(x AS REGCLASS), x, x FROM x WHERE x = 'a' AND (x = CAST('mlparted' AS REGCLASS) OR x = CAST('mlparted1' AS REGCLASS) OR x = CAST('mlparted11' AS REGCLASS)) ORDER BY CAST(CAST(x AS REGCLASS) AS TEXT) NULLS LAST;
alter table mlparted1 attach partition mlparted11 for values from (2) to (5);
alter table mlparted attach partition mlparted1 for values from (1, 2) to (1, 10);
/* check that "(1, 2)" is correctly routed to mlparted11. */ INSERT INTO x VALUES (1, 2);
SELECT CAST(x AS REGCLASS), * FROM x;
/* check that proper message is shown after failure to route through mlparted1 */ INSERT INTO x (x, x) VALUES (1, 5);
TRUNCATE TABLE x;
ALTER TABLE x ADD CONSTRAINT x CHECK (x = 3);
x AS x;
COMMIT;
create trigger mlparted11_trig before insert ON mlparted11   for each row execute procedure mlparted11_trig_fn();
/* check that the correct row is shown when constraint check_b fails after */ /* "(1, 2)" is routed to mlparted11 (actually "(1, 4)" would be shown due */ /* to the BR trigger mlparted11_trig_fn) */ INSERT INTO x VALUES (1, 2);
drop trigger mlparted11_trig on mlparted11;
DROP FUNCTION x;
/* check that inserting into an internal partition successfully results in */ /* checking its partition constraint before inserting into the leaf partition */ /* selected by tuple-routing */ INSERT INTO x (x, x) VALUES (2, 3);
/* check routing error through a list partitioned table when the key is null */ CREATE TABLE x (x INT, x CHAR) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN ('a');
INSERT INTO x VALUES (1);
DROP TABLE x;
ALTER TABLE x DROP CONSTRAINT x /* check that RETURNING works correctly with tuple-routing */;
CREATE TABLE x PARTITION OF x FOR VALUES FROM (5) TO (10);
CREATE TABLE x (x INT NOT NULL, x INT NOT NULL);
alter table mlparted attach partition mlparted2 for values from (1, 10) to (1, 20);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (1, 20) TO (1, 30);
CREATE TABLE x (LIKE x);
ALTER TABLE x drop a;
ALTER TABLE x ADD COLUMN x INT NOT NULL;
alter table mlparted attach partition mlparted4 for values from (1, 30) to (1, 40);
WITH x AS (INSERT INTO x (x, x) SELECT x.x, 1 FROM x AS x RETURNING CAST(x AS REGCLASS), *) SELECT x, x, MIN(x), MAX(x) FROM x GROUP BY x, x ORDER BY 1 NULLS LAST;
ALTER TABLE x ADD COLUMN x TEXT;
CREATE TABLE x (x TEXT, x INT NOT NULL, x INT NOT NULL) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x (x INT NOT NULL, x TEXT, x INT NOT NULL);
alter table mlparted5 attach partition mlparted5a for values in ('a');
alter table mlparted attach partition mlparted5 for values from (1, 40) to (1, 50);
ALTER TABLE x ADD CONSTRAINT x CHECK (x = 1 AND x < 45);
INSERT INTO x VALUES (1, 45, 'a');
x AS x;
COMMIT;
create trigger mlparted5abrtrig before insert on mlparted5a for each row execute procedure mlparted5abrtrig_func();
INSERT INTO x (x, x, x) VALUES (1, 40, 'a');
DROP TABLE x;
ALTER TABLE x DROP CONSTRAINT x;
/* Check multi-level default partition */ CREATE TABLE x PARTITION OF x DEFAULT WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (40) TO (50);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (50) TO (60);
INSERT INTO x VALUES (40, 100);
INSERT INTO x VALUES (42, 100);
INSERT INTO x VALUES (54, 50);
/* fail */ INSERT INTO x VALUES (70, 100);
INSERT INTO x VALUES (52, 50);
INSERT INTO x VALUES (34, 50);
/* ok */ CREATE TABLE x PARTITION OF x DEFAULT;
INSERT INTO x VALUES (70, 100);
SELECT CAST(x AS REGCLASS), * FROM x;
ALTER TABLE x ADD COLUMN x INT, ADD COLUMN x INT /* Check multi-level tuple routing with attributes dropped from the */ /* top-most parent.  First remove the last attribute. */;
ALTER TABLE x drop e;
CREATE TABLE x PARTITION OF x FOR VALUES FROM (1, 40) TO (1, 50) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM ('a') TO ('c') WITH (PARTITIONED_BY=LIST(x));
/* This partitioned table should remain with no partitions. */ CREATE TABLE x PARTITION OF x FOR VALUES FROM ('c') TO ('e') WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN ('a');
CREATE TABLE x (x INT, x INT, x TEXT, x INT);
alter table mlparted5_ab attach partition mlparted5_b for values in ('b');
TRUNCATE TABLE x;
INSERT INTO x VALUES (1, 2, 'a', 1);
INSERT INTO x VALUES (1, 40, 'a', 1);
/* goes to mlparted5_a */ INSERT INTO x VALUES (1, 45, 'b', 1);
/* goes to mlparted5_b */ INSERT INTO x VALUES (1, 45, 'c', 1);
/* goes to mlparted5_cd, fails */ INSERT INTO x VALUES (1, 45, 'f', 1);
/* goes to mlparted5, fails */ SELECT CAST(x AS REGCLASS), * FROM x ORDER BY x NULLS LAST, x NULLS LAST, x NULLS LAST, x NULLS LAST;
ALTER TABLE x drop d;
TRUNCATE TABLE x;
ALTER TABLE x ADD COLUMN x INT, ADD COLUMN x INT /* Remove the before last attribute. */;
ALTER TABLE x drop e;
INSERT INTO x VALUES (1, 2, 'a', 1);
INSERT INTO x VALUES (1, 40, 'a', 1);
/* goes to mlparted5_a */ INSERT INTO x VALUES (1, 45, 'b', 1);
/* goes to mlparted5_b */ INSERT INTO x VALUES (1, 45, 'c', 1);
/* goes to mlparted5_cd, fails */ INSERT INTO x VALUES (1, 45, 'f', 1);
/* goes to mlparted5, fails */ SELECT CAST(x AS REGCLASS), * FROM x ORDER BY x NULLS LAST, x NULLS LAST, x NULLS LAST, x NULLS LAST;
ALTER TABLE x drop d;
DROP TABLE x;
/* check that message shown after failure to find a partition shows the */ /* appropriate key description (or none) in various situations */ CREATE TABLE x (x INT, x INT) WITH (PARTITIONED_BY=LIST((x + 0)));
CREATE TABLE x PARTITION OF x FOR VALUES IN (1) WITH (PARTITIONED_BY=RANGE(x));
create user regress_insert_other_user;
GRANT SELECT(x) ON x TO x;
GRANT INSERT ON x TO x;
set role regress_insert_other_user;
/* no key description is shown */ INSERT INTO x VALUES (1, 1);
RESET role;
GRANT SELECT(x) ON x TO x;
set role regress_insert_other_user;
/* key description (b)=(1) is now shown */ INSERT INTO x VALUES (1, 1);
/* key description is not shown if key contains expression */ INSERT INTO x VALUES (2, 1);
RESET role;
REVOKE all on key_desc from regress_insert_other_user;
REVOKE all on key_desc_1 from regress_insert_other_user;
drop role regress_insert_other_user;
/* test minvalue/maxvalue restrictions */ CREATE TABLE x (x INT, x INT, x INT) WITH (PARTITIONED_BY=RANGE(x, ABS(x), x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (MINVALUE, 0, 0) TO (1, MAXVALUE, MAXVALUE);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (10, 6, MINVALUE) TO (10, MAXVALUE, MINVALUE);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (21, MINVALUE, 0) TO (30, 20, MINVALUE);
/* check multi-column range partitioning expression enforces the same */ /* constraint as what tuple-routing would determine it to be */ CREATE TABLE x PARTITION OF x FOR VALUES FROM (MINVALUE, MINVALUE, MINVALUE) TO (1, MAXVALUE, MAXVALUE);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (2, 1, MINVALUE) TO (10, 5, 10);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (10, 6, MINVALUE) TO (10, MAXVALUE, MAXVALUE);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (11, 1, 1) TO (20, 10, 10);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (21, MINVALUE, MINVALUE) TO (30, 20, MAXVALUE);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (30, 21, 20) TO (MAXVALUE, MAXVALUE, MAXVALUE);
/* null not allowed in range partition */ INSERT INTO x VALUES (NULL, NULL, NULL);
/* routed to mcrparted0 */ INSERT INTO x VALUES (0, 1, 1);
INSERT INTO x VALUES (0, 1, 1);
/* routed to mcparted1 */ INSERT INTO x VALUES (9, 1000, 1);
INSERT INTO x VALUES (9, 1000, 1);
INSERT INTO x VALUES (10, 5, -1);
INSERT INTO x VALUES (10, 5, -1);
INSERT INTO x VALUES (2, 1, 0);
INSERT INTO x VALUES (2, 1, 0);
/* routed to mcparted2 */ INSERT INTO x VALUES (10, 6, 1000);
INSERT INTO x VALUES (10, 6, 1000);
INSERT INTO x VALUES (10, 1000, 1000);
INSERT INTO x VALUES (10, 1000, 1000);
/* no partition exists, nor does mcrparted3 accept it */ INSERT INTO x VALUES (11, 1, -1);
INSERT INTO x VALUES (11, 1, -1);
/* routed to mcrparted5 */ INSERT INTO x VALUES (30, 21, 20);
INSERT INTO x VALUES (30, 21, 20);
INSERT INTO x VALUES (30, 21, 20);
/* error */ /* check rows */ SELECT CAST(CAST(x AS REGCLASS) AS TEXT), * FROM x ORDER BY 1 NULLS LAST;
/* cleanup */ DROP TABLE x;
/* check that a BR constraint can't make partition contain violating rows */ CREATE TABLE x (x INT, x TEXT) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN (1);
x AS x;
create trigger brtrigpartcon1trig before insert on brtrigpartcon1 for each row execute procedure brtrigpartcon1trigf();
INSERT INTO x VALUES (1, 'hi there');
INSERT INTO x VALUES (1, 'hi there');
/* check that the message shows the appropriate column description in a */ /* situation where the partitioned table is not the primary ModifyTable node */ CREATE TABLE x (x TEXT DEFAULT 'foo', x TEXT DEFAULT 'bar', x INT);
create role regress_coldesc_role;
GRANT INSERT ON x TO x;
GRANT INSERT ON x TO x;
REVOKE select on brtrigpartcon from regress_coldesc_role;
set role regress_coldesc_role;
WITH x AS (INSERT INTO x VALUES (1, 'hi there') RETURNING 1) INSERT INTO x (x) SELECT * FROM x;
RESET role;
/* cleanup */ REVOKE all on inserttest3 from regress_coldesc_role;
REVOKE all on brtrigpartcon from regress_coldesc_role;
drop role regress_coldesc_role;
DROP TABLE x;
DROP TABLE x;
DROP FUNCTION x;
/* check that "do nothing" BR triggers work with tuple-routing */ CREATE TABLE x (x INT, x TEXT) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x (x TEXT, x INT);
CREATE TABLE x (x TEXT, x TEXT, x INT);
ALTER TABLE x DROP COLUMN x;
x AS x;
create trigger donothingbrtrig1 before insert on donothingbrtrig_test1 for each row execute procedure donothingbrtrig_func();
create trigger donothingbrtrig2 before insert on donothingbrtrig_test2 for each row execute procedure donothingbrtrig_func();
alter table donothingbrtrig_test attach partition donothingbrtrig_test1 for values in (1);
alter table donothingbrtrig_test attach partition donothingbrtrig_test2 for values in (2);
INSERT INTO x VALUES (1, 'foo'), (2, 'bar');
COPY INTO x FROM x;
/* cleanup */ DROP TABLE x;
DROP FUNCTION x;
/* check multi-column range partitioning with minvalue/maxvalue constraints */ CREATE TABLE x (x TEXT, x INT) WITH (PARTITIONED_BY=RANGE(x, x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (MINVALUE, MINVALUE) TO ('b', MINVALUE);
CREATE TABLE x PARTITION OF x FOR VALUES FROM ('b', MINVALUE) TO ('c', MINVALUE);
CREATE TABLE x PARTITION OF x FOR VALUES FROM ('c', MINVALUE) TO ('common', MINVALUE);
CREATE TABLE x PARTITION OF x FOR VALUES FROM ('common', MINVALUE) TO ('common', 0);
CREATE TABLE x PARTITION OF x FOR VALUES FROM ('common', 0) TO ('common', 10);
CREATE TABLE x PARTITION OF x FOR VALUES FROM ('common', 10) TO ('common', MAXVALUE);
CREATE TABLE x PARTITION OF x FOR VALUES FROM ('common', MAXVALUE) TO ('d', MINVALUE);
CREATE TABLE x PARTITION OF x FOR VALUES FROM ('d', MINVALUE) TO (MAXVALUE, MAXVALUE);
SELECT CAST(x AS REGCLASS), * FROM x ORDER BY x NULLS LAST, x NULLS LAST;
DROP TABLE x;
/* check that wholerow vars in the RETURNING list work with partitioned tables */ CREATE TABLE x (x INT) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN (1);
INSERT INTO x VALUES (1) RETURNING x;
ALTER TABLE x ADD COLUMN x TEXT /* check also that the wholerow vars in RETURNING list are converted as needed */;
CREATE TABLE x (x TEXT, x INT, x INT);
ALTER TABLE x drop c;
alter table returningwrtest attach partition returningwrtest2 for values in (2);
INSERT INTO x VALUES (2, 'foo') RETURNING x;
DROP TABLE x;
/* insert...on conflict do unique index inference */ CREATE TABLE x (x INT, x TEXT);
/* These things should work through a view, as well */ CREATE VIEW x AS SELECT * FROM x;
/* Test unique index inference with operator class specifications and */ /* named collations */ CREATE UNIQUE INDEX x ON x(x NULLS LAST, x x NULLS LAST);
CREATE UNIQUE INDEX x ON x(x NULLS LAST, x COLLATE "x" NULLS LAST);
CREATE UNIQUE INDEX x ON x(x NULLS LAST, x COLLATE "x" x NULLS LAST);
CREATE UNIQUE INDEX x ON x(x NULLS LAST, LOWER(x) COLLATE "x" x NULLS LAST);
/* fails */ EXPLAIN (costs off) insert into insertconflicttest values(0, 'Crowberry') on conflict (key) do nothing;
EXPLAIN (costs off) insert into insertconflicttest values(0, 'Crowberry') on conflict (fruit) do nothing;
/* succeeds */ EXPLAIN (costs off) insert into insertconflicttest values(0, 'Crowberry') on conflict (key, fruit) do nothing;
EXPLAIN (costs off) insert into insertconflicttest values(0, 'Crowberry') on conflict (fruit, key, fruit, key) do nothing;
EXPLAIN (costs off) insert into insertconflicttest values(0, 'Crowberry') on conflict (lower(fruit), key, lower(fruit), key) do nothing;
EXPLAIN (costs off) insert into insertconflictview values(0, 'Crowberry') on conflict (lower(fruit), key, lower(fruit), key) do nothing;
EXPLAIN (costs off) insert into insertconflicttest values(0, 'Crowberry') on conflict (key, fruit) do update set fruit = excluded.fruit   where exists (select 1 from insertconflicttest ii where ii.key = excluded.key);
/* Neither collation nor operator class specifications are required -- */ /* supplying them merely *limits* matches to indexes with matching opclasses */ /* used for relevant indexes */ EXPLAIN (costs off) insert into insertconflicttest values(0, 'Crowberry') on conflict (key, fruit text_pattern_ops) do nothing;
/* Okay, arbitrates using both index where text_pattern_ops opclass does and */ /* does not appear. */ EXPLAIN (costs off) insert into insertconflicttest values(0, 'Crowberry') on conflict (key, fruit collate "C") do nothing;
/* Okay, but only accepts the single index where both opclass and collation are */ /* specified */ EXPLAIN (costs off) insert into insertconflicttest values(0, 'Crowberry') on conflict (fruit collate "C" text_pattern_ops, key) do nothing;
/* Okay, but only accepts the single index where both opclass and collation are */ /* specified (plus expression variant) */ EXPLAIN (costs off) insert into insertconflicttest values(0, 'Crowberry') on conflict (lower(fruit) collate "C", key, key) do nothing;
/* Attribute appears twice, while not all attributes/expressions on attributes */ /* appearing within index definition match in terms of both opclass and */ /* collation. */ /* Works because every attribute in inference specification needs to be */ /* satisfied once or more by cataloged index attribute, and as always when an */ /* attribute in the cataloged definition has a non-default opclass/collation, */ /* it still satisfied some inference attribute lacking any particular */ /* opclass/collation specification. */ /* The implementation is liberal in accepting inference specifications on the */ /* assumption that multiple inferred unique indexes will prevent problematic */ /* cases.  It rolls with unique indexes where attributes redundantly appear */ /* multiple times, too (which is not tested here). */ EXPLAIN (costs off) insert into insertconflicttest values(0, 'Crowberry') on conflict (fruit, key, fruit text_pattern_ops, key) do nothing;
EXPLAIN (costs off) insert into insertconflicttest values(0, 'Crowberry') on conflict (lower(fruit) collate "C" text_pattern_ops, key, key) do nothing;
DROP INDEX x;
DROP INDEX x;
DROP INDEX x;
DROP INDEX x;
/* Make sure that cross matching of attribute opclass/collation does not occur */ CREATE UNIQUE INDEX x ON x(LOWER(x) COLLATE "x" NULLS LAST, UPPER(x) x NULLS LAST);
/* fails: */ EXPLAIN (costs off) insert into insertconflicttest values(0, 'Crowberry') on conflict (lower(fruit) text_pattern_ops, upper(fruit) collate "C") do nothing;
/* works: */ EXPLAIN (costs off) insert into insertconflicttest values(0, 'Crowberry') on conflict (lower(fruit) collate "C", upper(fruit) text_pattern_ops) do nothing;
DROP INDEX x;
/* Single key tests */ CREATE UNIQUE INDEX x ON x(x NULLS LAST);
/* Explain tests */ EXPLAIN (costs off) insert into insertconflicttest values (0, 'Bilberry') on conflict (key) do update set fruit = excluded.fruit;
/* Should display qual actually attributable to internal sequential scan: */ EXPLAIN (costs off) insert into insertconflicttest values (0, 'Bilberry') on conflict (key) do update set fruit = excluded.fruit where insertconflicttest.fruit != 'Cawesh';
/* With EXCLUDED.* expression in scan node: */ EXPLAIN (costs off) insert into insertconflicttest values(0, 'Crowberry') on conflict (key) do update set fruit = excluded.fruit where excluded.fruit != 'Elderberry';
/* Does the same, but JSON format shows "Conflict Arbiter Index" as JSON array: */ EXPLAIN (costs off, format json) insert into insertconflicttest values (0, 'Bilberry') on conflict (key) do update set fruit = excluded.fruit where insertconflicttest.fruit != 'Lime' returning *;
/* Fails (no unique index inference specification, required for do update variant): */ INSERT INTO x VALUES (1, 'Apple') ON CONFLICT DO UPDATE SET x = x.x;
/* inference succeeds: */ INSERT INTO x VALUES (1, 'Apple') ON CONFLICT(x) DO UPDATE SET x = x.x;
INSERT INTO x VALUES (2, 'Orange') ON CONFLICT(x, x, x) DO UPDATE SET x = x.x;
/* Succeed, since multi-assignment does not involve subquery: */ INSERT INTO x VALUES (1, 'Apple'), (2, 'Orange') ON CONFLICT(x) DO UPDATE SET (x, x) = (x.x, x.x);
/* Give good diagnostic message when EXCLUDED.* spuriously referenced from */ /* RETURNING: */ INSERT INTO x VALUES (1, 'Apple') ON CONFLICT(x) DO UPDATE SET x = x.x RETURNING x.x;
/* Only suggest <table>.* column when inference element misspelled: */ INSERT INTO x VALUES (1, 'Apple') ON CONFLICT(x) DO UPDATE SET x = x.x;
/* Have useful HINT for EXCLUDED.* RTE within UPDATE: */ INSERT INTO x VALUES (1, 'Apple') ON CONFLICT(x) DO UPDATE SET x = x.x;
/* inference fails: */ INSERT INTO x VALUES (3, 'Kiwi') ON CONFLICT(x, x) DO UPDATE SET x = x.x;
INSERT INTO x VALUES (4, 'Mango') ON CONFLICT(x, x) DO UPDATE SET x = x.x;
INSERT INTO x VALUES (5, 'Lemon') ON CONFLICT(x) DO UPDATE SET x = x.x;
/* Check the target relation can be aliased */ INSERT INTO x AS x VALUES (6, 'Passionfruit') ON CONFLICT(x) DO UPDATE SET x = x.x;
/* ok, no reference to target table */ INSERT INTO x AS x VALUES (6, 'Passionfruit') ON CONFLICT(x) DO UPDATE SET x = x.x;
/* ok, alias */ INSERT INTO x AS x VALUES (6, 'Passionfruit') ON CONFLICT(x) DO UPDATE SET x = x.x;
/* error, references aliased away name */ /* Check helpful hint when qualifying set column with target table */ INSERT INTO x VALUES (3, 'Kiwi') ON CONFLICT(x, x) DO UPDATE SET x.x = 'Mango';
DROP INDEX x;
/* Composite key tests */ CREATE UNIQUE INDEX x ON x(x NULLS LAST, x NULLS LAST);
/* inference succeeds: */ INSERT INTO x VALUES (7, 'Raspberry') ON CONFLICT(x, x) DO UPDATE SET x = x.x;
INSERT INTO x VALUES (8, 'Lime') ON CONFLICT(x, x) DO UPDATE SET x = x.x;
/* inference fails: */ INSERT INTO x VALUES (9, 'Banana') ON CONFLICT(x) DO UPDATE SET x = x.x;
INSERT INTO x VALUES (10, 'Blueberry') ON CONFLICT(x, x, x) DO UPDATE SET x = x.x;
DROP INDEX x;
/* Partial index tests, no inference predicate specified */ CREATE UNIQUE INDEX x ON x(x NULLS LAST, x NULLS LAST) WHERE x < 5;
CREATE UNIQUE INDEX x ON x(x NULLS LAST, LOWER(x) NULLS LAST) WHERE x < 5;
/* inference fails: */ INSERT INTO x VALUES (13, 'Grape') ON CONFLICT(x, x) DO UPDATE SET x = x.x;
INSERT INTO x VALUES (14, 'Raisin') ON CONFLICT(x, x) DO UPDATE SET x = x.x;
INSERT INTO x VALUES (15, 'Cranberry') ON CONFLICT(x) DO UPDATE SET x = x.x;
INSERT INTO x VALUES (16, 'Melon') ON CONFLICT(x, x, x) DO UPDATE SET x = x.x;
DROP INDEX x;
DROP INDEX x;
/* Expression index tests */ CREATE UNIQUE INDEX x ON x(LOWER(x) NULLS LAST);
INSERT INTO x VALUES (23, 'Blackberry') ON CONFLICT(x) DO UPDATE SET x = x.x;
DROP INDEX x;
/* Expression index tests (with regular column) */ CREATE UNIQUE INDEX x ON x(x NULLS LAST, LOWER(x) NULLS LAST);
CREATE UNIQUE INDEX x ON x(x NULLS LAST, LOWER(x) NULLS LAST, UPPER(x) NULLS LAST);
/* Should not infer "tricky_expr_comp_key_index" index: */ EXPLAIN (costs off) insert into insertconflicttest values (26, 'Fig') on conflict (lower(fruit), key, lower(fruit), key) do update set fruit = excluded.fruit;
INSERT INTO x VALUES (28, 'Redcurrant') ON CONFLICT(x, x) DO UPDATE SET x = x.x;
INSERT INTO x VALUES (29, 'Nectarine') ON CONFLICT(x) DO UPDATE SET x = x.x;
DROP INDEX x;
DROP INDEX x;
/* Non-spurious duplicate violation tests */ CREATE UNIQUE INDEX x ON x(x NULLS LAST);
CREATE UNIQUE INDEX x ON x(x NULLS LAST);
/* succeeds, since UPDATE happens to update "fruit" to existing value: */ INSERT INTO x VALUES (26, 'Fig') ON CONFLICT(x) DO UPDATE SET x = x.x;
/* fails, since UPDATE is to row with key value 26, and we're updating "fruit" */ /* to a value that happens to exist in another row ('peach'): */ INSERT INTO x VALUES (26, 'Peach') ON CONFLICT(x) DO UPDATE SET x = x.x;
/* succeeds, since "key" isn't repeated/referenced in UPDATE, and "fruit" */ /* arbitrates that statement updates existing "Fig" row: */ INSERT INTO x VALUES (25, 'Fig') ON CONFLICT(x) DO UPDATE SET x = x.x;
DROP INDEX x;
DROP INDEX x;
/* Test partial unique index inference */ CREATE UNIQUE INDEX x ON x(x NULLS LAST) WHERE x LIKE '%berry';
/* fails */ INSERT INTO x VALUES (23, 'Blackberry') ON CONFLICT(x) DO UPDATE SET x = x.x;
DROP INDEX x;
/* Test that wholerow references to ON CONFLICT's EXCLUDED work */ CREATE UNIQUE INDEX x ON x(x NULLS LAST);
/* Succeeds, updates existing row: */ INSERT INTO x AS x VALUES (23, 'Jackfruit') ON CONFLICT(x) DO UPDATE SET x = x.x WHERE x.* <> x.* RETURNING *;
/* No update this time, though: */ INSERT INTO x AS x VALUES (23, 'Jackfruit') ON CONFLICT(x) DO UPDATE SET x = x.x WHERE x.* <> x.* RETURNING *;
/* Predicate changed to require match rather than non-match, so updates once more: */ INSERT INTO x AS x VALUES (23, 'Jackfruit') ON CONFLICT(x) DO UPDATE SET x = x.x WHERE x.* = x.* RETURNING *;
/* Assign: */ INSERT INTO x AS x VALUES (23, 'Avocado') ON CONFLICT(x) DO UPDATE SET x = CAST(x.* AS TEXT) RETURNING *;
/* deparse whole row var in WHERE and SET clauses: */ EXPLAIN (costs off) insert into insertconflicttest as i values (23, 'Avocado') on conflict (key) do update set fruit = excluded.fruit where excluded.* is null;
EXPLAIN (costs off) insert into insertconflicttest as i values (23, 'Avocado') on conflict (key) do update set fruit = excluded.*::text;
DROP INDEX x;
/* Cleanup */ DROP VIEW x;
DROP TABLE x;
/* Verify that EXCLUDED does not allow system column references. These */ /* do not make sense because EXCLUDED isn't an already stored tuple */ /* (and thus doesn't have a ctid etc). */ CREATE TABLE x (x INT, x TEXT);
INSERT INTO x VALUES (1);
INSERT INTO x VALUES (1) ON CONFLICT(x) DO UPDATE SET x = CAST(x.x AS TEXT);
DROP TABLE x;
/* Previous tests all managed to not test any expressions requiring */ /* planner preprocessing ... */ CREATE TABLE x (x BIGINT, x BIGINT);
CREATE UNIQUE INDEX x ON x(COALESCE(x, 0) NULLS LAST);
CREATE UNIQUE INDEX x ON x(x NULLS LAST) WHERE COALESCE(x, 1) > 0;
DROP TABLE x;
/* test insertion through view */ CREATE TABLE x (x INT PRIMARY KEY, x TEXT);
create view insertconflictv as   select * from insertconflict with cascaded check option;
INSERT INTO x VALUES (1, 'foo') ON CONFLICT(x) DO UPDATE SET x = x.x;
SELECT * FROM x;
INSERT INTO x VALUES (1, 'bar') ON CONFLICT(x) DO UPDATE SET x = x.x;
SELECT * FROM x;
DROP VIEW x;
DROP TABLE x;
/* ****************************************************************** */ /* *                                                                * */ /* * Test inheritance (example taken from tutorial)                 * */ /* *                                                                * */ /* ****************************************************************** */ CREATE TABLE x (x TEXT, x DOUBLE, x INT /* (in ft) */);
CREATE TABLE x (x CHAR(2)) INHERITS (x);
/* Create unique indexes.  Due to a general limitation of inheritance, */ /* uniqueness is only enforced per-relation.  Unique index inference */ /* specification will do the right thing, though. */ CREATE UNIQUE INDEX x ON x(x NULLS LAST);
CREATE UNIQUE INDEX x ON x(x NULLS LAST);
/* prepopulate the tables. */ INSERT INTO x VALUES ('San Francisco', 7.24E+5, 63);
INSERT INTO x VALUES ('Las Vegas', 2.583E+5, 2174);
INSERT INTO x VALUES ('Mariposa', 1200, 1953);
INSERT INTO x VALUES ('Sacramento', 3.694E+5, 30, 'CA');
INSERT INTO x VALUES ('Madison', 1.913E+5, 845, 'WI');
/* Tests proper for inheritance: */ SELECT * FROM x;
/* Succeeds: */ INSERT INTO x VALUES ('Las Vegas', 2.583E+5, 2174) ON CONFLICT DO NOTHING;
INSERT INTO x VALUES ('Sacramento', 4664.E+5, 30, 'CA') ON CONFLICT(x) DO UPDATE SET x = x.x;
/* Wrong "Sacramento", so do nothing: */ INSERT INTO x VALUES ('Sacramento', 50, 2267, 'NE') ON CONFLICT(x) DO NOTHING;
SELECT * FROM x;
INSERT INTO x VALUES ('Las Vegas', 5.83E+5, 2001) ON CONFLICT(x) DO UPDATE SET x = x.x, x = x.x;
SELECT CAST(x AS REGCLASS), * FROM x;
INSERT INTO x VALUES ('Las Vegas', 5.83E+5, 2222, 'NV') ON CONFLICT(x) DO UPDATE SET x = x.x;
/* Capitals will contain new capital, Las Vegas: */ SELECT * FROM x;
/* Cities contains two instances of "Las Vegas", since unique constraints don't */ /* work across inheritance: */ SELECT CAST(x AS REGCLASS), * FROM x;
/* This only affects "cities" version of "Las Vegas": */ INSERT INTO x VALUES ('Las Vegas', 5.86E+5, 2223) ON CONFLICT(x) DO UPDATE SET x = x.x, x = x.x;
SELECT CAST(x AS REGCLASS), * FROM x;
/* clean up */ DROP TABLE x;
DROP TABLE x;
/* Make sure a table named excluded is handled properly */ CREATE TABLE x (x INT PRIMARY KEY, x TEXT);
INSERT INTO x VALUES (1, '1');
/* error, ambiguous */ INSERT INTO x VALUES (1, '2') ON CONFLICT(x) DO UPDATE SET x = x.x RETURNING *;
/* ok, aliased */ INSERT INTO x AS x VALUES (1, '2') ON CONFLICT(x) DO UPDATE SET x = x.x RETURNING *;
/* ok, aliased */ INSERT INTO x AS x VALUES (1, '2') ON CONFLICT(x) DO UPDATE SET x = x.x RETURNING *;
/* make sure excluded isn't a problem in returning clause */ INSERT INTO x VALUES (1, '2') ON CONFLICT(x) DO UPDATE SET x = 3 RETURNING x.*;
/* clean up */ DROP TABLE x;
/* check that references to columns after dropped columns are handled correctly */ CREATE TABLE x (x INT PRIMARY KEY, x INT, x TEXT, x DECIMAL, x DOUBLE);
INSERT INTO x (x, x, x, x, x) VALUES (1, 1, '1', '1', 1);
/* set using excluded */ INSERT INTO x (x, x, x, x, x) VALUES (1, 2, '2', '2', 2) ON CONFLICT(x) DO UPDATE SET x = x.x, x = x.x, x = x.x, x = x.x WHERE NOT x.x IS NULL AND NOT x.x IS NULL AND NOT x.x IS NULL AND NOT x.x IS NULL AND NOT x.x IS NULL AND NOT x.x IS NULL AND NOT x.x IS NULL AND NOT x.x IS NULL RETURNING *;
/* set using existing table */ INSERT INTO x (x, x, x, x, x) VALUES (1, 3, '3', '3', 3) ON CONFLICT(x) DO UPDATE SET x = x.x, x = x.x, x = x.x, x = x.x RETURNING *;
ALTER TABLE x DROP COLUMN x, DROP COLUMN x;
/* set using excluded */ INSERT INTO x (x, x, x) VALUES (1, '4', 4) ON CONFLICT(x) DO UPDATE SET x = x.x, x = x.x WHERE NOT x.x IS NULL AND NOT x.x IS NULL AND NOT x.x IS NULL AND NOT x.x IS NULL RETURNING *;
/* set using existing table */ INSERT INTO x (x, x, x) VALUES (1, '5', 5) ON CONFLICT(x) DO UPDATE SET x = x.x, x = x.x RETURNING *;
DROP TABLE x;
/* check handling of regular btree constraint along with gist constraint */ CREATE TABLE x (x INT UNIQUE, x box, EXCLUDE USING gist(x NULLS LAST WITH &&));
INSERT INTO x VALUES (1, '((0,0),(1,1))');
INSERT INTO x VALUES (1, '((2,2),(3,3))');
/* fail on f1 */ INSERT INTO x VALUES (2, '((0,0),(1,2))');
/* fail on f2 */ INSERT INTO x VALUES (2, '((0,0),(1,2))') ON CONFLICT ON CONSTRAINT x DO NOTHING;
/* fail on f2 */ INSERT INTO x VALUES (2, '((0,0),(1,2))') ON CONFLICT ON CONSTRAINT x DO NOTHING;
/* do nothing */ SELECT * FROM x;
DROP TABLE x;
/* check handling of self-conflicts at various isolation levels */ CREATE TABLE x (x INT PRIMARY KEY, x INT);
BEGIN;
INSERT INTO x VALUES (1, 1), (1, 2) ON CONFLICT DO NOTHING;
COMMIT;
BEGIN;
INSERT INTO x VALUES (2, 1), (2, 2) ON CONFLICT DO NOTHING;
COMMIT;
BEGIN;
INSERT INTO x VALUES (3, 1), (3, 2) ON CONFLICT DO NOTHING;
COMMIT;
BEGIN;
INSERT INTO x VALUES (4, 1), (4, 2) ON CONFLICT(x) DO UPDATE SET x = 0;
COMMIT;
BEGIN;
INSERT INTO x VALUES (5, 1), (5, 2) ON CONFLICT(x) DO UPDATE SET x = 0;
COMMIT;
BEGIN;
INSERT INTO x VALUES (6, 1), (6, 2) ON CONFLICT(x) DO UPDATE SET x = 0;
COMMIT;
SELECT * FROM x;
DROP TABLE x;
/* check ON CONFLICT handling with partitioned tables */ CREATE TABLE x (x INT UNIQUE, x CHAR) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x (x UNIQUE) FOR VALUES IN (1, 2);
/* no indexes required here */ INSERT INTO x VALUES (1, 'a') ON CONFLICT DO NOTHING;
/* index on a required, which does exist in parent */ INSERT INTO x VALUES (1, 'a') ON CONFLICT(x) DO NOTHING;
INSERT INTO x VALUES (1, 'a') ON CONFLICT(x) DO UPDATE SET x = x.x;
/* targeting partition directly will work */ INSERT INTO x VALUES (1, 'a') ON CONFLICT(x) DO NOTHING;
INSERT INTO x VALUES (1, 'b') ON CONFLICT(x) DO UPDATE SET x = x.x;
/* index on b required, which doesn't exist in parent */ INSERT INTO x VALUES (2, 'b') ON CONFLICT(x) DO UPDATE SET x = x.x;
/* targeting partition directly will work */ INSERT INTO x VALUES (2, 'b') ON CONFLICT(x) DO UPDATE SET x = x.x;
/* should see (2, 'b') */ SELECT * FROM x ORDER BY x NULLS LAST;
/* now check that DO UPDATE works correctly for target partition with */ /* different attribute numbers */ CREATE TABLE x (x CHAR, x INT UNIQUE);
alter table parted_conflict_test attach partition parted_conflict_test_2 for values in (3);
TRUNCATE TABLE x;
INSERT INTO x VALUES (3, 'a') ON CONFLICT(x) DO UPDATE SET x = x.x;
INSERT INTO x VALUES (3, 'b') ON CONFLICT(x) DO UPDATE SET x = x.x;
/* should see (3, 'b') */ SELECT * FROM x ORDER BY x NULLS LAST;
ALTER TABLE x drop b, add b char /* case where parent will have a dropped column, but the partition won't */;
CREATE TABLE x PARTITION OF x FOR VALUES IN (4);
TRUNCATE TABLE x;
INSERT INTO x (x, x) VALUES (4, 'a') ON CONFLICT(x) DO UPDATE SET x = x.x;
INSERT INTO x (x, x) VALUES (4, 'b') ON CONFLICT(x) DO UPDATE SET x = x.x WHERE x.x = 'a';
/* should see (4, 'b') */ SELECT * FROM x ORDER BY x NULLS LAST;
/* case with multi-level partitioning */ CREATE TABLE x PARTITION OF x FOR VALUES IN (5) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN (5);
TRUNCATE TABLE x;
INSERT INTO x (x, x) VALUES (5, 'a') ON CONFLICT(x) DO UPDATE SET x = x.x;
INSERT INTO x (x, x) VALUES (5, 'b') ON CONFLICT(x) DO UPDATE SET x = x.x WHERE x.x = 'a';
/* should see (5, 'b') */ SELECT * FROM x ORDER BY x NULLS LAST;
TRUNCATE TABLE x /* test with multiple rows */;
INSERT INTO x (x, x) VALUES (1, 'a'), (2, 'a'), (4, 'a') ON CONFLICT(x) DO UPDATE SET x = x.x WHERE x.x = 'b';
INSERT INTO x (x, x) VALUES (1, 'b'), (2, 'c'), (4, 'b') ON CONFLICT(x) DO UPDATE SET x = x.x WHERE x.x = 'b';
/* should see (1, 'b'), (2, 'a'), (4, 'b') */ SELECT * FROM x ORDER BY x NULLS LAST;
DROP TABLE x;
/* test behavior of inserting a conflicting tuple into an intermediate */ /* partitioning level */ CREATE TABLE x (x INT PRIMARY KEY, x TEXT) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (0) TO (1000) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (0) TO (500);
INSERT INTO x VALUES (40, 'forty');
INSERT INTO x VALUES (40, 'cuarenta') ON CONFLICT(x) DO UPDATE SET x = x.x;
DROP TABLE x;
/* same thing, but this time try to use an index that's created not in the */ /* partition */ CREATE TABLE x (x INT, x TEXT) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (0) TO (1000) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (0) TO (500);
alter index parted_conflict_a_idx attach partition parted_conflict_1_a_idx;
INSERT INTO x VALUES (40, 'forty');
INSERT INTO x VALUES (40, 'cuarenta') ON CONFLICT(x) DO UPDATE SET x = x.x;
DROP TABLE x;
/* test whole-row Vars in ON CONFLICT expressions */ CREATE TABLE x (x INT, x TEXT, x INT) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x (x TEXT, x INT, x INT, x TEXT);
ALTER TABLE x DROP COLUMN x;
CREATE UNIQUE INDEX ON x(x NULLS LAST, x NULLS LAST);
alter table parted_conflict attach partition parted_conflict_1 for values from (0) to (1000);
TRUNCATE TABLE x;
INSERT INTO x VALUES (50, 'cincuenta', 1);
INSERT INTO x VALUES (50, 'cincuenta', 2) ON CONFLICT(x, x) DO UPDATE SET (x, x, x) = ROW(x.*) WHERE x = (50, CAST('cincuenta' AS TEXT), 1) AND x = (50, CAST('cincuenta' AS TEXT), 2);
/* should see (50, 'cincuenta', 2) */ SELECT * FROM x ORDER BY x NULLS LAST;
BEGIN for r in select * from inserted loop 	raise notice 'a = %, b = %, c = %', r.a, r.b, r.c;
x AS x;
COMMIT;
create trigger parted_conflict_update     after update on parted_conflict     referencing new table as inserted     for each statement     execute procedure parted_conflict_update_func();
TRUNCATE TABLE x;
INSERT INTO x VALUES (0, 'cero', 1);
INSERT INTO x VALUES (0, 'cero', 1) ON CONFLICT(x, x) DO UPDATE SET x = x.x + 1;
DROP TABLE x;
DROP FUNCTION x;
/* INT2 */ /* int2_tbl was already created and filled in test_setup.sql. */ /* Here we just try to insert bad values. */ INSERT INTO x (x) VALUES ('34.5');
INSERT INTO x (x) VALUES ('100000');
INSERT INTO x (x) VALUES ('asdf');
INSERT INTO x (x) VALUES ('    ');
INSERT INTO x (x) VALUES ('- 1234');
INSERT INTO x (x) VALUES ('4 444');
INSERT INTO x (x) VALUES ('123 dt');
INSERT INTO x (x) VALUES ('');
SELECT * FROM x;
/* Also try it with non-error-throwing API */ SELECT PG_INPUT_IS_VALID('34', 'int2');
SELECT PG_INPUT_IS_VALID('asdf', 'int2');
SELECT PG_INPUT_IS_VALID('50000', 'int2');
SELECT * FROM x;
/* While we're here, check int2vector as well */ SELECT PG_INPUT_IS_VALID(' 1 3  5 ', 'int2vector');
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x AS x;
SELECT * FROM (x AS x) AS x;
SELECT x.* FROM x AS x WHERE x.x <> CAST('0' AS SMALLINT);
SELECT x.* FROM x AS x WHERE x.x <> CAST('0' AS INT);
SELECT x.* FROM x AS x WHERE x.x = CAST('0' AS SMALLINT);
SELECT x.* FROM x AS x WHERE x.x = CAST('0' AS INT);
SELECT x.* FROM x AS x WHERE x.x < CAST('0' AS SMALLINT);
SELECT x.* FROM x AS x WHERE x.x < CAST('0' AS INT);
SELECT x.* FROM x AS x WHERE x.x <= CAST('0' AS SMALLINT);
SELECT x.* FROM x AS x WHERE x.x <= CAST('0' AS INT);
SELECT x.* FROM x AS x WHERE x.x > CAST('0' AS SMALLINT);
SELECT x.* FROM x AS x WHERE x.x > CAST('0' AS INT);
SELECT x.* FROM x AS x WHERE x.x >= CAST('0' AS SMALLINT);
SELECT x.* FROM x AS x WHERE x.x >= CAST('0' AS INT);
/* positive odds */ SELECT x.* FROM x AS x WHERE (x.x % CAST('2' AS SMALLINT)) = CAST('1' AS SMALLINT);
/* any evens */ SELECT x.* FROM x AS x WHERE (x.x % CAST('2' AS INT)) = CAST('0' AS SMALLINT);
SELECT x.x, x.x * CAST('2' AS SMALLINT) AS x FROM x AS x;
SELECT x.x, x.x * CAST('2' AS SMALLINT) AS x FROM x AS x WHERE ABS(x) < 16384;
SELECT x.x, x.x * CAST('2' AS INT) AS x FROM x AS x;
SELECT x.x, x.x + CAST('2' AS SMALLINT) AS x FROM x AS x;
SELECT x.x, x.x + CAST('2' AS SMALLINT) AS x FROM x AS x WHERE x < 32766;
SELECT x.x, x.x + CAST('2' AS INT) AS x FROM x AS x;
SELECT x.x, x.x - CAST('2' AS SMALLINT) AS x FROM x AS x;
SELECT x.x, x.x - CAST('2' AS SMALLINT) AS x FROM x AS x WHERE x > -32767;
SELECT x.x, x.x - CAST('2' AS INT) AS x FROM x AS x;
SELECT x.x, x.x / CAST('2' AS SMALLINT) AS x FROM x AS x;
SELECT x.x, x.x / CAST('2' AS INT) AS x FROM x AS x;
/* corner cases */ SELECT CAST((-CAST(1 AS SMALLINT) << 15) AS TEXT);
SELECT CAST(((-CAST(1 AS SMALLINT) << 15) + CAST(1 AS SMALLINT)) AS TEXT);
/* check sane handling of INT16_MIN overflow cases */ SELECT CAST((-32768) AS SMALLINT) * CAST((-1) AS SMALLINT);
SELECT CAST(CAST((-32768) AS SMALLINT) / CAST((-1) AS SMALLINT) AS BIGINT);
SELECT CAST((-32768) AS SMALLINT) % CAST((-1) AS SMALLINT);
/* check rounding when casting from float */ SELECT x, CAST(x AS SMALLINT) AS x FROM (VALUES (-CAST(2.5 AS DOUBLE)), (-CAST(1.5 AS DOUBLE)), (-CAST(0.5 AS DOUBLE)), (CAST(0.0 AS DOUBLE)), (CAST(0.5 AS DOUBLE)), (CAST(1.5 AS DOUBLE)), (CAST(2.5 AS DOUBLE))) AS x;
/* check rounding when casting from numeric */ SELECT x, CAST(x AS SMALLINT) AS x FROM (VALUES (-CAST(2.5 AS DECIMAL)), (-CAST(1.5 AS DECIMAL)), (-CAST(0.5 AS DECIMAL)), (CAST(0.0 AS DECIMAL)), (CAST(0.5 AS DECIMAL)), (CAST(1.5 AS DECIMAL)), (CAST(2.5 AS DECIMAL))) AS x;
/* non-decimal literals */ SELECT CAST('0b100101' AS SMALLINT);
SELECT CAST('0o273' AS SMALLINT);
SELECT CAST('0x42F' AS SMALLINT);
SELECT CAST('0b' AS SMALLINT);
SELECT CAST('0o' AS SMALLINT);
SELECT CAST('0x' AS SMALLINT);
/* cases near overflow */ SELECT CAST('0b111111111111111' AS SMALLINT);
SELECT CAST('0b1000000000000000' AS SMALLINT);
SELECT CAST('0o77777' AS SMALLINT);
SELECT CAST('0o100000' AS SMALLINT);
SELECT CAST('0x7FFF' AS SMALLINT);
SELECT CAST('0x8000' AS SMALLINT);
SELECT CAST('-0b1000000000000000' AS SMALLINT);
SELECT CAST('-0b1000000000000001' AS SMALLINT);
SELECT CAST('-0o100000' AS SMALLINT);
SELECT CAST('-0o100001' AS SMALLINT);
SELECT CAST('-0x8000' AS SMALLINT);
SELECT CAST('-0x8001' AS SMALLINT);
/* underscores */ SELECT CAST('1_000' AS SMALLINT);
SELECT CAST('1_2_3' AS SMALLINT);
SELECT CAST('0xE_FF' AS SMALLINT);
SELECT CAST('0o2_73' AS SMALLINT);
SELECT CAST('0b_10_0101' AS SMALLINT);
/* error cases */ SELECT CAST('_100' AS SMALLINT);
SELECT CAST('100_' AS SMALLINT);
SELECT CAST('10__000' AS SMALLINT);
/* INT4 */ /* int4_tbl was already created and filled in test_setup.sql. */ /* Here we just try to insert bad values. */ INSERT INTO x (x) VALUES ('34.5');
INSERT INTO x (x) VALUES ('1000000000000');
INSERT INTO x (x) VALUES ('asdf');
INSERT INTO x (x) VALUES ('     ');
INSERT INTO x (x) VALUES ('   asdf   ');
INSERT INTO x (x) VALUES ('- 1234');
INSERT INTO x (x) VALUES ('123       5');
INSERT INTO x (x) VALUES ('');
SELECT * FROM x;
/* Also try it with non-error-throwing API */ SELECT PG_INPUT_IS_VALID('34', 'int4');
SELECT PG_INPUT_IS_VALID('asdf', 'int4');
SELECT PG_INPUT_IS_VALID('1000000000000', 'int4');
SELECT * FROM x;
SELECT x.* FROM x AS x WHERE x.x <> CAST('0' AS SMALLINT);
SELECT x.* FROM x AS x WHERE x.x <> CAST('0' AS INT);
SELECT x.* FROM x AS x WHERE x.x = CAST('0' AS SMALLINT);
SELECT x.* FROM x AS x WHERE x.x = CAST('0' AS INT);
SELECT x.* FROM x AS x WHERE x.x < CAST('0' AS SMALLINT);
SELECT x.* FROM x AS x WHERE x.x < CAST('0' AS INT);
SELECT x.* FROM x AS x WHERE x.x <= CAST('0' AS SMALLINT);
SELECT x.* FROM x AS x WHERE x.x <= CAST('0' AS INT);
SELECT x.* FROM x AS x WHERE x.x > CAST('0' AS SMALLINT);
SELECT x.* FROM x AS x WHERE x.x > CAST('0' AS INT);
SELECT x.* FROM x AS x WHERE x.x >= CAST('0' AS SMALLINT);
SELECT x.* FROM x AS x WHERE x.x >= CAST('0' AS INT);
/* positive odds */ SELECT x.* FROM x AS x WHERE (x.x % CAST('2' AS SMALLINT)) = CAST('1' AS SMALLINT);
/* any evens */ SELECT x.* FROM x AS x WHERE (x.x % CAST('2' AS INT)) = CAST('0' AS SMALLINT);
SELECT x.x, x.x * CAST('2' AS SMALLINT) AS x FROM x AS x;
SELECT x.x, x.x * CAST('2' AS SMALLINT) AS x FROM x AS x WHERE ABS(x) < 1073741824;
SELECT x.x, x.x * CAST('2' AS INT) AS x FROM x AS x;
SELECT x.x, x.x * CAST('2' AS INT) AS x FROM x AS x WHERE ABS(x) < 1073741824;
SELECT x.x, x.x + CAST('2' AS SMALLINT) AS x FROM x AS x;
SELECT x.x, x.x + CAST('2' AS SMALLINT) AS x FROM x AS x WHERE x < 2147483646;
SELECT x.x, x.x + CAST('2' AS INT) AS x FROM x AS x;
SELECT x.x, x.x + CAST('2' AS INT) AS x FROM x AS x WHERE x < 2147483646;
SELECT x.x, x.x - CAST('2' AS SMALLINT) AS x FROM x AS x;
SELECT x.x, x.x - CAST('2' AS SMALLINT) AS x FROM x AS x WHERE x > -2147483647;
SELECT x.x, x.x - CAST('2' AS INT) AS x FROM x AS x;
SELECT x.x, x.x - CAST('2' AS INT) AS x FROM x AS x WHERE x > -2147483647;
SELECT x.x, x.x / CAST('2' AS SMALLINT) AS x FROM x AS x;
SELECT x.x, x.x / CAST('2' AS INT) AS x FROM x AS x;
/* more complex expressions */ /* variations on unary minus parsing */ SELECT -2 + 3 AS x;
SELECT 4 - 2 AS x;
SELECT 2 - -1 AS x;
SELECT 2 - -2 AS x;
SELECT CAST('2' AS SMALLINT) * CAST('2' AS SMALLINT) = CAST(CAST('16' AS SMALLINT) / CAST('4' AS SMALLINT) AS BIGINT) AS x;
SELECT CAST('2' AS INT) * CAST('2' AS SMALLINT) = CAST(CAST('16' AS SMALLINT) / CAST('4' AS INT) AS BIGINT) AS x;
SELECT CAST('2' AS SMALLINT) * CAST('2' AS INT) = CAST(CAST('16' AS INT) / CAST('4' AS SMALLINT) AS BIGINT) AS x;
SELECT CAST('1000' AS INT) < CAST('999' AS INT) AS x;
SELECT 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 AS x;
SELECT 2 + 2 / 2 AS x;
SELECT (2 + 2) / 2 AS x;
/* corner case */ SELECT CAST((-CAST(1 AS INT) << 31) AS TEXT);
SELECT CAST(((-CAST(1 AS INT) << 31) + 1) AS TEXT);
/* check sane handling of INT_MIN overflow cases */ SELECT CAST((-2147483648) AS INT) * CAST((-1) AS INT);
SELECT CAST(CAST((-2147483648) AS INT) / CAST((-1) AS INT) AS BIGINT);
SELECT CAST((-2147483648) AS INT) % CAST((-1) AS INT);
SELECT CAST((-2147483648) AS INT) * CAST((-1) AS SMALLINT);
SELECT CAST(CAST((-2147483648) AS INT) / CAST((-1) AS SMALLINT) AS BIGINT);
SELECT CAST((-2147483648) AS INT) % CAST((-1) AS SMALLINT);
/* check rounding when casting from float */ SELECT x, CAST(x AS INT) AS x FROM (VALUES (-CAST(2.5 AS DOUBLE)), (-CAST(1.5 AS DOUBLE)), (-CAST(0.5 AS DOUBLE)), (CAST(0.0 AS DOUBLE)), (CAST(0.5 AS DOUBLE)), (CAST(1.5 AS DOUBLE)), (CAST(2.5 AS DOUBLE))) AS x;
/* check rounding when casting from numeric */ SELECT x, CAST(x AS INT) AS x FROM (VALUES (-CAST(2.5 AS DECIMAL)), (-CAST(1.5 AS DECIMAL)), (-CAST(0.5 AS DECIMAL)), (CAST(0.0 AS DECIMAL)), (CAST(0.5 AS DECIMAL)), (CAST(1.5 AS DECIMAL)), (CAST(2.5 AS DECIMAL))) AS x;
/* test gcd() */ SELECT x, x, GCD(x, x), GCD(x, -x), GCD(x, x), GCD(-x, x) FROM (VALUES (CAST(0 AS INT), CAST(0 AS INT)), (CAST(0 AS INT), CAST(6410818 AS INT)), (CAST(61866666 AS INT), CAST(6410818 AS INT)), (-CAST(61866666 AS INT), CAST(6410818 AS INT)), (CAST((-2147483648) AS INT), CAST(1 AS INT)), (CAST((-2147483648) AS INT), CAST(2147483647 AS INT)), (CAST((-2147483648) AS INT), CAST(1073741824 AS INT))) AS x;
SELECT GCD(CAST((-2147483648) AS INT), CAST(0 AS INT));
/* overflow */ SELECT GCD(CAST((-2147483648) AS INT), CAST((-2147483648) AS INT));
/* overflow */ /* test lcm() */ SELECT x, x, LCM(x, x), LCM(x, -x), LCM(x, x), LCM(-x, x) FROM (VALUES (CAST(0 AS INT), CAST(0 AS INT)), (CAST(0 AS INT), CAST(42 AS INT)), (CAST(42 AS INT), CAST(42 AS INT)), (CAST(330 AS INT), CAST(462 AS INT)), (-CAST(330 AS INT), CAST(462 AS INT)), (CAST((-2147483648) AS INT), CAST(0 AS INT))) AS x;
SELECT LCM(CAST((-2147483648) AS INT), CAST(1 AS INT));
/* overflow */ SELECT LCM(CAST(2147483647 AS INT), CAST(2147483646 AS INT));
/* overflow */ /* non-decimal literals */ SELECT CAST('0b100101' AS INT);
SELECT CAST('0o273' AS INT);
SELECT CAST('0x42F' AS INT);
SELECT CAST('0b' AS INT);
SELECT CAST('0o' AS INT);
SELECT CAST('0x' AS INT);
/* cases near overflow */ SELECT CAST('0b1111111111111111111111111111111' AS INT);
SELECT CAST('0b10000000000000000000000000000000' AS INT);
SELECT CAST('0o17777777777' AS INT);
SELECT CAST('0o20000000000' AS INT);
SELECT CAST('0x7FFFFFFF' AS INT);
SELECT CAST('0x80000000' AS INT);
SELECT CAST('-0b10000000000000000000000000000000' AS INT);
SELECT CAST('-0b10000000000000000000000000000001' AS INT);
SELECT CAST('-0o20000000000' AS INT);
SELECT CAST('-0o20000000001' AS INT);
SELECT CAST('-0x80000000' AS INT);
SELECT CAST('-0x80000001' AS INT);
/* underscores */ SELECT CAST('1_000_000' AS INT);
SELECT CAST('1_2_3' AS INT);
SELECT CAST('0x1EEE_FFFF' AS INT);
SELECT CAST('0o2_73' AS INT);
SELECT CAST('0b_10_0101' AS INT);
/* error cases */ SELECT CAST('_100' AS INT);
SELECT CAST('100_' AS INT);
SELECT CAST('100__000' AS INT);
/* INT8 */ /* Test int8 64-bit integers. */ /* int8_tbl was already created and filled in test_setup.sql. */ /* Here we just try to insert bad values. */ INSERT INTO x (x) VALUES ('      ');
INSERT INTO x (x) VALUES ('xxx');
INSERT INTO x (x) VALUES ('3908203590239580293850293850329485');
INSERT INTO x (x) VALUES ('-1204982019841029840928340329840934');
INSERT INTO x (x) VALUES ('- 123');
INSERT INTO x (x) VALUES ('  345     5');
INSERT INTO x (x) VALUES ('');
SELECT * FROM x;
/* Also try it with non-error-throwing API */ SELECT PG_INPUT_IS_VALID('34', 'int8');
SELECT PG_INPUT_IS_VALID('asdf', 'int8');
SELECT PG_INPUT_IS_VALID('10000000000000000000', 'int8');
SELECT * FROM x;
/* int8/int8 cmp */ SELECT * FROM x WHERE x = 4567890123456789;
SELECT * FROM x WHERE x <> 4567890123456789;
SELECT * FROM x WHERE x < 4567890123456789;
SELECT * FROM x WHERE x > 4567890123456789;
SELECT * FROM x WHERE x <= 4567890123456789;
SELECT * FROM x WHERE x >= 4567890123456789;
/* int8/int4 cmp */ SELECT * FROM x WHERE x = 456;
SELECT * FROM x WHERE x <> 456;
SELECT * FROM x WHERE x < 456;
SELECT * FROM x WHERE x > 456;
SELECT * FROM x WHERE x <= 456;
SELECT * FROM x WHERE x >= 456;
/* int4/int8 cmp */ SELECT * FROM x WHERE 123 = x;
SELECT * FROM x WHERE 123 <> x;
SELECT * FROM x WHERE 123 < x;
SELECT * FROM x WHERE 123 > x;
SELECT * FROM x WHERE 123 <= x;
SELECT * FROM x WHERE 123 >= x;
/* int8/int2 cmp */ SELECT * FROM x WHERE x = CAST('456' AS SMALLINT);
SELECT * FROM x WHERE x <> CAST('456' AS SMALLINT);
SELECT * FROM x WHERE x < CAST('456' AS SMALLINT);
SELECT * FROM x WHERE x > CAST('456' AS SMALLINT);
SELECT * FROM x WHERE x <= CAST('456' AS SMALLINT);
SELECT * FROM x WHERE x >= CAST('456' AS SMALLINT);
/* int2/int8 cmp */ SELECT * FROM x WHERE CAST('123' AS SMALLINT) = x;
SELECT * FROM x WHERE CAST('123' AS SMALLINT) <> x;
SELECT * FROM x WHERE CAST('123' AS SMALLINT) < x;
SELECT * FROM x WHERE CAST('123' AS SMALLINT) > x;
SELECT * FROM x WHERE CAST('123' AS SMALLINT) <= x;
SELECT * FROM x WHERE CAST('123' AS SMALLINT) >= x;
SELECT x AS x, -x AS x FROM x;
SELECT x, x, x + x AS x FROM x;
SELECT x, x, x - x AS x FROM x;
SELECT x, x, x * x AS x FROM x;
SELECT x, x, x * x AS x FROM x WHERE x < 1000 OR (x > 0 AND x < 1000);
SELECT x, x, x / x AS x, x % x AS x FROM x;
SELECT x, FLOAT8(x) FROM x;
SELECT x, FLOAT8(x) FROM x;
SELECT 37 + x AS x FROM x;
SELECT 37 - x AS x FROM x;
SELECT 2 * x AS "x" FROM x;
SELECT x * 2 AS "x" FROM x;
/* int8 op int4 */ SELECT x + CAST(42 AS INT) AS "x", x - CAST(42 AS INT) AS "x", x * CAST(42 AS INT) AS "x", x / CAST(42 AS INT) AS "x" FROM x;
/* int4 op int8 */ SELECT CAST(246 AS INT) + x AS "x", CAST(246 AS INT) - x AS "x", CAST(246 AS INT) * x AS "x", CAST(246 AS INT) / x AS "x" FROM x;
/* int8 op int2 */ SELECT x + CAST(42 AS SMALLINT) AS "x", x - CAST(42 AS SMALLINT) AS "x", x * CAST(42 AS SMALLINT) AS "x", x / CAST(42 AS SMALLINT) AS "x" FROM x;
/* int2 op int8 */ SELECT CAST(246 AS SMALLINT) + x AS "x", CAST(246 AS SMALLINT) - x AS "x", CAST(246 AS SMALLINT) * x AS "x", CAST(246 AS SMALLINT) / x AS "x" FROM x;
SELECT x, ABS(x) FROM x;
SELECT MIN(x), MIN(x) FROM x;
SELECT MAX(x), MAX(x) FROM x;
/* TO_CHAR() */ SELECT TIME_TO_STR(x, '9G999G999G999G999G999'), TIME_TO_STR(x, '9,999,999,999,999,999') FROM x;
SELECT TIME_TO_STR(x, '9G999G999G999G999G999%u999G999'), TIME_TO_STR(x, '9,999,999,999,999,999.999,999') FROM x;
SELECT TIME_TO_STR((x * -1), '9999999999999999PR'), TIME_TO_STR((x * -1), '9999999999999999.999PR') FROM x;
SELECT TIME_TO_STR((x * -1), '9999999999999999S'), TIME_TO_STR((x * -1), 'S9999999999999999') FROM x;
SELECT TIME_TO_STR(x, '%M9999999999999999') FROM x;
SELECT TIME_TO_STR(x, '9999999999999999PL') FROM x;
SELECT TIME_TO_STR(x, 'FMS9999999999999999') FROM x;
SELECT TIME_TO_STR(x, 'FM9999999999999999THPR') FROM x;
SELECT TIME_TO_STR(x, 'SG9999999999999999th') FROM x;
SELECT TIME_TO_STR(x, '0999999999999999') FROM x;
SELECT TIME_TO_STR(x, 'S0999999999999999') FROM x;
SELECT TIME_TO_STR(x, 'FM0999999999999999') FROM x;
SELECT TIME_TO_STR(x, 'FM9999999999999999.000') FROM x;
SELECT TIME_TO_STR(x, 'L9999999999999999.000') FROM x;
SELECT TIME_TO_STR(x, 'FM9999999999999999.999') FROM x;
SELECT TIME_TO_STR(x, 'S 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 . 9 9 9') FROM x;
SELECT TIME_TO_STR(x, 99999 "text" 9999 "9999" 999 "\\"text between quote marks\\"" 9999) FROM x;
SELECT TIME_TO_STR(x, '999999SG9999999999') FROM x;
SELECT TIME_TO_STR(x, 'FMRN') FROM x;
SELECT TIME_TO_STR(1234, '9.99EEEE');
SELECT TIME_TO_STR(CAST(1234 AS BIGINT), '9.99eeee');
SELECT TIME_TO_STR(-CAST(1234 AS BIGINT), '9.99eeee');
SELECT TIME_TO_STR(1234, '99999V99');
SELECT TIME_TO_STR(CAST(1234 AS BIGINT), '99999V99');
/* check min/max values and overflow behavior */ SELECT CAST('-9223372036854775808' AS BIGINT);
SELECT CAST('-9223372036854775809' AS BIGINT);
SELECT CAST('9223372036854775807' AS BIGINT);
SELECT CAST('9223372036854775808' AS BIGINT);
SELECT -(CAST('-9223372036854775807' AS BIGINT));
SELECT -(CAST('-9223372036854775808' AS BIGINT));
SELECT CAST(0 AS BIGINT) - CAST('-9223372036854775808' AS BIGINT);
SELECT CAST('9223372036854775800' AS BIGINT) + CAST('9223372036854775800' AS BIGINT);
SELECT CAST('-9223372036854775800' AS BIGINT) + CAST('-9223372036854775800' AS BIGINT);
SELECT CAST('9223372036854775800' AS BIGINT) - CAST('-9223372036854775800' AS BIGINT);
SELECT CAST('-9223372036854775800' AS BIGINT) - CAST('9223372036854775800' AS BIGINT);
SELECT CAST('9223372036854775800' AS BIGINT) * CAST('9223372036854775800' AS BIGINT);
SELECT CAST(CAST('9223372036854775800' AS BIGINT) / CAST('0' AS BIGINT) AS BIGINT);
SELECT CAST('9223372036854775800' AS BIGINT) % CAST('0' AS BIGINT);
SELECT ABS(CAST('-9223372036854775808' AS BIGINT));
SELECT CAST('9223372036854775800' AS BIGINT) + CAST('100' AS INT);
SELECT CAST('-9223372036854775800' AS BIGINT) - CAST('100' AS INT);
SELECT CAST('9223372036854775800' AS BIGINT) * CAST('100' AS INT);
SELECT CAST('100' AS INT) + CAST('9223372036854775800' AS BIGINT);
SELECT CAST('-100' AS INT) - CAST('9223372036854775800' AS BIGINT);
SELECT CAST('100' AS INT) * CAST('9223372036854775800' AS BIGINT);
SELECT CAST('9223372036854775800' AS BIGINT) + CAST('100' AS SMALLINT);
SELECT CAST('-9223372036854775800' AS BIGINT) - CAST('100' AS SMALLINT);
SELECT CAST('9223372036854775800' AS BIGINT) * CAST('100' AS SMALLINT);
SELECT CAST(CAST('-9223372036854775808' AS BIGINT) / CAST('0' AS SMALLINT) AS BIGINT);
SELECT CAST('100' AS SMALLINT) + CAST('9223372036854775800' AS BIGINT);
SELECT CAST('-100' AS SMALLINT) - CAST('9223372036854775800' AS BIGINT);
SELECT CAST('100' AS SMALLINT) * CAST('9223372036854775800' AS BIGINT);
SELECT CAST(CAST('100' AS SMALLINT) / CAST('0' AS BIGINT) AS BIGINT);
SELECT CAST(x AS INT) FROM x WHERE x = 456;
SELECT CAST(x AS INT) FROM x WHERE x <> 456;
SELECT CAST(x AS SMALLINT) FROM x WHERE x = 456;
SELECT CAST(x AS SMALLINT) FROM x WHERE x <> 456;
SELECT CAST(CAST('42' AS SMALLINT) AS BIGINT), CAST(CAST('-37' AS SMALLINT) AS BIGINT);
SELECT CAST(x AS FLOAT), CAST(x AS DOUBLE) FROM x;
SELECT CAST(CAST('36854775807.0' AS FLOAT) AS BIGINT);
SELECT CAST(CAST('922337203685477580700.0' AS DOUBLE) AS BIGINT);
SELECT CAST(x AS OID) FROM x;
SELECT CAST(x AS BIGINT) FROM x WHERE x = 'pg_class';
SELECT x, x << 2 AS "x", x >> 3 AS "x" FROM x;
/* generate_series */ SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
/* corner case */ SELECT CAST((-CAST(1 AS BIGINT) << 63) AS TEXT);
SELECT CAST(((-CAST(1 AS BIGINT) << 63) + 1) AS TEXT);
/* check sane handling of INT64_MIN overflow cases */ SELECT CAST((-9223372036854775808) AS BIGINT) * CAST((-1) AS BIGINT);
SELECT CAST(CAST((-9223372036854775808) AS BIGINT) / CAST((-1) AS BIGINT) AS BIGINT);
SELECT CAST((-9223372036854775808) AS BIGINT) % CAST((-1) AS BIGINT);
SELECT CAST((-9223372036854775808) AS BIGINT) * CAST((-1) AS INT);
SELECT CAST(CAST((-9223372036854775808) AS BIGINT) / CAST((-1) AS INT) AS BIGINT);
SELECT CAST((-9223372036854775808) AS BIGINT) % CAST((-1) AS INT);
SELECT CAST((-9223372036854775808) AS BIGINT) * CAST((-1) AS SMALLINT);
SELECT CAST(CAST((-9223372036854775808) AS BIGINT) / CAST((-1) AS SMALLINT) AS BIGINT);
SELECT CAST((-9223372036854775808) AS BIGINT) % CAST((-1) AS SMALLINT);
/* check rounding when casting from float */ SELECT x, CAST(x AS BIGINT) AS x FROM (VALUES (-CAST(2.5 AS DOUBLE)), (-CAST(1.5 AS DOUBLE)), (-CAST(0.5 AS DOUBLE)), (CAST(0.0 AS DOUBLE)), (CAST(0.5 AS DOUBLE)), (CAST(1.5 AS DOUBLE)), (CAST(2.5 AS DOUBLE))) AS x;
/* check rounding when casting from numeric */ SELECT x, CAST(x AS BIGINT) AS x FROM (VALUES (-CAST(2.5 AS DECIMAL)), (-CAST(1.5 AS DECIMAL)), (-CAST(0.5 AS DECIMAL)), (CAST(0.0 AS DECIMAL)), (CAST(0.5 AS DECIMAL)), (CAST(1.5 AS DECIMAL)), (CAST(2.5 AS DECIMAL))) AS x;
/* test gcd() */ SELECT x, x, GCD(x, x), GCD(x, -x), GCD(x, x), GCD(-x, x) FROM (VALUES (CAST(0 AS BIGINT), CAST(0 AS BIGINT)), (CAST(0 AS BIGINT), CAST(29893644334 AS BIGINT)), (CAST(288484263558 AS BIGINT), CAST(29893644334 AS BIGINT)), (-CAST(288484263558 AS BIGINT), CAST(29893644334 AS BIGINT)), (CAST((-9223372036854775808) AS BIGINT), CAST(1 AS BIGINT)), (CAST((-9223372036854775808) AS BIGINT), CAST(9223372036854775807 AS BIGINT)), (CAST((-9223372036854775808) AS BIGINT), CAST(4611686018427387904 AS BIGINT))) AS x;
SELECT GCD(CAST((-9223372036854775808) AS BIGINT), CAST(0 AS BIGINT));
/* overflow */ SELECT GCD(CAST((-9223372036854775808) AS BIGINT), CAST((-9223372036854775808) AS BIGINT));
/* overflow */ /* test lcm() */ SELECT x, x, LCM(x, x), LCM(x, -x), LCM(x, x), LCM(-x, x) FROM (VALUES (CAST(0 AS BIGINT), CAST(0 AS BIGINT)), (CAST(0 AS BIGINT), CAST(29893644334 AS BIGINT)), (CAST(29893644334 AS BIGINT), CAST(29893644334 AS BIGINT)), (CAST(288484263558 AS BIGINT), CAST(29893644334 AS BIGINT)), (-CAST(288484263558 AS BIGINT), CAST(29893644334 AS BIGINT)), (CAST((-9223372036854775808) AS BIGINT), CAST(0 AS BIGINT))) AS x;
SELECT LCM(CAST((-9223372036854775808) AS BIGINT), CAST(1 AS BIGINT));
/* overflow */ SELECT LCM(CAST(9223372036854775807 AS BIGINT), CAST(9223372036854775806 AS BIGINT));
/* overflow */ /* non-decimal literals */ SELECT CAST('0b100101' AS BIGINT);
SELECT CAST('0o273' AS BIGINT);
SELECT CAST('0x42F' AS BIGINT);
SELECT CAST('0b' AS BIGINT);
SELECT CAST('0o' AS BIGINT);
SELECT CAST('0x' AS BIGINT);
/* cases near overflow */ SELECT CAST('0b111111111111111111111111111111111111111111111111111111111111111' AS BIGINT);
SELECT CAST('0b1000000000000000000000000000000000000000000000000000000000000000' AS BIGINT);
SELECT CAST('0o777777777777777777777' AS BIGINT);
SELECT CAST('0o1000000000000000000000' AS BIGINT);
SELECT CAST('0x7FFFFFFFFFFFFFFF' AS BIGINT);
SELECT CAST('0x8000000000000000' AS BIGINT);
SELECT CAST('-0b1000000000000000000000000000000000000000000000000000000000000000' AS BIGINT);
SELECT CAST('-0b1000000000000000000000000000000000000000000000000000000000000001' AS BIGINT);
SELECT CAST('-0o1000000000000000000000' AS BIGINT);
SELECT CAST('-0o1000000000000000000001' AS BIGINT);
SELECT CAST('-0x8000000000000000' AS BIGINT);
SELECT CAST('-0x8000000000000001' AS BIGINT);
/* underscores */ SELECT CAST('1_000_000' AS BIGINT);
SELECT CAST('1_2_3' AS BIGINT);
SELECT CAST('0x1EEE_FFFF' AS BIGINT);
SELECT CAST('0o2_73' AS BIGINT);
SELECT CAST('0b_10_0101' AS BIGINT);
/* error cases */ SELECT CAST('_100' AS BIGINT);
SELECT CAST('100_' AS BIGINT);
SELECT CAST('100__000' AS BIGINT);
SET x = 'ISO' /* INTERVAL */;
SET x = postgres;
/* check acceptance of "time zone style" */ SELECT INTERVAL '01:00' AS "x";
SELECT INTERVAL '+02:00' AS "x";
SELECT INTERVAL '-08:00' AS "x";
SELECT INTERVAL '-1 +02:03' AS "x";
SELECT INTERVAL '1' DAYS AS "x";
SELECT INTERVAL '5' WEEKS AS "x";
SELECT INTERVAL '5' MONTHS AS "x";
SELECT INTERVAL '10 years -11 month -12 days +13:14' AS "x";
SELECT INTERVAL 'infinity' AS "x";
SELECT INTERVAL '-infinity' AS "x";
CREATE TABLE x (x INTERVAL);
INSERT INTO x (x) VALUES ('@ 1 minute');
INSERT INTO x (x) VALUES ('@ 5 hour');
INSERT INTO x (x) VALUES ('@ 10 day');
INSERT INTO x (x) VALUES ('@ 34 year');
INSERT INTO x (x) VALUES ('@ 3 months');
INSERT INTO x (x) VALUES ('@ 14 seconds ago');
INSERT INTO x (x) VALUES ('1 day 2 hours 3 minutes 4 seconds');
INSERT INTO x (x) VALUES ('6 years');
INSERT INTO x (x) VALUES ('5 months');
INSERT INTO x (x) VALUES ('5 months 12 hours');
INSERT INTO x (x) VALUES ('infinity');
INSERT INTO x (x) VALUES ('-infinity');
/* badly formatted interval */ INSERT INTO x (x) VALUES ('badly formatted interval');
INSERT INTO x (x) VALUES ('@ 30 eons ago');
/* Test non-error-throwing API */ SELECT PG_INPUT_IS_VALID('1.5 weeks', 'interval');
SELECT PG_INPUT_IS_VALID('garbage', 'interval');
SELECT PG_INPUT_IS_VALID('@ 30 eons ago', 'interval');
SELECT * FROM x;
SELECT * FROM x;
/* test interval operators */ SELECT * FROM x;
SELECT * FROM x WHERE x.x <> INTERVAL '10' DAYS;
SELECT * FROM x WHERE x.x <= INTERVAL '5' HOURS;
SELECT * FROM x WHERE x.x < INTERVAL '1' DAY;
SELECT * FROM x WHERE x.x = INTERVAL '34' YEARS;
SELECT * FROM x WHERE x.x >= INTERVAL '1' MONTH;
SELECT * FROM x WHERE x.x > INTERVAL '3' SECONDS;
SELECT x.*, x.* FROM x AS x, x AS x WHERE x.x > x.x ORDER BY x.x NULLS LAST, x.x NULLS LAST;
/* test unary minus */ SELECT x, -x FROM x;
SELECT -(CAST('-2147483648 months' AS INTERVAL));
/* should fail */ SELECT -(CAST('-2147483647 months' AS INTERVAL));
/* ok */ SELECT -(CAST('-2147483648 days' AS INTERVAL));
/* should fail */ SELECT -(CAST('-2147483647 days' AS INTERVAL));
/* ok */ SELECT -(CAST('-9223372036854775808 us' AS INTERVAL));
/* should fail */ SELECT -(CAST('-9223372036854775807 us' AS INTERVAL));
/* ok */ SELECT -(CAST('-2147483647 months -2147483647 days -9223372036854775807 us' AS INTERVAL));
/* should fail */ /* Test intervals that are large enough to overflow 64 bits in comparisons */ CREATE TEMPORARY TABLE x (x INTERVAL);
INSERT INTO x (x) VALUES ('2147483647 days 2147483647 months'), ('2147483647 days -2147483648 months'), ('1 year'), ('-2147483648 days 2147483647 months'), ('-2147483648 days -2147483648 months');
/* these should fail as out-of-range */ INSERT INTO x (x) VALUES ('2147483648 days');
INSERT INTO x (x) VALUES ('-2147483649 days');
INSERT INTO x (x) VALUES ('2147483647 years');
INSERT INTO x (x) VALUES ('-2147483648 years');
/* Test edge-case overflow detection in interval multiplication */ SELECT EXTRACT(EPOCH FROM CAST('256 microseconds' AS INTERVAL) * CAST((POWER(2, 55)) AS DOUBLE));
SELECT x.*, x.* FROM x AS x, x AS x WHERE x.x > x.x ORDER BY x.x NULLS LAST, x.x NULLS LAST;
CREATE INDEX ON x USING btree(x NULLS LAST);
SET x = FALSE;
EXPLAIN (COSTS OFF) SELECT f1 FROM INTERVAL_TBL_OF r1 ORDER BY f1;
SELECT x FROM x AS x ORDER BY x NULLS LAST;
RESET enable_seqscan;
/* subtracting about-to-overflow values should result in 0 */ SELECT x - x FROM x;
DROP TABLE x;
/* Test multiplication and division with intervals. */ /* Floating point arithmetic rounding errors can lead to unexpected results, */ /* though the code attempts to do the right thing and round up to days and */ /* minutes to avoid results such as '3 days 24:00 hours' or '14:20:60'. */ /* Note that it is expected for some day components to be greater than 29 and */ /* some time components be greater than 23:59:59 due to how intervals are */ /* stored internally. */ CREATE TABLE x (x INTERVAL);
COPY INTO x FROM x;
SELECT x * 8.2 AS x FROM x;
SELECT x / 10 AS x FROM x;
SELECT x / 100 AS x FROM x;
DROP TABLE x;
SET x = 'postgres';
SET x = postgres_verbose;
SELECT * FROM x;
/* multiplication and division overflow test cases */ SELECT CAST('3000000 months' AS INTERVAL) * 1000;
SELECT CAST('3000000 months' AS INTERVAL) / 0.001;
SELECT CAST('3000000 days' AS INTERVAL) * 1000;
SELECT CAST('3000000 days' AS INTERVAL) / 0.001;
SELECT CAST('1 month 2146410 days' AS INTERVAL) * 1000.5002;
SELECT CAST('4611686018427387904 usec' AS INTERVAL) / 0.1;
/* test avg(interval), which is somewhat fragile since people have been */ /* known to change the allowed input syntax for type interval without */ /* updating pg_aggregate.agginitval */ SELECT AVG(x) FROM x WHERE ISFINITE(x);
/* test long interval input */ SELECT CAST('4 millenniums 5 centuries 4 decades 1 year 4 months 4 days 17 minutes 31 seconds' AS INTERVAL);
/* test long interval output */ /* Note: the actual maximum length of the interval output is longer, */ /* but we need the test to work for both integer and floating-point */ /* timestamps. */ SELECT CAST('100000000y 10mon -1000000000d -100000h -10min -10.000001s ago' AS INTERVAL);
/* test justify_hours() and justify_days() */ SELECT JUSTIFY_HOURS(INTERVAL '6 months 3 days 52 hours 3 minutes 2 seconds') AS "x";
SELECT JUSTIFY_DAYS(INTERVAL '6 months 36 days 5 hours 4 minutes 3 seconds') AS "x";
SELECT JUSTIFY_HOURS(INTERVAL '2147483647 days 24 hrs');
SELECT JUSTIFY_DAYS(INTERVAL '2147483647 months 30 days');
/* test justify_interval() */ SELECT JUSTIFY_INTERVAL(INTERVAL '1 month -1 hour') AS "x";
SELECT JUSTIFY_INTERVAL(INTERVAL '2147483647 days 24 hrs');
SELECT JUSTIFY_INTERVAL(INTERVAL '-2147483648 days -24 hrs');
SELECT JUSTIFY_INTERVAL(INTERVAL '2147483647 months 30 days');
SELECT JUSTIFY_INTERVAL(INTERVAL '-2147483648 months -30 days');
SELECT JUSTIFY_INTERVAL(INTERVAL '2147483647 months 30 days -24 hrs');
SELECT JUSTIFY_INTERVAL(INTERVAL '-2147483648 months -30 days 24 hrs');
SELECT JUSTIFY_INTERVAL(INTERVAL '2147483647 months -30 days 1440 hrs');
SELECT JUSTIFY_INTERVAL(INTERVAL '-2147483648 months 30 days -1440 hrs');
SET x = 'ISO' /* test fractional second input, and detection of duplicate units */;
SET x = postgres;
SELECT CAST('1 millisecond' AS INTERVAL), CAST('1 microsecond' AS INTERVAL), CAST('500 seconds 99 milliseconds 51 microseconds' AS INTERVAL);
SELECT CAST('3 days 5 milliseconds' AS INTERVAL);
SELECT CAST('1 second 2 seconds' AS INTERVAL);
/* error */ SELECT CAST('10 milliseconds 20 milliseconds' AS INTERVAL);
/* error */ SELECT CAST('5.5 seconds 3 milliseconds' AS INTERVAL);
/* error */ SELECT CAST('1:20:05 5 microseconds' AS INTERVAL);
/* error */ SELECT CAST('1 day 1 day' AS INTERVAL);
/* error */ SELECT INTERVAL '1-2';
/* SQL year-month literal */ SELECT INTERVAL '999' SECOND;
/* oversize leading field is ok */ SELECT INTERVAL '999' MINUTE;
SELECT INTERVAL '999' HOUR;
SELECT INTERVAL '999' DAY;
SELECT INTERVAL '999' MONTH;
/* test SQL-spec syntaxes for restricted field sets */ SELECT INTERVAL '1' YEAR;
SELECT INTERVAL '2' MONTH;
SELECT INTERVAL '3' DAY;
SELECT INTERVAL '4' HOUR;
SELECT INTERVAL '5' MINUTE;
SELECT INTERVAL '6' SECOND;
SELECT INTERVAL '1' YEAR TO MONTH;
SELECT INTERVAL '1-2' YEAR TO MONTH;
SELECT INTERVAL '1 2' DAY TO HOUR;
SELECT INTERVAL '1 2:03' DAY TO HOUR;
SELECT INTERVAL '1 2:03:04' DAY TO HOUR;
SELECT INTERVAL '1 2' DAY TO MINUTE;
SELECT INTERVAL '1 2:03' DAY TO MINUTE;
SELECT INTERVAL '1 2:03:04' DAY TO MINUTE;
SELECT INTERVAL '1 2' DAY TO SECOND;
SELECT INTERVAL '1 2:03' DAY TO SECOND;
SELECT INTERVAL '1 2:03:04' DAY TO SECOND;
SELECT INTERVAL '1 2' HOUR TO MINUTE;
SELECT INTERVAL '1 2:03' HOUR TO MINUTE;
SELECT INTERVAL '1 2:03:04' HOUR TO MINUTE;
SELECT INTERVAL '1 2' HOUR TO SECOND;
SELECT INTERVAL '1 2:03' HOUR TO SECOND;
SELECT INTERVAL '1 2:03:04' HOUR TO SECOND;
SELECT INTERVAL '1 2' MINUTE TO SECOND;
SELECT INTERVAL '1 2:03' MINUTE TO SECOND;
SELECT INTERVAL '1 2:03:04' MINUTE TO SECOND;
SELECT INTERVAL '1 +2:03' MINUTE TO SECOND;
SELECT INTERVAL '1 +2:03:04' MINUTE TO SECOND;
SELECT INTERVAL '1 -2:03' MINUTE TO SECOND;
SELECT INTERVAL '1 -2:03:04' MINUTE TO SECOND;
SELECT INTERVAL '123 11' DAY TO HOUR;
/* ok */ SELECT INTERVAL '123 11' DAY;
/* not ok */ SELECT INTERVAL '123 11';
/* not ok, too ambiguous */ SELECT INTERVAL '123 2:03 -2:04';
/* not ok, redundant hh:mm fields */ /* test syntaxes for restricted precision */ SELECT INTERVAL (0) 1 DAY 01:23:45.6789;
SELECT INTERVAL (2) 1 DAY 01:23:45.6789;
/* per SQL spec */ SELECT INTERVAL '1.234' SECOND;
SELECT INTERVAL '1.234' SECOND(2);
SELECT INTERVAL '2562047788:00:54.775807' SECOND(2);
/* out of range */ SELECT INTERVAL '-2562047788:00:54.775807' SECOND(2);
/* out of range */ /* test casting to restricted precision (bug #14479) */ SELECT x, CAST(x AS INTERVAL DAY TO MINUTE) AS "x", CAST(CAST((x + INTERVAL '1' MONTH) AS INTERVAL MONTH) AS INTERVAL YEAR) AS "x" FROM x;
SET x = sql_standard /* test inputting and outputting SQL standard interval literals */;
SELECT INTERVAL '0' AS "x", INTERVAL '1-2' YEAR TO MONTH AS "x", INTERVAL '1 2:03:04' DAY TO SECOND AS "x", -INTERVAL '1-2' AS "x", -INTERVAL '1 2:03:04' AS "x";
SET x = postgres /* test input of some not-quite-standard interval values in the sql style */;
SELECT INTERVAL '+1 -1:00:00', INTERVAL '-1 +1:00:00', INTERVAL '+1-2 -3 +4:05:06.789', INTERVAL '-1-2 +3 -4:05:06.789';
/* cases that trigger sign-matching rules in the sql style */ SELECT INTERVAL '-23 hours 45 min 12.34 sec', INTERVAL '-1 day 23 hours 45 min 12.34 sec', INTERVAL '-1 year 2 months 1 day 23 hours 45 min 12.34 sec', INTERVAL '-1 year 2 months 1 day 23 hours 45 min +12.34 sec';
SET x = sql_standard /* test output of couple non-standard interval values in the sql style */;
SELECT INTERVAL '1 day -1 hours', INTERVAL '-1 days +1 hours', INTERVAL '1 years 2 months -3 days 4 hours 5 minutes 6.789 seconds', -INTERVAL '1 years 2 months -3 days 4 hours 5 minutes 6.789 seconds';
/* cases that trigger sign-matching rules in the sql style */ SELECT INTERVAL '-23 hours 45 min 12.34 sec', INTERVAL '-1 day 23 hours 45 min 12.34 sec', INTERVAL '-1 year 2 months 1 day 23 hours 45 min 12.34 sec', INTERVAL '-1 year 2 months 1 day 23 hours 45 min +12.34 sec';
/* edge case for sign-matching rules */ SELECT INTERVAL '';
SET x = iso_8601 /* error */ /* test outputting iso8601 intervals */;
SELECT INTERVAL '0' AS "x", INTERVAL '1-2' AS "x", INTERVAL '1 2:03:04' AS "x", INTERVAL '2:03:04.45679' AS "x", (INTERVAL '1-2' + INTERVAL '3 4:05:06.7') AS "x", (INTERVAL '1-2' - INTERVAL '3 4:05:06.7') AS "x", (-INTERVAL '1-2' + INTERVAL '3 4:05:06.7') AS "x";
SET x = sql_standard /* test inputting ISO 8601 4.4.2.1 "Format With Time Unit Designators" */;
SELECT INTERVAL '0' YEAR AS "x", INTERVAL 'P1Y2M' AS "x", INTERVAL '1' WEEK AS "x", INTERVAL 'P1DT2H3M4S' AS "x", INTERVAL 'P1Y2M3DT4H5M6.7S' AS "x", INTERVAL 'P-1Y-2M-3DT-4H-5M-6.7S' AS "x", INTERVAL '1' SECOND AS "x";
SET x = postgres /* test inputting ISO 8601 4.4.2.2 "Alternative Format" */;
SELECT INTERVAL '00021015' T AS "x", INTERVAL '15' T AS "x";
/* Make sure optional ISO8601 alternative format fields are optional. */ SELECT INTERVAL 'P0002' AS "x", INTERVAL 'P0002-10' AS "x", INTERVAL 'P0002-10-15' AS "x", INTERVAL 'P0002T1S' AS "x", INTERVAL 'P0002-10T1S' AS "x", INTERVAL 'P0002-10-15T1S' AS "x", INTERVAL 'PT10' AS "x", INTERVAL 'PT10:30' AS "x";
/* Check handling of fractional fields in ISO8601 format. */ SELECT INTERVAL 'P1Y0M3DT4H5M6S';
SELECT INTERVAL 'P1.0Y0M3DT4H5M6S';
SELECT INTERVAL 'P1.1Y0M3DT4H5M6S';
SELECT INTERVAL 'P1.Y0M3DT4H5M6S';
SELECT INTERVAL 'P.1Y0M3DT4H5M6S';
SELECT INTERVAL 'P10.5e4Y';
/* not per spec, but we've historically taken it */ SELECT INTERVAL 'P.Y0M3DT4H5M6S';
SET x = postgres_verbose /* error */ /* test a couple rounding cases that changed since 8.3 w/ HAVE_INT64_TIMESTAMP. */;
SELECT INTERVAL '-10 mons -3 days +03:55:06.70';
SELECT INTERVAL '1 year 2 mons 3 days 04:05:06.699999';
SELECT INTERVAL '0:0:0.7', INTERVAL '70' SECS, INTERVAL '7' SECONDS;
/* test time fields using entire 64 bit microseconds range */ SELECT INTERVAL '01521550194' HOURS;
SELECT INTERVAL '01521550222' HOURS;
SELECT INTERVAL '912930117' MINUTES;
SELECT INTERVAL '912930133' MINUTES;
SELECT INTERVAL '775807' SECONDS;
SELECT INTERVAL '775808' SECONDS;
SELECT INTERVAL '807' MILLISECONDS;
SELECT INTERVAL '808' MILLISECONDS;
SELECT INTERVAL '9223372036854775807' MICROSECONDS;
SELECT INTERVAL '9223372036854775808' MICROSECONDS;
SELECT INTERVAL 'PT2562047788H54.775807S';
SELECT INTERVAL 'PT-2562047788H-54.775808S';
SELECT INTERVAL 'PT2562047788:00:54.775807';
SELECT INTERVAL 'PT2562047788.0152155019444';
SELECT INTERVAL 'PT-2562047788.0152155022222';
/* overflow each date/time field */ SELECT INTERVAL '2147483648' YEARS;
SELECT INTERVAL '2147483649' YEARS;
SELECT INTERVAL '2147483648' MONTHS;
SELECT INTERVAL '2147483649' MONTHS;
SELECT INTERVAL '2147483648' DAYS;
SELECT INTERVAL '2147483649' DAYS;
SELECT INTERVAL '2562047789' HOURS;
SELECT INTERVAL '2562047789' HOURS;
SELECT INTERVAL '153722867281' MINUTES;
SELECT INTERVAL '153722867281' MINUTES;
SELECT INTERVAL '9223372036855' SECONDS;
SELECT INTERVAL '9223372036855' SECONDS;
SELECT INTERVAL '9223372036854777' MILLISECOND;
SELECT INTERVAL '9223372036854777' MILLISECOND;
SELECT INTERVAL '9223372036854775808' MICROSECOND;
SELECT INTERVAL '9223372036854775809' MICROSECOND;
SELECT INTERVAL 'P2147483648';
SELECT INTERVAL 'P-2147483649';
SELECT INTERVAL 'P1-2147483647-2147483647';
SELECT INTERVAL 'PT2562047789';
SELECT INTERVAL 'PT-2562047789';
/* overflow with date/time unit aliases */ SELECT INTERVAL '2147483647' WEEKS;
SELECT INTERVAL '2147483648' WEEKS;
SELECT INTERVAL '2147483647' DECADES;
SELECT INTERVAL '2147483648' DECADES;
SELECT INTERVAL '2147483647' CENTURIES;
SELECT INTERVAL '2147483648' CENTURIES;
SELECT INTERVAL '2147483647' MILLENNIUM;
SELECT INTERVAL '2147483648' MILLENNIUM;
SELECT INTERVAL '1 week 2147483647 days';
SELECT INTERVAL '-1 week -2147483648 days';
SELECT INTERVAL '2147483647 days 1 week';
SELECT INTERVAL '-2147483648 days -1 week';
SELECT INTERVAL 'P1W2147483647D';
SELECT INTERVAL 'P-1W-2147483648D';
SELECT INTERVAL 'P2147483647D1W';
SELECT INTERVAL 'P-2147483648D-1W';
SELECT INTERVAL '1 decade 2147483647 years';
SELECT INTERVAL '1 century 2147483647 years';
SELECT INTERVAL '1 millennium 2147483647 years';
SELECT INTERVAL '-1 decade -2147483648 years';
SELECT INTERVAL '-1 century -2147483648 years';
SELECT INTERVAL '-1 millennium -2147483648 years';
SELECT INTERVAL '2147483647 years 1 decade';
SELECT INTERVAL '2147483647 years 1 century';
SELECT INTERVAL '2147483647 years 1 millennium';
SELECT INTERVAL '-2147483648 years -1 decade';
SELECT INTERVAL '-2147483648 years -1 century';
SELECT INTERVAL '-2147483648 years -1 millennium';
/* overflowing with fractional fields - postgres format */ SELECT INTERVAL '0.1 millennium 2147483647 months';
SELECT INTERVAL '0.1 centuries 2147483647 months';
SELECT INTERVAL '0.1 decades 2147483647 months';
SELECT INTERVAL '0.1 yrs 2147483647 months';
SELECT INTERVAL '-0.1 millennium -2147483648 months';
SELECT INTERVAL '-0.1 centuries -2147483648 months';
SELECT INTERVAL '-0.1 decades -2147483648 months';
SELECT INTERVAL '-0.1 yrs -2147483648 months';
SELECT INTERVAL '2147483647 months 0.1 millennium';
SELECT INTERVAL '2147483647 months 0.1 centuries';
SELECT INTERVAL '2147483647 months 0.1 decades';
SELECT INTERVAL '2147483647 months 0.1 yrs';
SELECT INTERVAL '-2147483648 months -0.1 millennium';
SELECT INTERVAL '-2147483648 months -0.1 centuries';
SELECT INTERVAL '-2147483648 months -0.1 decades';
SELECT INTERVAL '-2147483648 months -0.1 yrs';
SELECT INTERVAL '0.1 months 2147483647 days';
SELECT INTERVAL '-0.1 months -2147483648 days';
SELECT INTERVAL '2147483647 days 0.1 months';
SELECT INTERVAL '-2147483648 days -0.1 months';
SELECT INTERVAL '0.5 weeks 2147483647 days';
SELECT INTERVAL '-0.5 weeks -2147483648 days';
SELECT INTERVAL '2147483647 days 0.5 weeks';
SELECT INTERVAL '-2147483648 days -0.5 weeks';
SELECT INTERVAL '0.01 months 9223372036854775807 microseconds';
SELECT INTERVAL '-0.01 months -9223372036854775808 microseconds';
SELECT INTERVAL '9223372036854775807 microseconds 0.01 months';
SELECT INTERVAL '-9223372036854775808 microseconds -0.01 months';
SELECT INTERVAL '0.1 weeks 9223372036854775807 microseconds';
SELECT INTERVAL '-0.1 weeks -9223372036854775808 microseconds';
SELECT INTERVAL '9223372036854775807 microseconds 0.1 weeks';
SELECT INTERVAL '-9223372036854775808 microseconds -0.1 weeks';
SELECT INTERVAL '0.1 days 9223372036854775807 microseconds';
SELECT INTERVAL '-0.1 days -9223372036854775808 microseconds';
SELECT INTERVAL '9223372036854775807 microseconds 0.1 days';
SELECT INTERVAL '-9223372036854775808 microseconds -0.1 days';
/* overflowing with fractional fields - ISO8601 format */ SELECT INTERVAL 'P0.1Y2147483647M';
SELECT INTERVAL 'P-0.1Y-2147483648M';
SELECT INTERVAL 'P2147483647M0.1Y';
SELECT INTERVAL 'P-2147483648M-0.1Y';
SELECT INTERVAL 'P0.1M2147483647D';
SELECT INTERVAL 'P-0.1M-2147483648D';
SELECT INTERVAL 'P2147483647D0.1M';
SELECT INTERVAL 'P-2147483648D-0.1M';
SELECT INTERVAL 'P0.5W2147483647D';
SELECT INTERVAL 'P-0.5W-2147483648D';
SELECT INTERVAL 'P2147483647D0.5W';
SELECT INTERVAL 'P-2147483648D-0.5W';
SELECT INTERVAL 'P0.01MT2562047788H54.775807S';
SELECT INTERVAL 'P-0.01MT-2562047788H-54.775808S';
SELECT INTERVAL 'P0.1DT2562047788H54.775807S';
SELECT INTERVAL 'P-0.1DT-2562047788H-54.775808S';
SELECT INTERVAL 'PT2562047788.1H54.775807S';
SELECT INTERVAL 'PT-2562047788.1H-54.775808S';
SELECT INTERVAL 'PT2562047788H0.1M54.775807S';
SELECT INTERVAL 'PT-2562047788H-0.1M-54.775808S';
/* overflowing with fractional fields - ISO8601 alternative format */ SELECT INTERVAL 'P0.1-2147483647-00';
SELECT INTERVAL 'P00-0.1-2147483647';
SELECT INTERVAL '00' T;
SELECT INTERVAL '1' T;
SELECT INTERVAL 'PT2562047788.1:00:54.775807';
SELECT INTERVAL 'PT2562047788:01.:54.775807';
/* overflowing with fractional fields - SQL standard format */ SELECT INTERVAL '0.1 2562047788:0:54.775807';
SELECT INTERVAL '775808' AGO;
SELECT INTERVAL '2562047788.1:0:54.775807';
SELECT INTERVAL '775808' AGO;
SELECT INTERVAL '2562047788:0.1:54.775807';
SELECT INTERVAL '775808' AGO;
/* overflowing using AGO with INT_MIN */ SELECT INTERVAL '2147483648' MONTHS;
SELECT INTERVAL '2147483648' DAYS;
SELECT INTERVAL '9223372036854775808' MICROSECONDS;
SELECT INTERVAL '-2147483648 months -2147483648 days -9223372036854775808 microseconds ago';
/* overflowing using make_interval */ SELECT MAKE_INTERVAL(x := 178956971);
SELECT MAKE_INTERVAL(x := -178956971);
SELECT MAKE_INTERVAL(x := 1, x := 2147483647);
SELECT MAKE_INTERVAL(x := -1, x := -2147483648);
SELECT MAKE_INTERVAL(x := 306783379);
SELECT MAKE_INTERVAL(x := -306783379);
SELECT MAKE_INTERVAL(x := 1, x := 2147483647);
SELECT MAKE_INTERVAL(x := -1, x := -2147483648);
SELECT MAKE_INTERVAL(x := 1e308);
SELECT MAKE_INTERVAL(x := 1e18);
SELECT MAKE_INTERVAL(x := -1e18);
SELECT MAKE_INTERVAL(x := 1, x := 9223372036800.0);
SELECT MAKE_INTERVAL(x := -1, x := -9223372036800.0);
SET x = postgres /* test that INT_MIN number is formatted properly */;
SELECT INTERVAL '-2147483647 months -2147483648 days -9223372036854775808 us';
SET x = sql_standard;
SELECT INTERVAL '-2147483647 months -2147483648 days -9223372036854775808 us';
SET x = iso_8601;
SELECT INTERVAL '-2147483647 months -2147483648 days -9223372036854775808 us';
SET x = postgres_verbose;
SELECT INTERVAL '-2147483647 months -2147483648 days -9223372036854775808 us';
/* check that '30 days' equals '1 month' according to the hash function */ SELECT CAST('30 days' AS INTERVAL) = CAST('1 month' AS INTERVAL) AS x;
SELECT INTERVAL_HASH(CAST('30 days' AS INTERVAL)) = INTERVAL_HASH(CAST('1 month' AS INTERVAL)) AS x;
/* numeric constructor */ SELECT MAKE_INTERVAL(x := 2);
SELECT MAKE_INTERVAL(x := 1, x := 6);
SELECT MAKE_INTERVAL(x := 1, x := -1, x := 5, x := -7, x := 25, x := -180);
SELECT MAKE_INTERVAL() = MAKE_INTERVAL(x := 0, x := 0, x := 0, x := 0, x := 0, x := 0.0);
SELECT MAKE_INTERVAL(x := -2, x := -10, x := -25.3);
SELECT MAKE_INTERVAL(x := CAST(CAST('inf' AS DOUBLE) AS INT));
SELECT MAKE_INTERVAL(x := CAST(CAST('NaN' AS DOUBLE) AS INT));
SELECT MAKE_INTERVAL(x := 'inf');
SELECT MAKE_INTERVAL(x := 'NaN');
SELECT MAKE_INTERVAL(x := 7e12);
/* test EXTRACT */ SELECT x, EXTRACT(MICROSECOND FROM x) AS x, EXTRACT(MILLISECOND FROM x) AS x, EXTRACT(SECOND FROM x) AS x, EXTRACT(MINUTE FROM x) AS x, EXTRACT(HOUR FROM x) AS x, EXTRACT(DAY FROM x) AS x, EXTRACT(WEEK FROM x) AS x, EXTRACT(MONTH FROM x) AS x, EXTRACT(QUARTER FROM x) AS x, EXTRACT(YEAR FROM x) AS x, EXTRACT(DECADE FROM x) AS x, EXTRACT(CENTURY FROM x) AS x, EXTRACT(MILLENNIUM FROM x) AS x, EXTRACT(EPOCH FROM x) AS x FROM x;
SELECT -x, EXTRACT(MICROSECOND FROM -x) AS x, EXTRACT(MILLISECOND FROM -x) AS x, EXTRACT(SECOND FROM -x) AS x, EXTRACT(MINUTE FROM -x) AS x, EXTRACT(HOUR FROM -x) AS x, EXTRACT(DAY FROM -x) AS x, EXTRACT(WEEK FROM -x) AS x, EXTRACT(MONTH FROM -x) AS x, EXTRACT(QUARTER FROM -x) AS x, EXTRACT(YEAR FROM -x) AS x, EXTRACT(DECADE FROM -x) AS x, EXTRACT(CENTURY FROM -x) AS x, EXTRACT(MILLENNIUM FROM -x) AS x, EXTRACT(EPOCH FROM -x) AS x FROM x;
SELECT EXTRACT(FORTNIGHT FROM INTERVAL '2' DAYS);
/* error */ SELECT EXTRACT(TIMEZONE FROM INTERVAL '2' DAYS);
/* error */ SELECT EXTRACT(DECADE FROM INTERVAL '100' YEAR);
SELECT EXTRACT(DECADE FROM INTERVAL '99' YEAR);
SELECT EXTRACT(DECADE FROM INTERVAL '99' YEAR);
SELECT EXTRACT(DECADE FROM INTERVAL '100' YEAR);
SELECT EXTRACT(CENTURY FROM INTERVAL '100' YEAR);
SELECT EXTRACT(CENTURY FROM INTERVAL '99' YEAR);
SELECT EXTRACT(CENTURY FROM INTERVAL '99' YEAR);
SELECT EXTRACT(CENTURY FROM INTERVAL '100' YEAR);
/* date_part implementation is mostly the same as extract, so only */ /* test a few cases for additional coverage. */ SELECT x, EXTRACT(microsecond FROM x) AS x, EXTRACT(millisecond FROM x) AS x, EXTRACT(second FROM x) AS x, EXTRACT(epoch FROM x) AS x FROM x;
/* internal overflow test case */ SELECT EXTRACT(EPOCH FROM INTERVAL '1000000000' DAYS);
/* test infinite intervals */ /* largest finite intervals */ SELECT INTERVAL '-2147483648 months -2147483648 days -9223372036854775807 us';
SELECT INTERVAL '2147483647 months 2147483647 days 9223372036854775806 us';
/* infinite intervals */ SELECT INTERVAL '-2147483648 months -2147483648 days -9223372036854775808 us';
SELECT INTERVAL '2147483647 months 2147483647 days 9223372036854775807 us';
CREATE TABLE x (x INTERVAL);
INSERT INTO x VALUES ('infinity'), ('-infinity'), ('1 year 2 days 3 hours');
SELECT x, ISFINITE(x) FROM x;
BEGIN EXECUTE 'select '||expr INTO result;
x AS x;
SELECT x AS x, x AS x, EVAL(FORMAT('date %L + interval %L', x, x)) AS x, EVAL(FORMAT('date %L - interval %L', x, x)) AS x FROM (VALUES (CAST('-infinity' AS DATE)), (CAST('1995-08-06' AS DATE)), (CAST('infinity' AS DATE))) AS x, (VALUES (INTERVAL '-infinity'), (INTERVAL 'infinity')) AS x;
SELECT x AS x, x AS x, EVAL(FORMAT('interval %L + interval %L', x, x)) AS x, EVAL(FORMAT('interval %L - interval %L', x, x)) AS x FROM (VALUES (INTERVAL '-infinity'), (INTERVAL '2' MONTHS), (INTERVAL 'infinity')) AS x, (VALUES (INTERVAL '-infinity'), (INTERVAL '10' DAYS), (INTERVAL 'infinity')) AS x;
SELECT INTERVAL '2147483646 months 2147483646 days 9223372036854775806 us' + INTERVAL '1 month 1 day 1 us';
SELECT INTERVAL '-2147483647 months -2147483647 days -9223372036854775807 us' + INTERVAL '-1 month -1 day -1 us';
SELECT INTERVAL '2147483646 months 2147483646 days 9223372036854775806 us' - INTERVAL '-1 month -1 day -1 us';
SELECT INTERVAL '-2147483647 months -2147483647 days -9223372036854775807 us' - INTERVAL '1 month 1 day 1 us';
SELECT x AS x, x AS x, EVAL(FORMAT('timestamp %L + interval %L', x, x)) AS x, EVAL(FORMAT('timestamp %L - interval %L', x, x)) AS x FROM (VALUES (CAST('-infinity' AS TIMESTAMP)), (CAST('1995-08-06 12:30:15' AS TIMESTAMP)), (CAST('infinity' AS TIMESTAMP))) AS x, (VALUES (INTERVAL '-infinity'), (INTERVAL 'infinity')) AS x;
SELECT x AT TIME ZONE 'GMT' AS x, x AS x, EVAL(FORMAT('timestamptz %L + interval %L', x, x)) AS x, EVAL(FORMAT('timestamptz %L - interval %L', x, x)) AS x FROM (VALUES (CAST('-infinity' AS TIMESTAMPTZ)), (CAST('1995-08-06 12:30:15 GMT' AS TIMESTAMPTZ)), (CAST('infinity' AS TIMESTAMPTZ))) AS x, (VALUES (INTERVAL '-infinity'), (INTERVAL 'infinity')) AS x;
/* time +/- infinite interval not supported */ SELECT CAST('11:27:42' AS TIME) + INTERVAL 'infinity';
SELECT CAST('11:27:42' AS TIME) + INTERVAL '-infinity';
SELECT CAST('11:27:42' AS TIME) - INTERVAL 'infinity';
SELECT CAST('11:27:42' AS TIME) - INTERVAL '-infinity';
SELECT CAST('11:27:42' AS TIMETZ) + INTERVAL 'infinity';
SELECT CAST('11:27:42' AS TIMETZ) + INTERVAL '-infinity';
SELECT CAST('11:27:42' AS TIMETZ) - INTERVAL 'infinity';
SELECT CAST('11:27:42' AS TIMETZ) - INTERVAL '-infinity';
SELECT x.x AS x, x.x AS x, x.x < x.x AS x, x.x <= x.x AS x, x.x = x.x AS x, x.x > x.x AS x, x.x >= x.x AS x, x.x <> x.x AS x FROM x AS x CROSS JOIN x AS x WHERE NOT ISFINITE(x.x);
SELECT x AS x, -x AS x, x * 2.0 AS x, x * -2.0 AS x, x * 'infinity' AS x, x * '-infinity' AS x, x / 3.0 AS x, x / -3.0 AS x FROM x WHERE NOT ISFINITE(x);
SELECT -INTERVAL '-2147483647 months -2147483647 days -9223372036854775807 us';
SELECT INTERVAL 'infinity' * 'nan';
SELECT INTERVAL '-infinity' * 'nan';
SELECT INTERVAL '-1073741824 months -1073741824 days -4611686018427387904 us' * 2;
SELECT INTERVAL 'infinity' * 0;
SELECT INTERVAL '-infinity' * 0;
SELECT INTERVAL '0' DAYS * CAST('infinity' AS DOUBLE);
SELECT INTERVAL '0' DAYS * CAST('-infinity' AS DOUBLE);
SELECT INTERVAL '5' DAYS * CAST('infinity' AS DOUBLE);
SELECT INTERVAL '5' DAYS * CAST('-infinity' AS DOUBLE);
SELECT INTERVAL 'infinity' / 'infinity';
SELECT INTERVAL 'infinity' / '-infinity';
SELECT INTERVAL 'infinity' / 'nan';
SELECT INTERVAL '-infinity' / 'infinity';
SELECT INTERVAL '-infinity' / '-infinity';
SELECT INTERVAL '-infinity' / 'nan';
SELECT INTERVAL '-1073741824 months -1073741824 days -4611686018427387904 us' / 0.5;
SELECT DATE_BIN('infinity', CAST('2001-02-16 20:38:40' AS TIMESTAMP), CAST('2001-02-16 20:05:00' AS TIMESTAMP));
SELECT DATE_BIN('-infinity', CAST('2001-02-16 20:38:40' AS TIMESTAMP), CAST('2001-02-16 20:05:00' AS TIMESTAMP));
SELECT x AS x, TIMESTAMP_TRUNC(x, HOUR) FROM x WHERE NOT ISFINITE(x);
SELECT x AS x, TIMESTAMP_TRUNC(x, WEEK) FROM x WHERE NOT ISFINITE(x);
SELECT x AS x, TIMESTAMP_TRUNC(x, AGO) FROM x WHERE NOT ISFINITE(x);
SELECT x AS x, JUSTIFY_DAYS(x), JUSTIFY_HOURS(x), JUSTIFY_INTERVAL(x) FROM x WHERE NOT ISFINITE(x);
SELECT TIMEZONE(CAST('infinity' AS INTERVAL), CAST('1995-08-06 12:12:12' AS TIMESTAMP));
SELECT TIMEZONE(CAST('-infinity' AS INTERVAL), CAST('1995-08-06 12:12:12' AS TIMESTAMP));
SELECT TIMEZONE(CAST('infinity' AS INTERVAL), CAST('1995-08-06 12:12:12' AS TIMESTAMPTZ));
SELECT TIMEZONE(CAST('-infinity' AS INTERVAL), CAST('1995-08-06 12:12:12' AS TIMESTAMPTZ));
SELECT TIMEZONE(CAST('infinity' AS INTERVAL), CAST('12:12:12' AS TIME));
SELECT TIMEZONE(CAST('-infinity' AS INTERVAL), CAST('12:12:12' AS TIME));
SELECT TIMEZONE(CAST('infinity' AS INTERVAL), CAST('12:12:12' AS TIMETZ));
SELECT TIMEZONE(CAST('-infinity' AS INTERVAL), CAST('12:12:12' AS TIMETZ));
SELECT CAST(CAST('infinity' AS INTERVAL) AS TIME);
SELECT CAST(CAST('-infinity' AS INTERVAL) AS TIME);
SELECT TIME_TO_STR(CAST('infinity' AS INTERVAL), '%Y');
SELECT TIME_TO_STR(CAST('-infinity' AS INTERVAL), '%Y');
/* "ago" can only appear once at the end of an interval. */ SELECT INTERVAL '42 days 2 seconds ago ago';
SELECT INTERVAL '2 minutes ago 5 days';
/* consecutive and dangling units are not allowed. */ SELECT INTERVAL '5' MONTHS;
SELECT INTERVAL '1 year months days 5 hours';
/* unacceptable reserved words in interval. Only "infinity", "+infinity" and */ /* "-infinity" are allowed. */ SELECT INTERVAL 'now';
SELECT INTERVAL 'today';
SELECT INTERVAL 'tomorrow';
SELECT INTERVAL 'allballs';
SELECT INTERVAL 'epoch';
SELECT INTERVAL 'yesterday';
/* infinity specification should be the only thing */ SELECT INTERVAL 'infinity years';
SELECT INTERVAL 'infinity ago';
SELECT INTERVAL '+infinity -infinity';
/* JOIN */ /* Test JOIN clauses */ CREATE TABLE x (x INT, x INT, x TEXT);
CREATE TABLE x (x INT, x INT);
INSERT INTO x VALUES (1, 4, 'one');
INSERT INTO x VALUES (2, 3, 'two');
INSERT INTO x VALUES (3, 2, 'three');
INSERT INTO x VALUES (4, 1, 'four');
INSERT INTO x VALUES (5, 0, 'five');
INSERT INTO x VALUES (6, 6, 'six');
INSERT INTO x VALUES (7, 7, 'seven');
INSERT INTO x VALUES (8, 8, 'eight');
INSERT INTO x VALUES (0, NULL, 'zero');
INSERT INTO x VALUES (NULL, NULL, 'null');
INSERT INTO x VALUES (NULL, 0, 'zero');
INSERT INTO x VALUES (1, -1);
INSERT INTO x VALUES (2, 2);
INSERT INTO x VALUES (3, -3);
INSERT INTO x VALUES (2, 4);
INSERT INTO x VALUES (5, -5);
INSERT INTO x VALUES (5, -5);
INSERT INTO x VALUES (0, NULL);
INSERT INTO x VALUES (NULL, NULL);
INSERT INTO x VALUES (NULL, 0);
/* useful in some tests below */ CREATE TEMPORARY TABLE x;
ANALYZE x;
/* CORRELATION NAMES */ /* Make sure that table/column aliases are supported */ /* before diving into more complex join syntax. */ SELECT * FROM x AS x;
SELECT * FROM x AS x;
SELECT * FROM x AS x;
SELECT * FROM x AS x;
SELECT * FROM x AS x, x AS x;
SELECT x.x, x.x FROM x AS x, x AS x WHERE x.x = x.x;
/* CROSS JOIN */ /* Qualifications are not allowed on cross joins, */ /* which degenerate into a standard unqualified inner join. */ SELECT * FROM x CROSS JOIN x;
/* ambiguous column */ SELECT x, x, x FROM x CROSS JOIN x;
/* resolve previous ambiguity by specifying the table name */ SELECT x.x, x, x FROM x AS x CROSS JOIN x AS x;
SELECT x, x, x FROM (x CROSS JOIN x) AS x;
SELECT x.x, x.x, x.x FROM (x AS x CROSS JOIN x AS x) AS x;
SELECT * FROM x CROSS JOIN x AS x CROSS JOIN x AS x;
/* Inner joins (equi-joins) */ /* Inner joins (equi-joins) with USING clause */ /* The USING syntax changes the shape of the resulting table */ /* by including a column in the USING clause only once in the result. */ /* Inner equi-join on specified column */ SELECT * FROM x INNER JOIN x USING (x);
/* Same as above, slightly different syntax */ SELECT * FROM x JOIN x USING (x);
SELECT * FROM x AS x JOIN x AS x USING (x) ORDER BY x NULLS LAST, x NULLS LAST;
SELECT * FROM x AS x JOIN x AS x USING (x) ORDER BY x NULLS LAST, x.x NULLS LAST;
/* test join using aliases */ SELECT * FROM x JOIN x USING (x) WHERE x.x = 'one';
/* ok */ SELECT * FROM (x JOIN x USING (x)) AS x WHERE x.x = 'one';
/* NATURAL JOIN */ /* Inner equi-join on all columns with the same name */ SELECT * FROM x NATURAL JOIN x;
SELECT * FROM x AS x NATURAL JOIN x AS x;
SELECT * FROM x AS x NATURAL JOIN x AS x;
/* mismatch number of columns */ /* currently, Postgres will fill in with underlying names */ SELECT * FROM x AS x NATURAL JOIN x AS x;
/* Inner joins (equi-joins) */ SELECT * FROM x JOIN x ON (x.x = x.x);
SELECT * FROM x JOIN x ON (x.x = x.x);
/* Non-equi-joins */ SELECT * FROM x JOIN x ON (x.x <= x.x);
/* Outer joins */ /* Note that OUTER is a noise word */ SELECT * FROM x LEFT OUTER JOIN x USING (x) ORDER BY x NULLS LAST, x NULLS LAST, x NULLS LAST;
SELECT * FROM x LEFT JOIN x USING (x) ORDER BY x NULLS LAST, x NULLS LAST, x NULLS LAST;
SELECT * FROM x RIGHT OUTER JOIN x USING (x);
SELECT * FROM x RIGHT JOIN x USING (x);
SELECT * FROM x FULL OUTER JOIN x USING (x) ORDER BY x NULLS LAST, x NULLS LAST, x NULLS LAST;
SELECT * FROM x FULL JOIN x USING (x) ORDER BY x NULLS LAST, x NULLS LAST, x NULLS LAST;
SELECT * FROM x LEFT JOIN x USING (x) WHERE (x = 1);
SELECT * FROM x LEFT JOIN x USING (x) WHERE (x = 1);
/* semijoin selectivity for <> */ EXPLAIN (costs off) select * from tenk1 a, tenk1 b where exists(select * from tenk1 c              where b.twothousand = c.twothousand and b.fivethous <> c.fivethous)       and a.tenthous = b.tenthous and a.tenthous < 5000;
/* More complicated constructs */ /* Multiway full join */ CREATE TABLE x (x TEXT, x INT);
CREATE TABLE x (x TEXT, x INT);
CREATE TABLE x (x TEXT, x INT);
INSERT INTO x VALUES ('bb', 11);
INSERT INTO x VALUES ('bb', 12);
INSERT INTO x VALUES ('cc', 22);
INSERT INTO x VALUES ('ee', 42);
INSERT INTO x VALUES ('bb', 13);
INSERT INTO x VALUES ('cc', 23);
INSERT INTO x VALUES ('dd', 33);
SELECT * FROM x FULL JOIN x USING (x) FULL JOIN x USING (x);
/* Test interactions of join syntax and subqueries */ /* Basic cases (we expect planner to pull up the subquery here) */ SELECT * FROM (SELECT * FROM x) AS x INNER JOIN (SELECT * FROM x) AS x USING (x);
SELECT * FROM (SELECT * FROM x) AS x LEFT JOIN (SELECT * FROM x) AS x USING (x);
SELECT * FROM (SELECT * FROM x) AS x FULL JOIN (SELECT * FROM x) AS x USING (x);
/* make sure these go to null as expected */ SELECT * FROM (SELECT x, x AS x, 2 AS x FROM x) AS x NATURAL INNER JOIN (SELECT x, x AS x, 3 AS x FROM x) AS x;
SELECT * FROM (SELECT x, x AS x, 2 AS x FROM x) AS x NATURAL LEFT JOIN (SELECT x, x AS x, 3 AS x FROM x) AS x;
SELECT * FROM (SELECT x, x AS x, 2 AS x FROM x) AS x NATURAL FULL JOIN (SELECT x, x AS x, 3 AS x FROM x) AS x;
SELECT * FROM (SELECT x, x AS x, 1 AS x FROM x) AS x NATURAL INNER JOIN (SELECT x, x AS x, 2 AS x FROM x) AS x NATURAL INNER JOIN (SELECT x, x AS x, 3 AS x FROM x) AS x;
SELECT * FROM (SELECT x, x AS x, 1 AS x FROM x) AS x NATURAL FULL JOIN (SELECT x, x AS x, 2 AS x FROM x) AS x NATURAL FULL JOIN (SELECT x, x AS x, 3 AS x FROM x) AS x;
SELECT * FROM (SELECT x, x AS x FROM x) AS x NATURAL FULL JOIN (SELECT * FROM (SELECT x, x AS x FROM x) AS x NATURAL FULL JOIN (SELECT x, x AS x FROM x) AS x) AS x;
SELECT * FROM (SELECT x, x AS x FROM x) AS x NATURAL FULL JOIN (SELECT * FROM (SELECT x, x AS x, 2 AS x FROM x) AS x NATURAL FULL JOIN (SELECT x, x AS x FROM x) AS x) AS x;
/* Constants as join keys can also be problematic */ SELECT * FROM (SELECT x, x AS x FROM x) AS x FULL JOIN (SELECT x, 2 AS x FROM x) AS x ON (x = x);
/* Test for propagation of nullability constraints into sub-joins */ CREATE TEMPORARY TABLE x (x INT, x INT);
INSERT INTO x VALUES (1, 11);
INSERT INTO x VALUES (2, 22);
INSERT INTO x VALUES (3, NULL);
INSERT INTO x VALUES (4, 44);
INSERT INTO x VALUES (5, NULL);
CREATE TEMPORARY TABLE x (x INT, x INT);
INSERT INTO x VALUES (1, 111);
INSERT INTO x VALUES (2, 222);
INSERT INTO x VALUES (3, 333);
INSERT INTO x VALUES (4, NULL);
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x LEFT JOIN x ON (x = x AND NOT x IS NULL);
SELECT * FROM x LEFT JOIN x ON (x = x AND NOT x IS NULL);
SELECT * FROM (x LEFT JOIN x ON (x = x)) LEFT JOIN x AS x ON (x = x);
SELECT * FROM (x LEFT JOIN x ON (x = x)) LEFT JOIN x AS x ON (x = x AND NOT x IS NULL);
SELECT * FROM (x LEFT JOIN x ON (x = x)) LEFT JOIN x AS x ON (x = x AND NOT x IS NULL);
SELECT * FROM (x LEFT JOIN x ON (x = x)) LEFT JOIN x AS x ON (x = x AND NOT x IS NULL);
/* these should NOT give the same answers as above */ SELECT * FROM (x LEFT JOIN x ON (x = x)) LEFT JOIN x AS x ON (x = x) WHERE (NOT x IS NULL);
SELECT * FROM (x LEFT JOIN x ON (x = x)) LEFT JOIN x AS x ON (x = x) WHERE (NOT x IS NULL);
SELECT * FROM (x LEFT JOIN x ON (x = x)) LEFT JOIN x AS x ON (x = x) WHERE (NOT x IS NULL);
/* regression test: check for bug with propagation of implied equality */ /* to outside an IN */ SELECT COUNT(*) FROM x AS x WHERE x IN (SELECT x FROM x AS x JOIN x AS x USING (x) WHERE x.x = 42);
/* regression test: check for failure to generate a plan with multiple */ /* degenerate IN clauses */ SELECT COUNT(*) FROM x AS x WHERE x.x IN (SELECT x.x FROM x AS x, x AS x WHERE x.x = x.x) AND x.x = 0 AND x.x IN (SELECT x.x FROM x AS x, x AS x WHERE x.x = x.x);
/* try that with GEQO too */ BEGIN;
SET x = on;
SET x = 2;
SELECT COUNT(*) FROM x AS x WHERE x.x IN (SELECT x.x FROM x AS x, x AS x WHERE x.x = x.x) AND x.x = 0 AND x.x IN (SELECT x.x FROM x AS x, x AS x WHERE x.x = x.x);
ROLLBACK;
/* regression test: be sure we cope with proven-dummy append rels */ EXPLAIN (costs off) select aa, bb, unique1, unique1   from tenk1 right join b_star on aa = unique1   where bb < bb and bb is null;
SELECT x, x, x, x FROM x RIGHT JOIN x ON x = x WHERE x < x AND x IS NULL;
/* regression test: check handling of empty-FROM subquery underneath outer join */ EXPLAIN (costs off) select * from int8_tbl i1 left join (int8_tbl i2 join   (select 123 as x) ss on i2.q1 = x) on i1.q2 = i2.q2 order by 1, 2;
SELECT * FROM x AS x LEFT JOIN (x AS x JOIN (SELECT 123 AS x) AS x ON x.x = x) ON x.x = x.x ORDER BY 1 NULLS LAST, 2 NULLS LAST;
/* regression test: check a case where join_clause_is_movable_into() */ /* used to give an imprecise result, causing an assertion failure */ SELECT COUNT(*) FROM (SELECT x.x AS x, COALESCE(x.x, x.x) AS x FROM x AS x LEFT JOIN x AS x ON x.x = x.x JOIN x AS x ON x.x = x.x) AS x, x AS x, x AS x WHERE x.x = x.x AND x.x = x.x AND x.x = x.x;
/* regression test: check a case where we formerly missed including an EC */ /* enforcement clause because it was expected to be handled at scan level */ EXPLAIN (costs off) select a.f1, b.f1, t.thousand, t.tenthous from   tenk1 t,   (select sum(f1)+1 as f1 from int4_tbl i4a) a,   (select sum(f1) as f1 from int4_tbl i4b) b where b.f1 = t.thousand and a.f1 = b.f1 and (a.f1+b.f1+999) = t.tenthous;
SELECT x.x, x.x, x.x, x.x FROM x AS x, (SELECT SUM(x) + 1 AS x FROM x AS x) AS x, (SELECT SUM(x) AS x FROM x AS x) AS x WHERE x.x = x.x AND x.x = x.x AND (x.x + x.x + 999) = x.x;
/* Test hash joins with multiple hash keys and subplans. */ /* First ensure we get a hash join with multiple hash keys. */ EXPLAIN (costs off) select t1.unique1,t2.unique1 from tenk1 t1 inner join tenk1 t2 on t1.two = t2.two   and t1.unique1 = (select min(unique1) from tenk1                     where t2.unique1=unique1) where t1.unique1 < 10 and t2.unique1 < 10 order by t1.unique1;
/* Ensure we get the expected result */ SELECT x.x, x.x FROM x AS x INNER JOIN x AS x ON x.x = x.x AND x.x = (SELECT MIN(x) FROM x WHERE x.x = x) WHERE x.x < 10 AND x.x < 10 ORDER BY x.x NULLS LAST;
/* checks for correct handling of quals in multiway outer joins */ EXPLAIN (costs off) select t1.f1 from int4_tbl t1, int4_tbl t2   left join int4_tbl t3 on t3.f1 > 0   left join int4_tbl t4 on t3.f1 > 1 where t4.f1 is null;
SELECT x.x FROM x AS x, x AS x LEFT JOIN x AS x ON x.x > 0 LEFT JOIN x AS x ON x.x > 1 WHERE x.x IS NULL;
EXPLAIN (costs off) select * from int4_tbl t1 left join int4_tbl t2 on true   left join int4_tbl t3 on t2.f1 > 0   left join int4_tbl t4 on t3.f1 > 0;
EXPLAIN (costs off) select * from onek t1   left join onek t2 on t1.unique1 = t2.unique1   left join onek t3 on t2.unique1 != t3.unique1   left join onek t4 on t3.unique1 = t4.unique1;
EXPLAIN (costs off) select * from int4_tbl t1   left join (select now() from int4_tbl t2              left join int4_tbl t3 on t2.f1 = t3.f1              left join int4_tbl t4 on t3.f1 = t4.f1) s on true   inner join int4_tbl t5 on true;
EXPLAIN (costs off) select * from int4_tbl t1   left join int4_tbl t2 on true   left join int4_tbl t3 on true   left join int4_tbl t4 on t2.f1 = t3.f1;
EXPLAIN (costs off) select * from int4_tbl t1   left join int4_tbl t2 on true   left join int4_tbl t3 on t2.f1 = t3.f1   left join int4_tbl t4 on t3.f1 != t4.f1;
EXPLAIN (costs off) select * from int4_tbl t1   left join (int4_tbl t2 left join int4_tbl t3 on t2.f1 > 0) on t2.f1 > 1   left join int4_tbl t4 on t2.f1 > 2 and t3.f1 > 3 where t1.f1 = coalesce(t2.f1, 1);
EXPLAIN (costs off) select * from int4_tbl t1   left join ((select t2.f1 from int4_tbl t2                 left join int4_tbl t3 on t2.f1 > 0                 where t3.f1 is null) s              left join tenk1 t4 on s.f1 > 1)     on s.f1 = t1.f1;
EXPLAIN (costs off) select * from int4_tbl t1   left join ((select t2.f1 from int4_tbl t2                 left join int4_tbl t3 on t2.f1 > 0                 where t2.f1 <> coalesce(t3.f1, -1)) s              left join tenk1 t4 on s.f1 > 1)     on s.f1 = t1.f1;
EXPLAIN (costs off) select * from onek t1     left join onek t2 on t1.unique1 = t2.unique1     left join onek t3 on t2.unique1 = t3.unique1     left join onek t4 on t3.unique1 = t4.unique1 and t2.unique2 = t4.unique2;
EXPLAIN (costs off) select * from int8_tbl t1 left join     (int8_tbl t2 left join int8_tbl t3 full join int8_tbl t4 on false on false)     left join int8_tbl t5 on t2.q1 = t5.q1 on t2.q2 = 123;
EXPLAIN (costs off) select * from int8_tbl t1     left join int8_tbl t2 on true     left join lateral       (select * from int8_tbl t3 where t3.q1 = t2.q1 offset 0) s       on t2.q1 = 1;
EXPLAIN (costs off) select * from int8_tbl t1     left join int8_tbl t2 on true     left join lateral       (select * from generate_series(t2.q1, 100)) s       on t2.q1 = 1;
EXPLAIN (costs off) select * from int8_tbl t1     left join int8_tbl t2 on true     left join lateral       (select t2.q1 from int8_tbl t3) s       on t2.q1 = 1;
EXPLAIN (costs off) select * from onek t1     left join onek t2 on true     left join lateral       (select * from onek t3 where t3.two = t2.two offset 0) s       on t2.unique1 = 1;
/* check a case where we formerly got confused by conflicting sort orders */ /* in redundant merge join path keys */ EXPLAIN (costs off) select * from   j1_tbl full join   (select * from j2_tbl order by j2_tbl.i desc, j2_tbl.k asc) j2_tbl   on j1_tbl.i = j2_tbl.i and j1_tbl.i = j2_tbl.k;
SELECT * FROM x FULL JOIN (SELECT * FROM x ORDER BY x.x DESC NULLS FIRST, x.x ASC NULLS LAST) AS x ON x.x = x.x AND x.x = x.x;
/* a different check for handling of redundant sort keys in merge joins */ EXPLAIN (costs off) select count(*) from   (select * from tenk1 x order by x.thousand, x.twothousand, x.fivethous) x   left join   (select * from tenk1 y order by y.unique2) y   on x.thousand = y.unique2 and x.twothousand = y.hundred and x.fivethous = y.unique2;
SELECT COUNT(*) FROM (SELECT * FROM x AS x ORDER BY x.x NULLS LAST, x.x NULLS LAST, x.x NULLS LAST) AS x LEFT JOIN (SELECT * FROM x AS x ORDER BY x.x NULLS LAST) AS x ON x.x = x.x AND x.x = x.x AND x.x = x.x;
SET x = 0;
SET x = 0;
SET x = 0;
/* Check that we use the pathkeys from a prefix of the group by / order by */ /* clause for the join pathkeys when that prefix covers all join quals.  We */ /* expect this to lead to an incremental sort for the group by / order by. */ EXPLAIN (costs off) select x.thousand, x.twothousand, count(*) from tenk1 x inner join tenk1 y on x.thousand = y.thousand group by x.thousand, x.twothousand order by x.thousand desc, x.twothousand;
RESET enable_hashagg;
RESET enable_nestloop;
RESET enable_hashjoin;
/* Clean up */ DROP TABLE x;
DROP TABLE x;
DROP TABLE x;
DROP TABLE x;
DROP TABLE x;
/* Both DELETE and UPDATE allow the specification of additional tables */ /* to "join" against to determine which rows should be modified. */ CREATE TEMPORARY TABLE x (x INT, x INT);
CREATE TEMPORARY TABLE x (x INT, x INT);
CREATE TEMPORARY TABLE x (x INT, x INT);
INSERT INTO x VALUES (5, 10);
INSERT INTO x VALUES (15, 20);
INSERT INTO x VALUES (100, 100);
INSERT INTO x VALUES (200, 1000);
INSERT INTO x VALUES (200, 2000);
INSERT INTO x VALUES (5, 20);
INSERT INTO x VALUES (6, 7);
INSERT INTO x VALUES (7, 8);
INSERT INTO x VALUES (500, 100);
DELETE FROM x USING x AS x WHERE x.x = x.x;
SELECT * FROM x;
DELETE FROM x USING x JOIN x USING (x) WHERE x.x > x.x;
SELECT * FROM x;
DELETE FROM x USING x AS x WHERE x.x = x.x AND x.x = x.x;
SELECT * FROM x;
/* Test join against inheritance tree */ CREATE TEMPORARY TABLE x INHERITS (x);
INSERT INTO x VALUES (200, 2001);
SELECT * FROM x LEFT JOIN x ON (x.x = x.x);
/* Test matching of column name with wrong alias */ SELECT x.x FROM x JOIN x ON (x.x = x.x);
/* Test matching of locking clause with wrong alias */ SELECT x.*, x.*, x.* FROM x JOIN x ON (x.x = x.x), x AS x;
/* regression test for 8.1 merge right join bug */ CREATE TEMPORARY TABLE x (x INT, x INT);
INSERT INTO x VALUES (1, 11);
INSERT INTO x VALUES (2, NULL);
CREATE TEMPORARY TABLE x (x INT, x INT);
INSERT INTO x VALUES (21, 11);
INSERT INTO x VALUES (22, 11);
SET x = off;
SET x = off;
/* these should give the same results */ SELECT x.*, x.* FROM x LEFT JOIN x ON x.x = x.x;
SELECT x.*, x.* FROM x RIGHT JOIN x ON x.x = x.x;
RESET enable_hashjoin;
RESET enable_nestloop;
/* regression test for bug #18522 (merge-right-anti-join in inner_unique cases) */ CREATE TEMPORARY TABLE x (x INT UNIQUE, x INT);
INSERT INTO x SELECT x, x % 100 FROM x AS x;
CREATE INDEX ON x(x NULLS LAST);
ANALYZE x;
SET x = off;
SET x = off;
/* ensure we get a merge right anti join */ EXPLAIN (costs off) select * from tbl_ra t1 where not exists (select 1 from tbl_ra t2 where t2.b = t1.a) and t1.b < 2;
/* and check we get the expected results */ SELECT * FROM x AS x WHERE NOT EXISTS(SELECT 1 FROM x AS x WHERE x.x = x.x) AND x.x < 2;
RESET enable_hashjoin;
RESET enable_nestloop;
/* regression test for bug with hash-right-semi join */ CREATE TEMPORARY TABLE x (x INT, x INT);
INSERT INTO x SELECT x, x FROM x AS x;
ANALYZE x;
/* ensure we get a hash right semi join */ EXPLAIN (costs off) select * from tbl_rs t1 join   lateral (select * from tbl_rs t2 where t2.a in             (select t1.a+t3.a from tbl_rs t3) and t2.a < 5)   on true;
/* and check we get the expected results */ SELECT * FROM x AS x JOIN LATERAL (SELECT * FROM x AS x WHERE x.x IN (SELECT x.x + x.x FROM x AS x) AND x.x < 5) ON TRUE;
SET x = '64kB' /* regression test for bug #13908 (hash join with skew tuples & nbatch increase) */;
SET x = off;
SET x = off;
EXPLAIN (costs off) select count(*) from tenk1 a, tenk1 b   where a.hundred = b.thousand and (b.fivethous % 10) < 10;
SELECT COUNT(*) FROM x AS x, x AS x WHERE x.x = x.x AND (x.x % 10) < 10;
RESET work_mem;
RESET enable_mergejoin;
RESET enable_memoize;
/* regression test for 8.2 bug with improper re-ordering of left joins */ CREATE TEMPORARY TABLE x (x INT, x TEXT);
INSERT INTO x SELECT x, REPEAT('xyzzy', 100) FROM x AS x;
ANALYZE x;
CREATE TEMPORARY TABLE x (x INT);
INSERT INTO x VALUES (0), (1), (9999);
ANALYZE x;
SET x = off;
EXPLAIN (COSTS OFF) SELECT a.f1 FROM tt4 a LEFT JOIN (         SELECT b.f1         FROM tt3 b LEFT JOIN tt3 c ON (b.f1 = c.f1)         WHERE COALESCE(c.f1, 0) = 0 ) AS d ON (a.f1 = d.f1) WHERE COALESCE(d.f1, 0) = 0 ORDER BY 1;
SELECT x.x FROM x AS x LEFT JOIN (SELECT x.x FROM x AS x LEFT JOIN x AS x ON (x.x = x.x) WHERE COALESCE(x.x, 0) = 0) AS x ON (x.x = x.x) WHERE COALESCE(x.x, 0) = 0 ORDER BY 1 NULLS LAST;
RESET enable_nestloop;
/* basic semijoin and antijoin recognition tests */ EXPLAIN (costs off) select a.* from tenk1 a where unique1 in (select unique2 from tenk1 b);
/* sadly, this is not an antijoin */ EXPLAIN (costs off) select a.* from tenk1 a where unique1 not in (select unique2 from tenk1 b);
EXPLAIN (costs off) select a.* from tenk1 a where exists (select 1 from tenk1 b where a.unique1 = b.unique2);
EXPLAIN (costs off) select a.* from tenk1 a where not exists (select 1 from tenk1 b where a.unique1 = b.unique2);
EXPLAIN (costs off) select a.* from tenk1 a left join tenk1 b on a.unique1 = b.unique2 where b.unique2 is null;
/* regression test for bogus RTE_GROUP entries */ EXPLAIN (costs off) select a.* from tenk1 a where exists (select 1 from tenk1 b where a.unique1 = b.unique2 group by b.unique1);
/* regression test for proper handling of outer joins within antijoins */ CREATE TEMPORARY TABLE x (x INT, x INT, x INT);
EXPLAIN (costs off) select * from tt4x t1 where not exists (   select 1 from tt4x t2     left join tt4x t3 on t2.c3 = t3.c1     left join ( select t5.c1 as c1                 from tt4x t4 left join tt4x t5 on t4.c2 = t5.c1               ) a1 on t3.c2 = a1.c1   where t1.c1 = t2.c2 );
/* regression test for problems of the sort depicted in bug #3494 */ CREATE TEMPORARY TABLE x (x INT, x INT);
CREATE TEMPORARY TABLE x (x INT, x INT);
INSERT INTO x VALUES (1, 10);
INSERT INTO x VALUES (1, 11);
INSERT INTO x VALUES (1, 9);
INSERT INTO x VALUES (1, 2);
INSERT INTO x VALUES (2, 9);
SELECT * FROM x, x WHERE x.x = x.x AND x.x = x.x - x.x;
/* regression test for problems of the sort depicted in bug #3588 */ CREATE TEMPORARY TABLE x (x INT);
CREATE TEMPORARY TABLE x (x INT, x INT);
INSERT INTO x VALUES (1);
INSERT INTO x VALUES (2);
INSERT INTO x VALUES (3);
INSERT INTO x VALUES (101, 1);
INSERT INTO x VALUES (201, 2);
INSERT INTO x VALUES (301, NULL);
SELECT x.x AS x, x.x AS x, x.x AS x, x.x AS x, x.x AS x FROM x LEFT JOIN (SELECT * FROM x WHERE x = 101) AS x ON x.x = x.x LEFT JOIN x AS x ON x.x = x.x LEFT JOIN x AS x ON COALESCE(x.x, 1) = x.x;
/* regression test for improper pushing of constants across outer-join clauses */ /* (as seen in early 8.2.x releases) */ CREATE TEMPORARY TABLE x (x INT PRIMARY KEY);
CREATE TEMPORARY TABLE x (x INT PRIMARY KEY);
CREATE TEMPORARY TABLE x (x INT PRIMARY KEY);
INSERT INTO x VALUES (53);
INSERT INTO x VALUES (53);
SELECT * FROM x LEFT JOIN x ON (x = x) LEFT JOIN x ON (x = x) WHERE x = 53;
CREATE TEMPORARY VIEW x AS SELECT *, CAST('dummy' AS TEXT) AS x FROM x;
SELECT * FROM x LEFT JOIN x ON (x = x) LEFT JOIN x ON (x = x) WHERE x = 53;
/* regression test for improper extraction of OR indexqual conditions */ /* (as seen in early 8.3.x releases) */ SELECT x.x, x.x, x.x, x.x, x.x FROM x AS x LEFT JOIN x AS x ON x.x = x.x WHERE x.x = 42 AND ((x.x IS NULL AND x.x = 2) OR x.x = 3);
/* test proper positioning of one-time quals in EXISTS (8.4devel bug) */ PREPARE foo(bool) as   select count(*) from tenk1 a left join tenk1 b     on (a.unique2 = b.unique1 and exists         (select 1 from tenk1 c where c.thousand = b.unique2 and $1));
EXECUTE foo(true);
EXECUTE foo(false);
/* test for sane behavior with noncanonical merge clauses, per bug #4926 */ BEGIN;
SET x = 1;
SET x = 0;
SET x = 0;
CREATE TEMPORARY TABLE x (x INT);
CREATE TEMPORARY TABLE x (x INT, x INT);
SELECT * FROM x LEFT JOIN x ON x = x AND x = x AND x = x;
ROLLBACK;
/* test handling of merge clauses using record_ops */ BEGIN;
create type mycomptype as (id int, v bigint);
CREATE TEMPORARY TABLE x (x mycomptype);
CREATE INDEX ON x(x NULLS LAST);
EXPLAIN (costs off) select a.idv, b.idv from tidv a, tidv b where a.idv = b.idv;
SET x = 0;
SET x = 0;
EXPLAIN (costs off) select a.idv, b.idv from tidv a, tidv b where a.idv = b.idv;
ROLLBACK;
/* test NULL behavior of whole-row Vars, per bug #5025 */ SELECT x.x, COUNT(x.*) FROM x AS x LEFT JOIN x AS x ON (x.x = x.x) GROUP BY x.x ORDER BY 1 NULLS LAST;
SELECT x.x, COUNT(x.*) FROM x AS x LEFT JOIN (SELECT * FROM x) AS x ON (x.x = x.x) GROUP BY x.x ORDER BY 1 NULLS LAST;
SELECT x.x, COUNT(x.*) FROM x AS x LEFT JOIN (SELECT * FROM x OFFSET 0) AS x ON (x.x = x.x) GROUP BY x.x ORDER BY 1 NULLS LAST;
SELECT x.x, COUNT(x.*) FROM x AS x LEFT JOIN (SELECT x, CASE WHEN x = 1 THEN 1 ELSE x END AS x FROM x) AS x ON (x.x = x.x) GROUP BY x.x ORDER BY 1 NULLS LAST;
/* test incorrect failure to NULL pulled-up subexpressions */ BEGIN;
CREATE TEMPORARY TABLE x (x CHAR NOT NULL, CONSTRAINT x PRIMARY KEY (x NULLS LAST));
CREATE TEMPORARY TABLE x (x CHAR NOT NULL, x INT NOT NULL, CONSTRAINT x PRIMARY KEY (x NULLS LAST, x NULLS LAST));
CREATE TEMPORARY TABLE x (x CHAR NOT NULL, x CHAR, CONSTRAINT x PRIMARY KEY (x NULLS LAST));
INSERT INTO x (x) VALUES ('p');
INSERT INTO x (x) VALUES ('q');
INSERT INTO x (x, x) VALUES ('p', 1);
INSERT INTO x (x, x) VALUES ('p', 2);
INSERT INTO x (x, x) VALUES ('A', 'p');
INSERT INTO x (x, x) VALUES ('B', 'q');
INSERT INTO x (x, x) VALUES ('C', NULL);
SELECT x.x, x.x, x.x, x.x FROM x LEFT JOIN (SELECT x.x, COALESCE(x.x, 0) AS x, -1 AS x FROM x LEFT JOIN (SELECT COUNT(1) AS x, x.x FROM x GROUP BY x.x) AS x ON x.x = x.x) AS x ON (x.x = x.x) ORDER BY x.x NULLS LAST;
ROLLBACK;
/* test incorrect handling of placeholders that only appear in targetlists, */ /* per bug #6154 */ SELECT * FROM (SELECT 1 AS x) AS x LEFT JOIN (SELECT x.x, x.x, COALESCE(x.x, 66) AS x FROM (SELECT 1 AS x) AS x LEFT JOIN (SELECT x.x, COALESCE(x.x, 1) AS x FROM (SELECT 1 AS x) AS x LEFT JOIN (SELECT 2 AS x, 42 AS x) AS x ON x.x = x.x) AS x ON x.x = x.x) AS x ON x.x = x.x;
/* test the path using join aliases, too */ SELECT * FROM (SELECT 1 AS x) AS x LEFT JOIN (SELECT x.x, x, COALESCE(x, 66) AS x FROM (SELECT 1 AS x) AS x LEFT JOIN (SELECT x.x, COALESCE(x.x, 1) AS x FROM (SELECT 1 AS x) AS x LEFT JOIN (SELECT 2 AS x, 42 AS x) AS x ON x.x = x.x) AS x ON x.x = x.x) AS x ON x.x = x.x;
/* test case where a PlaceHolderVar is used as a nestloop parameter */ EXPLAIN (COSTS OFF) SELECT qq, unique1   FROM   ( SELECT COALESCE(q1, 0) AS qq FROM int8_tbl a ) AS ss1   FULL OUTER JOIN   ( SELECT COALESCE(q2, -1) AS qq FROM int8_tbl b ) AS ss2   USING (qq)   INNER JOIN tenk1 c ON qq = unique2;
SELECT x, x FROM (SELECT COALESCE(x, 0) AS x FROM x AS x) AS x FULL OUTER JOIN (SELECT COALESCE(x, -1) AS x FROM x AS x) AS x USING (x) INNER JOIN x AS x ON x = x;
/* nested nestloops can require nested PlaceHolderVars */ CREATE TEMPORARY TABLE x (x INT PRIMARY KEY, x BOOLEAN, x BOOLEAN);
CREATE TEMPORARY TABLE x (x INT PRIMARY KEY, x INT, x BOOLEAN, x BOOLEAN, FOREIGN KEY (x) REFERENCES x (x));
CREATE TEMPORARY TABLE x (x INT PRIMARY KEY, x INT, x BOOLEAN, FOREIGN KEY (x) REFERENCES x (x));
INSERT INTO x VALUES (1, TRUE, TRUE);
INSERT INTO x VALUES (2, TRUE, FALSE);
INSERT INTO x VALUES (3, FALSE, FALSE);
INSERT INTO x VALUES (1, 1, TRUE, TRUE);
INSERT INTO x VALUES (2, 2, TRUE, FALSE);
INSERT INTO x VALUES (3, 3, FALSE, FALSE);
INSERT INTO x VALUES (1, 1, TRUE);
INSERT INTO x VALUES (2, 2, FALSE);
INSERT INTO x VALUES (3, 3, TRUE);
EXPLAIN (costs off) select nt3.id from nt3 as nt3   left join     (select nt2.*, (nt2.b1 and ss1.a3) AS b3      from nt2 as nt2        left join          (select nt1.*, (nt1.id is not null) as a3 from nt1) as ss1          on ss1.id = nt2.nt1_id     ) as ss2     on ss2.id = nt3.nt2_id where nt3.id = 1 and ss2.b3;
SELECT x.x FROM x AS x LEFT JOIN (SELECT x.*, (x.x AND x.x) AS x FROM x AS x LEFT JOIN (SELECT x.*, (NOT x.x IS NULL) AS x FROM x) AS x ON x.x = x.x) AS x ON x.x = x.x WHERE x.x = 1 AND x.x;
/* test case where a PlaceHolderVar is propagated into a subquery */ EXPLAIN (costs off) select * from   int8_tbl t1 left join   (select q1 as x, 42 as y from int8_tbl t2) ss   on t1.q2 = ss.x where   1 = (select 1 from int8_tbl t3 where ss.y is not null limit 1) order by 1,2;
SELECT * FROM x AS x LEFT JOIN (SELECT x AS x, 42 AS x FROM x AS x) AS x ON x.x = x.x WHERE 1 = (SELECT 1 FROM x AS x WHERE NOT x.x IS NULL LIMIT 1) ORDER BY 1 NULLS LAST, 2 NULLS LAST;
/* variant where a PlaceHolderVar is needed at a join, but not above the join */ EXPLAIN (costs off) select * from   int4_tbl as i41,   lateral     (select 1 as x from       (select i41.f1 as lat,               i42.f1 as loc from          int8_tbl as i81, int4_tbl as i42) as ss1       right join int4_tbl as i43 on (i43.f1 > 1)       where ss1.loc = ss1.lat) as ss2 where i41.f1 > 0;
SELECT * FROM x AS x, LATERAL (SELECT 1 AS x FROM (SELECT x.x AS x, x.x AS x FROM x AS x, x AS x) AS x RIGHT JOIN x AS x ON (x.x > 1) WHERE x.x = x.x) AS x WHERE x.x > 0;
/* test the corner cases FULL JOIN ON TRUE and FULL JOIN ON FALSE */ SELECT * FROM x AS x FULL JOIN x AS x ON TRUE;
SELECT * FROM x AS x FULL JOIN x AS x ON FALSE;
/* test for ability to use a cartesian join when necessary */ CREATE TEMPORARY TABLE x AS SELECT 1 AS x;
CREATE TEMPORARY TABLE x AS SELECT 0 AS x;
ANALYZE x;
ANALYZE x;
EXPLAIN (costs off) select * from   tenk1 join int4_tbl on f1 = twothousand,   q1, q2 where q1 = thousand or q2 = thousand;
EXPLAIN (costs off) select * from   tenk1 join int4_tbl on f1 = twothousand,   q1, q2 where thousand = (q1 + q2);
/* test ability to generate a suitable plan for a star-schema query */ EXPLAIN (costs off) select * from   tenk1, int8_tbl a, int8_tbl b where thousand = a.q1 and tenthous = b.q1 and a.q2 = 1 and b.q2 = 2;
/* test a corner case in which we shouldn't apply the star-schema optimization */ EXPLAIN (costs off) select t1.unique2, t1.stringu1, t2.unique1, t2.stringu2 from   tenk1 t1   inner join int4_tbl i1     left join (select v1.x2, v2.y1, 11 AS d1                from (select 1,0 from onerow) v1(x1,x2)                left join (select 3,1 from onerow) v2(y1,y2)                on v1.x1 = v2.y2) subq1     on (i1.f1 = subq1.x2)   on (t1.unique2 = subq1.d1)   left join tenk1 t2   on (subq1.y1 = t2.unique1) where t1.unique2 < 42 and t1.stringu1 > t2.stringu2;
SELECT x.x, x.x, x.x, x.x FROM x AS x INNER JOIN x AS x LEFT JOIN (SELECT x.x, x.x, 11 AS x FROM (SELECT 1, 0 FROM x) AS x LEFT JOIN (SELECT 3, 1 FROM x) AS x ON x.x = x.x) AS x ON (x.x = x.x) ON (x.x = x.x) LEFT JOIN x AS x ON (x.x = x.x) WHERE x.x < 42 AND x.x > x.x;
/* variant that isn't quite a star-schema case */ SELECT x.x FROM x AS x INNER JOIN x AS x ON x.x = x.x INNER JOIN x AS x LEFT JOIN x AS x INNER JOIN (SELECT CAST(64 AS information_schema.cardinal_number) AS x FROM x AS x, LATERAL (SELECT ABS(x.x) + RAND()) AS x WHERE x.x < 0) AS x ON x.x = x.x ON x.x = x.x ON x.x = x.x WHERE x.x < x.x;
/* this variant is foldable by the remove-useless-RESULT-RTEs code */ EXPLAIN (costs off) select t1.unique2, t1.stringu1, t2.unique1, t2.stringu2 from   tenk1 t1   inner join int4_tbl i1     left join (select v1.x2, v2.y1, 11 AS d1                from (values(1,0)) v1(x1,x2)                left join (values(3,1)) v2(y1,y2)                on v1.x1 = v2.y2) subq1     on (i1.f1 = subq1.x2)   on (t1.unique2 = subq1.d1)   left join tenk1 t2   on (subq1.y1 = t2.unique1) where t1.unique2 < 42 and t1.stringu1 > t2.stringu2;
SELECT x.x, x.x, x.x, x.x FROM x AS x INNER JOIN x AS x LEFT JOIN (SELECT x.x, x.x, 11 AS x FROM (VALUES (1, 0)) AS x LEFT JOIN (VALUES (3, 1)) AS x ON x.x = x.x) AS x ON (x.x = x.x) ON (x.x = x.x) LEFT JOIN x AS x ON (x.x = x.x) WHERE x.x < 42 AND x.x > x.x;
/* Here's a variant that we can't fold too aggressively, though, */ /* or we end up with noplace to evaluate the lateral PHV */ EXPLAIN (verbose, costs off) select * from   (select 1 as x) ss1 left join (select 2 as y) ss2 on (true),   lateral (select ss2.y as z limit 1) ss3;
SELECT * FROM (SELECT 1 AS x) AS x LEFT JOIN (SELECT 2 AS x) AS x ON (TRUE), LATERAL (SELECT x.x AS x LIMIT 1) AS x;
/* Test proper handling of appendrel PHVs during useless-RTE removal */ EXPLAIN (costs off) select * from   (select 0 as z) as t1   left join   (select true as a) as t2   on true,   lateral (select true as b            union all            select a as b) as t3 where b;
SELECT * FROM (SELECT 0 AS x) AS x LEFT JOIN (SELECT TRUE AS x) AS x ON TRUE, LATERAL (SELECT TRUE AS x UNION ALL SELECT x AS x) AS x WHERE x;
/* Test PHV in a semijoin qual, which confused useless-RTE removal (bug #17700) */ EXPLAIN (verbose, costs off) with ctetable as not materialized ( select 1 as f1 ) select * from ctetable c1 where f1 in ( select c3.f1 from ctetable c2 full join ctetable c3 on true );
WITH x AS NOT MATERIALIZED (SELECT 1 AS x) SELECT * FROM x AS x WHERE x IN (SELECT x.x FROM x AS x FULL JOIN x AS x ON TRUE);
/* Test PHV that winds up in a Result node, despite having nonempty nullingrels */ EXPLAIN (verbose, costs off) select table_catalog, table_name from int4_tbl t1   inner join (int8_tbl t2               left join information_schema.column_udt_usage on null)   on null;
/* Test handling of qual pushdown to appendrel members with non-Var outputs */ EXPLAIN (verbose, costs off) select * from int4_tbl left join (   select text 'foo' union all select text 'bar' ) ss(x) on true where ss.x is null;
COMMIT;
/* check optimization of function scan with join */ EXPLAIN (costs off) select unique1 from tenk1, (select * from f_immutable_int4(1) x) x where x = unique1;
EXPLAIN (verbose, costs off) select unique1, x.* from tenk1, (select *, random() from f_immutable_int4(1) x) x where x = unique1;
EXPLAIN (costs off) select unique1 from tenk1, f_immutable_int4(1) x where x = unique1;
EXPLAIN (costs off) select unique1 from tenk1, lateral f_immutable_int4(1) x where x = unique1;
EXPLAIN (costs off) select unique1 from tenk1, lateral f_immutable_int4(1) x where x in (select 17);
EXPLAIN (costs off) select unique1, x from tenk1 join f_immutable_int4(1) x on unique1 = x;
EXPLAIN (costs off) select unique1, x from tenk1 left join f_immutable_int4(1) x on unique1 = x;
EXPLAIN (costs off) select unique1, x from tenk1 right join f_immutable_int4(1) x on unique1 = x;
EXPLAIN (costs off) select unique1, x from tenk1 full join f_immutable_int4(1) x on unique1 = x;
/* check that pullup of a const function allows further const-folding */ EXPLAIN (costs off) select unique1 from tenk1, f_immutable_int4(1) x where x = 42;
/* test inlining of immutable functions with PlaceHolderVars */ EXPLAIN (costs off) select nt3.id from nt3 as nt3   left join     (select nt2.*, (nt2.b1 or i4 = 42) AS b3      from nt2 as nt2        left join          f_immutable_int4(0) i4          on i4 = nt2.nt1_id     ) as ss2     on ss2.id = nt3.nt2_id where nt3.id = 1 and ss2.b3;
DROP FUNCTION x (INT);
/* test inlining when function returns composite */ CREATE FUNCTION x(x, x) RETURNS int8_tbl LANGUAGE sql AS $$select row($1,$2)::int8_tbl$$;
CREATE FUNCTION x(x) RETURNS int4_tbl LANGUAGE sql AS $$select row($1)::int4_tbl$$;
EXPLAIN (verbose, costs off) select * from mki8(1,2);
SELECT * FROM x;
EXPLAIN (verbose, costs off) select * from mki4(42);
SELECT * FROM x;
DROP FUNCTION x (BIGINT, BIGINT);
DROP FUNCTION x (INT);
EXPLAIN (verbose, costs off) select (t2.*).unique1, f_field_select(t2) from tenk1 t1     left join onek t2 on t1.unique1 = t2.unique1     left join int8_tbl t3 on true;
/* test extraction of restriction OR clauses from join OR clause */ /* (we used to only do this for indexable clauses) */ EXPLAIN (costs off) select * from tenk1 a join tenk1 b on   (a.unique1 = 1 and b.unique1 = 2) or (a.unique2 = 3 and b.hundred = 4);
EXPLAIN (costs off) select * from tenk1 a join tenk1 b on   (a.unique1 = 1 and b.unique1 = 2) or (a.unique2 = 3 and b.ten = 4);
EXPLAIN (costs off) select * from tenk1 a join tenk1 b on   (a.unique1 = 1 and b.unique1 = 2) or   ((a.unique2 = 3 or a.unique2 = 7) and b.hundred = 4);
EXPLAIN (costs off) select * from tenk1 a join tenk1 b on   (a.unique1 = 1 and b.unique1 = 2) or   ((a.unique2 = 3 or a.unique2 = 7) and b.hundred = 4);
EXPLAIN (costs off) select * from tenk1 a join tenk1 b on   (a.unique1 < 20 or a.unique1 = 3 or a.unique1 = 1 and b.unique1 = 2) or   ((a.unique2 = 3 or a.unique2 = 7) and b.hundred = 4);
/* test placement of movable quals in a parameterized join tree */ EXPLAIN (costs off) select * from tenk1 t1 left join   (tenk1 t2 join tenk1 t3 on t2.thousand = t3.unique2)   on t1.hundred = t2.hundred and t1.ten = t3.ten where t1.unique1 = 1;
EXPLAIN (costs off) select * from tenk1 t1 left join   (tenk1 t2 join tenk1 t3 on t2.thousand = t3.unique2)   on t1.hundred = t2.hundred and t1.ten + t2.ten = t3.ten where t1.unique1 = 1;
EXPLAIN (costs off) select count(*) from   tenk1 a join tenk1 b on a.unique1 = b.unique2   left join tenk1 c on a.unique2 = b.unique1 and c.thousand = a.thousand   join int4_tbl on b.thousand = f1;
SELECT COUNT(*) FROM x AS x JOIN x AS x ON x.x = x.x LEFT JOIN x AS x ON x.x = x.x AND x.x = x.x JOIN x ON x.x = x;
EXPLAIN (costs off) select b.unique1 from   tenk1 a join tenk1 b on a.unique1 = b.unique2   left join tenk1 c on b.unique1 = 42 and c.thousand = a.thousand   join int4_tbl i1 on b.thousand = f1   right join int4_tbl i2 on i2.f1 = b.tenthous   order by 1;
SELECT x.x FROM x AS x JOIN x AS x ON x.x = x.x LEFT JOIN x AS x ON x.x = 42 AND x.x = x.x JOIN x AS x ON x.x = x RIGHT JOIN x AS x ON x.x = x.x ORDER BY 1 NULLS LAST;
EXPLAIN (costs off) select * from (   select unique1, q1, coalesce(unique1, -1) + q1 as fault   from int8_tbl left join tenk1 on (q2 = unique2) ) ss where fault = 122 order by fault;
SELECT * FROM (SELECT x, x, COALESCE(x, -1) + x AS x FROM x LEFT JOIN x ON (x = x)) AS x WHERE x = 122 ORDER BY x NULLS LAST;
EXPLAIN (costs off) select * from (values (1, array[10,20]), (2, array[20,30])) as v1(v1x,v1ys) left join (values (1, 10), (2, 20)) as v2(v2x,v2y) on v2x = v1x left join unnest(v1ys) as u1(u1y) on u1y = v2y;
SELECT * FROM (VALUES (1, ARRAY(10, 20)), (2, ARRAY(20, 30))) AS x LEFT JOIN (VALUES (1, 10), (2, 20)) AS x ON x = x LEFT JOIN UNNEST(x) AS x ON x = x;
/* test handling of potential equivalence clauses above outer joins */ EXPLAIN (costs off) select q1, unique2, thousand, hundred   from int8_tbl a left join tenk1 b on q1 = unique2   where coalesce(thousand,123) = q1 and q1 = coalesce(hundred,123);
SELECT x, x, x, x FROM x AS x LEFT JOIN x AS x ON x = x WHERE COALESCE(x, 123) = x AND x = COALESCE(x, 123);
EXPLAIN (costs off) select f1, unique2, case when unique2 is null then f1 else 0 end   from int4_tbl a left join tenk1 b on f1 = unique2   where (case when unique2 is null then f1 else 0 end) = 0;
SELECT x, x, CASE WHEN x IS NULL THEN x ELSE 0 END FROM x AS x LEFT JOIN x AS x ON x = x WHERE (CASE WHEN x IS NULL THEN x ELSE 0 END) = 0;
/* another case with equivalence clauses above outer joins (bug #8591) */ EXPLAIN (costs off) select a.unique1, b.unique1, c.unique1, coalesce(b.twothousand, a.twothousand)   from tenk1 a left join tenk1 b on b.thousand = a.unique1                        left join tenk1 c on c.unique2 = coalesce(b.twothousand, a.twothousand)   where a.unique2 < 10 and coalesce(b.twothousand, a.twothousand) = 44;
SELECT x.x, x.x, x.x, COALESCE(x.x, x.x) FROM x AS x LEFT JOIN x AS x ON x.x = x.x LEFT JOIN x AS x ON x.x = COALESCE(x.x, x.x) WHERE x.x < 10 AND COALESCE(x.x, x.x) = 44;
/* related case */ EXPLAIN (costs off) select * from int8_tbl t1 left join int8_tbl t2 on t1.q2 = t2.q1,   lateral (select * from int8_tbl t3 where t2.q1 = t2.q2) ss;
SELECT * FROM x AS x LEFT JOIN x AS x ON x.x = x.x, LATERAL (SELECT * FROM x AS x WHERE x.x = x.x) AS x;
/* check handling of join aliases when flattening multiple levels of subquery */ EXPLAIN (verbose, costs off) select foo1.join_key as foo1_id, foo3.join_key AS foo3_id, bug_field from   (values (0),(1)) foo1(join_key) left join   (select join_key, bug_field from     (select ss1.join_key, ss1.bug_field from       (select f1 as join_key, 666 as bug_field from int4_tbl i1) ss1     ) foo2    left join     (select unique2 as join_key from tenk1 i2) ss2    using (join_key)   ) foo3 using (join_key);
SELECT x.x AS x, x.x AS x, x FROM (VALUES (0), (1)) AS x LEFT JOIN (SELECT x, x FROM (SELECT x.x, x.x FROM (SELECT x AS x, 666 AS x FROM x AS x) AS x) AS x LEFT JOIN (SELECT x AS x FROM x AS x) AS x USING (x)) AS x USING (x);
/* check handling of a variable-free join alias */ EXPLAIN (verbose, costs off) select * from int4_tbl i0 left join ( (select *, 123 as x from int4_tbl i1) ss1   left join   (select *, q2 as x from int8_tbl i2) ss2   using (x) ) ss0 on (i0.f1 = ss0.f1) order by i0.f1, x;
SELECT * FROM x AS x LEFT JOIN ((SELECT *, 123 AS x FROM x AS x) AS x LEFT JOIN (SELECT *, x AS x FROM x AS x) AS x USING (x)) AS x ON (x.x = x.x) ORDER BY x.x NULLS LAST, x NULLS LAST;
/* test successful handling of nested outer joins with degenerate join quals */ EXPLAIN (verbose, costs off) select t1.* from   text_tbl t1   left join (select *, '***'::text as d1 from int8_tbl i8b1) b1     left join int8_tbl i8       left join (select *, null::int as d2 from int8_tbl i8b2) b2       on (i8.q1 = b2.q1)     on (b2.d2 = b1.q2)   on (t1.f1 = b1.d1)   left join int4_tbl i4   on (i8.q2 = i4.f1);
SELECT x.* FROM x AS x LEFT JOIN (SELECT *, CAST('***' AS TEXT) AS x FROM x AS x) AS x LEFT JOIN x AS x LEFT JOIN (SELECT *, CAST(NULL AS INT) AS x FROM x AS x) AS x ON (x.x = x.x) ON (x.x = x.x) ON (x.x = x.x) LEFT JOIN x AS x ON (x.x = x.x);
EXPLAIN (verbose, costs off) select t1.* from   text_tbl t1   left join (select *, '***'::text as d1 from int8_tbl i8b1) b1     left join int8_tbl i8       left join (select *, null::int as d2 from int8_tbl i8b2, int4_tbl i4b2) b2       on (i8.q1 = b2.q1)     on (b2.d2 = b1.q2)   on (t1.f1 = b1.d1)   left join int4_tbl i4   on (i8.q2 = i4.f1);
SELECT x.* FROM x AS x LEFT JOIN (SELECT *, CAST('***' AS TEXT) AS x FROM x AS x) AS x LEFT JOIN x AS x LEFT JOIN (SELECT *, CAST(NULL AS INT) AS x FROM x AS x, x AS x) AS x ON (x.x = x.x) ON (x.x = x.x) ON (x.x = x.x) LEFT JOIN x AS x ON (x.x = x.x);
EXPLAIN (verbose, costs off) select t1.* from   text_tbl t1   left join (select *, '***'::text as d1 from int8_tbl i8b1) b1     left join int8_tbl i8       left join (select *, null::int as d2 from int8_tbl i8b2, int4_tbl i4b2                  where q1 = f1) b2       on (i8.q1 = b2.q1)     on (b2.d2 = b1.q2)   on (t1.f1 = b1.d1)   left join int4_tbl i4   on (i8.q2 = i4.f1);
SELECT x.* FROM x AS x LEFT JOIN (SELECT *, CAST('***' AS TEXT) AS x FROM x AS x) AS x LEFT JOIN x AS x LEFT JOIN (SELECT *, CAST(NULL AS INT) AS x FROM x AS x, x AS x WHERE x = x) AS x ON (x.x = x.x) ON (x.x = x.x) ON (x.x = x.x) LEFT JOIN x AS x ON (x.x = x.x);
EXPLAIN (verbose, costs off) select * from   text_tbl t1   inner join int8_tbl i8   on i8.q2 = 456   right join text_tbl t2   on t1.f1 = 'doh!'   left join int4_tbl i4   on i8.q1 = i4.f1;
SELECT * FROM x AS x INNER JOIN x AS x ON x.x = 456 RIGHT JOIN x AS x ON x.x = 'doh!' LEFT JOIN x AS x ON x.x = x.x;
/* check handling of a variable-free qual for a non-commutable outer join */ EXPLAIN (costs off) select nspname from (select 1 as x) ss1 left join ( select n.nspname, c.relname   from pg_class c left join pg_namespace n on n.oid = c.relnamespace   where c.relkind = 'r' ) ss2 on false;
/* check handling of apparently-commutable outer joins with non-commutable */ /* joins between them */ EXPLAIN (costs off) select 1 from   int4_tbl i4   left join int8_tbl i8 on i4.f1 is not null   left join (select 1 as a) ss1 on null   join int4_tbl i42 on ss1.a is null or i8.q1 <> i8.q2   right join (select 2 as b) ss2   on ss2.b < i4.f1;
/* test for appropriate join order in the presence of lateral references */ EXPLAIN (verbose, costs off) select * from   text_tbl t1   left join int8_tbl i8   on i8.q2 = 123,   lateral (select i8.q1, t2.f1 from text_tbl t2 limit 1) as ss where t1.f1 = ss.f1;
SELECT * FROM x AS x LEFT JOIN x AS x ON x.x = 123, LATERAL (SELECT x.x, x.x FROM x AS x LIMIT 1) AS x WHERE x.x = x.x;
EXPLAIN (verbose, costs off) select * from   text_tbl t1   left join int8_tbl i8   on i8.q2 = 123,   lateral (select i8.q1, t2.f1 from text_tbl t2 limit 1) as ss1,   lateral (select ss1.* from text_tbl t3 limit 1) as ss2 where t1.f1 = ss2.f1;
SELECT * FROM x AS x LEFT JOIN x AS x ON x.x = 123, LATERAL (SELECT x.x, x.x FROM x AS x LIMIT 1) AS x, LATERAL (SELECT x.* FROM x AS x LIMIT 1) AS x WHERE x.x = x.x;
EXPLAIN (verbose, costs off) select 1 from   text_tbl as tt1   inner join text_tbl as tt2 on (tt1.f1 = 'foo')   left join text_tbl as tt3 on (tt3.f1 = 'foo')   left join text_tbl as tt4 on (tt3.f1 = tt4.f1),   lateral (select tt4.f1 as c0 from text_tbl as tt5 limit 1) as ss1 where tt1.f1 = ss1.c0;
SELECT 1 FROM x AS x INNER JOIN x AS x ON (x.x = 'foo') LEFT JOIN x AS x ON (x.x = 'foo') LEFT JOIN x AS x ON (x.x = x.x), LATERAL (SELECT x.x AS x FROM x AS x LIMIT 1) AS x WHERE x.x = x.x;
EXPLAIN (verbose, costs off) select 1 from   int4_tbl as i4   inner join     ((select 42 as n from int4_tbl x1 left join int8_tbl x2 on f1 = q1) as ss1      right join (select 1 as z) as ss2 on true)   on false,   lateral (select i4.f1, ss1.n from int8_tbl as i8 limit 1) as ss3;
SELECT 1 FROM x AS x INNER JOIN ((SELECT 42 AS x FROM x AS x LEFT JOIN x AS x ON x = x) AS x RIGHT JOIN (SELECT 1 AS x) AS x ON TRUE) ON FALSE, LATERAL (SELECT x.x, x.x FROM x AS x LIMIT 1) AS x;
/* check a case where we formerly generated invalid parameterized paths */ BEGIN;
CREATE TEMPORARY TABLE x (x INT UNIQUE);
EXPLAIN (costs off) select 1 from t t1   join lateral (select t1.a from (select 1) foo offset 0) as s1 on true   join     (select 1 from t t2        inner join (t t3                    left join (t t4 left join t t5 on t4.a = 1)                    on t3.a = t4.a)        on false      where t3.a = coalesce(t5.a,1)) as s2   on true;
ROLLBACK;
/* check a case in which a PlaceHolderVar forces join order */ EXPLAIN (verbose, costs off) select ss2.* from   int4_tbl i41   left join int8_tbl i8     join (select i42.f1 as c1, i43.f1 as c2, 42 as c3           from int4_tbl i42, int4_tbl i43) ss1     on i8.q1 = ss1.c2   on i41.f1 = ss1.c1,   lateral (select i41.*, i8.*, ss1.* from text_tbl limit 1) ss2 where ss1.c2 = 0;
SELECT x.* FROM x AS x LEFT JOIN x AS x JOIN (SELECT x.x AS x, x.x AS x, 42 AS x FROM x AS x, x AS x) AS x ON x.x = x.x ON x.x = x.x, LATERAL (SELECT x.*, x.*, x.* FROM x LIMIT 1) AS x WHERE x.x = 0;
/* test successful handling of full join underneath left join (bug #14105) */ EXPLAIN (costs off) select * from   (select 1 as id) as xx   left join     (tenk1 as a1 full join (select 1 as id) as yy on (a1.unique1 = yy.id))   on (xx.id = coalesce(yy.id));
SELECT * FROM (SELECT 1 AS x) AS x LEFT JOIN (x AS x FULL JOIN (SELECT 1 AS x) AS x ON (x.x = x.x)) ON (x.x = COALESCE(x.x));
/* test ability to push constants through outer join clauses */ EXPLAIN (costs off)   select * from int4_tbl a left join tenk1 b on f1 = unique2 where f1 = 0;
EXPLAIN (costs off)   select * from tenk1 a full join tenk1 b using(unique2) where unique2 = 42;
SET x = off /* we force a mergejoin so that coalesce(b.q1, 1) appears as a join input */;
SET x = off;
EXPLAIN (verbose, costs off)   select a.q2, b.q1     from int8_tbl a left join int8_tbl b on a.q2 = coalesce(b.q1, 1)     where coalesce(b.q1, 1) > 0;
SELECT x.x, x.x FROM x AS x LEFT JOIN x AS x ON x.x = COALESCE(x.x, 1) WHERE COALESCE(x.x, 1) > 0;
RESET enable_hashjoin;
RESET enable_nestloop;
/* test join strength reduction with a SubPlan providing the proof */ EXPLAIN (costs off) select a.unique1, b.unique2   from onek a left join onek b on a.unique1 = b.unique2   where (b.unique2, random() > 0) = any (select q1, random() > 0 from int8_tbl c where c.q1 < b.unique1);
SELECT x.x, x.x FROM x AS x LEFT JOIN x AS x ON x.x = x.x WHERE (x.x, RAND() > 0) = ANY (SELECT x, RAND() > 0 FROM x AS x WHERE x.x < x.x);
/* test full-join strength reduction */ EXPLAIN (costs off) select a.unique1, b.unique2   from onek a full join onek b on a.unique1 = b.unique2   where a.unique1 = 42;
SELECT x.x, x.x FROM x AS x FULL JOIN x AS x ON x.x = x.x WHERE x.x = 42;
EXPLAIN (costs off) select a.unique1, b.unique2   from onek a full join onek b on a.unique1 = b.unique2   where b.unique2 = 43;
SELECT x.x, x.x FROM x AS x FULL JOIN x AS x ON x.x = x.x WHERE x.x = 43;
EXPLAIN (costs off) select a.unique1, b.unique2   from onek a full join onek b on a.unique1 = b.unique2   where a.unique1 = 42 and b.unique2 = 42;
SELECT x.x, x.x FROM x AS x FULL JOIN x AS x ON x.x = x.x WHERE x.x = 42 AND x.x = 42;
/* test result-RTE removal underneath a full join */ EXPLAIN (costs off) select * from   (select * from int8_tbl i81 join (values(123,2)) v(v1,v2) on q2=v1) ss1 full join   (select * from (values(456,2)) w(v1,v2) join int8_tbl i82 on q2=v1) ss2 on true;
SELECT * FROM (SELECT * FROM x AS x JOIN (VALUES (123, 2)) AS x ON x = x) AS x FULL JOIN (SELECT * FROM (VALUES (456, 2)) AS x JOIN x AS x ON x = x) AS x ON TRUE;
/* test join removal */ BEGIN;
CREATE TEMPORARY TABLE x (x INT PRIMARY KEY, x INT);
CREATE TEMPORARY TABLE x (x INT PRIMARY KEY, x INT);
CREATE TEMPORARY TABLE x (x INT PRIMARY KEY);
CREATE TEMPORARY TABLE x (x INT, x INT);
CREATE TEMPORARY TABLE x (x INT, x INT, PRIMARY KEY (x NULLS LAST, x NULLS LAST));
INSERT INTO x VALUES (0, 0), (1, NULL);
INSERT INTO x VALUES (0, 0), (1, NULL);
INSERT INTO x VALUES (0), (1);
INSERT INTO x VALUES (1, 3), (2, 2), (3, 1);
INSERT INTO x VALUES (0, 0), (2, 2), (3, 1);
/* all these cases should be optimizable into a simple seqscan */ EXPLAIN (costs off) SELECT a.* FROM a LEFT JOIN b ON a.b_id = b.id;
EXPLAIN (costs off) SELECT b.* FROM b LEFT JOIN c ON b.c_id = c.id;
EXPLAIN (costs off)   SELECT a.* FROM a LEFT JOIN (b left join c on b.c_id = c.id)   ON (a.b_id = b.id);
EXPLAIN (costs off)   SELECT a.* FROM a LEFT JOIN b ON a.id = b.id   LEFT JOIN e ON e.id1 = a.b_id AND b.c_id = e.id2;
/* check optimization of outer join within another special join */ EXPLAIN (costs off) select id from a where id in ( 	select b.id from b left join c on b.id = c.id );
/* check optimization with oddly-nested outer joins */ EXPLAIN (costs off) select a1.id from   (a a1 left join a a2 on true)   left join   (a a3 left join a a4 on a3.id = a4.id)   on a2.id = a3.id;
EXPLAIN (costs off) select a1.id from   (a a1 left join a a2 on a1.id = a2.id)   left join   (a a3 left join a a4 on a3.id = a4.id)   on a2.id = a3.id;
EXPLAIN (costs off) select 1 from a t1     left join a t2 on true    inner join a t3 on true     left join a t4 on t2.id = t4.id and t2.id = t3.id;
/* another example (bug #17781) */ EXPLAIN (costs off) select ss1.f1 from int4_tbl as t1   left join (int4_tbl as t2              right join int4_tbl as t3 on null              left join (int4_tbl as t4                         right join int8_tbl as t5 on null)                on t2.f1 = t4.f1              left join ((select null as f1 from int4_tbl as t6) as ss1                         inner join int8_tbl as t7 on null)                on t5.q1 = t7.q2)     on false;
/* variant with Var rather than PHV coming from t6 */ EXPLAIN (costs off) select ss1.f1 from int4_tbl as t1   left join (int4_tbl as t2              right join int4_tbl as t3 on null              left join (int4_tbl as t4                         right join int8_tbl as t5 on null)                on t2.f1 = t4.f1              left join ((select f1 from int4_tbl as t6) as ss1                         inner join int8_tbl as t7 on null)                on t5.q1 = t7.q2)     on false;
/* per further discussion of bug #17781 */ EXPLAIN (costs off) select ss1.x from (select f1/2 as x from int4_tbl i4 left join a on a.id = i4.f1) ss1      right join int8_tbl i8 on true where current_user is not null;
/* this is to add a Result node */ /* and further discussion of bug #17781 */ EXPLAIN (costs off) select * from int8_tbl t1   left join (int8_tbl t2 left join onek t3 on t2.q1 > t3.unique1)     on t1.q2 = t2.q2   left join onek t4     on t2.q2 < t3.unique2;
/* More tests of correct placement of pseudoconstant quals */ /* simple constant-false condition */ EXPLAIN (costs off) select * from int8_tbl t1 left join   (int8_tbl t2 inner join int8_tbl t3 on false    left join int8_tbl t4 on t2.q2 = t4.q2) on t1.q1 = t2.q1;
/* deduce constant-false from an EquivalenceClass */ EXPLAIN (costs off) select * from int8_tbl t1 left join   (int8_tbl t2 inner join int8_tbl t3 on (t2.q1-t3.q2) = 0 and (t2.q1-t3.q2) = 1    left join int8_tbl t4 on t2.q2 = t4.q2) on t1.q1 = t2.q1;
/* pseudoconstant based on an outer-level Param */ EXPLAIN (costs off) select exists(   select * from int8_tbl t1 left join     (int8_tbl t2 inner join int8_tbl t3 on x0.f1 = 1      left join int8_tbl t4 on t2.q2 = t4.q2)   on t1.q1 = t2.q1 ) from int4_tbl x0;
/* check that join removal works for a left join when joining a subquery */ /* that is guaranteed to be unique by its GROUP BY clause */ EXPLAIN (costs off) select d.* from d left join (select * from b group by b.id, b.c_id) s   on d.a = s.id and d.b = s.c_id;
/* similarly, but keying off a DISTINCT clause */ EXPLAIN (costs off) select d.* from d left join (select distinct * from b) s   on d.a = s.id and d.b = s.c_id;
/* but this happens too late for join removal in the outer plan level.) */ EXPLAIN (costs off) select d.* from d left join (select * from b group by b.id, b.c_id) s   on d.a = s.id;
/* similarly, but keying off a DISTINCT clause */ EXPLAIN (costs off) select d.* from d left join (select distinct * from b) s   on d.a = s.id;
/* join removal is not possible here */ EXPLAIN (costs off) select 1 from a t1   left join (a t2 left join a t3 on t2.id = 1) on t2.id = 1;
/* check join removal works when uniqueness of the join condition is enforced */ /* by a UNION */ EXPLAIN (costs off) select d.* from d left join (select id from a union select id from b) s   on d.a = s.id;
/* check join removal with a cross-type comparison operator */ EXPLAIN (costs off) select i8.* from int8_tbl i8 left join (select f1 from int4_tbl group by f1) i4   on i8.q1 = i4.f1;
/* check join removal with lateral references */ EXPLAIN (costs off) select 1 from (select a.id FROM a left join b on a.b_id = b.id) q, 			  lateral generate_series(1, q.id) gs(i) where q.id = gs.i;
/* check join removal within RHS of an outer join */ EXPLAIN (costs off) select c.id, ss.a from c   left join (select d.a from onerow, d left join b on d.a = b.id) ss   on c.id = ss.a;
/* check the case when the placeholder relates to an outer join and its */ /* inner in the press field but actually uses only the outer side of the join */ EXPLAIN (costs off) SELECT q.val FROM b LEFT JOIN (   SELECT (q1.z IS NOT NULL) AS val   FROM b LEFT JOIN (     SELECT (t1.b_id IS NOT NULL) AS z FROM a t1 LEFT JOIN a t2 USING (id)     ) AS q1   ON true ) AS q ON true;
CREATE TEMPORARY TABLE x (x INT PRIMARY KEY) WITH (PARTITIONED_BY=RANGE(x));
CREATE TEMPORARY TABLE x PARTITION OF x FOR VALUES FROM (0) TO (10);
/* test join removals on a partitioned table */ EXPLAIN (costs off) select a.* from a left join parted_b pb on a.b_id = pb.id;
ROLLBACK;
CREATE TEMPORARY TABLE x (x INT PRIMARY KEY, x INT);
CREATE TEMPORARY TABLE x (x INT UNIQUE, x INT);
INSERT INTO x VALUES (1, 10), (2, 20), (3, 30);
INSERT INTO x VALUES (1, 100), (4, 400);
/* this case is optimizable */ SELECT x.* FROM x AS x LEFT JOIN x AS x ON (x.x = x.x);
EXPLAIN (costs off)   select p.* from parent p left join child c on (p.k = c.k);
/* this case is not */ SELECT x.*, x FROM x AS x LEFT JOIN (SELECT x.*, TRUE AS x FROM x AS x) AS x ON (x.x = x.x);
EXPLAIN (costs off)   select p.*, linked from parent p     left join (select c.*, true as linked from child c) as ss     on (p.k = ss.k);
/* check for a 9.0rc1 bug: join removal breaks pseudoconstant qual handling */ SELECT x.* FROM x AS x LEFT JOIN x AS x ON (x.x = x.x) WHERE x.x = 1 AND x.x = 2;
EXPLAIN (costs off) select p.* from   parent p left join child c on (p.k = c.k)   where p.k = 1 and p.k = 2;
SELECT x.* FROM (x AS x LEFT JOIN x AS x ON (x.x = x.x)) JOIN x AS x ON x.x = x.x WHERE x.x = 1 AND x.x = 2;
EXPLAIN (costs off) select p.* from   (parent p left join child c on (p.k = c.k)) join parent x on p.k = x.k   where p.k = 1 and p.k = 2;
/* bug 5255: this is not optimizable by join removal */ BEGIN;
CREATE TEMPORARY TABLE x (x INT PRIMARY KEY);
CREATE TEMPORARY TABLE x (x INT PRIMARY KEY, x INT);
INSERT INTO x VALUES (0), (1);
INSERT INTO x VALUES (0, 0), (1, NULL);
SELECT * FROM x LEFT JOIN x ON (x.x = x.x) WHERE (x.x IS NULL OR x.x > 0);
SELECT x.* FROM x LEFT JOIN x ON (x.x = x.x) WHERE (x.x IS NULL OR x.x > 0);
ROLLBACK;
/* another join removal bug: this is not optimizable, either */ BEGIN;
CREATE TEMPORARY TABLE x (x BIGINT PRIMARY KEY, x BIGINT);
INSERT INTO x VALUES (123, 42);
SELECT * FROM (SELECT 1 AS x) AS x LEFT JOIN (SELECT x, x, COALESCE(x, x) AS x FROM x LEFT JOIN x ON x = x) AS x ON TRUE;
/* join removal bug #17769: can't remove if there's a pushed-down reference */ EXPLAIN (COSTS OFF) SELECT q2 FROM   (SELECT *    FROM int8_tbl LEFT JOIN innertab ON q2 = id) ss  WHERE COALESCE(dat1, 0) = q1;
/* join removal bug #17773: otherwise-removable PHV appears in a qual condition */ EXPLAIN (VERBOSE, COSTS OFF) SELECT q2 FROM   (SELECT q2, 'constant'::text AS x    FROM int8_tbl LEFT JOIN innertab ON q2 = id) ss   RIGHT JOIN int4_tbl ON NULL  WHERE x >= x;
/* join removal bug #17786: check that OR conditions are cleaned up */ EXPLAIN (COSTS OFF) SELECT f1, x FROM int4_tbl      JOIN ((SELECT 42 AS x FROM int8_tbl LEFT JOIN innertab ON q1 = id) AS ss1            RIGHT JOIN tenk1 ON NULL)         ON tenk1.unique1 = ss1.x OR tenk1.unique2 = ss1.x;
ROLLBACK;
/* another join removal bug: we must clean up correctly when removing a PHV */ BEGIN;
CREATE TEMPORARY TABLE x (x TEXT UNIQUE);
EXPLAIN (costs off) select t1.* from   uniquetbl as t1   left join (select *, '***'::text as d1 from uniquetbl) t2   on t1.f1 = t2.f1   left join uniquetbl t3   on t2.d1 = t3.f1;
EXPLAIN (costs off) select t0.* from  text_tbl t0  left join    (select case t1.ten when 0 then 'doh!'::text else null::text end as case1,            t1.stringu2      from tenk1 t1      join int4_tbl i4 ON i4.f1 = t1.unique2      left join uniquetbl u1 ON u1.f1 = t1.string4) ss   on t0.f1 = ss.case1 where ss.stringu2 !~* ss.case1;
SELECT x.* FROM x AS x LEFT JOIN (SELECT CASE x.x WHEN 0 THEN CAST('doh!' AS TEXT) ELSE CAST(NULL AS TEXT) END AS x, x.x FROM x AS x JOIN x AS x ON x.x = x.x LEFT JOIN x AS x ON x.x = x.x) AS x ON x.x = x.x WHERE NOT REGEXP_I_LIKE(x.x, x.x);
ROLLBACK;
/* another join removal bug: we must clean up EquivalenceClasses too */ BEGIN;
CREATE TEMPORARY TABLE x (x INT UNIQUE);
INSERT INTO x VALUES (1);
EXPLAIN (costs off) select 1 from t t1   left join (select 2 as c              from t t2 left join t t3 on t2.a = t3.a) s     on true where t1.a = s.c;
SELECT 1 FROM x AS x LEFT JOIN (SELECT 2 AS x FROM x AS x LEFT JOIN x AS x ON x.x = x.x) AS x ON TRUE WHERE x.x = x.x;
ROLLBACK;
/* test cases where we can remove a join, but not a PHV computed at it */ BEGIN;
CREATE TEMPORARY TABLE x (x INT UNIQUE, x INT);
INSERT INTO x VALUES (1, 1), (2, 2);
EXPLAIN (costs off) select 1 from t t1   left join (select t2.a, 1 as c              from t t2 left join t t3 on t2.a = t3.a) s   on true   left join t t4 on true where s.a < s.c;
EXPLAIN (costs off) select t1.a, s.* from t t1   left join lateral (select t2.a, coalesce(t1.a, 1) as c                      from t t2 left join t t3 on t2.a = t3.a) s   on true   left join t t4 on true where s.a < s.c;
SELECT x.x, x.* FROM x AS x LEFT JOIN LATERAL (SELECT x.x, COALESCE(x.x, 1) AS x FROM x AS x LEFT JOIN x AS x ON x.x = x.x) AS x ON TRUE LEFT JOIN x AS x ON TRUE WHERE x.x < x.x;
ROLLBACK;
/* test case to expose miscomputation of required relid set for a PHV */ EXPLAIN (verbose, costs off) select i8.*, ss.v, t.unique2   from int8_tbl i8     left join int4_tbl i4 on i4.f1 = 1     left join lateral (select i4.f1 + 1 as v) as ss on true     left join tenk1 t on t.unique2 = ss.v where q2 = 456;
SELECT x.*, x.x, x.x FROM x AS x LEFT JOIN x AS x ON x.x = 1 LEFT JOIN LATERAL (SELECT x.x + 1 AS x) AS x ON TRUE LEFT JOIN x AS x ON x.x = x.x WHERE x = 456;
/* and check a related issue where we miscompute required relids for */ /* a PHV that's been translated to a child rel */ CREATE TEMPORARY TABLE x (x INT PRIMARY KEY) WITH (PARTITIONED_BY=RANGE(x));
CREATE TEMPORARY TABLE x PARTITION OF x FOR VALUES FROM (1) TO (100);
INSERT INTO x VALUES (11), (12);
EXPLAIN (costs off) select * from   (select *, 12 as phv from parttbl) as ss   right join int4_tbl on true where ss.a = ss.phv and f1 = 0;
SELECT * FROM (SELECT *, 12 AS x FROM x) AS x RIGHT JOIN x ON TRUE WHERE x.x = x.x AND x = 0;
/* bug #8444: we've historically allowed duplicate aliases within aliased JOINs */ SELECT * FROM x AS x JOIN (x AS x CROSS JOIN x AS x) AS x ON x = x;
/* error */ SELECT * FROM x AS x JOIN (x AS x CROSS JOIN x AS x) AS x ON x = x.x;
/* error */ SELECT * FROM x AS x JOIN (x AS x CROSS JOIN x AS x) AS x ON x = x;
SET x = off /* ok */ /* test that semi- or inner self-joins on a unique column are removed */ /* enable only nestloop to get more predictable plans */;
SET x = off;
CREATE TABLE x (x INT UNIQUE, x INT, x INT UNIQUE);
INSERT INTO x VALUES (1, NULL, 2), (NULL, 2, NULL), (2, 1, 1);
ANALYZE x;
/* Trivial self-join case. */ EXPLAIN (costs off) select p.* from sj p, sj q where q.a = p.a and q.b = q.a - 1;
SELECT x.* FROM x AS x, x AS x WHERE x.x = x.x AND x.x = x.x - 1;
/* Self-join removal performs after a subquery pull-up process and could remove */ /* such kind of self-join too. Check this option. */ EXPLAIN (costs off) select * from sj p where exists (select * from sj q               where q.a = p.a and q.b < 10);
SELECT * FROM x AS x WHERE EXISTS(SELECT * FROM x AS x WHERE x.x = x.x AND x.x < 10);
/* Don't remove self-join for the case of equality of two different unique columns. */ EXPLAIN (costs off) select * from sj t1, sj t2 where t1.a = t2.c and t1.b is not null;
/* Ensure that relations with TABLESAMPLE clauses are not considered as */ /* candidates to be removed */ EXPLAIN (costs off) select * from sj t1     join lateral       (select * from sj tablesample system(t1.b)) s     on t1.a = s.a;
/* Ensure that SJE does not form a self-referential lateral dependency */ EXPLAIN (costs off) select * from sj t1     left join lateral       (select t1.a as t1a, * from sj t2) s     on true where t1.a = s.a;
/* Degenerated case. */ EXPLAIN (costs off) select * from   (select a as x from sj where false) as q1,   (select a as y from sj where false) as q2 where q1.x = q2.y;
/* We can't use a cross-EC generated self join qual because of current logic of */ /* the generate_join_implied_equalities routine. */ EXPLAIN (costs off) select * from sj t1, sj t2 where t1.a = t1.b and t1.b = t2.b and t2.b = t2.a;
EXPLAIN (costs off) select * from sj t1, sj t2, sj t3 where t1.a = t1.b and t1.b = t2.b and t2.b = t2.a and       t1.b = t3.b and t3.b = t3.a;
/* Double self-join removal. */ /* Use a condition on "b + 1", not on "b", for the second join, so that */ /* the equivalence class is different from the first one, and we can */ /* test the non-ec code path. */ EXPLAIN (costs off) select * from  sj t1       join sj t2 on t1.a = t2.a and t1.b = t2.b 	  join sj t3 on t2.a = t3.a and t2.b + 1 = t3.b + 1;
/* subselect that references the removed relation */ EXPLAIN (costs off) select t1.a, (select a from sj where a = t2.a and a = t1.a) from sj t1, sj t2 where t1.a = t2.a;
/* self-join under outer join */ EXPLAIN (costs off) select * from sj x join sj y on x.a = y.a left join int8_tbl z on x.a = z.q1;
EXPLAIN (costs off) select * from sj x join sj y on x.a = y.a left join int8_tbl z on y.a = z.q1;
EXPLAIN (costs off) select * from (   select t1.*, t2.a as ax from sj t1 join sj t2   on (t1.a = t2.a and t1.c * t1.c = t2.c + 2 and t2.b is null) ) as q1 left join   (select t3.* from sj t3, sj t4 where t3.c = t4.c) as q2 on q1.ax = q2.a;
/* Test that placeholders are updated correctly after join removal */ EXPLAIN (costs off) select * from (values (1)) x left join (select coalesce(y.q1, 1) from int8_tbl y 	right join sj j1 inner join sj j2 on j1.a = j2.a 	on true) z on true;
/* Test that references to the removed rel in lateral subqueries are replaced */ /* correctly after join removal */ EXPLAIN (verbose, costs off) select t3.a from sj t1 	join sj t2 on t1.a = t2.a 	join lateral (select t1.a offset 0) t3 on true;
EXPLAIN (verbose, costs off) select t3.a from sj t1 	join sj t2 on t1.a = t2.a 	join lateral (select * from (select t1.a offset 0) offset 0) t3 on true;
EXPLAIN (verbose, costs off) select t4.a from sj t1 	join sj t2 on t1.a = t2.a 	join lateral (select t3.a from sj t3, (select t1.a) offset 0) t4 on true;
/* Check updating of semi_rhs_exprs links from upper-level semi join to */ /* the removing relation */ EXPLAIN (verbose, costs off) select t1.a from sj t1 where t1.b in (   select t2.b from sj t2 join sj t3 on t2.c=t3.c);
/* SJE corner case: uniqueness of an inner is [partially] derived from */ /* baserestrictinfo clauses. */ /* XXX: We really should allow SJE for these corner cases? */ INSERT INTO x VALUES (3, 1, 3);
/* Don't remove SJ */ EXPLAIN (COSTS OFF) SELECT * FROM sj j1, sj j2 WHERE j1.b = j2.b AND j1.a = 2 AND j2.a = 3;
/* Return one row */ SELECT * FROM x AS x, x AS x WHERE x.x = x.x AND x.x = 2 AND x.x = 3;
/* Remove SJ, define uniqueness by a constant */ EXPLAIN (COSTS OFF) SELECT * FROM sj j1, sj j2 WHERE j1.b = j2.b AND j1.a = 2 AND j2.a = 2;
/* Return one row */ SELECT * FROM x AS x, x AS x WHERE x.x = x.x AND x.x = 2 AND x.x = 2;
/* Remove SJ, define uniqueness by a constant expression */ EXPLAIN (COSTS OFF) SELECT * FROM sj j1, sj j2 WHERE j1.b = j2.b   AND j1.a = (EXTRACT(DOW FROM current_timestamp(0))/15 + 3)::int   AND (EXTRACT(DOW FROM current_timestamp(0))/15 + 3)::int = j2.a;
/* Return one row */ SELECT * FROM x AS x, x AS x WHERE x.x = x.x AND x.x = CAST((EXTRACT(DOW FROM CURRENT_TIMESTAMP(0)) / 15 + 3) AS INT) AND CAST((EXTRACT(DOW FROM CURRENT_TIMESTAMP(0)) / 15 + 3) AS INT) = x.x;
/* Remove SJ */ EXPLAIN (COSTS OFF) SELECT * FROM sj j1, sj j2 WHERE j1.b = j2.b AND j1.a = 1 AND j2.a = 1;
/* Return no rows */ SELECT * FROM x AS x, x AS x WHERE x.x = x.x AND x.x = 1 AND x.x = 1;
/* Shuffle a clause. Remove SJ */ EXPLAIN (COSTS OFF) SELECT * FROM sj j1, sj j2 WHERE j1.b = j2.b AND 1 = j1.a AND j2.a = 1;
/* Return no rows */ SELECT * FROM x AS x, x AS x WHERE x.x = x.x AND 1 = x.x AND x.x = 1;
/* SJE Corner case: a 'a.x=a.x' clause, have replaced with 'a.x IS NOT NULL' */ /* after SJ elimination it shouldn't be a mergejoinable clause. */ EXPLAIN (COSTS OFF) SELECT t4.* FROM (SELECT t1.*, t2.a AS a1 FROM sj t1, sj t2 WHERE t1.b = t2.b) AS t3 JOIN sj t4 ON (t4.a = t3.a) WHERE t3.a1 = 42;
SELECT x.* FROM (SELECT x.*, x.x AS x FROM x AS x, x AS x WHERE x.x = x.x) AS x JOIN x AS x ON (x.x = x.x) WHERE x.x = 42;
/* Functional index */ CREATE UNIQUE INDEX x ON x((x * x) NULLS LAST);
/* Remove SJ */ EXPLAIN (COSTS OFF) SELECT * FROM sj j1, sj j2 	WHERE j1.b = j2.b AND j1.a*j1.a = 1 AND j2.a*j2.a = 1;
/* Don't remove SJ */ EXPLAIN (COSTS OFF) SELECT * FROM sj j1, sj j2 	WHERE j1.b = j2.b AND j1.a*j1.a = 1 AND j2.a*j2.a = 2;
/* Restriction contains expressions in both sides, Remove SJ. */ EXPLAIN (COSTS OFF) SELECT * FROM sj j1, sj j2 WHERE j1.b = j2.b   AND (j1.a*j1.a) = (EXTRACT(DOW FROM current_timestamp(0))/15 + 3)::int   AND (EXTRACT(DOW FROM current_timestamp(0))/15 + 3)::int = (j2.a*j2.a);
/* Empty set of rows should be returned */ SELECT * FROM x AS x, x AS x WHERE x.x = x.x AND (x.x * x.x) = CAST((EXTRACT(DOW FROM CURRENT_TIMESTAMP(0)) / 15 + 3) AS INT) AND CAST((EXTRACT(DOW FROM CURRENT_TIMESTAMP(0)) / 15 + 3) AS INT) = (x.x * x.x);
/* Restriction contains volatile function - disable SJE feature. */ EXPLAIN (COSTS OFF) SELECT * FROM sj j1, sj j2 WHERE j1.b = j2.b   AND (j1.a*j1.c/3) = (random()/3 + 3)::int   AND (random()/3 + 3)::int = (j2.a*j2.c/3);
/* Return one row */ SELECT * FROM x AS x, x AS x WHERE x.x = x.x AND (x.x * x.x / 3) = CAST((RAND() / 3 + 3) AS INT) AND CAST((RAND() / 3 + 3) AS INT) = (x.x * x.x / 3);
/* Multiple filters */ CREATE UNIQUE INDEX x ON x(x NULLS LAST, x NULLS LAST, x NULLS LAST);
/* Remove SJ */ EXPLAIN (COSTS OFF) SELECT * FROM sj j1, sj j2 	WHERE j1.b = j2.b AND j1.a = 2 AND j1.c = 3 AND j2.a = 2 AND 3 = j2.c;
/* Don't remove SJ */ EXPLAIN (COSTS OFF) 	SELECT * FROM sj j1, sj j2 	WHERE j1.b = j2.b AND 2 = j1.a AND j1.c = 3 AND j2.a = 1 AND 3 = j2.c;
CREATE UNIQUE INDEX x ON x(x NULLS LAST, x NULLS LAST);
/* Don't remove SJ */ EXPLAIN (COSTS OFF) SELECT * FROM sj j1, sj j2 WHERE j1.b = j2.b AND j1.a = 2;
/* Don't remove SJ */ EXPLAIN (COSTS OFF) SELECT * FROM sj j1, sj j2 WHERE j1.b = j2.b AND 2 = j2.a;
/* Don't remove SJ */ EXPLAIN (COSTS OFF) SELECT * FROM sj j1, sj j2 WHERE j1.b = j2.b AND (j1.a = 1 OR j2.a = 1);
/* Test that OR predicated are updated correctly after join removal */ CREATE TABLE x (x INT PRIMARY KEY, x SMALLINT);
CREATE INDEX x ON x(x NULLS LAST);
EXPLAIN (COSTS OFF) SELECT COUNT(*) FROM tab_with_flag WHERE 	(is_flag IS NULL OR is_flag = 0) 	AND id IN (SELECT id FROM tab_with_flag WHERE id IN (2, 3));
DROP TABLE x;
/* HAVING clause */ EXPLAIN (costs off) select p.b from sj p join sj q on p.a = q.a group by p.b having sum(p.a) = 1;
/* update lateral references and range table entry reference */ EXPLAIN (verbose, costs off) select 1 from (select x.* from sj x, sj y where x.a = y.a) q,   lateral generate_series(1, q.a) gs(i);
EXPLAIN (verbose, costs off) select 1 from (select y.* from sj x, sj y where x.a = y.a) q,   lateral generate_series(1, q.a) gs(i);
/* Test that a non-EC-derived join clause is processed correctly. Use an */ /* outer join so that we can't form an EC. */ EXPLAIN (costs off) select * from sj p join sj q on p.a = q.a   left join sj r on p.a + q.a = r.a;
/* FIXME this constant false filter doesn't look good. Should we merge */ /* equivalence classes? */ EXPLAIN (costs off) select * from sj p, sj q where p.a = q.a and p.b = 1 and q.b = 2;
/* Check that attr_needed is updated correctly after self-join removal. In this */ /* test, the join of j1 with j2 is removed. k1.b is required at either j1 or j2. */ /* If this info is lost, join targetlist for (k1, k2) will not contain k1.b. */ /* Use index scan for k1 so that we don't get 'b' from physical tlist used for */ /* seqscan. Also disable reordering of joins because this test depends on a */ /* particular join tree. */ CREATE TABLE x (x INT, x INT);
CREATE INDEX ON x(x NULLS LAST);
SET x = 1;
SET x = off;
EXPLAIN (costs off) select 1 from 	(sk k1 join sk k2 on k1.a = k2.a) 	join (sj j1 join sj j2 on j1.a = j2.a) on j1.b = k1.b;
EXPLAIN (costs off) select 1 from 	(sk k1 join sk k2 on k1.a = k2.a) 	join (sj j1 join sj j2 on j1.a = j2.a) on j2.b = k1.b;
RESET join_collapse_limit;
RESET enable_seqscan;
/* Check that clauses from the join filter list is not lost on the self-join removal */ CREATE TABLE x (x SERIAL PRIMARY KEY NOT NULL, x INT);
EXPLAIN (VERBOSE, COSTS OFF) SELECT * FROM emp1 e1, emp1 e2 WHERE e1.id = e2.id AND e2.code <> e1.code;
/* Shuffle self-joined relations. Only in the case of iterative deletion */ /* attempts explains of these queries will be identical. */ CREATE UNIQUE INDEX ON x((x * x) NULLS LAST);
EXPLAIN (COSTS OFF) SELECT count(*) FROM emp1 c1, emp1 c2, emp1 c3 WHERE c1.id=c2.id AND c1.id*c2.id=c3.id*c3.id;
EXPLAIN (COSTS OFF) SELECT count(*) FROM emp1 c1, emp1 c2, emp1 c3 WHERE c1.id=c3.id AND c1.id*c3.id=c2.id*c2.id;
EXPLAIN (COSTS OFF) SELECT count(*) FROM emp1 c1, emp1 c2, emp1 c3 WHERE c3.id=c2.id AND c3.id*c2.id=c1.id*c1.id;
/* Check the usage of a parse tree by the set operations (bug #18170) */ EXPLAIN (COSTS OFF) SELECT c1.code FROM emp1 c1 LEFT JOIN emp1 c2 ON c1.id = c2.id WHERE c2.id IS NOT NULL EXCEPT ALL SELECT c3.code FROM emp1 c3;
/* Check that SJE removes references from PHVs correctly */ EXPLAIN (costs off) select * from emp1 t1 left join     (select coalesce(t3.code, 1) from emp1 t2         left join (emp1 t3 join emp1 t4 on t3.id = t4.id)         on true) on true;
/* Check that SJE removes the whole PHVs correctly */ EXPLAIN (verbose, costs off) select 1 from emp1 t1 left join     ((select 1 as x, * from emp1 t2) s1 inner join         (select * from emp1 t3) s2 on s1.id = s2.id)     on true where s1.x = 1;
/* Check that PHVs do not impose any constraints on removing self joins */ EXPLAIN (verbose, costs off) select * from emp1 t1 join emp1 t2 on t1.id = t2.id left join     lateral (select t1.id as t1id, * from generate_series(1,1) t3) s on true;
EXPLAIN (verbose, costs off) select * from generate_series(1,10) t1(id) left join     lateral (select t1.id as t1id, t2.id from emp1 t2 join emp1 t3 on t2.id = t3.id) on true;
/* Check that SJE replaces join clauses involving the removed rel correctly */ EXPLAIN (costs off) select * from emp1 t1    inner join emp1 t2 on t1.id = t2.id     left join emp1 t3 on t1.id > 1 and t1.id < 2;
/* Check that SJE doesn't replace the target relation */ EXPLAIN (COSTS OFF) WITH t1 AS (SELECT * FROM emp1) UPDATE emp1 SET code = t1.code + 1 FROM t1 WHERE t1.id = emp1.id RETURNING emp1.id, emp1.code, t1.code;
INSERT INTO x VALUES (1, 1), (2, 1);
WITH x AS (SELECT * FROM x) UPDATE x SET x = x.x + 1 FROM x WHERE x.x = x.x RETURNING x.x, x.x, x.x;
TRUNCATE TABLE x;
EXPLAIN (COSTS OFF) UPDATE sj sq SET b = 1 FROM sj as sz WHERE sq.a = sz.a;
CREATE RULE sj_del_rule AS ON DELETE TO sj   DO INSTEAD     UPDATE sj SET a = 1 WHERE a = old.a;
EXPLAIN (COSTS OFF) DELETE FROM sj;
DROP RULE sj_del_rule ON sj CASCADE;
/* Check that SJE does not mistakenly omit qual clauses (bug #18187) */ INSERT INTO x VALUES (1, 1);
EXPLAIN (costs off) select 1 from emp1 full join     (select * from emp1 t1 join         emp1 t2 join emp1 t3 on t2.id = t3.id         on true     where false) s on true where false;
SELECT 1 FROM x FULL JOIN (SELECT * FROM x AS x JOIN x AS x JOIN x AS x ON x.x = x.x ON TRUE WHERE FALSE) AS x ON TRUE WHERE FALSE;
/* Check that SJE does not mistakenly re-use knowledge of relation uniqueness */ /* made with different set of quals */ INSERT INTO x VALUES (2, 1);
EXPLAIN (costs off) select * from emp1 t1 where exists (select * from emp1 t2                                     where t2.id = t1.code and t2.code > 0);
SELECT * FROM x AS x WHERE EXISTS(SELECT * FROM x AS x WHERE x.x = x.x AND x.x > 0);
/* We can remove the join even if we find the join can't duplicate rows and */ /* the base quals of each side are different.  In the following case we end up */ /* moving quals over to s1 to make it so it can't match any rows. */ CREATE TABLE x (x INT, x INT, x INT);
CREATE UNIQUE INDEX ON x(x NULLS LAST, x NULLS LAST);
VACUUM analyze sl;
/* Both sides are unique, but base quals are different */ EXPLAIN (costs off) select * from sl t1, sl t2 where t1.a = t2.a and t1.b = 1 and t2.b = 2;
/* Check NullTest in baserestrictinfo list */ EXPLAIN (costs off) select * from sl t1, sl t2 where t1.a = t2.a and t1.b = 1 and t2.b = 2   and t1.c IS NOT NULL and t2.c IS NOT NULL   and t2.b IS NOT NULL and t1.b IS NOT NULL   and t1.a IS NOT NULL and t2.a IS NOT NULL;
EXPLAIN (verbose, costs off) select * from sl t1, sl t2 where t1.b = t2.b and t2.a = 3 and t1.a = 3   and t1.c IS NOT NULL and t2.c IS NOT NULL   and t2.b IS NOT NULL and t1.b IS NOT NULL   and t1.a IS NOT NULL and t2.a IS NOT NULL;
/* Join qual isn't mergejoinable, but inner is unique. */ EXPLAIN (COSTS OFF) SELECT n2.a FROM sj n1, sj n2 WHERE n1.a <> n2.a AND n2.a = 1;
EXPLAIN (COSTS OFF) SELECT * FROM (SELECT n2.a FROM sj n1, sj n2 WHERE n1.a <> n2.a) q0, sl WHERE q0.a = 1;
/* Check optimization disabling if it will violate special join conditions. */ /* Two identical joined relations satisfies self join removal conditions but */ /* stay in different special join infos. */ CREATE TABLE x (x SERIAL, x INT);
CREATE TABLE x (x SERIAL, x INT);
CREATE TABLE x (x SERIAL, x INT);
CREATE TABLE x (x SERIAL, x INT);
CREATE UNIQUE INDEX ON x USING btree(x NULLS LAST, x NULLS LAST);
CREATE UNIQUE INDEX ON x USING btree(x NULLS LAST);
EXPLAIN (COSTS OFF) SELECT * FROM sj_t1 JOIN ( 	SELECT sj_t2.id AS id FROM sj_t2 	WHERE EXISTS 		( 		SELECT TRUE FROM sj_t3,sj_t4 WHERE sj_t3.a = 1 AND sj_t3.id = sj_t2.id 		) 	) t2t3t4 ON sj_t1.id = t2t3t4.id JOIN ( 	SELECT sj_t2.id AS id FROM sj_t2 	WHERE EXISTS 		( 		SELECT TRUE FROM sj_t3,sj_t4 WHERE sj_t3.a = 1 AND sj_t3.id = sj_t2.id 		) 	) _t2t3t4 ON sj_t1.id = _t2t3t4.id;
/* Test RowMarks-related code */ /* Both sides have explicit LockRows marks */ EXPLAIN (COSTS OFF) SELECT a1.a FROM sj a1,sj a2 WHERE (a1.a=a2.a) FOR UPDATE;
RESET enable_hashjoin;
RESET enable_mergejoin;
/* Test hints given on incorrect column references are useful */ SELECT x.x FROM x AS x JOIN x AS x ON x.x = x.x;
/* error, prefer "t1" suggestion */ SELECT x.x FROM x AS x JOIN x AS x ON x.x = x.x;
/* error, prefer "t2" suggestion */ SELECT x FROM x AS x JOIN x AS x ON x.x = x.x;
/* error, suggest both at once */ SELECT x FROM x AS x JOIN x AS x ON x.x = x.x;
/* error, need qualification */ /* Take care to reference the correct RTE */ SELECT CAST(x.x AS REGCLASS), x.* FROM x AS x JOIN x AS x ON x.x = x.x AND x.x = CAST(CAST(x.x AS REGCLASS) AS TEXT) JOIN (SELECT EXPLODE(x) AS x, x FROM x AS x) AS x ON x.x = x.x WHERE x <> 'pg_catalog';
/* Test bug in rangetable flattening */ EXPLAIN (verbose, costs off) select 1 from   (select * from int8_tbl where q1 <> (select 42) offset 0) ss where false;
/* Test LATERAL */ SELECT x, x.* FROM x AS x, LATERAL (SELECT * FROM x AS x WHERE x = x.x) AS x;
EXPLAIN (costs off)   select unique2, x.*   from tenk1 a, lateral (select * from int4_tbl b where f1 = a.unique1) x;
SELECT x, x.* FROM x AS x, LATERAL (SELECT x FROM x WHERE x = x) AS x;
EXPLAIN (costs off)   select unique2, x.*   from int4_tbl x, lateral (select unique2 from tenk1 where f1 = unique1) ss;
EXPLAIN (costs off)   select unique2, x.*   from int4_tbl x cross join lateral (select unique2 from tenk1 where f1 = unique1) ss;
SELECT x, x.* FROM x AS x LEFT JOIN LATERAL (SELECT x, x FROM x WHERE x = x) AS x ON TRUE;
EXPLAIN (costs off)   select unique2, x.*   from int4_tbl x left join lateral (select unique1, unique2 from tenk1 where f1 = unique1) ss on true;
/* check scoping of lateral versus parent references */ /* the first of these should return int8_tbl.q2, the second int8_tbl.q1 */ SELECT *, (SELECT x FROM (SELECT x AS x) AS x, (SELECT x AS x) AS x) FROM x;
SELECT *, (SELECT x FROM (SELECT x AS x) AS x, LATERAL (SELECT x AS x) AS x) FROM x;
/* lateral with function in FROM */ SELECT COUNT(*) FROM x AS x, LATERAL UNNEST(GENERATE_SERIES(1, x)) AS x;
EXPLAIN (costs off)   select count(*) from tenk1 a, lateral generate_series(1,two) g;
EXPLAIN (costs off)   select count(*) from tenk1 a cross join lateral generate_series(1,two) g;
/* don't need the explicit LATERAL keyword for functions */ EXPLAIN (costs off)   select count(*) from tenk1 a, generate_series(1,two) g;
/* lateral with UNION ALL subselect */ EXPLAIN (costs off)   select * from generate_series(100,200) g,     lateral (select * from int8_tbl a where g = q1 union all              select * from int8_tbl b where g = q2) ss;
SELECT * FROM x AS x, LATERAL (SELECT * FROM x AS x WHERE x = x UNION ALL SELECT * FROM x AS x WHERE x = x) AS x;
/* lateral with VALUES */ EXPLAIN (costs off)   select count(*) from tenk1 a,     tenk1 b join lateral (values(a.unique1)) ss(x) on b.unique2 = ss.x;
SELECT COUNT(*) FROM x AS x, x AS x JOIN LATERAL (VALUES (x.x)) AS x ON x.x = x.x;
/* lateral with VALUES, no flattening possible */ EXPLAIN (costs off)   select count(*) from tenk1 a,     tenk1 b join lateral (values(a.unique1),(-1)) ss(x) on b.unique2 = ss.x;
SELECT COUNT(*) FROM x AS x, x AS x JOIN LATERAL (VALUES (x.x), (-1)) AS x ON x.x = x.x;
/* lateral injecting a strange outer join condition */ EXPLAIN (costs off)   select * from int8_tbl a,     int8_tbl x left join lateral (select a.q1 from int4_tbl y) ss(z)       on x.q2 = ss.z   order by a.q1, a.q2, x.q1, x.q2, ss.z;
SELECT * FROM x AS x, x AS x LEFT JOIN LATERAL (SELECT x.x FROM x AS x) AS x ON x.x = x.x ORDER BY x.x NULLS LAST, x.x NULLS LAST, x.x NULLS LAST, x.x NULLS LAST, x.x NULLS LAST;
/* lateral reference to a join alias variable */ SELECT * FROM (SELECT x / 2 AS x FROM x) AS x JOIN x AS x ON x = x, LATERAL (SELECT x) AS x;
SELECT * FROM (SELECT x AS x FROM x) AS x JOIN x AS x ON x = x, LATERAL (VALUES (x)) AS x;
SELECT * FROM ((SELECT x / 2 AS x FROM x) AS x JOIN x AS x ON x = x) AS x, LATERAL (SELECT x) AS x;
/* lateral references requiring pullup */ SELECT * FROM (VALUES (1)) AS x, LATERAL UNNEST(GENERATE_SERIES(x, 4)) AS x;
SELECT * FROM (SELECT x / 1000000000 FROM x) AS x, LATERAL UNNEST(GENERATE_SERIES(x, 4)) AS x;
SELECT * FROM (VALUES (1)) AS x, LATERAL (VALUES (x)) AS x;
SELECT * FROM (VALUES (1)) AS x, LATERAL (SELECT x FROM x) AS x;
SELECT * FROM x AS x LEFT JOIN (SELECT x, COALESCE(x, 0) AS x FROM x) AS x ON x.x = x.x, LATERAL (VALUES (x.x, x.x, x.x)) AS x;
SELECT * FROM x AS x LEFT JOIN (SELECT x, COALESCE(x, 0) AS x FROM x) AS x ON x.x = x.x, LATERAL (SELECT x.x, x.x, x.x) AS x;
SELECT x.* FROM x AS x LEFT JOIN (SELECT x, COALESCE(x, 0) AS x FROM x) AS x ON x.x = x.x, LATERAL (SELECT x.x, x.x, x.x) AS x;
SELECT x.* FROM (x AS x LEFT JOIN (SELECT x, COALESCE(x, 0) AS x FROM x) AS x ON x.x = x.x) LEFT JOIN x AS x ON x.x = x.x, LATERAL (SELECT x.x, x.x UNION ALL SELECT x.x, x.x) AS x;
SELECT x.* FROM (x AS x LEFT JOIN (SELECT x, (SELECT COALESCE(x, 0)) AS x FROM x) AS x ON x.x = x.x) LEFT JOIN x AS x ON x.x = x.x, LATERAL (SELECT x.x, x.x UNION ALL SELECT x.x, x.x) AS x;
SELECT x.* FROM (x AS x LEFT JOIN (SELECT x, (SELECT COALESCE(x, 0)) AS x FROM x) AS x ON x.x = x.x) LEFT JOIN x AS x ON x.x = x.x, LATERAL (SELECT x.x, x.x FROM x UNION ALL SELECT x.x, x.x FROM x) AS x;
EXPLAIN (verbose, costs off) select * from   int8_tbl a left join   lateral (select *, a.q2 as x from int8_tbl b) ss on a.q2 = ss.q1;
SELECT * FROM x AS x LEFT JOIN LATERAL (SELECT *, x.x AS x FROM x AS x) AS x ON x.x = x.x;
EXPLAIN (verbose, costs off) select * from   int8_tbl a left join   lateral (select *, coalesce(a.q2, 42) as x from int8_tbl b) ss on a.q2 = ss.q1;
SELECT * FROM x AS x LEFT JOIN LATERAL (SELECT *, COALESCE(x.x, 42) AS x FROM x AS x) AS x ON x.x = x.x;
/* lateral can result in join conditions appearing below their */ /* real semantic level */ EXPLAIN (verbose, costs off) select * from int4_tbl i left join   lateral (select * from int2_tbl j where i.f1 = j.f1) k on true;
SELECT * FROM x AS x LEFT JOIN LATERAL (SELECT * FROM x AS x WHERE x.x = x.x) AS x ON TRUE;
EXPLAIN (verbose, costs off) select * from int4_tbl i left join   lateral (select coalesce(i) from int2_tbl j where i.f1 = j.f1) k on true;
SELECT * FROM x AS x LEFT JOIN LATERAL (SELECT COALESCE(x) FROM x AS x WHERE x.x = x.x) AS x ON TRUE;
EXPLAIN (verbose, costs off) select * from int4_tbl a,   lateral (     select * from int4_tbl b left join int8_tbl c on (b.f1 = q1 and a.f1 = q2)   ) ss;
SELECT * FROM x AS x, LATERAL (SELECT * FROM x AS x LEFT JOIN x AS x ON (x.x = x AND x.x = x)) AS x;
/* lateral reference in a PlaceHolderVar evaluated at join level */ EXPLAIN (verbose, costs off) select * from   int8_tbl a left join lateral   (select b.q1 as bq1, c.q1 as cq1, least(a.q1,b.q1,c.q1) from    int8_tbl b cross join int8_tbl c) ss   on a.q2 = ss.bq1;
SELECT * FROM x AS x LEFT JOIN LATERAL (SELECT x.x AS x, x.x AS x, LEAST(x.x, x.x, x.x) FROM x AS x CROSS JOIN x AS x) AS x ON x.x = x.x;
/* case requiring nested PlaceHolderVars */ EXPLAIN (verbose, costs off) select * from   int8_tbl c left join (     int8_tbl a left join (select q1, coalesce(q2,42) as x from int8_tbl b) ss1       on a.q2 = ss1.q1     cross join     lateral (select q1, coalesce(ss1.x,q2) as y from int8_tbl d) ss2   ) on c.q2 = ss2.q1,   lateral (select ss2.y offset 0) ss3;
/* another case requiring nested PlaceHolderVars */ EXPLAIN (verbose, costs off) select * from   (select 0 as val0) as ss0   left join (select 1 as val) as ss1 on true   left join lateral (select ss1.val as val_filtered where false) as ss2 on true;
SELECT * FROM (SELECT 0 AS x) AS x LEFT JOIN (SELECT 1 AS x) AS x ON TRUE LEFT JOIN LATERAL (SELECT x.x AS x WHERE FALSE) AS x ON TRUE;
/* case that breaks the old ph_may_need optimization */ EXPLAIN (verbose, costs off) select c.*,a.*,ss1.q1,ss2.q1,ss3.* from   int8_tbl c left join (     int8_tbl a left join       (select q1, coalesce(q2,f1) as x from int8_tbl b, int4_tbl b2        where q1 < f1) ss1       on a.q2 = ss1.q1     cross join     lateral (select q1, coalesce(ss1.x,q2) as y from int8_tbl d) ss2   ) on c.q2 = ss2.q1,   lateral (select * from int4_tbl i where ss2.y > f1) ss3;
/* check processing of postponed quals (bug #9041) */ EXPLAIN (verbose, costs off) select * from   (select 1 as x offset 0) x cross join (select 2 as y offset 0) y   left join lateral (     select * from (select 3 as z offset 0) z where z.z = x.x   ) zz on zz.z = y.y;
/* a new postponed-quals issue (bug #17768) */ EXPLAIN (costs off) select * from int4_tbl t1,   lateral (select * from int4_tbl t2 inner join int4_tbl t3 on t1.f1 = 1            inner join (int4_tbl t4 left join int4_tbl t5 on true) on true) ss;
/* check dummy rels with lateral references (bug #15694) */ EXPLAIN (verbose, costs off) select * from int8_tbl i8 left join lateral   (select *, i8.q2 from int4_tbl where false) ss on true;
EXPLAIN (verbose, costs off) select * from int8_tbl i8 left join lateral   (select *, i8.q2 from int4_tbl i1, int4_tbl i2 where false) ss on true;
/* check handling of nested appendrels inside LATERAL */ SELECT * FROM ((SELECT 2 AS x) UNION ALL (SELECT 3 AS x)) AS x CROSS JOIN LATERAL ((SELECT * FROM ((SELECT 4 AS x) UNION ALL (SELECT 5 AS x)) AS x) UNION ALL (SELECT x.x)) AS x;
/* check the number of columns specified */ SELECT * FROM (x AS x CROSS JOIN x AS x) AS x;
/* check we don't try to do a unique-ified semijoin with LATERAL */ EXPLAIN (verbose, costs off) select * from   (values (0,9998), (1,1000)) v(id,x),   lateral (select f1 from int4_tbl            where f1 = any (select unique1 from tenk1                            where unique2 = v.x offset 0)) ss;
SELECT * FROM (VALUES (0, 9998), (1, 1000)) AS x, LATERAL (SELECT x FROM x WHERE x = ANY (SELECT x FROM x WHERE x = x.x OFFSET 0)) AS x;
/* check proper extParam/allParam handling (this isn't exactly a LATERAL issue, */ /* but we can make the test case much more compact with LATERAL) */ EXPLAIN (verbose, costs off) select * from (values (0), (1)) v(id), lateral (select * from int8_tbl t1,          lateral (select * from                     (select * from int8_tbl t2                      where (q1, random() > 0) = any (select q2, random() > 0 from int8_tbl t3                                      where q2 = (select greatest(t1.q1,t2.q2))                                        and (select v.id=0)) offset 0) ss2) ss          where t1.q1 = ss.q2) ss0;
SELECT * FROM (VALUES (0), (1)) AS x, LATERAL (SELECT * FROM x AS x, LATERAL (SELECT * FROM (SELECT * FROM x AS x WHERE (x, RAND() > 0) = ANY (SELECT x, RAND() > 0 FROM x AS x WHERE x = (SELECT GREATEST(x.x, x.x)) AND (SELECT x.x = 0)) OFFSET 0) AS x) AS x WHERE x.x = x.x) AS x;
/* test some error cases where LATERAL should have been used but wasn't */ SELECT x, x FROM x AS x, (SELECT x AS x) AS x;
SELECT x, x FROM x AS x, (SELECT x.x AS x) AS x;
SELECT x, x FROM x AS x CROSS JOIN (SELECT x AS x) AS x;
SELECT x, x FROM x AS x CROSS JOIN (SELECT x.x AS x) AS x;
/* SQL:2008 says the left table is in scope but illegal to access here */ SELECT x, x FROM x AS x RIGHT JOIN LATERAL UNNEST(GENERATE_SERIES(0, x.x)) AS x ON TRUE;
SELECT x, x FROM x AS x FULL JOIN LATERAL UNNEST(GENERATE_SERIES(0, x.x)) AS x ON TRUE;
/* check we complain about ambiguous table references */ SELECT * FROM x AS x CROSS JOIN (x AS x CROSS JOIN LATERAL (SELECT x.x) AS x);
/* LATERAL can be used to put an aggregate into the FROM clause of its query */ SELECT 1 FROM x AS x, LATERAL (SELECT MAX(x.x) FROM x AS x) AS x;
/* check behavior of LATERAL in UPDATE/DELETE */ CREATE TEMPORARY TABLE x AS SELECT x AS x, -x AS x FROM x;
/* error, can't do this: */ UPDATE x SET x = x FROM (SELECT * FROM x WHERE x = x) AS x;
UPDATE x SET x = x FROM (SELECT * FROM x WHERE x = x.x) AS x;
/* can't do it even with LATERAL: */ UPDATE x SET x = x FROM LATERAL (SELECT * FROM x WHERE x = x) AS x;
/* we might in future allow something like this, but for now it's an error: */ UPDATE x SET x = x FROM x, LATERAL (SELECT * FROM x WHERE x = x) AS x;
/* also errors: */ DELETE FROM x USING (SELECT * FROM x WHERE x = x) AS x;
DELETE FROM x USING (SELECT * FROM x WHERE x = x.x) AS x;
DELETE FROM x USING LATERAL (SELECT * FROM x WHERE x = x) AS x;
/* test LATERAL reference propagation down a multi-level inheritance hierarchy */ /* produced for a multi-level partitioned table hierarchy. */ CREATE TABLE x (x INT, x INT, x VARCHAR) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (0) TO (100) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (100) TO (200);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (0) TO (100);
INSERT INTO x VALUES (1, 1, 'x'), (101, 101, 'y');
CREATE TABLE x (x INT, x INT, x VARCHAR);
INSERT INTO x VALUES (101, 101, 'y'), (2, 2, 'z');
EXPLAIN (verbose, costs off) select t1.b, ss.phv from join_ut1 t1 left join lateral               (select t2.a as t2a, t3.a t3a, least(t1.a, t2.a, t3.a) phv 					  from join_pt1 t2 join join_ut1 t3 on t2.a = t3.b) ss               on t1.a = ss.t2a order by t1.a;
SELECT x.x, x.x FROM x AS x LEFT JOIN LATERAL (SELECT x.x AS x, x.x AS x, LEAST(x.x, x.x, x.x) AS x FROM x AS x JOIN x AS x ON x.x = x.x) AS x ON x.x = x.x ORDER BY x.x NULLS LAST;
DROP TABLE x;
DROP TABLE x;
/* test estimation behavior with multi-column foreign key and constant qual */ BEGIN;
CREATE TABLE x (x INT, x INT, x INT, x INT);
INSERT INTO x SELECT x, x / 10, x / 10, x / 100 FROM x AS x;
CREATE UNIQUE INDEX ON x(x NULLS LAST, x NULLS LAST, x NULLS LAST);
ANALYZE x;
EXPLAIN (costs off) select * from fkest f1   join fkest f2 on (f1.x = f2.x and f1.x10 = f2.x10b and f1.x100 = f2.x100)   join fkest f3 on f1.x = f3.x   where f1.x100 = 2;
ALTER TABLE x ADD CONSTRAINT x FOREIGN KEY (x, x, x) REFERENCES x (x, x, x);
EXPLAIN (costs off) select * from fkest f1   join fkest f2 on (f1.x = f2.x and f1.x10 = f2.x10b and f1.x100 = f2.x100)   join fkest f3 on f1.x = f3.x   where f1.x100 = 2;
ROLLBACK;
/* test that foreign key join estimation performs sanely for outer joins */ BEGIN;
CREATE TABLE x (x INT, x INT, x INT UNIQUE, PRIMARY KEY (x NULLS LAST, x NULLS LAST));
CREATE TABLE x (x INT, x INT, PRIMARY KEY (x NULLS LAST, x NULLS LAST));
INSERT INTO x SELECT x / 10, x % 10, x FROM x AS x;
INSERT INTO x SELECT x / 10, x % 10 FROM x AS x;
ALTER TABLE x ADD CONSTRAINT x FOREIGN KEY (x, x) REFERENCES x;
ANALYZE x;
ANALYZE x;
EXPLAIN (costs off) select * from fkest f   left join fkest1 f1 on f.a = f1.a and f.b = f1.b   left join fkest1 f2 on f.a = f2.a and f.b = f2.b   left join fkest1 f3 on f.a = f3.a and f.b = f3.b where f.c = 1;
ROLLBACK;
/* test planner's ability to mark joins as unique */ CREATE TABLE x (x INT PRIMARY KEY);
CREATE TABLE x (x INT PRIMARY KEY);
CREATE TABLE x (x INT);
INSERT INTO x VALUES (1), (2), (3);
INSERT INTO x VALUES (1), (2), (3);
INSERT INTO x VALUES (1), (1);
ANALYZE x;
ANALYZE x;
ANALYZE x;
/* ensure join is properly marked as unique */ EXPLAIN (verbose, costs off) select * from j1 inner join j2 on j1.id = j2.id;
/* ensure join is not unique when not an equi-join */ EXPLAIN (verbose, costs off) select * from j1 inner join j2 on j1.id > j2.id;
/* ensure non-unique rel is not chosen as inner */ EXPLAIN (verbose, costs off) select * from j1 inner join j3 on j1.id = j3.id;
/* ensure left join is marked as unique */ EXPLAIN (verbose, costs off) select * from j1 left join j2 on j1.id = j2.id;
/* ensure right join is marked as unique */ EXPLAIN (verbose, costs off) select * from j1 right join j2 on j1.id = j2.id;
/* ensure full join is marked as unique */ EXPLAIN (verbose, costs off) select * from j1 full join j2 on j1.id = j2.id;
/* a clauseless (cross) join can't be unique */ EXPLAIN (verbose, costs off) select * from j1 cross join j2;
/* ensure a natural join is marked as unique */ EXPLAIN (verbose, costs off) select * from j1 natural join j2;
/* ensure a distinct clause allows the inner to become unique */ EXPLAIN (verbose, costs off) select * from j1 inner join (select distinct id from j3) j3 on j1.id = j3.id;
/* ensure group by clause allows the inner to become unique */ EXPLAIN (verbose, costs off) select * from j1 inner join (select id from j3 group by id) j3 on j1.id = j3.id;
DROP TABLE x;
DROP TABLE x;
DROP TABLE x;
/* test more complex permutations of unique joins */ CREATE TABLE x (x INT, x INT, PRIMARY KEY (x NULLS LAST, x NULLS LAST));
CREATE TABLE x (x INT, x INT, PRIMARY KEY (x NULLS LAST, x NULLS LAST));
CREATE TABLE x (x INT, x INT, PRIMARY KEY (x NULLS LAST, x NULLS LAST));
INSERT INTO x VALUES (1, 1), (1, 2);
INSERT INTO x VALUES (1, 1);
INSERT INTO x VALUES (1, 1);
ANALYZE x;
ANALYZE x;
ANALYZE x;
/* ensure there's no unique join when not all columns which are part of the */ /* unique index are seen in the join clause */ EXPLAIN (verbose, costs off) select * from j1 inner join j2 on j1.id1 = j2.id1;
/* ensure proper unique detection with multiple join quals */ EXPLAIN (verbose, costs off) select * from j1 inner join j2 on j1.id1 = j2.id1 and j1.id2 = j2.id2;
/* ensure we don't detect the join to be unique when quals are not part of the */ /* join condition */ EXPLAIN (verbose, costs off) select * from j1 inner join j2 on j1.id1 = j2.id1 where j1.id2 = 1;
/* as above, but for left joins. */ EXPLAIN (verbose, costs off) select * from j1 left join j2 on j1.id1 = j2.id1 where j1.id2 = 1;
CREATE UNIQUE INDEX x ON x(x NULLS LAST) WHERE NOT x IS NULL;
/* ensure we don't use a partial unique index as unique proofs */ EXPLAIN (verbose, costs off) select * from j1 inner join j2 on j1.id2 = j2.id2;
DROP INDEX x;
SET x = 0 /* validate logic in merge joins which skips mark and restore. */ /* it should only do this if all quals which were used to detect the unique */ /* are present as join quals, and not plain quals. */;
SET x = 0;
SET x = 0;
/* create indexes that will be preferred over the PKs to perform the join */ CREATE INDEX x ON x(x NULLS LAST) WHERE x % 1000 = 1;
CREATE INDEX x ON x(x NULLS LAST) WHERE x % 1000 = 1;
/* need an additional row in j2, if we want j2_id1_idx to be preferred */ INSERT INTO x VALUES (1, 2);
ANALYZE x;
EXPLAIN (costs off) select * from j1 inner join j2 on j1.id1 = j2.id1 and j1.id2 = j2.id2 where j1.id1 % 1000 = 1 and j2.id1 % 1000 = 1;
SELECT * FROM x INNER JOIN x ON x.x = x.x AND x.x = x.x WHERE x.x % 1000 = 1 AND x.x % 1000 = 1;
/* Exercise array keys mark/restore B-Tree code */ EXPLAIN (costs off) select * from j1 inner join j2 on j1.id1 = j2.id1 and j1.id2 = j2.id2 where j1.id1 % 1000 = 1 and j2.id1 % 1000 = 1 and j2.id1 = any (array[1]);
SELECT * FROM x INNER JOIN x ON x.x = x.x AND x.x = x.x WHERE x.x % 1000 = 1 AND x.x % 1000 = 1 AND x.x = ANY(ARRAY(1));
/* Exercise array keys "find extreme element" B-Tree code */ EXPLAIN (costs off) select * from j1 inner join j2 on j1.id1 = j2.id1 and j1.id2 = j2.id2 where j1.id1 % 1000 = 1 and j2.id1 % 1000 = 1 and j2.id1 >= any (array[1,5]);
SELECT * FROM x INNER JOIN x ON x.x = x.x AND x.x = x.x WHERE x.x % 1000 = 1 AND x.x % 1000 = 1 AND x.x >= ANY(ARRAY(1, 5));
RESET enable_nestloop;
RESET enable_hashjoin;
RESET enable_sort;
DROP TABLE x;
DROP TABLE x;
DROP TABLE x;
/* check that semijoin inner is not seen as unique for a portion of the outerrel */ EXPLAIN (verbose, costs off) select t1.unique1, t2.hundred from onek t1, tenk1 t2 where exists (select 1 from tenk1 t3               where t3.thousand = t1.unique1 and t3.tenthous = t2.hundred)       and t1.unique1 < 1;
/* ... unless it actually is unique */ CREATE TABLE x AS SELECT x, x FROM x;
VACUUM analyze j3;
CREATE UNIQUE INDEX ON x(x NULLS LAST, x NULLS LAST);
EXPLAIN (verbose, costs off) select t1.unique1, t2.hundred from onek t1, tenk1 t2 where exists (select 1 from j3               where j3.unique1 = t1.unique1 and j3.tenthous = t2.hundred)       and t1.unique1 < 1;
DROP TABLE x;
/* Exercise the "skip fetch" Bitmap Heap Scan optimization when candidate */ /* tuples are discarded. This may occur when: */ /*   1. A join doesn't require all inner tuples to be scanned for each outer */ /*      tuple, and */ /*   2. The inner side is scanned using a bitmap heap scan, and */ /*   3. The bitmap heap scan is eligible for the "skip fetch" optimization. */ /*      This optimization is usable when no data from the underlying table is */ /*      needed. Use a temp table so it is only visible to this backend and */ /*      vacuum may reliably mark all blocks in the table all visible in the */ /*      visibility map. */ CREATE TEMPORARY TABLE x (x INT, x INT) WITH (fillfactor=10);
INSERT INTO x SELECT x % 3, x FROM x AS x;
CREATE INDEX ON x(x NULLS LAST);
VACUUM (ANALYZE) skip_fetch;
SET x = off;
SET x = off;
EXPLAIN (COSTS OFF) SELECT t1.a FROM skip_fetch t1 LEFT JOIN skip_fetch t2 ON t2.a = 1 WHERE t2.a IS NULL;
SELECT x.x FROM x AS x LEFT JOIN x AS x ON x.x = 1 WHERE x.x IS NULL;
RESET enable_indexonlyscan;
RESET enable_seqscan;
SET x = off /* Test BitmapHeapScan with a rescan releases resources correctly */;
SET x = off;
CREATE TEMPORARY TABLE x (x INT);
INSERT INTO x VALUES (1), (2);
CREATE INDEX ON x(x NULLS LAST);
EXPLAIN (COSTS OFF) SELECT * FROM rescan_bhs t1 LEFT JOIN rescan_bhs t2 ON t1.a IN   (SELECT a FROM rescan_bhs t3 WHERE t2.a > 1);
SELECT * FROM x AS x LEFT JOIN x AS x ON x.x IN (SELECT x FROM x AS x WHERE x.x > 1);
RESET enable_seqscan;
RESET enable_indexscan;
/* Test that we do not account for nullingrels when looking up statistics */ CREATE TABLE x (x INT, x INT);
INSERT INTO x SELECT 1, 1;
CREATE STATISTICS group_tbl_stat (ndistinct) ON a, b FROM group_tbl;
ANALYZE x;
EXPLAIN (COSTS OFF) SELECT 1 FROM group_tbl t1     LEFT JOIN (SELECT a c1, COALESCE(a) c2 FROM group_tbl t2) s ON TRUE GROUP BY s.c1, s.c2;
DROP TABLE x;
/* Test for a nested loop join involving index scan, transforming OR-clauses */ /* to SAOP. */ EXPLAIN (COSTS OFF) SELECT COUNT(*) FROM tenk1 t1, tenk1 t2 WHERE t2.thousand = t1.tenthous OR t2.thousand = t1.unique1 OR t2.thousand = t1.unique2;
SELECT COUNT(*) FROM x AS x, x AS x WHERE x.x = x.x OR x.x = x.x OR x.x = x.x;
EXPLAIN (COSTS OFF) SELECT COUNT(*) FROM onek t1 LEFT JOIN tenk1 t2     ON (t2.thousand = t1.tenthous OR t2.thousand = t1.thousand);
SELECT COUNT(*) FROM x AS x LEFT JOIN x AS x ON (x.x = x.x OR x.x = x.x);
/* exercises for the hash join code */ BEGIN;
SET LOCAL x = 0;
SET LOCAL x = 0;
SET LOCAL x = on;
x AS x;
BEGIN if node->>'Node Type' = 'Hash' then     return node;
if x is not null then         return x;
x AS x;
COMMIT;
x AS x;
BEGIN for whole_plan in     execute 'explain (analyze, format ''json'') ' || query   loop     hash_node := find_hash(json_extract_path(whole_plan, '0', 'Plan'));
x := JSON_EXTRACT_SCALAR(x, '$["Original Hash Batches"]');
x := JSON_EXTRACT_SCALAR(x, '$["Hash Batches"]');
x AS x;
COMMIT;
/* Make a simple relation with well distributed keys and correctly */ /* estimated size. */ CREATE TABLE x AS SELECT UNNEST(GENERATE_SERIES(1, 20000)) AS x, 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa';
ALTER TABLE x SET x = 2;
ANALYZE x;
/* Make a relation whose size we will under-estimate.  We want stats */ /* to say 1000 rows, but actually there are 20,000 rows. */ CREATE TABLE x AS SELECT UNNEST(GENERATE_SERIES(1, 20000)) AS x, 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa';
ALTER TABLE x SET x = 'false';
ALTER TABLE x SET x = 2;
ANALYZE x;
UPDATE x SET x = 1000 WHERE x = 'bigger_than_it_looks';
/* Make a relation whose size we underestimate and that also has a */ /* kind of skew that breaks our batching scheme.  We want stats to say */ /* 2 rows, but actually there are 20,000 rows with the same key. */ CREATE TABLE x (x INT, x TEXT);
ALTER TABLE x SET x = 'false';
ALTER TABLE x SET x = 2;
ANALYZE x;
INSERT INTO x SELECT 42 AS x, 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' FROM x;
UPDATE x SET x = 2, x = PG_RELATION_SIZE('extremely_skewed') / 8192 WHERE x = 'extremely_skewed';
/* Make a relation with a couple of enormous tuples. */ CREATE TABLE x AS SELECT UNNEST(GENERATE_SERIES(1, 2)) AS x, RPAD('', 320000, 'x') AS x;
ALTER TABLE x SET x = 2;
SET LOCAL x = 0;
SET LOCAL x = '4MB';
SET LOCAL x = 1.0;
EXPLAIN (costs off)   select count(*) from simple r join simple s using (id);
SELECT COUNT(*) FROM x AS x JOIN x AS x USING (x);
ROLLBACK TO x;
x AS x /* parallel with parallel-oblivious hash join */;
SET LOCAL x = 2;
SET LOCAL x = '4MB';
SET LOCAL x = 1.0;
SET LOCAL x = off;
EXPLAIN (costs off)   select count(*) from simple r join simple s using (id);
SELECT COUNT(*) FROM x AS x JOIN x AS x USING (x);
ROLLBACK TO x;
x AS x /* parallel with parallel-aware hash join */;
SET LOCAL x = 2;
SET LOCAL x = '4MB';
SET LOCAL x = 1.0;
SET LOCAL x = on;
EXPLAIN (costs off)   select count(*) from simple r join simple s using (id);
SELECT COUNT(*) FROM x AS x JOIN x AS x USING (x);
ROLLBACK TO x;
SET LOCAL x = 0;
SET LOCAL x = '128kB';
SET LOCAL x = 1.0;
EXPLAIN (costs off)   select count(*) from simple r join simple s using (id);
SELECT COUNT(*) FROM x AS x JOIN x AS x USING (x);
ROLLBACK TO x;
x AS x /* parallel with parallel-oblivious hash join */;
SET LOCAL x = 2;
SET LOCAL x = '128kB';
SET LOCAL x = 1.0;
SET LOCAL x = off;
EXPLAIN (costs off)   select count(*) from simple r join simple s using (id);
SELECT COUNT(*) FROM x AS x JOIN x AS x USING (x);
ROLLBACK TO x;
x AS x /* parallel with parallel-aware hash join */;
SET LOCAL x = 2;
SET LOCAL x = '192kB';
SET LOCAL x = 1.0;
SET LOCAL x = on;
EXPLAIN (costs off)   select count(*) from simple r join simple s using (id);
SELECT COUNT(*) FROM x AS x JOIN x AS x USING (x);
/* parallel full multi-batch hash join */ SELECT COUNT(*) FROM x AS x FULL OUTER JOIN x AS x USING (x);
ROLLBACK TO x;
SET LOCAL x = 0;
SET LOCAL x = '128kB';
SET LOCAL x = 1.0;
EXPLAIN (costs off)   select count(*) FROM simple r JOIN bigger_than_it_looks s USING (id);
SELECT COUNT(*) FROM x AS x JOIN x AS x USING (x);
ROLLBACK TO x;
x AS x /* parallel with parallel-oblivious hash join */;
SET LOCAL x = 2;
SET LOCAL x = '128kB';
SET LOCAL x = 1.0;
SET LOCAL x = off;
EXPLAIN (costs off)   select count(*) from simple r join bigger_than_it_looks s using (id);
SELECT COUNT(*) FROM x AS x JOIN x AS x USING (x);
ROLLBACK TO x;
x AS x /* parallel with parallel-aware hash join */;
SET LOCAL x = 1;
SET LOCAL x = '192kB';
SET LOCAL x = 1.0;
SET LOCAL x = on;
EXPLAIN (costs off)   select count(*) from simple r join bigger_than_it_looks s using (id);
SELECT COUNT(*) FROM x AS x JOIN x AS x USING (x);
ROLLBACK TO x;
SET LOCAL x = 0;
SET LOCAL x = '128kB';
SET LOCAL x = 1.0;
EXPLAIN (costs off)   select count(*) from simple r join extremely_skewed s using (id);
SELECT COUNT(*) FROM x AS x JOIN x AS x USING (x);
ROLLBACK TO x;
x AS x /* parallel with parallel-oblivious hash join */;
SET LOCAL x = 2;
SET LOCAL x = '128kB';
SET LOCAL x = 1.0;
SET LOCAL x = off;
EXPLAIN (costs off)   select count(*) from simple r join extremely_skewed s using (id);
SELECT COUNT(*) FROM x AS x JOIN x AS x USING (x);
ROLLBACK TO x;
x AS x /* parallel with parallel-aware hash join */;
SET LOCAL x = 1;
SET LOCAL x = '128kB';
SET LOCAL x = 1.0;
SET LOCAL x = on;
EXPLAIN (costs off)   select count(*) from simple r join extremely_skewed s using (id);
SELECT COUNT(*) FROM x AS x JOIN x AS x USING (x);
ROLLBACK TO x;
x AS x /* A couple of other hash join tests unrelated to work_mem management. */ /* Check that EXPLAIN ANALYZE has data even if the leader doesn't participate */;
SET LOCAL x = 2;
SET LOCAL x = '4MB';
SET LOCAL x = 1.0;
SET LOCAL x = off;
ROLLBACK TO x;
/* Exercise rescans.  We'll turn off parallel_leader_participation so */ /* that we can check that instrumentation comes back correctly. */ CREATE TABLE x AS SELECT UNNEST(GENERATE_SERIES(1, 3)) AS x, CAST('xxxxx' AS TEXT) AS x;
ALTER TABLE x SET x = 0;
CREATE TABLE x AS SELECT UNNEST(GENERATE_SERIES(1, 10000)) AS x, CAST('xxxxx' AS TEXT) AS x;
ALTER TABLE x SET x = 2;
x AS x /* multi-batch with rescan, parallel-oblivious */;
SET x = off;
SET x = off;
SET x = 0;
SET x = 0;
SET x = 0;
SET x = 2;
SET x = off;
SET x = off;
SET x = '64kB';
SET x = 1.0;
EXPLAIN (costs off)   select count(*) from join_foo     left join (select b1.id, b1.t from join_bar b1 join join_bar b2 using (id)) ss     on join_foo.id < ss.id + 1 and join_foo.id > ss.id - 1;
SELECT COUNT(*) FROM x LEFT JOIN (SELECT x.x, x.x FROM x AS x JOIN x AS x USING (x)) AS x ON x.x < x.x + 1 AND x.x > x.x - 1;
ROLLBACK TO x;
x AS x /* single-batch with rescan, parallel-oblivious */;
SET x = off;
SET x = off;
SET x = 0;
SET x = 0;
SET x = 0;
SET x = 2;
SET x = off;
SET x = off;
SET x = '4MB';
SET x = 1.0;
EXPLAIN (costs off)   select count(*) from join_foo     left join (select b1.id, b1.t from join_bar b1 join join_bar b2 using (id)) ss     on join_foo.id < ss.id + 1 and join_foo.id > ss.id - 1;
SELECT COUNT(*) FROM x LEFT JOIN (SELECT x.x, x.x FROM x AS x JOIN x AS x USING (x)) AS x ON x.x < x.x + 1 AND x.x > x.x - 1;
ROLLBACK TO x;
x AS x /* multi-batch with rescan, parallel-aware */;
SET x = on;
SET x = off;
SET x = 0;
SET x = 0;
SET x = 0;
SET x = 2;
SET x = off;
SET x = off;
SET x = '64kB';
SET x = 1.0;
EXPLAIN (costs off)   select count(*) from join_foo     left join (select b1.id, b1.t from join_bar b1 join join_bar b2 using (id)) ss     on join_foo.id < ss.id + 1 and join_foo.id > ss.id - 1;
SELECT COUNT(*) FROM x LEFT JOIN (SELECT x.x, x.x FROM x AS x JOIN x AS x USING (x)) AS x ON x.x < x.x + 1 AND x.x > x.x - 1;
ROLLBACK TO x;
x AS x /* single-batch with rescan, parallel-aware */;
SET x = on;
SET x = off;
SET x = 0;
SET x = 0;
SET x = 0;
SET x = 2;
SET x = off;
SET x = off;
SET x = '4MB';
SET x = 1.0;
EXPLAIN (costs off)   select count(*) from join_foo     left join (select b1.id, b1.t from join_bar b1 join join_bar b2 using (id)) ss     on join_foo.id < ss.id + 1 and join_foo.id > ss.id - 1;
SELECT COUNT(*) FROM x LEFT JOIN (SELECT x.x, x.x FROM x AS x JOIN x AS x USING (x)) AS x ON x.x < x.x + 1 AND x.x > x.x - 1;
ROLLBACK TO x;
x AS x /* A full outer join where every record is matched. */ /* non-parallel */;
SET LOCAL x = 0;
EXPLAIN (costs off)      select  count(*) from simple r full outer join simple s using (id);
SELECT COUNT(*) FROM x AS x FULL OUTER JOIN x AS x USING (x);
ROLLBACK TO x;
x AS x /* parallelism not possible with parallel-oblivious full hash join */;
SET x = off;
SET LOCAL x = 2;
EXPLAIN (costs off)      select  count(*) from simple r full outer join simple s using (id);
SELECT COUNT(*) FROM x AS x FULL OUTER JOIN x AS x USING (x);
ROLLBACK TO x;
x AS x /* parallelism is possible with parallel-aware full hash join */;
SET LOCAL x = 2;
EXPLAIN (costs off)      select  count(*) from simple r full outer join simple s using (id);
SELECT COUNT(*) FROM x AS x FULL OUTER JOIN x AS x USING (x);
ROLLBACK TO x;
x AS x /* A full outer join where every record is not matched. */ /* non-parallel */;
SET LOCAL x = 0;
EXPLAIN (costs off)      select  count(*) from simple r full outer join simple s on (r.id = 0 - s.id);
SELECT COUNT(*) FROM x AS x FULL OUTER JOIN x AS x ON (x.x = 0 - x.x);
ROLLBACK TO x;
x AS x /* parallelism not possible with parallel-oblivious full hash join */;
SET x = off;
SET LOCAL x = 2;
EXPLAIN (costs off)      select  count(*) from simple r full outer join simple s on (r.id = 0 - s.id);
SELECT COUNT(*) FROM x AS x FULL OUTER JOIN x AS x ON (x.x = 0 - x.x);
ROLLBACK TO x;
x AS x /* parallelism is possible with parallel-aware full hash join */;
SET LOCAL x = 2;
EXPLAIN (costs off)      select  count(*) from simple r full outer join simple s on (r.id = 0 - s.id);
SELECT COUNT(*) FROM x AS x FULL OUTER JOIN x AS x ON (x.x = 0 - x.x);
ROLLBACK TO x;
x AS x /* exercise special code paths for huge tuples (note use of non-strict */ /* expression and left join required to get the detoasted tuple into */ /* the hash table) */ /* parallel with parallel-aware hash join (hits ExecParallelHashLoadTuple and */ /* sts_puttuple oversized tuple cases because it's multi-batch) */;
SET x = 2;
SET x = on;
SET x = '128kB';
SET x = 1.0;
EXPLAIN (costs off)   select length(max(s.t))   from wide left join (select id, coalesce(t, '') || '' as t from wide) s using (id);
SELECT LENGTH(MAX(x.x)) FROM x LEFT JOIN (SELECT x, COALESCE(x, '') || '' AS x FROM x) AS x USING (x);
ROLLBACK TO x;
x AS x /* Hash join reuses the HOT status bit to indicate match status. This can only */ /* be guaranteed to produce correct results if all the hash join tuple match */ /* bits are reset before reuse. This is done upon loading them into the */ /* hashtable. */;
SET x = on;
SET x = 0;
SET x = 0;
SET x = 0;
CREATE TABLE x (x INT);
CREATE TABLE x (x INT);
INSERT INTO x VALUES (1);
INSERT INTO x VALUES (2);
/* Update should create a HOT tuple. If this status bit isn't cleared, we won't */ /* correctly emit the NULL-extended unmatching tuple in full hash join. */ UPDATE x SET x = 2;
SELECT * FROM x AS x FULL JOIN x AS x ON x.x = x.x ORDER BY x.x NULLS LAST;
/* Test serial full hash join. */ /* Resetting parallel_setup_cost should force a serial plan. */ /* Just to be safe, however, set enable_parallel_hash to off, as parallel full */ /* hash joins are only supported with shared hashtables. */ RESET parallel_setup_cost;
SET x = off;
SELECT * FROM x AS x FULL JOIN x AS x ON x.x = x.x;
ROLLBACK TO x;
ROLLBACK;
/* Verify that hash key expressions reference the correct */ /* nodes. Hashjoin's hashkeys need to reference its outer plan, Hash's */ /* need to reference Hash's outer plan (which is below HashJoin's */ /* inner plan). It's not trivial to verify that the references are */ /* correct (we don't display the hashkeys themselves), but if the */ /* hashkeys contain subplan references, those will be displayed. Force */ /* subplans to appear just about everywhere. */ /* Bug report: */ /* https://www.postgresql.org/message-id/CAPpHfdvGVegF_TKKRiBrSmatJL2dR9uwFCuR%2BteQ_8tEXU8mxg%40mail.gmail.com */ BEGIN;
SET LOCAL x = OFF;
SET LOCAL x = 1 /* avoid mergejoins */;
/* allows easy changing of join order */ CREATE TABLE x (x TEXT, x INT, x INT, x BOOLEAN);
CREATE TABLE x (x BOOLEAN, x INT, x TEXT, x INT);
INSERT INTO x (x, x, x, x) VALUES ('text', 2, 1, FALSE);
/* matches */ INSERT INTO x (x, x, x, x) VALUES ('text', 1, 2, FALSE);
/* fails id join condition */ INSERT INTO x (x, x, x, x) VALUES ('text', 20, 1, FALSE);
/* fails < 50 */ INSERT INTO x (x, x, x, x) VALUES ('text', 1, 1, FALSE);
/* fails (SELECT hjtest_1.b * 5) = (SELECT hjtest_2.c*5) */ INSERT INTO x (x, x, x, x) VALUES (TRUE, 1, 'another', 2);
/* matches */ INSERT INTO x (x, x, x, x) VALUES (TRUE, 3, 'another', 7);
/* fails id join condition */ INSERT INTO x (x, x, x, x) VALUES (TRUE, 1, 'another', 90);
/* fails < 55 */ INSERT INTO x (x, x, x, x) VALUES (TRUE, 1, 'another', 3);
/* fails (SELECT hjtest_1.b * 5) = (SELECT hjtest_2.c*5) */ INSERT INTO x (x, x, x, x) VALUES (TRUE, 1, 'text', 1);
EXPLAIN (COSTS OFF, VERBOSE) SELECT hjtest_1.a a1, hjtest_2.a a2,hjtest_1.tableoid::regclass t1, hjtest_2.tableoid::regclass t2 FROM hjtest_1, hjtest_2 WHERE     hjtest_1.id = (SELECT 1 WHERE hjtest_2.id = 1)     AND (SELECT hjtest_1.b * 5) = (SELECT hjtest_2.c*5)     AND (SELECT hjtest_1.b * 5) < 50     AND (SELECT hjtest_2.c * 5) < 55     AND hjtest_1.a <> hjtest_2.b;
SELECT x.x AS x, x.x AS x, CAST(x.x AS REGCLASS) AS x, CAST(x.x AS REGCLASS) AS x FROM x, x WHERE x.x = (SELECT 1 WHERE x.x = 1) AND (SELECT x.x * 5) = (SELECT x.x * 5) AND (SELECT x.x * 5) < 50 AND (SELECT x.x * 5) < 55 AND x.x <> x.x;
EXPLAIN (COSTS OFF, VERBOSE) SELECT hjtest_1.a a1, hjtest_2.a a2,hjtest_1.tableoid::regclass t1, hjtest_2.tableoid::regclass t2 FROM hjtest_2, hjtest_1 WHERE     hjtest_1.id = (SELECT 1 WHERE hjtest_2.id = 1)     AND (SELECT hjtest_1.b * 5) = (SELECT hjtest_2.c*5)     AND (SELECT hjtest_1.b * 5) < 50     AND (SELECT hjtest_2.c * 5) < 55     AND hjtest_1.a <> hjtest_2.b;
SELECT x.x AS x, x.x AS x, CAST(x.x AS REGCLASS) AS x, CAST(x.x AS REGCLASS) AS x FROM x, x WHERE x.x = (SELECT 1 WHERE x.x = 1) AND (SELECT x.x * 5) = (SELECT x.x * 5) AND (SELECT x.x * 5) < 50 AND (SELECT x.x * 5) < 55 AND x.x <> x.x;
ROLLBACK;
/* Verify that we behave sanely when the inner hash keys contain parameters */ /* (that is, outer or lateral references).  This situation has to defeat */ /* re-use of the inner hash table across rescans. */ BEGIN;
SET LOCAL x = on;
EXPLAIN (costs off) select i8.q2, ss.* from int8_tbl i8, lateral (select t1.fivethous, i4.f1 from tenk1 t1 join int4_tbl i4          on t1.fivethous = i4.f1+i8.q2 order by 1,2) ss;
SELECT x.x, x.* FROM x AS x, LATERAL (SELECT x.x, x.x FROM x AS x JOIN x AS x ON x.x = x.x + x.x ORDER BY 1 NULLS LAST, 2 NULLS LAST) AS x;
ROLLBACK;
/* Strings. */ SELECT CAST('""' AS JSON);
/* OK. */ SELECT CAST('''''' AS JSON);
/* ERROR, single quotes are not allowed */ SELECT CAST('"abc"' AS JSON);
/* OK */ SELECT CAST('"abc' AS JSON);
/* ERROR, quotes not closed */ SELECT CAST('"abc def"' AS JSON);
/* ERROR, unescaped newline in string constant */ SELECT CAST('"\n\"\\"' AS JSON);
/* OK, legal escapes */ SELECT CAST('"\v"' AS JSON);
/* ERROR, not a valid JSON escape */ /* Check fast path for longer strings (at least 16 bytes long) */ SELECT CAST(('"' || REPEAT('.', 12) || 'abc"') AS JSON);
/* OK */ SELECT CAST(('"' || REPEAT('.', 12) || 'abc\n"') AS JSON);
/* OK, legal escapes */ /* Test various lengths of strings to validate SIMD processing to escape */ /* special chars in the JSON. */ SELECT CAST(ROW_TO_JSON(x) AS JSONB) FROM (SELECT LEFT(abcdefghijklmnopqrstuv"\twxyz012345678, x) AS x FROM x AS x) AS x;
/* see json_encoding test for input with unicode escapes */ /* Numbers. */ SELECT CAST('1' AS JSON);
/* OK */ SELECT CAST('0' AS JSON);
/* OK */ SELECT CAST('01' AS JSON);
/* ERROR, not valid according to JSON spec */ SELECT CAST('0.1' AS JSON);
/* OK */ SELECT CAST('9223372036854775808' AS JSON);
/* OK, even though it's too large for int8 */ SELECT CAST('1e100' AS JSON);
/* OK */ SELECT CAST('1.3e100' AS JSON);
/* OK */ SELECT CAST('1f2' AS JSON);
/* ERROR */ SELECT CAST('0.x1' AS JSON);
/* ERROR */ SELECT CAST('1.3ex100' AS JSON);
/* ERROR */ /* Arrays. */ SELECT CAST('[]' AS JSON);
/* OK */ SELECT CAST('[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]' AS JSON);
/* OK */ SELECT CAST('[1,2]' AS JSON);
/* OK */ SELECT CAST('[1,2,]' AS JSON);
/* ERROR, trailing comma */ SELECT CAST('[1,2' AS JSON);
/* ERROR, no closing bracket */ SELECT CAST('[1,[2]' AS JSON);
/* ERROR, no closing bracket */ /* Objects. */ SELECT CAST('{}' AS JSON);
/* OK */ SELECT CAST('{"abc"}' AS JSON);
/* ERROR, no value */ SELECT CAST('{"abc":1}' AS JSON);
/* OK */ SELECT CAST('{1:"abc"}' AS JSON);
/* ERROR, keys must be strings */ SELECT CAST('{"abc",1}' AS JSON);
/* ERROR, wrong separator */ SELECT CAST('{"abc"=1}' AS JSON);
/* ERROR, totally wrong separator */ SELECT CAST('{"abc"::1}' AS JSON);
/* ERROR, another wrong separator */ SELECT CAST('{"abc":1,"def":2,"ghi":[3,4],"hij":{"klm":5,"nop":[6]}}' AS JSON);
/* OK */ SELECT CAST('{"abc":1:2}' AS JSON);
/* ERROR, colon in wrong spot */ SELECT CAST('{"abc":1,3}' AS JSON);
SET x = '100kB' /* ERROR, no value */ /* Recursion. */;
SELECT CAST(REPEAT('[', 10000) AS JSON);
SELECT CAST(REPEAT('{"a":', 10000) AS JSON);
RESET max_stack_depth;
/* Miscellaneous stuff. */ SELECT CAST('true' AS JSON);
/* OK */ SELECT CAST('false' AS JSON);
/* OK */ SELECT CAST('null' AS JSON);
/* OK */ SELECT CAST(' true ' AS JSON);
/* OK, even with extra whitespace */ SELECT CAST('true false' AS JSON);
/* ERROR, too many values */ SELECT CAST('true, false' AS JSON);
/* ERROR, too many values */ SELECT CAST('truf' AS JSON);
/* ERROR, not a keyword */ SELECT CAST('trues' AS JSON);
/* ERROR, not a keyword */ SELECT CAST('' AS JSON);
/* ERROR, no value */ SELECT CAST('    ' AS JSON);
/* ERROR, no value */ /* Multi-line JSON input to check ERROR reporting */ SELECT CAST('{ 		"one": 1, 		"two":"two", 		"three": 		true}' AS JSON);
/* OK */ SELECT CAST('{ 		"one": 1, 		"two":,"two",  -- ERROR extraneous comma before field "two" 		"three": 		true}' AS JSON);
SELECT CAST('{ 		"one": 1, 		"two":"two", 		"averyveryveryveryveryveryveryveryveryverylongfieldname":}' AS JSON);
/* ERROR missing value for last field */ /* test non-error-throwing input */ SELECT PG_INPUT_IS_VALID('{"a":true}', 'json');
SELECT PG_INPUT_IS_VALID('{"a":true', 'json');
SELECT * FROM x;
/* constructors */ /* array_to_json */ SELECT ARRAY_TO_JSON(ARRAY(SELECT 1 AS x));
SELECT ARRAY_TO_JSON(ARRAY_AGG(x), FALSE) FROM (SELECT x AS x, x * 2 AS x FROM x AS x) AS x;
SELECT ARRAY_TO_JSON(ARRAY_AGG(x), TRUE) FROM (SELECT x AS x, x * 2 AS x FROM x AS x) AS x;
SELECT ARRAY_TO_JSON(ARRAY_AGG(x), FALSE) FROM (SELECT 'a' || x AS x, x AS x, ARRAY(ROW(x.*, ARRAY(1, 2, 3)), ROW(x.*, ARRAY(4, 5, 6))) AS x FROM x AS x, x AS x) AS x;
SELECT ARRAY_TO_JSON(ARRAY_AGG(x), FALSE) FROM x AS x;
SELECT ARRAY_TO_JSON(CAST('{{1,5},{99,100}}' AS ARRAY<INT>));
/* row_to_json */ SELECT ROW_TO_JSON(ROW(1, 'foo'));
SELECT ROW_TO_JSON(x) FROM (SELECT 'a' || x AS x, x AS x, ARRAY(ROW(x.*, ARRAY(1, 2, 3)), ROW(x.*, ARRAY(4, 5, 6))) AS x FROM x AS x, x AS x) AS x;
SELECT ROW_TO_JSON(x, TRUE) FROM (SELECT 'a' || x AS x, x AS x, ARRAY(ROW(x.*, ARRAY(1, 2, 3)), ROW(x.*, ARRAY(4, 5, 6))) AS x FROM x AS x, x AS x) AS x;
CREATE TEMPORARY TABLE x AS SELECT x, 'txt' || x AS x FROM x AS x;
SELECT ROW_TO_JSON(x, TRUE) FROM x AS x;
SELECT ROW_TO_JSON(ROW((SELECT ARRAY_AGG(x) AS x FROM x AS x)), FALSE);
ANALYZE x /* anyarray column */;
SELECT x, TO_JSON(x) AS x FROM x WHERE x = 'rows' AND x = CAST(CAST(PG_MY_TEMP_SCHEMA() AS REGNAMESPACE) AS TEXT) ORDER BY 1 NULLS LAST;
/* to_json, timestamps */ SELECT TO_JSON(CAST('2014-05-28 12:22:35.614298' AS TIMESTAMP));
BEGIN;
SET LOCAL TIME ZONE 10.5;
SELECT TO_JSON(CAST('2014-05-28 12:22:35.614298-04' AS TIMESTAMPTZ));
SET LOCAL TIME ZONE -8;
SELECT TO_JSON(CAST('2014-05-28 12:22:35.614298-04' AS TIMESTAMPTZ));
COMMIT;
SELECT TO_JSON(CAST('2014-05-28' AS DATE));
SELECT TO_JSON(CAST('Infinity' AS DATE));
SELECT TO_JSON(CAST('-Infinity' AS DATE));
SELECT TO_JSON(CAST('Infinity' AS TIMESTAMP));
SELECT TO_JSON(CAST('-Infinity' AS TIMESTAMP));
SELECT TO_JSON(CAST('Infinity' AS TIMESTAMPTZ));
SELECT TO_JSON(CAST('-Infinity' AS TIMESTAMPTZ));
/* json_agg */ SELECT JSON_AGG(x) FROM (SELECT 'a' || x AS x, x AS x, ARRAY(ROW(x.*, ARRAY(1, 2, 3)), ROW(x.*, ARRAY(4, 5, 6))) AS x FROM x AS x, x AS x) AS x;
SELECT JSON_AGG(x ORDER BY x NULLS LAST, x NULLS LAST) FROM x AS x;
UPDATE x SET x = NULL WHERE x = 1;
SELECT JSON_AGG(x ORDER BY x, x NULLS LAST) FROM x AS x;
/* non-numeric output */ SELECT ROW_TO_JSON(x) FROM (SELECT CAST('NaN' AS DOUBLE) AS "x") AS x;
SELECT ROW_TO_JSON(x) FROM (SELECT CAST('Infinity' AS DOUBLE) AS "x") AS x;
SELECT ROW_TO_JSON(x) FROM (SELECT CAST('-Infinity' AS DOUBLE) AS "x") AS x;
/* json input */ SELECT ROW_TO_JSON(x) FROM (SELECT CAST('{"a":1,"b": [2,3,4,"d","e","f"],"c":{"p":1,"q":2}}' AS JSON) AS "x") AS x;
/* json extraction functions */ CREATE TEMPORARY TABLE x (x TEXT, x JSON);
INSERT INTO x VALUES ('scalar', '"a scalar"'), ('array', '["zero", "one","two",null,"four","five", [1,2,3],{"f1":9}]'), ('object', '{"field1":"val1","field2":"val2","field3":null, "field4": 4, "field5": [1,2,3], "field6": {"f1":9}}');
SELECT JSON_EXTRACT(x, '$.x') FROM x WHERE x = 'scalar';
SELECT JSON_EXTRACT(x, '$.x') FROM x WHERE x = 'array';
SELECT JSON_EXTRACT(x, '$.x') FROM x WHERE x = 'object';
SELECT JSON_EXTRACT(x, '$.field2') FROM x WHERE x = 'object';
SELECT JSON_EXTRACT_SCALAR(x, '$.field2') FROM x WHERE x = 'object';
SELECT JSON_EXTRACT(x, '$[2]') FROM x WHERE x = 'scalar';
SELECT JSON_EXTRACT(x, '$[2]') FROM x WHERE x = 'array';
SELECT JSON_EXTRACT(x) - 1 FROM x WHERE x = 'array';
SELECT JSON_EXTRACT(x, '$[2]') FROM x WHERE x = 'object';
SELECT JSON_EXTRACT_SCALAR(x, '$[2]') FROM x WHERE x = 'array';
SELECT JSON_EXTRACT_SCALAR(x, '$[6]') FROM x WHERE x = 'array';
SELECT JSON_EXTRACT_SCALAR(x, '$[7]') FROM x WHERE x = 'array';
SELECT JSON_EXTRACT_SCALAR(x, '$.field4') FROM x WHERE x = 'object';
SELECT JSON_EXTRACT_SCALAR(x, '$.field5') FROM x WHERE x = 'object';
SELECT JSON_EXTRACT_SCALAR(x, '$.field6') FROM x WHERE x = 'object';
SELECT JSON_OBJECT_KEYS(x) FROM x WHERE x = 'scalar';
SELECT JSON_OBJECT_KEYS(x) FROM x WHERE x = 'array';
SELECT JSON_OBJECT_KEYS(x) FROM x WHERE x = 'object';
/* nulls */ SELECT (JSON_EXTRACT(x, '$.field3')) IS NULL AS x FROM x WHERE x = 'object';
SELECT (JSON_EXTRACT_SCALAR(x, '$.field3')) IS NULL AS x FROM x WHERE x = 'object';
SELECT (JSON_EXTRACT(x, '$[3]')) IS NULL AS x FROM x WHERE x = 'array';
SELECT (JSON_EXTRACT_SCALAR(x, '$[3]')) IS NULL AS x FROM x WHERE x = 'array';
/* corner cases */ SELECT CAST(JSON_EXTRACT(CAST('{"a": [{"b": "c"}, {"b": "cc"}]}' AS JSON), NULL) AS TEXT);
SELECT CAST(JSON_EXTRACT(CAST('{"a": [{"b": "c"}, {"b": "cc"}]}' AS JSON), NULL) AS INT);
SELECT JSON_EXTRACT(CAST('{"a": [{"b": "c"}, {"b": "cc"}]}' AS JSON), '$[1]');
SELECT JSON_EXTRACT(CAST('{"a": [{"b": "c"}, {"b": "cc"}]}' AS JSON)) - 1;
SELECT JSON_EXTRACT(CAST('{"a": [{"b": "c"}, {"b": "cc"}]}' AS JSON), '$.z');
SELECT JSON_EXTRACT(CAST('{"a": [{"b": "c"}, {"b": "cc"}]}' AS JSON), '$[""]');
SELECT JSON_EXTRACT(CAST('[{"b": "c"}, {"b": "cc"}]' AS JSON), '$[1]');
SELECT JSON_EXTRACT(CAST('[{"b": "c"}, {"b": "cc"}]' AS JSON), '$[3]');
SELECT JSON_EXTRACT(CAST('[{"b": "c"}, {"b": "cc"}]' AS JSON), '$.z');
SELECT JSON_EXTRACT(CAST('{"a": "c", "b": null}' AS JSON), '$.b');
SELECT JSON_EXTRACT(CAST('"foo"' AS JSON), '$[1]');
SELECT JSON_EXTRACT(CAST('"foo"' AS JSON), '$.z');
SELECT CAST(JSON_EXTRACT_SCALAR(CAST('{"a": [{"b": "c"}, {"b": "cc"}]}' AS JSON), NULL) AS TEXT);
SELECT CAST(JSON_EXTRACT_SCALAR(CAST('{"a": [{"b": "c"}, {"b": "cc"}]}' AS JSON), NULL) AS INT);
SELECT JSON_EXTRACT_SCALAR(CAST('{"a": [{"b": "c"}, {"b": "cc"}]}' AS JSON), '$[1]');
SELECT JSON_EXTRACT_SCALAR(CAST('{"a": [{"b": "c"}, {"b": "cc"}]}' AS JSON), '$.z');
SELECT JSON_EXTRACT_SCALAR(CAST('{"a": [{"b": "c"}, {"b": "cc"}]}' AS JSON), '$[""]');
SELECT JSON_EXTRACT_SCALAR(CAST('[{"b": "c"}, {"b": "cc"}]' AS JSON), '$[1]');
SELECT JSON_EXTRACT_SCALAR(CAST('[{"b": "c"}, {"b": "cc"}]' AS JSON), '$[3]');
SELECT JSON_EXTRACT_SCALAR(CAST('[{"b": "c"}, {"b": "cc"}]' AS JSON), '$.z');
SELECT JSON_EXTRACT_SCALAR(CAST('{"a": "c", "b": null}' AS JSON), '$.b');
SELECT JSON_EXTRACT_SCALAR(CAST('"foo"' AS JSON), '$[1]');
SELECT JSON_EXTRACT_SCALAR(CAST('"foo"' AS JSON), '$.z');
/* array length */ SELECT JSON_ARRAY_LENGTH('[1,2,3,{"f1":1,"f2":[5,6]},4]');
SELECT JSON_ARRAY_LENGTH('[]');
SELECT JSON_ARRAY_LENGTH('{"f1":1,"f2":[5,6]}');
SELECT JSON_ARRAY_LENGTH('4');
/* each */ SELECT JSON_EACH('{"f1":[1,2,3],"f2":{"f3":1},"f4":null}');
SELECT * FROM x AS x;
SELECT JSON_EACH_TEXT('{"f1":[1,2,3],"f2":{"f3":1},"f4":null,"f5":"null"}');
SELECT * FROM x AS x;
/* extract_path, extract_path_as_text */ SELECT JSON_EXTRACT('{"f2":{"f3":1},"f4":{"f5":99,"f6":"stringy"}}', '$.f4.f6');
SELECT JSON_EXTRACT('{"f2":{"f3":1},"f4":{"f5":99,"f6":"stringy"}}', '$.f2');
SELECT JSON_EXTRACT('{"f2":["f3",1],"f4":{"f5":99,"f6":"stringy"}}', 'f2', CAST(0 AS TEXT));
SELECT JSON_EXTRACT('{"f2":["f3",1],"f4":{"f5":99,"f6":"stringy"}}', 'f2', CAST(1 AS TEXT));
SELECT JSON_EXTRACT_SCALAR('{"f2":{"f3":1},"f4":{"f5":99,"f6":"stringy"}}', '$.f4.f6');
SELECT JSON_EXTRACT_SCALAR('{"f2":{"f3":1},"f4":{"f5":99,"f6":"stringy"}}', '$.f2');
SELECT JSON_EXTRACT_SCALAR('{"f2":["f3",1],"f4":{"f5":99,"f6":"stringy"}}', 'f2', CAST(0 AS TEXT));
SELECT JSON_EXTRACT_SCALAR('{"f2":["f3",1],"f4":{"f5":99,"f6":"stringy"}}', 'f2', CAST(1 AS TEXT));
/* extract_path nulls */ SELECT JSON_EXTRACT('{"f2":{"f3":1},"f4":{"f5":null,"f6":"stringy"}}', '$.f4.f5') IS NULL AS x;
SELECT JSON_EXTRACT_SCALAR('{"f2":{"f3":1},"f4":{"f5":null,"f6":"stringy"}}', '$.f4.f5') IS NULL AS x;
SELECT JSON_EXTRACT('{"f2":{"f3":1},"f4":[0,1,2,null]}', '$.f4[3]') IS NULL AS x;
SELECT JSON_EXTRACT_SCALAR('{"f2":{"f3":1},"f4":[0,1,2,null]}', '$.f4[3]') IS NULL AS x;
/* extract_path operators */ SELECT JSONB_EXTRACT(CAST('{"f2":{"f3":1},"f4":{"f5":99,"f6":"stringy"}}' AS JSON), x)['f4', 'f6'];
SELECT JSONB_EXTRACT(CAST('{"f2":{"f3":1},"f4":{"f5":99,"f6":"stringy"}}' AS JSON), x)['f2'];
SELECT JSONB_EXTRACT(CAST('{"f2":["f3",1],"f4":{"f5":99,"f6":"stringy"}}' AS JSON), x)['f2', '0'];
SELECT JSONB_EXTRACT(CAST('{"f2":["f3",1],"f4":{"f5":99,"f6":"stringy"}}' AS JSON), x)['f2', '1'];
SELECT JSONB_EXTRACT_SCALAR(CAST('{"f2":{"f3":1},"f4":{"f5":99,"f6":"stringy"}}' AS JSON), x)['f4', 'f6'];
SELECT JSONB_EXTRACT_SCALAR(CAST('{"f2":{"f3":1},"f4":{"f5":99,"f6":"stringy"}}' AS JSON), x)['f2'];
SELECT JSONB_EXTRACT_SCALAR(CAST('{"f2":["f3",1],"f4":{"f5":99,"f6":"stringy"}}' AS JSON), x)['f2', '0'];
SELECT JSONB_EXTRACT_SCALAR(CAST('{"f2":["f3",1],"f4":{"f5":99,"f6":"stringy"}}' AS JSON), x)['f2', '1'];
/* corner cases for same */ SELECT JSONB_EXTRACT(CAST('{"a": {"b":{"c": "foo"}}}' AS JSON), '{}');
SELECT JSONB_EXTRACT(CAST('[1,2,3]' AS JSON), '{}');
SELECT JSONB_EXTRACT(CAST('"foo"' AS JSON), '{}');
SELECT JSONB_EXTRACT(CAST('42' AS JSON), '{}');
SELECT JSONB_EXTRACT(CAST('null' AS JSON), '{}');
SELECT JSONB_EXTRACT(CAST('{"a": {"b":{"c": "foo"}}}' AS JSON), x)['a'];
SELECT JSONB_EXTRACT(CAST('{"a": {"b":{"c": "foo"}}}' AS JSON), x)['a', NULL];
SELECT JSONB_EXTRACT(CAST('{"a": {"b":{"c": "foo"}}}' AS JSON), x)['a', ''];
SELECT JSONB_EXTRACT(CAST('{"a": {"b":{"c": "foo"}}}' AS JSON), x)['a', 'b'];
SELECT JSONB_EXTRACT(CAST('{"a": {"b":{"c": "foo"}}}' AS JSON), x)['a', 'b', 'c'];
SELECT JSONB_EXTRACT(CAST('{"a": {"b":{"c": "foo"}}}' AS JSON), x)['a', 'b', 'c', 'd'];
SELECT JSONB_EXTRACT(CAST('{"a": {"b":{"c": "foo"}}}' AS JSON), x)['a', 'z', 'c'];
SELECT JSONB_EXTRACT(CAST('{"a": [{"b": "c"}, {"b": "cc"}]}' AS JSON), x)['a', '1', 'b'];
SELECT JSONB_EXTRACT(CAST('{"a": [{"b": "c"}, {"b": "cc"}]}' AS JSON), x)['a', 'z', 'b'];
SELECT JSONB_EXTRACT(CAST('[{"b": "c"}, {"b": "cc"}]' AS JSON), x)['1', 'b'];
SELECT JSONB_EXTRACT(CAST('[{"b": "c"}, {"b": "cc"}]' AS JSON), x)['z', 'b'];
SELECT JSONB_EXTRACT(CAST('[{"b": "c"}, {"b": null}]' AS JSON), x)['1', 'b'];
SELECT JSONB_EXTRACT(CAST('"foo"' AS JSON), x)['z'];
SELECT JSONB_EXTRACT(CAST('42' AS JSON), x)['f2'];
SELECT JSONB_EXTRACT(CAST('42' AS JSON), x)['0'];
SELECT JSONB_EXTRACT_SCALAR(CAST('{"a": {"b":{"c": "foo"}}}' AS JSON), '{}');
SELECT JSONB_EXTRACT_SCALAR(CAST('[1,2,3]' AS JSON), '{}');
SELECT JSONB_EXTRACT_SCALAR(CAST('"foo"' AS JSON), '{}');
SELECT JSONB_EXTRACT_SCALAR(CAST('42' AS JSON), '{}');
SELECT JSONB_EXTRACT_SCALAR(CAST('null' AS JSON), '{}');
SELECT JSONB_EXTRACT_SCALAR(CAST('{"a": {"b":{"c": "foo"}}}' AS JSON), x)['a'];
SELECT JSONB_EXTRACT_SCALAR(CAST('{"a": {"b":{"c": "foo"}}}' AS JSON), x)['a', NULL];
SELECT JSONB_EXTRACT_SCALAR(CAST('{"a": {"b":{"c": "foo"}}}' AS JSON), x)['a', ''];
SELECT JSONB_EXTRACT_SCALAR(CAST('{"a": {"b":{"c": "foo"}}}' AS JSON), x)['a', 'b'];
SELECT JSONB_EXTRACT_SCALAR(CAST('{"a": {"b":{"c": "foo"}}}' AS JSON), x)['a', 'b', 'c'];
SELECT JSONB_EXTRACT_SCALAR(CAST('{"a": {"b":{"c": "foo"}}}' AS JSON), x)['a', 'b', 'c', 'd'];
SELECT JSONB_EXTRACT_SCALAR(CAST('{"a": {"b":{"c": "foo"}}}' AS JSON), x)['a', 'z', 'c'];
SELECT JSONB_EXTRACT_SCALAR(CAST('{"a": [{"b": "c"}, {"b": "cc"}]}' AS JSON), x)['a', '1', 'b'];
SELECT JSONB_EXTRACT_SCALAR(CAST('{"a": [{"b": "c"}, {"b": "cc"}]}' AS JSON), x)['a', 'z', 'b'];
SELECT JSONB_EXTRACT_SCALAR(CAST('[{"b": "c"}, {"b": "cc"}]' AS JSON), x)['1', 'b'];
SELECT JSONB_EXTRACT_SCALAR(CAST('[{"b": "c"}, {"b": "cc"}]' AS JSON), x)['z', 'b'];
SELECT JSONB_EXTRACT_SCALAR(CAST('[{"b": "c"}, {"b": null}]' AS JSON), x)['1', 'b'];
SELECT JSONB_EXTRACT_SCALAR(CAST('"foo"' AS JSON), x)['z'];
SELECT JSONB_EXTRACT_SCALAR(CAST('42' AS JSON), x)['f2'];
SELECT JSONB_EXTRACT_SCALAR(CAST('42' AS JSON), x)['0'];
/* array_elements */ SELECT JSON_ARRAY_ELEMENTS('[1,true,[1,[2,3]],null,{"f1":1,"f2":[7,8,9]},false,"stringy"]');
SELECT * FROM x AS x;
SELECT JSON_ARRAY_ELEMENTS_TEXT('[1,true,[1,[2,3]],null,{"f1":1,"f2":[7,8,9]},false,"stringy"]');
SELECT * FROM x AS x;
/* populate_record */ create type jpop as (a text, b int, c timestamp);
CREATE DOMAIN js_int_not_null  AS int     NOT NULL;
CREATE DOMAIN js_int_array_1d  AS int[]   CHECK(array_length(VALUE, 1) = 3);
CREATE DOMAIN js_int_array_2d  AS int[][] CHECK(array_length(VALUE, 2) = 3);
create type j_unordered_pair as (x int, y int);
create domain j_ordered_pair as j_unordered_pair check((value).x <= (value).y);
CREATE TYPE jsrec AS ( 	i	int, 	ia	_int4, 	ia1	int[], 	ia2	int[][], 	ia3	int[][][], 	ia1d	js_int_array_1d, 	ia2d	js_int_array_2d, 	t	text, 	ta	text[], 	c	char(10), 	ca	char(10)[], 	ts	timestamp, 	js	json, 	jsb	jsonb, 	jsa	json[], 	rec	jpop, 	reca	jpop[] );
CREATE TYPE jsrec_i_not_null AS ( 	i	js_int_not_null );
SELECT * FROM x AS x;
SELECT * FROM x AS x;
SELECT * FROM x AS x;
SELECT * FROM x AS x;
SELECT * FROM x AS x;
SELECT * FROM x AS x;
SELECT * FROM x AS x;
SELECT * FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
/* anonymous record type */ SELECT JSON_POPULATE_RECORD(CAST(NULL AS record), '{"x": 0, "y": 1}');
SELECT JSON_POPULATE_RECORD(ROW(1, 2), '{"f1": 0, "f2": 1}');
SELECT * FROM x AS _t0;
/* composite domain */ SELECT JSON_POPULATE_RECORD(CAST(NULL AS j_ordered_pair), '{"x": 0, "y": 1}');
SELECT JSON_POPULATE_RECORD(CAST(ROW(1, 2) AS j_ordered_pair), '{"x": 0}');
SELECT JSON_POPULATE_RECORD(CAST(ROW(1, 2) AS j_ordered_pair), '{"x": 1, "y": 0}');
/* populate_recordset */ SELECT * FROM x AS x;
SELECT * FROM x AS x;
SELECT * FROM x AS x;
SELECT * FROM x AS x;
SELECT * FROM x AS x;
SELECT * FROM x AS x;
create type jpop2 as (a int, b json, c int, d int);
SELECT * FROM x AS x;
SELECT * FROM x AS x;
SELECT * FROM x AS x;
SELECT * FROM x AS x;
/* anonymous record type */ SELECT JSON_POPULATE_RECORDSET(CAST(NULL AS record), '[{"x": 0, "y": 1}]');
SELECT JSON_POPULATE_RECORDSET(ROW(1, 2), '[{"f1": 0, "f2": 1}]');
SELECT x, JSON_POPULATE_RECORDSET(ROW(x, 50), '[{"f1":"42"},{"f2":"43"}]') FROM (VALUES (1), (2)) AS x;
SELECT * FROM x AS _t0;
/* empty array is a corner case */ SELECT JSON_POPULATE_RECORDSET(CAST(NULL AS record), '[]');
SELECT JSON_POPULATE_RECORDSET(ROW(1, 2), '[]');
SELECT * FROM x AS x;
SELECT * FROM x AS _t0;
/* composite domain */ SELECT JSON_POPULATE_RECORDSET(CAST(NULL AS j_ordered_pair), '[{"x": 0, "y": 1}]');
SELECT JSON_POPULATE_RECORDSET(CAST(ROW(1, 2) AS j_ordered_pair), '[{"x": 0}, {"y": 3}]');
SELECT JSON_POPULATE_RECORDSET(CAST(ROW(1, 2) AS j_ordered_pair), '[{"x": 1, "y": 0}]');
/* negative cases where the wrong record type is supplied */ SELECT * FROM x AS x;
SELECT * FROM x AS x;
SELECT * FROM x AS x;
SELECT * FROM x AS x;
/* test type info caching in json_populate_record() */ CREATE TEMPORARY TABLE x (x JSON);
INSERT INTO x SELECT CAST('{ 	"jsa": [1, "2", null, 4], 	"rec": {"a": "abc", "c": "01.02.2003", "x": 43.2}, 	"reca": [{"a": "abc", "b": 456}, null, {"c": "01.02.2003", "x": 43.2}] }' AS JSON) FROM x;
SELECT (JSON_POPULATE_RECORD(CAST(NULL AS jsrec), x)).* FROM x;
DROP TYPE jsrec;
DROP TYPE jsrec_i_not_null;
DROP DOMAIN js_int_not_null;
DROP DOMAIN js_int_array_1d;
DROP DOMAIN js_int_array_2d;
DROP DOMAIN j_ordered_pair;
DROP TYPE j_unordered_pair;
/* json_typeof() function */ SELECT x, JSON_TYPEOF(x) FROM (VALUES (PARSE_JSON('123.4')), (PARSE_JSON('-1')), (PARSE_JSON('"foo"')), (PARSE_JSON('true')), (PARSE_JSON('false')), (PARSE_JSON('null')), (PARSE_JSON('[1, 2, 3]')), (PARSE_JSON('[]')), (PARSE_JSON('{"x":"foo", "y":123}')), (PARSE_JSON('{}')), (CAST(NULL AS JSON))) AS x;
/* json_build_array, json_build_object, json_object_agg */ SELECT JSON_BUILD_ARRAY('a', 1, 'b', 1.2, 'c', TRUE, 'd', NULL, 'e', PARSE_JSON('{"x": 3, "y": [1,2,3]}'));
SELECT JSON_BUILD_ARRAY('a', NULL);
/* ok */ SELECT JSON_BUILD_OBJECT('a', 1, 'b', 1.2, 'c', TRUE, 'd', NULL, 'e', PARSE_JSON('{"x": 3, "y": [1,2,3]}'));
SELECT JSON_BUILD_OBJECT('a', JSON_BUILD_OBJECT('b', FALSE, 'c', 99), 'd', JSON_BUILD_OBJECT('e', CAST(ARRAY(9, 8, 7) AS ARRAY<INT>), 'f', (SELECT ROW_TO_JSON(x) FROM (SELECT x, CAST(x AS REGCLASS) AS x FROM x WHERE x = 'pg_class') AS x)));
SELECT JSON_BUILD_OBJECT(CAST('{a,b,c}' AS ARRAY<TEXT>));
/* error */ SELECT JSON_BUILD_OBJECT(CAST('{a,b,c}' AS ARRAY<TEXT>), CAST('{d,e,f}' AS ARRAY<TEXT>));
/* error, key cannot be array */ SELECT JSON_BUILD_OBJECT('a', 'b', 'c');
/* error */ SELECT JSON_BUILD_OBJECT(NULL, 'a');
/* error, key cannot be NULL */ SELECT JSON_BUILD_OBJECT('a', NULL);
/* ok */ /* empty objects/arrays */ SELECT JSON_BUILD_ARRAY();
SELECT JSON_BUILD_OBJECT();
/* make sure keys are quoted */ SELECT JSON_BUILD_OBJECT(1, 2);
/* keys must be scalar and not null */ SELECT JSON_BUILD_OBJECT(NULL, 2);
SELECT JSON_BUILD_OBJECT(x, 2) FROM (SELECT 1 AS x, 2 AS x) AS x;
SELECT JSON_BUILD_OBJECT(PARSE_JSON('{"a":1,"b":2}'), 3);
SELECT JSON_BUILD_OBJECT(CAST('{1,2,3}' AS ARRAY<INT>), 3);
CREATE TEMPORARY TABLE x (x INT, x TEXT, x TEXT);
INSERT INTO x VALUES (847001, 't15', 'GE1043');
INSERT INTO x VALUES (847002, 't16', 'GE1043');
INSERT INTO x VALUES (847003, 'sub-alpha', 'GESS90');
SELECT JSON_BUILD_OBJECT('turbines', JSON_OBJECTAGG(x, JSON_BUILD_OBJECT('name', x, 'type', x))) FROM x;
SELECT JSON_OBJECTAGG(x, x) FROM x;
INSERT INTO x VALUES (999999, NULL, 'bar');
SELECT JSON_OBJECTAGG(x, x) FROM x;
/* empty object, two dimensions */ SELECT JSON_OBJECT('{}': '{}');
/* two argument form of json_object */ SELECT JSON_OBJECT('{a,b,c,"d e f"}': '{1,2,3,"a b c"}');
/* too many dimensions */ SELECT JSON_OBJECT('{{a,1},{b,2},{3,NULL},{"d e f","a b c"}}': '{{a,1},{b,2},{3,NULL},{"d e f","a b c"}}');
/* mismatched dimensions */ SELECT JSON_OBJECT('{a,b,c,"d e f",g}': '{1,2,3,"a b c"}');
SELECT JSON_OBJECT('{a,b,c,"d e f"}': '{1,2,3,"a b c",g}');
/* null key error */ SELECT JSON_OBJECT('{a,b,NULL,"d e f"}': '{1,2,3,"a b c"}');
/* empty key is allowed */ SELECT JSON_OBJECT('{a,b,"","d e f"}': '{1,2,3,"a b c"}');
/* json_object_agg_unique requires unique keys */ SELECT JSON_OBJECT_AGG_UNIQUE(x % 100, x) FROM x AS x;
/* json_to_record and json_to_recordset */ SELECT * FROM x AS x;
SELECT * FROM x AS x;
SELECT * FROM x AS x;
SELECT *, x IS NULL AS x FROM x AS x;
SELECT *, x IS NULL AS x FROM x AS x;
SELECT * FROM x AS x;
SELECT * FROM x AS x;
SELECT * FROM x AS x;
SELECT * FROM x AS x;
SELECT * FROM x AS x;
SELECT * FROM x AS x;
SELECT * FROM x AS x;
SELECT * FROM x AS x;
SELECT * FROM x AS x;
SELECT * FROM x AS x;
SELECT * FROM x AS x;
SELECT * FROM x AS x;
SELECT * FROM x AS x;
SELECT * FROM x AS x;
SELECT * FROM x AS x;
/* json_strip_nulls */ SELECT JSON_STRIP_NULLS(NULL);
SELECT JSON_STRIP_NULLS('1');
SELECT JSON_STRIP_NULLS('"a string"');
SELECT JSON_STRIP_NULLS('null');
SELECT JSON_STRIP_NULLS('[1,2,null,3,4]');
SELECT JSON_STRIP_NULLS('{"a":1,"b":null,"c":[2,null,3],"d":{"e":4,"f":null}}');
SELECT JSON_STRIP_NULLS('[1,{"a":1,"b":null,"c":2},3]');
/* an empty object is not null and should not be stripped */ SELECT JSON_STRIP_NULLS('{"a": {"b": null, "c": null}, "d": {} }');
/* json_strip_nulls (strip_in_arrays=true) */ SELECT JSON_STRIP_NULLS(NULL, TRUE);
SELECT JSON_STRIP_NULLS('1', TRUE);
SELECT JSON_STRIP_NULLS('"a string"', TRUE);
SELECT JSON_STRIP_NULLS('null', TRUE);
SELECT JSON_STRIP_NULLS('[1,2,null,3,4]', TRUE);
SELECT JSON_STRIP_NULLS('{"a":1,"b":null,"c":[2,null,3],"d":{"e":4,"f":null}}', TRUE);
SELECT JSON_STRIP_NULLS('[1,{"a":1,"b":null,"c":2},3]', TRUE);
/* an empty object is not null and should not be stripped */ SELECT JSON_STRIP_NULLS('{"a": {"b": null, "c": null}, "d": {} }', TRUE);
/* json to tsvector */ SELECT TO_TSVECTOR(CAST('{"a": "aaa bbb ddd ccc", "b": ["eee fff ggg"], "c": {"d": "hhh iii"}}' AS JSON));
/* json to tsvector with config */ SELECT TO_TSVECTOR('simple', CAST('{"a": "aaa bbb ddd ccc", "b": ["eee fff ggg"], "c": {"d": "hhh iii"}}' AS JSON));
/* json to tsvector with stop words */ SELECT TO_TSVECTOR('english', CAST('{"a": "aaa in bbb ddd ccc", "b": ["the eee fff ggg"], "c": {"d": "hhh. iii"}}' AS JSON));
/* json to tsvector with numeric values */ SELECT TO_TSVECTOR('english', CAST('{"a": "aaa in bbb ddd ccc", "b": 123, "c": 456}' AS JSON));
/* json_to_tsvector */ SELECT JSON_TO_TSVECTOR('english', CAST('{"a": "aaa in bbb", "b": 123, "c": 456, "d": true, "f": false, "g": null}' AS JSON), '"all"');
SELECT JSON_TO_TSVECTOR('english', CAST('{"a": "aaa in bbb", "b": 123, "c": 456, "d": true, "f": false, "g": null}' AS JSON), '"key"');
SELECT JSON_TO_TSVECTOR('english', CAST('{"a": "aaa in bbb", "b": 123, "c": 456, "d": true, "f": false, "g": null}' AS JSON), '"string"');
SELECT JSON_TO_TSVECTOR('english', CAST('{"a": "aaa in bbb", "b": 123, "c": 456, "d": true, "f": false, "g": null}' AS JSON), '"numeric"');
SELECT JSON_TO_TSVECTOR('english', CAST('{"a": "aaa in bbb", "b": 123, "c": 456, "d": true, "f": false, "g": null}' AS JSON), '"boolean"');
SELECT JSON_TO_TSVECTOR('english', CAST('{"a": "aaa in bbb", "b": 123, "c": 456, "d": true, "f": false, "g": null}' AS JSON), '["string", "numeric"]');
SELECT JSON_TO_TSVECTOR('english', CAST('{"a": "aaa in bbb", "b": 123, "c": 456, "d": true, "f": false, "g": null}' AS JSON), '"all"');
SELECT JSON_TO_TSVECTOR('english', CAST('{"a": "aaa in bbb", "b": 123, "c": 456, "d": true, "f": false, "g": null}' AS JSON), '"key"');
SELECT JSON_TO_TSVECTOR('english', CAST('{"a": "aaa in bbb", "b": 123, "c": 456, "d": true, "f": false, "g": null}' AS JSON), '"string"');
SELECT JSON_TO_TSVECTOR('english', CAST('{"a": "aaa in bbb", "b": 123, "c": 456, "d": true, "f": false, "g": null}' AS JSON), '"numeric"');
SELECT JSON_TO_TSVECTOR('english', CAST('{"a": "aaa in bbb", "b": 123, "c": 456, "d": true, "f": false, "g": null}' AS JSON), '"boolean"');
SELECT JSON_TO_TSVECTOR('english', CAST('{"a": "aaa in bbb", "b": 123, "c": 456, "d": true, "f": false, "g": null}' AS JSON), '["string", "numeric"]');
/* to_tsvector corner cases */ SELECT TO_TSVECTOR(CAST('""' AS JSON));
SELECT TO_TSVECTOR(CAST('{}' AS JSON));
SELECT TO_TSVECTOR(CAST('[]' AS JSON));
SELECT TO_TSVECTOR(CAST('null' AS JSON));
/* json_to_tsvector corner cases */ SELECT JSON_TO_TSVECTOR(CAST('""' AS JSON), '"all"');
SELECT JSON_TO_TSVECTOR(CAST('{}' AS JSON), '"all"');
SELECT JSON_TO_TSVECTOR(CAST('[]' AS JSON), '"all"');
SELECT JSON_TO_TSVECTOR(CAST('null' AS JSON), '"all"');
SELECT JSON_TO_TSVECTOR('english', CAST('{"a": "aaa in bbb", "b": 123, "c": 456, "d": true, "f": false, "g": null}' AS JSON), '""');
SELECT JSON_TO_TSVECTOR('english', CAST('{"a": "aaa in bbb", "b": 123, "c": 456, "d": true, "f": false, "g": null}' AS JSON), '{}');
SELECT JSON_TO_TSVECTOR('english', CAST('{"a": "aaa in bbb", "b": 123, "c": 456, "d": true, "f": false, "g": null}' AS JSON), '[]');
SELECT JSON_TO_TSVECTOR('english', CAST('{"a": "aaa in bbb", "b": 123, "c": 456, "d": true, "f": false, "g": null}' AS JSON), 'null');
SELECT JSON_TO_TSVECTOR('english', CAST('{"a": "aaa in bbb", "b": 123, "c": 456, "d": true, "f": false, "g": null}' AS JSON), '["all", null]');
/* ts_headline for json */ SELECT TS_HEADLINE(CAST('{"a": "aaa bbb", "b": {"c": "ccc ddd fff", "c1": "ccc1 ddd1"}, "d": ["ggg hhh", "iii jjj"]}' AS JSON), TSQUERY('bbb & ddd & hhh'));
SELECT TS_HEADLINE('english', CAST('{"a": "aaa bbb", "b": {"c": "ccc ddd fff"}, "d": ["ggg hhh", "iii jjj"]}' AS JSON), TSQUERY('bbb & ddd & hhh'));
SELECT TS_HEADLINE(CAST('{"a": "aaa bbb", "b": {"c": "ccc ddd fff", "c1": "ccc1 ddd1"}, "d": ["ggg hhh", "iii jjj"]}' AS JSON), TSQUERY('bbb & ddd & hhh'), 'StartSel = <, StopSel = >');
SELECT TS_HEADLINE('english', CAST('{"a": "aaa bbb", "b": {"c": "ccc ddd fff", "c1": "ccc1 ddd1"}, "d": ["ggg hhh", "iii jjj"]}' AS JSON), TSQUERY('bbb & ddd & hhh'), 'StartSel = <, StopSel = >');
/* corner cases for ts_headline with json */ SELECT TS_HEADLINE(CAST('null' AS JSON), TSQUERY('aaa & bbb'));
SELECT TS_HEADLINE(CAST('{}' AS JSON), TSQUERY('aaa & bbb'));
SELECT TS_HEADLINE(CAST('[]' AS JSON), TSQUERY('aaa & bbb'));
/* Strings. */ SELECT CAST('""' AS JSONB);
/* OK. */ SELECT CAST('''''' AS JSONB);
/* ERROR, single quotes are not allowed */ SELECT CAST('"abc"' AS JSONB);
/* OK */ SELECT CAST('"abc' AS JSONB);
/* ERROR, quotes not closed */ SELECT CAST('"abc def"' AS JSONB);
/* ERROR, unescaped newline in string constant */ SELECT CAST('"\n\"\\"' AS JSONB);
/* OK, legal escapes */ SELECT CAST('"\v"' AS JSONB);
/* ERROR, not a valid JSON escape */ /* see json_encoding test for input with unicode escapes */ /* Numbers. */ SELECT CAST('1' AS JSONB);
/* OK */ SELECT CAST('0' AS JSONB);
/* OK */ SELECT CAST('01' AS JSONB);
/* ERROR, not valid according to JSON spec */ SELECT CAST('0.1' AS JSONB);
/* OK */ SELECT CAST('9223372036854775808' AS JSONB);
/* OK, even though it's too large for int8 */ SELECT CAST('1e100' AS JSONB);
/* OK */ SELECT CAST('1.3e100' AS JSONB);
/* OK */ SELECT CAST('1f2' AS JSONB);
/* ERROR */ SELECT CAST('0.x1' AS JSONB);
/* ERROR */ SELECT CAST('1.3ex100' AS JSONB);
/* ERROR */ /* Arrays. */ SELECT CAST('[]' AS JSONB);
/* OK */ SELECT CAST('[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]' AS JSONB);
/* OK */ SELECT CAST('[1,2]' AS JSONB);
/* OK */ SELECT CAST('[1,2,]' AS JSONB);
/* ERROR, trailing comma */ SELECT CAST('[1,2' AS JSONB);
/* ERROR, no closing bracket */ SELECT CAST('[1,[2]' AS JSONB);
/* ERROR, no closing bracket */ /* Objects. */ SELECT CAST('{}' AS JSONB);
/* OK */ SELECT CAST('{"abc"}' AS JSONB);
/* ERROR, no value */ SELECT CAST('{"abc":1}' AS JSONB);
/* OK */ SELECT CAST('{1:"abc"}' AS JSONB);
/* ERROR, keys must be strings */ SELECT CAST('{"abc",1}' AS JSONB);
/* ERROR, wrong separator */ SELECT CAST('{"abc"=1}' AS JSONB);
/* ERROR, totally wrong separator */ SELECT CAST('{"abc"::1}' AS JSONB);
/* ERROR, another wrong separator */ SELECT CAST('{"abc":1,"def":2,"ghi":[3,4],"hij":{"klm":5,"nop":[6]}}' AS JSONB);
/* OK */ SELECT CAST('{"abc":1:2}' AS JSONB);
/* ERROR, colon in wrong spot */ SELECT CAST('{"abc":1,3}' AS JSONB);
SET x = '100kB' /* ERROR, no value */ /* Recursion. */;
SELECT CAST(REPEAT('[', 10000) AS JSONB);
SELECT CAST(REPEAT('{"a":', 10000) AS JSONB);
RESET max_stack_depth;
/* Miscellaneous stuff. */ SELECT CAST('true' AS JSONB);
/* OK */ SELECT CAST('false' AS JSONB);
/* OK */ SELECT CAST('null' AS JSONB);
/* OK */ SELECT CAST(' true ' AS JSONB);
/* OK, even with extra whitespace */ SELECT CAST('true false' AS JSONB);
/* ERROR, too many values */ SELECT CAST('true, false' AS JSONB);
/* ERROR, too many values */ SELECT CAST('truf' AS JSONB);
/* ERROR, not a keyword */ SELECT CAST('trues' AS JSONB);
/* ERROR, not a keyword */ SELECT CAST('' AS JSONB);
/* ERROR, no value */ SELECT CAST('    ' AS JSONB);
/* ERROR, no value */ /* Multi-line JSON input to check ERROR reporting */ SELECT CAST('{ 		"one": 1, 		"two":"two", 		"three": 		true}' AS JSONB);
/* OK */ SELECT CAST('{ 		"one": 1, 		"two":,"two",  -- ERROR extraneous comma before field "two" 		"three": 		true}' AS JSONB);
SELECT CAST('{ 		"one": 1, 		"two":"two", 		"averyveryveryveryveryveryveryveryveryverylongfieldname":}' AS JSONB);
/* ERROR missing value for last field */ /* test non-error-throwing input */ SELECT PG_INPUT_IS_VALID('{"a":true}', 'jsonb');
SELECT PG_INPUT_IS_VALID('{"a":true', 'jsonb');
SELECT * FROM x;
SELECT * FROM x;
/* make sure jsonb is passed through json generators without being escaped */ SELECT ARRAY_TO_JSON(ARRAY(CAST('{"a":1}' AS JSONB), CAST('{"b":[2,3]}' AS JSONB)));
/* anyarray column */ CREATE TEMPORARY TABLE x AS SELECT x, 'txt' || x AS x FROM x AS x;
ANALYZE x;
SELECT x, TO_JSONB(x) AS x FROM x WHERE x = 'rows' AND x = CAST(CAST(PG_MY_TEMP_SCHEMA() AS REGNAMESPACE) AS TEXT) ORDER BY 1 NULLS LAST;
/* to_jsonb, timestamps */ SELECT TO_JSONB(CAST('2014-05-28 12:22:35.614298' AS TIMESTAMP));
BEGIN;
SET LOCAL TIME ZONE 10.5;
SELECT TO_JSONB(CAST('2014-05-28 12:22:35.614298-04' AS TIMESTAMPTZ));
SET LOCAL TIME ZONE -8;
SELECT TO_JSONB(CAST('2014-05-28 12:22:35.614298-04' AS TIMESTAMPTZ));
COMMIT;
SELECT TO_JSONB(CAST('2014-05-28' AS DATE));
SELECT TO_JSONB(CAST('Infinity' AS DATE));
SELECT TO_JSONB(CAST('-Infinity' AS DATE));
SELECT TO_JSONB(CAST('Infinity' AS TIMESTAMP));
SELECT TO_JSONB(CAST('-Infinity' AS TIMESTAMP));
SELECT TO_JSONB(CAST('Infinity' AS TIMESTAMPTZ));
SELECT TO_JSONB(CAST('-Infinity' AS TIMESTAMPTZ));
/* jsonb_agg */ SELECT JSONB_AGG(x) FROM (SELECT 'a' || x AS x, x AS x, ARRAY(ROW(x.*, ARRAY(1, 2, 3)), ROW(x.*, ARRAY(4, 5, 6))) AS x FROM x AS x, x AS x) AS x;
SELECT JSONB_AGG(x ORDER BY x NULLS LAST, x NULLS LAST) FROM x AS x;
UPDATE x SET x = NULL WHERE x = 1;
SELECT JSONB_AGG(x ORDER BY x, x NULLS LAST) FROM x AS x;
/* jsonb extraction functions */ CREATE TEMPORARY TABLE x (x TEXT, x JSONB);
INSERT INTO x VALUES ('scalar', '"a scalar"'), ('array', '["zero", "one","two",null,"four","five", [1,2,3],{"f1":9}]'), ('object', '{"field1":"val1","field2":"val2","field3":null, "field4": 4, "field5": [1,2,3], "field6": {"f1":9}}');
SELECT JSON_EXTRACT(x, '$.x') FROM x WHERE x = 'scalar';
SELECT JSON_EXTRACT(x, '$.x') FROM x WHERE x = 'array';
SELECT JSON_EXTRACT(x, '$.x') FROM x WHERE x = 'object';
SELECT JSON_EXTRACT(x, '$.field2') FROM x WHERE x = 'object';
SELECT JSON_EXTRACT_SCALAR(x, '$.field2') FROM x WHERE x = 'scalar';
SELECT JSON_EXTRACT_SCALAR(x, '$.field2') FROM x WHERE x = 'array';
SELECT JSON_EXTRACT_SCALAR(x, '$.field2') FROM x WHERE x = 'object';
SELECT JSON_EXTRACT(x, '$[2]') FROM x WHERE x = 'scalar';
SELECT JSON_EXTRACT(x, '$[2]') FROM x WHERE x = 'array';
SELECT JSON_EXTRACT(x, '$[9]') FROM x WHERE x = 'array';
SELECT JSON_EXTRACT(x, '$[2]') FROM x WHERE x = 'object';
SELECT JSON_EXTRACT_SCALAR(x, '$[6]') FROM x WHERE x = 'array';
SELECT JSON_EXTRACT_SCALAR(x, '$[7]') FROM x WHERE x = 'array';
SELECT JSON_EXTRACT_SCALAR(x, '$.field4') FROM x WHERE x = 'object';
SELECT JSON_EXTRACT_SCALAR(x, '$.field5') FROM x WHERE x = 'object';
SELECT JSON_EXTRACT_SCALAR(x, '$.field6') FROM x WHERE x = 'object';
SELECT JSON_EXTRACT_SCALAR(x, '$[2]') FROM x WHERE x = 'scalar';
SELECT JSON_EXTRACT_SCALAR(x, '$[2]') FROM x WHERE x = 'array';
SELECT JSON_EXTRACT_SCALAR(x, '$[2]') FROM x WHERE x = 'object';
SELECT JSONB_OBJECT_KEYS(x) FROM x WHERE x = 'scalar';
SELECT JSONB_OBJECT_KEYS(x) FROM x WHERE x = 'array';
SELECT JSONB_OBJECT_KEYS(x) FROM x WHERE x = 'object';
/* nulls */ SELECT (JSON_EXTRACT(x, '$.field3')) IS NULL AS x FROM x WHERE x = 'object';
SELECT (JSON_EXTRACT_SCALAR(x, '$.field3')) IS NULL AS x FROM x WHERE x = 'object';
SELECT (JSON_EXTRACT(x, '$[3]')) IS NULL AS x FROM x WHERE x = 'array';
SELECT (JSON_EXTRACT_SCALAR(x, '$[3]')) IS NULL AS x FROM x WHERE x = 'array';
/* corner cases */ SELECT CAST(JSON_EXTRACT(CAST('{"a": [{"b": "c"}, {"b": "cc"}]}' AS JSONB), NULL) AS TEXT);
SELECT CAST(JSON_EXTRACT(CAST('{"a": [{"b": "c"}, {"b": "cc"}]}' AS JSONB), NULL) AS INT);
SELECT JSON_EXTRACT(CAST('{"a": [{"b": "c"}, {"b": "cc"}]}' AS JSONB), '$[1]');
SELECT JSON_EXTRACT(CAST('{"a": [{"b": "c"}, {"b": "cc"}]}' AS JSONB), '$.z');
SELECT JSON_EXTRACT(CAST('{"a": [{"b": "c"}, {"b": "cc"}]}' AS JSONB), '$[""]');
SELECT JSON_EXTRACT(CAST('[{"b": "c"}, {"b": "cc"}]' AS JSONB), '$[1]');
SELECT JSON_EXTRACT(CAST('[{"b": "c"}, {"b": "cc"}]' AS JSONB), '$[3]');
SELECT JSON_EXTRACT(CAST('[{"b": "c"}, {"b": "cc"}]' AS JSONB), '$.z');
SELECT JSON_EXTRACT(CAST('{"a": "c", "b": null}' AS JSONB), '$.b');
SELECT JSON_EXTRACT(CAST('"foo"' AS JSONB), '$[1]');
SELECT JSON_EXTRACT(CAST('"foo"' AS JSONB), '$.z');
SELECT JSON_EXTRACT(CAST('[]' AS JSONB)) - 2147483648;
SELECT CAST(JSON_EXTRACT_SCALAR(CAST('{"a": [{"b": "c"}, {"b": "cc"}]}' AS JSONB), NULL) AS TEXT);
SELECT CAST(JSON_EXTRACT_SCALAR(CAST('{"a": [{"b": "c"}, {"b": "cc"}]}' AS JSONB), NULL) AS INT);
SELECT JSON_EXTRACT_SCALAR(CAST('{"a": [{"b": "c"}, {"b": "cc"}]}' AS JSONB), '$[1]');
SELECT JSON_EXTRACT_SCALAR(CAST('{"a": [{"b": "c"}, {"b": "cc"}]}' AS JSONB), '$.z');
SELECT JSON_EXTRACT_SCALAR(CAST('{"a": [{"b": "c"}, {"b": "cc"}]}' AS JSONB), '$[""]');
SELECT JSON_EXTRACT_SCALAR(CAST('[{"b": "c"}, {"b": "cc"}]' AS JSONB), '$[1]');
SELECT JSON_EXTRACT_SCALAR(CAST('[{"b": "c"}, {"b": "cc"}]' AS JSONB), '$[3]');
SELECT JSON_EXTRACT_SCALAR(CAST('[{"b": "c"}, {"b": "cc"}]' AS JSONB), '$.z');
SELECT JSON_EXTRACT_SCALAR(CAST('{"a": "c", "b": null}' AS JSONB), '$.b');
SELECT JSON_EXTRACT_SCALAR(CAST('"foo"' AS JSONB), '$[1]');
SELECT JSON_EXTRACT_SCALAR(CAST('"foo"' AS JSONB), '$.z');
SELECT JSON_EXTRACT_SCALAR(CAST('[]' AS JSONB)) - 2147483648;
/* equality and inequality */ SELECT CAST('{"x":"y"}' AS JSONB) = CAST('{"x":"y"}' AS JSONB);
SELECT CAST('{"x":"y"}' AS JSONB) = CAST('{"x":"z"}' AS JSONB);
SELECT CAST('{"x":"y"}' AS JSONB) <> CAST('{"x":"y"}' AS JSONB);
SELECT CAST('{"x":"y"}' AS JSONB) <> CAST('{"x":"z"}' AS JSONB);
/* containment */ SELECT JSONB_CONTAINS('{"a":"b", "b":1, "c":null}', '{"a":"b"}');
SELECT JSONB_CONTAINS('{"a":"b", "b":1, "c":null}', '{"a":"b", "c":null}');
SELECT JSONB_CONTAINS('{"a":"b", "b":1, "c":null}', '{"a":"b", "g":null}');
SELECT JSONB_CONTAINS('{"a":"b", "b":1, "c":null}', '{"g":null}');
SELECT JSONB_CONTAINS('{"a":"b", "b":1, "c":null}', '{"a":"c"}');
SELECT JSONB_CONTAINS('{"a":"b", "b":1, "c":null}', '{"a":"b"}');
SELECT JSONB_CONTAINS('{"a":"b", "b":1, "c":null}', '{"a":"b", "c":"q"}');
SELECT CAST('{"a":"b", "b":1, "c":null}' AS JSONB) @> '{"a":"b"}';
SELECT CAST('{"a":"b", "b":1, "c":null}' AS JSONB) @> '{"a":"b", "c":null}';
SELECT CAST('{"a":"b", "b":1, "c":null}' AS JSONB) @> '{"a":"b", "g":null}';
SELECT CAST('{"a":"b", "b":1, "c":null}' AS JSONB) @> '{"g":null}';
SELECT CAST('{"a":"b", "b":1, "c":null}' AS JSONB) @> '{"a":"c"}';
SELECT CAST('{"a":"b", "b":1, "c":null}' AS JSONB) @> '{"a":"b"}';
SELECT CAST('{"a":"b", "b":1, "c":null}' AS JSONB) @> '{"a":"b", "c":"q"}';
SELECT CAST('[1,2]' AS JSONB) @> CAST('[1,2,2]' AS JSONB);
SELECT CAST('[1,1,2]' AS JSONB) @> CAST('[1,2,2]' AS JSONB);
SELECT CAST('[[1,2]]' AS JSONB) @> CAST('[[1,2,2]]' AS JSONB);
SELECT CAST('[1,2]' AS JSONB) @> CAST('[1,2,2]' AS JSONB);
SELECT CAST('[1,1,2]' AS JSONB) @> CAST('[1,2,2]' AS JSONB);
SELECT CAST('[[1,2]]' AS JSONB) @> CAST('[[1,2,2]]' AS JSONB);
SELECT JSONB_CONTAINED('{"a":"b"}', '{"a":"b", "b":1, "c":null}');
SELECT JSONB_CONTAINED('{"a":"b", "c":null}', '{"a":"b", "b":1, "c":null}');
SELECT JSONB_CONTAINED('{"a":"b", "g":null}', '{"a":"b", "b":1, "c":null}');
SELECT JSONB_CONTAINED('{"g":null}', '{"a":"b", "b":1, "c":null}');
SELECT JSONB_CONTAINED('{"a":"c"}', '{"a":"b", "b":1, "c":null}');
SELECT JSONB_CONTAINED('{"a":"b"}', '{"a":"b", "b":1, "c":null}');
SELECT JSONB_CONTAINED('{"a":"b", "c":"q"}', '{"a":"b", "b":1, "c":null}');
SELECT '{"a":"b", "b":1, "c":null}' @> CAST('{"a":"b"}' AS JSONB);
SELECT '{"a":"b", "b":1, "c":null}' @> CAST('{"a":"b", "c":null}' AS JSONB);
SELECT '{"a":"b", "b":1, "c":null}' @> CAST('{"a":"b", "g":null}' AS JSONB);
SELECT '{"a":"b", "b":1, "c":null}' @> CAST('{"g":null}' AS JSONB);
SELECT '{"a":"b", "b":1, "c":null}' @> CAST('{"a":"c"}' AS JSONB);
SELECT '{"a":"b", "b":1, "c":null}' @> CAST('{"a":"b"}' AS JSONB);
SELECT '{"a":"b", "b":1, "c":null}' @> CAST('{"a":"b", "c":"q"}' AS JSONB);
/* Raw scalar may contain another raw scalar, array may contain a raw scalar */ SELECT CAST('[5]' AS JSONB) @> '[5]';
SELECT CAST('5' AS JSONB) @> '5';
SELECT CAST('[5]' AS JSONB) @> '5';
/* But a raw scalar cannot contain an array */ SELECT CAST('5' AS JSONB) @> '[5]';
/* In general, one thing should always contain itself. Test array containment: */ SELECT CAST('["9", ["7", "3"], 1]' AS JSONB) @> CAST('["9", ["7", "3"], 1]' AS JSONB);
SELECT CAST('["9", ["7", "3"], ["1"]]' AS JSONB) @> CAST('["9", ["7", "3"], ["1"]]' AS JSONB);
/* array containment string matching confusion bug */ SELECT CAST('{ "name": "Bob", "tags": [ "enim", "qui"]}' AS JSONB) @> '{"tags":["qu"]}';
/* array length */ SELECT JSONB_ARRAY_LENGTH('[1,2,3,{"f1":1,"f2":[5,6]},4]');
SELECT JSONB_ARRAY_LENGTH('[]');
SELECT JSONB_ARRAY_LENGTH('{"f1":1,"f2":[5,6]}');
SELECT JSONB_ARRAY_LENGTH('4');
/* each */ SELECT JSONB_EACH('{"f1":[1,2,3],"f2":{"f3":1},"f4":null}');
SELECT JSONB_EACH(CAST('{"a":{"b":"c","c":"b","1":"first"},"b":[1,2],"c":"cc","1":"first","n":null}' AS JSONB)) AS x;
SELECT * FROM x AS x;
SELECT * FROM x AS x;
SELECT JSONB_EACH_TEXT('{"f1":[1,2,3],"f2":{"f3":1},"f4":null,"f5":"null"}');
SELECT JSONB_EACH_TEXT(CAST('{"a":{"b":"c","c":"b","1":"first"},"b":[1,2],"c":"cc","1":"first","n":null}' AS JSONB)) AS x;
SELECT * FROM x AS x;
SELECT * FROM x AS x;
/* exists */ SELECT JSONB_EXISTS('{"a":null, "b":"qq"}', '$.a');
SELECT JSONB_EXISTS('{"a":null, "b":"qq"}', '$.b');
SELECT JSONB_EXISTS('{"a":null, "b":"qq"}', '$.c');
SELECT JSONB_EXISTS('{"a":"null", "b":"qq"}', '$.a');
/* array exists - array elements should behave as keys */ SELECT COUNT(*) FROM x WHERE JSONB_CONTAINS(JSON_EXTRACT(x, '$.array'), 'bar');
/* type sensitive array exists - should return no rows (since "exists" only */ /* matches strings that are either object keys or array elements) */ SELECT COUNT(*) FROM x WHERE CAST(JSONB_CONTAINS(JSON_EXTRACT(x, '$.array'), '5') AS TEXT);
/* However, a raw scalar is *contained* within the array */ SELECT COUNT(*) FROM x WHERE JSON_EXTRACT(x, '$.array') @> CAST('5' AS JSONB);
SELECT JSONB_EXISTS_ANY('{"a":null, "b":"qq"}', ARRAY('a', 'b'));
SELECT JSONB_EXISTS_ANY('{"a":null, "b":"qq"}', ARRAY('b', 'a'));
SELECT JSONB_EXISTS_ANY('{"a":null, "b":"qq"}', ARRAY('c', 'a'));
SELECT JSONB_EXISTS_ANY('{"a":null, "b":"qq"}', ARRAY('c', 'd'));
SELECT JSONB_EXISTS_ANY('{"a":null, "b":"qq"}', CAST('{}' AS ARRAY<TEXT>));
SELECT JSONB_EXISTS_ALL('{"a":null, "b":"qq"}', ARRAY('a', 'b'));
SELECT JSONB_EXISTS_ALL('{"a":null, "b":"qq"}', ARRAY('b', 'a'));
SELECT JSONB_EXISTS_ALL('{"a":null, "b":"qq"}', ARRAY('c', 'a'));
SELECT JSONB_EXISTS_ALL('{"a":null, "b":"qq"}', ARRAY('c', 'd'));
SELECT JSONB_EXISTS_ALL('{"a":null, "b":"qq"}', CAST('{}' AS ARRAY<TEXT>));
/* typeof */ SELECT JSONB_TYPEOF('{}') AS x;
SELECT JSONB_TYPEOF('{"c":3,"p":"o"}') AS x;
SELECT JSONB_TYPEOF('[]') AS x;
SELECT JSONB_TYPEOF('["a", 1]') AS x;
SELECT JSONB_TYPEOF('null') AS "x";
SELECT JSONB_TYPEOF('1') AS x;
SELECT JSONB_TYPEOF('-1') AS x;
SELECT JSONB_TYPEOF('1.0') AS x;
SELECT JSONB_TYPEOF('1e2') AS x;
SELECT JSONB_TYPEOF('-1.0') AS x;
SELECT JSONB_TYPEOF('true') AS x;
SELECT JSONB_TYPEOF('false') AS x;
SELECT JSONB_TYPEOF('"hello"') AS x;
SELECT JSONB_TYPEOF('"true"') AS x;
SELECT JSONB_TYPEOF('"1.0"') AS x;
/* jsonb_build_array, jsonb_build_object, jsonb_object_agg */ SELECT JSONB_BUILD_ARRAY('a', 1, 'b', 1.2, 'c', TRUE, 'd', NULL, 'e', PARSE_JSON('{"x": 3, "y": [1,2,3]}'));
SELECT JSONB_BUILD_ARRAY('a', NULL);
/* ok */ SELECT JSONB_BUILD_OBJECT('a', 1, 'b', 1.2, 'c', TRUE, 'd', NULL, 'e', PARSE_JSON('{"x": 3, "y": [1,2,3]}'));
SELECT JSONB_BUILD_OBJECT('a', JSONB_BUILD_OBJECT('b', FALSE, 'c', 99), 'd', JSONB_BUILD_OBJECT('e', CAST(ARRAY(9, 8, 7) AS ARRAY<INT>), 'f', (SELECT ROW_TO_JSON(x) FROM (SELECT x, CAST(x AS REGCLASS) AS x FROM x WHERE x = 'pg_class') AS x)));
SELECT JSONB_BUILD_OBJECT(CAST('{a,b,c}' AS ARRAY<TEXT>));
/* error */ SELECT JSONB_BUILD_OBJECT(CAST('{a,b,c}' AS ARRAY<TEXT>), CAST('{d,e,f}' AS ARRAY<TEXT>));
/* error, key cannot be array */ SELECT JSONB_BUILD_OBJECT('a', 'b', 'c');
/* error */ SELECT JSONB_BUILD_OBJECT(NULL, 'a');
/* error, key cannot be NULL */ SELECT JSONB_BUILD_OBJECT('a', NULL);
/* ok */ /* empty objects/arrays */ SELECT JSONB_BUILD_ARRAY();
SELECT JSONB_BUILD_OBJECT();
/* make sure keys are quoted */ SELECT JSONB_BUILD_OBJECT(1, 2);
/* keys must be scalar and not null */ SELECT JSONB_BUILD_OBJECT(NULL, 2);
SELECT JSONB_BUILD_OBJECT(x, 2) FROM (SELECT 1 AS x, 2 AS x) AS x;
SELECT JSONB_BUILD_OBJECT(PARSE_JSON('{"a":1,"b":2}'), 3);
SELECT JSONB_BUILD_OBJECT(CAST('{1,2,3}' AS ARRAY<INT>), 3);
/* handling of NULL values */ SELECT J_S_O_N_B_OBJECT_AGG(1, CAST(NULL AS JSONB));
SELECT J_S_O_N_B_OBJECT_AGG(NULL, '{"a":1}');
CREATE TEMPORARY TABLE x (x INT, x TEXT, x TEXT);
INSERT INTO x VALUES (847001, 't15', 'GE1043');
INSERT INTO x VALUES (847002, 't16', 'GE1043');
INSERT INTO x VALUES (847003, 'sub-alpha', 'GESS90');
SELECT JSONB_BUILD_OBJECT('turbines', J_S_O_N_B_OBJECT_AGG(x, JSONB_BUILD_OBJECT('name', x, 'type', x))) FROM x;
SELECT J_S_O_N_B_OBJECT_AGG(x, x) FROM x;
INSERT INTO x VALUES (999999, NULL, 'bar');
SELECT J_S_O_N_B_OBJECT_AGG(x, x) FROM x;
/* jsonb_object */ /* empty object, one dimension */ SELECT JSONB_OBJECT('{}');
/* empty object, two dimensions */ SELECT JSONB_OBJECT('{}', '{}');
/* one dimension */ SELECT JSONB_OBJECT('{a,1,b,2,3,NULL,"d e f","a b c"}');
/* same but with two dimensions */ SELECT JSONB_OBJECT('{{a,1},{b,2},{3,NULL},{"d e f","a b c"}}');
/* odd number error */ SELECT JSONB_OBJECT('{a,b,c}');
/* one column error */ SELECT JSONB_OBJECT('{{a},{b}}');
/* too many columns error */ SELECT JSONB_OBJECT('{{a,b,c},{b,c,d}}');
/* too many dimensions error */ SELECT JSONB_OBJECT('{{{a,b},{c,d}},{{b,c},{d,e}}}');
/* two argument form of jsonb_object */ SELECT JSONB_OBJECT('{a,b,c,"d e f"}', '{1,2,3,"a b c"}');
/* too many dimensions */ SELECT JSONB_OBJECT('{{a,1},{b,2},{3,NULL},{"d e f","a b c"}}', '{{a,1},{b,2},{3,NULL},{"d e f","a b c"}}');
/* mismatched dimensions */ SELECT JSONB_OBJECT('{a,b,c,"d e f",g}', '{1,2,3,"a b c"}');
SELECT JSONB_OBJECT('{a,b,c,"d e f"}', '{1,2,3,"a b c",g}');
/* null key error */ SELECT JSONB_OBJECT('{a,b,NULL,"d e f"}', '{1,2,3,"a b c"}');
/* empty key is allowed */ SELECT JSONB_OBJECT('{a,b,"","d e f"}', '{1,2,3,"a b c"}');
/* extract_path, extract_path_as_text */ SELECT JSONB_EXTRACT_PATH('{"f2":{"f3":1},"f4":{"f5":99,"f6":"stringy"}}', 'f4', 'f6');
SELECT JSONB_EXTRACT_PATH('{"f2":{"f3":1},"f4":{"f5":99,"f6":"stringy"}}', 'f2');
SELECT JSONB_EXTRACT_PATH('{"f2":["f3",1],"f4":{"f5":99,"f6":"stringy"}}', 'f2', CAST(0 AS TEXT));
SELECT JSONB_EXTRACT_PATH('{"f2":["f3",1],"f4":{"f5":99,"f6":"stringy"}}', 'f2', CAST(1 AS TEXT));
SELECT JSONB_EXTRACT_PATH_TEXT('{"f2":{"f3":1},"f4":{"f5":99,"f6":"stringy"}}', 'f4', 'f6');
SELECT JSONB_EXTRACT_PATH_TEXT('{"f2":{"f3":1},"f4":{"f5":99,"f6":"stringy"}}', 'f2');
SELECT JSONB_EXTRACT_PATH_TEXT('{"f2":["f3",1],"f4":{"f5":99,"f6":"stringy"}}', 'f2', CAST(0 AS TEXT));
SELECT JSONB_EXTRACT_PATH_TEXT('{"f2":["f3",1],"f4":{"f5":99,"f6":"stringy"}}', 'f2', CAST(1 AS TEXT));
/* extract_path nulls */ SELECT JSONB_EXTRACT_PATH('{"f2":{"f3":1},"f4":{"f5":null,"f6":"stringy"}}', 'f4', 'f5') IS NULL AS x;
SELECT JSONB_EXTRACT_PATH_TEXT('{"f2":{"f3":1},"f4":{"f5":null,"f6":"stringy"}}', 'f4', 'f5') IS NULL AS x;
SELECT JSONB_EXTRACT_PATH('{"f2":{"f3":1},"f4":[0,1,2,null]}', 'f4', '3') IS NULL AS x;
SELECT JSONB_EXTRACT_PATH_TEXT('{"f2":{"f3":1},"f4":[0,1,2,null]}', 'f4', '3') IS NULL AS x;
/* extract_path operators */ SELECT JSONB_EXTRACT(CAST('{"f2":{"f3":1},"f4":{"f5":99,"f6":"stringy"}}' AS JSONB), x)['f4', 'f6'];
SELECT JSONB_EXTRACT(CAST('{"f2":{"f3":1},"f4":{"f5":99,"f6":"stringy"}}' AS JSONB), x)['f2'];
SELECT JSONB_EXTRACT(CAST('{"f2":["f3",1],"f4":{"f5":99,"f6":"stringy"}}' AS JSONB), x)['f2', '0'];
SELECT JSONB_EXTRACT(CAST('{"f2":["f3",1],"f4":{"f5":99,"f6":"stringy"}}' AS JSONB), x)['f2', '1'];
SELECT JSONB_EXTRACT_SCALAR(CAST('{"f2":{"f3":1},"f4":{"f5":99,"f6":"stringy"}}' AS JSONB), x)['f4', 'f6'];
SELECT JSONB_EXTRACT_SCALAR(CAST('{"f2":{"f3":1},"f4":{"f5":99,"f6":"stringy"}}' AS JSONB), x)['f2'];
SELECT JSONB_EXTRACT_SCALAR(CAST('{"f2":["f3",1],"f4":{"f5":99,"f6":"stringy"}}' AS JSONB), x)['f2', '0'];
SELECT JSONB_EXTRACT_SCALAR(CAST('{"f2":["f3",1],"f4":{"f5":99,"f6":"stringy"}}' AS JSONB), x)['f2', '1'];
/* corner cases for same */ SELECT JSONB_EXTRACT(CAST('{"a": {"b":{"c": "foo"}}}' AS JSONB), '{}');
SELECT JSONB_EXTRACT(CAST('[1,2,3]' AS JSONB), '{}');
SELECT JSONB_EXTRACT(CAST('"foo"' AS JSONB), '{}');
SELECT JSONB_EXTRACT(CAST('42' AS JSONB), '{}');
SELECT JSONB_EXTRACT(CAST('null' AS JSONB), '{}');
SELECT JSONB_EXTRACT(CAST('{"a": {"b":{"c": "foo"}}}' AS JSONB), x)['a'];
SELECT JSONB_EXTRACT(CAST('{"a": {"b":{"c": "foo"}}}' AS JSONB), x)['a', NULL];
SELECT JSONB_EXTRACT(CAST('{"a": {"b":{"c": "foo"}}}' AS JSONB), x)['a', ''];
SELECT JSONB_EXTRACT(CAST('{"a": {"b":{"c": "foo"}}}' AS JSONB), x)['a', 'b'];
SELECT JSONB_EXTRACT(CAST('{"a": {"b":{"c": "foo"}}}' AS JSONB), x)['a', 'b', 'c'];
SELECT JSONB_EXTRACT(CAST('{"a": {"b":{"c": "foo"}}}' AS JSONB), x)['a', 'b', 'c', 'd'];
SELECT JSONB_EXTRACT(CAST('{"a": {"b":{"c": "foo"}}}' AS JSONB), x)['a', 'z', 'c'];
SELECT JSONB_EXTRACT(CAST('{"a": [{"b": "c"}, {"b": "cc"}]}' AS JSONB), x)['a', '1', 'b'];
SELECT JSONB_EXTRACT(CAST('{"a": [{"b": "c"}, {"b": "cc"}]}' AS JSONB), x)['a', 'z', 'b'];
SELECT JSONB_EXTRACT(CAST('[{"b": "c"}, {"b": "cc"}]' AS JSONB), x)['1', 'b'];
SELECT JSONB_EXTRACT(CAST('[{"b": "c"}, {"b": "cc"}]' AS JSONB), x)['z', 'b'];
SELECT JSONB_EXTRACT(CAST('[{"b": "c"}, {"b": null}]' AS JSONB), x)['1', 'b'];
SELECT JSONB_EXTRACT(CAST('"foo"' AS JSONB), x)['z'];
SELECT JSONB_EXTRACT(CAST('42' AS JSONB), x)['f2'];
SELECT JSONB_EXTRACT(CAST('42' AS JSONB), x)['0'];
SELECT JSONB_EXTRACT_SCALAR(CAST('{"a": {"b":{"c": "foo"}}}' AS JSONB), '{}');
SELECT JSONB_EXTRACT_SCALAR(CAST('[1,2,3]' AS JSONB), '{}');
SELECT JSONB_EXTRACT_SCALAR(CAST('"foo"' AS JSONB), '{}');
SELECT JSONB_EXTRACT_SCALAR(CAST('42' AS JSONB), '{}');
SELECT JSONB_EXTRACT_SCALAR(CAST('null' AS JSONB), '{}');
SELECT JSONB_EXTRACT_SCALAR(CAST('{"a": {"b":{"c": "foo"}}}' AS JSONB), x)['a'];
SELECT JSONB_EXTRACT_SCALAR(CAST('{"a": {"b":{"c": "foo"}}}' AS JSONB), x)['a', NULL];
SELECT JSONB_EXTRACT_SCALAR(CAST('{"a": {"b":{"c": "foo"}}}' AS JSONB), x)['a', ''];
SELECT JSONB_EXTRACT_SCALAR(CAST('{"a": {"b":{"c": "foo"}}}' AS JSONB), x)['a', 'b'];
SELECT JSONB_EXTRACT_SCALAR(CAST('{"a": {"b":{"c": "foo"}}}' AS JSONB), x)['a', 'b', 'c'];
SELECT JSONB_EXTRACT_SCALAR(CAST('{"a": {"b":{"c": "foo"}}}' AS JSONB), x)['a', 'b', 'c', 'd'];
SELECT JSONB_EXTRACT_SCALAR(CAST('{"a": {"b":{"c": "foo"}}}' AS JSONB), x)['a', 'z', 'c'];
SELECT JSONB_EXTRACT_SCALAR(CAST('{"a": [{"b": "c"}, {"b": "cc"}]}' AS JSONB), x)['a', '1', 'b'];
SELECT JSONB_EXTRACT_SCALAR(CAST('{"a": [{"b": "c"}, {"b": "cc"}]}' AS JSONB), x)['a', 'z', 'b'];
SELECT JSONB_EXTRACT_SCALAR(CAST('[{"b": "c"}, {"b": "cc"}]' AS JSONB), x)['1', 'b'];
SELECT JSONB_EXTRACT_SCALAR(CAST('[{"b": "c"}, {"b": "cc"}]' AS JSONB), x)['z', 'b'];
SELECT JSONB_EXTRACT_SCALAR(CAST('[{"b": "c"}, {"b": null}]' AS JSONB), x)['1', 'b'];
SELECT JSONB_EXTRACT_SCALAR(CAST('"foo"' AS JSONB), x)['z'];
SELECT JSONB_EXTRACT_SCALAR(CAST('42' AS JSONB), x)['f2'];
SELECT JSONB_EXTRACT_SCALAR(CAST('42' AS JSONB), x)['0'];
/* array_elements */ SELECT JSONB_ARRAY_ELEMENTS('[1,true,[1,[2,3]],null,{"f1":1,"f2":[7,8,9]},false]');
SELECT * FROM x AS x;
SELECT JSONB_ARRAY_ELEMENTS_TEXT('[1,true,[1,[2,3]],null,{"f1":1,"f2":[7,8,9]},false,"stringy"]');
SELECT * FROM x AS x;
/* populate_record */ CREATE TYPE jbpop AS (a text, b int, c timestamp);
CREATE DOMAIN jsb_int_not_null  AS int     NOT NULL;
CREATE DOMAIN jsb_int_array_1d  AS int[]   CHECK(array_length(VALUE, 1) = 3);
CREATE DOMAIN jsb_int_array_2d  AS int[][] CHECK(array_length(VALUE, 2) = 3);
create type jb_unordered_pair as (x int, y int);
create domain jb_ordered_pair as jb_unordered_pair check((value).x <= (value).y);
CREATE TYPE jsbrec AS ( 	i	int, 	ia	_int4, 	ia1	int[], 	ia2	int[][], 	ia3	int[][][], 	ia1d	jsb_int_array_1d, 	ia2d	jsb_int_array_2d, 	t	text, 	ta	text[], 	c	char(10), 	ca	char(10)[], 	ts	timestamp, 	js	json, 	jsb	jsonb, 	jsa	json[], 	rec	jbpop, 	reca	jbpop[] );
CREATE TYPE jsbrec_i_not_null AS ( 	i	jsb_int_not_null );
SELECT * FROM x AS x;
SELECT * FROM x AS x;
SELECT * FROM x AS x;
SELECT * FROM x AS x;
SELECT * FROM x AS x;
SELECT * FROM x AS x;
SELECT * FROM x AS x;
SELECT * FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
SELECT x FROM x AS x;
/* Tests to check soft-error support for populate_record_field() */ /* populate_scalar() */ create type jsb_char2 as (a char(2));
SELECT JSONB_POPULATE_RECORD_VALID(CAST(NULL AS jsb_char2), '{"a": "aaa"}');
SELECT * FROM x AS x;
SELECT JSONB_POPULATE_RECORD_VALID(CAST(NULL AS jsb_char2), '{"a": "aa"}');
SELECT * FROM x AS x;
/* populate_array() */ create type jsb_ia as (a int[]);
create type jsb_ia2 as (a int[][]);
SELECT JSONB_POPULATE_RECORD_VALID(CAST(NULL AS jsb_ia), '{"a": 43.2}');
SELECT * FROM x AS x;
SELECT JSONB_POPULATE_RECORD_VALID(CAST(NULL AS jsb_ia), '{"a": [1, 2]}');
SELECT * FROM x AS x;
SELECT JSONB_POPULATE_RECORD_VALID(CAST(NULL AS jsb_ia2), '{"a": [[1], [2, 3]]}');
SELECT * FROM x AS x;
SELECT JSONB_POPULATE_RECORD_VALID(CAST(NULL AS jsb_ia2), '{"a": [[1, 0], [2, 3]]}');
SELECT * FROM x AS x;
/* populate_domain() */ create domain jsb_i_not_null as int not null;
create domain jsb_i_gt_1 as int check (value > 1);
create type jsb_i_not_null_rec as (a jsb_i_not_null);
create type jsb_i_gt_1_rec as (a jsb_i_gt_1);
SELECT JSONB_POPULATE_RECORD_VALID(CAST(NULL AS jsb_i_not_null_rec), '{"a": null}');
SELECT * FROM x AS x;
SELECT JSONB_POPULATE_RECORD_VALID(CAST(NULL AS jsb_i_not_null_rec), '{"a": 1}');
SELECT * FROM x AS x;
SELECT JSONB_POPULATE_RECORD_VALID(CAST(NULL AS jsb_i_gt_1_rec), '{"a": 1}');
SELECT * FROM x AS x;
SELECT JSONB_POPULATE_RECORD_VALID(CAST(NULL AS jsb_i_gt_1_rec), '{"a": 2}');
SELECT * FROM x AS x;
drop type jsb_ia, jsb_ia2, jsb_char2, jsb_i_not_null_rec, jsb_i_gt_1_rec;
drop domain jsb_i_not_null, jsb_i_gt_1;
/* anonymous record type */ SELECT JSONB_POPULATE_RECORD(CAST(NULL AS record), '{"x": 0, "y": 1}');
SELECT JSONB_POPULATE_RECORD(ROW(1, 2), '{"f1": 0, "f2": 1}');
SELECT * FROM x AS _t0;
/* composite domain */ SELECT JSONB_POPULATE_RECORD(CAST(NULL AS jb_ordered_pair), '{"x": 0, "y": 1}');
SELECT JSONB_POPULATE_RECORD(CAST(ROW(1, 2) AS jb_ordered_pair), '{"x": 0}');
SELECT JSONB_POPULATE_RECORD(CAST(ROW(1, 2) AS jb_ordered_pair), '{"x": 1, "y": 0}');
/* populate_recordset */ SELECT * FROM x AS x;
SELECT * FROM x AS x;
SELECT * FROM x AS x;
SELECT * FROM x AS x;
SELECT * FROM x AS x;
SELECT * FROM x AS x;
SELECT * FROM x AS x;
SELECT * FROM x AS x;
SELECT * FROM x AS x;
/* anonymous record type */ SELECT JSONB_POPULATE_RECORDSET(CAST(NULL AS record), '[{"x": 0, "y": 1}]');
SELECT JSONB_POPULATE_RECORDSET(ROW(1, 2), '[{"f1": 0, "f2": 1}]');
SELECT x, JSONB_POPULATE_RECORDSET(ROW(x, 50), '[{"f1":"42"},{"f2":"43"}]') FROM (VALUES (1), (2)) AS x;
SELECT * FROM x AS _t0;
/* empty array is a corner case */ SELECT JSONB_POPULATE_RECORDSET(CAST(NULL AS record), '[]');
SELECT JSONB_POPULATE_RECORDSET(ROW(1, 2), '[]');
SELECT * FROM x AS x;
SELECT * FROM x AS _t0;
/* composite domain */ SELECT JSONB_POPULATE_RECORDSET(CAST(NULL AS jb_ordered_pair), '[{"x": 0, "y": 1}]');
SELECT JSONB_POPULATE_RECORDSET(CAST(ROW(1, 2) AS jb_ordered_pair), '[{"x": 0}, {"y": 3}]');
SELECT JSONB_POPULATE_RECORDSET(CAST(ROW(1, 2) AS jb_ordered_pair), '[{"x": 1, "y": 0}]');
/* negative cases where the wrong record type is supplied */ SELECT * FROM x AS x;
SELECT * FROM x AS x;
SELECT * FROM x AS x;
SELECT * FROM x AS x;
/* jsonb_to_record and jsonb_to_recordset */ SELECT * FROM x AS x;
SELECT * FROM x AS x;
SELECT *, x IS NULL AS x FROM x AS x;
SELECT *, x IS NULL AS x FROM x AS x;
SELECT * FROM x AS x;
SELECT * FROM x AS x;
SELECT * FROM x AS x;
SELECT * FROM x AS x;
SELECT * FROM x AS x;
SELECT * FROM x AS x;
SELECT * FROM x AS x;
SELECT * FROM x AS x;
SELECT * FROM x AS x;
SELECT * FROM x AS x;
SELECT * FROM x AS x;
SELECT * FROM x AS x;
SELECT * FROM x AS x;
SELECT * FROM x AS x;
SELECT * FROM x AS x;
/* test type info caching in jsonb_populate_record() */ CREATE TEMPORARY TABLE x (x JSONB);
INSERT INTO x SELECT CAST('{ 	"jsa": [1, "2", null, 4], 	"rec": {"a": "abc", "c": "01.02.2003", "x": 43.2}, 	"reca": [{"a": "abc", "b": 456}, null, {"c": "01.02.2003", "x": 43.2}] }' AS JSONB) FROM x;
SELECT (JSONB_POPULATE_RECORD(CAST(NULL AS jsbrec), x)).* FROM x;
DROP TYPE jsbrec;
DROP TYPE jsbrec_i_not_null;
DROP DOMAIN jsb_int_not_null;
DROP DOMAIN jsb_int_array_1d;
DROP DOMAIN jsb_int_array_2d;
DROP DOMAIN jb_ordered_pair;
DROP TYPE jb_unordered_pair;
/* indexing */ SELECT COUNT(*) FROM x WHERE x @> '{"wait":null}';
SELECT COUNT(*) FROM x WHERE x @> '{"wait":"CC"}';
SELECT COUNT(*) FROM x WHERE x @> '{"wait":"CC", "public":true}';
SELECT COUNT(*) FROM x WHERE x @> '{"age":25}';
SELECT COUNT(*) FROM x WHERE x @> '{"age":25.0}';
SELECT COUNT(*) FROM x WHERE JSONB_CONTAINS(x, 'public');
SELECT COUNT(*) FROM x WHERE JSONB_CONTAINS(x, 'bar');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('$.wait == null');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('"CC" == $.wait');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('$.wait == "CC" && true == $.public');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('$.age == 25');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('$.age == 25.0');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('exists($)');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('exists($.public)');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('exists($.bar)');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('exists($.public) || exists($.disabled)');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('exists($.public) && exists($.disabled)');
CREATE INDEX x ON x USING gin(x NULLS LAST);
SET x = off;
SELECT COUNT(*) FROM x WHERE x @> '{"wait":null}';
SELECT COUNT(*) FROM x WHERE x @> '{"wait":"CC"}';
SELECT COUNT(*) FROM x WHERE x @> '{"wait":"CC", "public":true}';
SELECT COUNT(*) FROM x WHERE x @> '{"age":25}';
SELECT COUNT(*) FROM x WHERE x @> '{"age":25.0}';
SELECT COUNT(*) FROM x WHERE x @> '{"array":["foo"]}';
SELECT COUNT(*) FROM x WHERE x @> '{"array":["bar"]}';
/* exercise GIN_SEARCH_MODE_ALL */ SELECT COUNT(*) FROM x WHERE x @> '{}';
SELECT COUNT(*) FROM x WHERE JSONB_CONTAINS(x, 'public');
SELECT COUNT(*) FROM x WHERE JSONB_CONTAINS(x, 'bar');
EXPLAIN (COSTS OFF) SELECT count(*) FROM testjsonb WHERE j @@ '$.wait == null';
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('$.wait == null');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('exists($ ? (@.wait == null))');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('exists($.wait ? (@ == null))');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('"CC" == $.wait');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('$.wait == "CC" && true == $.public');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('$.age == 25');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('$.age == 25.0');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('$.array[*] == "foo"');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('$.array[*] == "bar"');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('exists($ ? (@.array[*] == "bar"))');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('exists($.array ? (@[*] == "bar"))');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('exists($.array[*] ? (@ == "bar"))');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('exists($)');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('exists($.public)');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('exists($.bar)');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('exists($.public) || exists($.disabled)');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('exists($.public) && exists($.disabled)');
EXPLAIN (COSTS OFF) SELECT count(*) FROM testjsonb WHERE j @? '$.wait ? (@ == null)';
/* array exists - array elements should behave as keys (for GIN index scans too) */ CREATE INDEX x ON x USING gin((JSON_EXTRACT(x, '$.array')) NULLS LAST);
SELECT COUNT(*) FROM x WHERE JSONB_CONTAINS(JSON_EXTRACT(x, '$.array'), 'bar');
/* type sensitive array exists - should return no rows (since "exists" only */ /* matches strings that are either object keys or array elements) */ SELECT COUNT(*) FROM x WHERE CAST(JSONB_CONTAINS(JSON_EXTRACT(x, '$.array'), '5') AS TEXT);
/* However, a raw scalar is *contained* within the array */ SELECT COUNT(*) FROM x WHERE JSON_EXTRACT(x, '$.array') @> CAST('5' AS JSONB);
RESET enable_seqscan;
SELECT COUNT(*) FROM (SELECT (JSONB_EACH(x)).x FROM x) AS x;
SELECT x, COUNT(*) FROM (SELECT (JSONB_EACH(x)).x FROM x) AS x GROUP BY x ORDER BY x DESC NULLS FIRST, x NULLS LAST;
/* sort/hash */ SELECT COUNT(DISTINCT x) FROM x;
SET x = off;
SELECT COUNT(*) FROM (SELECT x FROM (SELECT * FROM x UNION ALL SELECT * FROM x) AS x GROUP BY x) AS x;
SET x = on;
SET x = off;
SELECT COUNT(*) FROM (SELECT x FROM (SELECT * FROM x UNION ALL SELECT * FROM x) AS x GROUP BY x) AS x;
SELECT DISTINCT * FROM (VALUES (CAST('{}' AS JSONB) || CAST('' AS TEXT)), ('{}')) AS x;
SET x = on;
RESET enable_hashagg;
RESET enable_sort;
DROP INDEX x;
DROP INDEX x;
/* btree */ CREATE INDEX x ON x USING btree(x NULLS LAST);
SET x = off;
SELECT COUNT(*) FROM x WHERE x > '{"p":1}';
SELECT COUNT(*) FROM x WHERE x = '{"pos":98, "line":371, "node":"CBA", "indexed":true}';
/* gin path opclass */ DROP INDEX x;
CREATE INDEX x ON x USING gin(x x NULLS LAST);
SET x = off;
SELECT COUNT(*) FROM x WHERE x @> '{"wait":null}';
SELECT COUNT(*) FROM x WHERE x @> '{"wait":"CC"}';
SELECT COUNT(*) FROM x WHERE x @> '{"wait":"CC", "public":true}';
SELECT COUNT(*) FROM x WHERE x @> '{"age":25}';
SELECT COUNT(*) FROM x WHERE x @> '{"age":25.0}';
/* exercise GIN_SEARCH_MODE_ALL */ SELECT COUNT(*) FROM x WHERE x @> '{}';
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('$.wait == null');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('exists($ ? (@.wait == null))');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('exists($.wait ? (@ == null))');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('"CC" == $.wait');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('$.wait == "CC" && true == $.public');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('$.age == 25');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('$.age == 25.0');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('$.array[*] == "foo"');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('$.array[*] == "bar"');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('exists($ ? (@.array[*] == "bar"))');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('exists($.array ? (@[*] == "bar"))');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('exists($.array[*] ? (@ == "bar"))');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('exists($)');
EXPLAIN (COSTS OFF) SELECT count(*) FROM testjsonb WHERE j @? '$.wait ? (@ == null)';
RESET enable_seqscan;
DROP INDEX x;
/* nested tests */ SELECT CAST('{"ff":{"a":12,"b":16}}' AS JSONB);
SELECT CAST('{"ff":{"a":12,"b":16},"qq":123}' AS JSONB);
SELECT CAST('{"aa":["a","aaa"],"qq":{"a":12,"b":16,"c":["c1","c2"],"d":{"d1":"d1","d2":"d2","d1":"d3"}}}' AS JSONB);
SELECT CAST('{"aa":["a","aaa"],"qq":{"a":"12","b":"16","c":["c1","c2"],"d":{"d1":"d1","d2":"d2"}}}' AS JSONB);
SELECT CAST('{"aa":["a","aaa"],"qq":{"a":"12","b":"16","c":["c1","c2",["c3"],{"c4":4}],"d":{"d1":"d1","d2":"d2"}}}' AS JSONB);
SELECT CAST('{"ff":["a","aaa"]}' AS JSONB);
SELECT JSON_EXTRACT(CAST('{"ff":{"a":12,"b":16},"qq":123,"x":[1,2],"Y":null}' AS JSONB), '$.ff'), JSON_EXTRACT(CAST('{"ff":{"a":12,"b":16},"qq":123,"x":[1,2],"Y":null}' AS JSONB), '$.qq'), (JSON_EXTRACT(CAST('{"ff":{"a":12,"b":16},"qq":123,"x":[1,2],"Y":null}' AS JSONB), '$.Y')) IS NULL AS x, (JSON_EXTRACT_SCALAR(CAST('{"ff":{"a":12,"b":16},"qq":123,"x":[1,2],"Y":null}' AS JSONB), '$.Y')) IS NULL AS x, JSON_EXTRACT(CAST('{"ff":{"a":12,"b":16},"qq":123,"x":[1,2],"Y":null}' AS JSONB), '$.x');
/* nested containment */ SELECT CAST('{"a":[1,2],"c":"b"}' AS JSONB) @> '{"a":[1,2]}';
SELECT CAST('{"a":[2,1],"c":"b"}' AS JSONB) @> '{"a":[1,2]}';
SELECT CAST('{"a":{"1":2},"c":"b"}' AS JSONB) @> '{"a":[1,2]}';
SELECT CAST('{"a":{"2":1},"c":"b"}' AS JSONB) @> '{"a":[1,2]}';
SELECT CAST('{"a":{"1":2},"c":"b"}' AS JSONB) @> '{"a":{"1":2}}';
SELECT CAST('{"a":{"2":1},"c":"b"}' AS JSONB) @> '{"a":{"1":2}}';
SELECT CAST('["a","b"]' AS JSONB) @> '["a","b","c","b"]';
SELECT CAST('["a","b","c","b"]' AS JSONB) @> '["a","b"]';
SELECT CAST('["a","b","c",[1,2]]' AS JSONB) @> '["a",[1,2]]';
SELECT CAST('["a","b","c",[1,2]]' AS JSONB) @> '["b",[1,2]]';
SELECT CAST('{"a":[1,2],"c":"b"}' AS JSONB) @> '{"a":[1]}';
SELECT CAST('{"a":[1,2],"c":"b"}' AS JSONB) @> '{"a":[2]}';
SELECT CAST('{"a":[1,2],"c":"b"}' AS JSONB) @> '{"a":[3]}';
SELECT CAST('{"a":[1,2,{"c":3,"x":4}],"c":"b"}' AS JSONB) @> '{"a":[{"c":3}]}';
SELECT CAST('{"a":[1,2,{"c":3,"x":4}],"c":"b"}' AS JSONB) @> '{"a":[{"x":4}]}';
SELECT CAST('{"a":[1,2,{"c":3,"x":4}],"c":"b"}' AS JSONB) @> '{"a":[{"x":4},3]}';
SELECT CAST('{"a":[1,2,{"c":3,"x":4}],"c":"b"}' AS JSONB) @> '{"a":[{"x":4},1]}';
/* check some corner cases for indexed nested containment (bug #13756) */ CREATE TEMPORARY TABLE x (x JSONB);
INSERT INTO x (x) VALUES ('{"a":[["b",{"x":1}],["b",{"x":2}]],"c":3}');
INSERT INTO x (x) VALUES ('[[14,2,3]]');
INSERT INTO x (x) VALUES ('[1,[14,2,3]]');
CREATE INDEX ON x USING gin(x x NULLS LAST);
SET x = on;
SET x = off;
SELECT * FROM x WHERE x @> CAST('{"a":[[{"x":2}]]}' AS JSONB);
SELECT * FROM x WHERE x @> '{"c":3}';
SELECT * FROM x WHERE x @> '[[14]]';
SET x = off;
SET x = on;
SELECT * FROM x WHERE x @> CAST('{"a":[[{"x":2}]]}' AS JSONB);
SELECT * FROM x WHERE x @> '{"c":3}';
SELECT * FROM x WHERE x @> '[[14]]';
RESET enable_seqscan;
RESET enable_bitmapscan;
/* nested object field / array index lookup */ SELECT JSON_EXTRACT(CAST('{"n":null,"a":1,"b":[1,2],"c":{"1":2},"d":{"1":[2,3]}}' AS JSONB), '$.n');
SELECT JSON_EXTRACT(CAST('{"n":null,"a":1,"b":[1,2],"c":{"1":2},"d":{"1":[2,3]}}' AS JSONB), '$.a');
SELECT JSON_EXTRACT(CAST('{"n":null,"a":1,"b":[1,2],"c":{"1":2},"d":{"1":[2,3]}}' AS JSONB), '$.b');
SELECT JSON_EXTRACT(CAST('{"n":null,"a":1,"b":[1,2],"c":{"1":2},"d":{"1":[2,3]}}' AS JSONB), '$.c');
SELECT JSON_EXTRACT(CAST('{"n":null,"a":1,"b":[1,2],"c":{"1":2},"d":{"1":[2,3]}}' AS JSONB), '$.d');
SELECT JSON_EXTRACT(JSON_EXTRACT(CAST('{"n":null,"a":1,"b":[1,2],"c":{"1":2},"d":{"1":[2,3]}}' AS JSONB), '$.d'), '$[1]');
SELECT JSON_EXTRACT(CAST('{"n":null,"a":1,"b":[1,2],"c":{"1":2},"d":{"1":[2,3]}}' AS JSONB), '$.e');
SELECT JSON_EXTRACT(CAST('{"n":null,"a":1,"b":[1,2],"c":{"1":2},"d":{"1":[2,3]}}' AS JSONB), '$[0]');
/* expecting error */ SELECT JSON_EXTRACT(CAST('["a","b","c",[1,2],null]' AS JSONB), '$[0]');
SELECT JSON_EXTRACT(CAST('["a","b","c",[1,2],null]' AS JSONB), '$[1]');
SELECT JSON_EXTRACT(CAST('["a","b","c",[1,2],null]' AS JSONB), '$[2]');
SELECT JSON_EXTRACT(CAST('["a","b","c",[1,2],null]' AS JSONB), '$[3]');
SELECT JSON_EXTRACT(JSON_EXTRACT(CAST('["a","b","c",[1,2],null]' AS JSONB), '$[3]'), '$[1]');
SELECT JSON_EXTRACT(CAST('["a","b","c",[1,2],null]' AS JSONB), '$[4]');
SELECT JSON_EXTRACT(CAST('["a","b","c",[1,2],null]' AS JSONB), '$[5]');
SELECT JSON_EXTRACT(CAST('["a","b","c",[1,2],null]' AS JSONB)) - 1;
SELECT JSON_EXTRACT(CAST('["a","b","c",[1,2],null]' AS JSONB)) - 5;
SELECT JSON_EXTRACT(CAST('["a","b","c",[1,2],null]' AS JSONB)) - 6;
/* nested path extraction */ SELECT JSONB_EXTRACT(CAST('{"a":"b","c":[1,2,3]}' AS JSONB), '{0}');
SELECT JSONB_EXTRACT(CAST('{"a":"b","c":[1,2,3]}' AS JSONB), '{a}');
SELECT JSONB_EXTRACT(CAST('{"a":"b","c":[1,2,3]}' AS JSONB), '{c}');
SELECT JSONB_EXTRACT(CAST('{"a":"b","c":[1,2,3]}' AS JSONB), '{c,0}');
SELECT JSONB_EXTRACT(CAST('{"a":"b","c":[1,2,3]}' AS JSONB), '{c,1}');
SELECT JSONB_EXTRACT(CAST('{"a":"b","c":[1,2,3]}' AS JSONB), '{c,2}');
SELECT JSONB_EXTRACT(CAST('{"a":"b","c":[1,2,3]}' AS JSONB), '{c,3}');
SELECT JSONB_EXTRACT(CAST('{"a":"b","c":[1,2,3]}' AS JSONB), '{c,-1}');
SELECT JSONB_EXTRACT(CAST('{"a":"b","c":[1,2,3]}' AS JSONB), '{c,-3}');
SELECT JSONB_EXTRACT(CAST('{"a":"b","c":[1,2,3]}' AS JSONB), '{c,-4}');
SELECT JSONB_EXTRACT(CAST('[0,1,2,[3,4],{"5":"five"}]' AS JSONB), '{0}');
SELECT JSONB_EXTRACT(CAST('[0,1,2,[3,4],{"5":"five"}]' AS JSONB), '{3}');
SELECT JSONB_EXTRACT(CAST('[0,1,2,[3,4],{"5":"five"}]' AS JSONB), '{4}');
SELECT JSONB_EXTRACT(CAST('[0,1,2,[3,4],{"5":"five"}]' AS JSONB), '{4,5}');
/* nested exists */ SELECT JSONB_CONTAINS(CAST('{"n":null,"a":1,"b":[1,2],"c":{"1":2},"d":{"1":[2,3]}}' AS JSONB), 'n');
SELECT JSONB_CONTAINS(CAST('{"n":null,"a":1,"b":[1,2],"c":{"1":2},"d":{"1":[2,3]}}' AS JSONB), 'a');
SELECT JSONB_CONTAINS(CAST('{"n":null,"a":1,"b":[1,2],"c":{"1":2},"d":{"1":[2,3]}}' AS JSONB), 'b');
SELECT JSONB_CONTAINS(CAST('{"n":null,"a":1,"b":[1,2],"c":{"1":2},"d":{"1":[2,3]}}' AS JSONB), 'c');
SELECT JSONB_CONTAINS(CAST('{"n":null,"a":1,"b":[1,2],"c":{"1":2},"d":{"1":[2,3]}}' AS JSONB), 'd');
SELECT JSONB_CONTAINS(CAST('{"n":null,"a":1,"b":[1,2],"c":{"1":2},"d":{"1":[2,3]}}' AS JSONB), 'e');
/* jsonb_strip_nulls */ SELECT JSONB_STRIP_NULLS(NULL);
SELECT JSONB_STRIP_NULLS('1');
SELECT JSONB_STRIP_NULLS('"a string"');
SELECT JSONB_STRIP_NULLS('null');
SELECT JSONB_STRIP_NULLS('[1,2,null,3,4]');
SELECT JSONB_STRIP_NULLS('{"a":1,"b":null,"c":[2,null,3],"d":{"e":4,"f":null}}');
SELECT JSONB_STRIP_NULLS('[1,{"a":1,"b":null,"c":2},3]');
/* an empty object is not null and should not be stripped */ SELECT JSONB_STRIP_NULLS('{"a": {"b": null, "c": null}, "d": {} }');
/* jsonb_strip_nulls (strip_in_arrays=true) */ SELECT JSONB_STRIP_NULLS(NULL, TRUE);
SELECT JSONB_STRIP_NULLS('1', TRUE);
SELECT JSONB_STRIP_NULLS('"a string"', TRUE);
SELECT JSONB_STRIP_NULLS('null', TRUE);
SELECT JSONB_STRIP_NULLS('[1,2,null,3,4]', TRUE);
SELECT JSONB_STRIP_NULLS('{"a":1,"b":null,"c":[2,null,3],"d":{"e":4,"f":null}}', TRUE);
SELECT JSONB_STRIP_NULLS('[1,{"a":1,"b":null,"c":2},3]', TRUE);
/* an empty object is not null and should not be stripped */ SELECT JSONB_STRIP_NULLS('{"a": {"b": null, "c": null}, "d": {} }', TRUE);
SELECT JSONB_PRETTY('{"a": "test", "b": [1, 2, 3], "c": "test3", "d":{"dd": "test4", "dd2":{"ddd": "test5"}}}');
SELECT JSONB_PRETTY('[{"f1":1,"f2":null},2,null,[[{"x":true},6,7],8],3]');
SELECT JSONB_PRETTY('{"a":["b", "c"], "d": {"e":"f"}}');
SELECT JSONB_CONCAT('{"d": "test", "a": [1, 2]}', '{"g": "test2", "c": {"c1":1, "c2":2}}');
SELECT CAST('{"aa":1 , "b":2, "cq":3}' AS JSONB) || '{"cq":"l", "b":"g", "fg":false}';
SELECT CAST('{"aa":1 , "b":2, "cq":3}' AS JSONB) || '{"aq":"l"}';
SELECT CAST('{"aa":1 , "b":2, "cq":3}' AS JSONB) || '{"aa":"l"}';
SELECT CAST('{"aa":1 , "b":2, "cq":3}' AS JSONB) || '{}';
SELECT CAST('["a", "b"]' AS JSONB) || '["c"]';
SELECT CAST('["a", "b"]' AS JSONB) || '["c", "d"]';
SELECT '["c"]' || CAST('["a", "b"]' AS JSONB);
SELECT CAST('["a", "b"]' AS JSONB) || '"c"';
SELECT '"c"' || CAST('["a", "b"]' AS JSONB);
SELECT CAST('[]' AS JSONB) || CAST('["a"]' AS JSONB);
SELECT CAST('[]' AS JSONB) || CAST('"a"' AS JSONB);
SELECT CAST('"b"' AS JSONB) || CAST('"a"' AS JSONB);
SELECT CAST('{}' AS JSONB) || CAST('{"a":"b"}' AS JSONB);
SELECT CAST('[]' AS JSONB) || CAST('{"a":"b"}' AS JSONB);
SELECT CAST('{"a":"b"}' AS JSONB) || CAST('[]' AS JSONB);
SELECT CAST('"a"' AS JSONB) || '{"a":1}';
SELECT '{"a":1}' || CAST('"a"' AS JSONB);
SELECT CAST('[3]' AS JSONB) || CAST('{}' AS JSONB);
SELECT CAST('3' AS JSONB) || CAST('[]' AS JSONB);
SELECT CAST('3' AS JSONB) || CAST('4' AS JSONB);
SELECT CAST('3' AS JSONB) || CAST('{}' AS JSONB);
SELECT CAST('["a", "b"]' AS JSONB) || '{"c":1}';
SELECT CAST('{"c": 1}' AS JSONB) || '["a", "b"]';
SELECT CAST('{}' AS JSONB) || '{"cq":"l", "b":"g", "fg":false}';
SELECT PG_COLUMN_SIZE(CAST('{}' AS JSONB) || CAST('{}' AS JSONB)) = PG_COLUMN_SIZE(CAST('{}' AS JSONB));
SELECT PG_COLUMN_SIZE(CAST('{"aa":1}' AS JSONB) || CAST('{"b":2}' AS JSONB)) = PG_COLUMN_SIZE(CAST('{"aa":1, "b":2}' AS JSONB));
SELECT PG_COLUMN_SIZE(CAST('{"aa":1, "b":2}' AS JSONB) || CAST('{}' AS JSONB)) = PG_COLUMN_SIZE(CAST('{"aa":1, "b":2}' AS JSONB));
SELECT PG_COLUMN_SIZE(CAST('{}' AS JSONB) || CAST('{"aa":1, "b":2}' AS JSONB)) = PG_COLUMN_SIZE(CAST('{"aa":1, "b":2}' AS JSONB));
SELECT JSONB_DELETE(CAST('{"a":1 , "b":2, "c":3}' AS JSONB), 'a');
SELECT JSONB_DELETE(CAST('{"a":null , "b":2, "c":3}' AS JSONB), 'a');
SELECT JSONB_DELETE(CAST('{"a":1 , "b":2, "c":3}' AS JSONB), 'b');
SELECT JSONB_DELETE(CAST('{"a":1 , "b":2, "c":3}' AS JSONB), 'c');
SELECT JSONB_DELETE(CAST('{"a":1 , "b":2, "c":3}' AS JSONB), 'd');
SELECT CAST('{"a":1 , "b":2, "c":3}' AS JSONB) - 'a';
SELECT CAST('{"a":null , "b":2, "c":3}' AS JSONB) - 'a';
SELECT CAST('{"a":1 , "b":2, "c":3}' AS JSONB) - 'b';
SELECT CAST('{"a":1 , "b":2, "c":3}' AS JSONB) - 'c';
SELECT CAST('{"a":1 , "b":2, "c":3}' AS JSONB) - 'd';
SELECT PG_COLUMN_SIZE(CAST('{"a":1 , "b":2, "c":3}' AS JSONB) - 'b') = PG_COLUMN_SIZE(CAST('{"a":1, "b":2}' AS JSONB));
SELECT CAST('["a","b","c"]' AS JSONB) - 3;
SELECT CAST('["a","b","c"]' AS JSONB) - 2;
SELECT CAST('["a","b","c"]' AS JSONB) - 1;
SELECT CAST('["a","b","c"]' AS JSONB) - 0;
SELECT CAST('["a","b","c"]' AS JSONB) - -1;
SELECT CAST('["a","b","c"]' AS JSONB) - -2;
SELECT CAST('["a","b","c"]' AS JSONB) - -3;
SELECT CAST('["a","b","c"]' AS JSONB) - -4;
SELECT CAST('{"a":1 , "b":2, "c":3}' AS JSONB) - CAST('{b}' AS ARRAY<TEXT>);
SELECT CAST('{"a":1 , "b":2, "c":3}' AS JSONB) - CAST('{c,b}' AS ARRAY<TEXT>);
SELECT CAST('{"a":1 , "b":2, "c":3}' AS JSONB) - CAST('{}' AS ARRAY<TEXT>);
SELECT JSONB_SET(CAST('{"n":null, "a":1, "b":[1,2], "c":{"1":2}, "d":{"1":[2,3]}}' AS JSONB), '{n}', '[1,2,3]');
SELECT JSONB_SET(CAST('{"n":null, "a":1, "b":[1,2], "c":{"1":2}, "d":{"1":[2,3]}}' AS JSONB), '{b,-1}', '[1,2,3]');
SELECT JSONB_SET(CAST('{"n":null, "a":1, "b":[1,2], "c":{"1":2}, "d":{"1":[2,3]}}' AS JSONB), '{d,1,0}', '[1,2,3]');
SELECT JSONB_SET(CAST('{"n":null, "a":1, "b":[1,2], "c":{"1":2}, "d":{"1":[2,3]}}' AS JSONB), '{d,NULL,0}', '[1,2,3]');
SELECT JSONB_SET(CAST('{"n":null, "a":1, "b":[1,2], "c":{"1":2}, "d":{"1":[2,3]}}' AS JSONB), '{n}', '{"1": 2}');
SELECT JSONB_SET(CAST('{"n":null, "a":1, "b":[1,2], "c":{"1":2}, "d":{"1":[2,3]}}' AS JSONB), '{b,-1}', '{"1": 2}');
SELECT JSONB_SET(CAST('{"n":null, "a":1, "b":[1,2], "c":{"1":2}, "d":{"1":[2,3]}}' AS JSONB), '{d,1,0}', '{"1": 2}');
SELECT JSONB_SET(CAST('{"n":null, "a":1, "b":[1,2], "c":{"1":2}, "d":{"1":[2,3]}}' AS JSONB), '{d,NULL,0}', '{"1": 2}');
SELECT JSONB_SET(CAST('{"n":null, "a":1, "b":[1,2], "c":{"1":2}, "d":{"1":[2,3]}}' AS JSONB), '{b,-1}', '"test"');
SELECT JSONB_SET(CAST('{"n":null, "a":1, "b":[1,2], "c":{"1":2}, "d":{"1":[2,3]}}' AS JSONB), '{b,-1}', '{"f": "test"}');
SELECT JSONB_DELETE_PATH('{"n":null, "a":1, "b":[1,2], "c":{"1":2}, "d":{"1":[2,3]}}', '{n}');
SELECT JSONB_DELETE_PATH('{"n":null, "a":1, "b":[1,2], "c":{"1":2}, "d":{"1":[2,3]}}', '{b,-1}');
SELECT JSONB_DELETE_PATH('{"n":null, "a":1, "b":[1,2], "c":{"1":2}, "d":{"1":[2,3]}}', '{d,1,0}');
SELECT JSONB_DELETE_PATH('{"a":[]}', '{"a",-2147483648}');
SELECT CAST('{"n":null, "a":1, "b":[1,2], "c":{"1":2}, "d":{"1":[2,3]}}' AS JSONB) ^ -'{n}';
SELECT CAST('{"n":null, "a":1, "b":[1,2], "c":{"1":2}, "d":{"1":[2,3]}}' AS JSONB) ^ -'{b,-1}';
SELECT CAST('{"n":null, "a":1, "b":[1,2], "c":{"1":2}, "d":{"1":[2,3]}}' AS JSONB) ^ -'{b,-1e}';
/* invalid array subscript */ SELECT CAST('{"n":null, "a":1, "b":[1,2], "c":{"1":2}, "d":{"1":[2,3]}}' AS JSONB) ^ -'{d,1,0}';
/* empty structure and error conditions for delete and replace */ SELECT CAST('"a"' AS JSONB) - 'a';
/* error */ SELECT CAST('{}' AS JSONB) - 'a';
SELECT CAST('[]' AS JSONB) - 'a';
SELECT CAST('"a"' AS JSONB) - 1;
/* error */ SELECT CAST('{}' AS JSONB) - 1;
/* error */ SELECT CAST('[]' AS JSONB) - 1;
SELECT CAST('"a"' AS JSONB) ^ -'{a}';
/* error */ SELECT CAST('{}' AS JSONB) ^ -'{a}';
SELECT CAST('[]' AS JSONB) ^ -'{a}';
SELECT JSONB_SET('"a"', '{a}', '"b"');
/* error */ SELECT JSONB_SET('{}', '{a}', '"b"', FALSE);
SELECT JSONB_SET('[]', '{1}', '"b"', FALSE);
SELECT JSONB_SET('[{"f1":1,"f2":null},2,null,3]', '{0}', '[2,3,4]', FALSE);
/* jsonb_set adding instead of replacing */ /* prepend to array */ SELECT JSONB_SET('{"a":1,"b":[0,1,2],"c":{"d":4}}', '{b,-33}', '{"foo":123}');
/* append to array */ SELECT JSONB_SET('{"a":1,"b":[0,1,2],"c":{"d":4}}', '{b,33}', '{"foo":123}');
/* check nesting levels addition */ SELECT JSONB_SET('{"a":1,"b":[4,5,[0,1,2],6,7],"c":{"d":4}}', '{b,2,33}', '{"foo":123}');
/* add new key */ SELECT JSONB_SET('{"a":1,"b":[0,1,2],"c":{"d":4}}', '{c,e}', '{"foo":123}');
/* adding doesn't do anything if elements before last aren't present */ SELECT JSONB_SET('{"a":1,"b":[0,1,2],"c":{"d":4}}', '{x,-33}', '{"foo":123}');
SELECT JSONB_SET('{"a":1,"b":[0,1,2],"c":{"d":4}}', '{x,y}', '{"foo":123}');
/* add to empty object */ SELECT JSONB_SET('{}', '{x}', '{"foo":123}');
/* add to empty array */ SELECT JSONB_SET('[]', '{0}', '{"foo":123}');
SELECT JSONB_SET('[]', '{99}', '{"foo":123}');
SELECT JSONB_SET('[]', '{-99}', '{"foo":123}');
SELECT JSONB_SET('{"a": [1, 2, 3]}', '{a, non_integer}', '"new_value"');
SELECT JSONB_SET('{"a": {"b": [1, 2, 3]}}', '{a, b, non_integer}', '"new_value"');
SELECT JSONB_SET('{"a": {"b": [1, 2, 3]}}', '{a, b, NULL}', '"new_value"');
SELECT JSONB_SET_LAX('{"a":1,"b":2}', '{d}', '6', TRUE);
/* using the default treatment */ SELECT JSONB_SET_LAX('{"a":1,"b":2}', '{b}', NULL);
SELECT JSONB_SET_LAX('{"a":1,"b":2}', '{d}', NULL, TRUE);
/* errors */ SELECT JSONB_SET_LAX('{"a":1,"b":2}', '{b}', NULL, TRUE, NULL);
SELECT JSONB_SET_LAX('{"a":1,"b":2}', '{b}', NULL, TRUE, 'no_such_treatment');
/* explicit treatments */ SELECT JSONB_SET_LAX('{"a":1,"b":2}', '{b}', NULL, null_value_treatment => 'raise_exception') AS x;
SELECT JSONB_SET_LAX('{"a":1,"b":2}', '{b}', NULL, null_value_treatment => 'return_target') AS x;
SELECT JSONB_SET_LAX('{"a":1,"b":2}', '{b}', NULL, null_value_treatment => 'delete_key') AS x;
SELECT JSONB_SET_LAX('{"a":1,"b":2}', '{b}', NULL, null_value_treatment => 'use_json_null') AS x;
SELECT JSONB_INSERT('{"a": [0,1,2]}', '{a, 1}', '"new_value"', TRUE);
SELECT JSONB_INSERT('{"a": {"b": {"c": [0, 1, "test1", "test2"]}}}', '{a, b, c, 2}', '"new_value"');
SELECT JSONB_INSERT('{"a": {"b": {"c": [0, 1, "test1", "test2"]}}}', '{a, b, c, 2}', '"new_value"', TRUE);
SELECT JSONB_INSERT('{"a": [0,1,2]}', '{a, 1}', '{"b": "value"}');
SELECT JSONB_INSERT('{"a": [0,1,2]}', '{a, 1}', '["value1", "value2"]');
/* edge cases */ SELECT JSONB_INSERT('{"a": [0,1,2]}', '{a, 0}', '"new_value"');
SELECT JSONB_INSERT('{"a": [0,1,2]}', '{a, 0}', '"new_value"', TRUE);
SELECT JSONB_INSERT('{"a": [0,1,2]}', '{a, 2}', '"new_value"');
SELECT JSONB_INSERT('{"a": [0,1,2]}', '{a, 2}', '"new_value"', TRUE);
SELECT JSONB_INSERT('{"a": [0,1,2]}', '{a, -1}', '"new_value"');
SELECT JSONB_INSERT('{"a": [0,1,2]}', '{a, -1}', '"new_value"', TRUE);
SELECT JSONB_INSERT('[]', '{1}', '"new_value"');
SELECT JSONB_INSERT('[]', '{1}', '"new_value"', TRUE);
SELECT JSONB_INSERT('{"a": []}', '{a, 1}', '"new_value"');
SELECT JSONB_INSERT('{"a": []}', '{a, 1}', '"new_value"', TRUE);
SELECT JSONB_INSERT('{"a": [0,1,2]}', '{a, 10}', '"new_value"');
SELECT JSONB_INSERT('{"a": [0,1,2]}', '{a, -10}', '"new_value"');
/* jsonb_insert should be able to insert new value for objects, but not to replace */ SELECT JSONB_INSERT('{"a": {"b": "value"}}', '{a, c}', '"new_value"');
SELECT JSONB_INSERT('{"a": {"b": "value"}}', '{a, c}', '"new_value"', TRUE);
SELECT JSONB_INSERT('{"a": {"b": "value"}}', '{a, b}', '"new_value"');
SELECT JSONB_INSERT('{"a": {"b": "value"}}', '{a, b}', '"new_value"', TRUE);
/* jsonb subscript */ SELECT (CAST('123' AS JSONB))['a'];
SELECT (CAST('123' AS JSONB))[0];
SELECT (CAST('123' AS JSONB))[NULL];
SELECT (CAST('{"a": 1}' AS JSONB))['a'];
SELECT (CAST('{"a": 1}' AS JSONB))[0];
SELECT (CAST('{"a": 1}' AS JSONB))['not_exist'];
SELECT (CAST('{"a": 1}' AS JSONB))[NULL];
SELECT (CAST('[1, "2", null]' AS JSONB))['a'];
SELECT (CAST('[1, "2", null]' AS JSONB))[0];
SELECT (CAST('[1, "2", null]' AS JSONB))['1'];
SELECT (CAST('[1, "2", null]' AS JSONB))[1.0];
SELECT (CAST('[1, "2", null]' AS JSONB))[2];
SELECT (CAST('[1, "2", null]' AS JSONB))[3];
SELECT (CAST('[1, "2", null]' AS JSONB))[-2];
SELECT (CAST('[1, "2", null]' AS JSONB))[1]['a'];
SELECT (CAST('[1, "2", null]' AS JSONB))[1][-1];
SELECT (CAST('{"a": 1, "b": "c", "d": [1, 2, 3]}' AS JSONB))['b'];
SELECT (CAST('{"a": 1, "b": "c", "d": [1, 2, 3]}' AS JSONB))['d'];
SELECT (CAST('{"a": 1, "b": "c", "d": [1, 2, 3]}' AS JSONB))['d'][0];
SELECT (CAST('{"a": 1, "b": "c", "d": [1, 2, 3]}' AS JSONB))['d']['a'];
SELECT (CAST('{"a": {"a1": {"a2": "aaa"}}, "b": "bbb", "c": "ccc"}' AS JSONB))['a']['a1'];
SELECT (CAST('{"a": {"a1": {"a2": "aaa"}}, "b": "bbb", "c": "ccc"}' AS JSONB))['a']['a1']['a2'];
SELECT (CAST('{"a": {"a1": {"a2": "aaa"}}, "b": "bbb", "c": "ccc"}' AS JSONB))['a']['a1']['a2']['a3'];
SELECT (CAST('{"a": ["a1", {"b1": ["aaa", "bbb", "ccc"]}], "b": "bb"}' AS JSONB))['a'][0]['b1'];
SELECT (CAST('{"a": ["a1", {"b1": ["aaa", "bbb", "ccc"]}], "b": "bb"}' AS JSONB))['a'][0]['b1'][1];
/* slices are not supported */ SELECT (CAST('{"a": 1}' AS JSONB))['a' : 'b'];
SELECT (CAST('[1, "2", null]' AS JSONB))[1 : 2];
SELECT (CAST('[1, "2", null]' AS JSONB))[ : 2];
SELECT (CAST('[1, "2", null]' AS JSONB))[1 : ];
SELECT (CAST('[1, "2", null]' AS JSONB))[ : ];
CREATE TEMPORARY TABLE x (x INT, x JSONB);
INSERT INTO x VALUES (1, '{}') /* empty jsonb */, (2, '{"key": "value"}');
/* jsonb with data */ /* update empty jsonb */ UPDATE x SET x['a'] = '1' WHERE x = 1;
SELECT * FROM x;
/* update jsonb with some data */ UPDATE x SET x['a'] = '1' WHERE x = 2;
SELECT * FROM x;
/* replace jsonb */ UPDATE x SET x['a'] = '"test"';
SELECT * FROM x;
/* replace by object */ UPDATE x SET x['a'] = CAST('{"b": 1}' AS JSONB);
SELECT * FROM x;
/* replace by array */ UPDATE x SET x['a'] = CAST('[1, 2, 3]' AS JSONB);
SELECT * FROM x;
/* use jsonb subscription in where clause */ SELECT * FROM x WHERE x['key'] = '"value"';
SELECT * FROM x WHERE x['key_doesnt_exists'] = '"value"';
SELECT * FROM x WHERE x['key'] = '"wrong_value"';
/* NULL */ UPDATE x SET x[NULL] = '1';
UPDATE x SET x['another_key'] = NULL;
SELECT * FROM x;
/* NULL as jsonb source */ INSERT INTO x VALUES (3, NULL);
UPDATE x SET x['a'] = '1' WHERE x = 3;
SELECT * FROM x;
UPDATE x SET x = NULL WHERE x = 3;
UPDATE x SET x[-1] = '1';
SELECT * FROM x;
/* Fill the gaps logic */ DELETE FROM x;
INSERT INTO x VALUES (1, '[0]');
UPDATE x SET x[4] = '1';
SELECT * FROM x;
UPDATE x SET x[-5] = '1';
SELECT * FROM x;
UPDATE x SET x[-9] = '1';
SELECT * FROM x;
/* keep consistent values position */ DELETE FROM x;
INSERT INTO x VALUES (1, '[]');
UPDATE x SET x[4] = '1';
SELECT * FROM x;
/* create the whole path */ DELETE FROM x;
INSERT INTO x VALUES (1, '{}');
UPDATE x SET x['a'][-1]['b'][-1]['c'] = '1';
SELECT * FROM x;
DELETE FROM x;
INSERT INTO x VALUES (1, '{}');
UPDATE x SET x['a'][1]['b'][1]['c'][1] = '1';
SELECT * FROM x;
/* create the whole path with already existing keys */ DELETE FROM x;
INSERT INTO x VALUES (1, '{"b": 1}');
UPDATE x SET x['a'][-1] = '2';
SELECT * FROM x;
/* the start jsonb is an object, first subscript is treated as a key */ DELETE FROM x;
INSERT INTO x VALUES (1, '{}');
UPDATE x SET x[-1]['a'] = '1';
SELECT * FROM x;
/* the start jsonb is an array */ DELETE FROM x;
INSERT INTO x VALUES (1, '[]');
UPDATE x SET x[-1]['a'] = '1';
UPDATE x SET x[1]['b'] = '2';
SELECT * FROM x;
/* overwriting an existing path */ DELETE FROM x;
INSERT INTO x VALUES (1, '{}');
UPDATE x SET x['a']['b'][0] = '1';
UPDATE x SET x['a']['b'][9] = '1';
SELECT * FROM x;
DELETE FROM x;
INSERT INTO x VALUES (1, '[]');
UPDATE x SET x[-1][-1][-1] = '1';
UPDATE x SET x[-1][-1][0] = '1';
SELECT * FROM x;
DELETE FROM x;
INSERT INTO x VALUES (1, '{}');
UPDATE x SET x['a']['b'][9] = '1';
UPDATE x SET x['a'][9][9] = '1';
SELECT * FROM x;
/* an empty sub element */ DELETE FROM x;
INSERT INTO x VALUES (1, '{"a": {}}');
UPDATE x SET x['a']['b']['c'][1] = '1';
SELECT * FROM x;
DELETE FROM x;
INSERT INTO x VALUES (1, '{"a": []}');
UPDATE x SET x['a'][0]['c'][1] = '1';
SELECT * FROM x;
/* trying replace assuming a composite object, but it's an element or a value */ DELETE FROM x;
INSERT INTO x VALUES (1, '{"a": 1}');
UPDATE x SET x['a']['b'] = '1';
UPDATE x SET x['a']['b']['c'] = '1';
UPDATE x SET x['a'][-1] = '1';
UPDATE x SET x['a'][-1]['c'] = '1';
UPDATE x SET x['a'][-1][-1] = '1';
/* trying replace assuming a composite object, but it's a raw scalar */ DELETE FROM x;
INSERT INTO x VALUES (1, 'null');
UPDATE x SET x[-1] = '1';
UPDATE x SET x[-1][-1] = '1';
/* try some things with short-header and toasted subscript values */ DROP TABLE x;
CREATE TEMPORARY TABLE x (x TEXT, x JSONB);
INSERT INTO x VALUES ('foo', '{"foo": "bar"}');
INSERT INTO x SELECT x, CAST(('{"' || x || '": "bar"}') AS JSONB) FROM x AS x;
SELECT LENGTH(x), x[x] FROM x;
UPDATE x SET x[x] = '"baz"';
SELECT LENGTH(x), x[x] FROM x;
/* jsonb to tsvector with config */ SELECT TO_TSVECTOR('simple', CAST('{"a": "aaa bbb ddd ccc", "b": ["eee fff ggg"], "c": {"d": "hhh iii"}}' AS JSONB));
/* jsonb to tsvector with stop words */ SELECT TO_TSVECTOR('english', CAST('{"a": "aaa in bbb ddd ccc", "b": ["the eee fff ggg"], "c": {"d": "hhh. iii"}}' AS JSONB));
/* jsonb to tsvector with numeric values */ SELECT TO_TSVECTOR('english', CAST('{"a": "aaa in bbb ddd ccc", "b": 123, "c": 456}' AS JSONB));
/* jsonb_to_tsvector */ SELECT JSONB_TO_TSVECTOR('english', CAST('{"a": "aaa in bbb", "b": 123, "c": 456, "d": true, "f": false, "g": null}' AS JSONB), '"all"');
SELECT JSONB_TO_TSVECTOR('english', CAST('{"a": "aaa in bbb", "b": 123, "c": 456, "d": true, "f": false, "g": null}' AS JSONB), '"key"');
SELECT JSONB_TO_TSVECTOR('english', CAST('{"a": "aaa in bbb", "b": 123, "c": 456, "d": true, "f": false, "g": null}' AS JSONB), '"string"');
SELECT JSONB_TO_TSVECTOR('english', CAST('{"a": "aaa in bbb", "b": 123, "c": 456, "d": true, "f": false, "g": null}' AS JSONB), '"numeric"');
SELECT JSONB_TO_TSVECTOR('english', CAST('{"a": "aaa in bbb", "b": 123, "c": 456, "d": true, "f": false, "g": null}' AS JSONB), '"boolean"');
SELECT JSONB_TO_TSVECTOR('english', CAST('{"a": "aaa in bbb", "b": 123, "c": 456, "d": true, "f": false, "g": null}' AS JSONB), '["string", "numeric"]');
SELECT JSONB_TO_TSVECTOR('english', CAST('{"a": "aaa in bbb", "b": 123, "c": 456, "d": true, "f": false, "g": null}' AS JSONB), '"all"');
SELECT JSONB_TO_TSVECTOR('english', CAST('{"a": "aaa in bbb", "b": 123, "c": 456, "d": true, "f": false, "g": null}' AS JSONB), '"key"');
SELECT JSONB_TO_TSVECTOR('english', CAST('{"a": "aaa in bbb", "b": 123, "c": 456, "d": true, "f": false, "g": null}' AS JSONB), '"string"');
SELECT JSONB_TO_TSVECTOR('english', CAST('{"a": "aaa in bbb", "b": 123, "c": 456, "d": true, "f": false, "g": null}' AS JSONB), '"numeric"');
SELECT JSONB_TO_TSVECTOR('english', CAST('{"a": "aaa in bbb", "b": 123, "c": 456, "d": true, "f": false, "g": null}' AS JSONB), '"boolean"');
SELECT JSONB_TO_TSVECTOR('english', CAST('{"a": "aaa in bbb", "b": 123, "c": 456, "d": true, "f": false, "g": null}' AS JSONB), '["string", "numeric"]');
/* to_tsvector corner cases */ SELECT TO_TSVECTOR(CAST('""' AS JSONB));
SELECT TO_TSVECTOR(CAST('{}' AS JSONB));
SELECT TO_TSVECTOR(CAST('[]' AS JSONB));
SELECT TO_TSVECTOR(CAST('null' AS JSONB));
/* jsonb_to_tsvector corner cases */ SELECT JSONB_TO_TSVECTOR(CAST('""' AS JSONB), '"all"');
SELECT JSONB_TO_TSVECTOR(CAST('{}' AS JSONB), '"all"');
SELECT JSONB_TO_TSVECTOR(CAST('[]' AS JSONB), '"all"');
SELECT JSONB_TO_TSVECTOR(CAST('null' AS JSONB), '"all"');
SELECT JSONB_TO_TSVECTOR('english', CAST('{"a": "aaa in bbb", "b": 123, "c": 456, "d": true, "f": false, "g": null}' AS JSONB), '""');
SELECT JSONB_TO_TSVECTOR('english', CAST('{"a": "aaa in bbb", "b": 123, "c": 456, "d": true, "f": false, "g": null}' AS JSONB), '{}');
SELECT JSONB_TO_TSVECTOR('english', CAST('{"a": "aaa in bbb", "b": 123, "c": 456, "d": true, "f": false, "g": null}' AS JSONB), '[]');
SELECT JSONB_TO_TSVECTOR('english', CAST('{"a": "aaa in bbb", "b": 123, "c": 456, "d": true, "f": false, "g": null}' AS JSONB), 'null');
SELECT JSONB_TO_TSVECTOR('english', CAST('{"a": "aaa in bbb", "b": 123, "c": 456, "d": true, "f": false, "g": null}' AS JSONB), '["all", null]');
/* ts_headline for jsonb */ SELECT TS_HEADLINE(CAST('{"a": "aaa bbb", "b": {"c": "ccc ddd fff", "c1": "ccc1 ddd1"}, "d": ["ggg hhh", "iii jjj"]}' AS JSONB), TSQUERY('bbb & ddd & hhh'));
SELECT TS_HEADLINE('english', CAST('{"a": "aaa bbb", "b": {"c": "ccc ddd fff"}, "d": ["ggg hhh", "iii jjj"]}' AS JSONB), TSQUERY('bbb & ddd & hhh'));
SELECT TS_HEADLINE(CAST('{"a": "aaa bbb", "b": {"c": "ccc ddd fff", "c1": "ccc1 ddd1"}, "d": ["ggg hhh", "iii jjj"]}' AS JSONB), TSQUERY('bbb & ddd & hhh'), 'StartSel = <, StopSel = >');
SELECT TS_HEADLINE('english', CAST('{"a": "aaa bbb", "b": {"c": "ccc ddd fff", "c1": "ccc1 ddd1"}, "d": ["ggg hhh", "iii jjj"]}' AS JSONB), TSQUERY('bbb & ddd & hhh'), 'StartSel = <, StopSel = >');
/* corner cases for ts_headline with jsonb */ SELECT TS_HEADLINE(CAST('null' AS JSONB), TSQUERY('aaa & bbb'));
SELECT TS_HEADLINE(CAST('{}' AS JSONB), TSQUERY('aaa & bbb'));
SELECT TS_HEADLINE(CAST('[]' AS JSONB), TSQUERY('aaa & bbb'));
/* casts */ SELECT CAST(CAST('true' AS JSONB) AS BOOLEAN);
SELECT CAST(CAST('null' AS JSONB) AS BOOLEAN);
SELECT CAST(CAST('[]' AS JSONB) AS BOOLEAN);
SELECT CAST(CAST('1.0' AS JSONB) AS DOUBLE);
SELECT CAST(CAST('null' AS JSONB) AS DOUBLE);
SELECT CAST(CAST('[1.0]' AS JSONB) AS DOUBLE);
SELECT CAST(CAST('1.0' AS JSONB) AS FLOAT);
SELECT CAST(CAST('null' AS JSONB) AS FLOAT);
SELECT CAST(CAST('[1.0]' AS JSONB) AS FLOAT);
SELECT CAST(CAST('12345' AS JSONB) AS SMALLINT);
SELECT CAST(CAST('null' AS JSONB) AS SMALLINT);
SELECT CAST(CAST('"hello"' AS JSONB) AS SMALLINT);
SELECT CAST(CAST('12345' AS JSONB) AS INT);
SELECT CAST(CAST('null' AS JSONB) AS INT);
SELECT CAST(CAST('"hello"' AS JSONB) AS INT);
SELECT CAST(CAST('12345' AS JSONB) AS BIGINT);
SELECT CAST(CAST('null' AS JSONB) AS BIGINT);
SELECT CAST(CAST('"hello"' AS JSONB) AS BIGINT);
SELECT CAST(CAST('12345' AS JSONB) AS DECIMAL);
SELECT CAST(CAST('null' AS JSONB) AS DECIMAL);
SELECT CAST(CAST('{}' AS JSONB) AS DECIMAL);
SELECT CAST(CAST('12345.05' AS JSONB) AS DECIMAL);
SELECT CAST(CAST('12345.05' AS JSONB) AS FLOAT);
SELECT CAST(CAST('12345.05' AS JSONB) AS DOUBLE);
SELECT CAST(CAST('12345.05' AS JSONB) AS SMALLINT);
SELECT CAST(CAST('12345.05' AS JSONB) AS INT);
SELECT CAST(CAST('12345.05' AS JSONB) AS BIGINT);
SELECT CAST(CAST('12345.0000000000000000000000000000000000000000000005' AS JSONB) AS DECIMAL);
SELECT CAST(CAST('12345.0000000000000000000000000000000000000000000005' AS JSONB) AS FLOAT);
SELECT CAST(CAST('12345.0000000000000000000000000000000000000000000005' AS JSONB) AS DOUBLE);
SELECT CAST(CAST('12345.0000000000000000000000000000000000000000000005' AS JSONB) AS SMALLINT);
SELECT CAST(CAST('12345.0000000000000000000000000000000000000000000005' AS JSONB) AS INT);
SELECT CAST(CAST('12345.0000000000000000000000000000000000000000000005' AS JSONB) AS BIGINT);
SELECT JSONB_PATH_QUERY('[1]', 'strict $[1]');
SELECT JSONB_PATH_QUERY('[1]', 'strict $[1]', silent => TRUE);
SELECT JSONB_PATH_QUERY('[1]', 'lax $[10000000000000000]');
SELECT JSONB_PATH_QUERY('[1]', 'strict $[10000000000000000]');
SELECT JSONB_PATH_EXISTS('[{"a": 1}, {"a": 2}, 3]', 'lax $[*].a', silent => FALSE);
SELECT JSONB_PATH_EXISTS('[{"a": 1}, {"a": 2}, 3]', 'lax $[*].a', silent => TRUE);
SELECT JSONB_PATH_EXISTS('[{"a": 1}, {"a": 2}, 3]', 'strict $[*].a', silent => FALSE);
SELECT JSONB_PATH_EXISTS('[{"a": 1}, {"a": 2}, 3]', 'strict $[*].a', silent => TRUE);
SELECT JSONB_PATH_QUERY('1', 'lax $.a');
SELECT JSONB_PATH_QUERY('1', 'strict $.a');
SELECT JSONB_PATH_QUERY('1', 'strict $.*');
SELECT JSONB_PATH_QUERY('1', 'strict $.a', silent => TRUE);
SELECT JSONB_PATH_QUERY('1', 'strict $.*', silent => TRUE);
SELECT JSONB_PATH_QUERY('[]', 'lax $.a');
SELECT JSONB_PATH_QUERY('[]', 'strict $.a');
SELECT JSONB_PATH_QUERY('[]', 'strict $.a', silent => TRUE);
SELECT JSONB_PATH_QUERY('{}', 'lax $.a');
SELECT JSONB_PATH_QUERY('{}', 'strict $.a');
SELECT JSONB_PATH_QUERY('{}', 'strict $.a', silent => TRUE);
SELECT JSONB_PATH_QUERY('1', 'strict $[1]');
SELECT JSONB_PATH_QUERY('1', 'strict $[*]');
SELECT JSONB_PATH_QUERY('[]', 'strict $[1]');
SELECT JSONB_PATH_QUERY('[]', 'strict $["a"]');
SELECT JSONB_PATH_QUERY('1', 'strict $[1]', silent => TRUE);
SELECT JSONB_PATH_QUERY('1', 'strict $[*]', silent => TRUE);
SELECT JSONB_PATH_QUERY('[]', 'strict $[1]', silent => TRUE);
SELECT JSONB_PATH_QUERY('[]', 'strict $["a"]', silent => TRUE);
SELECT JSONB_PATH_QUERY('{"a": 12, "b": {"a": 13}}', '$.a');
SELECT JSONB_PATH_QUERY('{"a": 12, "b": {"a": 13}}', '$.b');
SELECT JSONB_PATH_QUERY('{"a": 12, "b": {"a": 13}}', '$.*');
SELECT JSONB_PATH_QUERY('{"a": 12, "b": {"a": 13}}', 'lax $.*.a');
SELECT JSONB_PATH_QUERY('[12, {"a": 13}, {"b": 14}]', 'lax $[*].a');
SELECT JSONB_PATH_QUERY('[12, {"a": 13}, {"b": 14}]', 'lax $[*].*');
SELECT JSONB_PATH_QUERY('[12, {"a": 13}, {"b": 14}]', 'lax $[0].a');
SELECT JSONB_PATH_QUERY('[12, {"a": 13}, {"b": 14}]', 'lax $[1].a');
SELECT JSONB_PATH_QUERY('[12, {"a": 13}, {"b": 14}]', 'lax $[2].a');
SELECT JSONB_PATH_QUERY('[12, {"a": 13}, {"b": 14}]', 'lax $[0,1].a');
SELECT JSONB_PATH_QUERY('[12, {"a": 13}, {"b": 14}]', 'lax $[0 to 10].a');
SELECT JSONB_PATH_QUERY('[12, {"a": 13}, {"b": 14}]', 'lax $[0 to 10 / 0].a');
SELECT JSONB_PATH_QUERY('[12, {"a": 13}, {"b": 14}, "ccc", true]', '$[2.5 - 1 to $.size() - 2]');
SELECT JSONB_PATH_QUERY('1', 'lax $[0]');
SELECT JSONB_PATH_QUERY('1', 'lax $[*]');
SELECT JSONB_PATH_QUERY('[1]', 'lax $[0]');
SELECT JSONB_PATH_QUERY('[1]', 'lax $[*]');
SELECT JSONB_PATH_QUERY('[1,2,3]', 'lax $[*]');
SELECT JSONB_PATH_QUERY('[1,2,3]', 'strict $[*].a');
SELECT JSONB_PATH_QUERY('[1,2,3]', 'strict $[*].a', silent => TRUE);
SELECT JSONB_PATH_QUERY('[]', '$[last]');
SELECT JSONB_PATH_QUERY('[]', '$[last ? (exists(last))]');
SELECT JSONB_PATH_QUERY('[]', 'strict $[last]');
SELECT JSONB_PATH_QUERY('[]', 'strict $[last]', silent => TRUE);
SELECT JSONB_PATH_QUERY('[1]', '$[last]');
SELECT JSONB_PATH_QUERY('[1,2,3]', '$[last]');
SELECT JSONB_PATH_QUERY('[1,2,3]', '$[last - 1]');
SELECT JSONB_PATH_QUERY('[1,2,3]', '$[last ? (@.type() == "number")]');
SELECT JSONB_PATH_QUERY('[1,2,3]', '$[last ? (@.type() == "string")]');
SELECT JSONB_PATH_QUERY('[1,2,3]', '$[last ? (@.type() == "string")]', silent => TRUE);
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT JSONB_PATH_QUERY('{"a": {"b": 1}}', 'lax $.**');
SELECT JSONB_PATH_QUERY('{"a": {"b": 1}}', 'lax $.**{0}');
SELECT JSONB_PATH_QUERY('{"a": {"b": 1}}', 'lax $.**{0 to last}');
SELECT JSONB_PATH_QUERY('{"a": {"b": 1}}', 'lax $.**{1}');
SELECT JSONB_PATH_QUERY('{"a": {"b": 1}}', 'lax $.**{1 to last}');
SELECT JSONB_PATH_QUERY('{"a": {"b": 1}}', 'lax $.**{2}');
SELECT JSONB_PATH_QUERY('{"a": {"b": 1}}', 'lax $.**{2 to last}');
SELECT JSONB_PATH_QUERY('{"a": {"b": 1}}', 'lax $.**{3 to last}');
SELECT JSONB_PATH_QUERY('{"a": {"b": 1}}', 'lax $.**{last}');
SELECT JSONB_PATH_QUERY('{"a": {"b": 1}}', 'lax $.**.b ? (@ > 0)');
SELECT JSONB_PATH_QUERY('{"a": {"b": 1}}', 'lax $.**{0}.b ? (@ > 0)');
SELECT JSONB_PATH_QUERY('{"a": {"b": 1}}', 'lax $.**{1}.b ? (@ > 0)');
SELECT JSONB_PATH_QUERY('{"a": {"b": 1}}', 'lax $.**{0 to last}.b ? (@ > 0)');
SELECT JSONB_PATH_QUERY('{"a": {"b": 1}}', 'lax $.**{1 to last}.b ? (@ > 0)');
SELECT JSONB_PATH_QUERY('{"a": {"b": 1}}', 'lax $.**{1 to 2}.b ? (@ > 0)');
SELECT JSONB_PATH_QUERY('{"a": {"c": {"b": 1}}}', 'lax $.**.b ? (@ > 0)');
SELECT JSONB_PATH_QUERY('{"a": {"c": {"b": 1}}}', 'lax $.**{0}.b ? (@ > 0)');
SELECT JSONB_PATH_QUERY('{"a": {"c": {"b": 1}}}', 'lax $.**{1}.b ? (@ > 0)');
SELECT JSONB_PATH_QUERY('{"a": {"c": {"b": 1}}}', 'lax $.**{0 to last}.b ? (@ > 0)');
SELECT JSONB_PATH_QUERY('{"a": {"c": {"b": 1}}}', 'lax $.**{1 to last}.b ? (@ > 0)');
SELECT JSONB_PATH_QUERY('{"a": {"c": {"b": 1}}}', 'lax $.**{1 to 2}.b ? (@ > 0)');
SELECT JSONB_PATH_QUERY('{"a": {"c": {"b": 1}}}', 'lax $.**{2 to 3}.b ? (@ > 0)');
SELECT JSONB_PATH_QUERY('{"g": {"x": 2}}', '$.g ? (exists (@.x))');
SELECT JSONB_PATH_QUERY('{"g": {"x": 2}}', '$.g ? (exists (@.y))');
SELECT JSONB_PATH_QUERY('{"g": {"x": 2}}', '$.g ? (exists (@.x ? (@ >= 2) ))');
SELECT JSONB_PATH_QUERY('{"g": [{"x": 2}, {"y": 3}]}', 'lax $.g ? (exists (@.x))');
SELECT JSONB_PATH_QUERY('{"g": [{"x": 2}, {"y": 3}]}', 'lax $.g ? (exists (@.x + "3"))');
SELECT JSONB_PATH_QUERY('{"g": [{"x": 2}, {"y": 3}]}', 'lax $.g ? ((exists (@.x + "3")) is unknown)');
SELECT JSONB_PATH_QUERY('{"g": [{"x": 2}, {"y": 3}]}', 'strict $.g[*] ? (exists (@.x))');
SELECT JSONB_PATH_QUERY('{"g": [{"x": 2}, {"y": 3}]}', 'strict $.g[*] ? ((exists (@.x)) is unknown)');
SELECT JSONB_PATH_QUERY('{"g": [{"x": 2}, {"y": 3}]}', 'strict $.g ? (exists (@[*].x))');
SELECT JSONB_PATH_QUERY('{"g": [{"x": 2}, {"y": 3}]}', 'strict $.g ? ((exists (@[*].x)) is unknown)');
/* test ternary logic */ SELECT x, x, JSONB_PATH_QUERY('[true, false, null]', '$[*] ? (@ == true  &&  ($x == true && $y == true) || 				 @ == false && !($x == true && $y == true) || 				 @ == null  &&  ($x == true && $y == true) is unknown)', JSONB_BUILD_OBJECT('x', x, 'y', x)) AS "x" FROM (VALUES (CAST('true' AS JSONB)), ('false'), ('"null"')) AS x, (VALUES (CAST('true' AS JSONB)), ('false'), ('"null"')) AS x;
SELECT x, x, JSONB_PATH_QUERY('[true, false, null]', '$[*] ? (@ == true  &&  ($x == true || $y == true) || 				 @ == false && !($x == true || $y == true) || 				 @ == null  &&  ($x == true || $y == true) is unknown)', JSONB_BUILD_OBJECT('x', x, 'y', x)) AS "x" FROM (VALUES (CAST('true' AS JSONB)), ('false'), ('"null"')) AS x, (VALUES (CAST('true' AS JSONB)), ('false'), ('"null"')) AS x;
SELECT JSONB_PATH_QUERY('{"c": {"a": 2, "b":1}}', '$.** ? (@.a == 1 + 1)');
SELECT JSONB_PATH_QUERY('{"c": {"a": 2, "b":1}}', '$.** ? (@.a == (1 + 1))');
SELECT JSONB_PATH_QUERY('{"c": {"a": 2, "b":1}}', '$.** ? (@.a == @.b + 1)');
SELECT JSONB_PATH_QUERY('{"c": {"a": 2, "b":1}}', '$.** ? (@.a == (@.b + 1))');
/* arithmetic errors */ SELECT JSONB_PATH_QUERY('[1,2,0,3]', '$[*] ? (2 / @ > 0)');
SELECT JSONB_PATH_QUERY('[1,2,0,3]', '$[*] ? ((2 / @ > 0) is unknown)');
SELECT JSONB_PATH_QUERY('0', '1 / $');
SELECT JSONB_PATH_QUERY('0', '1 / $ + 2');
SELECT JSONB_PATH_QUERY('0', '-(3 + 1 % $)');
SELECT JSONB_PATH_QUERY('1', '$ + "2"');
SELECT JSONB_PATH_QUERY('[1, 2]', '3 * $');
SELECT JSONB_PATH_QUERY('"a"', '-$');
SELECT JSONB_PATH_QUERY('[1,"2",3]', '+$');
SELECT JSONB_PATH_QUERY('1', '$ + "2"', silent => TRUE);
SELECT JSONB_PATH_QUERY('[1, 2]', '3 * $', silent => TRUE);
SELECT JSONB_PATH_QUERY('"a"', '-$', silent => TRUE);
SELECT JSONB_PATH_QUERY('[1,"2",3]', '+$', silent => TRUE);
/* unwrapping of operator arguments in lax mode */ SELECT JSONB_PATH_QUERY('{"a": [2]}', 'lax $.a * 3');
SELECT JSONB_PATH_QUERY('{"a": [2]}', 'lax $.a + 3');
SELECT JSONB_PATH_QUERY('{"a": [2, 3, 4]}', 'lax -$.a');
/* should fail */ SELECT JSONB_PATH_QUERY('{"a": [1, 2]}', 'lax $.a * 3');
SELECT JSONB_PATH_QUERY('{"a": [1, 2]}', 'lax $.a * 3', silent => TRUE);
/* any key on arrays with and without unwrapping. */ SELECT JSONB_PATH_QUERY('{"a": [1,2,3], "b": [3,4,5]}', '$.*');
SELECT JSONB_PATH_QUERY('[1,2,3]', '$.*');
SELECT JSONB_PATH_QUERY('[1,2,3,{"b": [3,4,5]}]', 'lax $.*');
SELECT JSONB_PATH_QUERY('[1,2,3,{"b": [3,4,5]}]', 'strict $.*');
SELECT JSONB_PATH_QUERY('[1,2,3,{"b": [3,4,5]}]', 'strict $.*', NULL, TRUE);
/* extension: boolean expressions */ SELECT JSONB_PATH_QUERY('2', '$ > 1');
SELECT JSONB_PATH_QUERY('2', '$ <= 1');
SELECT JSONB_PATH_QUERY('2', '$ == "2"');
SELECT MATCH(CAST('2' AS JSONB)) AGAINST('$ > 1');
SELECT MATCH(CAST('2' AS JSONB)) AGAINST('$ <= 1');
SELECT MATCH(CAST('2' AS JSONB)) AGAINST('$ == "2"');
SELECT MATCH(CAST('2' AS JSONB)) AGAINST('1');
SELECT MATCH(CAST('{}' AS JSONB)) AGAINST('$');
SELECT MATCH(CAST('[]' AS JSONB)) AGAINST('$');
SELECT MATCH(CAST('[1,2,3]' AS JSONB)) AGAINST('$[*]');
SELECT MATCH(CAST('[]' AS JSONB)) AGAINST('$[*]');
SELECT JSONB_PATH_MATCH('[[1, true], [2, false]]', 'strict $[*] ? (@[0] > $x) [1]', '{"x": 1}');
SELECT JSONB_PATH_MATCH('[[1, true], [2, false]]', 'strict $[*] ? (@[0] < $x) [1]', '{"x": 2}');
SELECT JSONB_PATH_MATCH('[{"a": 1}, {"a": 2}, 3]', 'lax exists($[*].a)', silent => FALSE);
SELECT JSONB_PATH_MATCH('[{"a": 1}, {"a": 2}, 3]', 'lax exists($[*].a)', silent => TRUE);
SELECT JSONB_PATH_MATCH('[{"a": 1}, {"a": 2}, 3]', 'strict exists($[*].a)', silent => FALSE);
SELECT JSONB_PATH_MATCH('[{"a": 1}, {"a": 2}, 3]', 'strict exists($[*].a)', silent => TRUE);
SELECT JSONB_PATH_QUERY('[null,1,true,"a",[],{}]', '$.type()');
SELECT JSONB_PATH_QUERY('[null,1,true,"a",[],{}]', 'lax $.type()');
SELECT JSONB_PATH_QUERY('[null,1,true,"a",[],{}]', '$[*].type()');
SELECT JSONB_PATH_QUERY('null', 'null.type()');
SELECT JSONB_PATH_QUERY('null', 'true.type()');
SELECT JSONB_PATH_QUERY('null', '(123).type()');
SELECT JSONB_PATH_QUERY('null', '"123".type()');
SELECT JSONB_PATH_QUERY('{"a": 2}', '($.a - 5).abs() + 10');
SELECT JSONB_PATH_QUERY('{"a": 2.5}', '-($.a * $.a).floor() % 4.3');
SELECT JSONB_PATH_QUERY('[1, 2, 3]', '($[*] > 2) ? (@ == true)');
SELECT JSONB_PATH_QUERY('[1, 2, 3]', '($[*] > 3).type()');
SELECT JSONB_PATH_QUERY('[1, 2, 3]', '($[*].a > 3).type()');
SELECT JSONB_PATH_QUERY('[1, 2, 3]', 'strict ($[*].a > 3).type()');
SELECT JSONB_PATH_QUERY('[1,null,true,"11",[],[1],[1,2,3],{},{"a":1,"b":2}]', 'strict $[*].size()');
SELECT JSONB_PATH_QUERY('[1,null,true,"11",[],[1],[1,2,3],{},{"a":1,"b":2}]', 'strict $[*].size()', silent => TRUE);
SELECT JSONB_PATH_QUERY('[1,null,true,"11",[],[1],[1,2,3],{},{"a":1,"b":2}]', 'lax $[*].size()');
SELECT JSONB_PATH_QUERY('[0, 1, -2, -3.4, 5.6]', '$[*].abs()');
SELECT JSONB_PATH_QUERY('[0, 1, -2, -3.4, 5.6]', '$[*].floor()');
SELECT JSONB_PATH_QUERY('[0, 1, -2, -3.4, 5.6]', '$[*].ceiling()');
SELECT JSONB_PATH_QUERY('[0, 1, -2, -3.4, 5.6]', '$[*].ceiling().abs()');
SELECT JSONB_PATH_QUERY('[0, 1, -2, -3.4, 5.6]', '$[*].ceiling().abs().type()');
SELECT JSONB_PATH_QUERY('[{},1]', '$[*].keyvalue()');
SELECT JSONB_PATH_QUERY('[{},1]', '$[*].keyvalue()', silent => TRUE);
SELECT JSONB_PATH_QUERY('{}', '$.keyvalue()');
SELECT JSONB_PATH_QUERY('{"a": 1, "b": [1, 2], "c": {"a": "bbb"}}', '$.keyvalue()');
SELECT JSONB_PATH_QUERY('[{"a": 1, "b": [1, 2]}, {"c": {"a": "bbb"}}]', '$[*].keyvalue()');
SELECT JSONB_PATH_QUERY('[{"a": 1, "b": [1, 2]}, {"c": {"a": "bbb"}}]', 'strict $.keyvalue()');
SELECT JSONB_PATH_QUERY('[{"a": 1, "b": [1, 2]}, {"c": {"a": "bbb"}}]', 'lax $.keyvalue()');
SELECT JSONB_PATH_QUERY('[{"a": 1, "b": [1, 2]}, {"c": {"a": "bbb"}}]', 'strict $.keyvalue().a');
SELECT JSONB_PATH_QUERY('null', '$.double()');
SELECT JSONB_PATH_QUERY('true', '$.double()');
SELECT JSONB_PATH_QUERY('null', '$.double()', silent => TRUE);
SELECT JSONB_PATH_QUERY('true', '$.double()', silent => TRUE);
SELECT JSONB_PATH_QUERY('[]', '$.double()');
SELECT JSONB_PATH_QUERY('[]', 'strict $.double()');
SELECT JSONB_PATH_QUERY('{}', '$.double()');
SELECT JSONB_PATH_QUERY('[]', 'strict $.double()', silent => TRUE);
SELECT JSONB_PATH_QUERY('{}', '$.double()', silent => TRUE);
SELECT JSONB_PATH_QUERY('1.23', '$.double()');
SELECT JSONB_PATH_QUERY('"1.23"', '$.double()');
SELECT JSONB_PATH_QUERY('"1.23aaa"', '$.double()');
SELECT JSONB_PATH_QUERY('1e1000', '$.double()');
SELECT JSONB_PATH_QUERY('"nan"', '$.double()');
SELECT JSONB_PATH_QUERY('"NaN"', '$.double()');
SELECT JSONB_PATH_QUERY('"inf"', '$.double()');
SELECT JSONB_PATH_QUERY('"-inf"', '$.double()');
SELECT JSONB_PATH_QUERY('"inf"', '$.double()', silent => TRUE);
SELECT JSONB_PATH_QUERY('"-inf"', '$.double()', silent => TRUE);
SELECT JSONB_PATH_QUERY('{}', '$.abs()');
SELECT JSONB_PATH_QUERY('true', '$.floor()');
SELECT JSONB_PATH_QUERY('"1.2"', '$.ceiling()');
SELECT JSONB_PATH_QUERY('{}', '$.abs()', silent => TRUE);
SELECT JSONB_PATH_QUERY('true', '$.floor()', silent => TRUE);
SELECT JSONB_PATH_QUERY('"1.2"', '$.ceiling()', silent => TRUE);
SELECT JSONB_PATH_QUERY('["", "a", "abc", "abcabc"]', '$[*] ? (@ starts with "abc")');
SELECT JSONB_PATH_QUERY('["", "a", "abc", "abcabc"]', 'strict $ ? (@[*] starts with "abc")');
SELECT JSONB_PATH_QUERY('["", "a", "abd", "abdabc"]', 'strict $ ? (@[*] starts with "abc")');
SELECT JSONB_PATH_QUERY('["abc", "abcabc", null, 1]', 'strict $ ? (@[*] starts with "abc")');
SELECT JSONB_PATH_QUERY('["abc", "abcabc", null, 1]', 'strict $ ? ((@[*] starts with "abc") is unknown)');
SELECT JSONB_PATH_QUERY('[[null, 1, "abc", "abcabc"]]', 'lax $ ? (@[*] starts with "abc")');
SELECT JSONB_PATH_QUERY('[[null, 1, "abd", "abdabc"]]', 'lax $ ? ((@[*] starts with "abc") is unknown)');
SELECT JSONB_PATH_QUERY('[null, 1, "abd", "abdabc"]', 'lax $[*] ? ((@ starts with "abc") is unknown)');
SELECT JSONB_PATH_QUERY('[null, 1, "abc", "abd", "aBdC", "abdacb", "babc", "adc\nabc", "ab\nadc"]', 'lax $[*] ? (@ like_regex "^ab.*c")');
SELECT JSONB_PATH_QUERY('[null, 1, "abc", "abd", "aBdC", "abdacb", "babc", "adc\nabc", "ab\nadc"]', 'lax $[*] ? (@ like_regex "^ab.*c" flag "i")');
SELECT JSONB_PATH_QUERY('[null, 1, "abc", "abd", "aBdC", "abdacb", "babc", "adc\nabc", "ab\nadc"]', 'lax $[*] ? (@ like_regex "^ab.*c" flag "m")');
SELECT JSONB_PATH_QUERY('[null, 1, "abc", "abd", "aBdC", "abdacb", "babc", "adc\nabc", "ab\nadc"]', 'lax $[*] ? (@ like_regex "^ab.*c" flag "s")');
SELECT JSONB_PATH_QUERY('[null, 1, "a\b", "a\\b", "^a\\b$"]', 'lax $[*] ? (@ like_regex "a\\b" flag "q")');
SELECT JSONB_PATH_QUERY('[null, 1, "a\b", "a\\b", "^a\\b$"]', 'lax $[*] ? (@ like_regex "a\\b" flag "")');
SELECT JSONB_PATH_QUERY('[null, 1, "a\b", "a\\b", "^a\\b$"]', 'lax $[*] ? (@ like_regex "^a\\b$" flag "q")');
SELECT JSONB_PATH_QUERY('[null, 1, "a\b", "a\\b", "^a\\b$"]', 'lax $[*] ? (@ like_regex "^a\\B$" flag "q")');
SELECT JSONB_PATH_QUERY('[null, 1, "a\b", "a\\b", "^a\\b$"]', 'lax $[*] ? (@ like_regex "^a\\B$" flag "iq")');
SELECT JSONB_PATH_QUERY('[null, 1, "a\b", "a\\b", "^a\\b$"]', 'lax $[*] ? (@ like_regex "^a\\b$" flag "")');
SELECT JSONB_PATH_QUERY('null', '$.datetime()');
SELECT JSONB_PATH_QUERY('true', '$.datetime()');
SELECT JSONB_PATH_QUERY('1', '$.datetime()');
SELECT JSONB_PATH_QUERY('[]', '$.datetime()');
SELECT JSONB_PATH_QUERY('[]', 'strict $.datetime()');
SELECT JSONB_PATH_QUERY('{}', '$.datetime()');
SELECT JSONB_PATH_QUERY('"bogus"', '$.datetime()');
SELECT JSONB_PATH_QUERY('"12:34"', '$.datetime("aaa")');
SELECT JSONB_PATH_QUERY('"aaaa"', '$.datetime("HH24")');
SELECT JSONB_PATH_QUERY('"10-03-2017"', '$.datetime("dd-mm-yyyy")');
SELECT JSONB_PATH_QUERY('"10-03-2017"', '$.datetime("dd-mm-yyyy").type()');
SELECT JSONB_PATH_QUERY('"10-03-2017 12:34"', '$.datetime("dd-mm-yyyy")');
SELECT JSONB_PATH_QUERY('"10-03-2017 12:34"', '$.datetime("dd-mm-yyyy").type()');
SELECT JSONB_PATH_QUERY('"10-03-2017 12:34"', '       $.datetime("dd-mm-yyyy HH24:MI").type()');
SELECT JSONB_PATH_QUERY('"10-03-2017 12:34 +05:20"', '$.datetime("dd-mm-yyyy HH24:MI TZH:TZM").type()');
SELECT JSONB_PATH_QUERY('"12:34:56"', '$.datetime("HH24:MI:SS").type()');
SELECT JSONB_PATH_QUERY('"12:34:56 +05:20"', '$.datetime("HH24:MI:SS TZH:TZM").type()');
SELECT JSONB_PATH_QUERY('"10-03-2017T12:34:56"', '$.datetime("dd-mm-yyyy\"T\"HH24:MI:SS")');
SELECT JSONB_PATH_QUERY('"10-03-2017t12:34:56"', '$.datetime("dd-mm-yyyy\"T\"HH24:MI:SS")');
SELECT JSONB_PATH_QUERY('"10-03-2017 12:34:56"', '$.datetime("dd-mm-yyyy\"T\"HH24:MI:SS")');
/* Test .bigint() */ SELECT JSONB_PATH_QUERY('null', '$.bigint()');
SELECT JSONB_PATH_QUERY('true', '$.bigint()');
SELECT JSONB_PATH_QUERY('null', '$.bigint()', silent => TRUE);
SELECT JSONB_PATH_QUERY('true', '$.bigint()', silent => TRUE);
SELECT JSONB_PATH_QUERY('[]', '$.bigint()');
SELECT JSONB_PATH_QUERY('[]', 'strict $.bigint()');
SELECT JSONB_PATH_QUERY('{}', '$.bigint()');
SELECT JSONB_PATH_QUERY('[]', 'strict $.bigint()', silent => TRUE);
SELECT JSONB_PATH_QUERY('{}', '$.bigint()', silent => TRUE);
SELECT JSONB_PATH_QUERY('"1.23"', '$.bigint()');
SELECT JSONB_PATH_QUERY('"1.23aaa"', '$.bigint()');
SELECT JSONB_PATH_QUERY('1e1000', '$.bigint()');
SELECT JSONB_PATH_QUERY('"nan"', '$.bigint()');
SELECT JSONB_PATH_QUERY('"NaN"', '$.bigint()');
SELECT JSONB_PATH_QUERY('"inf"', '$.bigint()');
SELECT JSONB_PATH_QUERY('"-inf"', '$.bigint()');
SELECT JSONB_PATH_QUERY('"inf"', '$.bigint()', silent => TRUE);
SELECT JSONB_PATH_QUERY('"-inf"', '$.bigint()', silent => TRUE);
SELECT JSONB_PATH_QUERY('123', '$.bigint()');
SELECT JSONB_PATH_QUERY('"123"', '$.bigint()');
SELECT JSONB_PATH_QUERY('1.23', '$.bigint()');
SELECT JSONB_PATH_QUERY('1.83', '$.bigint()');
SELECT JSONB_PATH_QUERY('1234567890123', '$.bigint()');
SELECT JSONB_PATH_QUERY('"1234567890123"', '$.bigint()');
SELECT JSONB_PATH_QUERY('12345678901234567890', '$.bigint()');
SELECT JSONB_PATH_QUERY('"12345678901234567890"', '$.bigint()');
SELECT JSONB_PATH_QUERY('"+123"', '$.bigint()');
SELECT JSONB_PATH_QUERY('-123', '$.bigint()');
SELECT JSONB_PATH_QUERY('"-123"', '$.bigint()');
SELECT JSONB_PATH_QUERY('123', '$.bigint() * 2');
/* Test .boolean() */ SELECT JSONB_PATH_QUERY('null', '$.boolean()');
SELECT JSONB_PATH_QUERY('null', '$.boolean()', silent => TRUE);
SELECT JSONB_PATH_QUERY('[]', '$.boolean()');
SELECT JSONB_PATH_QUERY('[]', 'strict $.boolean()');
SELECT JSONB_PATH_QUERY('{}', '$.boolean()');
SELECT JSONB_PATH_QUERY('[]', 'strict $.boolean()', silent => TRUE);
SELECT JSONB_PATH_QUERY('{}', '$.boolean()', silent => TRUE);
SELECT JSONB_PATH_QUERY('1.23', '$.boolean()');
SELECT JSONB_PATH_QUERY('"1.23"', '$.boolean()');
SELECT JSONB_PATH_QUERY('"1.23aaa"', '$.boolean()');
SELECT JSONB_PATH_QUERY('1e1000', '$.boolean()');
SELECT JSONB_PATH_QUERY('"nan"', '$.boolean()');
SELECT JSONB_PATH_QUERY('"NaN"', '$.boolean()');
SELECT JSONB_PATH_QUERY('"inf"', '$.boolean()');
SELECT JSONB_PATH_QUERY('"-inf"', '$.boolean()');
SELECT JSONB_PATH_QUERY('"inf"', '$.boolean()', silent => TRUE);
SELECT JSONB_PATH_QUERY('"-inf"', '$.boolean()', silent => TRUE);
SELECT JSONB_PATH_QUERY('"100"', '$.boolean()');
SELECT JSONB_PATH_QUERY('true', '$.boolean()');
SELECT JSONB_PATH_QUERY('false', '$.boolean()');
SELECT JSONB_PATH_QUERY('1', '$.boolean()');
SELECT JSONB_PATH_QUERY('0', '$.boolean()');
SELECT JSONB_PATH_QUERY('-1', '$.boolean()');
SELECT JSONB_PATH_QUERY('100', '$.boolean()');
SELECT JSONB_PATH_QUERY('"1"', '$.boolean()');
SELECT JSONB_PATH_QUERY('"0"', '$.boolean()');
SELECT JSONB_PATH_QUERY('"true"', '$.boolean()');
SELECT JSONB_PATH_QUERY('"false"', '$.boolean()');
SELECT JSONB_PATH_QUERY('"TRUE"', '$.boolean()');
SELECT JSONB_PATH_QUERY('"FALSE"', '$.boolean()');
SELECT JSONB_PATH_QUERY('"yes"', '$.boolean()');
SELECT JSONB_PATH_QUERY('"NO"', '$.boolean()');
SELECT JSONB_PATH_QUERY('"T"', '$.boolean()');
SELECT JSONB_PATH_QUERY('"f"', '$.boolean()');
SELECT JSONB_PATH_QUERY('"y"', '$.boolean()');
SELECT JSONB_PATH_QUERY('"N"', '$.boolean()');
SELECT JSONB_PATH_QUERY('true', '$.boolean().type()');
SELECT JSONB_PATH_QUERY('123', '$.boolean().type()');
SELECT JSONB_PATH_QUERY('"Yes"', '$.boolean().type()');
SELECT JSONB_PATH_QUERY_ARRAY('[1, "yes", false]', '$[*].boolean()');
/* Test .date() */ SELECT JSONB_PATH_QUERY('null', '$.date()');
SELECT JSONB_PATH_QUERY('true', '$.date()');
SELECT JSONB_PATH_QUERY('1', '$.date()');
SELECT JSONB_PATH_QUERY('[]', '$.date()');
SELECT JSONB_PATH_QUERY('[]', 'strict $.date()');
SELECT JSONB_PATH_QUERY('{}', '$.date()');
SELECT JSONB_PATH_QUERY('"bogus"', '$.date()');
SELECT JSONB_PATH_QUERY('"2023-08-15"', '$.date()');
SELECT JSONB_PATH_QUERY('"2023-08-15"', '$.date().type()');
SELECT JSONB_PATH_QUERY('"12:34:56"', '$.date()');
SELECT JSONB_PATH_QUERY('"12:34:56 +05:30"', '$.date()');
SELECT JSONB_PATH_QUERY('"2023-08-15 12:34:56"', '$.date()');
SELECT JSONB_PATH_QUERY('"2023-08-15 12:34:56 +05:30"', '$.date()');
SELECT JSONB_PATH_QUERY_TZ('"2023-08-15 12:34:56 +05:30"', '$.date()');
/* should work */ SELECT JSONB_PATH_QUERY('"2023-08-15"', '$.date(2)');
/* Test .decimal() */ SELECT JSONB_PATH_QUERY('null', '$.decimal()');
SELECT JSONB_PATH_QUERY('true', '$.decimal()');
SELECT JSONB_PATH_QUERY('null', '$.decimal()', silent => TRUE);
SELECT JSONB_PATH_QUERY('true', '$.decimal()', silent => TRUE);
SELECT JSONB_PATH_QUERY('[]', '$.decimal()');
SELECT JSONB_PATH_QUERY('[]', 'strict $.decimal()');
SELECT JSONB_PATH_QUERY('{}', '$.decimal()');
SELECT JSONB_PATH_QUERY('[]', 'strict $.decimal()', silent => TRUE);
SELECT JSONB_PATH_QUERY('{}', '$.decimal()', silent => TRUE);
SELECT JSONB_PATH_QUERY('1.23', '$.decimal()');
SELECT JSONB_PATH_QUERY('"1.23"', '$.decimal()');
SELECT JSONB_PATH_QUERY('"1.23aaa"', '$.decimal()');
SELECT JSONB_PATH_QUERY('1e1000', '$.decimal()');
SELECT JSONB_PATH_QUERY('"nan"', '$.decimal()');
SELECT JSONB_PATH_QUERY('"NaN"', '$.decimal()');
SELECT JSONB_PATH_QUERY('"inf"', '$.decimal()');
SELECT JSONB_PATH_QUERY('"-inf"', '$.decimal()');
SELECT JSONB_PATH_QUERY('"inf"', '$.decimal()', silent => TRUE);
SELECT JSONB_PATH_QUERY('"-inf"', '$.decimal()', silent => TRUE);
SELECT JSONB_PATH_QUERY('123', '$.decimal()');
SELECT JSONB_PATH_QUERY('"123"', '$.decimal()');
SELECT JSONB_PATH_QUERY('12345678901234567890', '$.decimal()');
SELECT JSONB_PATH_QUERY('"12345678901234567890"', '$.decimal()');
SELECT JSONB_PATH_QUERY('"+12.3"', '$.decimal()');
SELECT JSONB_PATH_QUERY('-12.3', '$.decimal()');
SELECT JSONB_PATH_QUERY('"-12.3"', '$.decimal()');
SELECT JSONB_PATH_QUERY('12.3', '$.decimal() * 2');
SELECT JSONB_PATH_QUERY('12345.678', '$.decimal(6, 1)');
SELECT JSONB_PATH_QUERY('12345.678', '$.decimal(6, 2)');
SELECT JSONB_PATH_QUERY('1234.5678', '$.decimal(6, 2)');
SELECT JSONB_PATH_QUERY('12345.678', '$.decimal(4, 6)');
SELECT JSONB_PATH_QUERY('12345.678', '$.decimal(0, 6)');
SELECT JSONB_PATH_QUERY('12345.678', '$.decimal(1001, 6)');
SELECT JSONB_PATH_QUERY('1234.5678', '$.decimal(+6, +2)');
SELECT JSONB_PATH_QUERY('1234.5678', '$.decimal(+6, -2)');
SELECT JSONB_PATH_QUERY('1234.5678', '$.decimal(-6, +2)');
SELECT JSONB_PATH_QUERY('1234.5678', '$.decimal(6, -1001)');
SELECT JSONB_PATH_QUERY('1234.5678', '$.decimal(6, 1001)');
SELECT JSONB_PATH_QUERY('-1234.5678', '$.decimal(+6, -2)');
SELECT JSONB_PATH_QUERY('0.0123456', '$.decimal(1,2)');
SELECT JSONB_PATH_QUERY('0.0012345', '$.decimal(2,4)');
SELECT JSONB_PATH_QUERY('-0.00123456', '$.decimal(2,-4)');
SELECT JSONB_PATH_QUERY('12.3', '$.decimal(12345678901,1)');
SELECT JSONB_PATH_QUERY('12.3', '$.decimal(1,12345678901)');
/* Test .integer() */ SELECT JSONB_PATH_QUERY('null', '$.integer()');
SELECT JSONB_PATH_QUERY('true', '$.integer()');
SELECT JSONB_PATH_QUERY('null', '$.integer()', silent => TRUE);
SELECT JSONB_PATH_QUERY('true', '$.integer()', silent => TRUE);
SELECT JSONB_PATH_QUERY('[]', '$.integer()');
SELECT JSONB_PATH_QUERY('[]', 'strict $.integer()');
SELECT JSONB_PATH_QUERY('{}', '$.integer()');
SELECT JSONB_PATH_QUERY('[]', 'strict $.integer()', silent => TRUE);
SELECT JSONB_PATH_QUERY('{}', '$.integer()', silent => TRUE);
SELECT JSONB_PATH_QUERY('"1.23"', '$.integer()');
SELECT JSONB_PATH_QUERY('"1.23aaa"', '$.integer()');
SELECT JSONB_PATH_QUERY('1e1000', '$.integer()');
SELECT JSONB_PATH_QUERY('"nan"', '$.integer()');
SELECT JSONB_PATH_QUERY('"NaN"', '$.integer()');
SELECT JSONB_PATH_QUERY('"inf"', '$.integer()');
SELECT JSONB_PATH_QUERY('"-inf"', '$.integer()');
SELECT JSONB_PATH_QUERY('"inf"', '$.integer()', silent => TRUE);
SELECT JSONB_PATH_QUERY('"-inf"', '$.integer()', silent => TRUE);
SELECT JSONB_PATH_QUERY('123', '$.integer()');
SELECT JSONB_PATH_QUERY('"123"', '$.integer()');
SELECT JSONB_PATH_QUERY('1.23', '$.integer()');
SELECT JSONB_PATH_QUERY('1.83', '$.integer()');
SELECT JSONB_PATH_QUERY('12345678901', '$.integer()');
SELECT JSONB_PATH_QUERY('"12345678901"', '$.integer()');
SELECT JSONB_PATH_QUERY('"+123"', '$.integer()');
SELECT JSONB_PATH_QUERY('-123', '$.integer()');
SELECT JSONB_PATH_QUERY('"-123"', '$.integer()');
SELECT JSONB_PATH_QUERY('123', '$.integer() * 2');
/* Test .number() */ SELECT JSONB_PATH_QUERY('null', '$.number()');
SELECT JSONB_PATH_QUERY('true', '$.number()');
SELECT JSONB_PATH_QUERY('null', '$.number()', silent => TRUE);
SELECT JSONB_PATH_QUERY('true', '$.number()', silent => TRUE);
SELECT JSONB_PATH_QUERY('[]', '$.number()');
SELECT JSONB_PATH_QUERY('[]', 'strict $.number()');
SELECT JSONB_PATH_QUERY('{}', '$.number()');
SELECT JSONB_PATH_QUERY('[]', 'strict $.number()', silent => TRUE);
SELECT JSONB_PATH_QUERY('{}', '$.number()', silent => TRUE);
SELECT JSONB_PATH_QUERY('1.23', '$.number()');
SELECT JSONB_PATH_QUERY('"1.23"', '$.number()');
SELECT JSONB_PATH_QUERY('"1.23aaa"', '$.number()');
SELECT JSONB_PATH_QUERY('1e1000', '$.number()');
SELECT JSONB_PATH_QUERY('"nan"', '$.number()');
SELECT JSONB_PATH_QUERY('"NaN"', '$.number()');
SELECT JSONB_PATH_QUERY('"inf"', '$.number()');
SELECT JSONB_PATH_QUERY('"-inf"', '$.number()');
SELECT JSONB_PATH_QUERY('"inf"', '$.number()', silent => TRUE);
SELECT JSONB_PATH_QUERY('"-inf"', '$.number()', silent => TRUE);
SELECT JSONB_PATH_QUERY('123', '$.number()');
SELECT JSONB_PATH_QUERY('"123"', '$.number()');
SELECT JSONB_PATH_QUERY('12345678901234567890', '$.number()');
SELECT JSONB_PATH_QUERY('"12345678901234567890"', '$.number()');
SELECT JSONB_PATH_QUERY('"+12.3"', '$.number()');
SELECT JSONB_PATH_QUERY('-12.3', '$.number()');
SELECT JSONB_PATH_QUERY('"-12.3"', '$.number()');
SELECT JSONB_PATH_QUERY('12.3', '$.number() * 2');
/* Test .string() */ SELECT JSONB_PATH_QUERY('null', '$.string()');
SELECT JSONB_PATH_QUERY('null', '$.string()', silent => TRUE);
SELECT JSONB_PATH_QUERY('[]', '$.string()');
SELECT JSONB_PATH_QUERY('[]', 'strict $.string()');
SELECT JSONB_PATH_QUERY('{}', '$.string()');
SELECT JSONB_PATH_QUERY('[]', 'strict $.string()', silent => TRUE);
SELECT JSONB_PATH_QUERY('{}', '$.string()', silent => TRUE);
SELECT JSONB_PATH_QUERY('1.23', '$.string()');
SELECT JSONB_PATH_QUERY('"1.23"', '$.string()');
SELECT JSONB_PATH_QUERY('"1.23aaa"', '$.string()');
SELECT JSONB_PATH_QUERY('1234', '$.string()');
SELECT JSONB_PATH_QUERY('true', '$.string()');
SELECT JSONB_PATH_QUERY('1234', '$.string().type()');
SELECT JSONB_PATH_QUERY('[2, true]', '$.string()');
SELECT JSONB_PATH_QUERY_ARRAY('[1.23, "yes", false]', '$[*].string()');
SELECT JSONB_PATH_QUERY_ARRAY('[1.23, "yes", false]', '$[*].string().type()');
SELECT JSONB_PATH_QUERY('"2023-08-15 12:34:56 +5:30"', '$.timestamp().string()');
SELECT JSONB_PATH_QUERY_TZ('"2023-08-15 12:34:56 +5:30"', '$.timestamp().string()');
/* should work */ SELECT JSONB_PATH_QUERY('"2023-08-15 12:34:56"', '$.timestamp_tz().string()');
SELECT JSONB_PATH_QUERY_TZ('"2023-08-15 12:34:56"', '$.timestamp_tz().string()');
/* should work */ SELECT JSONB_PATH_QUERY('"2023-08-15 12:34:56 +5:30"', '$.timestamp_tz().string()');
SELECT JSONB_PATH_QUERY('"2023-08-15 12:34:56"', '$.timestamp().string()');
SELECT JSONB_PATH_QUERY('"12:34:56 +5:30"', '$.time_tz().string()');
/* this timetz usage will absorb the UTC offset of the current timezone setting */ BEGIN;
SET LOCAL x = 'UTC-10';
SELECT JSONB_PATH_QUERY_TZ('"12:34:56"', '$.time_tz().string()');
ROLLBACK;
SELECT JSONB_PATH_QUERY('"12:34:56"', '$.time().string()');
SELECT JSONB_PATH_QUERY('"2023-08-15"', '$.date().string()');
/* .string() does not react to timezone or datestyle */ BEGIN;
SET LOCAL x = 'UTC';
SET LOCAL x = 'German';
SELECT JSONB_PATH_QUERY('"2023-08-15 12:34:56 +5:30"', '$.timestamp_tz().string()');
SELECT JSONB_PATH_QUERY('"2023-08-15 12:34:56"', '$.timestamp().string()');
ROLLBACK;
/* Test .time() */ SELECT JSONB_PATH_QUERY('null', '$.time()');
SELECT JSONB_PATH_QUERY('true', '$.time()');
SELECT JSONB_PATH_QUERY('1', '$.time()');
SELECT JSONB_PATH_QUERY('[]', '$.time()');
SELECT JSONB_PATH_QUERY('[]', 'strict $.time()');
SELECT JSONB_PATH_QUERY('{}', '$.time()');
SELECT JSONB_PATH_QUERY('"bogus"', '$.time()');
SELECT JSONB_PATH_QUERY('"12:34:56"', '$.time()');
SELECT JSONB_PATH_QUERY('"12:34:56"', '$.time().type()');
SELECT JSONB_PATH_QUERY('"2023-08-15"', '$.time()');
SELECT JSONB_PATH_QUERY('"12:34:56 +05:30"', '$.time()');
SELECT JSONB_PATH_QUERY_TZ('"12:34:56 +05:30"', '$.time()');
/* should work */ SELECT JSONB_PATH_QUERY('"2023-08-15 12:34:56"', '$.time()');
SELECT JSONB_PATH_QUERY('"12:34:56.789"', '$.time(-1)');
SELECT JSONB_PATH_QUERY('"12:34:56.789"', '$.time(2.0)');
SELECT JSONB_PATH_QUERY('"12:34:56.789"', '$.time(12345678901)');
SELECT JSONB_PATH_QUERY('"12:34:56.789"', '$.time(0)');
SELECT JSONB_PATH_QUERY('"12:34:56.789"', '$.time(2)');
SELECT JSONB_PATH_QUERY('"12:34:56.789"', '$.time(5)');
SELECT JSONB_PATH_QUERY('"12:34:56.789"', '$.time(10)');
SELECT JSONB_PATH_QUERY('"12:34:56.789012"', '$.time(8)');
/* Test .time_tz() */ SELECT JSONB_PATH_QUERY('null', '$.time_tz()');
SELECT JSONB_PATH_QUERY('true', '$.time_tz()');
SELECT JSONB_PATH_QUERY('1', '$.time_tz()');
SELECT JSONB_PATH_QUERY('[]', '$.time_tz()');
SELECT JSONB_PATH_QUERY('[]', 'strict $.time_tz()');
SELECT JSONB_PATH_QUERY('{}', '$.time_tz()');
SELECT JSONB_PATH_QUERY('"bogus"', '$.time_tz()');
SELECT JSONB_PATH_QUERY('"12:34:56 +05:30"', '$.time_tz()');
SELECT JSONB_PATH_QUERY('"12:34:56 +05:30"', '$.time_tz().type()');
SELECT JSONB_PATH_QUERY('"2023-08-15"', '$.time_tz()');
SELECT JSONB_PATH_QUERY('"2023-08-15 12:34:56"', '$.time_tz()');
SELECT JSONB_PATH_QUERY('"12:34:56.789 +05:30"', '$.time_tz(-1)');
SELECT JSONB_PATH_QUERY('"12:34:56.789 +05:30"', '$.time_tz(2.0)');
SELECT JSONB_PATH_QUERY('"12:34:56.789 +05:30"', '$.time_tz(12345678901)');
SELECT JSONB_PATH_QUERY('"12:34:56.789 +05:30"', '$.time_tz(0)');
SELECT JSONB_PATH_QUERY('"12:34:56.789 +05:30"', '$.time_tz(2)');
SELECT JSONB_PATH_QUERY('"12:34:56.789 +05:30"', '$.time_tz(5)');
SELECT JSONB_PATH_QUERY('"12:34:56.789 +05:30"', '$.time_tz(10)');
SELECT JSONB_PATH_QUERY('"12:34:56.789012 +05:30"', '$.time_tz(8)');
/* Test .timestamp() */ SELECT JSONB_PATH_QUERY('null', '$.timestamp()');
SELECT JSONB_PATH_QUERY('true', '$.timestamp()');
SELECT JSONB_PATH_QUERY('1', '$.timestamp()');
SELECT JSONB_PATH_QUERY('[]', '$.timestamp()');
SELECT JSONB_PATH_QUERY('[]', 'strict $.timestamp()');
SELECT JSONB_PATH_QUERY('{}', '$.timestamp()');
SELECT JSONB_PATH_QUERY('"bogus"', '$.timestamp()');
SELECT JSONB_PATH_QUERY('"2023-08-15 12:34:56"', '$.timestamp()');
SELECT JSONB_PATH_QUERY('"2023-08-15 12:34:56"', '$.timestamp().type()');
SELECT JSONB_PATH_QUERY('"2023-08-15"', '$.timestamp()');
SELECT JSONB_PATH_QUERY('"12:34:56"', '$.timestamp()');
SELECT JSONB_PATH_QUERY('"12:34:56 +05:30"', '$.timestamp()');
SELECT JSONB_PATH_QUERY('"2023-08-15 12:34:56.789"', '$.timestamp(-1)');
SELECT JSONB_PATH_QUERY('"2023-08-15 12:34:56.789"', '$.timestamp(2.0)');
SELECT JSONB_PATH_QUERY('"2023-08-15 12:34:56.789"', '$.timestamp(12345678901)');
SELECT JSONB_PATH_QUERY('"2023-08-15 12:34:56.789"', '$.timestamp(0)');
SELECT JSONB_PATH_QUERY('"2023-08-15 12:34:56.789"', '$.timestamp(2)');
SELECT JSONB_PATH_QUERY('"2023-08-15 12:34:56.789"', '$.timestamp(5)');
SELECT JSONB_PATH_QUERY('"2023-08-15 12:34:56.789"', '$.timestamp(10)');
SELECT JSONB_PATH_QUERY('"2023-08-15 12:34:56.789012"', '$.timestamp(8)');
/* Test .timestamp_tz() */ SELECT JSONB_PATH_QUERY('null', '$.timestamp_tz()');
SELECT JSONB_PATH_QUERY('true', '$.timestamp_tz()');
SELECT JSONB_PATH_QUERY('1', '$.timestamp_tz()');
SELECT JSONB_PATH_QUERY('[]', '$.timestamp_tz()');
SELECT JSONB_PATH_QUERY('[]', 'strict $.timestamp_tz()');
SELECT JSONB_PATH_QUERY('{}', '$.timestamp_tz()');
SELECT JSONB_PATH_QUERY('"bogus"', '$.timestamp_tz()');
SELECT JSONB_PATH_QUERY('"2023-08-15 12:34:56 +05:30"', '$.timestamp_tz()');
SELECT JSONB_PATH_QUERY('"2023-08-15 12:34:56 +05:30"', '$.timestamp_tz().type()');
SELECT JSONB_PATH_QUERY('"2023-08-15"', '$.timestamp_tz()');
SELECT JSONB_PATH_QUERY_TZ('"2023-08-15"', '$.timestamp_tz()');
/* should work */ SELECT JSONB_PATH_QUERY('"12:34:56"', '$.timestamp_tz()');
SELECT JSONB_PATH_QUERY('"12:34:56 +05:30"', '$.timestamp_tz()');
SELECT JSONB_PATH_QUERY('"2023-08-15 12:34:56.789 +05:30"', '$.timestamp_tz(-1)');
SELECT JSONB_PATH_QUERY('"2023-08-15 12:34:56.789 +05:30"', '$.timestamp_tz(2.0)');
SELECT JSONB_PATH_QUERY('"2023-08-15 12:34:56.789 +05:30"', '$.timestamp_tz(12345678901)');
SELECT JSONB_PATH_QUERY('"2023-08-15 12:34:56.789 +05:30"', '$.timestamp_tz(0)');
SELECT JSONB_PATH_QUERY('"2023-08-15 12:34:56.789 +05:30"', '$.timestamp_tz(2)');
SELECT JSONB_PATH_QUERY('"2023-08-15 12:34:56.789 +05:30"', '$.timestamp_tz(5)');
SELECT JSONB_PATH_QUERY('"2023-08-15 12:34:56.789 +05:30"', '$.timestamp_tz(10)');
SELECT JSONB_PATH_QUERY('"2023-08-15 12:34:56.789012 +05:30"', '$.timestamp_tz(8)');
set time zone '+00';
SELECT JSONB_PATH_QUERY('"2023-08-15 12:34:56 +05:30"', '$.time()');
SELECT JSONB_PATH_QUERY_TZ('"2023-08-15 12:34:56 +05:30"', '$.time()');
/* should work */ SELECT JSONB_PATH_QUERY('"2023-08-15 12:34:56 +05:30"', '$.time_tz()');
SELECT JSONB_PATH_QUERY('"12:34:56"', '$.time_tz()');
SELECT JSONB_PATH_QUERY_TZ('"12:34:56"', '$.time_tz()');
/* should work */ SELECT JSONB_PATH_QUERY('"2023-08-15 12:34:56 +05:30"', '$.timestamp()');
SELECT JSONB_PATH_QUERY_TZ('"2023-08-15 12:34:56 +05:30"', '$.timestamp()');
/* should work */ SELECT JSONB_PATH_QUERY('"2023-08-15 12:34:56"', '$.timestamp_tz()');
SELECT JSONB_PATH_QUERY_TZ('"2023-08-15 12:34:56"', '$.timestamp_tz()');
/* should work */ SELECT JSONB_PATH_QUERY('"10-03-2017 12:34"', '$.datetime("dd-mm-yyyy HH24:MI")');
SELECT JSONB_PATH_QUERY('"10-03-2017 12:34"', '$.datetime("dd-mm-yyyy HH24:MI TZH")');
SELECT JSONB_PATH_QUERY('"10-03-2017 12:34 +05"', '$.datetime("dd-mm-yyyy HH24:MI TZH")');
SELECT JSONB_PATH_QUERY('"10-03-2017 12:34 -05"', '$.datetime("dd-mm-yyyy HH24:MI TZH")');
SELECT JSONB_PATH_QUERY('"10-03-2017 12:34 +05:20"', '$.datetime("dd-mm-yyyy HH24:MI TZH:TZM")');
SELECT JSONB_PATH_QUERY('"10-03-2017 12:34 -05:20"', '$.datetime("dd-mm-yyyy HH24:MI TZH:TZM")');
SELECT JSONB_PATH_QUERY('"12:34"', '$.datetime("HH24:MI")');
SELECT JSONB_PATH_QUERY('"12:34"', '$.datetime("HH24:MI TZH")');
SELECT JSONB_PATH_QUERY('"12:34 +05"', '$.datetime("HH24:MI TZH")');
SELECT JSONB_PATH_QUERY('"12:34 -05"', '$.datetime("HH24:MI TZH")');
SELECT JSONB_PATH_QUERY('"12:34 +05:20"', '$.datetime("HH24:MI TZH:TZM")');
SELECT JSONB_PATH_QUERY('"12:34 -05:20"', '$.datetime("HH24:MI TZH:TZM")');
set time zone '+10';
SELECT JSONB_PATH_QUERY('"2023-08-15 12:34:56 +05:30"', '$.time()');
SELECT JSONB_PATH_QUERY_TZ('"2023-08-15 12:34:56 +05:30"', '$.time()');
/* should work */ SELECT JSONB_PATH_QUERY('"2023-08-15 12:34:56 +05:30"', '$.time_tz()');
SELECT JSONB_PATH_QUERY('"2023-08-15 12:34:56 +05:30"', '$.timestamp()');
SELECT JSONB_PATH_QUERY_TZ('"2023-08-15 12:34:56 +05:30"', '$.timestamp()');
/* should work */ SELECT JSONB_PATH_QUERY('"2023-08-15 12:34:56"', '$.timestamp_tz()');
SELECT JSONB_PATH_QUERY_TZ('"2023-08-15 12:34:56"', '$.timestamp_tz()');
/* should work */ SELECT JSONB_PATH_QUERY('"2023-08-15 12:34:56 +05:30"', '$.timestamp_tz()');
SELECT JSONB_PATH_QUERY('"10-03-2017 12:34"', '$.datetime("dd-mm-yyyy HH24:MI")');
SELECT JSONB_PATH_QUERY('"10-03-2017 12:34"', '$.datetime("dd-mm-yyyy HH24:MI TZH")');
SELECT JSONB_PATH_QUERY('"10-03-2017 12:34 +05"', '$.datetime("dd-mm-yyyy HH24:MI TZH")');
SELECT JSONB_PATH_QUERY('"10-03-2017 12:34 -05"', '$.datetime("dd-mm-yyyy HH24:MI TZH")');
SELECT JSONB_PATH_QUERY('"10-03-2017 12:34 +05:20"', '$.datetime("dd-mm-yyyy HH24:MI TZH:TZM")');
SELECT JSONB_PATH_QUERY('"10-03-2017 12:34 -05:20"', '$.datetime("dd-mm-yyyy HH24:MI TZH:TZM")');
SELECT JSONB_PATH_QUERY('"12:34"', '$.datetime("HH24:MI")');
SELECT JSONB_PATH_QUERY('"12:34"', '$.datetime("HH24:MI TZH")');
SELECT JSONB_PATH_QUERY('"12:34 +05"', '$.datetime("HH24:MI TZH")');
SELECT JSONB_PATH_QUERY('"12:34 -05"', '$.datetime("HH24:MI TZH")');
SELECT JSONB_PATH_QUERY('"12:34 +05:20"', '$.datetime("HH24:MI TZH:TZM")');
SELECT JSONB_PATH_QUERY('"12:34 -05:20"', '$.datetime("HH24:MI TZH:TZM")');
set time zone default;
SELECT JSONB_PATH_QUERY('"2023-08-15 12:34:56 +05:30"', '$.time()');
SELECT JSONB_PATH_QUERY_TZ('"2023-08-15 12:34:56 +05:30"', '$.time()');
/* should work */ SELECT JSONB_PATH_QUERY('"2023-08-15 12:34:56 +05:30"', '$.time_tz()');
SELECT JSONB_PATH_QUERY('"2023-08-15 12:34:56 +05:30"', '$.timestamp()');
SELECT JSONB_PATH_QUERY_TZ('"2023-08-15 12:34:56 +05:30"', '$.timestamp()');
/* should work */ SELECT JSONB_PATH_QUERY('"2023-08-15 12:34:56 +05:30"', '$.timestamp_tz()');
SELECT JSONB_PATH_QUERY('"2017-03-10"', '$.datetime().type()');
SELECT JSONB_PATH_QUERY('"2017-03-10"', '$.datetime()');
SELECT JSONB_PATH_QUERY('"2017-03-10 12:34:56"', '$.datetime().type()');
SELECT JSONB_PATH_QUERY('"2017-03-10 12:34:56"', '$.datetime()');
SELECT JSONB_PATH_QUERY('"2017-03-10 12:34:56+3"', '$.datetime().type()');
SELECT JSONB_PATH_QUERY('"2017-03-10 12:34:56+3"', '$.datetime()');
SELECT JSONB_PATH_QUERY('"2017-03-10 12:34:56+3:10"', '$.datetime().type()');
SELECT JSONB_PATH_QUERY('"2017-03-10 12:34:56+3:10"', '$.datetime()');
SELECT JSONB_PATH_QUERY('"2017-03-10T12:34:56+3:10"', '$.datetime()');
SELECT JSONB_PATH_QUERY('"2017-03-10t12:34:56+3:10"', '$.datetime()');
SELECT JSONB_PATH_QUERY('"2017-03-10 12:34:56.789+3:10"', '$.datetime()');
SELECT JSONB_PATH_QUERY('"2017-03-10T12:34:56.789+3:10"', '$.datetime()');
SELECT JSONB_PATH_QUERY('"2017-03-10t12:34:56.789+3:10"', '$.datetime()');
SELECT JSONB_PATH_QUERY('"2017-03-10T12:34:56.789EST"', '$.datetime()');
SELECT JSONB_PATH_QUERY('"2017-03-10T12:34:56.789Z"', '$.datetime()');
SELECT JSONB_PATH_QUERY('"12:34:56"', '$.datetime().type()');
SELECT JSONB_PATH_QUERY('"12:34:56"', '$.datetime()');
SELECT JSONB_PATH_QUERY('"12:34:56+3"', '$.datetime().type()');
SELECT JSONB_PATH_QUERY('"12:34:56+3"', '$.datetime()');
SELECT JSONB_PATH_QUERY('"12:34:56+3:10"', '$.datetime().type()');
SELECT JSONB_PATH_QUERY('"12:34:56+3:10"', '$.datetime()');
set time zone '+00';
/* date comparison */ SELECT JSONB_PATH_QUERY('["2017-03-10", "2017-03-11", "2017-03-09", "12:34:56", "01:02:03+04", "2017-03-10 00:00:00", "2017-03-10 12:34:56", "2017-03-10 01:02:03+04", "2017-03-10 03:00:00+03"]', '$[*].datetime() ? (@ == "10.03.2017".datetime("dd.mm.yyyy"))');
SELECT JSONB_PATH_QUERY('["2017-03-10", "2017-03-11", "2017-03-09", "12:34:56", "01:02:03+04", "2017-03-10 00:00:00", "2017-03-10 12:34:56", "2017-03-10 01:02:03+04", "2017-03-10 03:00:00+03"]', '$[*].datetime() ? (@ >= "10.03.2017".datetime("dd.mm.yyyy"))');
SELECT JSONB_PATH_QUERY('["2017-03-10", "2017-03-11", "2017-03-09", "12:34:56", "01:02:03+04", "2017-03-10 00:00:00", "2017-03-10 12:34:56", "2017-03-10 01:02:03+04", "2017-03-10 03:00:00+03"]', '$[*].datetime() ? (@ <  "10.03.2017".datetime("dd.mm.yyyy"))');
SELECT JSONB_PATH_QUERY_TZ('["2017-03-10", "2017-03-11", "2017-03-09", "12:34:56", "01:02:03+04", "2017-03-10 00:00:00", "2017-03-10 12:34:56", "2017-03-10 01:02:03+04", "2017-03-10 03:00:00+03"]', '$[*].datetime() ? (@ == "10.03.2017".datetime("dd.mm.yyyy"))');
SELECT JSONB_PATH_QUERY_TZ('["2017-03-10", "2017-03-11", "2017-03-09", "12:34:56", "01:02:03+04", "2017-03-10 00:00:00", "2017-03-10 12:34:56", "2017-03-10 01:02:03+04", "2017-03-10 03:00:00+03"]', '$[*].datetime() ? (@ >= "10.03.2017".datetime("dd.mm.yyyy"))');
SELECT JSONB_PATH_QUERY_TZ('["2017-03-10", "2017-03-11", "2017-03-09", "12:34:56", "01:02:03+04", "2017-03-10 00:00:00", "2017-03-10 12:34:56", "2017-03-10 01:02:03+04", "2017-03-10 03:00:00+03"]', '$[*].datetime() ? (@ <  "10.03.2017".datetime("dd.mm.yyyy"))');
SELECT JSONB_PATH_QUERY_TZ('["2017-03-10", "2017-03-11", "2017-03-09", "2017-03-10 00:00:00", "2017-03-10 12:34:56", "2017-03-10 01:02:03+04", "2017-03-10 03:00:00+03"]', '$[*].datetime() ? (@ == "2017-03-10".date())');
SELECT JSONB_PATH_QUERY_TZ('["2017-03-10", "2017-03-11", "2017-03-09", "2017-03-10 00:00:00", "2017-03-10 12:34:56", "2017-03-10 01:02:03+04", "2017-03-10 03:00:00+03"]', '$[*].datetime() ? (@ >= "2017-03-10".date())');
SELECT JSONB_PATH_QUERY_TZ('["2017-03-10", "2017-03-11", "2017-03-09", "2017-03-10 00:00:00", "2017-03-10 12:34:56", "2017-03-10 01:02:03+04", "2017-03-10 03:00:00+03"]', '$[*].datetime() ? (@ <  "2017-03-10".date())');
SELECT JSONB_PATH_QUERY('["2017-03-10", "2017-03-11", "2017-03-09", "2017-03-10 00:00:00", "2017-03-10 12:34:56", "2017-03-10 01:02:03+04", "2017-03-10 03:00:00+03"]', '$[*].date() ? (@ == "2017-03-10".date())');
SELECT JSONB_PATH_QUERY('["2017-03-10", "2017-03-11", "2017-03-09", "2017-03-10 00:00:00", "2017-03-10 12:34:56", "2017-03-10 01:02:03+04", "2017-03-10 03:00:00+03"]', '$[*].date() ? (@ >= "2017-03-10".date())');
SELECT JSONB_PATH_QUERY('["2017-03-10", "2017-03-11", "2017-03-09", "2017-03-10 00:00:00", "2017-03-10 12:34:56", "2017-03-10 01:02:03+04", "2017-03-10 03:00:00+03"]', '$[*].date() ? (@ <  "2017-03-10".date())');
SELECT JSONB_PATH_QUERY_TZ('["2017-03-10", "2017-03-11", "2017-03-09", "2017-03-10 00:00:00", "2017-03-10 12:34:56", "2017-03-10 01:02:03+04", "2017-03-10 03:00:00+03"]', '$[*].date() ? (@ == "2017-03-10".date())');
SELECT JSONB_PATH_QUERY_TZ('["2017-03-10", "2017-03-11", "2017-03-09", "2017-03-10 00:00:00", "2017-03-10 12:34:56", "2017-03-10 01:02:03+04", "2017-03-10 03:00:00+03"]', '$[*].date() ? (@ >= "2017-03-10".date())');
SELECT JSONB_PATH_QUERY_TZ('["2017-03-10", "2017-03-11", "2017-03-09", "2017-03-10 00:00:00", "2017-03-10 12:34:56", "2017-03-10 01:02:03+04", "2017-03-10 03:00:00+03"]', '$[*].date() ? (@ <  "2017-03-10".date())');
/* time comparison */ SELECT JSONB_PATH_QUERY('["12:34:00", "12:35:00", "12:36:00", "12:35:00+00", "12:35:00+01", "13:35:00+01", "2017-03-10", "2017-03-10 12:35:00", "2017-03-10 12:35:00+01"]', '$[*].datetime() ? (@ == "12:35".datetime("HH24:MI"))');
SELECT JSONB_PATH_QUERY('["12:34:00", "12:35:00", "12:36:00", "12:35:00+00", "12:35:00+01", "13:35:00+01", "2017-03-10", "2017-03-10 12:35:00", "2017-03-10 12:35:00+01"]', '$[*].datetime() ? (@ >= "12:35".datetime("HH24:MI"))');
SELECT JSONB_PATH_QUERY('["12:34:00", "12:35:00", "12:36:00", "12:35:00+00", "12:35:00+01", "13:35:00+01", "2017-03-10", "2017-03-10 12:35:00", "2017-03-10 12:35:00+01"]', '$[*].datetime() ? (@ <  "12:35".datetime("HH24:MI"))');
SELECT JSONB_PATH_QUERY_TZ('["12:34:00", "12:35:00", "12:36:00", "12:35:00+00", "12:35:00+01", "13:35:00+01", "2017-03-10", "2017-03-10 12:35:00", "2017-03-10 12:35:00+01"]', '$[*].datetime() ? (@ == "12:35".datetime("HH24:MI"))');
SELECT JSONB_PATH_QUERY_TZ('["12:34:00", "12:35:00", "12:36:00", "12:35:00+00", "12:35:00+01", "13:35:00+01", "2017-03-10", "2017-03-10 12:35:00", "2017-03-10 12:35:00+01"]', '$[*].datetime() ? (@ >= "12:35".datetime("HH24:MI"))');
SELECT JSONB_PATH_QUERY_TZ('["12:34:00", "12:35:00", "12:36:00", "12:35:00+00", "12:35:00+01", "13:35:00+01", "2017-03-10", "2017-03-10 12:35:00", "2017-03-10 12:35:00+01"]', '$[*].datetime() ? (@ <  "12:35".datetime("HH24:MI"))');
SELECT JSONB_PATH_QUERY_TZ('["12:34:00", "12:35:00", "12:36:00", "12:35:00+00", "12:35:00+01", "13:35:00+01", "2017-03-10 12:35:00", "2017-03-10 12:35:00+01"]', '$[*].datetime() ? (@ == "12:35:00".time())');
SELECT JSONB_PATH_QUERY_TZ('["12:34:00", "12:35:00", "12:36:00", "12:35:00+00", "12:35:00+01", "13:35:00+01", "2017-03-10 12:35:00", "2017-03-10 12:35:00+01"]', '$[*].datetime() ? (@ >= "12:35:00".time())');
SELECT JSONB_PATH_QUERY_TZ('["12:34:00", "12:35:00", "12:36:00", "12:35:00+00", "12:35:00+01", "13:35:00+01", "2017-03-10 12:35:00", "2017-03-10 12:35:00+01"]', '$[*].datetime() ? (@ <  "12:35:00".time())');
SELECT JSONB_PATH_QUERY('["12:34:00", "12:35:00", "12:36:00", "12:35:00+00", "12:35:00+01", "13:35:00+01", "2017-03-10 12:35:00", "2017-03-10 12:35:00+01"]', '$[*].time() ? (@ == "12:35:00".time())');
SELECT JSONB_PATH_QUERY('["12:34:00", "12:35:00", "12:36:00", "12:35:00+00", "12:35:00+01", "13:35:00+01", "2017-03-10 12:35:00", "2017-03-10 12:35:00+01"]', '$[*].time() ? (@ >= "12:35:00".time())');
SELECT JSONB_PATH_QUERY('["12:34:00", "12:35:00", "12:36:00", "12:35:00+00", "12:35:00+01", "13:35:00+01", "2017-03-10 12:35:00", "2017-03-10 12:35:00+01"]', '$[*].time() ? (@ <  "12:35:00".time())');
SELECT JSONB_PATH_QUERY('["12:34:00.123", "12:35:00.123", "12:36:00.1123", "12:35:00.1123+00", "12:35:00.123+01", "13:35:00.123+01", "2017-03-10 12:35:00.1", "2017-03-10 12:35:00.123+01"]', '$[*].time(2) ? (@ >= "12:35:00.123".time(2))');
SELECT JSONB_PATH_QUERY_TZ('["12:34:00", "12:35:00", "12:36:00", "12:35:00+00", "12:35:00+01", "13:35:00+01", "2017-03-10 12:35:00", "2017-03-10 12:35:00+01"]', '$[*].time() ? (@ == "12:35:00".time())');
SELECT JSONB_PATH_QUERY_TZ('["12:34:00", "12:35:00", "12:36:00", "12:35:00+00", "12:35:00+01", "13:35:00+01", "2017-03-10 12:35:00", "2017-03-10 12:35:00+01"]', '$[*].time() ? (@ >= "12:35:00".time())');
SELECT JSONB_PATH_QUERY_TZ('["12:34:00", "12:35:00", "12:36:00", "12:35:00+00", "12:35:00+01", "13:35:00+01", "2017-03-10 12:35:00", "2017-03-10 12:35:00+01"]', '$[*].time() ? (@ <  "12:35:00".time())');
SELECT JSONB_PATH_QUERY_TZ('["12:34:00.123", "12:35:00.123", "12:36:00.1123", "12:35:00.1123+00", "12:35:00.123+01", "13:35:00.123+01", "2017-03-10 12:35:00.1", "2017-03-10 12:35:00.123+01"]', '$[*].time(2) ? (@ >= "12:35:00.123".time(2))');
/* timetz comparison */ SELECT JSONB_PATH_QUERY('["12:34:00+01", "12:35:00+01", "12:36:00+01", "12:35:00+02", "12:35:00-02", "10:35:00", "11:35:00", "12:35:00", "2017-03-10", "2017-03-10 12:35:00", "2017-03-10 12:35:00 +1"]', '$[*].datetime() ? (@ == "12:35 +1".datetime("HH24:MI TZH"))');
SELECT JSONB_PATH_QUERY('["12:34:00+01", "12:35:00+01", "12:36:00+01", "12:35:00+02", "12:35:00-02", "10:35:00", "11:35:00", "12:35:00", "2017-03-10", "2017-03-10 12:35:00", "2017-03-10 12:35:00 +1"]', '$[*].datetime() ? (@ >= "12:35 +1".datetime("HH24:MI TZH"))');
SELECT JSONB_PATH_QUERY('["12:34:00+01", "12:35:00+01", "12:36:00+01", "12:35:00+02", "12:35:00-02", "10:35:00", "11:35:00", "12:35:00", "2017-03-10", "2017-03-10 12:35:00", "2017-03-10 12:35:00 +1"]', '$[*].datetime() ? (@ <  "12:35 +1".datetime("HH24:MI TZH"))');
SELECT JSONB_PATH_QUERY_TZ('["12:34:00+01", "12:35:00+01", "12:36:00+01", "12:35:00+02", "12:35:00-02", "10:35:00", "11:35:00", "12:35:00", "2017-03-10", "2017-03-10 12:35:00", "2017-03-10 12:35:00 +1"]', '$[*].datetime() ? (@ == "12:35 +1".datetime("HH24:MI TZH"))');
SELECT JSONB_PATH_QUERY_TZ('["12:34:00+01", "12:35:00+01", "12:36:00+01", "12:35:00+02", "12:35:00-02", "10:35:00", "11:35:00", "12:35:00", "2017-03-10", "2017-03-10 12:35:00", "2017-03-10 12:35:00 +1"]', '$[*].datetime() ? (@ >= "12:35 +1".datetime("HH24:MI TZH"))');
SELECT JSONB_PATH_QUERY_TZ('["12:34:00+01", "12:35:00+01", "12:36:00+01", "12:35:00+02", "12:35:00-02", "10:35:00", "11:35:00", "12:35:00", "2017-03-10", "2017-03-10 12:35:00", "2017-03-10 12:35:00 +1"]', '$[*].datetime() ? (@ <  "12:35 +1".datetime("HH24:MI TZH"))');
SELECT JSONB_PATH_QUERY_TZ('["12:34:00+01", "12:35:00+01", "12:36:00+01", "12:35:00+02", "12:35:00-02", "10:35:00", "11:35:00", "12:35:00", "2017-03-10 12:35:00 +1"]', '$[*].datetime() ? (@ == "12:35:00 +1".time_tz())');
SELECT JSONB_PATH_QUERY_TZ('["12:34:00+01", "12:35:00+01", "12:36:00+01", "12:35:00+02", "12:35:00-02", "10:35:00", "11:35:00", "12:35:00", "2017-03-10 12:35:00 +1"]', '$[*].datetime() ? (@ >= "12:35:00 +1".time_tz())');
SELECT JSONB_PATH_QUERY_TZ('["12:34:00+01", "12:35:00+01", "12:36:00+01", "12:35:00+02", "12:35:00-02", "10:35:00", "11:35:00", "12:35:00", "2017-03-10 12:35:00 +1"]', '$[*].datetime() ? (@ <  "12:35:00 +1".time_tz())');
SELECT JSONB_PATH_QUERY('["12:34:00+01", "12:35:00+01", "12:36:00+01", "12:35:00+02", "12:35:00-02", "10:35:00", "11:35:00", "12:35:00", "2017-03-10 12:35:00 +1"]', '$[*].time_tz() ? (@ == "12:35:00 +1".time_tz())');
SELECT JSONB_PATH_QUERY('["12:34:00+01", "12:35:00+01", "12:36:00+01", "12:35:00+02", "12:35:00-02", "10:35:00", "11:35:00", "12:35:00", "2017-03-10 12:35:00 +1"]', '$[*].time_tz() ? (@ >= "12:35:00 +1".time_tz())');
SELECT JSONB_PATH_QUERY('["12:34:00+01", "12:35:00+01", "12:36:00+01", "12:35:00+02", "12:35:00-02", "10:35:00", "11:35:00", "12:35:00", "2017-03-10 12:35:00 +1"]', '$[*].time_tz() ? (@ <  "12:35:00 +1".time_tz())');
SELECT JSONB_PATH_QUERY('["12:34:00.123+01", "12:35:00.123+01", "12:36:00.1123+01", "12:35:00.1123+02", "12:35:00.123-02", "10:35:00.123", "11:35:00.1", "12:35:00.123", "2017-03-10 12:35:00.123 +1"]', '$[*].time_tz(2) ? (@ >= "12:35:00.123 +1".time_tz(2))');
SELECT JSONB_PATH_QUERY_TZ('["12:34:00+01", "12:35:00+01", "12:36:00+01", "12:35:00+02", "12:35:00-02", "10:35:00", "11:35:00", "12:35:00", "2017-03-10 12:35:00 +1"]', '$[*].time_tz() ? (@ == "12:35:00 +1".time_tz())');
SELECT JSONB_PATH_QUERY_TZ('["12:34:00+01", "12:35:00+01", "12:36:00+01", "12:35:00+02", "12:35:00-02", "10:35:00", "11:35:00", "12:35:00", "2017-03-10 12:35:00 +1"]', '$[*].time_tz() ? (@ >= "12:35:00 +1".time_tz())');
SELECT JSONB_PATH_QUERY_TZ('["12:34:00+01", "12:35:00+01", "12:36:00+01", "12:35:00+02", "12:35:00-02", "10:35:00", "11:35:00", "12:35:00", "2017-03-10 12:35:00 +1"]', '$[*].time_tz() ? (@ <  "12:35:00 +1".time_tz())');
SELECT JSONB_PATH_QUERY_TZ('["12:34:00.123+01", "12:35:00.123+01", "12:36:00.1123+01", "12:35:00.1123+02", "12:35:00.123-02", "10:35:00.123", "11:35:00.1", "12:35:00.123", "2017-03-10 12:35:00.123 +1"]', '$[*].time_tz(2) ? (@ >= "12:35:00.123 +1".time_tz(2))');
/* timestamp comparison */ SELECT JSONB_PATH_QUERY('["2017-03-10 12:34:00", "2017-03-10 12:35:00", "2017-03-10 12:36:00", "2017-03-10 12:35:00+01", "2017-03-10 13:35:00+01", "2017-03-10 12:35:00-01", "2017-03-10", "2017-03-11", "12:34:56", "12:34:56+01"]', '$[*].datetime() ? (@ == "10.03.2017 12:35".datetime("dd.mm.yyyy HH24:MI"))');
SELECT JSONB_PATH_QUERY('["2017-03-10 12:34:00", "2017-03-10 12:35:00", "2017-03-10 12:36:00", "2017-03-10 12:35:00+01", "2017-03-10 13:35:00+01", "2017-03-10 12:35:00-01", "2017-03-10", "2017-03-11", "12:34:56", "12:34:56+01"]', '$[*].datetime() ? (@ >= "10.03.2017 12:35".datetime("dd.mm.yyyy HH24:MI"))');
SELECT JSONB_PATH_QUERY('["2017-03-10 12:34:00", "2017-03-10 12:35:00", "2017-03-10 12:36:00", "2017-03-10 12:35:00+01", "2017-03-10 13:35:00+01", "2017-03-10 12:35:00-01", "2017-03-10", "2017-03-11", "12:34:56", "12:34:56+01"]', '$[*].datetime() ? (@ < "10.03.2017 12:35".datetime("dd.mm.yyyy HH24:MI"))');
SELECT JSONB_PATH_QUERY_TZ('["2017-03-10 12:34:00", "2017-03-10 12:35:00", "2017-03-10 12:36:00", "2017-03-10 12:35:00+01", "2017-03-10 13:35:00+01", "2017-03-10 12:35:00-01", "2017-03-10", "2017-03-11", "12:34:56", "12:34:56+01"]', '$[*].datetime() ? (@ == "10.03.2017 12:35".datetime("dd.mm.yyyy HH24:MI"))');
SELECT JSONB_PATH_QUERY_TZ('["2017-03-10 12:34:00", "2017-03-10 12:35:00", "2017-03-10 12:36:00", "2017-03-10 12:35:00+01", "2017-03-10 13:35:00+01", "2017-03-10 12:35:00-01", "2017-03-10", "2017-03-11", "12:34:56", "12:34:56+01"]', '$[*].datetime() ? (@ >= "10.03.2017 12:35".datetime("dd.mm.yyyy HH24:MI"))');
SELECT JSONB_PATH_QUERY_TZ('["2017-03-10 12:34:00", "2017-03-10 12:35:00", "2017-03-10 12:36:00", "2017-03-10 12:35:00+01", "2017-03-10 13:35:00+01", "2017-03-10 12:35:00-01", "2017-03-10", "2017-03-11", "12:34:56", "12:34:56+01"]', '$[*].datetime() ? (@ < "10.03.2017 12:35".datetime("dd.mm.yyyy HH24:MI"))');
SELECT JSONB_PATH_QUERY_TZ('["2017-03-10 12:34:00", "2017-03-10 12:35:00", "2017-03-10 12:36:00", "2017-03-10 12:35:00+01", "2017-03-10 13:35:00+01", "2017-03-10 12:35:00-01", "2017-03-10", "2017-03-11"]', '$[*].datetime() ? (@ == "2017-03-10 12:35:00".timestamp())');
SELECT JSONB_PATH_QUERY_TZ('["2017-03-10 12:34:00", "2017-03-10 12:35:00", "2017-03-10 12:36:00", "2017-03-10 12:35:00+01", "2017-03-10 13:35:00+01", "2017-03-10 12:35:00-01", "2017-03-10", "2017-03-11"]', '$[*].datetime() ? (@ >= "2017-03-10 12:35:00".timestamp())');
SELECT JSONB_PATH_QUERY_TZ('["2017-03-10 12:34:00", "2017-03-10 12:35:00", "2017-03-10 12:36:00", "2017-03-10 12:35:00+01", "2017-03-10 13:35:00+01", "2017-03-10 12:35:00-01", "2017-03-10", "2017-03-11"]', '$[*].datetime() ? (@ < "2017-03-10 12:35:00".timestamp())');
SELECT JSONB_PATH_QUERY('["2017-03-10 12:34:00", "2017-03-10 12:35:00", "2017-03-10 12:36:00", "2017-03-10 12:35:00+01", "2017-03-10 13:35:00+01", "2017-03-10 12:35:00-01", "2017-03-10", "2017-03-11"]', '$[*].timestamp() ? (@ == "2017-03-10 12:35:00".timestamp())');
SELECT JSONB_PATH_QUERY('["2017-03-10 12:34:00", "2017-03-10 12:35:00", "2017-03-10 12:36:00", "2017-03-10 12:35:00+01", "2017-03-10 13:35:00+01", "2017-03-10 12:35:00-01", "2017-03-10", "2017-03-11"]', '$[*].timestamp() ? (@ >= "2017-03-10 12:35:00".timestamp())');
SELECT JSONB_PATH_QUERY('["2017-03-10 12:34:00", "2017-03-10 12:35:00", "2017-03-10 12:36:00", "2017-03-10 12:35:00+01", "2017-03-10 13:35:00+01", "2017-03-10 12:35:00-01", "2017-03-10", "2017-03-11"]', '$[*].timestamp() ? (@ < "2017-03-10 12:35:00".timestamp())');
SELECT JSONB_PATH_QUERY('["2017-03-10 12:34:00.123", "2017-03-10 12:35:00.123", "2017-03-10 12:36:00.1123", "2017-03-10 12:35:00.1123+01", "2017-03-10 13:35:00.123+01", "2017-03-10 12:35:00.1-01", "2017-03-10", "2017-03-11"]', '$[*].timestamp(2) ? (@ >= "2017-03-10 12:35:00.123".timestamp(2))');
SELECT JSONB_PATH_QUERY_TZ('["2017-03-10 12:34:00", "2017-03-10 12:35:00", "2017-03-10 12:36:00", "2017-03-10 12:35:00+01", "2017-03-10 13:35:00+01", "2017-03-10 12:35:00-01", "2017-03-10", "2017-03-11"]', '$[*].timestamp() ? (@ == "2017-03-10 12:35:00".timestamp())');
SELECT JSONB_PATH_QUERY_TZ('["2017-03-10 12:34:00", "2017-03-10 12:35:00", "2017-03-10 12:36:00", "2017-03-10 12:35:00+01", "2017-03-10 13:35:00+01", "2017-03-10 12:35:00-01", "2017-03-10", "2017-03-11"]', '$[*].timestamp() ? (@ >= "2017-03-10 12:35:00".timestamp())');
SELECT JSONB_PATH_QUERY_TZ('["2017-03-10 12:34:00", "2017-03-10 12:35:00", "2017-03-10 12:36:00", "2017-03-10 12:35:00+01", "2017-03-10 13:35:00+01", "2017-03-10 12:35:00-01", "2017-03-10", "2017-03-11"]', '$[*].timestamp() ? (@ < "2017-03-10 12:35:00".timestamp())');
SELECT JSONB_PATH_QUERY_TZ('["2017-03-10 12:34:00.123", "2017-03-10 12:35:00.123", "2017-03-10 12:36:00.1123", "2017-03-10 12:35:00.1123+01", "2017-03-10 13:35:00.123+01", "2017-03-10 12:35:00.1-01", "2017-03-10", "2017-03-11"]', '$[*].timestamp(2) ? (@ >= "2017-03-10 12:35:00.123".timestamp(2))');
/* timestamptz comparison */ SELECT JSONB_PATH_QUERY('["2017-03-10 12:34:00+01", "2017-03-10 12:35:00+01", "2017-03-10 12:36:00+01", "2017-03-10 12:35:00+02", "2017-03-10 12:35:00-02", "2017-03-10 10:35:00", "2017-03-10 11:35:00", "2017-03-10 12:35:00", "2017-03-10", "2017-03-11", "12:34:56", "12:34:56+01"]', '$[*].datetime() ? (@ == "10.03.2017 12:35 +1".datetime("dd.mm.yyyy HH24:MI TZH"))');
SELECT JSONB_PATH_QUERY('["2017-03-10 12:34:00+01", "2017-03-10 12:35:00+01", "2017-03-10 12:36:00+01", "2017-03-10 12:35:00+02", "2017-03-10 12:35:00-02", "2017-03-10 10:35:00", "2017-03-10 11:35:00", "2017-03-10 12:35:00", "2017-03-10", "2017-03-11", "12:34:56", "12:34:56+01"]', '$[*].datetime() ? (@ >= "10.03.2017 12:35 +1".datetime("dd.mm.yyyy HH24:MI TZH"))');
SELECT JSONB_PATH_QUERY('["2017-03-10 12:34:00+01", "2017-03-10 12:35:00+01", "2017-03-10 12:36:00+01", "2017-03-10 12:35:00+02", "2017-03-10 12:35:00-02", "2017-03-10 10:35:00", "2017-03-10 11:35:00", "2017-03-10 12:35:00", "2017-03-10", "2017-03-11", "12:34:56", "12:34:56+01"]', '$[*].datetime() ? (@ < "10.03.2017 12:35 +1".datetime("dd.mm.yyyy HH24:MI TZH"))');
SELECT JSONB_PATH_QUERY_TZ('["2017-03-10 12:34:00+01", "2017-03-10 12:35:00+01", "2017-03-10 12:36:00+01", "2017-03-10 12:35:00+02", "2017-03-10 12:35:00-02", "2017-03-10 10:35:00", "2017-03-10 11:35:00", "2017-03-10 12:35:00", "2017-03-10", "2017-03-11", "12:34:56", "12:34:56+01"]', '$[*].datetime() ? (@ == "10.03.2017 12:35 +1".datetime("dd.mm.yyyy HH24:MI TZH"))');
SELECT JSONB_PATH_QUERY_TZ('["2017-03-10 12:34:00+01", "2017-03-10 12:35:00+01", "2017-03-10 12:36:00+01", "2017-03-10 12:35:00+02", "2017-03-10 12:35:00-02", "2017-03-10 10:35:00", "2017-03-10 11:35:00", "2017-03-10 12:35:00", "2017-03-10", "2017-03-11", "12:34:56", "12:34:56+01"]', '$[*].datetime() ? (@ >= "10.03.2017 12:35 +1".datetime("dd.mm.yyyy HH24:MI TZH"))');
SELECT JSONB_PATH_QUERY_TZ('["2017-03-10 12:34:00+01", "2017-03-10 12:35:00+01", "2017-03-10 12:36:00+01", "2017-03-10 12:35:00+02", "2017-03-10 12:35:00-02", "2017-03-10 10:35:00", "2017-03-10 11:35:00", "2017-03-10 12:35:00", "2017-03-10", "2017-03-11", "12:34:56", "12:34:56+01"]', '$[*].datetime() ? (@ < "10.03.2017 12:35 +1".datetime("dd.mm.yyyy HH24:MI TZH"))');
SELECT JSONB_PATH_QUERY_TZ('["2017-03-10 12:34:00+01", "2017-03-10 12:35:00+01", "2017-03-10 12:36:00+01", "2017-03-10 12:35:00+02", "2017-03-10 12:35:00-02", "2017-03-10 10:35:00", "2017-03-10 11:35:00", "2017-03-10 12:35:00", "2017-03-10", "2017-03-11"]', '$[*].datetime() ? (@ == "2017-03-10 12:35:00 +1".timestamp_tz())');
SELECT JSONB_PATH_QUERY_TZ('["2017-03-10 12:34:00+01", "2017-03-10 12:35:00+01", "2017-03-10 12:36:00+01", "2017-03-10 12:35:00+02", "2017-03-10 12:35:00-02", "2017-03-10 10:35:00", "2017-03-10 11:35:00", "2017-03-10 12:35:00", "2017-03-10", "2017-03-11"]', '$[*].datetime() ? (@ >= "2017-03-10 12:35:00 +1".timestamp_tz())');
SELECT JSONB_PATH_QUERY_TZ('["2017-03-10 12:34:00+01", "2017-03-10 12:35:00+01", "2017-03-10 12:36:00+01", "2017-03-10 12:35:00+02", "2017-03-10 12:35:00-02", "2017-03-10 10:35:00", "2017-03-10 11:35:00", "2017-03-10 12:35:00", "2017-03-10", "2017-03-11"]', '$[*].datetime() ? (@ < "2017-03-10 12:35:00 +1".timestamp_tz())');
SELECT JSONB_PATH_QUERY('["2017-03-10 12:34:00+01", "2017-03-10 12:35:00+01", "2017-03-10 12:36:00+01", "2017-03-10 12:35:00+02", "2017-03-10 12:35:00-02", "2017-03-10 10:35:00", "2017-03-10 11:35:00", "2017-03-10 12:35:00", "2017-03-10", "2017-03-11"]', '$[*].timestamp_tz() ? (@ == "2017-03-10 12:35:00 +1".timestamp_tz())');
SELECT JSONB_PATH_QUERY('["2017-03-10 12:34:00+01", "2017-03-10 12:35:00+01", "2017-03-10 12:36:00+01", "2017-03-10 12:35:00+02", "2017-03-10 12:35:00-02", "2017-03-10 10:35:00", "2017-03-10 11:35:00", "2017-03-10 12:35:00", "2017-03-10", "2017-03-11"]', '$[*].timestamp_tz() ? (@ >= "2017-03-10 12:35:00 +1".timestamp_tz())');
SELECT JSONB_PATH_QUERY('["2017-03-10 12:34:00+01", "2017-03-10 12:35:00+01", "2017-03-10 12:36:00+01", "2017-03-10 12:35:00+02", "2017-03-10 12:35:00-02", "2017-03-10 10:35:00", "2017-03-10 11:35:00", "2017-03-10 12:35:00", "2017-03-10", "2017-03-11"]', '$[*].timestamp_tz() ? (@ < "2017-03-10 12:35:00 +1".timestamp_tz())');
SELECT JSONB_PATH_QUERY('["2017-03-10 12:34:00.123+01", "2017-03-10 12:35:00.123+01", "2017-03-10 12:36:00.1123+01", "2017-03-10 12:35:00.1123+02", "2017-03-10 12:35:00.123-02", "2017-03-10 10:35:00.123", "2017-03-10 11:35:00.1", "2017-03-10 12:35:00.123", "2017-03-10", "2017-03-11"]', '$[*].timestamp_tz(2) ? (@ >= "2017-03-10 12:35:00.123 +1".timestamp_tz(2))');
SELECT JSONB_PATH_QUERY_TZ('["2017-03-10 12:34:00+01", "2017-03-10 12:35:00+01", "2017-03-10 12:36:00+01", "2017-03-10 12:35:00+02", "2017-03-10 12:35:00-02", "2017-03-10 10:35:00", "2017-03-10 11:35:00", "2017-03-10 12:35:00", "2017-03-10", "2017-03-11"]', '$[*].timestamp_tz() ? (@ == "2017-03-10 12:35:00 +1".timestamp_tz())');
SELECT JSONB_PATH_QUERY_TZ('["2017-03-10 12:34:00+01", "2017-03-10 12:35:00+01", "2017-03-10 12:36:00+01", "2017-03-10 12:35:00+02", "2017-03-10 12:35:00-02", "2017-03-10 10:35:00", "2017-03-10 11:35:00", "2017-03-10 12:35:00", "2017-03-10", "2017-03-11"]', '$[*].timestamp_tz() ? (@ >= "2017-03-10 12:35:00 +1".timestamp_tz())');
SELECT JSONB_PATH_QUERY_TZ('["2017-03-10 12:34:00+01", "2017-03-10 12:35:00+01", "2017-03-10 12:36:00+01", "2017-03-10 12:35:00+02", "2017-03-10 12:35:00-02", "2017-03-10 10:35:00", "2017-03-10 11:35:00", "2017-03-10 12:35:00", "2017-03-10", "2017-03-11"]', '$[*].timestamp_tz() ? (@ < "2017-03-10 12:35:00 +1".timestamp_tz())');
SELECT JSONB_PATH_QUERY_TZ('["2017-03-10 12:34:00.123+01", "2017-03-10 12:35:00.123+01", "2017-03-10 12:36:00.1123+01", "2017-03-10 12:35:00.1123+02", "2017-03-10 12:35:00.123-02", "2017-03-10 10:35:00.123", "2017-03-10 11:35:00.1", "2017-03-10 12:35:00.123", "2017-03-10", "2017-03-11"]', '$[*].timestamp_tz(2) ? (@ >= "2017-03-10 12:35:00.123 +1".timestamp_tz(2))');
/* overflow during comparison */ SELECT JSONB_PATH_QUERY('"1000000-01-01"', CAST('$.datetime() > "2020-01-01 12:00:00".datetime()' AS jsonpath));
set time zone default;
/* jsonpath operators */ SELECT JSONB_PATH_QUERY('[{"a": 1}, {"a": 2}]', '$[*]');
SELECT JSONB_PATH_QUERY('[{"a": 1}, {"a": 2}]', '$[*] ? (@.a > 10)');
SELECT JSONB_PATH_QUERY('[{"a": 1}]', '$undefined_var');
SELECT JSONB_PATH_QUERY('[{"a": 1}]', 'false');
SELECT JSONB_PATH_QUERY_ARRAY('[{"a": 1}, {"a": 2}, {}]', 'strict $[*].a');
SELECT JSONB_PATH_QUERY_ARRAY('[{"a": 1}, {"a": 2}]', '$[*].a');
SELECT JSONB_PATH_QUERY_ARRAY('[{"a": 1}, {"a": 2}]', '$[*].a ? (@ == 1)');
SELECT JSONB_PATH_QUERY_ARRAY('[{"a": 1}, {"a": 2}]', '$[*].a ? (@ > 10)');
SELECT JSONB_PATH_QUERY_ARRAY('[{"a": 1}, {"a": 2}, {"a": 3}, {"a": 5}]', '$[*].a ? (@ > $min && @ < $max)', vars => '{"min": 1, "max": 4}');
SELECT JSONB_PATH_QUERY_ARRAY('[{"a": 1}, {"a": 2}, {"a": 3}, {"a": 5}]', '$[*].a ? (@ > $min && @ < $max)', vars => '{"min": 3, "max": 4}');
SELECT JSONB_PATH_QUERY_FIRST('[{"a": 1}, {"a": 2}, {}]', 'strict $[*].a');
SELECT JSONB_PATH_QUERY_FIRST('[{"a": 1}, {"a": 2}, {}]', 'strict $[*].a', silent => TRUE);
SELECT JSONB_PATH_QUERY_FIRST('[{"a": 1}, {"a": 2}]', '$[*].a');
SELECT JSONB_PATH_QUERY_FIRST('[{"a": 1}, {"a": 2}]', '$[*].a ? (@ == 1)');
SELECT JSONB_PATH_QUERY_FIRST('[{"a": 1}, {"a": 2}]', '$[*].a ? (@ > 10)');
SELECT JSONB_PATH_QUERY_FIRST('[{"a": 1}, {"a": 2}, {"a": 3}, {"a": 5}]', '$[*].a ? (@ > $min && @ < $max)', vars => '{"min": 1, "max": 4}');
SELECT JSONB_PATH_QUERY_FIRST('[{"a": 1}, {"a": 2}, {"a": 3}, {"a": 5}]', '$[*].a ? (@ > $min && @ < $max)', vars => '{"min": 3, "max": 4}');
SELECT JSONB_PATH_QUERY_FIRST('[{"a": 1}]', '$undefined_var');
SELECT JSONB_PATH_QUERY_FIRST('[{"a": 1}]', 'false');
SELECT JSONB_PATH_EXISTS('[{"a": 1}, {"a": 2}]', '$[*].a ? (@ > 1)');
SELECT JSONB_PATH_EXISTS('[{"a": 1}, {"a": 2}, {"a": 3}, {"a": 5}]', '$[*] ? (@.a > $min && @.a < $max)', vars => '{"min": 1, "max": 4}');
SELECT JSONB_PATH_EXISTS('[{"a": 1}, {"a": 2}, {"a": 3}, {"a": 5}]', '$[*] ? (@.a > $min && @.a < $max)', vars => '{"min": 3, "max": 4}');
SELECT JSONB_PATH_EXISTS('[{"a": 1}]', '$undefined_var');
SELECT JSONB_PATH_EXISTS('[{"a": 1}]', 'false');
SELECT JSONB_PATH_MATCH('true', '$', silent => FALSE);
SELECT JSONB_PATH_MATCH('false', '$', silent => FALSE);
SELECT JSONB_PATH_MATCH('null', '$', silent => FALSE);
SELECT JSONB_PATH_MATCH('1', '$', silent => TRUE);
SELECT JSONB_PATH_MATCH('1', '$', silent => FALSE);
SELECT JSONB_PATH_MATCH('"a"', '$', silent => FALSE);
SELECT JSONB_PATH_MATCH('{}', '$', silent => FALSE);
SELECT JSONB_PATH_MATCH('[true]', '$', silent => FALSE);
SELECT JSONB_PATH_MATCH('{}', 'lax $.a', silent => FALSE);
SELECT JSONB_PATH_MATCH('{}', 'strict $.a', silent => FALSE);
SELECT JSONB_PATH_MATCH('{}', 'strict $.a', silent => TRUE);
SELECT JSONB_PATH_MATCH('[true, true]', '$[*]', silent => FALSE);
SELECT MATCH(CAST('[{"a": 1}, {"a": 2}]' AS JSONB)) AGAINST('$[*].a > 1');
SELECT MATCH(CAST('[{"a": 1}, {"a": 2}]' AS JSONB)) AGAINST('$[*].a > 2');
SELECT JSONB_PATH_MATCH('[{"a": 1}, {"a": 2}]', '$[*].a > 1');
SELECT JSONB_PATH_MATCH('[{"a": 1}]', '$undefined_var');
SELECT JSONB_PATH_MATCH('[{"a": 1}]', 'false');
/* test string comparison (Unicode codepoint collation) */ WITH x AS (SELECT JSONB_BUILD_OBJECT('s', x), x FROM UNNEST(CAST('{"", "a", "ab", "abc", "abcd", "b", "A", "AB", "ABC", "ABc", "ABcD", "B"}' AS ARRAY<TEXT>)) WITH ORDINALITY AS x(x)) SELECT x.x, x.x, JSONB_PATH_QUERY_FIRST(x.x, '$.s < $s', vars => x.x) AS x, JSONB_PATH_QUERY_FIRST(x.x, '$.s <= $s', vars => x.x) AS x, JSONB_PATH_QUERY_FIRST(x.x, '$.s == $s', vars => x.x) AS x, JSONB_PATH_QUERY_FIRST(x.x, '$.s >= $s', vars => x.x) AS x, JSONB_PATH_QUERY_FIRST(x.x, '$.s > $s', vars => x.x) AS x FROM x AS x, x AS x ORDER BY x.x NULLS LAST, x.x NULLS LAST;
/* jsonpath io */ SELECT CAST('' AS jsonpath);
SELECT CAST('$' AS jsonpath);
SELECT CAST('strict $' AS jsonpath);
SELECT CAST('lax $' AS jsonpath);
SELECT CAST('$.a' AS jsonpath);
SELECT CAST('$.a.v' AS jsonpath);
SELECT CAST('$.a.*' AS jsonpath);
SELECT CAST('$.*[*]' AS jsonpath);
SELECT CAST('$.a[*]' AS jsonpath);
SELECT CAST('$.a[*][*]' AS jsonpath);
SELECT CAST('$[*]' AS jsonpath);
SELECT CAST('$[0]' AS jsonpath);
SELECT CAST('$[*][0]' AS jsonpath);
SELECT CAST('$[*].a' AS jsonpath);
SELECT CAST('$[*][0].a.b' AS jsonpath);
SELECT CAST('$.a.**.b' AS jsonpath);
SELECT CAST('$.a.**{2}.b' AS jsonpath);
SELECT CAST('$.a.**{2 to 2}.b' AS jsonpath);
SELECT CAST('$.a.**{2 to 5}.b' AS jsonpath);
SELECT CAST('$.a.**{0 to 5}.b' AS jsonpath);
SELECT CAST('$.a.**{5 to last}.b' AS jsonpath);
SELECT CAST('$.a.**{last}.b' AS jsonpath);
SELECT CAST('$.a.**{last to 5}.b' AS jsonpath);
SELECT CAST('$+1' AS jsonpath);
SELECT CAST('$-1' AS jsonpath);
SELECT CAST('$--+1' AS jsonpath);
SELECT CAST('$.a/+-1' AS jsonpath);
SELECT CAST('1 * 2 + 4 % -3 != false' AS jsonpath);
SELECT CAST('"\b\f\r\n\t\v\"\''\\"' AS jsonpath);
SELECT CAST('"\x50\u0067\u{53}\u{051}\u{00004C}"' AS jsonpath);
SELECT CAST('$.foo\x50\u0067\u{53}\u{051}\u{00004C}\t\"bar' AS jsonpath);
SELECT CAST('"\z"' AS jsonpath);
/* unrecognized escape is just the literal char */ SELECT CAST('$.g ? ($.a == 1)' AS jsonpath);
SELECT CAST('$.g ? (@ == 1)' AS jsonpath);
SELECT CAST('$.g ? (@.a == 1)' AS jsonpath);
SELECT CAST('$.g ? (@.a == 1 || @.a == 4)' AS jsonpath);
SELECT CAST('$.g ? (@.a == 1 && @.a == 4)' AS jsonpath);
SELECT CAST('$.g ? (@.a == 1 || @.a == 4 && @.b == 7)' AS jsonpath);
SELECT CAST('$.g ? (@.a == 1 || !(@.a == 4) && @.b == 7)' AS jsonpath);
SELECT CAST('$.g ? (@.a == 1 || !(@.x >= 123 || @.a == 4) && @.b == 7)' AS jsonpath);
SELECT CAST('$.g ? (@.x >= @[*]?(@.a > "abc"))' AS jsonpath);
SELECT CAST('$.g ? ((@.x >= 123 || @.a == 4) is unknown)' AS jsonpath);
SELECT CAST('$.g ? (exists (@.x))' AS jsonpath);
SELECT CAST('$.g ? (exists (@.x ? (@ == 14)))' AS jsonpath);
SELECT CAST('$.g ? ((@.x >= 123 || @.a == 4) && exists (@.x ? (@ == 14)))' AS jsonpath);
SELECT CAST('$.g ? (+@.x >= +-(+@.a + 2))' AS jsonpath);
SELECT CAST('$a' AS jsonpath);
SELECT CAST('$a.b' AS jsonpath);
SELECT CAST('$a[*]' AS jsonpath);
SELECT CAST('$.g ? (@.zip == $zip)' AS jsonpath);
SELECT CAST('$.a[1,2, 3 to 16]' AS jsonpath);
SELECT CAST('$.a[$a + 1, ($b[*]) to -($[0] * 2)]' AS jsonpath);
SELECT CAST('$.a[$.a.size() - 3]' AS jsonpath);
SELECT CAST('last' AS jsonpath);
SELECT CAST('"last"' AS jsonpath);
SELECT CAST('$.last' AS jsonpath);
SELECT CAST('$ ? (last > 0)' AS jsonpath);
SELECT CAST('$[last]' AS jsonpath);
SELECT CAST('$[$[0] ? (last > 0)]' AS jsonpath);
SELECT CAST('null.type()' AS jsonpath);
SELECT CAST('1.type()' AS jsonpath);
SELECT CAST('(1).type()' AS jsonpath);
SELECT CAST('1.2.type()' AS jsonpath);
SELECT CAST('"aaa".type()' AS jsonpath);
SELECT CAST('true.type()' AS jsonpath);
SELECT CAST('$.double().floor().ceiling().abs()' AS jsonpath);
SELECT CAST('$.keyvalue().key' AS jsonpath);
SELECT CAST('$.datetime()' AS jsonpath);
SELECT CAST('$.datetime("datetime template")' AS jsonpath);
SELECT CAST('$.bigint().integer().number().decimal()' AS jsonpath);
SELECT CAST('$.boolean()' AS jsonpath);
SELECT CAST('$.date()' AS jsonpath);
SELECT CAST('$.decimal(4,2)' AS jsonpath);
SELECT CAST('$.string()' AS jsonpath);
SELECT CAST('$.time()' AS jsonpath);
SELECT CAST('$.time(6)' AS jsonpath);
SELECT CAST('$.time_tz()' AS jsonpath);
SELECT CAST('$.time_tz(4)' AS jsonpath);
SELECT CAST('$.timestamp()' AS jsonpath);
SELECT CAST('$.timestamp(2)' AS jsonpath);
SELECT CAST('$.timestamp_tz()' AS jsonpath);
SELECT CAST('$.timestamp_tz(0)' AS jsonpath);
SELECT CAST('$ ? (@ starts with "abc")' AS jsonpath);
SELECT CAST('$ ? (@ starts with $var)' AS jsonpath);
SELECT CAST('$ ? (@ like_regex "(invalid pattern")' AS jsonpath);
SELECT CAST('$ ? (@ like_regex "pattern")' AS jsonpath);
SELECT CAST('$ ? (@ like_regex "pattern" flag "")' AS jsonpath);
SELECT CAST('$ ? (@ like_regex "pattern" flag "i")' AS jsonpath);
SELECT CAST('$ ? (@ like_regex "pattern" flag "is")' AS jsonpath);
SELECT CAST('$ ? (@ like_regex "pattern" flag "isim")' AS jsonpath);
SELECT CAST('$ ? (@ like_regex "pattern" flag "xsms")' AS jsonpath);
SELECT CAST('$ ? (@ like_regex "pattern" flag "q")' AS jsonpath);
SELECT CAST('$ ? (@ like_regex "pattern" flag "iq")' AS jsonpath);
SELECT CAST('$ ? (@ like_regex "pattern" flag "smixq")' AS jsonpath);
SELECT CAST('$ ? (@ like_regex "pattern" flag "a")' AS jsonpath);
SELECT CAST('$ < 1' AS jsonpath);
SELECT CAST('($ < 1) || $.a.b <= $x' AS jsonpath);
SELECT CAST('@ + 1' AS jsonpath);
SELECT CAST('($).a.b' AS jsonpath);
SELECT CAST('($.a.b).c.d' AS jsonpath);
SELECT CAST('($.a.b + -$.x.y).c.d' AS jsonpath);
SELECT CAST('(-+$.a.b).c.d' AS jsonpath);
SELECT CAST('1 + ($.a.b + 2).c.d' AS jsonpath);
SELECT CAST('1 + ($.a.b > 2).c.d' AS jsonpath);
SELECT CAST('($)' AS jsonpath);
SELECT CAST('(($))' AS jsonpath);
SELECT CAST('((($ + 1)).a + ((2)).b ? ((((@ > 1)) || (exists(@.c)))))' AS jsonpath);
SELECT CAST('$ ? (@.a < 1)' AS jsonpath);
SELECT CAST('$ ? (@.a < -1)' AS jsonpath);
SELECT CAST('$ ? (@.a < +1)' AS jsonpath);
SELECT CAST('$ ? (@.a < .1)' AS jsonpath);
SELECT CAST('$ ? (@.a < -.1)' AS jsonpath);
SELECT CAST('$ ? (@.a < +.1)' AS jsonpath);
SELECT CAST('$ ? (@.a < 0.1)' AS jsonpath);
SELECT CAST('$ ? (@.a < -0.1)' AS jsonpath);
SELECT CAST('$ ? (@.a < +0.1)' AS jsonpath);
SELECT CAST('$ ? (@.a < 10.1)' AS jsonpath);
SELECT CAST('$ ? (@.a < -10.1)' AS jsonpath);
SELECT CAST('$ ? (@.a < +10.1)' AS jsonpath);
SELECT CAST('$ ? (@.a < 1e1)' AS jsonpath);
SELECT CAST('$ ? (@.a < -1e1)' AS jsonpath);
SELECT CAST('$ ? (@.a < +1e1)' AS jsonpath);
SELECT CAST('$ ? (@.a < .1e1)' AS jsonpath);
SELECT CAST('$ ? (@.a < -.1e1)' AS jsonpath);
SELECT CAST('$ ? (@.a < +.1e1)' AS jsonpath);
SELECT CAST('$ ? (@.a < 0.1e1)' AS jsonpath);
SELECT CAST('$ ? (@.a < -0.1e1)' AS jsonpath);
SELECT CAST('$ ? (@.a < +0.1e1)' AS jsonpath);
SELECT CAST('$ ? (@.a < 10.1e1)' AS jsonpath);
SELECT CAST('$ ? (@.a < -10.1e1)' AS jsonpath);
SELECT CAST('$ ? (@.a < +10.1e1)' AS jsonpath);
SELECT CAST('$ ? (@.a < 1e-1)' AS jsonpath);
SELECT CAST('$ ? (@.a < -1e-1)' AS jsonpath);
SELECT CAST('$ ? (@.a < +1e-1)' AS jsonpath);
SELECT CAST('$ ? (@.a < .1e-1)' AS jsonpath);
SELECT CAST('$ ? (@.a < -.1e-1)' AS jsonpath);
SELECT CAST('$ ? (@.a < +.1e-1)' AS jsonpath);
SELECT CAST('$ ? (@.a < 0.1e-1)' AS jsonpath);
SELECT CAST('$ ? (@.a < -0.1e-1)' AS jsonpath);
SELECT CAST('$ ? (@.a < +0.1e-1)' AS jsonpath);
SELECT CAST('$ ? (@.a < 10.1e-1)' AS jsonpath);
SELECT CAST('$ ? (@.a < -10.1e-1)' AS jsonpath);
SELECT CAST('$ ? (@.a < +10.1e-1)' AS jsonpath);
SELECT CAST('$ ? (@.a < 1e+1)' AS jsonpath);
SELECT CAST('$ ? (@.a < -1e+1)' AS jsonpath);
SELECT CAST('$ ? (@.a < +1e+1)' AS jsonpath);
SELECT CAST('$ ? (@.a < .1e+1)' AS jsonpath);
SELECT CAST('$ ? (@.a < -.1e+1)' AS jsonpath);
SELECT CAST('$ ? (@.a < +.1e+1)' AS jsonpath);
SELECT CAST('$ ? (@.a < 0.1e+1)' AS jsonpath);
SELECT CAST('$ ? (@.a < -0.1e+1)' AS jsonpath);
SELECT CAST('$ ? (@.a < +0.1e+1)' AS jsonpath);
SELECT CAST('$ ? (@.a < 10.1e+1)' AS jsonpath);
SELECT CAST('$ ? (@.a < -10.1e+1)' AS jsonpath);
SELECT CAST('$ ? (@.a < +10.1e+1)' AS jsonpath);
/* numeric literals */ SELECT CAST('0' AS jsonpath);
SELECT CAST('00' AS jsonpath);
SELECT CAST('0755' AS jsonpath);
SELECT CAST('0.0' AS jsonpath);
SELECT CAST('0.000' AS jsonpath);
SELECT CAST('0.000e1' AS jsonpath);
SELECT CAST('0.000e2' AS jsonpath);
SELECT CAST('0.000e3' AS jsonpath);
SELECT CAST('0.0010' AS jsonpath);
SELECT CAST('0.0010e-1' AS jsonpath);
SELECT CAST('0.0010e+1' AS jsonpath);
SELECT CAST('0.0010e+2' AS jsonpath);
SELECT CAST('.001' AS jsonpath);
SELECT CAST('.001e1' AS jsonpath);
SELECT CAST('1.' AS jsonpath);
SELECT CAST('1.e1' AS jsonpath);
SELECT CAST('1a' AS jsonpath);
SELECT CAST('1e' AS jsonpath);
SELECT CAST('1.e' AS jsonpath);
SELECT CAST('1.2a' AS jsonpath);
SELECT CAST('1.2e' AS jsonpath);
SELECT CAST('1.2.e' AS jsonpath);
SELECT CAST('(1.2).e' AS jsonpath);
SELECT CAST('1e3' AS jsonpath);
SELECT CAST('1.e3' AS jsonpath);
SELECT CAST('1.e3.e' AS jsonpath);
SELECT CAST('1.e3.e4' AS jsonpath);
SELECT CAST('1.2e3' AS jsonpath);
SELECT CAST('1.2e3a' AS jsonpath);
SELECT CAST('1.2.e3' AS jsonpath);
SELECT CAST('(1.2).e3' AS jsonpath);
SELECT CAST('1..e' AS jsonpath);
SELECT CAST('1..e3' AS jsonpath);
SELECT CAST('(1.).e' AS jsonpath);
SELECT CAST('(1.).e3' AS jsonpath);
SELECT CAST('1?(2>3)' AS jsonpath);
/* nondecimal */ SELECT CAST('0b100101' AS jsonpath);
SELECT CAST('0o273' AS jsonpath);
SELECT CAST('0x42F' AS jsonpath);
/* error cases */ SELECT CAST('0b' AS jsonpath);
SELECT CAST('1b' AS jsonpath);
SELECT CAST('0b0x' AS jsonpath);
SELECT CAST('0o' AS jsonpath);
SELECT CAST('1o' AS jsonpath);
SELECT CAST('0o0x' AS jsonpath);
SELECT CAST('0x' AS jsonpath);
SELECT CAST('1x' AS jsonpath);
SELECT CAST('0x0y' AS jsonpath);
/* underscores */ SELECT CAST('1_000_000' AS jsonpath);
SELECT CAST('1_2_3' AS jsonpath);
SELECT CAST('0x1EEE_FFFF' AS jsonpath);
SELECT CAST('0o2_73' AS jsonpath);
SELECT CAST('0b10_0101' AS jsonpath);
SELECT CAST('1_000.000_005' AS jsonpath);
SELECT CAST('1_000.' AS jsonpath);
SELECT CAST('.000_005' AS jsonpath);
SELECT CAST('1_000.5e0_1' AS jsonpath);
/* error cases */ SELECT CAST('_100' AS jsonpath);
SELECT CAST('100_' AS jsonpath);
SELECT CAST('100__000' AS jsonpath);
SELECT CAST('_1_000.5' AS jsonpath);
SELECT CAST('1_000_.5' AS jsonpath);
SELECT CAST('1_000._5' AS jsonpath);
SELECT CAST('1_000.5_' AS jsonpath);
SELECT CAST('1_000.5e_1' AS jsonpath);
/* underscore after prefix not allowed in JavaScript (but allowed in SQL) */ SELECT CAST('0b_10_0101' AS jsonpath);
SELECT CAST('0o_273' AS jsonpath);
SELECT CAST('0x_42F' AS jsonpath);
/* test non-error-throwing API */ SELECT x AS x, PG_INPUT_IS_VALID(x, 'jsonpath') AS x, x.x, x.x, x.x, x.x FROM UNNEST(ARRAY(CAST('$ ? (@ like_regex "pattern" flag "smixq")' AS TEXT), '$ ? (@ like_regex "pattern" flag "a")', '@ + 1', '00', '1a')) AS x, LATERAL PG_INPUT_ERROR_INFO(x, 'jsonpath') AS x;
/* just to label the results files */ /* checks for double-quoted values */ /* basic unicode input */ SELECT CAST('"\u"' AS jsonpath);
/* ERROR, incomplete escape */ SELECT CAST('"\u00"' AS jsonpath);
/* ERROR, incomplete escape */ SELECT CAST('"\u000g"' AS jsonpath);
/* ERROR, g is not a hex digit */ SELECT CAST('"\u0000"' AS jsonpath);
/* OK, legal escape */ SELECT CAST('"\uaBcD"' AS jsonpath);
/* OK, uppercase and lower case both OK */ /* handling of unicode surrogate pairs */ SELECT CAST('"\ud83d\ude04\ud83d\udc36"' AS jsonpath) AS x;
SELECT CAST('"\ud83d\ud83d"' AS jsonpath);
/* 2 high surrogates in a row */ SELECT CAST('"\ude04\ud83d"' AS jsonpath);
/* surrogates in wrong order */ SELECT CAST('"\ud83dX"' AS jsonpath);
/* orphan high surrogate */ SELECT CAST('"\ude04X"' AS jsonpath);
/* orphan low surrogate */ /* handling of simple unicode escapes */ SELECT CAST('"the Copyright \u00a9 sign"' AS jsonpath) AS x;
SELECT CAST('"dollar \u0024 character"' AS jsonpath) AS x;
SELECT CAST('"dollar \\u0024 character"' AS jsonpath) AS x;
SELECT CAST('"null \u0000 escape"' AS jsonpath) AS x;
SELECT CAST('"null \\u0000 escape"' AS jsonpath) AS x;
/* checks for quoted key names */ /* basic unicode input */ SELECT CAST('$."\u"' AS jsonpath);
/* ERROR, incomplete escape */ SELECT CAST('$."\u00"' AS jsonpath);
/* ERROR, incomplete escape */ SELECT CAST('$."\u000g"' AS jsonpath);
/* ERROR, g is not a hex digit */ SELECT CAST('$."\u0000"' AS jsonpath);
/* OK, legal escape */ SELECT CAST('$."\uaBcD"' AS jsonpath);
/* OK, uppercase and lower case both OK */ /* handling of unicode surrogate pairs */ SELECT CAST('$."\ud83d\ude04\ud83d\udc36"' AS jsonpath) AS x;
SELECT CAST('$."\ud83d\ud83d"' AS jsonpath);
/* 2 high surrogates in a row */ SELECT CAST('$."\ude04\ud83d"' AS jsonpath);
/* surrogates in wrong order */ SELECT CAST('$."\ud83dX"' AS jsonpath);
/* orphan high surrogate */ SELECT CAST('$."\ude04X"' AS jsonpath);
/* orphan low surrogate */ /* handling of simple unicode escapes */ SELECT CAST('$."the Copyright \u00a9 sign"' AS jsonpath) AS x;
SELECT CAST('$."dollar \u0024 character"' AS jsonpath) AS x;
SELECT CAST('$."dollar \\u0024 character"' AS jsonpath) AS x;
SELECT CAST('$."null \u0000 escape"' AS jsonpath) AS x;
SELECT CAST('$."null \\u0000 escape"' AS jsonpath) AS x;
/* just to label the results files */ /* first json */ /* basic unicode input */ SELECT CAST('"\u"' AS JSON);
/* ERROR, incomplete escape */ SELECT CAST('"\u00"' AS JSON);
/* ERROR, incomplete escape */ SELECT CAST('"\u000g"' AS JSON);
/* ERROR, g is not a hex digit */ SELECT CAST('"\u0000"' AS JSON);
/* OK, legal escape */ SELECT CAST('"\uaBcD"' AS JSON);
/* orphan low surrogate */ /* handling of simple unicode escapes */ SELECT PARSE_JSON('{ "a":  "the Copyright \u00a9 sign" }') AS x;
SELECT PARSE_JSON('{ "a":  "dollar \u0024 character" }') AS x;
SELECT PARSE_JSON('{ "a":  "dollar \\u0024 character" }') AS x;
SELECT PARSE_JSON('{ "a":  "null \u0000 escape" }') AS x;
SELECT PARSE_JSON('{ "a":  "null \\u0000 escape" }') AS x;
/* then jsonb */ /* basic unicode input */ SELECT CAST('"\u"' AS JSONB);
/* ERROR, incomplete escape */ SELECT CAST('"\u00"' AS JSONB);
/* ERROR, incomplete escape */ SELECT CAST('"\u000g"' AS JSONB);
/* ERROR, g is not a hex digit */ SELECT CAST('"\u0045"' AS JSONB);
/* OK, legal escape */ SELECT CAST('"\u0000"' AS JSONB);
/* ERROR, we don't support U+0000 */ /* use octet_length here so we don't get an odd unicode char in the */ /* output */ SELECT OCTET_LENGTH(CAST(CAST('"\uaBcD"' AS JSONB) AS TEXT));
/* orphan low surrogate */ /* handling of simple unicode escapes */ SELECT CAST('{ "a":  "the Copyright \u00a9 sign" }' AS JSONB) AS x;
SELECT CAST('{ "a":  "dollar \u0024 character" }' AS JSONB) AS x;
SELECT CAST('{ "a":  "dollar \\u0024 character" }' AS JSONB) AS x;
SELECT CAST('{ "a":  "null \u0000 escape" }' AS JSONB) AS x;
SELECT CAST('{ "a":  "null \\u0000 escape" }' AS JSONB) AS x;
/* soft error for input-time failure */ SELECT * FROM x;
/* Test ALTER LARGE OBJECT OWNER */ CREATE ROLE regress_lo_user;
SELECT LO_CREATE(42);
ALTER LARGE OBJECT 42 OWNER TO regress_lo_user;
/* Test GRANT, COMMENT as non-superuser */ SET SESSION AUTHORIZATION regress_lo_user;
GRANT SELECT ON LARGE OBJECT 42 TO public;
COMMENT ON LARGE OBJECT 42 IS 'the ultimate answer';
RESET SESSION AUTHORIZATION;
/* lo_creat(mode integer) returns oid */ /* The mode arg to lo_creat is unused, some vestigal holdover from ancient times */ /* returns the large object id */ INSERT INTO x (x) SELECT LO_CREAT(42);
/* NOTE: large objects require transactions */ BEGIN;
/* lo_open(lobjId oid, mode integer) returns integer */ /* The mode parameter to lo_open uses two constants: */ /*   INV_WRITE = 0x20000 */ /*   INV_READ  = 0x40000 */ /* The return value is a file descriptor-like value which remains valid for the */ /* transaction. */ UPDATE x SET x = LO_OPEN(x, CAST(131072 | 262144 AS INT));
/* lo_close(fd integer) returns integer */ /* return value is 0 for success, or <0 for error (actually only -1, but...) */ SELECT LO_CLOSE(x) FROM x;
COMMIT;
/* Read out a portion */ BEGIN;
UPDATE x SET x = LO_OPEN(x, CAST(131072 | 262144 AS INT));
/* lo_lseek(fd integer, offset integer, whence integer) returns integer */ /* offset is in bytes, whence is one of three values: */ /*  SEEK_SET (= 0) meaning relative to beginning */ /*  SEEK_CUR (= 1) meaning relative to current position */ /*  SEEK_END (= 2) meaning relative to end (offset better be negative) */ /* returns current position in file */ SELECT LO_LSEEK(x, 104, 0) FROM x;
/* loread/lowrite names are wonky, different from other functions which are lo_* */ /* loread(fd integer, len integer) returns bytea */ SELECT LOREAD(x, 28) FROM x;
SELECT LO_LSEEK(x, -19, 1) FROM x;
SELECT LOWRITE(x, 'n') FROM x;
SELECT LO_TELL(x) FROM x;
SELECT LO_LSEEK(x, -744, 2) FROM x;
SELECT LOREAD(x, 28) FROM x;
SELECT LO_CLOSE(x) FROM x;
COMMIT;
/* Test resource management */ BEGIN;
SELECT LO_OPEN(x, CAST(262144 AS INT)) FROM x;
x;
BEGIN ' \set dobody :dobody 'SELECT tbl.loid INTO loid FROM lotest_stash_values tbl;
/* Test truncation. */ BEGIN;
UPDATE x SET x = LO_OPEN(x, CAST(131072 | 262144 AS INT));
SELECT LO_TRUNCATE(x, 11) FROM x;
SELECT LOREAD(x, 15) FROM x;
SELECT LO_TRUNCATE(x, 10000) FROM x;
SELECT LOREAD(x, 10) FROM x;
SELECT LO_LSEEK(x, 0, 2) FROM x;
SELECT LO_TELL(x) FROM x;
SELECT LO_TRUNCATE(x, 5000) FROM x;
SELECT LO_LSEEK(x, 0, 2) FROM x;
SELECT LO_TELL(x) FROM x;
SELECT LO_CLOSE(x) FROM x;
COMMIT;
/* Test 64-bit large object functions. */ BEGIN;
UPDATE x SET x = LO_OPEN(x, CAST(131072 | 262144 AS INT));
SELECT LO_LSEEK64(x, 4294967296, 0) FROM x;
SELECT LOWRITE(x, 'offset:4GB') FROM x;
SELECT LO_TELL64(x) FROM x;
SELECT LO_LSEEK64(x, -10, 1) FROM x;
SELECT LO_TELL64(x) FROM x;
SELECT LOREAD(x, 10) FROM x;
SELECT LO_TRUNCATE64(x, 5000000000) FROM x;
SELECT LO_LSEEK64(x, 0, 2) FROM x;
SELECT LO_TELL64(x) FROM x;
SELECT LO_TRUNCATE64(x, 3000000000) FROM x;
SELECT LO_LSEEK64(x, 0, 2) FROM x;
SELECT LO_TELL64(x) FROM x;
SELECT LO_CLOSE(x) FROM x;
COMMIT;
/* lo_unlink(lobjId oid) returns integer */ /* return value appears to always be 1 */ SELECT LO_UNLINK(x) FROM x;
TRUNCATE TABLE x;
BEGIN;
UPDATE x SET x = LO_OPEN(x, CAST(131072 | 262144 AS INT));
/* verify length of large object */ SELECT LO_LSEEK(x, 0, 2) FROM x;
/* with the default BLCKSZ, LOBLKSIZE = 2048, so this positions us for a block */ /* edge case */ SELECT LO_LSEEK(x, 2030, 0) FROM x;
/* this should get half of the value from page 0 and half from page 1 of the */ /* large object */ SELECT LOREAD(x, 36) FROM x;
SELECT LO_TELL(x) FROM x;
SELECT LO_LSEEK(x, -26, 1) FROM x;
SELECT LOWRITE(x, 'abcdefghijklmnop') FROM x;
SELECT LO_LSEEK(x, 2030, 0) FROM x;
SELECT LOREAD(x, 36) FROM x;
SELECT LO_CLOSE(x) FROM x;
COMMIT;
SELECT LO_UNLINK(x) FROM x;
TRUNCATE TABLE x;
SELECT LO_GET(:newloid_1, 0, 20);
SELECT LO_GET(:newloid_1, 10, 20);
SELECT LO_PUT(:newloid_1, 5, DECODE('afafafaf', 'hex'));
SELECT LO_GET(:newloid_1, 0, 20);
SELECT LO_PUT(:newloid_1, 4294967310, 'foo');
SELECT LO_GET(:newloid_1);
SELECT LO_GET(:newloid_1, 4294967294, 100);
SELECT LO_GET(:newloid);
/* this one intentionally has an OID in the system range */ SELECT LO_CREATE(2121);
COMMENT ON LARGE OBJECT 2121 IS 'testing comments';
/* INV_READ ... ok */ SELECT LO_OPEN(2121, CAST(262144 AS INT));
/* INV_WRITE ... error */ SELECT LO_OPEN(2121, CAST(131072 AS INT));
ROLLBACK;
SELECT LO_CREATE(42);
ROLLBACK;
SELECT LO_CREAT(42);
ROLLBACK;
SELECT LO_UNLINK(42);
ROLLBACK;
SELECT LOWRITE(42, 'x');
ROLLBACK;
ROLLBACK;
SELECT LO_TRUNCATE(42, 0);
ROLLBACK;
SELECT LO_TRUNCATE64(42, 0);
ROLLBACK;
SELECT LO_FROM_BYTEA(0, 'x');
ROLLBACK;
SELECT LO_PUT(42, 0, 'x');
ROLLBACK;
/* Clean up */ DROP TABLE x;
DROP ROLE regress_lo_user;
/* LIMIT */ /* Check the LIMIT/OFFSET feature of SELECT */ SELECT CAST('' AS TEXT) AS x, x, x, x FROM x WHERE x > 50 ORDER BY x NULLS LAST LIMIT 2;
SELECT CAST('' AS TEXT) AS x, x, x, x FROM x WHERE x > 60 ORDER BY x NULLS LAST LIMIT 5;
SELECT CAST('' AS TEXT) AS x, x, x, x FROM x WHERE x > 60 AND x < 63 ORDER BY x NULLS LAST LIMIT 5;
SELECT CAST('' AS TEXT) AS x, x, x, x FROM x WHERE x > 100 ORDER BY x NULLS LAST LIMIT 3 OFFSET 20;
SELECT CAST('' AS TEXT) AS x, x, x, x FROM x WHERE x < 50 ORDER BY x DESC NULLS FIRST LIMIT 8 OFFSET 99;
SELECT CAST('' AS TEXT) AS x, x, x, x FROM x WHERE x < 50 ORDER BY x DESC NULLS FIRST LIMIT 20 OFFSET 39;
SELECT CAST('' AS TEXT) AS x, x, x, x FROM x ORDER BY x NULLS LAST OFFSET 990;
SELECT CAST('' AS TEXT) AS x, x, x, x FROM x ORDER BY x NULLS LAST LIMIT 5 OFFSET 990;
SELECT CAST('' AS TEXT) AS x, x, x, x FROM x ORDER BY x NULLS LAST LIMIT 5 OFFSET 900;
/* Test null limit and offset.  The planner would discard a simple null */ /* constant, so to ensure executor is exercised, do this: */ SELECT * FROM x LIMIT (CASE WHEN RAND() < 0.5 THEN CAST(NULL AS BIGINT) END);
SELECT * FROM x OFFSET (CASE WHEN RAND() < 0.5 THEN CAST(NULL AS BIGINT) END);
/* Test assorted cases involving backwards fetch from a LIMIT plan node */ BEGIN;
DECLARE c1 cursor for select * from int8_tbl limit 10;
FETCH all in c1;
FETCH 1 in c1;
FETCH backward 1 in c1;
FETCH backward all in c1;
FETCH backward 1 in c1;
FETCH all in c1;
DECLARE c2 cursor for select * from int8_tbl limit 3;
FETCH all in c2;
FETCH 1 in c2;
FETCH backward 1 in c2;
FETCH backward all in c2;
FETCH backward 1 in c2;
FETCH all in c2;
DECLARE c3 cursor for select * from int8_tbl offset 3;
FETCH all in c3;
FETCH 1 in c3;
FETCH backward 1 in c3;
FETCH backward all in c3;
FETCH backward 1 in c3;
FETCH all in c3;
DECLARE c4 cursor for select * from int8_tbl offset 10;
FETCH all in c4;
FETCH 1 in c4;
FETCH backward 1 in c4;
FETCH backward all in c4;
FETCH backward 1 in c4;
FETCH all in c4;
DECLARE c5 cursor for select * from int8_tbl order by q1 fetch first 2 rows with ties;
FETCH all in c5;
FETCH 1 in c5;
FETCH backward 1 in c5;
FETCH backward 1 in c5;
FETCH all in c5;
FETCH backward all in c5;
FETCH all in c5;
FETCH backward all in c5;
ROLLBACK;
/* Stress test for variable LIMIT in conjunction with bounded-heap sorting */ SELECT (SELECT x FROM (VALUES (1)) AS x, (SELECT x FROM x AS x ORDER BY x NULLS LAST LIMIT 1 OFFSET x - 1) AS x) AS x FROM x AS x;
/* Test behavior of volatile and set-returning functions in conjunction */ /* with ORDER BY and LIMIT. */ CREATE TEMPORARY SEQUENCE x;
EXPLAIN (verbose, costs off) select unique1, unique2, nextval('testseq')   from tenk1 order by unique2 limit 10;
SELECT x, x, NEXTVAL('testseq') FROM x ORDER BY x NULLS LAST LIMIT 10;
SELECT CURRVAL('testseq');
EXPLAIN (verbose, costs off) select unique1, unique2, nextval('testseq')   from tenk1 order by tenthous limit 10;
SELECT x, x, NEXTVAL('testseq') FROM x ORDER BY x NULLS LAST LIMIT 10;
SELECT CURRVAL('testseq');
EXPLAIN (verbose, costs off) select unique1, unique2, generate_series(1,10)   from tenk1 order by unique2 limit 7;
SELECT x, x, UNNEST(GENERATE_SERIES(1, 10)) FROM x ORDER BY x NULLS LAST LIMIT 7;
EXPLAIN (verbose, costs off) select unique1, unique2, generate_series(1,10)   from tenk1 order by tenthous limit 7;
SELECT x, x, UNNEST(GENERATE_SERIES(1, 10)) FROM x ORDER BY x NULLS LAST LIMIT 7;
/* use of random() is to keep planner from folding the expressions together */ EXPLAIN (verbose, costs off) select generate_series(0,2) as s1, generate_series((random()*.1)::int,2) as s2;
SELECT UNNEST(GENERATE_SERIES(0, 2)) AS x, UNNEST(GENERATE_SERIES(CAST((RAND() * 0.1) AS INT), 2)) AS x;
EXPLAIN (verbose, costs off) select generate_series(0,2) as s1, generate_series((random()*.1)::int,2) as s2 order by s2 desc;
SELECT UNNEST(GENERATE_SERIES(0, 2)) AS x, UNNEST(GENERATE_SERIES(CAST((RAND() * 0.1) AS INT), 2)) AS x ORDER BY x DESC NULLS FIRST;
/* test for failure to set all aggregates' aggtranstype */ EXPLAIN (verbose, costs off) select sum(tenthous) as s1, sum(tenthous) + random()*0 as s2   from tenk1 group by thousand order by thousand limit 3;
SELECT SUM(x) AS x, SUM(x) + RAND() * 0 AS x FROM x GROUP BY x ORDER BY x NULLS LAST LIMIT 3;
/* FETCH FIRST */ /* Check the WITH TIES clause */ SELECT x FROM x WHERE x < 5 ORDER BY x NULLS LAST FETCH FIRST 2 ROWS WITH TIES;
SELECT x FROM x WHERE x < 5 ORDER BY x NULLS LAST FETCH FIRST ROWS WITH TIES;
SELECT x FROM x WHERE x < 5 ORDER BY x NULLS LAST FETCH FIRST 1 ROWS WITH TIES;
SELECT x FROM x WHERE x < 5 ORDER BY x NULLS LAST FETCH FIRST 2 ROWS ONLY;
/* SKIP LOCKED and WITH TIES are incompatible */ SELECT x FROM x WHERE x < 5 ORDER BY x NULLS LAST FETCH FIRST 1 ROWS WITH TIES;
/* should fail */ SELECT CAST('' AS TEXT) AS x, x, x, x FROM x WHERE x > 50 FETCH FIRST 2 ROWS WITH TIES;
/* test ruleutils */ CREATE VIEW x AS SELECT x FROM x WHERE x < 995 ORDER BY x NULLS LAST OFFSET 10 FETCH FIRST 5 ROWS WITH TIES;
/* fails */ CREATE VIEW x AS SELECT x FROM x WHERE x < 995 ORDER BY x NULLS LAST FETCH FIRST (NULL + 1) ROWS WITH TIES;
CREATE TABLE x (x line);
INSERT INTO x VALUES ('{0,-1,5}');
/* A == 0 */ INSERT INTO x VALUES ('{1,0,5}');
/* B == 0 */ INSERT INTO x VALUES ('{0,3,0}');
/* A == C == 0 */ INSERT INTO x VALUES (' (0,0), (6,6)');
INSERT INTO x VALUES ('10,-10 ,-5,-4');
INSERT INTO x VALUES ('[-1e6,2e2,3e5, -4e1]');
INSERT INTO x VALUES ('{3,NaN,5}');
INSERT INTO x VALUES ('{NaN,NaN,NaN}');
/* horizontal */ INSERT INTO x VALUES ('[(1,3),(2,3)]');
/* bad values for parser testing */ INSERT INTO x VALUES ('{}');
INSERT INTO x VALUES ('{0');
INSERT INTO x VALUES ('{0,0}');
INSERT INTO x VALUES ('{0,0,1');
INSERT INTO x VALUES ('{0,0,1}');
INSERT INTO x VALUES ('{0,0,1} x');
INSERT INTO x VALUES ('(3asdf,2 ,3,4r2)');
INSERT INTO x VALUES ('[1,2,3, 4');
INSERT INTO x VALUES ('[(,2),(3,4)]');
INSERT INTO x VALUES ('[(1,2),(3,4)');
INSERT INTO x VALUES ('[(1,2),(1,2)]');
SELECT * FROM x;
SELECT CAST('{nan, 1, nan}' AS line) = CAST('{nan, 1, nan}' AS line) AS x, CAST('{nan, 1, nan}' AS line) = CAST('{nan, 2, nan}' AS line) AS x;
/* test non-error-throwing API for some core types */ SELECT PG_INPUT_IS_VALID('{1, 1}', 'line');
SELECT * FROM x;
SELECT PG_INPUT_IS_VALID('{0, 0, 0}', 'line');
SELECT * FROM x;
SELECT PG_INPUT_IS_VALID('{1, 1, a}', 'line');
SELECT * FROM x;
SELECT PG_INPUT_IS_VALID('{1, 1, 1e400}', 'line');
SELECT * FROM x;
SELECT PG_INPUT_IS_VALID('(1, 1), (1, 1e400)', 'line');
SELECT * FROM x;
SET x = lock_schema1;
CREATE TABLE x (x BIGINT);
CREATE TABLE x (x BIGINT);
CREATE VIEW x AS SELECT * FROM x;
CREATE VIEW x (x, x) AS SELECT * FROM x, x;
CREATE VIEW x AS SELECT * FROM x;
CREATE VIEW x AS SELECT (SELECT x FROM x LIMIT 1) FROM x;
CREATE VIEW x AS SELECT * FROM x WHERE x IN (SELECT * FROM x);
CREATE VIEW x AS SELECT * FROM (SELECT * FROM x) AS x;
CREATE ROLE regress_rol_lock1;
ALTER ROLE regress_rol_lock1 SET search_path = lock_schema1;
GRANT USAGE ON SCHEMA x TO x;
ROLLBACK;
BEGIN /* Try using NOWAIT along with valid options. */ /* Try using NOWAIT along with valid options. */;
ROLLBACK;
BEGIN /* Verify that we can lock views. */ /* Verify that we can lock views. */;
/* lock_view1 and lock_tbl1 are locked. */ SELECT x FROM x AS x, x AS x WHERE x.x = x.x AND x LIKE '%lock_%' AND x = 'ExclusiveLock' ORDER BY x NULLS LAST;
ROLLBACK;
BEGIN;
/* lock_view1, lock_tbl1, and lock_tbl1a are locked. */ SELECT x FROM x AS x, x AS x WHERE x.x = x.x AND x LIKE '%lock_%' AND x = 'ExclusiveLock' ORDER BY x NULLS LAST;
ROLLBACK;
BEGIN;
/* lock_view3, lock_view2, lock_tbl1, and lock_tbl1a are locked recursively. */ SELECT x FROM x AS x, x AS x WHERE x.x = x.x AND x LIKE '%lock_%' AND x = 'ExclusiveLock' ORDER BY x NULLS LAST;
ROLLBACK;
BEGIN;
/* lock_view4, lock_tbl1, and lock_tbl1a are locked. */ SELECT x FROM x AS x, x AS x WHERE x.x = x.x AND x LIKE '%lock_%' AND x = 'ExclusiveLock' ORDER BY x NULLS LAST;
ROLLBACK;
BEGIN;
/* lock_view5, lock_tbl1, and lock_tbl1a are locked. */ SELECT x FROM x AS x, x AS x WHERE x.x = x.x AND x LIKE '%lock_%' AND x = 'ExclusiveLock' ORDER BY x NULLS LAST;
ROLLBACK;
BEGIN;
/* lock_view6 an lock_tbl1 are locked. */ SELECT x FROM x AS x, x AS x WHERE x.x = x.x AND x LIKE '%lock_%' AND x = 'ExclusiveLock' ORDER BY x NULLS LAST;
ROLLBACK;
/* Verify that we cope with infinite recursion in view definitions. */ CREATE OR REPLACE VIEW x AS SELECT * FROM x;
BEGIN;
ROLLBACK;
CREATE VIEW x AS SELECT * FROM x;
BEGIN;
ROLLBACK;
/* Verify that we can lock a table with inheritance children. */ CREATE TABLE x (x BIGINT) INHERITS (x);
CREATE TABLE x INHERITS (x);
BEGIN;
ROLLBACK;
GRANT UPDATE ON TABLE x TO x /* Child tables are locked without granting explicit permission to do so as */ /* long as we have permission to lock the parent. */;
SET ROLE regress_rol_lock1;
/* fail when child locked directly */ BEGIN;
ROLLBACK;
BEGIN;
ROLLBACK;
BEGIN;
ROLLBACK;
RESET ROLE;
REVOKE UPDATE ON TABLE lock_tbl1 FROM regress_rol_lock1;
/* Tables referred to by views are locked without explicit permission to do so */ /* as long as we have permission to lock the view itself. */ SET ROLE regress_rol_lock1;
/* fail without permissions on the view */ BEGIN;
ROLLBACK;
RESET ROLE;
GRANT UPDATE ON TABLE x TO x;
SET ROLE regress_rol_lock1;
BEGIN;
/* lock_view1 and lock_tbl1 (plus children lock_tbl2 and lock_tbl3) are locked. */ SELECT x FROM x AS x, x AS x WHERE x.x = x.x AND x LIKE '%lock_%' AND x = 'AccessExclusiveLock' ORDER BY x NULLS LAST;
ROLLBACK;
RESET ROLE;
REVOKE UPDATE ON TABLE lock_view1 FROM regress_rol_lock1;
SET ROLE regress_rol_lock1;
/* fail without permissions on the view */ BEGIN;
ROLLBACK;
RESET ROLE;
GRANT UPDATE ON TABLE x TO x;
SET ROLE regress_rol_lock1;
/* fail without permissions on the table referenced by the view */ BEGIN;
ROLLBACK;
RESET ROLE;
GRANT UPDATE ON TABLE x TO x;
BEGIN;
/* lock_view8 and lock_tbl1 (plus children lock_tbl2 and lock_tbl3) are locked. */ SELECT x FROM x AS x, x AS x WHERE x.x = x.x AND x LIKE '%lock_%' AND x = 'AccessExclusiveLock' ORDER BY x NULLS LAST;
ROLLBACK;
RESET ROLE;
REVOKE UPDATE ON TABLE lock_view8 FROM regress_rol_lock1;
/* Clean up */ DROP VIEW x;
DROP VIEW x;
DROP VIEW x;
DROP VIEW x;
DROP VIEW x;
DROP VIEW x CASCADE;
DROP VIEW x;
DROP TABLE x;
DROP TABLE x;
DROP TABLE x;
DROP TABLE x;
DROP SCHEMA x.x CASCADE;
DROP ROLE regress_rol_lock1;
/* atomic ops tests */ RESET search_path;
CREATE FUNCTION test_atomic_ops()     RETURNS bool     AS :'regresslib'     LANGUAGE C;
SELECT TEST_ATOMIC_OPS();
CREATE TABLE x (x lseg);
INSERT INTO x VALUES ('[(1,2),(3,4)]');
INSERT INTO x VALUES ('(0,0),(6,6)');
INSERT INTO x VALUES ('10,-10 ,-3,-4');
INSERT INTO x VALUES ('[-1e6,2e2,3e5, -4e1]');
INSERT INTO x VALUES (LSEG(POINT(11, 22), POINT(33, 44)));
INSERT INTO x VALUES ('[(-10,2),(-10,3)]');
/* vertical */ INSERT INTO x VALUES ('[(0,-20),(30,-20)]');
/* horizontal */ INSERT INTO x VALUES ('[(NaN,1),(NaN,90)]');
/* NaN */ /* bad values for parser testing */ INSERT INTO x VALUES ('(3asdf,2 ,3,4r2)');
INSERT INTO x VALUES ('[1,2,3, 4');
INSERT INTO x VALUES ('[(,2),(3,4)]');
INSERT INTO x VALUES ('[(1,2),(3,4)');
SELECT * FROM x;
/* test non-error-throwing API for some core types */ SELECT PG_INPUT_IS_VALID('[(1,2),(3)]', 'lseg');
SELECT * FROM x;
/* macaddr */ CREATE TABLE x (x INT, x macaddr);
INSERT INTO x VALUES (1, '08:00:2b:01:02:03');
INSERT INTO x VALUES (2, '08-00-2b-01-02-03');
INSERT INTO x VALUES (3, '08002b:010203');
INSERT INTO x VALUES (4, '08002b-010203');
INSERT INTO x VALUES (5, '0800.2b01.0203');
INSERT INTO x VALUES (6, '0800-2b01-0203');
INSERT INTO x VALUES (7, '08002b010203');
INSERT INTO x VALUES (8, '0800:2b01:0203');
/* invalid */ INSERT INTO x VALUES (9, 'not even close');
/* invalid */ INSERT INTO x VALUES (10, '08:00:2b:01:02:04');
INSERT INTO x VALUES (11, '08:00:2b:01:02:02');
INSERT INTO x VALUES (12, '08:00:2a:01:02:03');
INSERT INTO x VALUES (13, '08:00:2c:01:02:03');
INSERT INTO x VALUES (14, '08:00:2a:01:02:04');
SELECT * FROM x;
CREATE INDEX x ON x USING btree(x NULLS LAST);
CREATE INDEX x ON x USING hash(x NULLS LAST);
SELECT x, x, TRUNC(x) FROM x ORDER BY 2 NULLS LAST, 1 NULLS LAST;
SELECT x < '08:00:2b:01:02:04' FROM x WHERE x = 1;
/* true */ SELECT x > '08:00:2b:01:02:04' FROM x WHERE x = 1;
/* false */ SELECT x > '08:00:2b:01:02:03' FROM x WHERE x = 1;
/* false */ SELECT x <= '08:00:2b:01:02:04' FROM x WHERE x = 1;
/* true */ SELECT x >= '08:00:2b:01:02:04' FROM x WHERE x = 1;
/* false */ SELECT x = '08:00:2b:01:02:03' FROM x WHERE x = 1;
/* true */ SELECT x <> '08:00:2b:01:02:04' FROM x WHERE x = 1;
/* true */ SELECT x <> '08:00:2b:01:02:03' FROM x WHERE x = 1;
SELECT x & '00:00:00:ff:ff:ff' FROM x;
SELECT x | '01:02:03:04:05:06' FROM x;
DROP TABLE x;
/* test non-error-throwing API for some core types */ SELECT PG_INPUT_IS_VALID('08:00:2b:01:02:ZZ', 'macaddr');
SELECT * FROM x;
SELECT PG_INPUT_IS_VALID('08:00:2b:01:02:', 'macaddr');
SELECT * FROM x;
/* macaddr8 */ /* test various cases of valid and invalid input */ /* valid */ SELECT CAST('08:00:2b:01:02:03     ' AS macaddr8);
SELECT CAST('    08:00:2b:01:02:03     ' AS macaddr8);
SELECT CAST('    08:00:2b:01:02:03' AS macaddr8);
SELECT CAST('08:00:2b:01:02:03:04:05     ' AS macaddr8);
SELECT CAST('    08:00:2b:01:02:03:04:05     ' AS macaddr8);
SELECT CAST('    08:00:2b:01:02:03:04:05' AS macaddr8);
SELECT CAST('123    08:00:2b:01:02:03' AS macaddr8);
/* invalid */ SELECT CAST('08:00:2b:01:02:03  123' AS macaddr8);
/* invalid */ SELECT CAST('123    08:00:2b:01:02:03:04:05' AS macaddr8);
/* invalid */ SELECT CAST('08:00:2b:01:02:03:04:05  123' AS macaddr8);
/* invalid */ SELECT CAST('08:00:2b:01:02:03:04:05:06:07' AS macaddr8);
/* invalid */ SELECT CAST('08-00-2b-01-02-03-04-05-06-07' AS macaddr8);
/* invalid */ SELECT CAST('08002b:01020304050607' AS macaddr8);
/* invalid */ SELECT CAST('08002b01020304050607' AS macaddr8);
/* invalid */ SELECT CAST('0z002b0102030405' AS macaddr8);
/* invalid */ SELECT CAST('08002b010203xyza' AS macaddr8);
/* invalid */ SELECT CAST('08:00-2b:01:02:03:04:05' AS macaddr8);
/* invalid */ SELECT CAST('08:00-2b:01:02:03:04:05' AS macaddr8);
/* invalid */ SELECT CAST('08:00:2b:01.02:03:04:05' AS macaddr8);
/* invalid */ SELECT CAST('08:00:2b:01.02:03:04:05' AS macaddr8);
/* invalid */ /* test converting a MAC address to modified EUI-64 for inclusion */ /* in an ipv6 address */ SELECT MACADDR8_SET7BIT(CAST('00:08:2b:01:02:03' AS macaddr8));
CREATE TABLE x (x INT, x macaddr8);
INSERT INTO x VALUES (1, '08:00:2b:01:02:03');
INSERT INTO x VALUES (2, '08-00-2b-01-02-03');
INSERT INTO x VALUES (3, '08002b:010203');
INSERT INTO x VALUES (4, '08002b-010203');
INSERT INTO x VALUES (5, '0800.2b01.0203');
INSERT INTO x VALUES (6, '0800-2b01-0203');
INSERT INTO x VALUES (7, '08002b010203');
INSERT INTO x VALUES (8, '0800:2b01:0203');
INSERT INTO x VALUES (9, 'not even close');
/* invalid */ INSERT INTO x VALUES (10, '08:00:2b:01:02:04');
INSERT INTO x VALUES (11, '08:00:2b:01:02:02');
INSERT INTO x VALUES (12, '08:00:2a:01:02:03');
INSERT INTO x VALUES (13, '08:00:2c:01:02:03');
INSERT INTO x VALUES (14, '08:00:2a:01:02:04');
INSERT INTO x VALUES (15, '08:00:2b:01:02:03:04:05');
INSERT INTO x VALUES (16, '08-00-2b-01-02-03-04-05');
INSERT INTO x VALUES (17, '08002b:0102030405');
INSERT INTO x VALUES (18, '08002b-0102030405');
INSERT INTO x VALUES (19, '0800.2b01.0203.0405');
INSERT INTO x VALUES (20, '08002b01:02030405');
INSERT INTO x VALUES (21, '08002b0102030405');
SELECT * FROM x ORDER BY 1 NULLS LAST;
CREATE INDEX x ON x USING btree(x NULLS LAST);
CREATE INDEX x ON x USING hash(x NULLS LAST);
SELECT x, x, TRUNC(x) FROM x ORDER BY 2 NULLS LAST, 1 NULLS LAST;
SELECT x < '08:00:2b:01:02:04' FROM x WHERE x = 1;
/* true */ SELECT x > '08:00:2b:ff:fe:01:02:04' FROM x WHERE x = 1;
/* false */ SELECT x > '08:00:2b:ff:fe:01:02:03' FROM x WHERE x = 1;
/* false */ SELECT CAST(x AS macaddr) <= '08:00:2b:01:02:04' FROM x WHERE x = 1;
/* true */ SELECT CAST(x AS macaddr) >= '08:00:2b:01:02:04' FROM x WHERE x = 1;
/* false */ SELECT x = '08:00:2b:ff:fe:01:02:03' FROM x WHERE x = 1;
/* true */ SELECT CAST(x AS macaddr) <> CAST('08:00:2b:01:02:04' AS macaddr) FROM x WHERE x = 1;
/* true */ SELECT CAST(x AS macaddr) <> CAST('08:00:2b:01:02:03' AS macaddr) FROM x WHERE x = 1;
/* false */ SELECT x < '08:00:2b:01:02:03:04:06' FROM x WHERE x = 15;
/* true */ SELECT x > '08:00:2b:01:02:03:04:06' FROM x WHERE x = 15;
/* false */ SELECT x > '08:00:2b:01:02:03:04:05' FROM x WHERE x = 15;
/* false */ SELECT x <= '08:00:2b:01:02:03:04:06' FROM x WHERE x = 15;
/* true */ SELECT x >= '08:00:2b:01:02:03:04:06' FROM x WHERE x = 15;
/* false */ SELECT x = '08:00:2b:01:02:03:04:05' FROM x WHERE x = 15;
/* true */ SELECT x <> '08:00:2b:01:02:03:04:06' FROM x WHERE x = 15;
/* true */ SELECT x <> '08:00:2b:01:02:03:04:05' FROM x WHERE x = 15;
SELECT x & '00:00:00:ff:ff:ff' FROM x;
SELECT x | '01:02:03:04:05:06' FROM x;
DROP TABLE x;
/* test non-error-throwing API for some core types */ SELECT PG_INPUT_IS_VALID('08:00:2b:01:02:03:04:ZZ', 'macaddr8');
SELECT * FROM x;
SELECT PG_INPUT_IS_VALID('08:00:2b:01:02:03:04:', 'macaddr8');
SELECT * FROM x;
/* create a table to use as a basis for views and materialized views in various combinations */ CREATE TABLE x (x INT NOT NULL PRIMARY KEY, x TEXT NOT NULL, x DECIMAL NOT NULL);
INSERT INTO x VALUES (1, 'x', 2), (2, 'x', 3), (3, 'y', 5), (4, 'y', 7), (5, 'z', 11);
/* we want a view based on the table, too, since views present additional challenges */ CREATE VIEW x AS SELECT x, SUM(x) AS x FROM x GROUP BY x;
SELECT * FROM x ORDER BY x NULLS LAST;
/* create a materialized view with no data, and confirm correct behavior */ EXPLAIN (costs off)   CREATE MATERIALIZED VIEW mvtest_tm AS SELECT type, sum(amt) AS totamt FROM mvtest_t GROUP BY type WITH NO DATA;
CREATE MATERIALIZED VIEW mvtest_tm AS SELECT type, sum(amt) AS totamt FROM mvtest_t GROUP BY type WITH NO DATA;
SELECT x FROM x WHERE x = CAST('mvtest_tm' AS REGCLASS);
SELECT * FROM x ORDER BY x NULLS LAST;
REFRESH MATERIALIZED VIEW mvtest_tm;
SELECT x FROM x WHERE x = CAST('mvtest_tm' AS REGCLASS);
CREATE UNIQUE INDEX x ON x(x NULLS LAST);
SELECT * FROM x ORDER BY x NULLS LAST;
/* create various views */ EXPLAIN (costs off)   CREATE MATERIALIZED VIEW mvtest_tvm AS SELECT * FROM mvtest_tv ORDER BY type;
CREATE MATERIALIZED VIEW x AS SELECT * FROM x ORDER BY x NULLS LAST;
SELECT * FROM x;
CREATE MATERIALIZED VIEW x AS SELECT SUM(x) AS x FROM x;
CREATE MATERIALIZED VIEW x AS SELECT SUM(x) AS x FROM x;
CREATE UNIQUE INDEX x ON x((x > 0) NULLS LAST);
CREATE UNIQUE INDEX x ON x(x NULLS LAST) WHERE x < 0;
CREATE VIEW x AS SELECT SUM(x) AS x FROM x;
EXPLAIN (costs off)   CREATE MATERIALIZED VIEW mvtest_tvvm AS SELECT * FROM mvtest_tvv;
CREATE MATERIALIZED VIEW x AS SELECT * FROM x;
CREATE VIEW x AS SELECT * FROM x;
CREATE MATERIALIZED VIEW x AS SELECT * FROM x;
CREATE INDEX x ON x(x NULLS LAST);
ALTER MATERIALIZED VIEW mvtest_tvm SET SCHEMA mvtest_mvschema;
/* confirm pre- and post-refresh contents of fairly simple materialized views */ SELECT * FROM x ORDER BY x NULLS LAST;
SELECT * FROM x ORDER BY x NULLS LAST;
REFRESH MATERIALIZED VIEW CONCURRENTLY mvtest_tm;
REFRESH MATERIALIZED VIEW mvtest_tvm;
SELECT * FROM x ORDER BY x NULLS LAST;
SELECT * FROM x ORDER BY x NULLS LAST;
RESET search_path;
/* confirm pre- and post-refresh contents of nested materialized views */ EXPLAIN (costs off)   SELECT * FROM mvtest_tmm;
EXPLAIN (costs off)   SELECT * FROM mvtest_tvmm;
EXPLAIN (costs off)   SELECT * FROM mvtest_tvvm;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
REFRESH MATERIALIZED VIEW mvtest_tmm;
REFRESH MATERIALIZED VIEW CONCURRENTLY mvtest_tvmm;
REFRESH MATERIALIZED VIEW mvtest_tvmm;
REFRESH MATERIALIZED VIEW mvtest_tvvm;
EXPLAIN (costs off)   SELECT * FROM mvtest_tmm;
EXPLAIN (costs off)   SELECT * FROM mvtest_tvmm;
EXPLAIN (costs off)   SELECT * FROM mvtest_tvvm;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
/* test diemv when the mv does not exist */ DROP MATERIALIZED VIEW IF EXISTS x;
/* make sure invalid combination of options is prohibited */ REFRESH MATERIALIZED VIEW CONCURRENTLY mvtest_tvmm WITH NO DATA;
/* no tuple locks on materialized views */ SELECT * FROM x;
/* test join of mv and view */ SELECT x, x.x AS x, x.x AS x FROM x AS x LEFT JOIN x AS x USING (x) ORDER BY x NULLS LAST;
/* make sure that dependencies are reported properly when they block the drop */ DROP TABLE x;
/* make sure dependencies are dropped and reported */ /* and make sure that transactional behavior is correct on rollback */ /* incidentally leaving some interesting materialized views for pg_dump testing */ BEGIN;
DROP TABLE x CASCADE;
ROLLBACK;
/* some additional tests not using base tables */ CREATE VIEW x AS SELECT 1 AS x;
CREATE VIEW x AS SELECT x, 2 * x FROM x UNION ALL SELECT x, 3 * x FROM x;
SELECT x FROM x WHERE x = CAST('mv_test3' AS REGCLASS);
DROP VIEW x CASCADE;
/* test that duplicate values on unique index prevent refresh */ CREATE TABLE x (x, x) AS VALUES (1, 10);
CREATE MATERIALIZED VIEW x AS SELECT * FROM x;
CREATE UNIQUE INDEX ON x(x NULLS LAST);
INSERT INTO x SELECT * FROM x;
REFRESH MATERIALIZED VIEW mvtest_mv;
REFRESH MATERIALIZED VIEW CONCURRENTLY mvtest_mv;
DROP TABLE x CASCADE;
/* make sure that all columns covered by unique indexes works */ CREATE TABLE x (x, x, x) AS VALUES (1, 2, 3);
CREATE MATERIALIZED VIEW x AS SELECT * FROM x;
CREATE UNIQUE INDEX ON x(x NULLS LAST);
CREATE UNIQUE INDEX ON x(x NULLS LAST);
CREATE UNIQUE INDEX ON x(x NULLS LAST);
INSERT INTO x VALUES (2, 3, 4);
INSERT INTO x VALUES (3, 4, 5);
REFRESH MATERIALIZED VIEW mvtest_mv;
REFRESH MATERIALIZED VIEW CONCURRENTLY mvtest_mv;
DROP TABLE x CASCADE;
/* allow subquery to reference unpopulated matview if WITH NO DATA is specified */ CREATE MATERIALIZED VIEW mvtest_mv1 AS SELECT 1 AS col1 WITH NO DATA;
CREATE MATERIALIZED VIEW mvtest_mv2 AS SELECT * FROM mvtest_mv1   WHERE col1 = (SELECT LEAST(col1) FROM mvtest_mv1) WITH NO DATA;
DROP MATERIALIZED VIEW x CASCADE;
/* make sure that types with unusual equality tests work */ CREATE TABLE x (x SERIAL PRIMARY KEY, x box);
INSERT INTO x (x) VALUES ('(32,32),(31,31)'), ('(2.0000004,2.0000004),(1,1)'), ('(1.9999996,1.9999996),(1,1)');
CREATE MATERIALIZED VIEW x AS SELECT * FROM x;
CREATE UNIQUE INDEX x ON x(x NULLS LAST);
UPDATE x SET x = '(2,2),(1,1)' WHERE x = 2;
REFRESH MATERIALIZED VIEW CONCURRENTLY mvtest_boxmv;
SELECT * FROM x ORDER BY x NULLS LAST;
DROP TABLE x CASCADE;
/* make sure that column names are handled correctly */ CREATE TABLE x (x INT, x INT);
CREATE MATERIALIZED VIEW x (x, x, x) AS SELECT x, x FROM x;
/* error */ CREATE MATERIALIZED VIEW x (x, x) AS SELECT x, x FROM x;
/* ok */ CREATE MATERIALIZED VIEW x (x) AS SELECT x, x FROM x;
/* ok */ CREATE MATERIALIZED VIEW mvtest_mv_v_3 (ii, jj, kk) AS SELECT i, j FROM mvtest_v WITH NO DATA;
/* error */ CREATE MATERIALIZED VIEW mvtest_mv_v_3 (ii, jj) AS SELECT i, j FROM mvtest_v WITH NO DATA;
/* ok */ CREATE MATERIALIZED VIEW mvtest_mv_v_4 (ii) AS SELECT i, j FROM mvtest_v WITH NO DATA;
ALTER TABLE x RENAME COLUMN x TO x /* ok */;
INSERT INTO x VALUES (1, 2);
CREATE UNIQUE INDEX x ON x(x NULLS LAST);
REFRESH MATERIALIZED VIEW mvtest_mv_v;
UPDATE x SET x = 3 WHERE x = 1;
REFRESH MATERIALIZED VIEW CONCURRENTLY mvtest_mv_v;
REFRESH MATERIALIZED VIEW mvtest_mv_v_2;
REFRESH MATERIALIZED VIEW mvtest_mv_v_3;
REFRESH MATERIALIZED VIEW mvtest_mv_v_4;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
DROP TABLE x CASCADE;
/* Check that unknown literals are converted to "text" in CREATE MATVIEW, */ /* so that we don't end up with unknown-type columns. */ CREATE MATERIALIZED VIEW x AS SELECT 42 AS x, 42.5 AS x, 'foo' AS x, CAST('foo' AS UNKNOWN) AS x, NULL AS x;
DROP MATERIALIZED VIEW x;
/* make sure that create WITH NO DATA does not plan the query (bug #13907) */ CREATE MATERIALIZED VIEW x AS SELECT 1 / 0 AS x;
/* fail */ create materialized view mvtest_error as select 1/0 as x with no data;
REFRESH materialized view mvtest_error;
/* fail here */ DROP MATERIALIZED VIEW x;
/* make sure that matview rows can be referenced as source rows (bug #9398) */ CREATE TABLE x AS SELECT UNNEST(GENERATE_SERIES(1, 10)) AS x;
CREATE MATERIALIZED VIEW x AS SELECT x FROM x WHERE x <= 5;
DELETE FROM x WHERE EXISTS(SELECT * FROM x WHERE x.x = x.x);
SELECT * FROM x;
SELECT * FROM x;
DROP TABLE x CASCADE;
/* make sure running as superuser works when MV owned by another role (bug #11208) */ CREATE ROLE regress_user_mvtest;
SET ROLE regress_user_mvtest;
/* this test case also checks for ambiguity in the queries issued by */ /* refresh_by_match_merge(), by choosing column names that intentionally */ /* duplicate all the aliases used in those queries */ CREATE TABLE x AS SELECT x, x + 1 AS x, FIPSHASH(CAST(RAND() AS TEXT)) AS x, FIPSHASH(CAST(RAND() AS TEXT)) AS x, FIPSHASH(CAST(RAND() AS TEXT)) AS x, FIPSHASH(CAST(RAND() AS TEXT)) AS x FROM x AS x;
CREATE MATERIALIZED VIEW x AS SELECT * FROM x;
CREATE MATERIALIZED VIEW x AS SELECT * FROM x;
CREATE MATERIALIZED VIEW IF NOT EXISTS x AS SELECT * FROM x;
CREATE UNIQUE INDEX ON x(x NULLS LAST);
RESET ROLE;
REFRESH MATERIALIZED VIEW mvtest_mv_foo;
REFRESH MATERIALIZED VIEW CONCURRENTLY mvtest_mv_foo;
DROP OWNED BY regress_user_mvtest CASCADE;
DROP ROLE regress_user_mvtest;
/* Concurrent refresh requires a unique index on the materialized */ /* view. Test what happens if it's dropped during the refresh. */ SET search_path = mvtest_mvschema, public;
x AS x;
COMMIT;
CREATE MATERIALIZED VIEW x AS SELECT 1 AS x WHERE MVTEST_DROP_THE_INDEX();
CREATE UNIQUE INDEX x ON x(x NULLS LAST);
REFRESH MATERIALIZED VIEW CONCURRENTLY drop_idx_matview;
DROP MATERIALIZED VIEW x;
/* clean up */ RESET search_path;
/* make sure that create WITH NO DATA works via SPI */ BEGIN;
CREATE MATERIALIZED VIEW mvtest2 AS SELECT 1 AS x WITH NO DATA;
COMMIT;
SELECT MVTEST_FUNC();
SELECT * FROM x;
SELECT * FROM x;
ROLLBACK;
/* INSERT privileges if relation owner is not allowed to insert. */ CREATE SCHEMA x.x;
CREATE USER regress_matview_user;
ALTER DEFAULT PRIVILEGES FOR ROLE regress_matview_user   REVOKE INSERT ON TABLES FROM regress_matview_user;
GRANT ALL ON SCHEMA x TO x;
SET SESSION AUTHORIZATION regress_matview_user;
CREATE MATERIALIZED VIEW matview_schema.mv_withdata1 (a) AS   SELECT generate_series(1, 10) WITH DATA;
EXPLAIN (ANALYZE, COSTS OFF, SUMMARY OFF, TIMING OFF, BUFFERS OFF)   CREATE MATERIALIZED VIEW matview_schema.mv_withdata2 (a) AS   SELECT generate_series(1, 10) WITH DATA;
REFRESH MATERIALIZED VIEW matview_schema.mv_withdata2;
CREATE MATERIALIZED VIEW matview_schema.mv_nodata1 (a) AS   SELECT generate_series(1, 10) WITH NO DATA;
EXPLAIN (ANALYZE, COSTS OFF, SUMMARY OFF, TIMING OFF, BUFFERS OFF)   CREATE MATERIALIZED VIEW matview_schema.mv_nodata2 (a) AS   SELECT generate_series(1, 10) WITH NO DATA;
REFRESH MATERIALIZED VIEW matview_schema.mv_nodata2;
RESET SESSION AUTHORIZATION;
ALTER DEFAULT PRIVILEGES FOR ROLE regress_matview_user   GRANT INSERT ON TABLES TO regress_matview_user;
DROP SCHEMA x.x CASCADE;
DROP USER regress_matview_user;
/* CREATE MATERIALIZED VIEW ... IF NOT EXISTS */ CREATE MATERIALIZED VIEW x AS SELECT 1;
CREATE MATERIALIZED VIEW x AS SELECT 1 / 0;
/* error */ CREATE MATERIALIZED VIEW IF NOT EXISTS x AS SELECT 1 / 0;
/* ok */ CREATE MATERIALIZED VIEW matview_ine_tab AS   SELECT 1 / 0 WITH NO DATA;
/* error */ CREATE MATERIALIZED VIEW IF NOT EXISTS matview_ine_tab AS   SELECT 1 / 0 WITH NO DATA;
/* ok */ EXPLAIN (ANALYZE, COSTS OFF, SUMMARY OFF, TIMING OFF, BUFFERS OFF)   CREATE MATERIALIZED VIEW matview_ine_tab AS     SELECT 1 / 0;
/* error */ EXPLAIN (ANALYZE, COSTS OFF, SUMMARY OFF, TIMING OFF, BUFFERS OFF)   CREATE MATERIALIZED VIEW IF NOT EXISTS matview_ine_tab AS     SELECT 1 / 0;
/* ok */ EXPLAIN (ANALYZE, COSTS OFF, SUMMARY OFF, TIMING OFF, BUFFERS OFF)   CREATE MATERIALIZED VIEW matview_ine_tab AS     SELECT 1 / 0 WITH NO DATA;
/* error */ EXPLAIN (ANALYZE, COSTS OFF, SUMMARY OFF, TIMING OFF, BUFFERS OFF)   CREATE MATERIALIZED VIEW IF NOT EXISTS matview_ine_tab AS     SELECT 1 / 0 WITH NO DATA;
/* ok */ DROP MATERIALIZED VIEW x;
/* MD5 test suite - from IETF RFC 1321 */ /* (see: https://www.rfc-editor.org/rfc/rfc1321) */ /* (The md5() function will error in OpenSSL FIPS mode.  By keeping */ /* this test in a separate file, it is easier to manage variant */ /* results.) */ SELECT MD5('') = 'd41d8cd98f00b204e9800998ecf8427e' AS "x";
SELECT MD5('a') = '0cc175b9c0f1b6a831c399e269772661' AS "x";
SELECT MD5('abc') = '900150983cd24fb0d6963f7d28e17f72' AS "x";
SELECT MD5('message digest') = 'f96b697d7cb7938d525a2f31aaf161d0' AS "x";
SELECT MD5('abcdefghijklmnopqrstuvwxyz') = 'c3fcd3d76192e4007dfb496cca67e13b' AS "x";
SELECT MD5('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789') = 'd174ab98d277d9f5a5611c2c9f419d9f' AS "x";
SELECT MD5('12345678901234567890123456789012345678901234567890123456789012345678901234567890') = '57edf4a22be3c955ac49da2e2107b67a' AS "x";
SELECT MD5(CAST('' AS VARBINARY)) = 'd41d8cd98f00b204e9800998ecf8427e' AS "x";
SELECT MD5(CAST('a' AS VARBINARY)) = '0cc175b9c0f1b6a831c399e269772661' AS "x";
SELECT MD5(CAST('abc' AS VARBINARY)) = '900150983cd24fb0d6963f7d28e17f72' AS "x";
SELECT MD5(CAST('message digest' AS VARBINARY)) = 'f96b697d7cb7938d525a2f31aaf161d0' AS "x";
SELECT MD5(CAST('abcdefghijklmnopqrstuvwxyz' AS VARBINARY)) = 'c3fcd3d76192e4007dfb496cca67e13b' AS "x";
SELECT MD5(CAST('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789' AS VARBINARY)) = 'd174ab98d277d9f5a5611c2c9f419d9f' AS "x";
SELECT MD5(CAST('12345678901234567890123456789012345678901234567890123456789012345678901234567890' AS VARBINARY)) = '57edf4a22be3c955ac49da2e2107b67a' AS "x";
BEGIN for ln in         execute format('explain (analyze, costs off, summary off, timing off, buffers off) %s',             query)     loop         if hide_hitmiss = true then                 ln := regexp_replace(ln, 'Hits: 0', 'Hits: Zero');
x := REGEXP_REPLACE(x, 'Hits: \d+', 'Hits: N');
x := REGEXP_REPLACE(x, 'Misses: 0', 'Misses: Zero');
x := REGEXP_REPLACE(x, 'Misses: \d+', 'Misses: N');
x := REGEXP_REPLACE(x, 'Evictions: 0', 'Evictions: Zero');
x := REGEXP_REPLACE(x, 'Evictions: \d+', 'Evictions: N');
x := REGEXP_REPLACE(x, 'Memory Usage: \d+', 'Memory Usage: N');
x := REGEXP_REPLACE(x, 'Heap Fetches: \d+', 'Heap Fetches: N');
x := REGEXP_REPLACE(x, 'loops=\d+', 'loops=N');
x := REGEXP_REPLACE(x, 'Index Searches: \d+', 'Index Searches: N');
COMMIT;
SET x = off /* Ensure we get a memoize node on the inner side of the nested loop */;
SET x = off;
/* And check we get the expected results. */ SELECT COUNT(*), AVG(x.x) FROM x AS x INNER JOIN x AS x ON x.x = x.x WHERE x.x < 1000;
/* And check we get the expected results. */ SELECT COUNT(*), AVG(x.x) FROM x AS x, LATERAL (SELECT x.x FROM x AS x WHERE x.x = x.x OFFSET 0) AS x WHERE x.x < 1000;
/* And check we get the expected results. */ SELECT COUNT(*), AVG(x.x) FROM x AS x LEFT JOIN LATERAL (SELECT x.x AS x, * FROM x AS x WHERE x.x < 4 OFFSET 0) AS x ON x.x = x.x WHERE x.x < 10;
/* And check we get the expected results. */ SELECT COUNT(*), AVG(x.x) FROM x AS x LEFT JOIN LATERAL (SELECT x.x + 1 AS x, x.x AS x FROM x AS x) AS x ON TRUE WHERE x.x = x.x AND x.x < 1000;
/* And check we get the expected results. */ SELECT COUNT(*), AVG(x.x) FROM x AS x LEFT JOIN LATERAL (SELECT x.x AS x, x.x AS x, x.x FROM x AS x) AS x ON x.x = x.x WHERE x.x = x.x AND x.x < 1000;
SET x = off;
/* Test for varlena datatype with expr evaluation */ CREATE TABLE x (x DECIMAL, x TEXT);
INSERT INTO x (x, x) SELECT CAST(x AS DECIMAL), CAST(x AS TEXT) FROM (SELECT ROUND(CAST((x / PI()) AS DECIMAL), 7) AS x FROM x AS x) AS x;
/* duplicate rows so we get some cache hits */ INSERT INTO x SELECT * FROM x;
CREATE INDEX x ON x(x NULLS LAST, x NULLS LAST);
VACUUM ANALYZE expr_key;
DROP TABLE x;
SET x = '64kB' /* Reduce work_mem and hash_mem_multiplier so that we see some cache evictions */;
SET x = 1.0;
CREATE TABLE x (x DOUBLE);
CREATE INDEX x ON x(x NULLS LAST);
INSERT INTO x VALUES (CAST('-0.0' AS DOUBLE)), (CAST('+0.0' AS DOUBLE));
ANALYZE x;
SET x = off;
DROP TABLE x;
/* Exercise Memoize in binary mode with a large fixed width type and a */ /* varlena type. */ CREATE TABLE x (x NAME, x TEXT);
CREATE INDEX x ON x(x NULLS LAST);
CREATE INDEX x ON x(x NULLS LAST);
INSERT INTO x VALUES ('one', 'one'), ('two', 'two'), ('three', REPEAT(FIPSHASH('three'), 100));
/* duplicate rows so we get some cache hits */ INSERT INTO x SELECT * FROM x;
ANALYZE x;
DROP TABLE x;
SET x = on /* Ensure memoize works with partitionwise join */;
CREATE TABLE x (x INT) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (0) TO (10);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (10) TO (20);
INSERT INTO x VALUES (0), (0), (0), (0);
INSERT INTO x VALUES (10), (10), (10), (10);
CREATE INDEX x ON x(x NULLS LAST);
CREATE INDEX x ON x(x NULLS LAST);
ANALYZE x;
SET x = off /* Ensure memoize works with parameterized union-all Append path */;
DROP TABLE x;
RESET enable_partitionwise_join;
/* Exercise Memoize code that flushes the cache when a parameter changes which */ /* is not part of the cache key. */ /* Ensure we get a Memoize plan */ EXPLAIN (COSTS OFF) SELECT unique1 FROM tenk1 t0 WHERE unique1 < 3   AND EXISTS ( 	SELECT 1 FROM tenk1 t1 	INNER JOIN tenk1 t2 ON t1.unique1 = t2.hundred 	WHERE t0.ten = t1.twenty AND t0.two <> t2.four OFFSET 0);
/* Ensure the above query returns the correct result */ SELECT x FROM x AS x WHERE x < 3 AND EXISTS(SELECT 1 FROM x AS x INNER JOIN x AS x ON x.x = x.x WHERE x.x = x.x AND x.x <> x.x OFFSET 0);
RESET enable_seqscan;
RESET enable_mergejoin;
RESET work_mem;
RESET hash_mem_multiplier;
RESET enable_bitmapscan;
RESET enable_hashjoin;
SET x = 0 /* Test parallel plans with Memoize */;
SET x = 0;
SET x = 0;
SET x = 2;
/* Ensure we get a parallel plan. */ EXPLAIN (COSTS OFF) SELECT COUNT(*),AVG(t2.unique1) FROM tenk1 t1, LATERAL (SELECT t2.unique1 FROM tenk1 t2 WHERE t1.twenty = t2.unique1) t2 WHERE t1.unique1 < 1000;
/* And ensure the parallel plan gives us the correct results. */ SELECT COUNT(*), AVG(x.x) FROM x AS x, LATERAL (SELECT x.x FROM x AS x WHERE x.x = x.x) AS x WHERE x.x < 1000;
RESET max_parallel_workers_per_gather;
RESET parallel_tuple_cost;
RESET parallel_setup_cost;
RESET min_parallel_table_scan_size;
/* MERGE */ CREATE USER regress_merge_privs;
CREATE USER regress_merge_no_privs;
CREATE USER regress_merge_none;
DROP TABLE IF EXISTS x;
DROP TABLE IF EXISTS x;
CREATE TABLE x (x INT, x INT) WITH (autovacuum_enabled=off);
CREATE TABLE x (x INT, x INT) /* no index */ WITH (autovacuum_enabled=off);
INSERT INTO x VALUES (1, 10);
INSERT INTO x VALUES (2, 20);
INSERT INTO x VALUES (3, 30);
SELECT NOT x.x IS NULL AS x, x.*, x.* FROM x AS x FULL OUTER JOIN x AS x ON x.x = x.x ORDER BY x.x NULLS LAST, x.x NULLS LAST;
ALTER TABLE target OWNER TO regress_merge_privs;
ALTER TABLE source OWNER TO regress_merge_privs;
CREATE TABLE x (x INT, x INT) WITH (autovacuum_enabled=off);
CREATE TABLE x (x INT, x INT) WITH (autovacuum_enabled=off);
ALTER TABLE target2 OWNER TO regress_merge_no_privs;
ALTER TABLE source2 OWNER TO regress_merge_no_privs;
GRANT INSERT ON x TO x;
SET SESSION AUTHORIZATION regress_merge_privs;
EXPLAIN (COSTS OFF) MERGE INTO target t USING source AS s ON t.tid = s.sid WHEN MATCHED THEN 	DELETE;
MERGE INTO x AS x USING x AS x ON x.x = x.x WHEN MATCHED THEN INSERT (x) /* MATCHED/INSERT error */;
MERGE INTO x AS x USING x AS x ON x.x = x.x WHEN NOT MATCHED BY SOURCE THEN INSERT (x) /* NOT MATCHED BY SOURCE/INSERT error */;
MERGE INTO x AS x USING x AS x ON x.x = x.x WHEN NOT MATCHED THEN UPDATE SET x = 0 /* NOT MATCHED/UPDATE */;
MERGE INTO x AS x USING x AS x ON x.x = x.x WHEN NOT MATCHED THEN UPDATE SET x = 0 /* NOT MATCHED BY TARGET/UPDATE */;
MERGE INTO x USING x ON x = x WHEN MATCHED THEN DO NOTHING /* source and target names the same */;
/* used in a CTE without RETURNING */ WITH x AS (MERGE INTO x USING x ON (TRUE) WHEN MATCHED THEN DELETE) SELECT * FROM x;
/* unsupported relation types */ /* materialized view */ CREATE MATERIALIZED VIEW x AS SELECT * FROM x;
MERGE INTO x AS x USING x AS x ON x.x = x.x WHEN NOT MATCHED THEN INSERT (x);
DROP MATERIALIZED VIEW x;
/* permissions */ SET SESSION AUTHORIZATION regress_merge_none;
MERGE INTO x USING (SELECT 1) ON TRUE WHEN MATCHED THEN DO NOTHING;
SET SESSION AUTHORIZATION regress_merge_privs;
MERGE INTO x USING x ON x.x = x.x WHEN MATCHED THEN UPDATE SET x = 0;
GRANT INSERT ON x TO x;
SET SESSION AUTHORIZATION regress_merge_no_privs;
MERGE INTO x USING x ON x.x = x.x WHEN MATCHED THEN UPDATE SET x = 0;
GRANT UPDATE ON x TO x;
SET SESSION AUTHORIZATION regress_merge_privs;
MERGE INTO x USING x ON x.x = x.x WHEN MATCHED THEN DELETE;
MERGE INTO x USING x ON x.x = x.x WHEN NOT MATCHED THEN INSERT (x);
MERGE INTO x USING x ON x.x = x.x WHEN MATCHED THEN UPDATE SET x = 0 /* initial tests */ /* zero rows in source has no effect */;
MERGE INTO x AS x USING x AS x ON x.x = x.x WHEN MATCHED THEN UPDATE SET x = 0;
MERGE INTO x AS x USING x AS x ON x.x = x.x WHEN MATCHED THEN DELETE;
BEGIN;
MERGE INTO x AS x USING x AS x ON x.x = x.x WHEN NOT MATCHED THEN INSERT (x);
ROLLBACK;
/* insert some non-matching source rows to work from */ INSERT INTO x VALUES (4, 40);
SELECT * FROM x ORDER BY x NULLS LAST;
SELECT * FROM x ORDER BY x NULLS LAST;
MERGE INTO x AS x USING x AS x ON x.x = x.x WHEN NOT MATCHED THEN DO NOTHING;
MERGE INTO x AS x USING x AS x ON x.x = x.x WHEN MATCHED THEN UPDATE SET x = 0;
MERGE INTO x AS x USING x AS x ON x.x = x.x WHEN MATCHED THEN DELETE;
BEGIN;
MERGE INTO x AS x USING x AS x ON x.x = x.x WHEN NOT MATCHED THEN INSERT (x);
SELECT * FROM x ORDER BY x NULLS LAST;
ROLLBACK;
/* DELETE/INSERT not matched by source/target */ BEGIN;
MERGE INTO x AS x USING x AS x ON x.x = x.x WHEN NOT MATCHED BY SOURCE THEN DELETE WHEN NOT MATCHED THEN INSERT VALUES (x.x, x.x) RETURNING MERGE_ACTION(), x, x, x.*;
SELECT * FROM x ORDER BY x NULLS LAST;
ROLLBACK;
/* index plans */ INSERT INTO x SELECT UNNEST(GENERATE_SERIES(1000, 2500)), 0;
ALTER TABLE x ADD PRIMARY KEY (x NULLS LAST);
ANALYZE x;
EXPLAIN (COSTS OFF) MERGE INTO target t USING source AS s ON t.tid = s.sid WHEN MATCHED THEN 	UPDATE SET balance = 0;
EXPLAIN (COSTS OFF) MERGE INTO target t USING source AS s ON t.tid = s.sid WHEN MATCHED THEN 	DELETE;
EXPLAIN (COSTS OFF) MERGE INTO target t USING source AS s ON t.tid = s.sid WHEN NOT MATCHED THEN 	INSERT VALUES (4, NULL);
DELETE FROM x WHERE x > 100;
ANALYZE x;
/* insert some matching source rows to work from */ INSERT INTO x VALUES (2, 5);
INSERT INTO x VALUES (3, 20);
SELECT * FROM x ORDER BY x NULLS LAST;
SELECT * FROM x ORDER BY x NULLS LAST;
/* equivalent of an UPDATE join */ BEGIN;
MERGE INTO x AS x USING x AS x ON x.x = x.x WHEN MATCHED THEN UPDATE SET x = 0;
SELECT * FROM x ORDER BY x NULLS LAST;
ROLLBACK;
/* equivalent of a DELETE join */ BEGIN;
MERGE INTO x AS x USING x AS x ON x.x = x.x WHEN MATCHED THEN DELETE;
SELECT * FROM x ORDER BY x NULLS LAST;
ROLLBACK;
BEGIN;
MERGE INTO x AS x USING x AS x ON x.x = x.x WHEN MATCHED THEN DO NOTHING;
SELECT * FROM x ORDER BY x NULLS LAST;
ROLLBACK;
BEGIN;
MERGE INTO x AS x USING x AS x ON x.x = x.x WHEN NOT MATCHED THEN INSERT VALUES (4, NULL);
SELECT * FROM x ORDER BY x NULLS LAST;
ROLLBACK;
/* duplicate source row causes multiple target row update ERROR */ INSERT INTO x VALUES (2, 5);
SELECT * FROM x ORDER BY x NULLS LAST;
SELECT * FROM x ORDER BY x NULLS LAST;
BEGIN;
MERGE INTO x AS x USING x AS x ON x.x = x.x WHEN MATCHED THEN UPDATE SET x = 0;
ROLLBACK;
BEGIN;
MERGE INTO x AS x USING x AS x ON x.x = x.x WHEN MATCHED THEN DELETE;
ROLLBACK;
/* remove duplicate MATCHED data from source data */ DELETE FROM x WHERE x = 2;
INSERT INTO x VALUES (2, 5);
SELECT * FROM x ORDER BY x NULLS LAST;
SELECT * FROM x ORDER BY x NULLS LAST;
/* duplicate source row on INSERT should fail because of target_pkey */ INSERT INTO x VALUES (4, 40);
BEGIN;
MERGE INTO x AS x USING x AS x ON x.x = x.x WHEN NOT MATCHED THEN INSERT VALUES (4, NULL);
SELECT * FROM x ORDER BY x NULLS LAST;
ROLLBACK;
/* remove duplicate NOT MATCHED data from source data */ DELETE FROM x WHERE x = 4;
INSERT INTO x VALUES (4, 40);
SELECT * FROM x ORDER BY x NULLS LAST;
SELECT * FROM x ORDER BY x NULLS LAST;
ALTER TABLE x DROP CONSTRAINT x /* remove constraints */;
ALTER TABLE x ALTER COLUMN x DROP NOT NULL;
/* multiple actions */ BEGIN;
MERGE INTO x AS x USING x AS x ON x.x = x.x WHEN NOT MATCHED THEN INSERT VALUES (4, 4) WHEN MATCHED THEN UPDATE SET x = 0;
SELECT * FROM x ORDER BY x NULLS LAST;
ROLLBACK;
/* should be equivalent */ BEGIN;
MERGE INTO x AS x USING x AS x ON x.x = x.x WHEN MATCHED THEN UPDATE SET x = 0 WHEN NOT MATCHED THEN INSERT VALUES (4, 4);
SELECT * FROM x ORDER BY x NULLS LAST;
ROLLBACK;
/* column references */ /* do a simple equivalent of an UPDATE join */ BEGIN;
MERGE INTO x AS x USING x AS x ON x.x = x.x WHEN MATCHED THEN UPDATE SET x = x.x + x.x;
SELECT * FROM x ORDER BY x NULLS LAST;
ROLLBACK;
/* do a simple equivalent of an INSERT SELECT */ BEGIN;
MERGE INTO x AS x USING x AS x ON x.x = x.x WHEN NOT MATCHED THEN INSERT VALUES (x.x, x.x);
SELECT * FROM x ORDER BY x NULLS LAST;
ROLLBACK;
/* and again with duplicate source rows */ INSERT INTO x VALUES (5, 50);
INSERT INTO x VALUES (5, 50);
/* do a simple equivalent of an INSERT SELECT */ BEGIN;
MERGE INTO x AS x USING x AS x ON x.x = x.x WHEN NOT MATCHED THEN INSERT VALUES (x.x, x.x);
SELECT * FROM x ORDER BY x NULLS LAST;
ROLLBACK;
/* removing duplicate source rows */ DELETE FROM x WHERE x = 5;
/* and again with explicitly identified column list */ BEGIN;
MERGE INTO x AS x USING x AS x ON x.x = x.x WHEN NOT MATCHED THEN INSERT (x, x) VALUES (x.x, x.x);
SELECT * FROM x ORDER BY x NULLS LAST;
ROLLBACK;
MERGE INTO x AS x USING x AS x ON x.x = x.x WHEN NOT MATCHED THEN INSERT (x, x) VALUES (x.x, x.x) /* and again with a subtle error: referring to non-existent target row for NOT MATCHED */;
/* and again with a constant ON clause */ BEGIN;
MERGE INTO x AS x USING x AS x ON (SELECT TRUE) WHEN NOT MATCHED THEN INSERT (x, x) VALUES (x.x, x.x);
SELECT * FROM x ORDER BY x NULLS LAST;
ROLLBACK;
/* now the classic UPSERT */ BEGIN;
MERGE INTO x AS x USING x AS x ON x.x = x.x WHEN MATCHED THEN UPDATE SET x = x.x + x.x WHEN NOT MATCHED THEN INSERT VALUES (x.x, x.x);
SELECT * FROM x ORDER BY x NULLS LAST;
ROLLBACK;
/* unreachable WHEN clause should ERROR */ BEGIN;
MERGE INTO x AS x USING x AS x ON x.x = x.x WHEN MATCHED THEN DELETE WHEN MATCHED THEN UPDATE SET x = x.x - x.x;
ROLLBACK;
/* conditional WHEN clause */ CREATE TABLE x (x INT NOT NULL, x INT DEFAULT -1) WITH (autovacuum_enabled=off);
CREATE TABLE x (x INT, x INT) WITH (autovacuum_enabled=off);
INSERT INTO x (x, x) VALUES (1, 100);
BEGIN;
MERGE INTO x AS x USING x AS x ON x.x = x.x WHEN NOT MATCHED THEN INSERT (x) VALUES (x.x) /* try a simple INSERT with default values first */;
SELECT * FROM x;
ROLLBACK;
MERGE INTO x AS x USING x AS x ON x.x = x.x WHEN NOT MATCHED AND FALSE THEN INSERT (x) VALUES (x.x) /* this time with a FALSE condition */;
SELECT * FROM x;
MERGE INTO x AS x USING x AS x ON x.x = x.x WHEN NOT MATCHED AND x.x <> 100 THEN INSERT (x) VALUES (x.x) /* this time with an actual condition which returns false */;
SELECT * FROM x;
BEGIN;
MERGE INTO x AS x USING x AS x ON x.x = x.x WHEN NOT MATCHED AND x.x = 100 THEN INSERT (x) VALUES (x.x) /* and now with a condition which returns true */;
SELECT * FROM x;
ROLLBACK;
/* conditions in the NOT MATCHED clause can only refer to source columns */ BEGIN;
MERGE INTO x AS x USING x AS x ON x.x = x.x WHEN NOT MATCHED AND x.x = 100 THEN INSERT (x) VALUES (x.x);
SELECT * FROM x;
ROLLBACK;
MERGE INTO x AS x USING x AS x ON x.x = x.x WHEN NOT MATCHED AND x.x = 100 THEN INSERT (x) VALUES (x.x);
SELECT * FROM x;
MERGE INTO x AS x USING x AS x ON x.x = x.x WHEN NOT MATCHED BY SOURCE AND x.x = 100 THEN DELETE /* conditions in NOT MATCHED BY SOURCE clause can only refer to target columns */;
MERGE INTO x AS x USING x AS x ON x.x = x.x WHEN NOT MATCHED BY SOURCE AND x.x = 100 THEN DELETE;
/* conditions in MATCHED clause can refer to both source and target */ SELECT * FROM x;
MERGE INTO x AS x USING x AS x ON x.x = x.x WHEN MATCHED AND x.x = 100 THEN UPDATE SET x = x.x + x.x;
SELECT * FROM x;
MERGE INTO x AS x USING x AS x ON x.x = x.x WHEN MATCHED AND x.x = 100 THEN UPDATE SET x = x.x + x.x;
SELECT * FROM x;
MERGE INTO x AS x USING x AS x ON x.x = x.x WHEN MATCHED AND x.x = 99 AND x.x > 100 THEN UPDATE SET x = x.x + x.x /* check if AND works */;
SELECT * FROM x;
MERGE INTO x AS x USING x AS x ON x.x = x.x WHEN MATCHED AND x.x = 99 AND x.x = 100 THEN UPDATE SET x = x.x + x.x;
SELECT * FROM x;
MERGE INTO x AS x USING x AS x ON x.x = x.x WHEN MATCHED AND x.x = 99 OR x.x > 100 THEN UPDATE SET x = x.x + x.x /* check if OR works */;
SELECT * FROM x;
MERGE INTO x AS x USING x AS x ON x.x = x.x WHEN MATCHED AND x.x = 199 OR x.x > 100 THEN UPDATE SET x = x.x + x.x;
SELECT * FROM x;
/* check source-side whole-row references */ BEGIN;
MERGE INTO x AS x USING x AS x ON (x.x = x.x) WHEN MATCHED AND x = x OR x.x = x.x THEN UPDATE SET x = x.x + x.x;
SELECT * FROM x;
ROLLBACK;
MERGE INTO x AS x USING x AS x ON x.x = x.x WHEN MATCHED AND x.x > (SELECT MAX(x) FROM x) THEN UPDATE SET x = x.x + x.x /* check if subqueries work in the conditions? */;
MERGE INTO x AS x USING x AS x ON x.x = x.x WHEN MATCHED AND x.x = x.x THEN UPDATE SET x = x.x + x.x /* check if we can access system columns in the conditions */;
MERGE INTO x AS x USING x AS x ON x.x = x.x WHEN MATCHED AND x.x >= 0 THEN UPDATE SET x = x.x + x.x;
SELECT * FROM x;
BEGIN SELECT INTO line format('%s %s %s trigger%s', 		TG_WHEN, TG_OP, TG_LEVEL, CASE 		WHEN TG_OP = 'INSERT' AND TG_LEVEL = 'ROW' 			THEN format(' row: %s', NEW) 		WHEN TG_OP = 'UPDATE' AND TG_LEVEL = 'ROW' 			THEN format(' row: %s -> %s', OLD, NEW) 		WHEN TG_OP = 'DELETE' AND TG_LEVEL = 'ROW' 			THEN format(' row: %s', OLD) 		END);
COMMIT;
CREATE TRIGGER merge_bsi BEFORE INSERT ON target FOR EACH STATEMENT EXECUTE PROCEDURE merge_trigfunc ();
CREATE TRIGGER merge_bsu BEFORE UPDATE ON target FOR EACH STATEMENT EXECUTE PROCEDURE merge_trigfunc ();
CREATE TRIGGER merge_bsd BEFORE DELETE ON target FOR EACH STATEMENT EXECUTE PROCEDURE merge_trigfunc ();
CREATE TRIGGER merge_asi AFTER INSERT ON target FOR EACH STATEMENT EXECUTE PROCEDURE merge_trigfunc ();
CREATE TRIGGER merge_asu AFTER UPDATE ON target FOR EACH STATEMENT EXECUTE PROCEDURE merge_trigfunc ();
CREATE TRIGGER merge_asd AFTER DELETE ON target FOR EACH STATEMENT EXECUTE PROCEDURE merge_trigfunc ();
CREATE TRIGGER merge_bri BEFORE INSERT ON target FOR EACH ROW EXECUTE PROCEDURE merge_trigfunc ();
CREATE TRIGGER merge_bru BEFORE UPDATE ON target FOR EACH ROW EXECUTE PROCEDURE merge_trigfunc ();
CREATE TRIGGER merge_brd BEFORE DELETE ON target FOR EACH ROW EXECUTE PROCEDURE merge_trigfunc ();
CREATE TRIGGER merge_ari AFTER INSERT ON target FOR EACH ROW EXECUTE PROCEDURE merge_trigfunc ();
CREATE TRIGGER merge_aru AFTER UPDATE ON target FOR EACH ROW EXECUTE PROCEDURE merge_trigfunc ();
CREATE TRIGGER merge_ard AFTER DELETE ON target FOR EACH ROW EXECUTE PROCEDURE merge_trigfunc ();
/* now the classic UPSERT, with a DELETE */ BEGIN;
UPDATE x SET x = 0 WHERE x = 3;
MERGE INTO x AS x USING x AS x ON x.x = x.x WHEN MATCHED AND x.x > x.x THEN UPDATE SET x = x.x - x.x WHEN MATCHED THEN DELETE WHEN NOT MATCHED THEN INSERT VALUES (x.x, x.x) /* EXPLAIN (ANALYZE ON, COSTS OFF, SUMMARY OFF, TIMING OFF) */;
SELECT * FROM x ORDER BY x NULLS LAST;
ROLLBACK;
/* UPSERT with UPDATE/DELETE when not matched by source */ BEGIN;
DELETE FROM x WHERE x = 2;
MERGE INTO x AS x USING x AS x ON x.x = x.x WHEN MATCHED AND x.x > x.x THEN UPDATE SET x = x.x - x.x WHEN MATCHED THEN UPDATE SET x = 0 WHEN NOT MATCHED THEN INSERT VALUES (x.x, x.x) WHEN NOT MATCHED BY SOURCE AND x = 1 THEN UPDATE SET x = 0 WHEN NOT MATCHED BY SOURCE THEN DELETE RETURNING MERGE_ACTION(), x, x, x.*;
SELECT * FROM x ORDER BY x NULLS LAST;
ROLLBACK;
COMMIT;
SELECT * FROM x FULL OUTER JOIN x ON (x = x);
create trigger merge_skip BEFORE INSERT OR UPDATE or DELETE   ON target FOR EACH ROW EXECUTE FUNCTION skip_merge_op();
BEGIN MERGE INTO target t USING source AS s ON t.tid = s.sid WHEN MATCHED AND s.sid = 3 THEN UPDATE SET balance = t.balance + s.delta WHEN MATCHED THEN DELETE WHEN NOT MATCHED THEN INSERT VALUES (sid, delta);
IF FOUND THEN   RAISE NOTICE 'Found';
COMMIT;
SELECT * FROM x FULL OUTER JOIN x ON (x = x);
DROP TRIGGER merge_skip ON target;
DROP FUNCTION x;
/* test from PL/pgSQL */ /* make sure MERGE INTO isn't interpreted to mean returning variables like SELECT INTO */ BEGIN;
COMMIT;
ROLLBACK;
/* source constants */ BEGIN;
MERGE INTO x AS x USING (SELECT 9 AS x, 57 AS x) AS x ON x.x = x.x WHEN NOT MATCHED THEN INSERT (x, x) VALUES (x.x, x.x);
SELECT * FROM x ORDER BY x NULLS LAST;
ROLLBACK;
/* source query */ BEGIN;
MERGE INTO x AS x USING (SELECT x, x FROM x WHERE x > 0) AS x ON x.x = x.x WHEN NOT MATCHED THEN INSERT (x, x) VALUES (x.x, x.x);
SELECT * FROM x ORDER BY x NULLS LAST;
ROLLBACK;
BEGIN;
MERGE INTO x AS x USING (SELECT x, x AS x FROM x WHERE x > 0) AS x ON x.x = x.x WHEN NOT MATCHED THEN INSERT (x, x) VALUES (x.x, x.x);
SELECT * FROM x ORDER BY x NULLS LAST;
ROLLBACK;
/* self-merge */ BEGIN;
MERGE INTO x AS x USING x AS x ON x.x = x.x WHEN MATCHED THEN UPDATE SET x = x.x + x.x WHEN NOT MATCHED THEN INSERT VALUES (x.x, x.x);
SELECT * FROM x ORDER BY x NULLS LAST;
ROLLBACK;
BEGIN;
MERGE INTO x AS x USING (SELECT x AS x, x AS x FROM x WHERE x > 0) AS x ON x.x = x.x WHEN NOT MATCHED THEN INSERT (x, x) VALUES (x.x, x.x);
SELECT * FROM x ORDER BY x NULLS LAST;
ROLLBACK;
BEGIN;
MERGE INTO x AS x USING (SELECT x, MAX(x) AS x FROM x GROUP BY x HAVING COUNT(*) = 1 ORDER BY x ASC NULLS LAST) AS x ON x.x = x.x WHEN NOT MATCHED THEN INSERT (x, x) VALUES (x.x, x.x);
SELECT * FROM x ORDER BY x NULLS LAST;
ROLLBACK;
/* plpgsql parameters and results */ BEGIN;
BEGIN MERGE INTO target t USING (SELECT p_id AS sid) AS s ON t.tid = s.sid WHEN MATCHED THEN 	UPDATE SET balance = t.balance - p_bal;
IF FOUND THEN 	GET DIAGNOSTICS result := ROW_COUNT;
x AS x;
COMMIT;
SELECT MERGE_FUNC(3, 4);
SELECT * FROM x ORDER BY x NULLS LAST;
ROLLBACK;
/* PREPARE */ BEGIN;
PREPARE foom as merge into target t using (select 1 as sid) s on (t.tid = s.sid) when matched then update set balance = 1;
EXECUTE foom;
SELECT * FROM x ORDER BY x NULLS LAST;
ROLLBACK;
BEGIN;
PREPARE foom2 (integer, integer) AS MERGE INTO target t USING (SELECT 1) s ON t.tid = $1 WHEN MATCHED THEN UPDATE SET balance = $2;
/* EXPLAIN (ANALYZE ON, COSTS OFF, SUMMARY OFF, TIMING OFF) */ EXECUTE foom2 (1, 1);
SELECT * FROM x ORDER BY x NULLS LAST;
ROLLBACK;
/* subqueries in source relation */ CREATE TABLE x (x INT NOT NULL, x INT) WITH (autovacuum_enabled=off);
CREATE TABLE x (x INT, x INT, x INT DEFAULT 0) WITH (autovacuum_enabled=off);
INSERT INTO x (x, x) VALUES (1, 100), (2, 200), (3, 300);
INSERT INTO x (x, x) VALUES (1, 10), (2, 20), (4, 40);
BEGIN;
MERGE INTO x AS x USING (SELECT * FROM x) AS x ON x = x WHEN MATCHED AND x.x > x THEN UPDATE SET x = x.x + x;
SELECT * FROM x;
ROLLBACK;
/* try a view */ CREATE VIEW x AS SELECT * FROM x WHERE x < 2;
BEGIN;
MERGE INTO x USING x ON x = x WHEN MATCHED THEN UPDATE SET x = x.x + x;
SELECT * FROM x;
ROLLBACK;
/* ambiguous reference to a column */ BEGIN;
MERGE INTO x USING x ON x = x WHEN MATCHED AND x >= 2 THEN UPDATE SET x = x + x WHEN NOT MATCHED THEN INSERT (x, x) VALUES (x + x, x) WHEN MATCHED AND x < 2 THEN DELETE;
ROLLBACK;
BEGIN;
INSERT INTO x (x, x, x) VALUES (-1, -1, -10);
MERGE INTO x AS x USING x ON x = x WHEN MATCHED AND x >= 2 THEN UPDATE SET x = x.x + x WHEN NOT MATCHED THEN INSERT (x, x) VALUES (x + x, x) WHEN MATCHED AND x < 2 THEN DELETE;
SELECT * FROM x;
ROLLBACK;
/* CTEs */ BEGIN;
INSERT INTO x (x, x, x) VALUES (-1, -1, -10);
WITH x AS (SELECT * FROM x) MERGE INTO x AS x USING x ON x = x WHEN MATCHED AND x >= 2 THEN UPDATE SET x = x.x + x WHEN NOT MATCHED THEN INSERT (x, x) VALUES (x + x, x) WHEN MATCHED AND x < 2 THEN DELETE;
ROLLBACK;
/* RETURNING */ SELECT * FROM x ORDER BY x NULLS LAST;
SELECT * FROM x ORDER BY x NULLS LAST;
BEGIN;
CREATE TABLE x (x TEXT, x TEXT);
INSERT INTO x VALUES ('INSERT', 'ins'), ('UPDATE', 'upd'), ('DELETE', 'del');
MERGE INTO x AS x USING x AS x ON x = x WHEN MATCHED AND x >= 2 THEN UPDATE SET x = x.x + x WHEN NOT MATCHED THEN INSERT (x, x) VALUES (x + x, x) WHEN MATCHED AND x < 2 THEN DELETE RETURNING (SELECT x FROM x WHERE x = MERGE_ACTION()) AS x, x.x AS x, x.x AS x, x.x AS x, x.x AS x, (SELECT x.x - x.x AS x), x.*, CASE MERGE_ACTION() WHEN 'INSERT' THEN 'Inserted ' || x WHEN 'UPDATE' THEN 'Added ' || x || ' to balance' WHEN 'DELETE' THEN 'Removed ' || x END AS x;
ROLLBACK;
/* error when using merge_action() outside MERGE */ SELECT MERGE_ACTION() FROM x;
UPDATE x SET x = x + 1 RETURNING MERGE_ACTION();
/* RETURNING in CTEs */ CREATE TABLE x (x INT NOT NULL, x TEXT);
INSERT INTO x VALUES (1, 'Original value');
BEGIN;
WITH x AS (MERGE INTO x AS x USING x AS x ON x = x WHEN MATCHED AND x >= 2 THEN UPDATE SET x = x.x + x WHEN NOT MATCHED THEN INSERT (x, x) VALUES (x + x, x) WHEN MATCHED AND x < 2 THEN DELETE RETURNING MERGE_ACTION() AS x, x AS x, x AS x, x.*, CASE MERGE_ACTION() WHEN 'INSERT' THEN 'Inserted ' || x WHEN 'UPDATE' THEN 'Added ' || x || ' to balance' WHEN 'DELETE' THEN 'Removed ' || x END AS x), x AS (MERGE INTO x AS x USING x ON x.x = x.x WHEN MATCHED THEN UPDATE SET x = x WHEN NOT MATCHED THEN INSERT VALUES (x.x, x) RETURNING x.*, MERGE_ACTION() AS x, x AS x, x AS x, x.*) SELECT * FROM x;
SELECT * FROM x ORDER BY x NULLS LAST;
ROLLBACK;
/* COPY (MERGE ... RETURNING) TO ... */ BEGIN;
ROLLBACK;
/* SQL function with MERGE ... RETURNING */ BEGIN;
SELECT x.* FROM (VALUES (1, 0, 0), (3, 0, 20), (4, 100, 10)) AS x, LATERAL (SELECT x, x, x FROM x) AS x;
ROLLBACK;
/* SQL SRF with MERGE ... RETURNING */ BEGIN;
SELECT * FROM x;
ROLLBACK;
/* PL/pgSQL function with MERGE ... RETURNING ... INTO */ BEGIN;
COMMIT;
SELECT x.* FROM (VALUES (1, 0, 0), (3, 0, 20), (4, 100, 10)) AS x, LATERAL (SELECT x, x, x FROM x) AS x;
ROLLBACK;
/* EXPLAIN */ CREATE TABLE x (x INT, x INT) WITH (autovacuum_enabled=off);
CREATE TABLE x (x INT, x INT) WITH (autovacuum_enabled=off);
INSERT INTO x SELECT x, x * 10 FROM x AS x;
INSERT INTO x SELECT x, x * 10 FROM x AS x;
BEGIN FOR ln IN         EXECUTE 'explain (analyze, timing off, summary off, costs off, buffers off) ' || 		  query     LOOP         ln := regexp_replace(ln, '(Memory( Usage)?|Buckets|Batches): \S*',  '\1: xxx', 'g');
COMMIT;
/* only updates */ SELECT EXPLAIN_MERGE(' MERGE INTO ex_mtarget t USING ex_msource s ON t.a = s.a WHEN MATCHED THEN 	UPDATE SET b = t.b + 1');
/* only updates to selected tuples */ SELECT EXPLAIN_MERGE(' MERGE INTO ex_mtarget t USING ex_msource s ON t.a = s.a WHEN MATCHED AND t.a < 10 THEN 	UPDATE SET b = t.b + 1');
/* updates + deletes */ SELECT EXPLAIN_MERGE(' MERGE INTO ex_mtarget t USING ex_msource s ON t.a = s.a WHEN MATCHED AND t.a < 10 THEN 	UPDATE SET b = t.b + 1 WHEN MATCHED AND t.a >= 10 AND t.a <= 20 THEN 	DELETE');
/* only inserts */ SELECT EXPLAIN_MERGE(' MERGE INTO ex_mtarget t USING ex_msource s ON t.a = s.a WHEN NOT MATCHED AND s.a < 10 THEN 	INSERT VALUES (a, b)');
/* all three */ SELECT EXPLAIN_MERGE(' MERGE INTO ex_mtarget t USING ex_msource s ON t.a = s.a WHEN MATCHED AND t.a < 10 THEN 	UPDATE SET b = t.b + 1 WHEN MATCHED AND t.a >= 30 AND t.a <= 40 THEN 	DELETE WHEN NOT MATCHED AND s.a < 20 THEN 	INSERT VALUES (a, b)');
/* not matched by source */ SELECT EXPLAIN_MERGE(' MERGE INTO ex_mtarget t USING ex_msource s ON t.a = s.a WHEN NOT MATCHED BY SOURCE and t.a < 10 THEN 	DELETE');
/* not matched by source and target */ SELECT EXPLAIN_MERGE(' MERGE INTO ex_mtarget t USING ex_msource s ON t.a = s.a WHEN NOT MATCHED BY SOURCE AND t.a < 10 THEN 	DELETE WHEN NOT MATCHED BY TARGET AND s.a < 20 THEN 	INSERT VALUES (a, b)');
/* nothing */ SELECT EXPLAIN_MERGE(' MERGE INTO ex_mtarget t USING ex_msource s ON t.a = s.a AND t.a < -1000 WHEN MATCHED AND t.a < 10 THEN 	DO NOTHING');
DROP FUNCTION x (TEXT);
/* EXPLAIN SubPlans and InitPlans */ CREATE TABLE x (x INT, x INT, x INT, x INT);
CREATE TABLE x (x INT, x INT, x INT, x INT);
CREATE TABLE x (x INT, x INT);
EXPLAIN (verbose, costs off) MERGE INTO tgt t USING (SELECT *, (SELECT count(*) FROM ref r                    WHERE r.ab = s.a + s.b                      AND r.cd = s.c - s.d) cnt          FROM src s) s ON t.a = s.a AND t.b < s.cnt WHEN MATCHED AND t.c > s.cnt THEN   UPDATE SET (b, c) = (SELECT s.b, s.cnt);
/* Subqueries */ BEGIN;
MERGE INTO x AS x USING x ON x = x WHEN MATCHED THEN UPDATE SET x = (SELECT COUNT(*) FROM x);
SELECT * FROM x WHERE x = 1;
ROLLBACK;
BEGIN;
MERGE INTO x AS x USING x ON x = x WHEN MATCHED AND (SELECT COUNT(*) > 0 FROM x) THEN UPDATE SET x = 42;
SELECT * FROM x WHERE x = 1;
ROLLBACK;
BEGIN;
MERGE INTO x AS x USING x ON x = x AND (SELECT COUNT(*) > 0 FROM x) WHEN MATCHED THEN UPDATE SET x = 42;
SELECT * FROM x WHERE x = 1;
ROLLBACK;
CREATE TABLE x (x INT, x DOUBLE, x TEXT) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN (1, 4) WITH (autovacuum_enabled=off);
CREATE TABLE x PARTITION OF x FOR VALUES IN (2, 5, 6) WITH (autovacuum_enabled=off);
CREATE TABLE x PARTITION OF x FOR VALUES IN (3, 8, 9) WITH (autovacuum_enabled=off);
CREATE TABLE x PARTITION OF x DEFAULT WITH (autovacuum_enabled=off);
CREATE TABLE x (x INT, x DOUBLE);
/* insert many rows to the source table */ INSERT INTO x SELECT x, x * 10 FROM x AS x;
/* insert a few rows in the target table (odd numbered tid) */ INSERT INTO x SELECT x, x * 100, 'initial' FROM x AS x;
/* try simple MERGE */ BEGIN;
MERGE INTO x AS x USING x AS x ON x.x = x.x WHEN MATCHED THEN UPDATE SET x = x + x, x = x || ' updated by merge' WHEN NOT MATCHED THEN INSERT VALUES (x, x, 'inserted by merge') WHEN NOT MATCHED BY SOURCE THEN UPDATE SET x = x || ' not matched by source';
SELECT * FROM x ORDER BY x NULLS LAST, x NULLS LAST;
ROLLBACK;
/* same with a constant qual */ BEGIN;
MERGE INTO x AS x USING x AS x ON x.x = x.x AND x = 1 WHEN MATCHED THEN UPDATE SET x = x + x, x = x || ' updated by merge' WHEN NOT MATCHED THEN INSERT VALUES (x, x, 'inserted by merge') WHEN NOT MATCHED BY SOURCE THEN UPDATE SET x = x || ' not matched by source';
SELECT * FROM x ORDER BY x NULLS LAST, x NULLS LAST;
ROLLBACK;
/* try updating the partition key column */ BEGIN;
BEGIN MERGE INTO pa_target t   USING pa_source s   ON t.tid = s.sid   WHEN MATCHED THEN     UPDATE SET tid = tid + 1, balance = balance + delta, val = val || ' updated by merge'   WHEN NOT MATCHED THEN     INSERT VALUES (sid, delta, 'inserted by merge')   WHEN NOT MATCHED BY SOURCE THEN     UPDATE SET tid = 1, val = val || ' not matched by source';
IF FOUND THEN   GET DIAGNOSTICS result := ROW_COUNT;
x AS x;
COMMIT;
SELECT MERGE_FUNC();
SELECT * FROM x ORDER BY x NULLS LAST, x NULLS LAST;
ROLLBACK;
/* update partition key to partition not initially scanned */ BEGIN;
MERGE INTO x AS x USING x AS x ON x.x = x.x AND x.x = 1 WHEN MATCHED THEN UPDATE SET x = x + 1, x = x + x, x = x || ' updated by merge' RETURNING MERGE_ACTION(), x, x, x.*;
SELECT * FROM x ORDER BY x NULLS LAST;
ROLLBACK;
DROP TABLE x CASCADE;
/* The target table is partitioned in the same way, but this time by attaching */ /* partitions which have columns in different order, dropped columns etc. */ CREATE TABLE x (x INT, x DOUBLE, x TEXT) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x (x INT, x DOUBLE, x TEXT) WITH (autovacuum_enabled=off);
CREATE TABLE x (x DOUBLE, x INT, x TEXT) WITH (autovacuum_enabled=off);
CREATE TABLE x (x INT, x DOUBLE, x TEXT) WITH (autovacuum_enabled=off);
CREATE TABLE x (x TEXT, x INT, x DOUBLE, x TEXT) WITH (autovacuum_enabled=off);
ALTER TABLE x DROP COLUMN x;
ALTER TABLE pa_target ATTACH PARTITION part1 FOR VALUES IN (1,4);
ALTER TABLE pa_target ATTACH PARTITION part2 FOR VALUES IN (2,5,6);
ALTER TABLE pa_target ATTACH PARTITION part3 FOR VALUES IN (3,8,9);
ALTER TABLE pa_target ATTACH PARTITION part4 DEFAULT;
/* insert a few rows in the target table (odd numbered tid) */ INSERT INTO x SELECT x, x * 100, 'initial' FROM x AS x;
/* try simple MERGE */ BEGIN;
BEGIN MERGE INTO pa_target t   USING pa_source s   ON t.tid = s.sid   WHEN MATCHED THEN     UPDATE SET balance = balance + delta, val = val || ' updated by merge'   WHEN NOT MATCHED THEN     INSERT VALUES (sid, delta, 'inserted by merge')   WHEN NOT MATCHED BY SOURCE THEN     UPDATE SET val = val || ' not matched by source';
COMMIT;
SELECT * FROM x ORDER BY x NULLS LAST, x NULLS LAST;
ROLLBACK;
/* same with a constant qual */ BEGIN;
MERGE INTO x AS x USING x AS x ON x.x = x.x AND x IN (1, 5) WHEN MATCHED AND x % 5 = 0 THEN DELETE WHEN MATCHED THEN UPDATE SET x = x + x, x = x || ' updated by merge' WHEN NOT MATCHED THEN INSERT VALUES (x, x, 'inserted by merge') WHEN NOT MATCHED BY SOURCE THEN UPDATE SET x = x || ' not matched by source';
SELECT * FROM x ORDER BY x NULLS LAST, x NULLS LAST;
ROLLBACK;
/* try updating the partition key column */ BEGIN;
BEGIN MERGE INTO pa_target t   USING pa_source s   ON t.tid = s.sid   WHEN MATCHED THEN     UPDATE SET tid = tid + 1, balance = balance + delta, val = val || ' updated by merge'   WHEN NOT MATCHED THEN     INSERT VALUES (sid, delta, 'inserted by merge')   WHEN NOT MATCHED BY SOURCE THEN     UPDATE SET tid = 1, val = val || ' not matched by source';
COMMIT;
SELECT * FROM x ORDER BY x NULLS LAST, x NULLS LAST;
ROLLBACK;
/* as above, but blocked by BEFORE DELETE ROW trigger */ BEGIN;
COMMIT;
CREATE TRIGGER del_trig BEFORE DELETE ON pa_target   FOR EACH ROW EXECUTE PROCEDURE trig_fn();
BEGIN MERGE INTO pa_target t   USING pa_source s   ON t.tid = s.sid   WHEN MATCHED THEN     UPDATE SET tid = tid + 1, balance = balance + delta, val = val || ' updated by merge'   WHEN NOT MATCHED THEN     INSERT VALUES (sid, delta, 'inserted by merge')   WHEN NOT MATCHED BY SOURCE THEN     UPDATE SET val = val || ' not matched by source';
COMMIT;
SELECT * FROM x ORDER BY x NULLS LAST, x NULLS LAST;
ROLLBACK;
/* as above, but blocked by BEFORE INSERT ROW trigger */ BEGIN;
COMMIT;
CREATE TRIGGER ins_trig BEFORE INSERT ON pa_target   FOR EACH ROW EXECUTE PROCEDURE trig_fn();
BEGIN MERGE INTO pa_target t   USING pa_source s   ON t.tid = s.sid   WHEN MATCHED THEN     UPDATE SET tid = tid + 1, balance = balance + delta, val = val || ' updated by merge'   WHEN NOT MATCHED THEN     INSERT VALUES (sid, delta, 'inserted by merge')   WHEN NOT MATCHED BY SOURCE THEN     UPDATE SET val = val || ' not matched by source';
COMMIT;
SELECT * FROM x ORDER BY x NULLS LAST, x NULLS LAST;
ROLLBACK;
/* test RLS enforcement */ BEGIN;
ALTER TABLE pa_target ENABLE ROW LEVEL SECURITY;
ALTER TABLE pa_target FORCE ROW LEVEL SECURITY;
CREATE POLICY pa_target_pol ON pa_target USING (tid != 0);
MERGE INTO x AS x USING x AS x ON x.x = x.x AND x.x IN (1, 2, 3, 4) WHEN MATCHED THEN UPDATE SET x = x - 1;
ROLLBACK;
DROP TABLE x;
DROP TABLE x CASCADE;
/* Sub-partitioning */ CREATE TABLE x (x TIMESTAMP, x INT, x DOUBLE, x TEXT) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM ('2017-01-01') TO ('2017-02-01') WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN (1, 3, 5, 7, 9) WITH (autovacuum_enabled=off);
CREATE TABLE x PARTITION OF x FOR VALUES IN (2, 4, 6, 8) WITH (autovacuum_enabled=off);
CREATE TABLE x PARTITION OF x FOR VALUES FROM ('2017-02-01') TO ('2017-03-01') WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN (1, 3, 5, 7, 9) WITH (autovacuum_enabled=off);
CREATE TABLE x PARTITION OF x FOR VALUES IN (2, 4, 6, 8) WITH (autovacuum_enabled=off);
CREATE TABLE x (x INT, x DOUBLE) WITH (autovacuum_enabled=off);
/* insert many rows to the source table */ INSERT INTO x SELECT x, x * 10 FROM x AS x;
/* insert a few rows in the target table (odd numbered tid) */ INSERT INTO x SELECT '2017-01-31', x, x * 100, 'initial' FROM x AS x;
INSERT INTO x SELECT '2017-02-28', x, x * 100, 'initial' FROM x AS x;
/* try simple MERGE */ BEGIN;
MERGE INTO x AS x USING (SELECT '2017-01-15' AS x, * FROM x WHERE x < 10) AS x ON x.x = x.x WHEN MATCHED THEN UPDATE SET x = x + x, x = x || ' updated by merge' WHEN NOT MATCHED THEN INSERT VALUES (CAST(x AS TIMESTAMP), x, x, 'inserted by merge') RETURNING MERGE_ACTION(), x, x, x.*;
SELECT * FROM x ORDER BY x NULLS LAST;
ROLLBACK;
DROP TABLE x;
DROP TABLE x CASCADE;
/* Partitioned table with primary key */ CREATE TABLE x (x INT PRIMARY KEY) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x DEFAULT;
CREATE TABLE x (x INT);
INSERT INTO x VALUES (1), (2);
EXPLAIN (VERBOSE, COSTS OFF) MERGE INTO pa_target t USING pa_source s ON t.tid = s.sid   WHEN NOT MATCHED THEN INSERT VALUES (s.sid);
MERGE INTO x AS x USING x AS x ON x.x = x.x WHEN NOT MATCHED THEN INSERT VALUES (x.x);
x AS x;
/* Partition-less partitioned table */ /* (the bug we are checking for appeared only if table had partitions before) */ DROP TABLE x;
EXPLAIN (VERBOSE, COSTS OFF) MERGE INTO pa_target t USING pa_source s ON t.tid = s.sid   WHEN NOT MATCHED THEN INSERT VALUES (s.sid);
MERGE INTO x AS x USING x AS x ON x.x = x.x WHEN NOT MATCHED THEN INSERT VALUES (x.x);
DROP TABLE x;
DROP TABLE x CASCADE;
/* some complex joins on the source side */ CREATE TABLE x (x INT, x DOUBLE, x TEXT) WITH (autovacuum_enabled=off);
CREATE TABLE x (x INT, x INT, x INT) WITH (autovacuum_enabled=off);
CREATE TABLE x (x INT, x TEXT) WITH (autovacuum_enabled=off);
INSERT INTO x VALUES (1, 10, 100);
INSERT INTO x VALUES (1, 20, 200);
INSERT INTO x VALUES (2, 20, 300);
INSERT INTO x VALUES (3, 10, 400);
INSERT INTO x VALUES (1, 'initial source2');
INSERT INTO x VALUES (2, 'initial source2');
INSERT INTO x VALUES (3, 'initial source2');
SELECT * FROM x;
SELECT * FROM x;
ALTER TABLE x RENAME COLUMN x TO x;
ALTER TABLE x RENAME COLUMN x TO x;
TRUNCATE TABLE x;
/* Function scans */ CREATE TABLE x (x INT, x INT, x TEXT) WITH (autovacuum_enabled=off);
MERGE INTO x AS x USING x AS x ON x.x = x WHEN MATCHED THEN UPDATE SET x = x + x WHEN NOT MATCHED THEN INSERT VALUES (x, -1);
MERGE INTO x AS x USING x AS x ON x.x = x WHEN MATCHED THEN UPDATE SET x = x + x, x = 'updated ' || CAST(x.* AS TEXT) WHEN NOT MATCHED THEN INSERT VALUES (x, -1, 'inserted ' || CAST(x.* AS TEXT));
SELECT COUNT(*) FROM x;
DROP TABLE x;
/* SERIALIZABLE test */ /* handled in isolation tests */ /* Inheritance-based partitioning */ CREATE TABLE x (x INT NOT NULL, x DATE NOT NULL, x INT, x INT) WITH (autovacuum_enabled=off);
CREATE TABLE x (CHECK (x >= CAST('2006-02-01' AS DATE) AND x < CAST('2006-03-01' AS DATE))) INHERITS (x) WITH (autovacuum_enabled=off);
CREATE TABLE x (CHECK (x >= CAST('2006-03-01' AS DATE) AND x < CAST('2006-04-01' AS DATE))) INHERITS (x) WITH (autovacuum_enabled=off);
CREATE TABLE x (x TEXT, x INT, x DATE NOT NULL, x INT NOT NULL, x INT CHECK (x >= CAST('2007-01-01' AS DATE) AND x < CAST('2007-02-01' AS DATE))) WITH (autovacuum_enabled=off);
ALTER TABLE x DROP COLUMN x;
ALTER TABLE measurement_y2007m01 INHERIT measurement;
INSERT INTO x VALUES (0, '2005-07-21', 5, 15);
x AS x;
COMMIT;
CREATE TRIGGER insert_measurement_trigger     BEFORE INSERT ON measurement     FOR EACH ROW EXECUTE PROCEDURE measurement_insert_trigger();
INSERT INTO x VALUES (1, '2006-02-10', 35, 10);
INSERT INTO x VALUES (1, '2006-02-16', 45, 20);
INSERT INTO x VALUES (1, '2006-03-17', 25, 10);
INSERT INTO x VALUES (1, '2006-03-27', 15, 40);
INSERT INTO x VALUES (1, '2007-01-15', 10, 10);
INSERT INTO x VALUES (1, '2007-01-17', 10, 10);
SELECT CAST(x AS REGCLASS), * FROM x ORDER BY x NULLS LAST, x NULLS LAST;
CREATE TABLE x (LIKE x) WITH (autovacuum_enabled=off);
INSERT INTO x VALUES (0, '2005-07-21', 25, 20);
INSERT INTO x VALUES (1, '2006-03-01', 20, 10);
INSERT INTO x VALUES (1, '2006-02-16', 50, 10);
INSERT INTO x VALUES (2, '2006-02-10', 20, 20);
INSERT INTO x VALUES (1, '2006-03-27', NULL, NULL);
INSERT INTO x VALUES (1, '2007-01-17', NULL, NULL);
INSERT INTO x VALUES (1, '2007-01-15', 5, NULL);
INSERT INTO x VALUES (1, '2007-01-16', 10, 10);
BEGIN;
MERGE INTO ONLY x AS x USING x AS x ON (x.x = x.x AND x.x = x.x) WHEN MATCHED AND x.x IS NULL THEN DELETE WHEN MATCHED THEN UPDATE SET x = GREATEST(x.x, x.x), x = x.x + COALESCE(x.x, 0) WHEN NOT MATCHED THEN INSERT (x, x, x, x) VALUES (x, x, x, x);
SELECT CAST(x AS REGCLASS), * FROM x ORDER BY x NULLS LAST, x NULLS LAST, x NULLS LAST;
ROLLBACK;
MERGE INTO x AS x USING x AS x ON (x.x = x.x AND x.x = x.x) WHEN MATCHED AND x.x IS NULL THEN DELETE WHEN MATCHED THEN UPDATE SET x = GREATEST(x.x, x.x), x = x.x + COALESCE(x.x, 0) WHEN NOT MATCHED THEN INSERT (x, x, x, x) VALUES (x, x, x, x);
SELECT CAST(x AS REGCLASS), * FROM x ORDER BY x NULLS LAST, x NULLS LAST;
BEGIN;
MERGE INTO x AS x USING ONLY x AS x ON (x.x = x.x AND x.x = x.x) WHEN MATCHED THEN DELETE;
SELECT * FROM x ORDER BY x NULLS LAST, x NULLS LAST;
ROLLBACK;
MERGE INTO x AS x USING x AS x ON (x.x = x.x AND x.x = x.x) WHEN MATCHED THEN DELETE;
SELECT * FROM x ORDER BY x NULLS LAST, x NULLS LAST;
DROP FUNCTION x;
/* test non-strict join clause */ CREATE TABLE x (x INT, x TEXT);
INSERT INTO x VALUES (1, 'src row');
CREATE TABLE x (x INT, x TEXT);
INSERT INTO x VALUES (NULL, 'tgt row');
MERGE INTO x USING x ON x.x IS NOT DISTINCT FROM x.x WHEN MATCHED THEN UPDATE SET x = x.x, x = x.x WHEN NOT MATCHED BY SOURCE THEN DELETE RETURNING MERGE_ACTION(), x.*, x.*;
SELECT * FROM x;
/* test for bug #18634 (wrong varnullingrels error) */ CREATE TABLE x (x INT, x INT, x TEXT);
INSERT INTO x VALUES (1, 10, 'tgt1'), (2, 20, 'tgt2');
CREATE VIEW x AS SELECT * FROM x WHERE EXISTS(SELECT 1 FROM x);
CREATE TABLE x (x INT, x INT, x TEXT);
INSERT INTO x VALUES (1, 2, 'src1');
MERGE INTO x AS x USING x AS x ON x.x = x.x WHEN MATCHED THEN UPDATE SET x = x.x WHEN NOT MATCHED BY SOURCE THEN DELETE RETURNING MERGE_ACTION(), x.x, x.*;
SELECT * FROM x;
DROP TABLE x CASCADE;
DROP TABLE x;
/* prepare */ RESET SESSION AUTHORIZATION;
MERGE INTO x AS x USING (SELECT CAST('pg_depend' AS REGCLASS) AS x) AS x ON x.x = x.x WHEN MATCHED THEN UPDATE SET x = x + 1 RETURNING x.x /* try a system catalog */;
CREATE VIEW x AS SELECT * FROM x;
MERGE INTO x AS x USING x AS x ON x.x = x.x WHEN MATCHED AND x.x = CAST('pg_depend' AS REGCLASS) THEN UPDATE SET x = x - 1 RETURNING x.x;
DROP FUNCTION x;
DROP USER regress_merge_privs;
DROP USER regress_merge_no_privs;
DROP USER regress_merge_none;
CREATE FUNCTION reverse_name(name)    RETURNS name    AS :'regresslib'    LANGUAGE C STRICT;
/* BTREE */ UPDATE x SET x = x.x + 1;
UPDATE x SET x = x.x - 1;
/* BTREE shutting out non-functional updates */ /* the following two tests seem to take a long time on some */ /* systems.    This non-func update stuff needs to be examined */ /* more closely.  			- jolly (2/22/96) */ CREATE TABLE x AS SELECT x, x, x, x FROM x;
UPDATE x SET x = REVERSE_NAME(x.x) FROM x WHERE x.x = 'JBAAAA' AND x.x = x.x;
UPDATE x SET x = REVERSE_NAME(x.x) FROM x WHERE x.x = 'JCAAAA' AND x.x = x.x;
DROP TABLE x;
CREATE TEMPORARY TABLE x (LIKE x);
SELECT * FROM x EXCEPT ALL SELECT * FROM x;
SELECT * FROM x EXCEPT ALL SELECT * FROM x;
CREATE TEMPORARY TABLE x (LIKE x);
SELECT * FROM x;
/* test data for postquel functions */ CREATE TABLE x (x TEXT, x TEXT);
CREATE TABLE x (x TEXT, x TEXT);
INSERT INTO x (x, x) SELECT 'posthacking', x.x FROM x AS x WHERE x.x = 'mike' OR x.x = 'jeff';
INSERT INTO x (x, x) SELECT 'basketball', x.x FROM x AS x WHERE x.x = 'joe' OR x.x = 'sally';
INSERT INTO x (x) VALUES ('skywalking');
INSERT INTO x (x, x) VALUES ('advil', 'posthacking');
INSERT INTO x (x, x) VALUES ('peet''s coffee', 'posthacking');
INSERT INTO x (x, x) VALUES ('hightops', 'basketball');
INSERT INTO x (x, x) VALUES ('guts', 'skywalking');
/* postquel functions */ CREATE FUNCTION hobbies(person)    RETURNS setof hobbies_r    AS 'select * from hobbies_r where person = $1.name'    LANGUAGE SQL;
CREATE FUNCTION x(x, x) RETURNS hobbies_r LANGUAGE SQL AS 'select $1 as name, $2 as hobby';
CREATE FUNCTION x(x TEXT, x TEXT) RETURNS hobbies_r LANGUAGE SQL AS 'select name, hobby';
CREATE FUNCTION equipment(hobbies_r)    RETURNS setof equipment_r    AS 'select * from equipment_r where hobby = $1.name'    LANGUAGE SQL;
CREATE FUNCTION equipment_named(hobby hobbies_r)    RETURNS setof equipment_r    AS 'select * from equipment_r where equipment_r.hobby = equipment_named.hobby.name'    LANGUAGE SQL;
CREATE FUNCTION equipment_named_ambiguous_1a(hobby hobbies_r)    RETURNS setof equipment_r    AS 'select * from equipment_r where hobby = equipment_named_ambiguous_1a.hobby.name'    LANGUAGE SQL;
CREATE FUNCTION equipment_named_ambiguous_1b(hobby hobbies_r)    RETURNS setof equipment_r    AS 'select * from equipment_r where equipment_r.hobby = hobby.name'    LANGUAGE SQL;
CREATE FUNCTION equipment_named_ambiguous_1c(hobby hobbies_r)    RETURNS setof equipment_r    AS 'select * from equipment_r where hobby = hobby.name'    LANGUAGE SQL;
CREATE FUNCTION equipment_named_ambiguous_2a(hobby text)    RETURNS setof equipment_r    AS 'select * from equipment_r where hobby = equipment_named_ambiguous_2a.hobby'    LANGUAGE SQL;
CREATE FUNCTION equipment_named_ambiguous_2b(hobby text)    RETURNS setof equipment_r    AS 'select * from equipment_r where equipment_r.hobby = hobby'    LANGUAGE SQL;
/* mike does post_hacking, */ /* joe and sally play basketball, and */ /* everyone else does nothing. */ SELECT x.x, NAME(x.x) FROM ONLY x AS x;
/* as above, but jeff also does post_hacking. */ SELECT x.x, NAME(x.x) FROM x AS x;
/* the next two queries demonstrate how functions generate bogus duplicates. */ /* this is a "feature" .. */ SELECT DISTINCT x.x, NAME(x.x) FROM x ORDER BY 1 NULLS LAST, 2 NULLS LAST;
SELECT x.x, (x.x).x FROM x;
/* mike needs advil and peet's coffee, */ /* joe and sally need hightops, and */ /* everyone else is fine. */ SELECT x.x, NAME(x.x), NAME(EQUIPMENT(x.x)) FROM ONLY x AS x;
/* as above, but jeff needs advil and peet's coffee as well. */ SELECT x.x, NAME(x.x), NAME(EQUIPMENT(x.x)) FROM x AS x;
/* just like the last two, but make sure that the target list fixup and */ /* unflattening is being done correctly. */ SELECT NAME(EQUIPMENT(x.x)), x.x, NAME(x.x) FROM ONLY x AS x;
SELECT (x.x).x.x, x.x, NAME(x.x) FROM x AS x;
SELECT (x.x).x.x, NAME(x.x), x.x FROM ONLY x AS x;
SELECT NAME(EQUIPMENT(x.x)), NAME(x.x), x.x FROM x AS x;
SELECT NAME(EQUIPMENT(HOBBY_CONSTRUCT(CAST('skywalking' AS TEXT), CAST('mer' AS TEXT))));
SELECT NAME(EQUIPMENT(HOBBY_CONSTRUCT_NAMED(CAST('skywalking' AS TEXT), CAST('mer' AS TEXT))));
SELECT NAME(EQUIPMENT_NAMED(HOBBY_CONSTRUCT_NAMED(CAST('skywalking' AS TEXT), CAST('mer' AS TEXT))));
SELECT NAME(EQUIPMENT_NAMED_AMBIGUOUS_1A(HOBBY_CONSTRUCT_NAMED(CAST('skywalking' AS TEXT), CAST('mer' AS TEXT))));
SELECT NAME(EQUIPMENT_NAMED_AMBIGUOUS_1B(HOBBY_CONSTRUCT_NAMED(CAST('skywalking' AS TEXT), CAST('mer' AS TEXT))));
SELECT NAME(EQUIPMENT_NAMED_AMBIGUOUS_1C(HOBBY_CONSTRUCT_NAMED(CAST('skywalking' AS TEXT), CAST('mer' AS TEXT))));
SELECT NAME(EQUIPMENT_NAMED_AMBIGUOUS_2A(CAST('skywalking' AS TEXT)));
SELECT NAME(EQUIPMENT_NAMED_AMBIGUOUS_2B(CAST('skywalking' AS TEXT)));
SELECT HOBBIES_BY_NAME('basketball');
SELECT x, OVERPAID(x.*) FROM x;
/* Try a few cases with SQL-spec row constructor expressions */ SELECT * FROM x;
SELECT NAME(EQUIPMENT(ROW('skywalking', 'mer')));
SELECT *, NAME(EQUIPMENT(x.*)) FROM x AS x;
SELECT *, (EQUIPMENT(CAST((x.*) AS hobbies_r))).x FROM x AS x;
x AS x;
BEGIN IF do_analyze = true THEN         analyze_str := 'on';
SET LOCAL x = 0 /* avoid jit related output by disabling it */;
IF hide_row_est = true THEN             -- don't use 'g' so that we leave the actual rows intact             ln := regexp_replace(ln, 'rows=\d+', 'rows=N');
IF hide_width = true THEN             ln := regexp_replace(ln, 'width=\d+', 'width=N');
COMMIT;
/* num_nulls() */ SELECT NUM_NONNULLS(NULL);
SELECT NUM_NONNULLS('1');
SELECT NUM_NONNULLS(CAST(NULL AS TEXT));
SELECT NUM_NONNULLS(CAST(NULL AS TEXT), CAST(NULL AS INT));
SELECT NUM_NONNULLS(1, 2, CAST(NULL AS TEXT), CAST(NULL AS point), '', CAST('9' AS BIGINT), 1.0 / NULL);
SELECT NUM_NULLS(NULL);
SELECT NUM_NULLS('1');
SELECT NUM_NULLS(CAST(NULL AS TEXT));
SELECT NUM_NULLS(CAST(NULL AS TEXT), CAST(NULL AS INT));
SELECT NUM_NULLS(1, 2, CAST(NULL AS TEXT), CAST(NULL AS point), '', CAST('9' AS BIGINT), 1.0 / NULL);
/* should fail, one or more arguments is required */ SELECT NUM_NONNULLS();
SELECT NUM_NULLS();
/* canonicalize_path() */ CREATE FUNCTION test_canonicalize_path(text)    RETURNS text    AS :'regresslib'    LANGUAGE C STRICT IMMUTABLE;
SELECT TEST_CANONICALIZE_PATH('/');
SELECT TEST_CANONICALIZE_PATH('/./abc/def/');
SELECT TEST_CANONICALIZE_PATH('/./../abc/def');
SELECT TEST_CANONICALIZE_PATH('/./../../abc/def/');
SELECT TEST_CANONICALIZE_PATH('/abc/.././def/ghi');
SELECT TEST_CANONICALIZE_PATH('/abc/./../def/ghi//');
SELECT TEST_CANONICALIZE_PATH('/abc/def/../..');
SELECT TEST_CANONICALIZE_PATH('/abc/def/../../..');
SELECT TEST_CANONICALIZE_PATH('/abc/def/../../../../ghi/jkl');
SELECT TEST_CANONICALIZE_PATH('.');
SELECT TEST_CANONICALIZE_PATH('./');
SELECT TEST_CANONICALIZE_PATH('./abc/..');
SELECT TEST_CANONICALIZE_PATH('abc/../');
SELECT TEST_CANONICALIZE_PATH('abc/../def');
SELECT TEST_CANONICALIZE_PATH('..');
SELECT TEST_CANONICALIZE_PATH('../abc/def');
SELECT TEST_CANONICALIZE_PATH('../abc/..');
SELECT TEST_CANONICALIZE_PATH('../abc/../def');
SELECT TEST_CANONICALIZE_PATH('../abc/../../def/ghi');
SELECT TEST_CANONICALIZE_PATH('./abc/./def/.');
SELECT TEST_CANONICALIZE_PATH('./abc/././def/.');
SELECT TEST_CANONICALIZE_PATH('./abc/./def/.././ghi/../../../jkl/mno');
/* pg_log_backend_memory_contexts() */ /* Memory contexts are logged and they are not returned to the function. */ /* Furthermore, their contents can vary depending on the timing. However, */ /* we can at least verify that the code doesn't fail, and that the */ /* permissions are set properly. */ SELECT PG_LOG_BACKEND_MEMORY_CONTEXTS(PG_BACKEND_PID());
SELECT PG_LOG_BACKEND_MEMORY_CONTEXTS(x) FROM x WHERE x = 'checkpointer';
CREATE ROLE regress_log_memory;
SELECT HAS_FUNCTION_PRIVILEGE('regress_log_memory', 'pg_log_backend_memory_contexts(integer)', 'EXECUTE');
GRANT EXECUTE ON FUNCTION x TO x /* no */;
SELECT HAS_FUNCTION_PRIVILEGE('regress_log_memory', 'pg_log_backend_memory_contexts(integer)', 'EXECUTE');
/* yes */ SET ROLE regress_log_memory;
SELECT PG_LOG_BACKEND_MEMORY_CONTEXTS(PG_BACKEND_PID());
RESET ROLE;
REVOKE EXECUTE ON FUNCTION pg_log_backend_memory_contexts(integer)   FROM regress_log_memory;
DROP ROLE regress_log_memory;
/* Test ProjectSet as well as FunctionScan */ SELECT COUNT(*) > 0 AS x FROM (SELECT PG_LS_WALDIR()) AS x;
/* Test not-run-to-completion cases. */ SELECT * FROM x LIMIT 0;
SELECT COUNT(*) > 0 AS x FROM (SELECT * FROM x LIMIT 1) AS x;
SELECT (x).x = :segsize AS x FROM (SELECT PG_LS_WALDIR() AS x) AS x WHERE LENGTH((x).x) = 24 LIMIT 1;
SELECT COUNT(*) >= 0 AS x FROM x;
SELECT COUNT(*) >= 0 AS x FROM x;
/* pg_read_file() */ SELECT LENGTH(PG_READ_FILE('postmaster.pid')) > 20;
SELECT LENGTH(PG_READ_FILE('postmaster.pid', 1, 20));
/* Test missing_ok */ SELECT PG_READ_FILE('does not exist');
/* error */ SELECT PG_READ_FILE('does not exist', TRUE) IS NULL;
/* ok */ /* Test invalid argument */ SELECT PG_READ_FILE('does not exist', 0, -1);
/* error */ SELECT PG_READ_FILE('does not exist', 0, -1, TRUE);
/* error */ /* pg_read_binary_file() */ SELECT LENGTH(PG_READ_BINARY_FILE('postmaster.pid')) > 20;
SELECT LENGTH(PG_READ_BINARY_FILE('postmaster.pid', 1, 20));
/* Test missing_ok */ SELECT PG_READ_BINARY_FILE('does not exist');
/* error */ SELECT PG_READ_BINARY_FILE('does not exist', TRUE) IS NULL;
/* ok */ /* Test invalid argument */ SELECT PG_READ_BINARY_FILE('does not exist', 0, -1);
/* error */ SELECT PG_READ_BINARY_FILE('does not exist', 0, -1, TRUE);
/* error */ /* pg_stat_file() */ SELECT x > 20, x FROM x;
/* pg_ls_dir() */ SELECT * FROM (SELECT PG_LS_DIR('.') AS x) AS x WHERE x = 'base' LIMIT 1;
/* Test missing_ok (second argument) */ SELECT PG_LS_DIR('does not exist', FALSE, FALSE);
/* error */ SELECT PG_LS_DIR('does not exist', TRUE, FALSE);
/* ok */ /* Test include_dot_dirs (third argument) */ SELECT COUNT(*) = 1 AS x FROM x AS x WHERE x = '.';
SELECT COUNT(*) = 1 AS x FROM x AS x WHERE x = '.';
/* pg_timezone_names() */ SELECT * FROM (SELECT (PG_TIMEZONE_NAMES()).x) AS x WHERE x = 'UTC' LIMIT 1;
/* pg_tablespace_databases() */ SELECT COUNT(*) > 0 FROM (SELECT PG_TABLESPACE_DATABASES(x) AS x FROM x WHERE x = 'pg_default') AS x JOIN x AS x ON x.x = x.x;
/* Test replication slot directory functions */ CREATE ROLE regress_slot_dir_funcs;
/* Not available by default. */ SELECT HAS_FUNCTION_PRIVILEGE('regress_slot_dir_funcs', 'pg_ls_logicalsnapdir()', 'EXECUTE');
SELECT HAS_FUNCTION_PRIVILEGE('regress_slot_dir_funcs', 'pg_ls_logicalmapdir()', 'EXECUTE');
SELECT HAS_FUNCTION_PRIVILEGE('regress_slot_dir_funcs', 'pg_ls_replslotdir(text)', 'EXECUTE');
GRANT pg_monitor TO regress_slot_dir_funcs;
/* Role is now part of pg_monitor, so these are available. */ SELECT HAS_FUNCTION_PRIVILEGE('regress_slot_dir_funcs', 'pg_ls_logicalsnapdir()', 'EXECUTE');
SELECT HAS_FUNCTION_PRIVILEGE('regress_slot_dir_funcs', 'pg_ls_logicalmapdir()', 'EXECUTE');
SELECT HAS_FUNCTION_PRIVILEGE('regress_slot_dir_funcs', 'pg_ls_replslotdir(text)', 'EXECUTE');
DROP ROLE regress_slot_dir_funcs;
/* Test adding a support function to a subject function */ CREATE FUNCTION my_int_eq(int, int) RETURNS bool   LANGUAGE internal STRICT IMMUTABLE PARALLEL SAFE   AS $$int4eq$$;
/* By default, planner does not think that's selective */ EXPLAIN (COSTS OFF) SELECT * FROM tenk1 a JOIN tenk1 b ON a.unique1 = b.unique1 WHERE my_int_eq(a.unique2, 42);
/* With support function that knows it's int4eq, we get a different plan */ CREATE FUNCTION test_support_func(internal)     RETURNS internal     AS :'regresslib', 'test_support_func'     LANGUAGE C STRICT;
ALTER FUNCTION my_int_eq(int, int) SUPPORT test_support_func;
EXPLAIN (COSTS OFF) SELECT * FROM tenk1 a JOIN tenk1 b ON a.unique1 = b.unique1 WHERE my_int_eq(a.unique2, 42);
/* Also test non-default rowcount estimate */ CREATE FUNCTION my_gen_series(int, int) RETURNS SETOF integer   LANGUAGE internal STRICT IMMUTABLE PARALLEL SAFE   AS $$generate_series_int4$$   SUPPORT test_support_func;
EXPLAIN (COSTS OFF) SELECT * FROM tenk1 a JOIN my_gen_series(1,1000) g ON a.unique1 = g;
EXPLAIN (COSTS OFF) SELECT * FROM tenk1 a JOIN my_gen_series(1,10) g ON a.unique1 = g;
/* Ensure the row estimate behaves correctly when step size is zero. */ /* We expect generate_series_timestamp() to throw the error rather than in */ /* the support function. */ SELECT * FROM x AS x;
/* Test functions for control data */ SELECT COUNT(*) > 0 AS x FROM x;
SELECT COUNT(*) > 0 AS x FROM x;
SELECT COUNT(*) > 0 AS x FROM x;
SELECT COUNT(*) > 0 AS x FROM x;
/* pg_split_walfile_name, pg_walfile_name & pg_walfile_name_offset */ SELECT * FROM x;
SELECT * FROM x;
SELECT x > 0 AS x, x FROM x;
SELECT x > 0 AS x, x FROM x;
SELECT x, x FROM x, x;
SELECT x, x = :segment_size - 1 FROM x, x;
/* pg_current_logfile */ CREATE ROLE regress_current_logfile;
/* not available by default */ SELECT HAS_FUNCTION_PRIVILEGE('regress_current_logfile', 'pg_current_logfile()', 'EXECUTE');
GRANT pg_monitor TO regress_current_logfile;
/* role has privileges of pg_monitor and can execute the function */ SELECT HAS_FUNCTION_PRIVILEGE('regress_current_logfile', 'pg_current_logfile()', 'EXECUTE');
DROP ROLE regress_current_logfile;
INSERT INTO x VALUES ('x', REPEAT('x', 8192));
DROP TABLE x;
DROP FUNCTION x (TEXT, BOOLEAN, BOOLEAN, BOOLEAN, BOOLEAN);
/* test stratnum support functions */ SELECT GIST_STRATNUM_COMMON(7);
SELECT GIST_STRATNUM_COMMON(3);
/* relpath tests */ CREATE FUNCTION test_relpath()     RETURNS void     AS :'regresslib'     LANGUAGE C;
SELECT TEST_RELPATH();
/* MISC_SANITY */ /* Sanity checks for common errors in making system tables that don't fit */ /* comfortably into either opr_sanity or type_sanity. */ /* Every test failure in this file should be closely inspected. */ /* The description of the failing test should be read carefully before */ /* adjusting the expected output.  In most cases, the queries should */ /* not find *any* matching entries. */ /* NB: run this test early, because some later tests create bogus entries. */ /* **************** pg_depend **************** */ /* Look for illegal values in pg_depend fields. */ SELECT * FROM x AS x WHERE x = 0 OR x = 0 OR x = 0 OR x = 0 OR NOT x IN ('a', 'e', 'i', 'n', 'x', 'P', 'S');
/* **************** pg_shdepend **************** */ /* Look for illegal values in pg_shdepend fields. */ SELECT * FROM x AS x WHERE x = 0 OR x = 0 OR x = 0 OR x = 0 OR NOT x IN ('a', 'i', 'o', 'r', 't');
/* **************** pg_class **************** */ /* Look for system tables with varlena columns but no toast table. All */ /* system tables with toastable columns should have toast tables, with */ /* the following exceptions: */ /* 1. pg_class and pg_attribute, due to fear of recursive dependencies as */ /* toast tables depend on them. */ /* 2. pg_largeobject and pg_largeobject_metadata.  Large object catalogs */ /* and toast tables are mutually exclusive and large object data is handled */ /* as user data by pg_upgrade, which would cause failures. */ /* 3. pg_authid, since its toast table cannot be accessed when it would be */ /* needed, i.e., during authentication before we've selected a database. */ SELECT x, x, CAST(x AS REGTYPE) FROM x AS x JOIN x AS x ON x.x = x WHERE x.x < 16384 AND x = 0 AND x = 'r' AND x <> 'p' ORDER BY 1 NULLS LAST, 2 NULLS LAST;
/* system catalogs without primary keys */ /* Current exceptions: */ /* * pg_depend, pg_shdepend don't have a unique key */ SELECT x FROM x WHERE x = CAST('pg_catalog' AS REGNAMESPACE) AND x = 'r' AND NOT x.x IN (SELECT x FROM x WHERE x) ORDER BY 1 NULLS LAST;
/* system catalog unique indexes not wrapped in a constraint */ /* (There should be none.) */ SELECT x FROM x AS x JOIN x AS x ON x.x = x.x WHERE x = CAST('pg_catalog' AS REGNAMESPACE) AND x = 'i' AND x.x AND NOT x.x IN (SELECT x FROM x) ORDER BY 1 NULLS LAST;
/* MONEY */ /* Note that we assume lc_monetary has been set to C. */ CREATE TABLE x (x MONEY);
INSERT INTO x VALUES ('123');
SELECT * FROM x;
SELECT x + '123' FROM x;
SELECT x + '123.45' FROM x;
SELECT x - '123.45' FROM x;
SELECT x / CAST('2' AS MONEY) FROM x;
SELECT x * 2 FROM x;
SELECT 2 * x FROM x;
SELECT x / 2 FROM x;
SELECT x * CAST(2 AS SMALLINT) FROM x;
SELECT CAST(2 AS SMALLINT) * x FROM x;
SELECT x / CAST(2 AS SMALLINT) FROM x;
SELECT x * CAST(2 AS BIGINT) FROM x;
SELECT CAST(2 AS BIGINT) * x FROM x;
SELECT x / CAST(2 AS BIGINT) FROM x;
SELECT x * CAST(2 AS DOUBLE) FROM x;
SELECT CAST(2 AS DOUBLE) * x FROM x;
SELECT x / CAST(2 AS DOUBLE) FROM x;
SELECT x * CAST(2 AS FLOAT) FROM x;
SELECT CAST(2 AS FLOAT) * x FROM x;
SELECT x / CAST(2 AS FLOAT) FROM x;
/* All true */ SELECT x = '$123.00' FROM x;
SELECT x <> '$124.00' FROM x;
SELECT x <= '$123.00' FROM x;
SELECT x >= '$123.00' FROM x;
SELECT x < '$124.00' FROM x;
SELECT x > '$122.00' FROM x;
/* All false */ SELECT x = '$123.01' FROM x;
SELECT x <> '$123.00' FROM x;
SELECT x <= '$122.99' FROM x;
SELECT x >= '$123.01' FROM x;
SELECT x > '$124.00' FROM x;
SELECT x < '$122.00' FROM x;
SELECT CASHLARGER(x, '$124.00') FROM x;
SELECT CASHSMALLER(x, '$124.00') FROM x;
SELECT CASH_WORDS(x) FROM x;
SELECT CASH_WORDS(x + '1.23') FROM x;
DELETE FROM x;
INSERT INTO x VALUES ('$123.45');
SELECT * FROM x;
DELETE FROM x;
INSERT INTO x VALUES ('$123.451');
SELECT * FROM x;
DELETE FROM x;
INSERT INTO x VALUES ('$123.454');
SELECT * FROM x;
DELETE FROM x;
INSERT INTO x VALUES ('$123.455');
SELECT * FROM x;
DELETE FROM x;
INSERT INTO x VALUES ('$123.456');
SELECT * FROM x;
DELETE FROM x;
INSERT INTO x VALUES ('$123.459');
SELECT * FROM x;
/* input checks */ SELECT CAST('1234567890' AS MONEY);
SELECT CAST('12345678901234567' AS MONEY);
SELECT CAST('123456789012345678' AS MONEY);
SELECT CAST('9223372036854775807' AS MONEY);
SELECT CAST('-12345' AS MONEY);
SELECT CAST('-1234567890' AS MONEY);
SELECT CAST('-12345678901234567' AS MONEY);
SELECT CAST('-123456789012345678' AS MONEY);
SELECT CAST('-9223372036854775808' AS MONEY);
/* special characters */ SELECT CAST('(1)' AS MONEY);
SELECT CAST('($123,456.78)' AS MONEY);
/* test non-error-throwing API */ SELECT PG_INPUT_IS_VALID('\x0001', 'money');
SELECT * FROM x;
SELECT PG_INPUT_IS_VALID('192233720368547758.07', 'money');
SELECT * FROM x;
/* documented minimums and maximums */ SELECT CAST('-92233720368547758.08' AS MONEY);
SELECT CAST('92233720368547758.07' AS MONEY);
SELECT CAST('-92233720368547758.09' AS MONEY);
SELECT CAST('92233720368547758.08' AS MONEY);
/* rounding */ SELECT CAST('-92233720368547758.085' AS MONEY);
SELECT CAST('92233720368547758.075' AS MONEY);
/* rounding vs. truncation in division */ SELECT CAST('878.08' AS MONEY) / CAST(11 AS DOUBLE);
SELECT CAST('878.08' AS MONEY) / CAST(11 AS FLOAT);
SELECT CAST('878.08' AS MONEY) / CAST(11 AS BIGINT);
SELECT CAST('878.08' AS MONEY) / CAST(11 AS INT);
SELECT CAST('878.08' AS MONEY) / CAST(11 AS SMALLINT);
/* check for precision loss in division */ SELECT CAST('90000000000000099.00' AS MONEY) / CAST(10 AS BIGINT);
SELECT CAST('90000000000000099.00' AS MONEY) / CAST(10 AS INT);
SELECT CAST('90000000000000099.00' AS MONEY) / CAST(10 AS SMALLINT);
/* Cast int4/int8/numeric to money */ SELECT CAST(1234567890 AS MONEY);
SELECT CAST(12345678901234567 AS MONEY);
SELECT CAST((-12345) AS MONEY);
SELECT CAST((-1234567890) AS MONEY);
SELECT CAST((-12345678901234567) AS MONEY);
SELECT CAST(CAST(1234567890 AS INT) AS MONEY);
SELECT CAST(CAST(12345678901234567 AS BIGINT) AS MONEY);
SELECT CAST(CAST(12345678901234567 AS DECIMAL) AS MONEY);
SELECT CAST(CAST((-1234567890) AS INT) AS MONEY);
SELECT CAST(CAST((-12345678901234567) AS BIGINT) AS MONEY);
SELECT CAST(CAST((-12345678901234567) AS DECIMAL) AS MONEY);
/* Cast from money to numeric */ SELECT CAST(CAST('12345678901234567' AS MONEY) AS DECIMAL);
SELECT CAST(CAST('-12345678901234567' AS MONEY) AS DECIMAL);
SELECT CAST(CAST('92233720368547758.07' AS MONEY) AS DECIMAL);
SELECT CAST(CAST('-92233720368547758.08' AS MONEY) AS DECIMAL);
/* overflow checks */ SELECT CAST('92233720368547758.07' AS MONEY) + CAST('0.01' AS MONEY);
SELECT CAST('-92233720368547758.08' AS MONEY) - CAST('0.01' AS MONEY);
SELECT CAST('92233720368547758.07' AS MONEY) * CAST(2 AS DOUBLE);
SELECT CAST('-1' AS MONEY) / CAST(1.175494e-38 AS FLOAT);
SELECT CAST('92233720368547758.07' AS MONEY) * CAST(2 AS INT);
SELECT CAST('1' AS MONEY) / CAST(0 AS SMALLINT);
SELECT CAST('42' AS MONEY) * CAST('inf' AS DOUBLE);
SELECT CAST('42' AS MONEY) * CAST('-inf' AS DOUBLE);
SELECT CAST('42' AS MONEY) * CAST('nan' AS FLOAT);
SELECT CAST('{,}' AS textmultirange);
SELECT CAST('{(,)}.' AS textmultirange);
SELECT CAST('{[a,c),}' AS textmultirange);
SELECT CAST('{,[a,c)}' AS textmultirange);
SELECT CAST('{-[a,z)}' AS textmultirange);
SELECT CAST('{[a,z) - }' AS textmultirange);
SELECT CAST('{(",a)}' AS textmultirange);
SELECT CAST('{(,,a)}' AS textmultirange);
SELECT CAST('{(),a)}' AS textmultirange);
SELECT CAST('{(a,))}' AS textmultirange);
SELECT CAST('{(],a)}' AS textmultirange);
SELECT CAST('{(a,])}' AS textmultirange);
SELECT CAST('{[z,a]}' AS textmultirange);
/* should succeed */ SELECT CAST('{}' AS textmultirange);
SELECT CAST('  {}  ' AS textmultirange);
SELECT CAST(' { empty, empty }  ' AS textmultirange);
SELECT CAST(' {( " a " " a ", " z " " z " )  }' AS textmultirange);
SELECT CAST(TEXTRANGE('\\\\', REPEAT('a', 200)) AS textmultirange);
SELECT CAST('{(,z)}' AS textmultirange);
SELECT CAST('{(a,)}' AS textmultirange);
SELECT CAST('{[,z]}' AS textmultirange);
SELECT CAST('{[a,]}' AS textmultirange);
SELECT CAST('{(,)}' AS textmultirange);
SELECT CAST('{[ , ]}' AS textmultirange);
SELECT CAST('{["",""]}' AS textmultirange);
SELECT CAST('{[",",","]}' AS textmultirange);
SELECT CAST('{["\\","\\"]}' AS textmultirange);
SELECT CAST('{["""","\""]}' AS textmultirange);
SELECT CAST('{(\\,a)}' AS textmultirange);
SELECT CAST('{((,z)}' AS textmultirange);
SELECT CAST('{([,z)}' AS textmultirange);
SELECT CAST('{(!,()}' AS textmultirange);
SELECT CAST('{(!,[)}' AS textmultirange);
SELECT CAST('{[a,a]}' AS textmultirange);
SELECT CAST('{[a,a],[a,b]}' AS textmultirange);
SELECT CAST('{[a,b), [b,e]}' AS textmultirange);
SELECT CAST('{[a,d), [b,f]}' AS textmultirange);
SELECT CAST('{[a,a],[b,b]}' AS textmultirange);
/* without canonicalization, we can't join these: */ SELECT CAST('{[a,a], [b,b]}' AS textmultirange);
/* with canonicalization, we can join these: */ SELECT CAST('{[1,2], [3,4]}' AS INT4MULTIRANGE);
SELECT CAST('{[a,a], [b,b], [c,c]}' AS textmultirange);
SELECT CAST('{[a,d], [b,e]}' AS textmultirange);
SELECT CAST('{[a,d), [d,e)}' AS textmultirange);
/* these are allowed but normalize to empty: */ SELECT CAST('{[a,a)}' AS textmultirange);
SELECT CAST('{(a,a]}' AS textmultirange);
SELECT CAST('{(a,a)}' AS textmultirange);
/* Also try it with non-error-throwing API */ SELECT PG_INPUT_IS_VALID('{[1,2], [4,5]}', 'int4multirange');
SELECT PG_INPUT_IS_VALID('{[1,2], [4,5]', 'int4multirange');
SELECT * FROM x;
SELECT PG_INPUT_IS_VALID('{[1,2], [4,zed]}', 'int4multirange');
SELECT * FROM x;
/* test the constructor */ /* - */ SELECT TEXTMULTIRANGE();
SELECT TEXTMULTIRANGE(TEXTRANGE('a', 'c'));
SELECT TEXTMULTIRANGE(TEXTRANGE('a', 'c'), TEXTRANGE('f', 'g'));
SELECT TEXTMULTIRANGE(TEXTRANGE('\\\\', REPEAT('a', 200)), TEXTRANGE('c', 'd'));
/* test casts, both a built-in range type and a user-defined one: */ SELECT CAST(CAST('empty' AS INT4RANGE) AS INT4MULTIRANGE);
SELECT CAST(INT4RANGE(1, 3) AS INT4MULTIRANGE);
SELECT CAST(INT4RANGE(1, NULL) AS INT4MULTIRANGE);
SELECT CAST(INT4RANGE(NULL, NULL) AS INT4MULTIRANGE);
SELECT CAST(CAST('empty' AS textrange) AS textmultirange);
SELECT CAST(TEXTRANGE('a', 'c') AS textmultirange);
SELECT CAST(TEXTRANGE('a', NULL) AS textmultirange);
SELECT CAST(TEXTRANGE(NULL, NULL) AS textmultirange);
/* test unnest(multirange) function */ SELECT EXPLODE(INT4MULTIRANGE(INT4RANGE('5', '6'), INT4RANGE('1', '2')));
SELECT EXPLODE(TEXTMULTIRANGE(TEXTRANGE('a', 'b'), TEXTRANGE('d', 'e')));
SELECT EXPLODE(TEXTMULTIRANGE(TEXTRANGE('\\\\', REPEAT('a', 200)), TEXTRANGE('c', 'd')));
/* create some test data and test the operators */ CREATE TABLE x (x NUMMULTIRANGE);
CREATE INDEX x ON x(x NULLS LAST);
INSERT INTO x VALUES ('{}');
INSERT INTO x VALUES ('{[,)}');
INSERT INTO x VALUES ('{[3,]}');
INSERT INTO x VALUES ('{[,), [3,]}');
INSERT INTO x VALUES ('{[, 5)}');
INSERT INTO x VALUES (NUMMULTIRANGE());
INSERT INTO x VALUES (NUMMULTIRANGE(NUMRANGE(1.1, 2.2)));
INSERT INTO x VALUES ('{empty}');
INSERT INTO x VALUES (NUMMULTIRANGE(NUMRANGE(1.7, 1.7, '[]'), NUMRANGE(1.7, 1.9)));
INSERT INTO x VALUES (NUMMULTIRANGE(NUMRANGE(1.7, 1.7, '[]'), NUMRANGE(1.9, 2.1)));
SELECT x, ISEMPTY(x), LOWER(x), UPPER(x) FROM x ORDER BY x NULLS LAST;
SELECT x, LOWER_INC(x), LOWER_INF(x), UPPER_INC(x), UPPER_INF(x) FROM x ORDER BY x NULLS LAST;
SELECT * FROM x WHERE x = '{}';
SELECT * FROM x WHERE x = '{(,5)}';
SELECT * FROM x WHERE x = '{[3,)}';
SELECT * FROM x WHERE x = '{[1.7,1.7]}';
SELECT * FROM x WHERE x = '{[1.7,1.7],[1.9,2.1)}';
SELECT * FROM x WHERE x < '{}';
SELECT * FROM x WHERE x < '{[-1000.0, -1000.0]}';
SELECT * FROM x WHERE x < '{[0.0, 1.0]}';
SELECT * FROM x WHERE x < '{[1000.0, 1001.0]}';
SELECT * FROM x WHERE x <= '{}';
SELECT * FROM x WHERE x <= '{[3,)}';
SELECT * FROM x WHERE x >= '{}';
SELECT * FROM x WHERE x >= '{[3,)}';
SELECT * FROM x WHERE x > '{}';
SELECT * FROM x WHERE x > '{[-1000.0, -1000.0]}';
SELECT * FROM x WHERE x > '{[0.0, 1.0]}';
SELECT * FROM x WHERE x > '{[1000.0, 1001.0]}';
SELECT * FROM x WHERE x <> '{}';
SELECT * FROM x WHERE x <> '{(,5)}';
SELECT NUMMULTIRANGE(NUMRANGE(2.0, 1.0));
SELECT NUMMULTIRANGE(NUMRANGE(5.0, 6.0), NUMRANGE(1.0, 2.0));
ANALYZE x;
/* overlaps */ SELECT * FROM x WHERE RANGE_OVERLAPS_MULTIRANGE(NUMRANGE(4.0, 4.2), x);
SELECT * FROM x WHERE NUMRANGE(4.0, 4.2) && x;
SELECT * FROM x WHERE MULTIRANGE_OVERLAPS_RANGE(x, NUMRANGE(4.0, 4.2));
SELECT * FROM x WHERE x && NUMRANGE(4.0, 4.2);
SELECT * FROM x WHERE MULTIRANGE_OVERLAPS_MULTIRANGE(x, NUMMULTIRANGE(NUMRANGE(4.0, 4.2), NUMRANGE(6.0, 7.0)));
SELECT * FROM x WHERE x && NUMMULTIRANGE(NUMRANGE(4.0, 4.2), NUMRANGE(6.0, 7.0));
SELECT * FROM x WHERE x && NUMMULTIRANGE(NUMRANGE(6.0, 7.0));
SELECT * FROM x WHERE x && NUMMULTIRANGE(NUMRANGE(6.0, 7.0), NUMRANGE(8.0, 9.0));
/* mr contains x */ SELECT * FROM x WHERE MULTIRANGE_CONTAINS_ELEM(x, 4.0);
SELECT * FROM x WHERE x @> 4.0;
SELECT * FROM x WHERE MULTIRANGE_CONTAINS_RANGE(x, NUMRANGE(4.0, 4.2));
SELECT * FROM x WHERE x @> NUMRANGE(4.0, 4.2);
SELECT * FROM x WHERE MULTIRANGE_CONTAINS_MULTIRANGE(x, '{[4.0,4.2), [6.0, 8.0)}');
SELECT * FROM x WHERE x @> CAST('{[4.0,4.2), [6.0, 8.0)}' AS NUMMULTIRANGE);
/* x is contained by mr */ SELECT * FROM x WHERE ELEM_CONTAINED_BY_MULTIRANGE(4.0, x);
SELECT * FROM x WHERE x @> 4.0;
SELECT * FROM x WHERE RANGE_CONTAINED_BY_MULTIRANGE(NUMRANGE(4.0, 4.2), x);
SELECT * FROM x WHERE x @> NUMRANGE(4.0, 4.2);
SELECT * FROM x WHERE MULTIRANGE_CONTAINED_BY_MULTIRANGE('{[4.0,4.2), [6.0, 8.0)}', x);
SELECT * FROM x WHERE x @> CAST('{[4.0,4.2), [6.0, 8.0)}' AS NUMMULTIRANGE);
/* overlaps */ SELECT CAST('empty' AS NUMRANGE) && NUMMULTIRANGE();
SELECT CAST('empty' AS NUMRANGE) && NUMMULTIRANGE(NUMRANGE(1, 2));
SELECT NUMMULTIRANGE() && CAST('empty' AS NUMRANGE);
SELECT NUMMULTIRANGE(NUMRANGE(1, 2)) && CAST('empty' AS NUMRANGE);
SELECT NUMMULTIRANGE() && NUMMULTIRANGE();
SELECT NUMMULTIRANGE() && NUMMULTIRANGE(NUMRANGE(1, 2));
SELECT NUMMULTIRANGE(NUMRANGE(1, 2)) && NUMMULTIRANGE();
SELECT NUMMULTIRANGE(NUMRANGE(3, 4)) && NUMMULTIRANGE(NUMRANGE(1, 2), NUMRANGE(7, 8));
SELECT NUMMULTIRANGE(NUMRANGE(1, 2), NUMRANGE(7, 8)) && NUMMULTIRANGE(NUMRANGE(3, 4));
SELECT NUMMULTIRANGE(NUMRANGE(3, 4)) && NUMMULTIRANGE(NUMRANGE(1, 2), NUMRANGE(3.5, 8));
SELECT NUMMULTIRANGE(NUMRANGE(1, 2), NUMRANGE(3.5, 8)) && NUMRANGE(3, 4);
SELECT NUMMULTIRANGE(NUMRANGE(1, 2), NUMRANGE(3.5, 8)) && NUMMULTIRANGE(NUMRANGE(3, 4));
SELECT CAST('{(10,20),(30,40),(50,60)}' AS NUMMULTIRANGE) && CAST('(42,92)' AS NUMRANGE);
/* contains */ SELECT NUMMULTIRANGE() @> NUMMULTIRANGE();
SELECT NUMMULTIRANGE() @> CAST('empty' AS NUMRANGE);
SELECT NUMMULTIRANGE(NUMRANGE(NULL, NULL)) @> NUMRANGE(1, 2);
SELECT NUMMULTIRANGE(NUMRANGE(NULL, NULL)) @> NUMRANGE(NULL, 2);
SELECT NUMMULTIRANGE(NUMRANGE(NULL, NULL)) @> NUMRANGE(2, NULL);
SELECT NUMMULTIRANGE(NUMRANGE(NULL, 5)) @> NUMRANGE(NULL, 3);
SELECT NUMMULTIRANGE(NUMRANGE(NULL, 5)) @> NUMRANGE(NULL, 8);
SELECT NUMMULTIRANGE(NUMRANGE(5, NULL)) @> NUMRANGE(8, NULL);
SELECT NUMMULTIRANGE(NUMRANGE(5, NULL)) @> NUMRANGE(3, NULL);
SELECT NUMMULTIRANGE(NUMRANGE(1, 5)) @> NUMRANGE(8, 9);
SELECT NUMMULTIRANGE(NUMRANGE(1, 5)) @> NUMRANGE(3, 9);
SELECT NUMMULTIRANGE(NUMRANGE(1, 5)) @> NUMRANGE(1, 4);
SELECT NUMMULTIRANGE(NUMRANGE(1, 5)) @> NUMRANGE(1, 5);
SELECT NUMMULTIRANGE(NUMRANGE(-4, -2), NUMRANGE(1, 5)) @> NUMRANGE(1, 5);
SELECT NUMMULTIRANGE(NUMRANGE(1, 5), NUMRANGE(8, 9)) @> NUMRANGE(1, 5);
SELECT NUMMULTIRANGE(NUMRANGE(1, 5), NUMRANGE(8, 9)) @> NUMRANGE(6, 7);
SELECT NUMMULTIRANGE(NUMRANGE(1, 5), NUMRANGE(6, 9)) @> NUMRANGE(6, 7);
SELECT CAST('{[1,5)}' AS NUMMULTIRANGE) @> '{[1,5)}';
SELECT CAST('{[-4,-2), [1,5)}' AS NUMMULTIRANGE) @> '{[1,5)}';
SELECT CAST('{[1,5), [8,9)}' AS NUMMULTIRANGE) @> '{[1,5)}';
SELECT CAST('{[1,5), [8,9)}' AS NUMMULTIRANGE) @> '{[6,7)}';
SELECT CAST('{[1,5), [6,9)}' AS NUMMULTIRANGE) @> '{[6,7)}';
SELECT CAST('{(10,20),(30,40),(50,60)}' AS NUMMULTIRANGE) @> CAST('(52,56)' AS NUMRANGE);
SELECT NUMRANGE(NULL, NULL) @> NUMMULTIRANGE(NUMRANGE(1, 2));
SELECT NUMRANGE(NULL, NULL) @> NUMMULTIRANGE(NUMRANGE(NULL, 2));
SELECT NUMRANGE(NULL, NULL) @> NUMMULTIRANGE(NUMRANGE(2, NULL));
SELECT NUMRANGE(NULL, 5) @> NUMMULTIRANGE(NUMRANGE(NULL, 3));
SELECT NUMRANGE(NULL, 5) @> NUMMULTIRANGE(NUMRANGE(NULL, 8));
SELECT NUMRANGE(5, NULL) @> NUMMULTIRANGE(NUMRANGE(8, NULL));
SELECT NUMRANGE(5, NULL) @> NUMMULTIRANGE(NUMRANGE(3, NULL));
SELECT NUMRANGE(1, 5) @> NUMMULTIRANGE(NUMRANGE(8, 9));
SELECT NUMRANGE(1, 5) @> NUMMULTIRANGE(NUMRANGE(3, 9));
SELECT NUMRANGE(1, 5) @> NUMMULTIRANGE(NUMRANGE(1, 4));
SELECT NUMRANGE(1, 5) @> NUMMULTIRANGE(NUMRANGE(1, 5));
SELECT NUMRANGE(1, 9) @> NUMMULTIRANGE(NUMRANGE(-4, -2), NUMRANGE(1, 5));
SELECT NUMRANGE(1, 9) @> NUMMULTIRANGE(NUMRANGE(1, 5), NUMRANGE(8, 9));
SELECT NUMRANGE(1, 9) @> NUMMULTIRANGE(NUMRANGE(1, 5), NUMRANGE(6, 9));
SELECT NUMRANGE(1, 9) @> NUMMULTIRANGE(NUMRANGE(1, 5), NUMRANGE(6, 10));
SELECT '{[1,9)}' @> CAST('{[1,5)}' AS NUMMULTIRANGE);
SELECT '{[1,9)}' @> CAST('{[-4,-2), [1,5)}' AS NUMMULTIRANGE);
SELECT '{[1,9)}' @> CAST('{[1,5), [8,9)}' AS NUMMULTIRANGE);
SELECT '{[1,9)}' @> CAST('{[1,5), [6,9)}' AS NUMMULTIRANGE);
SELECT '{[1,9)}' @> CAST('{[1,5), [6,10)}' AS NUMMULTIRANGE);
/* is contained by */ SELECT NUMMULTIRANGE() @> NUMMULTIRANGE();
SELECT NUMMULTIRANGE() @> CAST('empty' AS NUMRANGE);
SELECT NUMMULTIRANGE(NUMRANGE(NULL, NULL)) @> NUMRANGE(1, 2);
SELECT NUMMULTIRANGE(NUMRANGE(NULL, NULL)) @> NUMRANGE(NULL, 2);
SELECT NUMMULTIRANGE(NUMRANGE(NULL, NULL)) @> NUMRANGE(2, NULL);
SELECT NUMMULTIRANGE(NUMRANGE(NULL, 5)) @> NUMRANGE(NULL, 3);
SELECT NUMMULTIRANGE(NUMRANGE(NULL, 5)) @> NUMRANGE(NULL, 8);
SELECT NUMMULTIRANGE(NUMRANGE(5, NULL)) @> NUMRANGE(8, NULL);
SELECT NUMMULTIRANGE(NUMRANGE(5, NULL)) @> NUMRANGE(3, NULL);
SELECT NUMMULTIRANGE(NUMRANGE(1, 5)) @> NUMRANGE(8, 9);
SELECT NUMMULTIRANGE(NUMRANGE(1, 5)) @> NUMRANGE(3, 9);
SELECT NUMMULTIRANGE(NUMRANGE(1, 5)) @> NUMRANGE(1, 4);
SELECT NUMMULTIRANGE(NUMRANGE(1, 5)) @> NUMRANGE(1, 5);
SELECT NUMMULTIRANGE(NUMRANGE(-4, -2), NUMRANGE(1, 5)) @> NUMRANGE(1, 5);
SELECT NUMMULTIRANGE(NUMRANGE(1, 5), NUMRANGE(8, 9)) @> NUMRANGE(1, 5);
SELECT NUMMULTIRANGE(NUMRANGE(1, 5), NUMRANGE(8, 9)) @> NUMRANGE(6, 7);
SELECT NUMMULTIRANGE(NUMRANGE(1, 5), NUMRANGE(6, 9)) @> NUMRANGE(6, 7);
SELECT CAST('{[1,5)}' AS NUMMULTIRANGE) @> '{[1,5)}';
SELECT CAST('{[-4,-2), [1,5)}' AS NUMMULTIRANGE) @> '{[1,5)}';
SELECT CAST('{[1,5), [8,9)}' AS NUMMULTIRANGE) @> '{[1,5)}';
SELECT CAST('{[1,5), [8,9)}' AS NUMMULTIRANGE) @> '{[6,7)}';
SELECT CAST('{[1,5), [6,9)}' AS NUMMULTIRANGE) @> '{[6,7)}';
SELECT NUMRANGE(NULL, NULL) @> NUMMULTIRANGE(NUMRANGE(1, 2));
SELECT NUMRANGE(NULL, NULL) @> NUMMULTIRANGE(NUMRANGE(NULL, 2));
SELECT NUMRANGE(NULL, NULL) @> NUMMULTIRANGE(NUMRANGE(2, NULL));
SELECT NUMRANGE(NULL, 5) @> NUMMULTIRANGE(NUMRANGE(NULL, 3));
SELECT NUMRANGE(NULL, 5) @> NUMMULTIRANGE(NUMRANGE(NULL, 8));
SELECT NUMRANGE(5, NULL) @> NUMMULTIRANGE(NUMRANGE(8, NULL));
SELECT NUMRANGE(5, NULL) @> NUMMULTIRANGE(NUMRANGE(3, NULL));
SELECT NUMRANGE(1, 5) @> NUMMULTIRANGE(NUMRANGE(8, 9));
SELECT NUMRANGE(1, 5) @> NUMMULTIRANGE(NUMRANGE(3, 9));
SELECT NUMRANGE(1, 5) @> NUMMULTIRANGE(NUMRANGE(1, 4));
SELECT NUMRANGE(1, 5) @> NUMMULTIRANGE(NUMRANGE(1, 5));
SELECT NUMRANGE(1, 9) @> NUMMULTIRANGE(NUMRANGE(-4, -2), NUMRANGE(1, 5));
SELECT NUMRANGE(1, 9) @> NUMMULTIRANGE(NUMRANGE(1, 5), NUMRANGE(8, 9));
SELECT NUMRANGE(1, 9) @> NUMMULTIRANGE(NUMRANGE(1, 5), NUMRANGE(6, 9));
SELECT NUMRANGE(1, 9) @> NUMMULTIRANGE(NUMRANGE(1, 5), NUMRANGE(6, 10));
SELECT '{[1,9)}' @> CAST('{[1,5)}' AS NUMMULTIRANGE);
SELECT '{[1,9)}' @> CAST('{[-4,-2), [1,5)}' AS NUMMULTIRANGE);
SELECT '{[1,9)}' @> CAST('{[1,5), [8,9)}' AS NUMMULTIRANGE);
SELECT '{[1,9)}' @> CAST('{[1,5), [6,9)}' AS NUMMULTIRANGE);
SELECT '{[1,9)}' @> CAST('{[1,5), [6,10)}' AS NUMMULTIRANGE);
/* strictly left */ SELECT CAST('empty' AS NUMRANGE) << NUMMULTIRANGE();
SELECT NUMRANGE(1, 2) << NUMMULTIRANGE();
SELECT NUMRANGE(1, 2) << NUMMULTIRANGE(NUMRANGE(3, 4));
SELECT NUMRANGE(1, 2) << NUMMULTIRANGE(NUMRANGE(0, 4));
SELECT NUMRANGE(1, 2) << NUMMULTIRANGE(NUMRANGE(0, 4), NUMRANGE(7, 8));
SELECT NUMMULTIRANGE() << CAST('empty' AS NUMRANGE);
SELECT NUMMULTIRANGE() << NUMRANGE(1, 2);
SELECT NUMMULTIRANGE(NUMRANGE(3, 4)) << NUMRANGE(3, 6);
SELECT NUMMULTIRANGE(NUMRANGE(0, 2)) << NUMRANGE(3, 6);
SELECT NUMMULTIRANGE(NUMRANGE(0, 2), NUMRANGE(7, 8)) << NUMRANGE(3, 6);
SELECT NUMMULTIRANGE(NUMRANGE(-4, -2), NUMRANGE(0, 2)) << NUMRANGE(3, 6);
SELECT NUMMULTIRANGE() << NUMMULTIRANGE();
SELECT NUMMULTIRANGE() << NUMMULTIRANGE(NUMRANGE(1, 2));
SELECT NUMMULTIRANGE(NUMRANGE(1, 2)) << NUMMULTIRANGE();
SELECT NUMMULTIRANGE(NUMRANGE(1, 2)) << NUMMULTIRANGE(NUMRANGE(1, 2));
SELECT NUMMULTIRANGE(NUMRANGE(1, 2)) << NUMMULTIRANGE(NUMRANGE(3, 4));
SELECT NUMMULTIRANGE(NUMRANGE(1, 2)) << NUMMULTIRANGE(NUMRANGE(3, 4), NUMRANGE(7, 8));
SELECT NUMMULTIRANGE(NUMRANGE(1, 2), NUMRANGE(4, 5)) << NUMMULTIRANGE(NUMRANGE(3, 4), NUMRANGE(7, 8));
/* strictly right */ SELECT NUMMULTIRANGE() >> CAST('empty' AS NUMRANGE);
SELECT NUMMULTIRANGE() >> NUMRANGE(1, 2);
SELECT NUMMULTIRANGE(NUMRANGE(3, 4)) >> NUMRANGE(1, 2);
SELECT NUMMULTIRANGE(NUMRANGE(0, 4)) >> NUMRANGE(1, 2);
SELECT NUMMULTIRANGE(NUMRANGE(0, 4), NUMRANGE(7, 8)) >> NUMRANGE(1, 2);
SELECT CAST('empty' AS NUMRANGE) >> NUMMULTIRANGE();
SELECT NUMRANGE(1, 2) >> NUMMULTIRANGE();
SELECT NUMRANGE(3, 6) >> NUMMULTIRANGE(NUMRANGE(3, 4));
SELECT NUMRANGE(3, 6) >> NUMMULTIRANGE(NUMRANGE(0, 2));
SELECT NUMRANGE(3, 6) >> NUMMULTIRANGE(NUMRANGE(0, 2), NUMRANGE(7, 8));
SELECT NUMRANGE(3, 6) >> NUMMULTIRANGE(NUMRANGE(-4, -2), NUMRANGE(0, 2));
SELECT NUMMULTIRANGE() >> NUMMULTIRANGE();
SELECT NUMMULTIRANGE(NUMRANGE(1, 2)) >> NUMMULTIRANGE();
SELECT NUMMULTIRANGE() >> NUMMULTIRANGE(NUMRANGE(1, 2));
SELECT NUMMULTIRANGE(NUMRANGE(1, 2)) >> NUMMULTIRANGE(NUMRANGE(1, 2));
SELECT NUMMULTIRANGE(NUMRANGE(3, 4)) >> NUMMULTIRANGE(NUMRANGE(1, 2));
SELECT NUMMULTIRANGE(NUMRANGE(3, 4), NUMRANGE(7, 8)) >> NUMMULTIRANGE(NUMRANGE(1, 2));
SELECT NUMMULTIRANGE(NUMRANGE(3, 4), NUMRANGE(7, 8)) >> NUMMULTIRANGE(NUMRANGE(1, 2), NUMRANGE(4, 5));
/* union */ SELECT NUMMULTIRANGE() + NUMMULTIRANGE();
SELECT NUMMULTIRANGE() + NUMMULTIRANGE(NUMRANGE(1, 2));
SELECT NUMMULTIRANGE(NUMRANGE(1, 2)) + NUMMULTIRANGE();
SELECT NUMMULTIRANGE(NUMRANGE(1, 2)) + NUMMULTIRANGE(NUMRANGE(1, 2));
SELECT NUMMULTIRANGE(NUMRANGE(1, 2)) + NUMMULTIRANGE(NUMRANGE(2, 4));
SELECT NUMMULTIRANGE(NUMRANGE(1, 2)) + NUMMULTIRANGE(NUMRANGE(3, 4));
SELECT NUMMULTIRANGE(NUMRANGE(1, 2), NUMRANGE(4, 5)) + NUMMULTIRANGE(NUMRANGE(2, 4));
SELECT NUMMULTIRANGE(NUMRANGE(1, 2), NUMRANGE(4, 5)) + NUMMULTIRANGE(NUMRANGE(3, 4));
SELECT NUMMULTIRANGE(NUMRANGE(1, 2), NUMRANGE(4, 5)) + NUMMULTIRANGE(NUMRANGE(0, 9));
/* merge */ SELECT RANGE_MERGE(NUMMULTIRANGE());
SELECT RANGE_MERGE(NUMMULTIRANGE(NUMRANGE(1, 2)));
SELECT RANGE_MERGE(NUMMULTIRANGE(NUMRANGE(1, 2), NUMRANGE(7, 8)));
/* minus */ SELECT NUMMULTIRANGE() - NUMMULTIRANGE();
SELECT NUMMULTIRANGE() - NUMMULTIRANGE(NUMRANGE(1, 2));
SELECT NUMMULTIRANGE(NUMRANGE(1, 2)) - NUMMULTIRANGE();
SELECT NUMMULTIRANGE(NUMRANGE(1, 2), NUMRANGE(3, 4)) - NUMMULTIRANGE();
SELECT NUMMULTIRANGE(NUMRANGE(1, 2)) - NUMMULTIRANGE(NUMRANGE(1, 2));
SELECT NUMMULTIRANGE(NUMRANGE(1, 2)) - NUMMULTIRANGE(NUMRANGE(2, 4));
SELECT NUMMULTIRANGE(NUMRANGE(1, 2)) - NUMMULTIRANGE(NUMRANGE(3, 4));
SELECT NUMMULTIRANGE(NUMRANGE(1, 4)) - NUMMULTIRANGE(NUMRANGE(1, 2));
SELECT NUMMULTIRANGE(NUMRANGE(1, 4)) - NUMMULTIRANGE(NUMRANGE(2, 3));
SELECT NUMMULTIRANGE(NUMRANGE(1, 4)) - NUMMULTIRANGE(NUMRANGE(0, 8));
SELECT NUMMULTIRANGE(NUMRANGE(1, 4)) - NUMMULTIRANGE(NUMRANGE(0, 2));
SELECT NUMMULTIRANGE(NUMRANGE(1, 8)) - NUMMULTIRANGE(NUMRANGE(0, 2), NUMRANGE(3, 4));
SELECT NUMMULTIRANGE(NUMRANGE(1, 8)) - NUMMULTIRANGE(NUMRANGE(2, 3), NUMRANGE(5, NULL));
SELECT NUMMULTIRANGE(NUMRANGE(1, 2), NUMRANGE(4, 5)) - NUMMULTIRANGE(NUMRANGE(-2, 0));
SELECT NUMMULTIRANGE(NUMRANGE(1, 2), NUMRANGE(4, 5)) - NUMMULTIRANGE(NUMRANGE(2, 4));
SELECT NUMMULTIRANGE(NUMRANGE(1, 2), NUMRANGE(4, 5)) - NUMMULTIRANGE(NUMRANGE(3, 5));
SELECT NUMMULTIRANGE(NUMRANGE(1, 2), NUMRANGE(4, 5)) - NUMMULTIRANGE(NUMRANGE(0, 9));
SELECT NUMMULTIRANGE(NUMRANGE(1, 3), NUMRANGE(4, 5)) - NUMMULTIRANGE(NUMRANGE(2, 9));
SELECT NUMMULTIRANGE(NUMRANGE(1, 2), NUMRANGE(4, 5)) - NUMMULTIRANGE(NUMRANGE(8, 9));
SELECT NUMMULTIRANGE(NUMRANGE(1, 2), NUMRANGE(4, 5)) - NUMMULTIRANGE(NUMRANGE(-2, 0), NUMRANGE(8, 9));
/* intersection */ SELECT NUMMULTIRANGE() * NUMMULTIRANGE();
SELECT NUMMULTIRANGE() * NUMMULTIRANGE(NUMRANGE(1, 2));
SELECT NUMMULTIRANGE(NUMRANGE(1, 2)) * NUMMULTIRANGE();
SELECT CAST('{[1,3)}' AS NUMMULTIRANGE) * CAST('{[1,5)}' AS NUMMULTIRANGE);
SELECT CAST('{[1,3)}' AS NUMMULTIRANGE) * CAST('{[0,5)}' AS NUMMULTIRANGE);
SELECT CAST('{[1,3)}' AS NUMMULTIRANGE) * CAST('{[0,2)}' AS NUMMULTIRANGE);
SELECT CAST('{[1,3)}' AS NUMMULTIRANGE) * CAST('{[2,5)}' AS NUMMULTIRANGE);
SELECT CAST('{[1,4)}' AS NUMMULTIRANGE) * CAST('{[2,3)}' AS NUMMULTIRANGE);
SELECT CAST('{[1,4)}' AS NUMMULTIRANGE) * CAST('{[0,2), [3,5)}' AS NUMMULTIRANGE);
SELECT CAST('{[1,4), [7,10)}' AS NUMMULTIRANGE) * CAST('{[0,8), [9,12)}' AS NUMMULTIRANGE);
SELECT CAST('{[1,4), [7,10)}' AS NUMMULTIRANGE) * CAST('{[9,12)}' AS NUMMULTIRANGE);
SELECT CAST('{[1,4), [7,10)}' AS NUMMULTIRANGE) * CAST('{[-5,-4), [5,6), [9,12)}' AS NUMMULTIRANGE);
SELECT CAST('{[1,4), [7,10)}' AS NUMMULTIRANGE) * CAST('{[0,2), [3,8), [9,12)}' AS NUMMULTIRANGE);
SELECT CAST('{[1,4), [7,10)}' AS NUMMULTIRANGE) * CAST('{[0,2), [3,8), [9,12)}' AS NUMMULTIRANGE);
/* test GiST index */ CREATE TABLE x (x INT4MULTIRANGE);
INSERT INTO x SELECT INT4MULTIRANGE(INT4RANGE(x, x + 10), INT4RANGE(x + 20, x + 30), INT4RANGE(x + 40, x + 50)) FROM x AS x;
INSERT INTO x SELECT CAST('{}' AS INT4MULTIRANGE) FROM x AS x;
INSERT INTO x SELECT INT4MULTIRANGE(INT4RANGE(x, x + 10000)) FROM x AS x;
INSERT INTO x SELECT INT4MULTIRANGE(INT4RANGE(NULL, x * 10, '(]'), INT4RANGE(x * 10, x * 20, '(]')) FROM x AS x;
INSERT INTO x SELECT INT4MULTIRANGE(INT4RANGE(x * 10, x * 20, '(]'), INT4RANGE(x * 20, NULL, '(]')) FROM x AS x;
CREATE INDEX x ON x USING gist(x NULLS LAST);
ANALYZE x /* test statistics and selectivity estimation as well */ /* We don't check the accuracy of selectivity estimation, but at least check */ /* it doesn't fall. */;
SET x = t /* first, verify non-indexed results */;
SET x = f;
SET x = f;
SELECT COUNT(*) FROM x WHERE x = CAST('{}' AS INT4MULTIRANGE);
SELECT COUNT(*) FROM x WHERE x @> CAST('empty' AS INT4RANGE);
SELECT COUNT(*) FROM x WHERE x && CAST('empty' AS INT4RANGE);
SELECT COUNT(*) FROM x WHERE CAST('empty' AS INT4RANGE) @> x;
SELECT COUNT(*) FROM x WHERE x << CAST('empty' AS INT4RANGE);
SELECT COUNT(*) FROM x WHERE x >> CAST('empty' AS INT4RANGE);
SELECT COUNT(*) FROM x WHERE x @> CAST('{}' AS INT4MULTIRANGE);
SELECT COUNT(*) FROM x WHERE x @> CAST('{}' AS INT4MULTIRANGE);
SELECT COUNT(*) FROM x WHERE x && CAST('{}' AS INT4MULTIRANGE);
SELECT COUNT(*) FROM x WHERE CAST('{}' AS INT4MULTIRANGE) @> x;
SELECT COUNT(*) FROM x WHERE x << CAST('{}' AS INT4MULTIRANGE);
SELECT COUNT(*) FROM x WHERE x >> CAST('{}' AS INT4MULTIRANGE);
SELECT COUNT(*) FROM x WHERE x = INT4MULTIRANGE(INT4RANGE(10, 20), INT4RANGE(30, 40), INT4RANGE(50, 60));
SELECT COUNT(*) FROM x WHERE x @> 10;
SELECT COUNT(*) FROM x WHERE x @> INT4RANGE(10, 20);
SELECT COUNT(*) FROM x WHERE x && INT4RANGE(10, 20);
SELECT COUNT(*) FROM x WHERE INT4RANGE(10, 50) @> x;
SELECT COUNT(*) FROM x WHERE x << INT4RANGE(100, 500);
SELECT COUNT(*) FROM x WHERE x >> INT4RANGE(100, 500);
SELECT COUNT(*) FROM x WHERE x @> CAST('{}' AS INT4MULTIRANGE);
SELECT COUNT(*) FROM x WHERE x @> INT4MULTIRANGE(INT4RANGE(10, 20), INT4RANGE(30, 40));
SELECT COUNT(*) FROM x WHERE x && CAST('{(10,20),(30,40),(50,60)}' AS INT4MULTIRANGE);
SELECT COUNT(*) FROM x WHERE CAST('{(10,30),(40,60),(70,90)}' AS INT4MULTIRANGE) @> x;
SELECT COUNT(*) FROM x WHERE x << INT4MULTIRANGE(INT4RANGE(100, 200), INT4RANGE(400, 500));
SELECT COUNT(*) FROM x WHERE x >> INT4MULTIRANGE(INT4RANGE(100, 200), INT4RANGE(400, 500));
SET x = f /* now check same queries using index */;
SET x = t;
SET x = f;
SELECT COUNT(*) FROM x WHERE x = CAST('{}' AS INT4MULTIRANGE);
SELECT COUNT(*) FROM x WHERE x @> CAST('empty' AS INT4RANGE);
SELECT COUNT(*) FROM x WHERE x && CAST('empty' AS INT4RANGE);
SELECT COUNT(*) FROM x WHERE CAST('empty' AS INT4RANGE) @> x;
SELECT COUNT(*) FROM x WHERE x << CAST('empty' AS INT4RANGE);
SELECT COUNT(*) FROM x WHERE x >> CAST('empty' AS INT4RANGE);
SELECT COUNT(*) FROM x WHERE x @> CAST('{}' AS INT4MULTIRANGE);
SELECT COUNT(*) FROM x WHERE x @> CAST('{}' AS INT4MULTIRANGE);
SELECT COUNT(*) FROM x WHERE x && CAST('{}' AS INT4MULTIRANGE);
SELECT COUNT(*) FROM x WHERE CAST('{}' AS INT4MULTIRANGE) @> x;
SELECT COUNT(*) FROM x WHERE x << CAST('{}' AS INT4MULTIRANGE);
SELECT COUNT(*) FROM x WHERE x >> CAST('{}' AS INT4MULTIRANGE);
SELECT COUNT(*) FROM x WHERE x @> CAST('empty' AS INT4RANGE);
SELECT COUNT(*) FROM x WHERE x = INT4MULTIRANGE(INT4RANGE(10, 20), INT4RANGE(30, 40), INT4RANGE(50, 60));
SELECT COUNT(*) FROM x WHERE x @> 10;
SELECT COUNT(*) FROM x WHERE x @> INT4RANGE(10, 20);
SELECT COUNT(*) FROM x WHERE x && INT4RANGE(10, 20);
SELECT COUNT(*) FROM x WHERE INT4RANGE(10, 50) @> x;
SELECT COUNT(*) FROM x WHERE x << INT4RANGE(100, 500);
SELECT COUNT(*) FROM x WHERE x >> INT4RANGE(100, 500);
SELECT COUNT(*) FROM x WHERE x @> CAST('{}' AS INT4MULTIRANGE);
SELECT COUNT(*) FROM x WHERE x @> INT4MULTIRANGE(INT4RANGE(10, 20), INT4RANGE(30, 40));
SELECT COUNT(*) FROM x WHERE x && CAST('{(10,20),(30,40),(50,60)}' AS INT4MULTIRANGE);
SELECT COUNT(*) FROM x WHERE CAST('{(10,30),(40,60),(70,90)}' AS INT4MULTIRANGE) @> x;
SELECT COUNT(*) FROM x WHERE x << INT4MULTIRANGE(INT4RANGE(100, 200), INT4RANGE(400, 500));
SELECT COUNT(*) FROM x WHERE x >> INT4MULTIRANGE(INT4RANGE(100, 200), INT4RANGE(400, 500));
DROP TABLE x;
/* range_agg function */ CREATE TABLE x (x INT NOT NULL, x DATERANGE);
INSERT INTO x VALUES (1, DATERANGE('2018-07-01', '2018-07-07')), (1, DATERANGE('2018-07-07', '2018-07-14')), (1, DATERANGE('2018-07-20', '2018-07-22')), (2, DATERANGE('2018-07-01', '2018-07-03')), (3, NULL), (4, NULL), (4, NULL), (5, NULL), (5, DATERANGE('2018-07-01', '2018-07-03')), (6, DATERANGE('2018-07-01', '2018-07-07')), (6, DATERANGE('2018-07-05', '2018-07-10')), (7, DATERANGE('2018-07-01', '2018-07-07')), (7, DATERANGE('2018-07-07', '2018-07-14')), (8, CAST('empty' AS DATERANGE));
SELECT x, RANGE_AGG(x) FROM x GROUP BY x ORDER BY x NULLS LAST;
/* range_agg on a custom range type too */ SELECT RANGE_AGG(x) FROM (VALUES (CAST('[a,c]' AS textrange)), (CAST('[b,b]' AS textrange)), (CAST('[c,f]' AS textrange)), (CAST('[g,h)' AS textrange)), (CAST('[h,j)' AS textrange))) AS x;
/* range_agg with multirange inputs */ SELECT RANGE_AGG(x) FROM x;
SELECT RANGE_AGG(x) FROM x WHERE FALSE;
SELECT RANGE_AGG(CAST(NULL AS NUMMULTIRANGE)) FROM x;
SELECT RANGE_AGG(x) FROM (VALUES (CAST('{}' AS NUMMULTIRANGE))) AS x;
SELECT RANGE_AGG(x) FROM (VALUES (CAST('{}' AS NUMMULTIRANGE)), (CAST('{}' AS NUMMULTIRANGE))) AS x;
SELECT RANGE_AGG(x) FROM (VALUES (CAST('{[1,2]}' AS NUMMULTIRANGE))) AS x;
SELECT RANGE_AGG(x) FROM (VALUES (CAST('{[1,2], [5,6]}' AS NUMMULTIRANGE))) AS x;
SELECT RANGE_AGG(x) FROM (VALUES (CAST('{[1,2], [2,3]}' AS NUMMULTIRANGE))) AS x;
SELECT RANGE_AGG(x) FROM (VALUES (CAST('{[1,2]}' AS NUMMULTIRANGE)), (CAST('{[5,6]}' AS NUMMULTIRANGE))) AS x;
SELECT RANGE_AGG(x) FROM (VALUES (CAST('{[1,2]}' AS NUMMULTIRANGE)), (CAST('{[2,3]}' AS NUMMULTIRANGE))) AS x;
/* range_intersect_agg function */ SELECT RANGE_INTERSECT_AGG(x) FROM x;
SELECT RANGE_INTERSECT_AGG(x) FROM x WHERE FALSE;
SELECT RANGE_INTERSECT_AGG(CAST(NULL AS NUMMULTIRANGE)) FROM x;
SELECT RANGE_INTERSECT_AGG(x) FROM (VALUES (CAST('{[1,3]}' AS NUMMULTIRANGE)), (CAST('{[6,12]}' AS NUMMULTIRANGE))) AS x;
SELECT RANGE_INTERSECT_AGG(x) FROM (VALUES (CAST('{[1,6]}' AS NUMMULTIRANGE)), (CAST('{[3,12]}' AS NUMMULTIRANGE))) AS x;
SELECT RANGE_INTERSECT_AGG(x) FROM (VALUES (CAST('{[1,6], [10,12]}' AS NUMMULTIRANGE)), (CAST('{[4,14]}' AS NUMMULTIRANGE))) AS x;
/* test with just one input: */ SELECT RANGE_INTERSECT_AGG(x) FROM (VALUES (CAST('{}' AS NUMMULTIRANGE))) AS x;
SELECT RANGE_INTERSECT_AGG(x) FROM (VALUES (CAST('{[1,2]}' AS NUMMULTIRANGE))) AS x;
SELECT RANGE_INTERSECT_AGG(x) FROM (VALUES (CAST('{[1,6], [10,12]}' AS NUMMULTIRANGE))) AS x;
SELECT RANGE_INTERSECT_AGG(x) FROM x WHERE x @> 4.0;
CREATE TABLE x (x NUMMULTIRANGE);
CREATE INDEX x ON x USING hash(x NULLS LAST);
INSERT INTO x VALUES ('{[, 5)}');
INSERT INTO x VALUES (NUMMULTIRANGE(NUMRANGE(1.1, 2.2)));
INSERT INTO x VALUES (NUMMULTIRANGE(NUMRANGE(1.1, 2.2)));
INSERT INTO x VALUES (NUMMULTIRANGE(NUMRANGE(1.1, 2.2, '()')));
INSERT INTO x VALUES ('{}');
SELECT * FROM x WHERE x = '{}';
SELECT * FROM x WHERE x = NUMMULTIRANGE(NUMRANGE(1.1, 2.2));
SELECT * FROM x WHERE x = NUMMULTIRANGE(NUMRANGE(1.1, 2.3));
SET x = t;
SET x = f;
SET x = f;
SELECT * FROM x NATURAL JOIN x ORDER BY x NULLS LAST;
SET x = f;
SET x = t;
SET x = f;
SELECT * FROM x NATURAL JOIN x ORDER BY x NULLS LAST;
SET x = f;
SET x = f;
SET x = t;
SELECT * FROM x NATURAL JOIN x ORDER BY x NULLS LAST;
SET x = default;
SET x = default;
SET x = default;
DROP TABLE x;
/* Test user-defined multirange of floats */ SELECT CAST('{[123.001, 5.e9)}' AS float8multirange) @> CAST(888.882 AS DOUBLE);
CREATE TABLE x (x float8multirange, x INT);
INSERT INTO x VALUES (FLOAT8MULTIRANGE(FLOAT8RANGE(-100.00007, '1.111113e9')), 42);
SELECT * FROM x;
DROP TABLE x;
/* Test multirange types over domains */ create domain mydomain as int4;
create type mydomainrange as range(subtype=mydomain);
SELECT CAST('{[4,50)}' AS mydomainmultirange) @> CAST(7 AS mydomain);
drop domain mydomain cascade;
/* Test domains over multirange types */ create domain restrictedmultirange as int4multirange check (upper(value) < 10);
SELECT CAST('{[4,5)}' AS restrictedmultirange) @> 7;
SELECT CAST('{[4,50)}' AS restrictedmultirange) @> 7;
/* should fail */ drop domain restrictedmultirange;
/* - */ /* Check automatic naming of multiranges */ /* - */ create type intr as range(subtype=int);
SELECT INTR_MULTIRANGE(INTR(1, 10));
drop type intr;
create type intmultirange as (x int, y int);
create type intrange as range(subtype=int);
/* should fail */ drop type intmultirange;
create type intr_multirange as (x int, y int);
create type intr as range(subtype=int);
/* should fail */ drop type intr_multirange;
/* Test multiple multirange types over the same subtype and manual naming of */ /* the multirange type. */ /* should fail */ create type textrange1 as range(subtype=text, multirange_type_name=int, collation="C");
/* should pass */ create type textrange1 as range(subtype=text, multirange_type_name=multirange_of_text, collation="C");
/* should pass, because existing _textrange1 is automatically renamed */ create type textrange2 as range(subtype=text, multirange_type_name=_textrange1, collation="C");
SELECT MULTIRANGE_OF_TEXT(TEXTRANGE2('a', 'Z'));
/* should fail */ SELECT MULTIRANGE_OF_TEXT(TEXTRANGE1('a', 'Z')) @> CAST('b' AS TEXT);
SELECT EXPLODE(MULTIRANGE_OF_TEXT(TEXTRANGE1('a', 'b'), TEXTRANGE1('d', 'e')));
SELECT _TEXTRANGE1(TEXTRANGE2('a', 'z')) @> CAST('b' AS TEXT);
drop type textrange1;
drop type textrange2;
/* Multiranges don't have their own ownership or permissions. */ create type textrange1 as range(subtype=text, multirange_type_name=multitextrange1, collation="C");
create role regress_multirange_owner;
alter type multitextrange1 owner to regress_multirange_owner;
/* fail */ alter type textrange1 owner to regress_multirange_owner;
set role regress_multirange_owner;
REVOKE usage on type multitextrange1 from public;
/* fail */ REVOKE usage on type textrange1 from public;
REVOKE usage on type textrange1 from regress_multirange_owner;
CREATE TEMPORARY TABLE x (x ARRAY<multitextrange1>);
/* fail */ DROP TABLE x;
drop type textrange1;
RESET role;
drop role regress_multirange_owner;
SELECT ANYARRAY_ANYMULTIRANGE_FUNC(ARRAY(1, 2), INT4MULTIRANGE(INT4RANGE(10, 20)));
/* should fail */ SELECT ANYARRAY_ANYMULTIRANGE_FUNC(ARRAY(1, 2), NUMMULTIRANGE(NUMRANGE(10, 20)));
DROP FUNCTION x (anyarray, anymultirange);
/* should fail */ CREATE FUNCTION x(x) RETURNS anymultirange LANGUAGE sql AS 'select int4multirange(int4range(1,10))';
/* should fail */ CREATE FUNCTION x(x) RETURNS anymultirange LANGUAGE sql AS 'select int4multirange(int4range(1,10))';
CREATE FUNCTION x(x) RETURNS anyelement LANGUAGE sql AS 'select lower($1) + upper($1)';
SELECT RANGE_ADD_BOUNDS(INT4MULTIRANGE(INT4RANGE(1, 17)));
SELECT RANGE_ADD_BOUNDS(NUMMULTIRANGE(NUMRANGE(1.0001, 123.123)));
SELECT MULTIRANGETYPES_SQL(INT4MULTIRANGE(INT4RANGE(1, 10)), ARRAY(2, 20));
SELECT MULTIRANGETYPES_SQL(NUMMULTIRANGE(NUMRANGE(1, 10)), ARRAY(2, 20));
SELECT ANYCOMPATIBLEARRAY_ANYCOMPATIBLEMULTIRANGE_FUNC(ARRAY(1, 2), MULTIRANGE(INT4RANGE(10, 20)));
SELECT ANYCOMPATIBLEARRAY_ANYCOMPATIBLEMULTIRANGE_FUNC(ARRAY(1, 2), MULTIRANGE(NUMRANGE(10, 20)));
/* should fail */ SELECT ANYCOMPATIBLEARRAY_ANYCOMPATIBLEMULTIRANGE_FUNC(ARRAY(1.1, 2), MULTIRANGE(INT4RANGE(10, 20)));
DROP FUNCTION x (anycompatiblearray, anycompatiblemultirange);
SELECT ANYCOMPATIBLERANGE_ANYCOMPATIBLEMULTIRANGE_FUNC(INT4RANGE(1, 2), MULTIRANGE(INT4RANGE(10, 20)));
/* should fail */ SELECT ANYCOMPATIBLERANGE_ANYCOMPATIBLEMULTIRANGE_FUNC(NUMRANGE(1, 2), MULTIRANGE(INT4RANGE(10, 20)));
DROP FUNCTION x (anycompatiblerange, anycompatiblemultirange);
/* should fail */ CREATE FUNCTION x(x) RETURNS anycompatiblerange LANGUAGE sql AS 'select int4range(1,10)';
/* Arrays of multiranges */ SELECT ARRAY(NUMMULTIRANGE(NUMRANGE(1.1, 1.2)), NUMMULTIRANGE(NUMRANGE(12.3, 155.5)));
CREATE TABLE x (x INT, x ARRAY<INT8MULTIRANGE>);
INSERT INTO x VALUES (42, ARRAY(INT8MULTIRANGE(INT8RANGE(1, 10)), INT8MULTIRANGE(INT8RANGE(2, 20))));
SELECT * FROM x;
DROP TABLE x;
/* Multiranges of arrays */ SELECT ARRAYMULTIRANGE(ARRAYRANGE(ARRAY(1, 2), ARRAY(2, 1)));
SELECT ARRAYMULTIRANGE(ARRAYRANGE(ARRAY(2, 1), ARRAY(1, 2)));
/* fail */ SELECT ARRAYMULTIRANGE(ARRAYRANGE(ARRAY(1, 2), ARRAY(2, 1))) @> ARRAY(1, 1);
SELECT ARRAYMULTIRANGE(ARRAYRANGE(ARRAY(1, 2), ARRAY(2, 1))) @> ARRAY(1, 3);
/* Ranges of composites */ create type two_ints as (a int, b int);
create type two_ints_range as range (subtype = two_ints);
/* with debug_parallel_query on, this exercises tqueue.c's range remapping */ SELECT *, ROW_TO_JSON(UPPER(x)) AS x FROM (VALUES (TWO_INTS_MULTIRANGE(TWO_INTS_RANGE(ROW(1, 2), ROW(3, 4)))), (TWO_INTS_MULTIRANGE(TWO_INTS_RANGE(ROW(5, 6), ROW(7, 8))))) AS x;
drop type two_ints cascade;
SET x = off /* Check behavior when subtype lacks a hash function */;
/* try to make it pick a hash setop implementation */ SELECT CAST('{(01,10)}' AS varbitmultirange) EXCEPT SELECT CAST('{(10,11)}' AS varbitmultirange);
RESET enable_sort;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
/* infer anyelement+anymultirange from anyelement+anymultirange */ CREATE FUNCTION x(x anyelement, x anymultirange) RETURNS TABLE (x anyelement, x anymultirange) LANGUAGE sql AS $$ select $1, $2 $$;
SELECT * FROM x;
COMMIT;
SELECT MR_POLYMORPHIC(INT4RANGE(1, 4));
/* should fail */ CREATE FUNCTION x(x anyelement) RETURNS TABLE (x anyelement, x anymultirange) LANGUAGE sql AS $$ select $1, '[1,10]' $$;
/* Verify that index scans encountering dead rows produced by an */ /* aborted subtransaction of the current transaction can utilize the */ /* kill_prior_tuple optimization */ /* NB: The table size is currently *not* expected to stay the same, we */ /* don't have logic to trigger opportunistic pruning in cases like */ /* this. */ BEGIN;
SET LOCAL x = FALSE;
SET LOCAL x = FALSE;
SET LOCAL x = FALSE;
/* Can't easily use a unique index, since dead tuples can be found */ /* independent of the kill_prior_tuples optimization. */ CREATE TABLE x (x INT, x TEXT);
CREATE INDEX x ON x(x NULLS LAST);
INSERT INTO x (x, x) VALUES (-1, 'just to allocate metapage');
INSERT INTO x SELECT x.x, 'rolling back in a sec' FROM x AS x;
COMMIT;
/* show sizes only if they differ */ SELECT :clean_aborted_self_key_before AS x, PG_RELATION_SIZE('clean_aborted_self_key') AS x WHERE :clean_aborted_self_key_before <> PG_RELATION_SIZE('clean_aborted_self_key');
ROLLBACK;
/* NAME */ /* all inputs are silently truncated at NAMEDATALEN-1 (63) characters */ /* fixed-length by reference */ SELECT CAST('name string' AS NAME) = CAST('name string' AS NAME) AS "x";
SELECT CAST('name string' AS NAME) = CAST('name string ' AS NAME) AS "x";
CREATE TABLE x (x NAME);
INSERT INTO x (x) VALUES ('1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890ABCDEFGHIJKLMNOPQR');
INSERT INTO x (x) VALUES ('1234567890abcdefghijklmnopqrstuvwxyz1234567890abcdefghijklmnopqr');
INSERT INTO x (x) VALUES ('343f%2a');
INSERT INTO x (x) VALUES ('d34aaasdf');
INSERT INTO x (x) VALUES ('');
INSERT INTO x (x) VALUES ('1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ');
SELECT * FROM x;
SELECT x.x FROM x AS x WHERE x.x <> '1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890ABCDEFGHIJKLMNOPQR';
SELECT x.x FROM x AS x WHERE x.x = '1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890ABCDEFGHIJKLMNOPQR';
SELECT x.x FROM x AS x WHERE x.x < '1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890ABCDEFGHIJKLMNOPQR';
SELECT x.x FROM x AS x WHERE x.x <= '1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890ABCDEFGHIJKLMNOPQR';
SELECT x.x FROM x AS x WHERE x.x > '1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890ABCDEFGHIJKLMNOPQR';
SELECT x.x FROM x AS x WHERE x.x >= '1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890ABCDEFGHIJKLMNOPQR';
SELECT x.x FROM x AS x WHERE REGEXP_LIKE(x.x, '.*');
SELECT x.x FROM x AS x WHERE NOT REGEXP_LIKE(x.x, '.*');
SELECT x.x FROM x AS x WHERE REGEXP_LIKE(x.x, '[0-9]');
SELECT x.x FROM x AS x WHERE REGEXP_LIKE(x.x, '.*asdf.*');
DROP TABLE x;
BEGIN r := parse_ident('Schemax.Tabley');
x := PARSE_IDENT('"SchemaX"."TableY"');
COMMIT;
SELECT PARSE_IDENT('foo.boo');
SELECT PARSE_IDENT('foo.boo[]');
/* should fail */ SELECT PARSE_IDENT('foo.boo[]', strict => FALSE);
/* ok */ /* should fail */ SELECT PARSE_IDENT(' ');
SELECT PARSE_IDENT(' .aaa');
SELECT PARSE_IDENT(' aaa . ');
SELECT PARSE_IDENT('aaa.a%b');
SELECT PARSE_IDENT(X\rXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX);
SELECT LENGTH(x[0]), LENGTH(x[1]) FROM x AS x;
SELECT PARSE_IDENT(' first . "  second  " ."   third   ". "  ' || REPEAT('x', 66) || '"');
SELECT CAST(PARSE_IDENT(' first . "  second  " ."   third   ". "  ' || REPEAT('x', 66) || '"') AS ARRAY<NAME>);
SELECT PARSE_IDENT("c".X XXXX\002XXXXXX);
SELECT PARSE_IDENT('1020');
SELECT PARSE_IDENT('10.20');
SELECT PARSE_IDENT('.');
SELECT PARSE_IDENT('.1020');
SELECT PARSE_IDENT('xxx.1020');
/* Regression tests for schemas (namespaces) */ /* set the whitespace-only search_path to test that the */ /* GUC list syntax is preserved during a schema creation */ SELECT x.set_config('search_path', ' ', FALSE);
CREATE SCHEMA test_ns_schema_1        CREATE UNIQUE INDEX abc_a_idx ON abc (a)         CREATE VIEW abc_view AS               SELECT a+1 AS a, b+1 AS b FROM abc         CREATE TABLE abc (               a serial,               b int UNIQUE        );
SET x = public /* verify that the correct search_path restored on abort */;
BEGIN;
SET search_path to public, test_ns_schema_1;
CREATE SCHEMA test_ns_schema_2        CREATE VIEW abc_view AS SELECT c FROM abc;
COMMIT;
SHOW search_path;
/* verify that the correct search_path preserved */ /* after creating the schema and on commit */ BEGIN;
SET search_path to public, test_ns_schema_1;
CREATE SCHEMA test_ns_schema_2        CREATE VIEW abc_view AS SELECT a FROM abc;
SHOW search_path;
COMMIT;
SHOW search_path;
DROP SCHEMA x.x CASCADE;
/* verify that the objects were created */ SELECT COUNT(*) FROM x WHERE x = (SELECT x FROM x WHERE x = 'test_ns_schema_1');
SELECT * FROM x.x;
SELECT * FROM x.x;
ALTER SCHEMA test_ns_schema_1 RENAME TO test_ns_schema_renamed;
SELECT COUNT(*) FROM x WHERE x = (SELECT x FROM x WHERE x = 'test_ns_schema_1');
/* test IF NOT EXISTS cases */ CREATE SCHEMA x.x;
/* fail, already exists */ CREATE SCHEMA IF NOT EXISTS x.x;
/* ok with notice */ CREATE SCHEMA IF NOT EXISTS test_ns_schema_renamed -- fail, disallowed        CREATE TABLE abc (               a serial,               b int UNIQUE        );
DROP SCHEMA x.x CASCADE;
/* verify that the objects were dropped */ SELECT COUNT(*) FROM x WHERE x = (SELECT x FROM x WHERE x = 'test_ns_schema_renamed');
/* Verify that search_path is set to a safe value during maintenance */ /* commands. */ CREATE SCHEMA x.x;
SET x = test_maint_search_path;
x AS @1;
COMMIT;
CREATE TABLE x (x INT);
INSERT INTO x VALUES (1), (2);
CREATE MATERIALIZED VIEW x AS SELECT FN(x) FROM x;
/* the following commands should see search_path as pg_catalog, pg_temp */ CREATE INDEX x ON x.x(FN(x) NULLS LAST);
REINDEX TABLE test_maint_search_path.test_maint;
ANALYZE x.x;
VACUUM FULL test_maint_search_path.test_maint;
REFRESH MATERIALIZED VIEW test_maint_search_path.test_maint_mv;
RESET search_path;
DROP SCHEMA x.x CASCADE;
/* NUMERIC */ CREATE TABLE x (x INT, x DECIMAL(210, 10));
CREATE TABLE x (x INT, x INT, x DECIMAL(210, 10));
CREATE TABLE x (x INT, x INT, x DECIMAL(210, 10));
CREATE TABLE x (x INT, x INT, x DECIMAL(210, 10));
CREATE TABLE x (x INT, x INT, x DECIMAL(210, 10));
CREATE TABLE x (x INT, x DECIMAL(210, 10));
CREATE TABLE x (x INT, x DECIMAL(210, 10));
CREATE TABLE x (x INT, x DECIMAL(210, 10));
CREATE TABLE x (x INT, x DECIMAL(210, 10));
CREATE TABLE x (x INT, x INT, x DECIMAL(210, 10));
BEGIN /* ****************************** */ /* * The following EXPECTED results are computed by bc(1) */ /* * with a scale of 200 */ /* ****************************** */ /* ****************************** */ /* * The following EXPECTED results are computed by bc(1) */ /* * with a scale of 200 */ /* ****************************** */;
INSERT INTO x VALUES (0, 0, '0');
INSERT INTO x VALUES (0, 0, '0');
INSERT INTO x VALUES (0, 0, '0');
INSERT INTO x VALUES (0, 0, 'NaN');
INSERT INTO x VALUES (0, 1, '0');
INSERT INTO x VALUES (0, 1, '0');
INSERT INTO x VALUES (0, 1, '0');
INSERT INTO x VALUES (0, 1, 'NaN');
INSERT INTO x VALUES (0, 2, '-34338492.215397047');
INSERT INTO x VALUES (0, 2, '34338492.215397047');
INSERT INTO x VALUES (0, 2, '0');
INSERT INTO x VALUES (0, 2, '0');
INSERT INTO x VALUES (0, 3, '4.31');
INSERT INTO x VALUES (0, 3, '-4.31');
INSERT INTO x VALUES (0, 3, '0');
INSERT INTO x VALUES (0, 3, '0');
INSERT INTO x VALUES (0, 4, '7799461.4119');
INSERT INTO x VALUES (0, 4, '-7799461.4119');
INSERT INTO x VALUES (0, 4, '0');
INSERT INTO x VALUES (0, 4, '0');
INSERT INTO x VALUES (0, 5, '16397.038491');
INSERT INTO x VALUES (0, 5, '-16397.038491');
INSERT INTO x VALUES (0, 5, '0');
INSERT INTO x VALUES (0, 5, '0');
INSERT INTO x VALUES (0, 6, '93901.57763026');
INSERT INTO x VALUES (0, 6, '-93901.57763026');
INSERT INTO x VALUES (0, 6, '0');
INSERT INTO x VALUES (0, 6, '0');
INSERT INTO x VALUES (0, 7, '-83028485');
INSERT INTO x VALUES (0, 7, '83028485');
INSERT INTO x VALUES (0, 7, '0');
INSERT INTO x VALUES (0, 7, '0');
INSERT INTO x VALUES (0, 8, '74881');
INSERT INTO x VALUES (0, 8, '-74881');
INSERT INTO x VALUES (0, 8, '0');
INSERT INTO x VALUES (0, 8, '0');
INSERT INTO x VALUES (0, 9, '-24926804.045047420');
INSERT INTO x VALUES (0, 9, '24926804.045047420');
INSERT INTO x VALUES (0, 9, '0');
INSERT INTO x VALUES (0, 9, '0');
INSERT INTO x VALUES (1, 0, '0');
INSERT INTO x VALUES (1, 0, '0');
INSERT INTO x VALUES (1, 0, '0');
INSERT INTO x VALUES (1, 0, 'NaN');
INSERT INTO x VALUES (1, 1, '0');
INSERT INTO x VALUES (1, 1, '0');
INSERT INTO x VALUES (1, 1, '0');
INSERT INTO x VALUES (1, 1, 'NaN');
INSERT INTO x VALUES (1, 2, '-34338492.215397047');
INSERT INTO x VALUES (1, 2, '34338492.215397047');
INSERT INTO x VALUES (1, 2, '0');
INSERT INTO x VALUES (1, 2, '0');
INSERT INTO x VALUES (1, 3, '4.31');
INSERT INTO x VALUES (1, 3, '-4.31');
INSERT INTO x VALUES (1, 3, '0');
INSERT INTO x VALUES (1, 3, '0');
INSERT INTO x VALUES (1, 4, '7799461.4119');
INSERT INTO x VALUES (1, 4, '-7799461.4119');
INSERT INTO x VALUES (1, 4, '0');
INSERT INTO x VALUES (1, 4, '0');
INSERT INTO x VALUES (1, 5, '16397.038491');
INSERT INTO x VALUES (1, 5, '-16397.038491');
INSERT INTO x VALUES (1, 5, '0');
INSERT INTO x VALUES (1, 5, '0');
INSERT INTO x VALUES (1, 6, '93901.57763026');
INSERT INTO x VALUES (1, 6, '-93901.57763026');
INSERT INTO x VALUES (1, 6, '0');
INSERT INTO x VALUES (1, 6, '0');
INSERT INTO x VALUES (1, 7, '-83028485');
INSERT INTO x VALUES (1, 7, '83028485');
INSERT INTO x VALUES (1, 7, '0');
INSERT INTO x VALUES (1, 7, '0');
INSERT INTO x VALUES (1, 8, '74881');
INSERT INTO x VALUES (1, 8, '-74881');
INSERT INTO x VALUES (1, 8, '0');
INSERT INTO x VALUES (1, 8, '0');
INSERT INTO x VALUES (1, 9, '-24926804.045047420');
INSERT INTO x VALUES (1, 9, '24926804.045047420');
INSERT INTO x VALUES (1, 9, '0');
INSERT INTO x VALUES (1, 9, '0');
INSERT INTO x VALUES (2, 0, '-34338492.215397047');
INSERT INTO x VALUES (2, 0, '-34338492.215397047');
INSERT INTO x VALUES (2, 0, '0');
INSERT INTO x VALUES (2, 0, 'NaN');
INSERT INTO x VALUES (2, 1, '-34338492.215397047');
INSERT INTO x VALUES (2, 1, '-34338492.215397047');
INSERT INTO x VALUES (2, 1, '0');
INSERT INTO x VALUES (2, 1, 'NaN');
INSERT INTO x VALUES (2, 2, '-68676984.430794094');
INSERT INTO x VALUES (2, 2, '0');
INSERT INTO x VALUES (2, 2, '1179132047626883.596862135856320209');
INSERT INTO x VALUES (2, 2, '1.00000000000000000000');
INSERT INTO x VALUES (2, 3, '-34338487.905397047');
INSERT INTO x VALUES (2, 3, '-34338496.525397047');
INSERT INTO x VALUES (2, 3, '-147998901.44836127257');
INSERT INTO x VALUES (2, 3, '-7967167.56737750510440835266');
INSERT INTO x VALUES (2, 4, '-26539030.803497047');
INSERT INTO x VALUES (2, 4, '-42137953.627297047');
INSERT INTO x VALUES (2, 4, '-267821744976817.8111137106593');
INSERT INTO x VALUES (2, 4, '-4.40267480046830116685');
INSERT INTO x VALUES (2, 5, '-34322095.176906047');
INSERT INTO x VALUES (2, 5, '-34354889.253888047');
INSERT INTO x VALUES (2, 5, '-563049578578.769242506736077');
INSERT INTO x VALUES (2, 5, '-2094.18866914563535496429');
INSERT INTO x VALUES (2, 6, '-34244590.637766787');
INSERT INTO x VALUES (2, 6, '-34432393.793027307');
INSERT INTO x VALUES (2, 6, '-3224438592470.18449811926184222');
INSERT INTO x VALUES (2, 6, '-365.68599891479766440940');
INSERT INTO x VALUES (2, 7, '-117366977.215397047');
INSERT INTO x VALUES (2, 7, '48689992.784602953');
INSERT INTO x VALUES (2, 7, '2851072985828710.485883795');
INSERT INTO x VALUES (2, 7, '.41357483778485235518');
INSERT INTO x VALUES (2, 8, '-34263611.215397047');
INSERT INTO x VALUES (2, 8, '-34413373.215397047');
INSERT INTO x VALUES (2, 8, '-2571300635581.146276407');
INSERT INTO x VALUES (2, 8, '-458.57416721727870888476');
INSERT INTO x VALUES (2, 9, '-59265296.260444467');
INSERT INTO x VALUES (2, 9, '-9411688.170349627');
INSERT INTO x VALUES (2, 9, '855948866655588.453741509242968740');
INSERT INTO x VALUES (2, 9, '1.37757299946438931811');
INSERT INTO x VALUES (3, 0, '4.31');
INSERT INTO x VALUES (3, 0, '4.31');
INSERT INTO x VALUES (3, 0, '0');
INSERT INTO x VALUES (3, 0, 'NaN');
INSERT INTO x VALUES (3, 1, '4.31');
INSERT INTO x VALUES (3, 1, '4.31');
INSERT INTO x VALUES (3, 1, '0');
INSERT INTO x VALUES (3, 1, 'NaN');
INSERT INTO x VALUES (3, 2, '-34338487.905397047');
INSERT INTO x VALUES (3, 2, '34338496.525397047');
INSERT INTO x VALUES (3, 2, '-147998901.44836127257');
INSERT INTO x VALUES (3, 2, '-.00000012551512084352');
INSERT INTO x VALUES (3, 3, '8.62');
INSERT INTO x VALUES (3, 3, '0');
INSERT INTO x VALUES (3, 3, '18.5761');
INSERT INTO x VALUES (3, 3, '1.00000000000000000000');
INSERT INTO x VALUES (3, 4, '7799465.7219');
INSERT INTO x VALUES (3, 4, '-7799457.1019');
INSERT INTO x VALUES (3, 4, '33615678.685289');
INSERT INTO x VALUES (3, 4, '.00000055260225961552');
INSERT INTO x VALUES (3, 5, '16401.348491');
INSERT INTO x VALUES (3, 5, '-16392.728491');
INSERT INTO x VALUES (3, 5, '70671.23589621');
INSERT INTO x VALUES (3, 5, '.00026285234387695504');
INSERT INTO x VALUES (3, 6, '93905.88763026');
INSERT INTO x VALUES (3, 6, '-93897.26763026');
INSERT INTO x VALUES (3, 6, '404715.7995864206');
INSERT INTO x VALUES (3, 6, '.00004589912234457595');
INSERT INTO x VALUES (3, 7, '-83028480.69');
INSERT INTO x VALUES (3, 7, '83028489.31');
INSERT INTO x VALUES (3, 7, '-357852770.35');
INSERT INTO x VALUES (3, 7, '-.00000005190989574240');
INSERT INTO x VALUES (3, 8, '74885.31');
INSERT INTO x VALUES (3, 8, '-74876.69');
INSERT INTO x VALUES (3, 8, '322737.11');
INSERT INTO x VALUES (3, 8, '.00005755799201399553');
INSERT INTO x VALUES (3, 9, '-24926799.735047420');
INSERT INTO x VALUES (3, 9, '24926808.355047420');
INSERT INTO x VALUES (3, 9, '-107434525.43415438020');
INSERT INTO x VALUES (3, 9, '-.00000017290624149854');
INSERT INTO x VALUES (4, 0, '7799461.4119');
INSERT INTO x VALUES (4, 0, '7799461.4119');
INSERT INTO x VALUES (4, 0, '0');
INSERT INTO x VALUES (4, 0, 'NaN');
INSERT INTO x VALUES (4, 1, '7799461.4119');
INSERT INTO x VALUES (4, 1, '7799461.4119');
INSERT INTO x VALUES (4, 1, '0');
INSERT INTO x VALUES (4, 1, 'NaN');
INSERT INTO x VALUES (4, 2, '-26539030.803497047');
INSERT INTO x VALUES (4, 2, '42137953.627297047');
INSERT INTO x VALUES (4, 2, '-267821744976817.8111137106593');
INSERT INTO x VALUES (4, 2, '-.22713465002993920385');
INSERT INTO x VALUES (4, 3, '7799465.7219');
INSERT INTO x VALUES (4, 3, '7799457.1019');
INSERT INTO x VALUES (4, 3, '33615678.685289');
INSERT INTO x VALUES (4, 3, '1809619.81714617169373549883');
INSERT INTO x VALUES (4, 4, '15598922.8238');
INSERT INTO x VALUES (4, 4, '0');
INSERT INTO x VALUES (4, 4, '60831598315717.14146161');
INSERT INTO x VALUES (4, 4, '1.00000000000000000000');
INSERT INTO x VALUES (4, 5, '7815858.450391');
INSERT INTO x VALUES (4, 5, '7783064.373409');
INSERT INTO x VALUES (4, 5, '127888068979.9935054429');
INSERT INTO x VALUES (4, 5, '475.66281046305802686061');
INSERT INTO x VALUES (4, 6, '7893362.98953026');
INSERT INTO x VALUES (4, 6, '7705559.83426974');
INSERT INTO x VALUES (4, 6, '732381731243.745115764094');
INSERT INTO x VALUES (4, 6, '83.05996138436129499606');
INSERT INTO x VALUES (4, 7, '-75229023.5881');
INSERT INTO x VALUES (4, 7, '90827946.4119');
INSERT INTO x VALUES (4, 7, '-647577464846017.9715');
INSERT INTO x VALUES (4, 7, '-.09393717604145131637');
INSERT INTO x VALUES (4, 8, '7874342.4119');
INSERT INTO x VALUES (4, 8, '7724580.4119');
INSERT INTO x VALUES (4, 8, '584031469984.4839');
INSERT INTO x VALUES (4, 8, '104.15808298366741897143');
INSERT INTO x VALUES (4, 9, '-17127342.633147420');
INSERT INTO x VALUES (4, 9, '32726265.456947420');
INSERT INTO x VALUES (4, 9, '-194415646271340.1815956522980');
INSERT INTO x VALUES (4, 9, '-.31289456112403769409');
INSERT INTO x VALUES (5, 0, '16397.038491');
INSERT INTO x VALUES (5, 0, '16397.038491');
INSERT INTO x VALUES (5, 0, '0');
INSERT INTO x VALUES (5, 0, 'NaN');
INSERT INTO x VALUES (5, 1, '16397.038491');
INSERT INTO x VALUES (5, 1, '16397.038491');
INSERT INTO x VALUES (5, 1, '0');
INSERT INTO x VALUES (5, 1, 'NaN');
INSERT INTO x VALUES (5, 2, '-34322095.176906047');
INSERT INTO x VALUES (5, 2, '34354889.253888047');
INSERT INTO x VALUES (5, 2, '-563049578578.769242506736077');
INSERT INTO x VALUES (5, 2, '-.00047751189505192446');
INSERT INTO x VALUES (5, 3, '16401.348491');
INSERT INTO x VALUES (5, 3, '16392.728491');
INSERT INTO x VALUES (5, 3, '70671.23589621');
INSERT INTO x VALUES (5, 3, '3804.41728329466357308584');
INSERT INTO x VALUES (5, 4, '7815858.450391');
INSERT INTO x VALUES (5, 4, '-7783064.373409');
INSERT INTO x VALUES (5, 4, '127888068979.9935054429');
INSERT INTO x VALUES (5, 4, '.00210232958726897192');
INSERT INTO x VALUES (5, 5, '32794.076982');
INSERT INTO x VALUES (5, 5, '0');
INSERT INTO x VALUES (5, 5, '268862871.275335557081');
INSERT INTO x VALUES (5, 5, '1.00000000000000000000');
INSERT INTO x VALUES (5, 6, '110298.61612126');
INSERT INTO x VALUES (5, 6, '-77504.53913926');
INSERT INTO x VALUES (5, 6, '1539707782.76899778633766');
INSERT INTO x VALUES (5, 6, '.17461941433576102689');
INSERT INTO x VALUES (5, 7, '-83012087.961509');
INSERT INTO x VALUES (5, 7, '83044882.038491');
INSERT INTO x VALUES (5, 7, '-1361421264394.416135');
INSERT INTO x VALUES (5, 7, '-.00019748690453643710');
INSERT INTO x VALUES (5, 8, '91278.038491');
INSERT INTO x VALUES (5, 8, '-58483.961509');
INSERT INTO x VALUES (5, 8, '1227826639.244571');
INSERT INTO x VALUES (5, 8, '.21897461960978085228');
INSERT INTO x VALUES (5, 9, '-24910407.006556420');
INSERT INTO x VALUES (5, 9, '24943201.083538420');
INSERT INTO x VALUES (5, 9, '-408725765384.257043660243220');
INSERT INTO x VALUES (5, 9, '-.00065780749354660427');
INSERT INTO x VALUES (6, 0, '93901.57763026');
INSERT INTO x VALUES (6, 0, '93901.57763026');
INSERT INTO x VALUES (6, 0, '0');
INSERT INTO x VALUES (6, 0, 'NaN');
INSERT INTO x VALUES (6, 1, '93901.57763026');
INSERT INTO x VALUES (6, 1, '93901.57763026');
INSERT INTO x VALUES (6, 1, '0');
INSERT INTO x VALUES (6, 1, 'NaN');
INSERT INTO x VALUES (6, 2, '-34244590.637766787');
INSERT INTO x VALUES (6, 2, '34432393.793027307');
INSERT INTO x VALUES (6, 2, '-3224438592470.18449811926184222');
INSERT INTO x VALUES (6, 2, '-.00273458651128995823');
INSERT INTO x VALUES (6, 3, '93905.88763026');
INSERT INTO x VALUES (6, 3, '93897.26763026');
INSERT INTO x VALUES (6, 3, '404715.7995864206');
INSERT INTO x VALUES (6, 3, '21786.90896293735498839907');
INSERT INTO x VALUES (6, 4, '7893362.98953026');
INSERT INTO x VALUES (6, 4, '-7705559.83426974');
INSERT INTO x VALUES (6, 4, '732381731243.745115764094');
INSERT INTO x VALUES (6, 4, '.01203949512295682469');
INSERT INTO x VALUES (6, 5, '110298.61612126');
INSERT INTO x VALUES (6, 5, '77504.53913926');
INSERT INTO x VALUES (6, 5, '1539707782.76899778633766');
INSERT INTO x VALUES (6, 5, '5.72674008674192359679');
INSERT INTO x VALUES (6, 6, '187803.15526052');
INSERT INTO x VALUES (6, 6, '0');
INSERT INTO x VALUES (6, 6, '8817506281.4517452372676676');
INSERT INTO x VALUES (6, 6, '1.00000000000000000000');
INSERT INTO x VALUES (6, 7, '-82934583.42236974');
INSERT INTO x VALUES (6, 7, '83122386.57763026');
INSERT INTO x VALUES (6, 7, '-7796505729750.37795610');
INSERT INTO x VALUES (6, 7, '-.00113095617281538980');
INSERT INTO x VALUES (6, 8, '168782.57763026');
INSERT INTO x VALUES (6, 8, '19020.57763026');
INSERT INTO x VALUES (6, 8, '7031444034.53149906');
INSERT INTO x VALUES (6, 8, '1.25401073209839612184');
INSERT INTO x VALUES (6, 9, '-24832902.467417160');
INSERT INTO x VALUES (6, 9, '25020705.622677680');
INSERT INTO x VALUES (6, 9, '-2340666225110.29929521292692920');
INSERT INTO x VALUES (6, 9, '-.00376709254265256789');
INSERT INTO x VALUES (7, 0, '-83028485');
INSERT INTO x VALUES (7, 0, '-83028485');
INSERT INTO x VALUES (7, 0, '0');
INSERT INTO x VALUES (7, 0, 'NaN');
INSERT INTO x VALUES (7, 1, '-83028485');
INSERT INTO x VALUES (7, 1, '-83028485');
INSERT INTO x VALUES (7, 1, '0');
INSERT INTO x VALUES (7, 1, 'NaN');
INSERT INTO x VALUES (7, 2, '-117366977.215397047');
INSERT INTO x VALUES (7, 2, '-48689992.784602953');
INSERT INTO x VALUES (7, 2, '2851072985828710.485883795');
INSERT INTO x VALUES (7, 2, '2.41794207151503385700');
INSERT INTO x VALUES (7, 3, '-83028480.69');
INSERT INTO x VALUES (7, 3, '-83028489.31');
INSERT INTO x VALUES (7, 3, '-357852770.35');
INSERT INTO x VALUES (7, 3, '-19264149.65197215777262180974');
INSERT INTO x VALUES (7, 4, '-75229023.5881');
INSERT INTO x VALUES (7, 4, '-90827946.4119');
INSERT INTO x VALUES (7, 4, '-647577464846017.9715');
INSERT INTO x VALUES (7, 4, '-10.64541262725136247686');
INSERT INTO x VALUES (7, 5, '-83012087.961509');
INSERT INTO x VALUES (7, 5, '-83044882.038491');
INSERT INTO x VALUES (7, 5, '-1361421264394.416135');
INSERT INTO x VALUES (7, 5, '-5063.62688881730941836574');
INSERT INTO x VALUES (7, 6, '-82934583.42236974');
INSERT INTO x VALUES (7, 6, '-83122386.57763026');
INSERT INTO x VALUES (7, 6, '-7796505729750.37795610');
INSERT INTO x VALUES (7, 6, '-884.20756174009028770294');
INSERT INTO x VALUES (7, 7, '-166056970');
INSERT INTO x VALUES (7, 7, '0');
INSERT INTO x VALUES (7, 7, '6893729321395225');
INSERT INTO x VALUES (7, 7, '1.00000000000000000000');
INSERT INTO x VALUES (7, 8, '-82953604');
INSERT INTO x VALUES (7, 8, '-83103366');
INSERT INTO x VALUES (7, 8, '-6217255985285');
INSERT INTO x VALUES (7, 8, '-1108.80577182462841041118');
INSERT INTO x VALUES (7, 9, '-107955289.045047420');
INSERT INTO x VALUES (7, 9, '-58101680.954952580');
INSERT INTO x VALUES (7, 9, '2069634775752159.035758700');
INSERT INTO x VALUES (7, 9, '3.33089171198810413382');
INSERT INTO x VALUES (8, 0, '74881');
INSERT INTO x VALUES (8, 0, '74881');
INSERT INTO x VALUES (8, 0, '0');
INSERT INTO x VALUES (8, 0, 'NaN');
INSERT INTO x VALUES (8, 1, '74881');
INSERT INTO x VALUES (8, 1, '74881');
INSERT INTO x VALUES (8, 1, '0');
INSERT INTO x VALUES (8, 1, 'NaN');
INSERT INTO x VALUES (8, 2, '-34263611.215397047');
INSERT INTO x VALUES (8, 2, '34413373.215397047');
INSERT INTO x VALUES (8, 2, '-2571300635581.146276407');
INSERT INTO x VALUES (8, 2, '-.00218067233500788615');
INSERT INTO x VALUES (8, 3, '74885.31');
INSERT INTO x VALUES (8, 3, '74876.69');
INSERT INTO x VALUES (8, 3, '322737.11');
INSERT INTO x VALUES (8, 3, '17373.78190255220417633410');
INSERT INTO x VALUES (8, 4, '7874342.4119');
INSERT INTO x VALUES (8, 4, '-7724580.4119');
INSERT INTO x VALUES (8, 4, '584031469984.4839');
INSERT INTO x VALUES (8, 4, '.00960079113741758956');
INSERT INTO x VALUES (8, 5, '91278.038491');
INSERT INTO x VALUES (8, 5, '58483.961509');
INSERT INTO x VALUES (8, 5, '1227826639.244571');
INSERT INTO x VALUES (8, 5, '4.56673929509287019456');
INSERT INTO x VALUES (8, 6, '168782.57763026');
INSERT INTO x VALUES (8, 6, '-19020.57763026');
INSERT INTO x VALUES (8, 6, '7031444034.53149906');
INSERT INTO x VALUES (8, 6, '.79744134113322314424');
INSERT INTO x VALUES (8, 7, '-82953604');
INSERT INTO x VALUES (8, 7, '83103366');
INSERT INTO x VALUES (8, 7, '-6217255985285');
INSERT INTO x VALUES (8, 7, '-.00090187120721280172');
INSERT INTO x VALUES (8, 8, '149762');
INSERT INTO x VALUES (8, 8, '0');
INSERT INTO x VALUES (8, 8, '5607164161');
INSERT INTO x VALUES (8, 8, '1.00000000000000000000');
INSERT INTO x VALUES (8, 9, '-24851923.045047420');
INSERT INTO x VALUES (8, 9, '25001685.045047420');
INSERT INTO x VALUES (8, 9, '-1866544013697.195857020');
INSERT INTO x VALUES (8, 9, '-.00300403532938582735');
INSERT INTO x VALUES (9, 0, '-24926804.045047420');
INSERT INTO x VALUES (9, 0, '-24926804.045047420');
INSERT INTO x VALUES (9, 0, '0');
INSERT INTO x VALUES (9, 0, 'NaN');
INSERT INTO x VALUES (9, 1, '-24926804.045047420');
INSERT INTO x VALUES (9, 1, '-24926804.045047420');
INSERT INTO x VALUES (9, 1, '0');
INSERT INTO x VALUES (9, 1, 'NaN');
INSERT INTO x VALUES (9, 2, '-59265296.260444467');
INSERT INTO x VALUES (9, 2, '9411688.170349627');
INSERT INTO x VALUES (9, 2, '855948866655588.453741509242968740');
INSERT INTO x VALUES (9, 2, '.72591434384152961526');
INSERT INTO x VALUES (9, 3, '-24926799.735047420');
INSERT INTO x VALUES (9, 3, '-24926808.355047420');
INSERT INTO x VALUES (9, 3, '-107434525.43415438020');
INSERT INTO x VALUES (9, 3, '-5783481.21694835730858468677');
INSERT INTO x VALUES (9, 4, '-17127342.633147420');
INSERT INTO x VALUES (9, 4, '-32726265.456947420');
INSERT INTO x VALUES (9, 4, '-194415646271340.1815956522980');
INSERT INTO x VALUES (9, 4, '-3.19596478892958416484');
INSERT INTO x VALUES (9, 5, '-24910407.006556420');
INSERT INTO x VALUES (9, 5, '-24943201.083538420');
INSERT INTO x VALUES (9, 5, '-408725765384.257043660243220');
INSERT INTO x VALUES (9, 5, '-1520.20159364322004505807');
INSERT INTO x VALUES (9, 6, '-24832902.467417160');
INSERT INTO x VALUES (9, 6, '-25020705.622677680');
INSERT INTO x VALUES (9, 6, '-2340666225110.29929521292692920');
INSERT INTO x VALUES (9, 6, '-265.45671195426965751280');
INSERT INTO x VALUES (9, 7, '-107955289.045047420');
INSERT INTO x VALUES (9, 7, '58101680.954952580');
INSERT INTO x VALUES (9, 7, '2069634775752159.035758700');
INSERT INTO x VALUES (9, 7, '.30021990699995814689');
INSERT INTO x VALUES (9, 8, '-24851923.045047420');
INSERT INTO x VALUES (9, 8, '-25001685.045047420');
INSERT INTO x VALUES (9, 8, '-1866544013697.195857020');
INSERT INTO x VALUES (9, 8, '-332.88556569820675471748');
INSERT INTO x VALUES (9, 9, '-49853608.090094840');
INSERT INTO x VALUES (9, 9, '0');
INSERT INTO x VALUES (9, 9, '621345559900192.420120630048656400');
INSERT INTO x VALUES (9, 9, '1.00000000000000000000');
COMMIT;
BEGIN;
INSERT INTO x VALUES (0, '0');
INSERT INTO x VALUES (1, '0');
INSERT INTO x VALUES (2, '5859.90547836712524903505');
INSERT INTO x VALUES (3, '2.07605394920266944396');
INSERT INTO x VALUES (4, '2792.75158435189147418923');
INSERT INTO x VALUES (5, '128.05092147657509145473');
INSERT INTO x VALUES (6, '306.43364311096782703406');
INSERT INTO x VALUES (7, '9111.99676251039939975230');
INSERT INTO x VALUES (8, '273.64392922189960397542');
INSERT INTO x VALUES (9, '4992.67503899937593364766');
COMMIT;
BEGIN;
INSERT INTO x VALUES (0, 'NaN');
INSERT INTO x VALUES (1, 'NaN');
INSERT INTO x VALUES (2, '17.35177750493897715514');
INSERT INTO x VALUES (3, '1.46093790411565641971');
INSERT INTO x VALUES (4, '15.86956523951936572464');
INSERT INTO x VALUES (5, '9.70485601768871834038');
INSERT INTO x VALUES (6, '11.45000246622944403127');
INSERT INTO x VALUES (7, '18.23469429965478772991');
INSERT INTO x VALUES (8, '11.22365546576315513668');
INSERT INTO x VALUES (9, '17.03145425013166006962');
COMMIT;
BEGIN;
INSERT INTO x VALUES (0, 'NaN');
INSERT INTO x VALUES (1, 'NaN');
INSERT INTO x VALUES (2, '7.53578122160797276459');
INSERT INTO x VALUES (3, '.63447727016073160075');
INSERT INTO x VALUES (4, '6.89206461372691743345');
INSERT INTO x VALUES (5, '4.21476541614777768626');
INSERT INTO x VALUES (6, '4.97267288886207207671');
INSERT INTO x VALUES (7, '7.91922711353275546914');
INSERT INTO x VALUES (8, '4.87437163556421004138');
INSERT INTO x VALUES (9, '7.39666659961986567059');
COMMIT;
BEGIN;
INSERT INTO x VALUES (0, 'NaN');
INSERT INTO x VALUES (1, 'NaN');
INSERT INTO x VALUES (2, '224790267919917955.13261618583642653184');
INSERT INTO x VALUES (3, '28.90266599445155957393');
INSERT INTO x VALUES (4, '7405685069594999.07733999469386277636');
INSERT INTO x VALUES (5, '5068226527.32127265408584640098');
INSERT INTO x VALUES (6, '281839893606.99372343357047819067');
INSERT INTO x VALUES (7, '1716699575118597095.42330819910640247627');
INSERT INTO x VALUES (8, '167361463828.07491320069016125952');
INSERT INTO x VALUES (9, '107511333880052007.04141124673540337457');
COMMIT;
BEGIN;
INSERT INTO x VALUES (0, '0');
INSERT INTO x VALUES (1, '0');
INSERT INTO x VALUES (2, '-34338492.215397047');
INSERT INTO x VALUES (3, '4.31');
INSERT INTO x VALUES (4, '7799461.4119');
INSERT INTO x VALUES (5, '16397.038491');
INSERT INTO x VALUES (6, '93901.57763026');
INSERT INTO x VALUES (7, '-83028485');
INSERT INTO x VALUES (8, '74881');
INSERT INTO x VALUES (9, '-24926804.045047420');
COMMIT;
/* ****************************** */ /* * Create indices for faster checks */ /* ****************************** */ CREATE UNIQUE INDEX x ON x(x NULLS LAST, x NULLS LAST);
CREATE UNIQUE INDEX x ON x(x NULLS LAST, x NULLS LAST);
CREATE UNIQUE INDEX x ON x(x NULLS LAST, x NULLS LAST);
CREATE UNIQUE INDEX x ON x(x NULLS LAST, x NULLS LAST);
CREATE UNIQUE INDEX x ON x(x NULLS LAST);
CREATE UNIQUE INDEX x ON x(x NULLS LAST);
CREATE UNIQUE INDEX x ON x(x NULLS LAST);
CREATE UNIQUE INDEX x ON x(x NULLS LAST);
VACUUM ANALYZE num_exp_add;
VACUUM ANALYZE num_exp_sub;
VACUUM ANALYZE num_exp_div;
VACUUM ANALYZE num_exp_mul;
VACUUM ANALYZE num_exp_sqrt;
VACUUM ANALYZE num_exp_ln;
VACUUM ANALYZE num_exp_log10;
VACUUM ANALYZE num_exp_power_10_ln;
/* ****************************** */ /* * Now check the behaviour of the NUMERIC type */ /* ****************************** */ /* ****************************** */ /* * Addition check */ /* ****************************** */ DELETE FROM x;
INSERT INTO x SELECT x.x, x.x, x.x + x.x FROM x AS x, x AS x;
SELECT x.x, x.x, x.x, x.x FROM x AS x, x AS x WHERE x.x = x.x AND x.x = x.x AND x.x <> x.x;
DELETE FROM x;
INSERT INTO x SELECT x.x, x.x, ROUND(x.x + x.x, 10) FROM x AS x, x AS x;
SELECT x.x, x.x, x.x, ROUND(x.x, 10) AS x FROM x AS x, x AS x WHERE x.x = x.x AND x.x = x.x AND x.x <> ROUND(x.x, 10);
/* ****************************** */ /* * Subtraction check */ /* ****************************** */ DELETE FROM x;
INSERT INTO x SELECT x.x, x.x, x.x - x.x FROM x AS x, x AS x;
SELECT x.x, x.x, x.x, x.x FROM x AS x, x AS x WHERE x.x = x.x AND x.x = x.x AND x.x <> x.x;
DELETE FROM x;
INSERT INTO x SELECT x.x, x.x, ROUND(x.x - x.x, 40) FROM x AS x, x AS x;
SELECT x.x, x.x, x.x, ROUND(x.x, 40) FROM x AS x, x AS x WHERE x.x = x.x AND x.x = x.x AND x.x <> ROUND(x.x, 40);
/* ****************************** */ /* * Multiply check */ /* ****************************** */ DELETE FROM x;
INSERT INTO x SELECT x.x, x.x, x.x * x.x FROM x AS x, x AS x;
SELECT x.x, x.x, x.x, x.x FROM x AS x, x AS x WHERE x.x = x.x AND x.x = x.x AND x.x <> x.x;
DELETE FROM x;
INSERT INTO x SELECT x.x, x.x, ROUND(x.x * x.x, 30) FROM x AS x, x AS x;
SELECT x.x, x.x, x.x, ROUND(x.x, 30) AS x FROM x AS x, x AS x WHERE x.x = x.x AND x.x = x.x AND x.x <> ROUND(x.x, 30);
/* ****************************** */ /* * Division check */ /* ****************************** */ DELETE FROM x;
INSERT INTO x SELECT x.x, x.x, x.x / x.x FROM x AS x, x AS x WHERE x.x <> '0.0';
SELECT x.x, x.x, x.x, x.x FROM x AS x, x AS x WHERE x.x = x.x AND x.x = x.x AND x.x <> x.x;
DELETE FROM x;
INSERT INTO x SELECT x.x, x.x, ROUND(x.x / x.x, 80) FROM x AS x, x AS x WHERE x.x <> '0.0';
SELECT x.x, x.x, x.x, ROUND(x.x, 80) AS x FROM x AS x, x AS x WHERE x.x = x.x AND x.x = x.x AND x.x <> ROUND(x.x, 80);
/* ****************************** */ /* * Square root check */ /* ****************************** */ DELETE FROM x;
INSERT INTO x SELECT x, 0, SQRT(ABS(x)) FROM x;
SELECT x.x, x.x, x.x FROM x AS x, x AS x WHERE x.x = x.x AND x.x <> x.x;
/* ****************************** */ /* * Natural logarithm check */ /* ****************************** */ DELETE FROM x;
INSERT INTO x SELECT x, 0, LN(ABS(x)) FROM x WHERE x <> '0.0';
SELECT x.x, x.x, x.x FROM x AS x, x AS x WHERE x.x = x.x AND x.x <> x.x;
/* ****************************** */ /* * Logarithm base 10 check */ /* ****************************** */ DELETE FROM x;
INSERT INTO x SELECT x, 0, LOG(CAST('10' AS DECIMAL), ABS(x)) FROM x WHERE x <> '0.0';
SELECT x.x, x.x, x.x FROM x AS x, x AS x WHERE x.x = x.x AND x.x <> x.x;
/* ****************************** */ /* * POWER(10, LN(value)) check */ /* ****************************** */ DELETE FROM x;
INSERT INTO x SELECT x, 0, POWER(CAST('10' AS DECIMAL), LN(ABS(ROUND(x, 200)))) FROM x WHERE x <> '0.0';
SELECT x.x, x.x, x.x FROM x AS x, x AS x WHERE x.x = x.x AND x.x <> x.x;
/* ****************************** */ /* * Check behavior with Inf and NaN inputs.  It's easiest to handle these */ /* * separately from the num_data framework used above, because some input */ /* * combinations will throw errors. */ /* ****************************** */ WITH x AS (SELECT * FROM (VALUES (CAST('0' AS DECIMAL)), ('1'), ('-1'), ('4.2'), ('inf'), ('-inf'), ('nan')) AS x) SELECT x, x, x + x AS x, x - x AS x, x * x AS x FROM x AS x, x AS x;
WITH x AS (SELECT * FROM (VALUES (CAST('0' AS DECIMAL)), ('1'), ('-1'), ('4.2'), ('inf'), ('-inf'), ('nan')) AS x) SELECT x, x, x / x AS x, x % x AS x, CAST(CAST(x / x AS INT) AS DECIMAL) AS x FROM x AS x, x AS x WHERE x <> 0;
SELECT CAST('inf' AS DECIMAL) / '0';
SELECT CAST('-inf' AS DECIMAL) / '0';
SELECT CAST('nan' AS DECIMAL) / '0';
SELECT CAST('0' AS DECIMAL) / '0';
SELECT CAST('inf' AS DECIMAL) % '0';
SELECT CAST('-inf' AS DECIMAL) % '0';
SELECT CAST('nan' AS DECIMAL) % '0';
SELECT CAST('0' AS DECIMAL) % '0';
SELECT CAST(CAST(CAST('inf' AS DECIMAL) / '0' AS INT) AS DECIMAL);
SELECT CAST(CAST(CAST('-inf' AS DECIMAL) / '0' AS INT) AS DECIMAL);
SELECT CAST(CAST(CAST('nan' AS DECIMAL) / '0' AS INT) AS DECIMAL);
SELECT CAST(CAST(CAST('0' AS DECIMAL) / '0' AS INT) AS DECIMAL);
WITH x AS (SELECT * FROM (VALUES (CAST('0' AS DECIMAL)), ('1'), ('-1'), ('4.2'), ('-7.777'), ('inf'), ('-inf'), ('nan')) AS x) SELECT x, -x AS x, ABS(x), FLOOR(x), CEIL(x), SIGN(x), NUMERIC_INC(x) AS x FROM x;
WITH x AS (SELECT * FROM (VALUES (CAST('0' AS DECIMAL)), ('1'), ('-1'), ('4.2'), ('-7.777'), ('inf'), ('-inf'), ('nan')) AS x) SELECT x, ROUND(x), ROUND(x, 1) AS x, TRUNC(x), TRUNC(x, 1) AS x FROM x;
/* the large values fall into the numeric abbreviation code's maximal classes */ WITH x AS (SELECT * FROM (VALUES (CAST('0' AS DECIMAL)), ('1'), ('-1'), ('4.2'), ('-7.777'), ('1e340'), ('-1e340'), ('inf'), ('-inf'), ('nan'), ('inf'), ('-inf'), ('nan')) AS x) SELECT SUBSTRING(CAST(x AS TEXT), 1, 32) FROM x ORDER BY x NULLS LAST;
WITH x AS (SELECT * FROM (VALUES (CAST('0' AS DECIMAL)), ('1'), ('4.2'), ('inf'), ('nan')) AS x) SELECT x, SQRT(x) FROM x;
SELECT SQRT(CAST('-1' AS DECIMAL));
SELECT SQRT(CAST('-inf' AS DECIMAL));
WITH x AS (SELECT * FROM (VALUES (CAST('1' AS DECIMAL)), ('4.2'), ('inf'), ('nan')) AS x) SELECT x, LOG(x), LOG(10, x), LN(x) FROM x;
SELECT LN(CAST('0' AS DECIMAL));
SELECT LN(CAST('-1' AS DECIMAL));
SELECT LN(CAST('-inf' AS DECIMAL));
WITH x AS (SELECT * FROM (VALUES (CAST('2' AS DECIMAL)), ('4.2'), ('inf'), ('nan')) AS x) SELECT x, x, LOG(x, x) FROM x AS x, x AS x;
SELECT LOG(CAST('0' AS DECIMAL), '10');
SELECT LOG(CAST('10' AS DECIMAL), '0');
SELECT LOG(CAST('-inf' AS DECIMAL), '10');
SELECT LOG(CAST('10' AS DECIMAL), '-inf');
SELECT LOG(CAST('inf' AS DECIMAL), '0');
SELECT LOG(CAST('inf' AS DECIMAL), '-inf');
SELECT LOG(CAST('-inf' AS DECIMAL), 'inf');
WITH x AS (SELECT * FROM (VALUES (CAST('0' AS DECIMAL)), ('1'), ('2'), ('4.2'), ('inf'), ('nan')) AS x) SELECT x, x, POWER(x, x) FROM x AS x, x AS x WHERE x <> 0 OR x >= 0;
SELECT POWER(CAST('0' AS DECIMAL), '-1');
SELECT POWER(CAST('0' AS DECIMAL), '-inf');
SELECT POWER(CAST('-1' AS DECIMAL), 'inf');
SELECT POWER(CAST('-2' AS DECIMAL), '3');
SELECT POWER(CAST('-2' AS DECIMAL), '3.3');
SELECT POWER(CAST('-2' AS DECIMAL), '-1');
SELECT POWER(CAST('-2' AS DECIMAL), '-1.5');
SELECT POWER(CAST('-2' AS DECIMAL), 'inf');
SELECT POWER(CAST('-2' AS DECIMAL), '-inf');
SELECT POWER(CAST('inf' AS DECIMAL), '-2');
SELECT POWER(CAST('inf' AS DECIMAL), '-inf');
SELECT POWER(CAST('-inf' AS DECIMAL), '2');
SELECT POWER(CAST('-inf' AS DECIMAL), '3');
SELECT POWER(CAST('-inf' AS DECIMAL), '4.5');
SELECT POWER(CAST('-inf' AS DECIMAL), '-2');
SELECT POWER(CAST('-inf' AS DECIMAL), '-3');
SELECT POWER(CAST('-inf' AS DECIMAL), '0');
SELECT POWER(CAST('-inf' AS DECIMAL), 'inf');
SELECT POWER(CAST('-inf' AS DECIMAL), '-inf');
/* ****************************** */ /* * miscellaneous checks for things that have been broken in the past... */ /* ****************************** */ /* numeric AVG used to fail on some platforms */ SELECT AVG(x) FROM x;
SELECT MAX(x) FROM x;
SELECT MIN(x) FROM x;
SELECT STDDEV(x) FROM x;
SELECT VARIANCE(x) FROM x;
/* Check for appropriate rounding and overflow */ CREATE TABLE x (x INT, x DECIMAL(4, 4));
INSERT INTO x VALUES (1, '0.0');
INSERT INTO x VALUES (2, '0.1');
INSERT INTO x VALUES (3, '1.0');
/* should fail */ INSERT INTO x VALUES (4, '-0.9999');
INSERT INTO x VALUES (5, '0.99994');
INSERT INTO x VALUES (6, '0.99995');
/* should fail */ INSERT INTO x VALUES (7, '0.00001');
INSERT INTO x VALUES (8, '0.00017');
INSERT INTO x VALUES (9, 'NaN');
INSERT INTO x VALUES (10, 'Inf');
/* should fail */ INSERT INTO x VALUES (11, '-Inf');
/* should fail */ SELECT * FROM x;
DROP TABLE x;
/* Check conversion to integers */ SELECT CAST((-9223372036854775808.5) AS BIGINT);
/* should fail */ SELECT CAST((-9223372036854775808.4) AS BIGINT);
/* ok */ SELECT CAST(9223372036854775807.4 AS BIGINT);
/* ok */ SELECT CAST(9223372036854775807.5 AS BIGINT);
/* should fail */ SELECT CAST((-2147483648.5) AS INT);
/* should fail */ SELECT CAST((-2147483648.4) AS INT);
/* ok */ SELECT CAST(2147483647.4 AS INT);
/* ok */ SELECT CAST(2147483647.5 AS INT);
/* should fail */ SELECT CAST((-32768.5) AS SMALLINT);
/* should fail */ SELECT CAST((-32768.4) AS SMALLINT);
/* ok */ SELECT CAST(32767.4 AS SMALLINT);
/* ok */ SELECT CAST(32767.5 AS SMALLINT);
/* should fail */ /* Check inf/nan conversion behavior */ SELECT CAST(CAST('NaN' AS DOUBLE) AS DECIMAL);
SELECT CAST(CAST('Infinity' AS DOUBLE) AS DECIMAL);
SELECT CAST(CAST('-Infinity' AS DOUBLE) AS DECIMAL);
SELECT CAST(CAST('NaN' AS DECIMAL) AS DOUBLE);
SELECT CAST(CAST('Infinity' AS DECIMAL) AS DOUBLE);
SELECT CAST(CAST('-Infinity' AS DECIMAL) AS DOUBLE);
SELECT CAST(CAST('NaN' AS FLOAT) AS DECIMAL);
SELECT CAST(CAST('Infinity' AS FLOAT) AS DECIMAL);
SELECT CAST(CAST('-Infinity' AS FLOAT) AS DECIMAL);
SELECT CAST(CAST('NaN' AS DECIMAL) AS FLOAT);
SELECT CAST(CAST('Infinity' AS DECIMAL) AS FLOAT);
SELECT CAST(CAST('-Infinity' AS DECIMAL) AS FLOAT);
SELECT CAST(CAST('42' AS SMALLINT) AS DECIMAL);
SELECT CAST(CAST('NaN' AS DECIMAL) AS SMALLINT);
SELECT CAST(CAST('Infinity' AS DECIMAL) AS SMALLINT);
SELECT CAST(CAST('-Infinity' AS DECIMAL) AS SMALLINT);
SELECT CAST(CAST('NaN' AS DECIMAL) AS INT);
SELECT CAST(CAST('Infinity' AS DECIMAL) AS INT);
SELECT CAST(CAST('-Infinity' AS DECIMAL) AS INT);
SELECT CAST(CAST('NaN' AS DECIMAL) AS BIGINT);
SELECT CAST(CAST('Infinity' AS DECIMAL) AS BIGINT);
SELECT CAST(CAST('-Infinity' AS DECIMAL) AS BIGINT);
/* Simple check that ceil(), floor(), and round() work correctly */ CREATE TABLE x (x DECIMAL);
INSERT INTO x VALUES ('-5.5');
INSERT INTO x VALUES ('-5.499999');
INSERT INTO x VALUES ('9.5');
INSERT INTO x VALUES ('9.4999999');
INSERT INTO x VALUES ('0.0');
INSERT INTO x VALUES ('0.0000001');
INSERT INTO x VALUES ('-0.000001');
SELECT x, CEIL(x), CEIL(x), FLOOR(x), ROUND(x) FROM x;
DROP TABLE x;
/* Check rounding, it should round ties away from zero. */ SELECT x AS x, ROUND(CAST((-2.5 * POWER(10, x)) AS DECIMAL), -x), ROUND(CAST((-1.5 * POWER(10, x)) AS DECIMAL), -x), ROUND(CAST((-0.5 * POWER(10, x)) AS DECIMAL), -x), ROUND(CAST((0.5 * POWER(10, x)) AS DECIMAL), -x), ROUND(CAST((1.5 * POWER(10, x)) AS DECIMAL), -x), ROUND(CAST((2.5 * POWER(10, x)) AS DECIMAL), -x) FROM x AS x;
/* Check limits of rounding before the decimal point */ SELECT ROUND(4.4e131071, -131071) = 4e131071;
SELECT ROUND(4.5e131071, -131071) = 5e131071;
SELECT ROUND(4.5e131071, -131072);
/* loses all digits */ SELECT ROUND(5.5e131071, -131072);
/* rounds up and overflows */ SELECT ROUND(5.5e131071, -131073);
/* loses all digits */ SELECT ROUND(5.5e131071, -1000000);
/* loses all digits */ /* Check limits of rounding after the decimal point */ SELECT ROUND(5e-16383, 1000000) = 5e-16383;
SELECT ROUND(5e-16383, 16383) = 5e-16383;
SELECT ROUND(5e-16383, 16382) = 1e-16382;
SELECT ROUND(5e-16383, 16381) = 0;
/* Check limits of trunc() before the decimal point */ SELECT TRUNC(9.9e131071, -131071) = 9e131071;
SELECT TRUNC(9.9e131071, -131072);
/* loses all digits */ SELECT TRUNC(9.9e131071, -131073);
/* loses all digits */ SELECT TRUNC(9.9e131071, -1000000);
/* loses all digits */ /* Check limits of trunc() after the decimal point */ SELECT TRUNC(5e-16383, 1000000) = 5e-16383;
SELECT TRUNC(5e-16383, 16383) = 5e-16383;
SELECT TRUNC(5e-16383, 16382) = 0;
/* Testing for width_bucket(). For convenience, we test both the */ /* numeric and float8 versions of the function in this file. */ /* errors */ SELECT WIDTH_BUCKET(5.0, 3.0, 4.0, 0);
SELECT WIDTH_BUCKET(5.0, 3.0, 4.0, -5);
SELECT WIDTH_BUCKET(3.5, 3.0, 3.0, 888);
SELECT WIDTH_BUCKET(CAST(5.0 AS DOUBLE), CAST(3.0 AS DOUBLE), CAST(4.0 AS DOUBLE), 0);
SELECT WIDTH_BUCKET(CAST(5.0 AS DOUBLE), CAST(3.0 AS DOUBLE), CAST(4.0 AS DOUBLE), -5);
SELECT WIDTH_BUCKET(CAST(3.5 AS DOUBLE), CAST(3.0 AS DOUBLE), CAST(3.0 AS DOUBLE), 888);
SELECT WIDTH_BUCKET('NaN', 3.0, 4.0, 888);
SELECT WIDTH_BUCKET(CAST(0 AS DOUBLE), 'NaN', CAST(4.0 AS DOUBLE), 888);
SELECT WIDTH_BUCKET(2.0, 3.0, '-inf', 888);
SELECT WIDTH_BUCKET(CAST(0 AS DOUBLE), '-inf', CAST(4.0 AS DOUBLE), 888);
/* normal operation */ CREATE TABLE x (x DECIMAL, x DOUBLE);
COPY INTO x (x) FROM x;
SELECT x, WIDTH_BUCKET(x, 0, 10, 5) AS x, WIDTH_BUCKET(x, 0, 10, 5) AS x, WIDTH_BUCKET(x, 10, 0, 5) AS x, WIDTH_BUCKET(x, 10, 0, 5) AS x, WIDTH_BUCKET(x, 2, 8, 4) AS x, WIDTH_BUCKET(x, 2, 8, 4) AS x, WIDTH_BUCKET(x, 5.0, 5.5, 20) AS x, WIDTH_BUCKET(x, 5.0, 5.5, 20) AS x, WIDTH_BUCKET(x, -25, 25, 10) AS x, WIDTH_BUCKET(x, -25, 25, 10) AS x FROM x;
/* Check positive and negative infinity: we require */ /* finite bucket bounds, but allow an infinite operand */ SELECT WIDTH_BUCKET(CAST(0.0 AS DECIMAL), CAST('Infinity' AS DECIMAL), 5, 10);
/* error */ SELECT WIDTH_BUCKET(CAST(0.0 AS DECIMAL), 5, CAST('-Infinity' AS DECIMAL), 20);
/* error */ SELECT WIDTH_BUCKET(CAST('Infinity' AS DECIMAL), 1, 10, 10), WIDTH_BUCKET(CAST('-Infinity' AS DECIMAL), 1, 10, 10);
SELECT WIDTH_BUCKET(CAST(0.0 AS DOUBLE), CAST('Infinity' AS DOUBLE), 5, 10);
/* error */ SELECT WIDTH_BUCKET(CAST(0.0 AS DOUBLE), 5, CAST('-Infinity' AS DOUBLE), 20);
/* error */ SELECT WIDTH_BUCKET(CAST('Infinity' AS DOUBLE), 1, 10, 10), WIDTH_BUCKET(CAST('-Infinity' AS DOUBLE), 1, 10, 10);
DROP TABLE x;
/* Simple test for roundoff error when results should be exact */ SELECT x, WIDTH_BUCKET(CAST(x AS DOUBLE), 10, 100, 9) AS x, WIDTH_BUCKET(CAST(x AS DECIMAL), 10, 100, 9) AS x FROM x AS x;
SELECT x, WIDTH_BUCKET(CAST(x AS DOUBLE), 100, 10, 9) AS x, WIDTH_BUCKET(CAST(x AS DECIMAL), 100, 10, 9) AS x FROM x AS x;
/* Another roundoff-error hazard */ SELECT WIDTH_BUCKET(0, -CAST(1e100 AS DECIMAL), 1, 10);
SELECT WIDTH_BUCKET(0, -CAST(1e100 AS DOUBLE), 1, 10);
SELECT WIDTH_BUCKET(1, CAST(1e100 AS DECIMAL), 0, 10);
SELECT WIDTH_BUCKET(1, CAST(1e100 AS DOUBLE), 0, 10);
/* Check cases that could trigger overflow or underflow within the calculation */ SELECT x, x, x, x, WIDTH_BUCKET(x, x, x, x) FROM (SELECT CAST(1.797e+308 AS DOUBLE) AS x, CAST(5e-324 AS DOUBLE) AS x) AS x, LATERAL (VALUES (CAST(10.5 AS DOUBLE), -x, x, 1), (CAST(10.5 AS DOUBLE), -x, x, 2), (CAST(10.5 AS DOUBLE), -x, x, 3), (x / 4, -x / 2, x / 2, 10), (CAST(10.5 AS DOUBLE), x, -x, 1), (CAST(10.5 AS DOUBLE), x, -x, 2), (CAST(10.5 AS DOUBLE), x, -x, 3), (x / 4, x / 2, -x / 2, 10), (0, 0, x, 4), (x, 0, x, 4), (0, 0, 1, 2147483647), (1, 1, 0, 2147483647)) AS x;
/* These fail because the result would be out of int32 range: */ SELECT WIDTH_BUCKET(CAST(1 AS DOUBLE), 0, 1, 2147483647);
SELECT WIDTH_BUCKET(CAST(0 AS DOUBLE), 1, 0, 2147483647);
/* TO_CHAR() */ SELECT TIME_TO_STR(x, '9G999G999G999G999G999') FROM x;
SELECT TIME_TO_STR(x, '9G999G999G999G999G999%u999G999G999G999G999') FROM x;
SELECT TIME_TO_STR(x, '9999999999999999.999999999999999PR') FROM x;
SELECT TIME_TO_STR(x, '9999999999999999.999999999999999S') FROM x;
SELECT TIME_TO_STR(x, '%M9999999999999999.999999999999999') FROM x;
SELECT TIME_TO_STR(x, 'FMS9999999999999999.999999999999999') FROM x;
SELECT TIME_TO_STR(x, 'FM9999999999999999.999999999999999THPR') FROM x;
SELECT TIME_TO_STR(x, 'SG9999999999999999.999999999999999th') FROM x;
SELECT TIME_TO_STR(x, '0999999999999999.999999999999999') FROM x;
SELECT TIME_TO_STR(x, 'S0999999999999999.999999999999999') FROM x;
SELECT TIME_TO_STR(x, 'FM0999999999999999.999999999999999') FROM x;
SELECT TIME_TO_STR(x, 'FM9999999999999999.099999999999999') FROM x;
SELECT TIME_TO_STR(x, 'FM9999999999990999.990999999999999') FROM x;
SELECT TIME_TO_STR(x, 'FM0999999999999999.999909999999999') FROM x;
SELECT TIME_TO_STR(x, 'FM9999999990999999.099999999999999') FROM x;
SELECT TIME_TO_STR(x, 'L9999999999999999.099999999999999') FROM x;
SELECT TIME_TO_STR(x, 'FM9999999999999999.99999999999999') FROM x;
SELECT TIME_TO_STR(x, 'S 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 . 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9') FROM x;
SELECT TIME_TO_STR(x, 'FMS 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 . 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9') FROM x;
SELECT TIME_TO_STR(x, 99999 "text" 9999 "9999" 999 "\\"text between quote marks\\"" 9999) FROM x;
SELECT TIME_TO_STR(x, '999999SG9999999999') FROM x;
SELECT TIME_TO_STR(x, 'FM9999999999999999.999999999999999') FROM x;
SELECT TIME_TO_STR(x, '9.999EEEE') FROM x;
SELECT TIME_TO_STR(x, 'FMRN') FROM x;
WITH x AS (SELECT * FROM (VALUES (CAST('0' AS DECIMAL)), ('-4.2'), ('4.2e9'), ('1.2e-5'), ('inf'), ('-inf'), ('nan')) AS x) SELECT x, TIME_TO_STR(x, '9.999EEEE') AS x, TIME_TO_STR(CAST(x AS DOUBLE), '9.999EEEE') AS x, TIME_TO_STR(CAST(x AS FLOAT), '9.999EEEE') AS x FROM x;
WITH x AS (SELECT * FROM (VALUES (-16379), (-16378), (-1234), (-789), (-45), (-5), (-4), (-3), (-2), (-1), (0), (1), (2), (3), (4), (5), (38), (275), (2345), (45678), (131070), (131071)) AS x) SELECT x, TIME_TO_STR(CAST(('1.2345e' || x) AS DECIMAL), '9.999EEEE') AS x FROM x;
WITH x AS (SELECT * FROM (VALUES (CAST('0' AS DECIMAL)), ('-4.2'), ('4.2e9'), ('1.2e-5'), ('inf'), ('-inf'), ('nan')) AS x) SELECT x, TIME_TO_STR(x, '%M9999999999.99') AS x, TIME_TO_STR(CAST(x AS DOUBLE), '%M9999999999.99') AS x, TIME_TO_STR(CAST(x AS FLOAT), '%M9999999999.99') AS x FROM x;
WITH x AS (SELECT * FROM (VALUES (CAST('0' AS DECIMAL)), ('-4.2'), ('4.2e9'), ('1.2e-5'), ('inf'), ('-inf'), ('nan')) AS x) SELECT x, TIME_TO_STR(x, '%M99.99') AS x, TIME_TO_STR(CAST(x AS DOUBLE), '%M99.99') AS x, TIME_TO_STR(CAST(x AS FLOAT), '%M99.99') AS x FROM x;
SELECT TIME_TO_STR(CAST('100' AS DECIMAL), 'FM999.9');
SELECT TIME_TO_STR(CAST('100' AS DECIMAL), 'FM999.');
SELECT TIME_TO_STR(CAST('100' AS DECIMAL), 'FM999');
SELECT TIME_TO_STR(CAST('12345678901' AS DOUBLE), 'FM9999999999%u9999900000000000000000');
SELECT TIME_TO_STR(CAST('100' AS DECIMAL), 'rn');
SELECT TIME_TO_STR(CAST('1234' AS DECIMAL), 'rn');
SELECT TIME_TO_STR(CAST('1235' AS FLOAT), 'rn');
SELECT TIME_TO_STR(CAST('1236' AS DOUBLE), 'rn');
SELECT TIME_TO_STR(CAST('1237' AS DOUBLE), 'fmrn');
SELECT TIME_TO_STR(CAST('100e9' AS DECIMAL), 'RN');
SELECT TIME_TO_STR(CAST('100e9' AS FLOAT), 'RN');
SELECT TIME_TO_STR(CAST('100e9' AS DOUBLE), 'RN');
SELECT TIME_TO_STR(CAST(1234.56 AS DECIMAL), '99999V99');
SELECT TIME_TO_STR(CAST(1234.56 AS FLOAT), '99999V99');
SELECT TIME_TO_STR(CAST(1234.56 AS DOUBLE), '99999V99');
/* Check parsing of literal text in a format string */ SELECT TIME_TO_STR(CAST('100' AS DECIMAL), 'foo999');
SELECT TIME_TO_STR(CAST('100' AS DECIMAL), 'f\oo999');
SELECT TIME_TO_STR(CAST('100' AS DECIMAL), 'f\\oo999');
SELECT TIME_TO_STR(CAST('100' AS DECIMAL), 'f\"oo999');
SELECT TIME_TO_STR(CAST('100' AS DECIMAL), 'f\\"oo999');
SELECT TIME_TO_STR(CAST('100' AS DECIMAL), 'f"ool"999');
SELECT TIME_TO_STR(CAST('100' AS DECIMAL), 'f"\ool"999');
SELECT TIME_TO_STR(CAST('100' AS DECIMAL), 'f"\\ool"999');
SELECT TIME_TO_STR(CAST('100' AS DECIMAL), 'f"ool\"999');
SELECT TIME_TO_STR(CAST('100' AS DECIMAL), 'f"ool\\"999');
SET x = 'C' /* TO_NUMBER() */;
SELECT TO_NUMBER('-34,338,492', '99G999G999');
SELECT TO_NUMBER('-34,338,492.654,878', '99G999G999D999G999');
SELECT TO_NUMBER('<564646.654564>', '999999.999999PR');
SELECT TO_NUMBER('0.00001-', '9.999999S');
SELECT TO_NUMBER('5.01-', 'FM9.999999S');
SELECT TO_NUMBER('5.01-', 'FM9.999999MI');
SELECT TO_NUMBER('5 4 4 4 4 8 . 7 8', '9 9 9 9 9 9 . 9 9');
SELECT TO_NUMBER('.01', 'FM9.99');
SELECT TO_NUMBER('.0', '99999999.99999999');
SELECT TO_NUMBER('0', '99.99');
SELECT TO_NUMBER('.-01', 'S99.99');
SELECT TO_NUMBER('.01-', '99.99S');
SELECT TO_NUMBER(' . 0 1-', ' 9 9 . 9 9 S');
SELECT TO_NUMBER('34,50', '999,99');
SELECT TO_NUMBER('123,000', '999G');
SELECT TO_NUMBER('123456', '999G999');
SELECT TO_NUMBER('$1234.56', 'L9,999.99');
SELECT TO_NUMBER('$1234.56', 'L99,999.99');
SELECT TO_NUMBER('$1,234.56', 'L99,999.99');
SELECT TO_NUMBER('1234.56', 'L99,999.99');
SELECT TO_NUMBER('1,234.56', 'L99,999.99');
SELECT TO_NUMBER('42nd', '99th');
SELECT TO_NUMBER('123456', '99999V99');
/* Test for correct conversion between numbers and Roman numerals */ WITH x AS (SELECT x, TIME_TO_STR(x, 'RN') AS x FROM x AS x) SELECT LOGICAL_AND(TO_NUMBER(x, 'RN') = x) AS x FROM x;
/* Some additional tests for RN input */ SELECT TO_NUMBER('CvIiI', 'rn');
SELECT TO_NUMBER('MMXX  ', 'RN');
SELECT TO_NUMBER('  XIV', '  RN');
SELECT TO_NUMBER('  XIV  ', '  RN');
SELECT TO_NUMBER('M CC', 'RN');
/* error cases */ SELECT TO_NUMBER('viv', 'RN');
SELECT TO_NUMBER('DCCCD', 'RN');
SELECT TO_NUMBER('XIXL', 'RN');
SELECT TO_NUMBER('MCCM', 'RN');
SELECT TO_NUMBER('MMMM', 'RN');
SELECT TO_NUMBER('VV', 'RN');
SELECT TO_NUMBER('IL', 'RN');
SELECT TO_NUMBER('VIX', 'RN');
SELECT TO_NUMBER('LXC', 'RN');
SELECT TO_NUMBER('DCM', 'RN');
SELECT TO_NUMBER('MMMDCM', 'RN');
SELECT TO_NUMBER('CLXC', 'RN');
SELECT TO_NUMBER('CM', 'MIRN');
SELECT TO_NUMBER('CM', 'RNRN');
SELECT TO_NUMBER('qiv', 'RN');
SELECT TO_NUMBER('', 'RN');
SELECT TO_NUMBER(' ', 'RN');
RESET lc_numeric;
/* Input syntax */ CREATE TABLE x (x DECIMAL);
/* good inputs */ INSERT INTO x (x) VALUES (' 123');
INSERT INTO x (x) VALUES ('   3245874    ');
INSERT INTO x (x) VALUES ('  -93853');
INSERT INTO x (x) VALUES ('555.50');
INSERT INTO x (x) VALUES ('-555.50');
INSERT INTO x (x) VALUES ('NaN ');
INSERT INTO x (x) VALUES ('        nan');
INSERT INTO x (x) VALUES (' inf ');
INSERT INTO x (x) VALUES (' +inf ');
INSERT INTO x (x) VALUES (' -inf ');
INSERT INTO x (x) VALUES (' Infinity ');
INSERT INTO x (x) VALUES (' +inFinity ');
INSERT INTO x (x) VALUES (' -INFINITY ');
INSERT INTO x (x) VALUES ('12_000_000_000');
INSERT INTO x (x) VALUES ('12_000.123_456');
INSERT INTO x (x) VALUES ('23_000_000_000e-1_0');
INSERT INTO x (x) VALUES ('.000_000_000_123e1_0');
INSERT INTO x (x) VALUES ('.000_000_000_123e+1_1');
INSERT INTO x (x) VALUES ('0b10001110111100111100001001010');
INSERT INTO x (x) VALUES ('  -0B_1010_1011_0101_0100_1010_1001_1000_1100_1110_1011_0001_1111_0000_1010_1101_0010  ');
INSERT INTO x (x) VALUES ('  +0o112402761777 ');
INSERT INTO x (x) VALUES ('-0O0012_5524_5230_6334_3167_0261');
INSERT INTO x (x) VALUES ('-0x0000000000000000000000000deadbeef');
INSERT INTO x (x) VALUES (' 0X_30b1_F33a_6DF0_bD4E_64DF_9BdA_7D15 ');
/* bad inputs */ INSERT INTO x (x) VALUES ('     ');
INSERT INTO x (x) VALUES ('   1234   %');
INSERT INTO x (x) VALUES ('xyz');
INSERT INTO x (x) VALUES ('- 1234');
INSERT INTO x (x) VALUES ('5 . 0');
INSERT INTO x (x) VALUES ('5. 0   ');
INSERT INTO x (x) VALUES ('');
INSERT INTO x (x) VALUES (' N aN ');
INSERT INTO x (x) VALUES ('+NaN');
INSERT INTO x (x) VALUES ('-NaN');
INSERT INTO x (x) VALUES ('+ infinity');
INSERT INTO x (x) VALUES ('_123');
INSERT INTO x (x) VALUES ('123_');
INSERT INTO x (x) VALUES ('12__34');
INSERT INTO x (x) VALUES ('123_.456');
INSERT INTO x (x) VALUES ('123._456');
INSERT INTO x (x) VALUES ('1.2e_34');
INSERT INTO x (x) VALUES ('1.2e34_');
INSERT INTO x (x) VALUES ('1.2e3__4');
INSERT INTO x (x) VALUES ('0b1112');
INSERT INTO x (x) VALUES ('0c1112');
INSERT INTO x (x) VALUES ('0o12345678');
INSERT INTO x (x) VALUES ('0x1eg');
INSERT INTO x (x) VALUES ('0x12.34');
INSERT INTO x (x) VALUES ('0x__1234');
INSERT INTO x (x) VALUES ('0x1234_');
INSERT INTO x (x) VALUES ('0x12__34');
SELECT * FROM x;
/* Also try it with non-error-throwing API */ SELECT PG_INPUT_IS_VALID('34.5', 'numeric');
SELECT PG_INPUT_IS_VALID('34xyz', 'numeric');
SELECT PG_INPUT_IS_VALID('1e400000', 'numeric');
SELECT * FROM x;
SELECT PG_INPUT_IS_VALID('1234.567', 'numeric(8,4)');
SELECT PG_INPUT_IS_VALID('1234.567', 'numeric(7,4)');
SELECT * FROM x;
SELECT * FROM x;
INSERT INTO x VALUES (654321, 654, 0.654, 0.000654, 0.000000654);
INSERT INTO x VALUES (2345678, 2345, 2.345, 0.002345, 0.000002345);
INSERT INTO x VALUES (7654321, 7654, 7.654, 0.007654, 0.000007654);
INSERT INTO x VALUES (12345678, 12345, 12.345, 0.012345, 0.000012345);
INSERT INTO x VALUES (87654321, 87654, 87.654, 0.087654, 0.000087654);
INSERT INTO x VALUES (123456789, 123456, 123.456, 0.123456, 0.000123456);
INSERT INTO x VALUES (987654321, 987654, 987.654, 0.987654, 0.000987654);
INSERT INTO x VALUES ('NaN', 'NaN', 'NaN', 'NaN', 'NaN');
SELECT SCALE(x), * FROM x ORDER BY x NULLS LAST;
/* invalid inputs */ INSERT INTO x (x) VALUES ('inf');
INSERT INTO x (x) VALUES (999500000);
INSERT INTO x (x) VALUES (999500);
INSERT INTO x (x) VALUES (999.5);
INSERT INTO x (x) VALUES (0.9995);
INSERT INTO x (x) VALUES (0.0009995);
/* Test some corner cases for multiplication */ SELECT 4790999999999999999999999999999999999999999999999999999999999999999999999999999999999999 * 9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999;
SELECT 4789999999999999999999999999999999999999999999999999999999999999999999999999999999999999 * 9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999;
SELECT 4770999999999999999999999999999999999999999999999999999999999999999999999999999999999999 * 9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999;
SELECT 4769999999999999999999999999999999999999999999999999999999999999999999999999999999999999 * 9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999;
SELECT TRIM_SCALE((0.1 - 2e-16383) * (0.1 - 3e-16383));
/* Test some corner cases for division */ SELECT CAST(999999999999999999999 AS DECIMAL) / 1000000000000000000000;
SELECT CAST(CAST(CAST(999999999999999999999 AS DECIMAL) / 1000000000000000000000 AS INT) AS DECIMAL);
SELECT CAST(999999999999999999999 AS DECIMAL) % 1000000000000000000000;
SELECT CAST(CAST(-CAST(9999999999999999999999 AS DECIMAL) / 1000000000000000000000 AS INT) AS DECIMAL);
SELECT -CAST(9999999999999999999999 AS DECIMAL) % 1000000000000000000000;
SELECT CAST(CAST(-CAST(9999999999999999999999 AS DECIMAL) / 1000000000000000000000 AS INT) AS DECIMAL) * 1000000000000000000000 + -CAST(9999999999999999999999 AS DECIMAL) % 1000000000000000000000;
SELECT 70.0 % 70;
SELECT CAST(CAST(70.0 / 70 AS INT) AS DECIMAL);
SELECT 70.0 / 70;
SELECT 12345678901234567890 % 123;
SELECT 12345678901234567890 / 123;
SELECT CAST(CAST(12345678901234567890 / 123 AS INT) AS DECIMAL);
SELECT CAST(CAST(12345678901234567890 / 123 AS INT) AS DECIMAL) * 123 + 12345678901234567890 % 123;
SELECT 8e9000 - CAST(CAST(8e18000 - 1 / 9e9000 - 1 AS INT) AS DECIMAL) * 9;
SELECT 7328412092 - CAST(CAST(53705623790171816464 - 1 / 7328412092 AS INT) AS DECIMAL);
SELECT CAST(CAST(539913372912345678 / 539913372912345678 AS INT) AS DECIMAL);
/* Test some corner cases for square root */ SELECT SQRT(CAST(1.000000000000003 AS DECIMAL));
SELECT SQRT(CAST(1.000000000000004 AS DECIMAL));
SELECT SQRT(CAST(96627521408608.56340355805 AS DECIMAL));
SELECT SQRT(CAST(96627521408608.56340355806 AS DECIMAL));
SELECT SQRT(CAST(515549506212297735.073688290367 AS DECIMAL));
SELECT SQRT(CAST(515549506212297735.073688290368 AS DECIMAL));
SELECT SQRT(CAST(8015491789940783531003294973900306 AS DECIMAL));
SELECT SQRT(CAST(8015491789940783531003294973900307 AS DECIMAL));
/* Test code path for raising to integer powers */ SELECT POWER(10.0, -2147483648) AS x;
SELECT POWER(10.0, -2147483647) AS x;
SELECT POWER(10.0, 2147483647) AS x;
SELECT POWER(117743296169.0, 1000000000) AS x;
/* cases that used to return inaccurate results */ SELECT POWER(3.789, 21.0000000000000000);
SELECT POWER(3.789, 35.0000000000000000);
SELECT POWER(1.2, 345);
SELECT POWER(0.12, (-20));
SELECT POWER(1.000000000123, (-2147483648));
SELECT COALESCE(NULLIF(POWER(0.9999999999, 23300000000000), 0), 0) AS x;
SELECT ROUND((POWER((1 - 1.500012345678e-1000), 1.45e1003)) * 1e1000);
/* cases that used to error out */ SELECT POWER(0.12, (-25));
SELECT POWER(0.5678, (-85));
SELECT COALESCE(NULLIF(POWER(0.9999999999, 70000000000000), 0), 0) AS x;
/* negative base to integer powers */ SELECT POWER((-1.0), 2147483646);
SELECT POWER((-1.0), 2147483647);
SELECT POWER((-1.0), 2147483648);
SELECT POWER((-1.0), 1000000000000000);
SELECT POWER((-1.0), 1000000000000001);
/* integer powers of 10 */ SELECT x, POWER(10.0, x) AS "x", (POWER(10.0, x)) * (POWER(10.0, (-x))) = 1 AS x FROM x AS x;
/* Tests for raising to non-integer powers */ /* special cases */ SELECT POWER(0.0, 0.0);
SELECT POWER((-12.34), 0.0);
SELECT POWER(12.34, 0.0);
SELECT POWER(0.0, 12.34);
/* NaNs */ SELECT POWER(CAST('NaN' AS DECIMAL), CAST('NaN' AS DECIMAL));
SELECT POWER(CAST('NaN' AS DECIMAL), 0);
SELECT POWER(CAST('NaN' AS DECIMAL), 1);
SELECT POWER(0, CAST('NaN' AS DECIMAL));
SELECT POWER(1, CAST('NaN' AS DECIMAL));
/* invalid inputs */ SELECT POWER(0.0, (-12.34));
SELECT POWER((-12.34), 1.2);
/* cases that used to generate inaccurate results */ SELECT POWER(32.1, 9.8);
SELECT POWER(32.1, (-9.8));
SELECT POWER(12.3, 45.6);
SELECT POWER(12.3, (-45.6));
/* big test */ SELECT POWER(1.234, 5678);
/* Tests for EXP() */ /* special cases */ SELECT EXP(0.0);
SELECT EXP(1.0);
SELECT EXP(CAST(1.0 AS DECIMAL(71, 70)));
SELECT EXP(CAST('nan' AS DECIMAL));
SELECT EXP(CAST('inf' AS DECIMAL));
SELECT EXP(CAST('-inf' AS DECIMAL));
SELECT COALESCE(NULLIF(EXP(-CAST(5000 AS DECIMAL)), 0), 0) AS x;
SELECT COALESCE(NULLIF(EXP(-CAST(10000 AS DECIMAL)), 0), 0) AS x;
/* cases that used to generate inaccurate results */ SELECT EXP(32.999);
SELECT EXP(-32.999);
SELECT EXP(123.456);
SELECT EXP(-123.456);
/* big test */ SELECT EXP(1234.5678);
/* Tests for generate_series */ SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
/* Trigger errors */ SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
/* Checks maximum, output is truncated */ SELECT CAST((x / (POWER(CAST(10 AS DECIMAL), 131071))) AS DECIMAL(1, 0)) FROM x AS x;
/* Check usage with variables */ SELECT * FROM x AS x, x AS x;
SELECT * FROM x AS x, x AS x;
SELECT * FROM x AS x, x AS x;
/* Tests for LN() */ /* Invalid inputs */ SELECT LN(-12.34);
SELECT LN(0.0);
/* Some random tests */ SELECT LN(1.2345678e-28);
SELECT LN(0.0456789);
SELECT LN(0.349873948359354029493948309745709580730482050975);
SELECT LN(0.99949452);
SELECT LN(1.00049687395);
SELECT LN(1234.567890123456789);
SELECT LN(5.80397490724e5);
SELECT LN(9.342536355e34);
/* Tests for LOG() (base 10) */ /* invalid inputs */ SELECT LOG(-12.34);
SELECT LOG(0.0);
/* some random tests */ SELECT LOG(1.234567e-89);
SELECT LOG(3.4634998359873254962349856073435545);
SELECT LOG(9.999999999999999999);
SELECT LOG(10.00000000000000000);
SELECT LOG(10.00000000000000001);
SELECT LOG(590489.45235237);
/* Tests for LOG() (arbitrary base) */ /* invalid inputs */ SELECT LOG(-12.34, 56.78);
SELECT LOG(-12.34, -56.78);
SELECT LOG(12.34, -56.78);
SELECT LOG(0.0, 12.34);
SELECT LOG(12.34, 0.0);
SELECT LOG(1.0, 12.34);
/* some random tests */ SELECT LOG(1.23e-89, 6.4689e45);
SELECT LOG(0.99923, 4.58934e34);
SELECT LOG(1.000016, 8.452010e18);
SELECT LOG(3.1954752e47, 9.4792021e-73);
/* Tests for scale() */ SELECT SCALE(CAST('NaN' AS DECIMAL));
SELECT SCALE(CAST('inf' AS DECIMAL));
SELECT SCALE(CAST(NULL AS DECIMAL));
SELECT SCALE(1.12);
SELECT SCALE(0);
SELECT SCALE(0.00);
SELECT SCALE(1.12345);
SELECT SCALE(110123.12475871856128);
SELECT SCALE(-1123.12471856128);
SELECT SCALE(-13.000000000000000);
/* Tests for min_scale() */ SELECT MIN_SCALE(CAST('NaN' AS DECIMAL)) IS NULL;
/* should be true */ SELECT MIN_SCALE(CAST('inf' AS DECIMAL)) IS NULL;
/* should be true */ SELECT MIN_SCALE(0);
/* no digits */ SELECT MIN_SCALE(0.00);
/* no digits again */ SELECT MIN_SCALE(1.0);
/* no scale */ SELECT MIN_SCALE(1.1);
/* scale 1 */ SELECT MIN_SCALE(1.12);
/* scale 2 */ SELECT MIN_SCALE(1.123);
/* scale 3 */ SELECT MIN_SCALE(1.1234);
/* scale 4, filled digit */ SELECT MIN_SCALE(1.12345);
/* scale 5, 2 NDIGITS */ SELECT MIN_SCALE(1.1000);
/* 1 pos in NDIGITS */ SELECT MIN_SCALE(1e100);
/* very big number */ /* Tests for trim_scale() */ SELECT TRIM_SCALE(CAST('NaN' AS DECIMAL));
SELECT TRIM_SCALE(CAST('inf' AS DECIMAL));
SELECT TRIM_SCALE(1.120);
SELECT TRIM_SCALE(0);
SELECT TRIM_SCALE(0.00);
SELECT TRIM_SCALE(1.1234500);
SELECT TRIM_SCALE(110123.12475871856128000);
SELECT TRIM_SCALE(-1123.124718561280000000);
SELECT TRIM_SCALE(-13.00000000000000000000);
SELECT TRIM_SCALE(1e100);
/* Tests for SUM() */ /* cases that need carry propagation */ SELECT SUM(CAST(9999 AS DECIMAL)) FROM x;
SELECT SUM(CAST((-9999) AS DECIMAL)) FROM x;
/* Tests for VARIANCE() */ CREATE TABLE x (x DECIMAL);
INSERT INTO x VALUES (0);
INSERT INTO x VALUES (3e-500);
INSERT INTO x VALUES (-3e-500);
INSERT INTO x VALUES (4e-500 - 1e-16383);
INSERT INTO x VALUES (-4e-500 + 1e-16383);
/* variance is just under 12.5e-1000 and so should round down to 12e-1000 */ SELECT TRIM_SCALE(VARIANCE(x) * 1e1000) FROM x;
/* check that parallel execution produces the same result */ BEGIN;
ALTER TABLE x SET x = 4;
SET LOCAL x = 0;
SET LOCAL x = 4;
SELECT TRIM_SCALE(VARIANCE(x) * 1e1000) FROM x;
ROLLBACK;
/* case where sum of squares would overflow but variance does not */ DELETE FROM x;
INSERT INTO x SELECT 9e131071 + x FROM x AS x;
SELECT VARIANCE(x) FROM x;
/* check that parallel execution produces the same result */ BEGIN;
ALTER TABLE x SET x = 4;
SET LOCAL x = 0;
SET LOCAL x = 4;
SELECT VARIANCE(x) FROM x;
ROLLBACK;
DROP TABLE x;
/* Tests for GCD() */ SELECT x, x, GCD(x, x), GCD(x, -x), GCD(-x, x), GCD(-x, -x) FROM (VALUES (CAST(0 AS DECIMAL), CAST(0 AS DECIMAL)), (CAST(0 AS DECIMAL), CAST('NaN' AS DECIMAL)), (CAST(0 AS DECIMAL), CAST(46375 AS DECIMAL)), (CAST(433125 AS DECIMAL), CAST(46375 AS DECIMAL)), (CAST(43312.5 AS DECIMAL), CAST(4637.5 AS DECIMAL)), (CAST(4331.250 AS DECIMAL), CAST(463.75000 AS DECIMAL)), ('inf', '0'), ('inf', '42'), ('inf', 'inf')) AS x;
/* Tests for LCM() */ SELECT x, x, LCM(x, x), LCM(x, -x), LCM(-x, x), LCM(-x, -x) FROM (VALUES (CAST(0 AS DECIMAL), CAST(0 AS DECIMAL)), (CAST(0 AS DECIMAL), CAST('NaN' AS DECIMAL)), (CAST(0 AS DECIMAL), CAST(13272 AS DECIMAL)), (CAST(13272 AS DECIMAL), CAST(13272 AS DECIMAL)), (CAST(423282 AS DECIMAL), CAST(13272 AS DECIMAL)), (CAST(42328.2 AS DECIMAL), CAST(1327.2 AS DECIMAL)), (CAST(4232.820 AS DECIMAL), CAST(132.72000 AS DECIMAL)), ('inf', '0'), ('inf', '42'), ('inf', 'inf')) AS x;
SELECT LCM(9999 * POWER((CAST(10 AS DECIMAL)), 131068) + (POWER(CAST(10 AS DECIMAL), 131068) - 1), 2);
/* overflow */ /* Tests for factorial */ SELECT FACTORIAL(4);
SELECT FACTORIAL(15);
SELECT FACTORIAL(100000);
SELECT FACTORIAL(0);
SELECT FACTORIAL(-4);
/* Tests for pg_lsn() */ SELECT PG_LSN(CAST(23783416 AS DECIMAL));
SELECT PG_LSN(CAST(0 AS DECIMAL));
SELECT PG_LSN(CAST(18446744073709551615 AS DECIMAL));
SELECT PG_LSN(-CAST(1 AS DECIMAL));
SELECT PG_LSN(CAST(18446744073709551616 AS DECIMAL));
SELECT PG_LSN(CAST('NaN' AS DECIMAL));
/* ****************************** */ /* * Test suite for the Postgres NUMERIC data type */ /* ****************************** */ /* Must drop tables created by short numeric test. */ DROP TABLE x;
DROP TABLE x;
DROP TABLE x;
DROP TABLE x;
DROP TABLE x;
DROP TABLE x;
DROP TABLE x;
DROP TABLE x;
DROP TABLE x;
DROP TABLE x;
CREATE TABLE x (x INT, x DECIMAL(1000, 800));
CREATE TABLE x (x INT, x INT, x DECIMAL(1000, 800));
CREATE TABLE x (x INT, x INT, x DECIMAL(1000, 800));
CREATE TABLE x (x INT, x INT, x DECIMAL(1000, 800));
CREATE TABLE x (x INT, x INT, x DECIMAL(1000, 800));
CREATE TABLE x (x INT, x DECIMAL(1000, 800));
CREATE TABLE x (x INT, x DECIMAL(1000, 800));
CREATE TABLE x (x INT, x DECIMAL(1000, 800));
CREATE TABLE x (x INT, x DECIMAL(1000, 800));
CREATE TABLE x (x INT, x INT, x DECIMAL(1000, 800));
BEGIN /* ****************************** */ /* * The following EXPECTED results are computed by bc(1) */ /* * with a scale of 1000 */ /* ****************************** */ /* ****************************** */ /* * The following EXPECTED results are computed by bc(1) */ /* * with a scale of 1000 */ /* ****************************** */;
INSERT INTO x VALUES (0, 0, '0');
INSERT INTO x VALUES (0, 0, '0');
INSERT INTO x VALUES (0, 0, '0');
INSERT INTO x VALUES (0, 0, 'NaN');
INSERT INTO x VALUES (0, 1, '85243.39540024977626076239847863600785982737155858270959890014613035727868293618673807776733416230953723818527101593495895350807775607346277892835514324320448949370623441059033804864158715021903312693889518990256881059434042443507529601095150710777634743301398926463888783847290873199395304998050753365215426971278237920063435565949203678024225270616295573678510929020831006146661747271783837653203039829647102027431761129518881525935216608429897041525858540380754759125150233053469999022855035');
INSERT INTO x VALUES (0, 1, '-85243.39540024977626076239847863600785982737155858270959890014613035727868293618673807776733416230953723818527101593495895350807775607346277892835514324320448949370623441059033804864158715021903312693889518990256881059434042443507529601095150710777634743301398926463888783847290873199395304998050753365215426971278237920063435565949203678024225270616295573678510929020831006146661747271783837653203039829647102027431761129518881525935216608429897041525858540380754759125150233053469999022855035');
INSERT INTO x VALUES (0, 1, '0');
INSERT INTO x VALUES (0, 1, '0');
INSERT INTO x VALUES (0, 2, '-994877526002806872754342148749241.04353023451866590387054959174736129501310680280823383331007646306243540953499740615246583399296334239109936336446284803020643582102868247857009494139535009572740621288230740389545481395');
INSERT INTO x VALUES (0, 2, '994877526002806872754342148749241.04353023451866590387054959174736129501310680280823383331007646306243540953499740615246583399296334239109936336446284803020643582102868247857009494139535009572740621288230740389545481395');
INSERT INTO x VALUES (0, 2, '0');
INSERT INTO x VALUES (0, 2, '0');
INSERT INTO x VALUES (0, 3, '-60302029489319384367663884408085757480.2322712404088283093870869198708849258097125725036189625900174440196153781995220721511009855207486224837798752903681993777275846325950111427710563453217985216966456785944859989497422927661683538629473170704026975786513125842675604577233871570629808699803522400038975396500769162308448069085909755023233588510630417065084295051270219462289785473643946404281422516357503746700705970360169619852905053433235726497292406142332833');
INSERT INTO x VALUES (0, 3, '60302029489319384367663884408085757480.2322712404088283093870869198708849258097125725036189625900174440196153781995220721511009855207486224837798752903681993777275846325950111427710563453217985216966456785944859989497422927661683538629473170704026975786513125842675604577233871570629808699803522400038975396500769162308448069085909755023233588510630417065084295051270219462289785473643946404281422516357503746700705970360169619852905053433235726497292406142332833');
INSERT INTO x VALUES (0, 3, '0');
INSERT INTO x VALUES (0, 3, '0');
INSERT INTO x VALUES (0, 4, '5329378275943663322215245.24931765987630429629836382184742348353920297283690739124220773955591340709935970062776650204659187764581615597720798385015942389765692769739983054442503547211560297249686289665792078548480268091496050883021187158502798880896590227542729659940394038802461081290690995869705131152889309663639310553909874081663091069118126221594338242710530718836025225507189149221049928936955230868771875644038572888630664890573507822342998964954667474300944699078658989010257103569231493090050659723450626338923049035040974032671138430612839043269997482582763267536489504794826476836323549796385028155416935072959933315468068930689064483178204550825728947252440604703474049780550458442808479096492346910001692358508618202898514895453589357');
INSERT INTO x VALUES (0, 4, '-5329378275943663322215245.24931765987630429629836382184742348353920297283690739124220773955591340709935970062776650204659187764581615597720798385015942389765692769739983054442503547211560297249686289665792078548480268091496050883021187158502798880896590227542729659940394038802461081290690995869705131152889309663639310553909874081663091069118126221594338242710530718836025225507189149221049928936955230868771875644038572888630664890573507822342998964954667474300944699078658989010257103569231493090050659723450626338923049035040974032671138430612839043269997482582763267536489504794826476836323549796385028155416935072959933315468068930689064483178204550825728947252440604703474049780550458442808479096492346910001692358508618202898514895453589357');
INSERT INTO x VALUES (0, 4, '0');
INSERT INTO x VALUES (0, 4, '0');
INSERT INTO x VALUES (0, 5, '-652755630.43456071828048833552593835051449845484289562110789582081210403487973096161149072377955192388469356112505543620695003436531392789029513380101663750625024853263344909355177280161504414335005574882649025508632900995595004153086358670541462762210415346958050909878501048483523600711486406055424807840429541335391538322886495085448421556770991545781035298449067051916630343957356635391594362639819978677032855590055900561501350354631803808000307050416047072513406855040715556454205065332997338225626635780147287003130754254277103928406089109802521803537038957372612837169223905290912251006321930223154562110264217937');
INSERT INTO x VALUES (0, 5, '652755630.43456071828048833552593835051449845484289562110789582081210403487973096161149072377955192388469356112505543620695003436531392789029513380101663750625024853263344909355177280161504414335005574882649025508632900995595004153086358670541462762210415346958050909878501048483523600711486406055424807840429541335391538322886495085448421556770991545781035298449067051916630343957356635391594362639819978677032855590055900561501350354631803808000307050416047072513406855040715556454205065332997338225626635780147287003130754254277103928406089109802521803537038957372612837169223905290912251006321930223154562110264217937');
INSERT INTO x VALUES (0, 5, '0');
INSERT INTO x VALUES (0, 5, '0');
INSERT INTO x VALUES (0, 6, '.0469370721950711508944806393077762204079964905145503836835397203739563036579760026190241480514409364');
INSERT INTO x VALUES (0, 6, '-.0469370721950711508944806393077762204079964905145503836835397203739563036579760026190241480514409364');
INSERT INTO x VALUES (0, 6, '0');
INSERT INTO x VALUES (0, 6, '0');
INSERT INTO x VALUES (0, 7, '-818934540071845742');
INSERT INTO x VALUES (0, 7, '818934540071845742');
INSERT INTO x VALUES (0, 7, '0');
INSERT INTO x VALUES (0, 7, '0');
INSERT INTO x VALUES (0, 8, '8496986223.64063724353165506167988570717591150432282238795309964705925283285060558038824227595710139960766584401003765241409149793494330798800');
INSERT INTO x VALUES (0, 8, '-8496986223.64063724353165506167988570717591150432282238795309964705925283285060558038824227595710139960766584401003765241409149793494330798800');
INSERT INTO x VALUES (0, 8, '0');
INSERT INTO x VALUES (0, 8, '0');
INSERT INTO x VALUES (0, 9, '54863480.34685027005508022756223282084742813020271603840941647350440860843570182437301045468670059279379903480024743452620396345637401505220786389930600883087012615993343976556472498552535317826554614696684732913955544753638726438705858481670766245958647367500212800073774509075408148134050353551558174813940258910304990570172170811882520915334358633');
INSERT INTO x VALUES (0, 9, '-54863480.34685027005508022756223282084742813020271603840941647350440860843570182437301045468670059279379903480024743452620396345637401505220786389930600883087012615993343976556472498552535317826554614696684732913955544753638726438705858481670766245958647367500212800073774509075408148134050353551558174813940258910304990570172170811882520915334358633');
INSERT INTO x VALUES (0, 9, '0');
INSERT INTO x VALUES (0, 9, '0');
INSERT INTO x VALUES (1, 0, '85243.39540024977626076239847863600785982737155858270959890014613035727868293618673807776733416230953723818527101593495895350807775607346277892835514324320448949370623441059033804864158715021903312693889518990256881059434042443507529601095150710777634743301398926463888783847290873199395304998050753365215426971278237920063435565949203678024225270616295573678510929020831006146661747271783837653203039829647102027431761129518881525935216608429897041525858540380754759125150233053469999022855035');
INSERT INTO x VALUES (1, 0, '85243.39540024977626076239847863600785982737155858270959890014613035727868293618673807776733416230953723818527101593495895350807775607346277892835514324320448949370623441059033804864158715021903312693889518990256881059434042443507529601095150710777634743301398926463888783847290873199395304998050753365215426971278237920063435565949203678024225270616295573678510929020831006146661747271783837653203039829647102027431761129518881525935216608429897041525858540380754759125150233053469999022855035');
INSERT INTO x VALUES (1, 0, '0');
INSERT INTO x VALUES (1, 0, 'NaN');
INSERT INTO x VALUES (1, 1, '170486.79080049955252152479695727201571965474311716541919780029226071455736587237347615553466832461907447637054203186991790701615551214692555785671028648640897898741246882118067609728317430043806625387779037980513762118868084887015059202190301421555269486602797852927777567694581746398790609996101506730430853942556475840126871131898407356048450541232591147357021858041662012293323494543567675306406079659294204054863522259037763051870433216859794083051717080761509518250300466106939998045710070');
INSERT INTO x VALUES (1, 1, '0');
INSERT INTO x VALUES (1, 1, '7266436459.363324713115467666113895787027372854351303425444968800459979742082292257107107767894843498525848597439323325297125474674300428669958003640228730876886174255457103020291514229439701871032118057857763809224712818579091741996335014138185389554630910658876423205103697147288306070059640369158894028731728589073730895396494400175420670713113234800826523252075036892246807434088405522834549449664122407363485486902219500109237667016524913027290777216477989904700729228025571098410870506256758678625928245828210775042611512394316804583459576285681159178280400209217948833631961377519855502763611693070238579591463373484424582723121059964236704135695706864890193388054537703767833595331866551990460050750959493829603581882430597105627056085260296454181999581594565113210481151487049158699087454047624433576922179904629');
INSERT INTO x VALUES (1, 1, '1.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000');
INSERT INTO x VALUES (1, 2, '-994877526002806872754342148663997.64812998474240514147207095573950146764154822009863493316394610578375247334825932838513167168342610420582834742950389452212867974756590355021495169819086060202117180229196935525386766373096687306110481009743118940565957556492470398904849289222365256698601073536111216152709126800604695001949246634784573028721762079936564434050796321975774729383704426321489070979168993853338252728216162346796960170352897972568238870481118474064783391570102958474141459619245240874849766946530000977144965');
INSERT INTO x VALUES (1, 2, '994877526002806872754342148834484.43893048429492666626902822775522112238466538551783273345620682034111834572173548391979999630250058057637037929942180153828419189449146140692523818459983958943364062347264545253704196416903312693889518990256881059434042443507529601095150710777634743301398926463888783847290873199395304998050753365215426971278237920063435565949203678024225270616295573678510929020831006146661747271783837653203039829647102027431761129518881525935216608429897041525858540380754759125150233053469999022855035');
INSERT INTO x VALUES (1, 2, '-84806738323879544552397401815149740513.8505875535743013876823142649666132764556588225959336097903898464616542203793600590311980154402068027051522932586050753865288419084437796768749509032177577451738712965496693249429231838833655025794915864261585848007162358912070811805298210095333433397862313304655108809804359760907473898420016370058274978588765092161529583480924554820756527238472641797198545539410039895140087686344382628317530286295498797849942258314364503000942821309916954725689781458590617068629906894951122301020797266469357701283289275708774593896770378558232444454118891917258610753077932026885574920166837998049508644891327208474213193224700658584824407382455480657734911543930195324144216374573825');
INSERT INTO x VALUES (1, 2, '-.000000000000000000000000000085682300757901809257711279577127388124986344391495296640171942990079130291883279872719240502687189411421655284515420074848478500192127657883342858267913417679786356766341637336955924836847768457039175660279784295612167899455618405343686908907695358239088351870495830739180518509859269437015797489301844593920484927630172344269378248455657186218762679357609204333669024237648538465053048724383898528808961206696787294681884412485427843796696788390072124570957047672341581447744981862017791206857428430183366004980966398716823512288330174863890117558744630102020144500158878244146399686532935435591262767487823942606452349972401012308378888947381934278131785907155692007064636085000405504866631011593239041758448995933095907216863744502344014999804306234830774259496097549717476344048');
INSERT INTO x VALUES (1, 3, '-60302029489319384367663884408085672236.83687099063256754698860828386302509843815398979402006244388708674093244201278399438376682321121138429850885935540924586964982855913223221441591310211730902799041126800414795030815514254713522692405212716783388698431088814919226444677188004928663343696636297536500970117716818423689175692808344185016908913828066250587407384563498516598672584120143890364303296142744031320345312431817858545326010704685255237541162931904446804064783391570102958474141459619245240874849766946530000977144965');
INSERT INTO x VALUES (1, 3, '60302029489319384367663884408085842723.62767149018508907178556555587874475318127115521321786273614780129829831438626014991843514783028586066905089122532715288580534070605779007112619958852628801540288008918482404759132944298520148080184250697297150817299173701934285646867489426483932830299434150464278537812298564822479785688909850915447762856384542090714278516461905872647123125352735037721325154184406043613668806975385533851732090363979459292404685190942209855935216608429897041525858540380754759125150233053469999022855035');
INSERT INTO x VALUES (1, 3, '-5140349743195574373979577554212527512597024.162480344833040409158673429491690439298506850052285119390701002577176786023622062742050099464897084793357329597395417632908812044304066963549928478520702505283307379218587635434673128958824348493758429380623577527186462464399974242800361134191519694694139153279582776168995426125926314513926640766117733774558011741611075336271613675760116784769700605008122422944290652448956922432960815546502965310676913079866511016221573557684245901002643719965652152439520727383305120298495304784052489867651462175349450610643411043707261107569691076730261762793560088893354750383257372118118753366377402045596735023445172252225346164608897913115394905485106225627590643805003075069931177395059698550161546962768768895596088478488887530518018212441345360153523733317120037436403475909117998647781920105313938836144009539683');
INSERT INTO x VALUES (1, 3, '-.000000000000000000000000000000001413607404628860353773457807436398753936801768769045711604884548436548520368932184112069166807060840219636509423284498981041814526856251281381511288768719259120481595036745286884246627534964287523188738499223075292690431699417313258943941279343383979626641848305343592679057491670166887054819766294147341982669243114259272404203080347707713358471397866402657818267495050115642987782080912962056565478445923456884713049272637646637760989004917643369240372476411912794578381690666695711891846833983534126217706309741885844723208036219144146342212915129560758201609824034610223907791643110990898577049488934294259106725414517181607988173722432655731491050637087261030314548853334338835938120502930424813699221083197863303458179445322810087784892821862085562891180364134284641396475');
INSERT INTO x VALUES (1, 4, '5329378275943663322300488.64471790965256505869684245785528331091076155554650629138833809683459634328609777839510066435612911583108717191216693735823717997111970662575497378762952496582183738308720094529950793570383580785385569873278068217936841324404119828637880370718028782103860007754579779716996004352284614661690063919125301052941328989181561787543541920734755989452320799185700078241880935083616978140555713297241612718277766918005268951861880490889884082730841740604517529391011862694381726143520658746305661338923049035040974032671138430612839043269997482582763267536489504794826476836323549796385028155416935072959933315468068930689064483178204550825728947252440604703474049780550458442808479096492346910001692358508618202898514895453589357');
INSERT INTO x VALUES (1, 4, '-5329378275943663322130001.85391741010004353389988518583956365616764439012730849109607738227723047091262162286043233973705463946054514004224903034208166782419414876904468730122054597840936856190652484801633363526576955397606531892764306099068756437389060626447578949162759295501062154826802212022414257953494004665588557188694447110384853149054690655645134564686305448219729651828678220200218922790293483596988037990835533058983562863141746692824117439019450865871047657552800448629502344444081260036580660700595591338923049035040974032671138430612839043269997482582763267536489504794826476836323549796385028155416935072959933315468068930689064483178204550825728947252440604703474049780550458442808479096492346910001692358508618202898514895453589357');
INSERT INTO x VALUES (1, 4, '454294299613767152878025320780.534199313974295807138790763501115780294529340799108297697573066187975311338382917022391830256203305238757334106943821060545424417350991354829668286194840925251162479496893943917530660694097932059166013476064988623431110002057735318529554555260199417935495388243829261809007709919225000608711536928171687251088217591210419208480251102484043683131687013687838713055660405381318396419588727500715930145098362997142075433472039319292466570912777345841400769387321465602989947078951135489852486382469990409873227894248208197179481868230244584527040573428134962626267135732247029762468417273891700661832893497067151409134724061246612631376075173287264787886064622106855886785805818642123776489793586531950438285720668411465570116161790343538663297713926678759640594912243360541590368666922379919514826022141331900181');
INSERT INTO x VALUES (1, 4, '.000000000000000000015994998100440878014888861029956505927201309704413242103407885948184870841766875212766910686894450511886242468216220470061916924303252919423028993720180330014505454865704155281502763018913215741264982350384245753394656021401865680441649920273268554396350483440173848850052788410943178207336328451359951614056237100465802151856198860908371340425459435127133071447273887829397881221098443685586506647314622864702873235212396755866459409263439958011711379929751157260020133239574261188528305921244365838405372320186907437842180388704854605498842516581811515413843298370501194935797268161171428747542997504369133579105180311662221854071962295818264211400101689450830279979372422749150894553349570063000769685274875561760334738424509532610467832951796852051505383374693614022043010735004494395190');
INSERT INTO x VALUES (1, 5, '-652670387.03916046850422757312745971450663862747133703839829692066597367760104802542475264601221776157515632293978442027199108085723617181683235487266149426304575903892721468296143475297345699313102262188759506518376019936160961709578829069446312051432780603656651983414612264636232727512091101057374054475214114364113300402823059519499217878746766275164739724770556122895799337810694888119810524986616938847385753562624139431982468828696587199570410008890188532132652095915565323400735066310142303225626635780147287003130754254277103928406089109802521803537038957372612837169223905290912251006321930223154562110264217937');
INSERT INTO x VALUES (1, 5, '652840873.82996096805674909792441698652235828221445420381749472095823439215841389779822880154688608619423079931032645214190898787339168396375791272937178074945473802633968350414211085025663129356908887576538544498889782055029046596593888271636613472988050090259449836342389832330814473910881711053475561205644968306669776242949930651397625234795216816397330872127577980937461350104018382663378200293023018506679957617487661691020231880567020416430204091941905612894161614165865789507675064355852373225626635780147287003130754254277103928406089109802521803537038957372612837169223905290912251006321930223154562110264217937');
INSERT INTO x VALUES (1, 5, '-55643106304872.575994253221940844841058071061962511162776681458310912066379595519265546225338405882027547140476045378015935579066580347282075024392379464189067155567624835346798806677988850250198082355055954078446421075165109896091047534711081616362392995575466807084807876544560268050611445006601394735810211678919646667455478469014906335433468365011768049600750224822391684377238242162320161552720449713229523135506671063115436813348612986916614320012995541575293478341408982118538094438068036422562665160411591652618670802973618768526197813319204816293073794413317669922144705633308090832805914096147659820167569140291210526520361556881576175809360614782817717579318298657744021133210954279487777567785280633309576696708168342539425395482429923273623865667723482418178781573723597156804085501875735112311466228778929147929');
INSERT INTO x VALUES (1, 5, '-.000130590057635351941758745900947472461593749814351229292370661147301124533787181489468804246182606762727711479707901680546780430454163647774077629503207962424213266902732555945190365467801995495570282501722505521485829885605904543846887348545254658726343578684749830307120625129857380290225370772763609458975555029415082569247186899112975387051141777417911244576134390940441209829852154391377911942082738699481875795620569383196133124499983396562167632007454221121465745085962247988140942672429187053671899537331280701003778040796615094903602095098880716919238394057384949891444700347825726273725378453454782330181608182747900774711384845635284701538541452235224216112380245660177463043471814071809869894647262285332580556739424040615194137651616350340752691170045698234853734471923738591898290468792787543896');
INSERT INTO x VALUES (1, 6, '85243.44233732197133191329295927531563604777955507322414928382967007765263923984471408038635831036097817458527101593495895350807775607346277892835514324320448949370623441059033804864158715021903312693889518990256881059434042443507529601095150710777634743301398926463888783847290873199395304998050753365215426971278237920063435565949203678024225270616295573678510929020831006146661747271783837653203039829647102027431761129518881525935216608429897041525858540380754759125150233053469999022855035');
INSERT INTO x VALUES (1, 6, '85243.34846317758118961150399799670008360696356209219504851646259063690472663252876207514831001425809630178527101593495895350807775607346277892835514324320448949370623441059033804864158715021903312693889518990256881059434042443507529601095150710777634743301398926463888783847290873199395304998050753365215426971278237920063435565949203678024225270616295573678510929020831006146661747271783837653203039829647102027431761129518881525935216608429897041525858540380754759125150233053469999022855035');
INSERT INTO x VALUES (1, 6, '4001.075404054519813215296429095020391062109905613738157927030437221793757373268325953178030040276107574363822832168160758728653712686313134828282109532831190239521843808940611025488601517574653932032236616573457735900045655665690517797280666732780030171712864961531623060353548802466577910774711998056232872212688464691036260746751992072745518373073825852119460094113694393273456369345499434994672730920070410547163082189385645712866100999708173472360864669110044660667614583576570496399103026286828660558854973376227247132815728164629722965145778698957093136175449225024685874279280018547740');
INSERT INTO x VALUES (1, 6, '1816120.848909727306817960620941575637231136442992819290405125420545200026620306446043740992108329883383706060582482495616151605111275635501481354526017831484915013545483361715432312183101964395505340188909970344423950565285639911521082834494088840596716495422427543520536844348040681236845850482165744696068209384509064196671206362539077218412355776790921130042376467606683622970728503408501481791356294886150690067651815776445750760428874351556866105285911902433352126498951242195408782804314174041618879250740246352525074791310920062276490422853700893340860452528740673590486626464460321410814395342850270921486724297414692313177440726749004398703147904603937755702369682956482832074779404350351752662820773690162594400557957241676636030332988289683112176900913522668426137377289536793838959751008646843014106876005');
INSERT INTO x VALUES (1, 7, '-818934540071760498.60459975022373923760152136399214017262844141729040109985386964272131706381326192223266583769046276181472898406504104649192224392653722107164485675679551050629376558940966195135841284978096687306110481009743118940565957556492470398904849289222365256698601073536111216152709126800604695001949246634784573028721762079936564434050796321975774729383704426321489070979168993853338252728216162346796960170352897972568238870481118474064783391570102958474141459619245240874849766946530000977144965');
INSERT INTO x VALUES (1, 7, '818934540071930985.39540024977626076239847863600785982737155858270959890014613035727868293618673807776733416230953723818527101593495895350807775607346277892835514324320448949370623441059033804864158715021903312693889518990256881059434042443507529601095150710777634743301398926463888783847290873199395304998050753365215426971278237920063435565949203678024225270616295573678510929020831006146661747271783837653203039829647102027431761129518881525935216608429897041525858540380754759125150233053469999022855035');
INSERT INTO x VALUES (1, 7, '-69808760806266041400340.70700818693892852138813934414383886494691670042143650609934777814995087699409404201920249076407981012095999320858479644760715204999741683528746097757549835956359129287002171391961763797857794730120426599135099619822532290339000466211195776337667123320942107370731349851576864242697412616810236323676004067839744992733887503405311090677026008324895177587064547630828026123718296429295638934384446325302964896473296829265805737112709269803814942537657996725913938408781715328945194948010970');
INSERT INTO x VALUES (1, 7, '-.000000000000104090609479936344103210175655521317012597986331111866307697262848964666360492361638117930801818899121383806224630563676018240181412174154250663423230239912527388431901852952893943812666142740182651125508583527237123596541789628675379232473721293630968882045044077795828674268595016625198802475186587918019739056755398151182369187670251750080227679555002307777300392769289647975058449905106584837938556260801229545589323224752038795423164214112897202147313792076165011373139219134850954217300915326944185918762838321705825423789073869940092569940135329697980600082436317664012683589681419530904283106912171330819469065141821685734295058255484933744156717782754922568796985634397878149984177882018261742637463462647452140104146195353696596211873925359508622779658904411330975862442989437933211964821');
INSERT INTO x VALUES (1, 8, '8497071467.03603749330791582407836434318377133169438097066269854720538319012928851657498035372443556191720308219530866834905045144302106406146277892835514324320448949370623441059033804864158715021903312693889518990256881059434042443507529601095150710777634743301398926463888783847290873199395304998050753365215426971278237920063435565949203678024225270616295573678510929020831006146661747271783837653203039829647102027431761129518881525935216608429897041525858540380754759125150233053469999022855035');
INSERT INTO x VALUES (1, 8, '-8496900980.24523699375539429928140707116805167695126380524350074691312247557192264420150419818976723729812860582476663647913254442686555191453722107164485675679551050629376558940966195135841284978096687306110481009743118940565957556492470398904849289222365256698601073536111216152709126800604695001949246634784573028721762079936564434050796321975774729383704426321489070979168993853338252728216162346796960170352897972568238870481118474064783391570102958474141459619245240874849766946530000977144965');
INSERT INTO x VALUES (1, 8, '724311956372274.0135050255361637906710330203036651743488213007179039756514944640108625580172737414192938789413338554327986697518463087452612658955180411327002900979574347739956600177846996063741787205122007268468674386396156638261992679442768654367111433834151087792255469957061758837789341439211010331332174981459471333376067541234901538285101103690622656631026001337239036711179989456674399137008584021283568040818388709554256523118702728176420022080138548890713013682480239784198421500241995499841675772793497485550923152267616622892846304530712344886979674416990935007952941652591352603797627920865960622077762568060903908151958000');
INSERT INTO x VALUES (1, 8, '.000010032191786198542900505683562217892317481076466949299850809276743457759270150820565375820388277409258249926696079166209409657808406245382887790534127749833677458375931047385994887406206232330491317602830654688957983804698568410728278089250379255157030886262396950539100566975000094268415749476738358914633948867977798590927055566888255636132486899287919515638902721543629183577900872078173883974905921239149419877613723476347774771230668479296621531969573505480695490386225866950545725121902534610730154727385072738079149623798073810167706094070842646222833137345669922898403368997676634709281456818189049718956207208697021706186341405575300648248555331280690778367620868775005181264547924615247991795542738868003191757946979714250339430363902549866892041102771965653407197094250270379367437342632741280710');
INSERT INTO x VALUES (1, 9, '54948723.74225051983134098996071145685528795757427462111901537365053896571438476055974853245403475510333627298551845046116291696445177112567064282766115207407461565363967417615506303416694032848457927390574251904212425813072768882213388082765916956736282110801611726537663292922699021333445658549608928179155685881583228490235606377831724593358583903616295573678510929020831006146661747271783837653203039829647102027431761129518881525935216608429897041525858540380754759125150233053469999022855035');
INSERT INTO x VALUES (1, 9, '-54778236.95145002027881946516375418483956830283115745569981757335827825115701888818627237691936643048426179661497641859124500994829625897874508497095086558766563666622720535497438693688376602804651302002795213923698663694204683995198328880575615535181012624198813873609885725228117274934655048553507421448724831939026752650108735245933317237310133362383704426321489070979168993853338252728216162346796960170352897972568238870481118474064783391570102958474141459619245240874849766946530000977144965');
INSERT INTO x VALUES (1, 9, '4676749348240.390309875431213992853550297086049749814750492488995108783145961719774217441193547534210468967573344456866203963659951312519988497979489304488948342258375915152429008993288817366720647491166024151209542534474867042837694499222928509320280684557676243780452100132238968233413333851595648146954975713386711764268506890884764704949969602122157394714663532141060559896359465918874990769222345665160127552795532197771168442486088776803398878354288847069602460071745966589164282641033852314335279121191855487126430176047553895892632834940595958394834437871886013513058514896870683979585091413977173250824451205330441299000850618134248917380244749589254309567551846327349592529960432446947239714236828401206843011440433362544797025114476612133622499094287321570559088587999417440664282418005102546343020409520421747216');
INSERT INTO x VALUES (1, 9, '.001553736563217204408368240901181555234014339476186598647410198373122572205209277343865051610898136462487966496673511261433286284257044548634547569923035899634327495195510767312478861719221916387940027268721306540663743713345337497285507595251328382906111997524508729275471287648008479480805967901972481289402930660848950039779707354469389216931774094174326513465502460315792834278614886136688161679443873815113442220055827192996984074129528034845339130162104547166079591654852164993577408422015514100323825529286511720963047269483211930770803479398243069649400360625259869765138545866815758888670363356947311319523139395191102286838888146829667276592755438606664644975648828848738708349790766370694194763606850690923803984129157519048493985198591771429264967247245289970213262206709011468289046840862597010969');
INSERT INTO x VALUES (2, 0, '-994877526002806872754342148749241.04353023451866590387054959174736129501310680280823383331007646306243540953499740615246583399296334239109936336446284803020643582102868247857009494139535009572740621288230740389545481395');
INSERT INTO x VALUES (2, 0, '-994877526002806872754342148749241.04353023451866590387054959174736129501310680280823383331007646306243540953499740615246583399296334239109936336446284803020643582102868247857009494139535009572740621288230740389545481395');
INSERT INTO x VALUES (2, 0, '0');
INSERT INTO x VALUES (2, 0, 'NaN');
INSERT INTO x VALUES (2, 1, '-994877526002806872754342148663997.64812998474240514147207095573950146764154822009863493316394610578375247334825932838513167168342610420582834742950389452212867974756590355021495169819086060202117180229196935525386766373096687306110481009743118940565957556492470398904849289222365256698601073536111216152709126800604695001949246634784573028721762079936564434050796321975774729383704426321489070979168993853338252728216162346796960170352897972568238870481118474064783391570102958474141459619245240874849766946530000977144965');
INSERT INTO x VALUES (2, 1, '-994877526002806872754342148834484.43893048429492666626902822775522112238466538551783273345620682034111834572173548391979999630250058057637037929942180153828419189449146140692523818459983958943364062347264545253704196416903312693889518990256881059434042443507529601095150710777634743301398926463888783847290873199395304998050753365215426971278237920063435565949203678024225270616295573678510929020831006146661747271783837653203039829647102027431761129518881525935216608429897041525858540380754759125150233053469999022855035');
INSERT INTO x VALUES (2, 1, '-84806738323879544552397401815149740513.8505875535743013876823142649666132764556588225959336097903898464616542203793600590311980154402068027051522932586050753865288419084437796768749509032177577451738712965496693249429231838833655025794915864261585848007162358912070811805298210095333433397862313304655108809804359760907473898420016370058274978588765092161529583480924554820756527238472641797198545539410039895140087686344382628317530286295498797849942258314364503000942821309916954725689781458590617068629906894951122301020797266469357701283289275708774593896770378558232444454118891917258610753077932026885574920166837998049508644891327208474213193224700658584824407382455480657734911543930195324144216374573825');
INSERT INTO x VALUES (2, 1, '-11671021799770914903865020509.301561107153561058074179843542446420696517132461554451075945807420674211966679216615407057626541711186781735967334896541890595771915856783008831770988426637435694856170266346306640678577376310547806764332837625966429200996250687908930748245035578756314083608655163891041399241377675534416837659335561005203219889972336214863417948542956735403991871098341470996860469878038840964359144637726669728240650066795729910649523281308716277906908340457162235831526838308777581569974551673352306004330423694524256415657620427590352277556907586751621496248973165690360552007637570957980230685679819820147036159174977086193494572117089582758015847544798464543446227632367713941117001423437766840744488426025388612316819120660814681298624293065972395923651314350558006567251033289878238407790871784676348196394482477767774');
INSERT INTO x VALUES (2, 2, '-1989755052005613745508684297498482.08706046903733180774109918349472259002621360561646766662015292612487081906999481230493166798592668478219872672892569606041287164205736495714018988279070019145481242576461480779090962790');
INSERT INTO x VALUES (2, 2, '0');
INSERT INTO x VALUES (2, 2, '989781291745465665243281323944996915810556285052564220274237162526.1617859904902612197894543199389468971679632139059029459520163585971122643624316475417489000981872666677202334180945949860058384424993911721081868337499377890298636260338063268639283065887210924895929155083478140340889209440025415565915964293989840603863813531303253038823629712989041722072693449251635519992922148998556112923060331794396659338057474019846675262291146025');
INSERT INTO x VALUES (2, 2, '1.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000');
INSERT INTO x VALUES (2, 3, '-60303024366845387174536638750234506721.2758014749274942132576365116182462208228193753118527959000939070820507877345194783035668195137119648748792386548310474079340204536236936213411512867171486174240518914767934028451971067161683538629473170704026975786513125842675604577233871570629808699803522400038975396500769162308448069085909755023233588510630417065084295051270219462289785473643946404281422516357503746700705970360169619852905053433235726497292406142332833');
INSERT INTO x VALUES (2, 3, '60301034611793381560791130065937008239.1887410058901624055165373281235236307966057696953851292799409809571799686645246659986351515277852800926805119259053513475211488115663286642009614039264484259692394657121785950542874788161683538629473170704026975786513125842675604577233871570629808699803522400038975396500769162308448069085909755023233588510630417065084295051270219462289785473643946404281422516357503746700705970360169619852905053433235726497292406142332833');
INSERT INTO x VALUES (2, 3, '59993133911282372667149627097418449223835595194300848703012380022306762.154418449236691515146061305380465061074531890529497774836941002526095632166401249277270674802626154774328055399254982998368191676630276960361274433270795772477146870294928855773172789856196219950097157391050424577381777627004101100872747943673762087675405200265837631665464736842180920496158545887039337399558993437594084473932658319914390365451919627956823980800124880375978662052111797881386060353490432427832058851094210488804887183034572364751639107535041308434932952695103493677600969712634416241541391613699710826602011076372592299807609658979777598672141389319098817824624950794758296679318319299142035');
INSERT INTO x VALUES (2, 3, '.000016498242835741013709859217005931279826178662180173096568520102488480129191427472581644597420895622947234184547373944996197105916093347103336318249582032230903680989710242610024298937774441533502282949127537125997753002819456724709929935850697744632904111143787011103837624936502324835260843148595669524694347566421203164808527739207590986975750648112133699756328511947175496694080071202064255118777680958612315513441989609682655431197367166056616661045712867189326408877133865572680407329449150282415810958772293869902662884761202424695742898573841869524376684740249281181605067345203479719345061595919652192297531638467223956758315591610733251562492794891852151639643060692698365496208796638230566761231611376199140556503620471090364900792180618741355091923808605890415081571900697282725022629812561702118');
INSERT INTO x VALUES (2, 4, '-994877520673428596810678826533995.79421257464236160757218576989993781147390382997132644206786872350652200243563770552469933194637146474528320738725486418004701192337175478117026439697031462361180324038544450723753402846519731908503949116978812841497201119103409772457270340059605961197538918709309004130294868847110690336360689446090125918336908930881873778405661757289469281163974774492810850778950071063044769131228124355961427111369335109426492177657001035045332525699055300921341010989742896430768506909949340276549373661076950964959025967328861569387160956730002517417236732463510495205173523163676450203614971844583064927040066684531931069310935516821795449174271052747559395296525950219449541557191520903507653089998307641491381797101485104546410643');
INSERT INTO x VALUES (2, 4, '-994877531332185148698005470964486.29284789439497020016891341359478477855230977564514122455228420261834881663435710678023233603955522003691551934167083188036585971868561017596992548582038556784300918537917030055337559943480268091496050883021187158502798880896590227542729659940394038802461081290690995869705131152889309663639310553909874081663091069118126221594338242710530718836025225507189149221049928936955230868771875644038572888630664890573507822342998964954667474300944699078658989010257103569231493090050659723450626338923049035040974032671138430612839043269997482582763267536489504794826476836323549796385028155416935072959933315468068930689064483178204550825728947252440604703474049780550458442808479096492346910001692358508618202898514895453589357');
INSERT INTO x VALUES (2, 4, '-5302078674303935968062773235453828254014583744527466365136.236414807326868572353809920518232561005161225922028750078608989965741402418802255050636954800114792425419735155504035469350521800895164087027043476055514245942961100610551646034472084954313670284875310691807937254054948742125729353864014122131419164449567115006621212424805182687707372956385102095255735458593389920872596796806885847543910224476727171570873698525606016990229936284811067826588349092841322512643043008589065847223683467371925773023109720951609815041012521485326120380123169545818055967455575736140138663815073081494226676896278654189873597341203197903408668523514375373841493189836809506003729379742035629498519683885268256481104619815130659628225053833297766479068686119691010593208135616363994230674606991733148502293102108193522604968743948323130517040609601859735899914987426089053869350663');
INSERT INTO x VALUES (2, 4, '-186677971.517539861245390308778107722315862721823627804195528485535806132067679059453022306691281662574091826898288146790399178357754908901382135796783067563944022498807930452234032896817601590728156392188660701355670595952594500812333935362955625137944589981298793332621503315902294100258945995827423279442031218510259915311555745581797315793010762585658196457363672908315687720174516274528662385172326028870945153551774300419158584379602045442200523311437013776079979639415633358878239012925000523542907592866797199229858272764668664323316251874027468128770456766875866492004650352654523634716923150212263912760225390093339729495231675627059805624175587380165509763048913150826017167286786277908970769297060278191518730887417202276531151575412404467497036737825989088867451153485938272367300939127313445244028528055624');
INSERT INTO x VALUES (2, 5, '-994877526002806872754342801504871.47809095279915423939648794226185974985600242391612965412218049794216637114648812993201775787765690351615479957141288239552036371132381627958673244764559862836085530643408020551049895730005574882649025508632900995595004153086358670541462762210415346958050909878501048483523600711486406055424807840429541335391538322886495085448421556770991545781035298449067051916630343957356635391594362639819978677032855590055900561501350354631803808000307050416047072513406855040715556454205065332997338225626635780147287003130754254277103928406089109802521803537038957372612837169223905290912251006321930223154562110264217937');
INSERT INTO x VALUES (2, 5, '-994877526002806872754341495993610.60896951623817756834461124123286284017021118170033801249797242818270444792350668237291391010826978126604392715751281366489250793073354867755345743514510156309395711933053460228041067059994425117350974491367099004404995846913641329458537237789584653041949090121498951516476399288513593944575192159570458664608461677113504914551578443229008454218964701550932948083369656042643364608405637360180021322967144409944099438498649645368196191999692949583952927486593144959284443545794934667002661774373364219852712996869245745722896071593910890197478196462961042627387162830776094709087748993678069776845437889735782063');
INSERT INTO x VALUES (2, 5, '649411906691138274293985410502516861224852.2323455192714410716272307781034189160865613770320102043319541634113746032638191509585045862973333645830298922352816245477556264222094036953195419857712804755170632292914187367964994214922001758104594052499795564860466055599417895782179851297585155129541589802249540436678824225950907268084876110445460948679383611117263673106597132046331719468816839434908155684738864149955129235751738204036443603521478609787295079710078973503970964790273461142497259987849074597264522099648376356902360358310245001183020992360260836105404118742418040965190000718736837422434593694808973939805954329718232693154128543253581495885789333274488461716809104532693754070810202831113003978085636579574171344721710232931261731022478029314435363413498991740750878099825781577297965642009156858479681236085226911858782115');
INSERT INTO x VALUES (2, 5, '1524119409495532727030986.638577103454261465522025182901477334004986357902177024959076085490119358611626688213654669281670407680244740174673394111775678935383154847014211641601227316639834450258566053805263858706381900273201146454036688771735398324537667996974210741719621449948660517037619359095556637235980122706739013220201060795557114248610410815988952748489854367480813823114296393315170621979351958306734282429929421779129764262568942699813166237466796852578307944635545174715298176546980314973426586923195248536376403319094417073026382024413817222396402299695717290716014320518777088811749776114378145110676170242861393274018655137797545194817703831240390631723050378397773341835222892981773205967439339460305257986693600088957772328044922955990976285151896366292514128607363007421484320868718566256882080399264346243272770200676');
INSERT INTO x VALUES (2, 6, '-994877526002806872754342148749240.99659316232359475297606895243958507460511031229368344962653674268847910587702140353344168594152240599109936336446284803020643582102868247857009494139535009572740621288230740389545481395');
INSERT INTO x VALUES (2, 6, '-994877526002806872754342148749241.09046730671373705476503023105513751542110329332278421699361618343639171319297340877148998204440427879109936336446284803020643582102868247857009494139535009572740621288230740389545481395');
INSERT INTO x VALUES (2, 6, '-46696638263247522384986521136500.479312417066793299922708112595886608370451213741279484136907754744903470430131032928908162742687359367826808123516519335458861613010646992354378739165872253762686683966945711430182491860196341344982195078000259063231136011430995647812149294224699587849791008794261026932467933475782780');
INSERT INTO x VALUES (2, 6, '-21195986018643887410662481595901800.342199657994285865579781485758715114242459388977583220756870314514884887803267837816669111279417861218648323488364513921592045485003563036021370174294475403630933854767386355037781881144701319212711655881277140183173924089814927297045029394618083349813549439341772734606115369911736164723942330187830605893993276674913563980890459604886172701331890746621222114280438198802989678877404376001410627722336243835841751052795437979198996482216031399073597399901975686733315751292369326904428230195579137225651689857057115970784985439417129044974524632220457594191305254649113470116960582543784928547885740020507755033347968928034294570497118410435615856155184563329718831512839630769097935523279881940380220955993456451396417879773380305142918906742431812580562496634831735169817705720949712410595406012323294829461');
INSERT INTO x VALUES (2, 7, '-994877526002807691688882220594983.04353023451866590387054959174736129501310680280823383331007646306243540953499740615246583399296334239109936336446284803020643582102868247857009494139535009572740621288230740389545481395');
INSERT INTO x VALUES (2, 7, '-994877526002806053819802076903499.04353023451866590387054959174736129501310680280823383331007646306243540953499740615246583399296334239109936336446284803020643582102868247857009494139535009572740621288230740389545481395');
INSERT INTO x VALUES (2, 7, '814739569184924399102711674444306584731316176345067.39834031417849342571224916231092924046722938910652929295271097903377854123984307101079073134405782275535446337229706620713104545454319555885847481531722101704765783025789147453570970090');
INSERT INTO x VALUES (2, 7, '1214843772391778.127361407585140553741220126410637250571020684739034685508176000812180032686291124045768750332493129822580347351032145964983629059968936201592138368806173099130176852606440296388856520582890650384142745607345709716826703676313341953999327129144154152914234659001555055379537780751567782847296067128932113870102563522810980359433259696591977617184951677390423898232135100000764121508662830515405980450892222598485287609657612482190264517684867291774820716746063133066053446257163185646067618679478975882247893469409405379034723543061767846895135644429012095930584952053545016706315299076691015196261253199176743281648949731423486208098120903720124071047872917636988241710583721537777321338769039241700203546247947405745989053846970910400831817998342969657501678430211657755864160072525313889413731419647001970593');
INSERT INTO x VALUES (2, 8, '-994877526002806872754333651763017.40289299098701084219066388457144979069028441485513418625082363021182982914675513019536443438529749838106171095037135009526312783302868247857009494139535009572740621288230740389545481395');
INSERT INTO x VALUES (2, 8, '-994877526002806872754350645735464.68416747805032096555043529892327279933592919076133348036932929591304098992323968210956723360062918640113701577855434596514974380902868247857009494139535009572740621288230740389545481395');
INSERT INTO x VALUES (2, 8, '-8453460632655529853033389979024265783461224.3195241893307807116624750282852146303290708492834695194274289713076935297734670940696121761483641291930931061232942894577813178566088927221374036301485916497770984757492912292002695944367308880163698595015497307574177176409203214324418237020500352652934909632442547242092296504047310806151851207329042221920888326000');
INSERT INTO x VALUES (2, 8, '-117085929036205907700251.219065234073336548829793284434494573185718678644093751558890746941383215425734761534822966779511801033216479269605150574332107020180872343673157350081102818832254463561564431056604957702984438484261858890324442581609284935850435611342611117035589511568432559140282381526487115307554496353616929034919886387903446436924514812698404129456069856633480965357915969548215985452939172313964007318881987188665231550330515412104367728617802960792164260429920719961650164518261501571220901151359208484337831586551714193024143212288426326740373893030225940355268499071669300664200888186064836443459131985786957267268845966279576380786883200277187591448294590370986026461176853573555996139940001165172158855197070946665074838360933025833716166930231164328918316437195201546383664484983447934244744303265471044295601062898');
INSERT INTO x VALUES (2, 9, '-994877526002806872754342093885760.69667996446358567630831677089993316481039076439881735980566785462673358516198695146576524119916430759085192883825888457383242076882081857926408611052522393579396644731758241837010163568445385303315267086044455246361273561294141518329233754041352632499787199926225490924591851865949646448441825186059741089695009429827829188117479084665641367');
INSERT INTO x VALUES (2, 9, '-994877526002806872754342203612721.39038050457374613143278241259478942521582284121765030681448507149813723390800786083916642678676237719134679789066681148658045087323654637787610377226547625566084597844703238942080799221554614696684732913955544753638726438705858481670766245958647367500212800073774509075408148134050353551558174813940258910304990570172170811882520915334358633');
INSERT INTO x VALUES (2, 9, '-54582443595378013373024060492546032003692.4875677735896411267274323339692558458420972958075073392126734000341372096298914875892612108329218081214550050039133117695428196702128258481789017059073444323729583900855712795086447886053552786449313809589992185978097430132940882612817775035217244553616977182049775786664446683332098226841743818600819221587510039430478859412452506872131851471967577741190323481953867845129745440745526578327709351120432530702446916035797432129052518980799424635406993848916727957825620638983706180841278402925286540375225365057191075559133035');
INSERT INTO x VALUES (2, 9, '-18133693300409132895168796.074616314168631402221003009151140409826855230810646429042722071403306917323628118792142878282108022292754325022530103525285999179488507720688317761243448898240836430183645778132937666952111134601563043980164547020295727057908447220163534134835130866457657964382363853570827467081988390359191484798677813656413640874450449802233520570178139244957518604566383671867773821069602665918688868868894979351219381089954104823746091972754649316823714354000113723793845707472924569647945844436702275724514171940901057842455729977729388911537391920702753167125695758365521631000334183494148229356487592577177344247694925635113222720411958290166668659311154664393442690740373285505786584987609789805525300762074682544164213490532272590665630428583216403362629445153016404037983825555019274338559686335405719430737559715778');
INSERT INTO x VALUES (3, 0, '-60302029489319384367663884408085757480.2322712404088283093870869198708849258097125725036189625900174440196153781995220721511009855207486224837798752903681993777275846325950111427710563453217985216966456785944859989497422927661683538629473170704026975786513125842675604577233871570629808699803522400038975396500769162308448069085909755023233588510630417065084295051270219462289785473643946404281422516357503746700705970360169619852905053433235726497292406142332833');
INSERT INTO x VALUES (3, 0, '-60302029489319384367663884408085757480.2322712404088283093870869198708849258097125725036189625900174440196153781995220721511009855207486224837798752903681993777275846325950111427710563453217985216966456785944859989497422927661683538629473170704026975786513125842675604577233871570629808699803522400038975396500769162308448069085909755023233588510630417065084295051270219462289785473643946404281422516357503746700705970360169619852905053433235726497292406142332833');
INSERT INTO x VALUES (3, 0, '0');
INSERT INTO x VALUES (3, 0, 'NaN');
INSERT INTO x VALUES (3, 1, '-60302029489319384367663884408085672236.83687099063256754698860828386302509843815398979402006244388708674093244201278399438376682321121138429850885935540924586964982855913223221441591310211730902799041126800414795030815514254713522692405212716783388698431088814919226444677188004928663343696636297536500970117716818423689175692808344185016908913828066250587407384563498516598672584120143890364303296142744031320345312431817858545326010704685255237541162931904446804064783391570102958474141459619245240874849766946530000977144965');
INSERT INTO x VALUES (3, 1, '-60302029489319384367663884408085842723.62767149018508907178556555587874475318127115521321786273614780129829831438626014991843514783028586066905089122532715288580534070605779007112619958852628801540288008918482404759132944298520148080184250697297150817299173701934285646867489426483932830299434150464278537812298564822479785688909850915447762856384542090714278516461905872647123125352735037721325154184406043613668806975385533851732090363979459292404685190942209855935216608429897041525858540380754759125150233053469999022855035');
INSERT INTO x VALUES (3, 1, '-5140349743195574373979577554212527512597024.162480344833040409158673429491690439298506850052285119390701002577176786023622062742050099464897084793357329597395417632908812044304066963549928478520702505283307379218587635434673128958824348493758429380623577527186462464399974242800361134191519694694139153279582776168995426125926314513926640766117733774558011741611075336271613675760116784769700605008122422944290652448956922432960815546502965310676913079866511016221573557684245901002643719965652152439520727383305120298495304784052489867651462175349450610643411043707261107569691076730261762793560088893354750383257372118118753366377402045596735023445172252225346164608897913115394905485106225627590643805003075069931177395059698550161546962768768895596088478488887530518018212441345360153523733317120037436403475909117998647781920105313938836144009539683');
INSERT INTO x VALUES (3, 1, '-707409990019504668223608170643582.082425157530076679823177950190511141917761066423266390864536360056345386873500583953954967225431526056199231768143978526582904071798714789552447782850723926323452633811653766838064983821149041415149067433978085927687765773012158659685363079191901396502099956189371719135315616249471739677995520904113581848295732911534266040260836644379296158092198514963023001686666281725991605685524015227112003429486755206848316731257322742428352116058878710728614841247581716185886403744830796740424927494009978599974431617064012221450054532987372285996679180090592706458366967534834069977644215413076082570497451654516268857039718730203921980307096740864747006176117071983875364434497517026142488015705391255750729200497229031250705777282987863242056223584453312226818451807347197583925624299372040413470456696588043062815');
INSERT INTO x VALUES (3, 2, '-60303024366845387174536638750234506721.2758014749274942132576365116182462208228193753118527959000939070820507877345194783035668195137119648748792386548310474079340204536236936213411512867171486174240518914767934028451971067161683538629473170704026975786513125842675604577233871570629808699803522400038975396500769162308448069085909755023233588510630417065084295051270219462289785473643946404281422516357503746700705970360169619852905053433235726497292406142332833');
INSERT INTO x VALUES (3, 2, '-60301034611793381560791130065937008239.1887410058901624055165373281235236307966057696953851292799409809571799686645246659986351515277852800926805119259053513475211488115663286642009614039264484259692394657121785950542874788161683538629473170704026975786513125842675604577233871570629808699803522400038975396500769162308448069085909755023233588510630417065084295051270219462289785473643946404281422516357503746700705970360169619852905053433235726497292406142332833');
INSERT INTO x VALUES (3, 2, '59993133911282372667149627097418449223835595194300848703012380022306762.154418449236691515146061305380465061074531890529497774836941002526095632166401249277270674802626154774328055399254982998368191676630276960361274433270795772477146870294928855773172789856196219950097157391050424577381777627004101100872747943673762087675405200265837631665464736842180920496158545887039337399558993437594084473932658319914390365451919627956823980800124880375978662052111797881386060353490432427832058851094210488804887183034572364751639107535041308434932952695103493677600969712634416241541391613699710826602011076372592299807609658979777598672141389319098817824624950794758296679318319299142035');
INSERT INTO x VALUES (3, 2, '60612.515523995516156897729403721504966784736064970538891936016753206905080265887046037910122269129293912171105589512464185386239562077778499936203155976336284324712221812806801062157592930664021782540155687632208890794166119782594464410498356083266087045927038416810562596141871858142749062925965665039981381277808608946877852933015970874447235220989360704166270479475802673572039541121473138382812420076284458769543418652217394352637294823914346726065145538710933281768776286965107974980550163605068693568717671571780028113969794125200592691656568731359981803586296135840575095063824258761205175762907549288801963550628589530419118771779395037240198270853609924445368393952404606326559485235840170339343865253618184271158932135392539396160392488927771488269959497352568205940636180870805982484030168838833607478593');
INSERT INTO x VALUES (3, 3, '-120604058978638768735327768816171514960.4645424808176566187741738397417698516194251450072379251800348880392307563990441443022019710414972449675597505807363987554551692651900222855421126906435970433932913571889719978994845855323367077258946341408053951573026251685351209154467743141259617399607044800077950793001538324616896138171819510046467177021260834130168590102540438924579570947287892808562845032715007493401411940720339239705810106866471452994584812284665666');
INSERT INTO x VALUES (3, 3, '0');
INSERT INTO x VALUES (3, 3, '3636334760530744652235488357607657374520053530993537920755375319352615385278.023608692512217812784472508939511216316773023870624171279878340621219698109986095090336065266376220109007718694455520948311677863167090936408887147442375455695868593092154861636486745490748828207939155392396090682312136290864359484540126174821846208064763823279315343506148025281475729723686566174395516982893064510403581479746673749128344955124070957545815390178764940816628194640888255387443237798761377617383817511745005525149990207764725040109364671749403389999498572538135588695345112358160274671918953118753964073105250116426665508214894805722798842017943220605600452911496071424281587802689830031742105619630787641205011894680546049982654601956546154572720177337696285354350903475239411654436042931409507429892682706228354459580412759920815932840348933425754970917910500027837428631661182510071352138858');
INSERT INTO x VALUES (3, 3, '1.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000');
INSERT INTO x VALUES (3, 4, '-60302029489314054989387940744763542234.98295358053252401308872309802346144227050959966671157134780970446370197110016237152333448347415674483796371931316021552756816073493808344537122580089676304958104270609762310229182150728136567294798680824019082599362332377530165818229609055765904048195574142709698758095302560470195171027219786996322461803443213101532716728918363951912367135900414238535625075942525108530051828834829820554490477645701692374399416239080329365045332525699055300921341010989742896430768506909949340276549373661076950964959025967328861569387160956730002517417236732463510495205173523163676450203614971844583064927040066684531931069310935516821795449174271052747559395296525950219449541557191520903507653089998307641491381797101485104546410643');
INSERT INTO x VALUES (3, 4, '-60302029489324713745939828071407972725.48158890028513260568545074171830840934891554534052635383222518357552878529888177277886748756734050012959603126757618322788700853025193884017088688974683399381224865109134889560766307825097103477790782590061456916367930139323346273315068375646692125800496305291080749834712822775973790354498408104142209966769395239768969172107040437333428573572464689550003374384624966403962290572373571842567623422963022155546431883766327294954667474300944699078658989010257103569231493090050659723450626338923049035040974032671138430612839043269997482582763267536489504794826476836323549796385028155416935072959933315468068930689064483178204550825728947252440604703474049780550458442808479096492346910001692358508618202898514895453589357');
INSERT INTO x VALUES (3, 4, '-321372325955692885069615337209737469749246561535004445508427591.072860243358366933071485495726715620133686420023451450292996945184959542770492705998350644739298629407567812798540119555932604687814429669592481327761428042980782672136901602006622227365754036664912989085940235439697789102358431343119457114603363936544931303133371137532006899162833369543279729021228901466728220729625107362063321334489394782322741444425117731922691457341543446841167138481424319752111748042440994701571955325673470021626946676976482516292402239416632497972073915818846704053624707839813514171497746804751780741682011937606462260710753056669269928580460921188286249923152921382198282201761171043384698319895970192114563900025573490442674225227682235790590616707857188385274186584856872573669591460447105688151281208238908470285147895678001948902280493477604361481216667716971590499226735103039');
INSERT INTO x VALUES (3, 4, '-11315021446594.877643290091276308982961654569173523687151347727612592478433578066762912541361898899908505997444632820107356713116459078630334224890355872486337973552333755378190316811715776951317058334754704988120078733912131691682869448731717816749620336196719541702138949084375907248656748314375183301372633028246109596775255074617515860012417935744433243071057057560464360663978361945666099558526069794464437818864063206829678640156992474597480916575712563493776637239091589972373682399519931569163592317107392231951775499293572134702843085474656152913351183535194499521618027894129537558509428098859715020703897463518891082573242502356303078754574312965093639182648263511466558336912294702019648266054331227425119096294871153811412169351624751542166779635702042223762951850816568617453355571302500885410532963789364822647');
INSERT INTO x VALUES (3, 5, '-60302029489319384367663884408738513110.66683195868931664491302527038538338065260819361151478340212147889934633981101279593065290940544218360883531149731823374304151252289014494378769385157204705433009477214625880056478643611622410268943757215673170753460135411513114716313801477916713433956086133878890802448531292334570886746283905390661877220497842493537338035961123751393889400517474762491881277080205381424363695095196058838349029211365212855028824622924678684631803808000307050416047072513406855040715556454205065332997338225626635780147287003130754254277103928406089109802521803537038957372612837169223905290912251006321930223154562110264217937');
INSERT INTO x VALUES (3, 5, '-60302029489319384367663884407433001849.79771052212833997386114856935638647096681695139572314177791340913988441658803134837154906163605506135872443908341816501241365674229987734175441883907154998906319658504271319733469814941611260503645706198407368762270127105340397375230875953495882740039984314121888705481484090911598074635434289709802794549714765847764347865064280637851906308955404165593747173246944693509650424312007333558709071857299501674917023499921977975368196191999692949583952927486593144959284443545794934667002661774373364219852712996869245745722896071593910890197478196462961042627387162830776094709087748993678069776845437889735782063');
INSERT INTO x VALUES (3, 5, '39362489275784146262776411377472433635883331946.794473520543457442955620133347015506556162839462623905489255080102447195050109095701660164272430316804466254467810714209179752718730906325952685817112992943656292503112803950215110778476301809440329937774061163668461957943313261962261081942055908935814323069621279128270849852239727888939033546870208376394878842958202403235309372240005941467570230067124830916866857395233038346727879951123599893174252558078732888910139309038957525961212820831321973219557165558911222848692996406741318948607549825343491479728117062814094258484536263158005174429922237853707635743736923521032098496725445243775790161216159399180889906705265012270270348146530113428221072591696851818281866095288773371414866822270689959827332258348570976075184933893434327278299820594014788148344260948638847457822697682605612771344335201258128');
INSERT INTO x VALUES (3, 5, '92380711368470856513514428781.033155715252174277753317877861994356621252232374386687048394529670637693505779282500567256835271428113529026462111032257747830329068594622091282098767000694818101994264352932243278144124687156236926607422077479412495979777588932692081795130282128890441931602671468684153168580234070246201722180460130467506344034452687371838907269162119534950946217165384250603250357360223255177692065141037447374172264943732616165429783010079281851748804739433821308362193703012671569249508710820679009084891198169587484117171861141580870066764275087111843275285564262902405980617569581840831518012986031156042600391943605532635833608358301306456966765206853910579231447150839538731157206153540873916893579943906851149770881336811951119112558311734171557608362620988555075663589827484854016702489324791126228380209309587206299');
INSERT INTO x VALUES (3, 6, '-60302029489319384367663884408085757480.1853341682137571584926062805631087054017160819890685789064777236456590745415460695320768374693076860837798752903681993777275846325950111427710563453217985216966456785944859989497422927661683538629473170704026975786513125842675604577233871570629808699803522400038975396500769162308448069085909755023233588510630417065084295051270219462289785473643946404281422516357503746700705970360169619852905053433235726497292406142332833');
INSERT INTO x VALUES (3, 6, '-60302029489319384367663884408085757480.2792083126038994602815675591786611462177090630181693462735571643935716818574980747701251335721895588837798752903681993777275846325950111427710563453217985216966456785944859989497422927661683538629473170704026975786513125842675604577233871570629808699803522400038975396500769162308448069085909755023233588510630417065084295051270219462289785473643946404281422516357503746700705970360169619852905053433235726497292406142332833');
INSERT INTO x VALUES (3, 6, '-2830400711649493468815157129316992649.40542786074520931471973065281957756940496588853021620372179463538053123396140685749478530925306163968207226329985017644835203709485594362663495728106061878665324856417118064730721101615473194292620972173690618491026470353143141125614124440035267592258385099934706896692953497971326605145704135723011753705907329979207428661473172503098296622281647255008204864404416199384701720347319806375450632245634238172654086373193251877533131784268854289406126119630708578053354762596511353053106459297339360827562281168219966099848212');
INSERT INTO x VALUES (3, 6, '-1284742031601444539630782308463065726620.121021225455596762466053504195700643301310745151565435123335541550963124666304408503436412726848834604336377169205828654564329888653766451656774534718709065521243637375270687684572524302099749018591530352756390467862377335526634920857924031482455373589053524922608255779040656019538392173139295812160325688504210040741075388404155144782519528791757450256668977268409265390016721724966592135644698341754332845002439113523127047593325646484654291494607100188094186116001064043796216982681807318598789324900462932294782971663150070521334398542559480877366424630693734132836518604260869235580641521264976411493166969530737254118968281271908306432918913600567757535151861421384835424322504855607676315840963696944683182767935565256136130185809101891760917733694553800748568697830680328155128016670099315391685422333');
INSERT INTO x VALUES (3, 7, '-60302029489319384368482818948157603222.2322712404088283093870869198708849258097125725036189625900174440196153781995220721511009855207486224837798752903681993777275846325950111427710563453217985216966456785944859989497422927661683538629473170704026975786513125842675604577233871570629808699803522400038975396500769162308448069085909755023233588510630417065084295051270219462289785473643946404281422516357503746700705970360169619852905053433235726497292406142332833');
INSERT INTO x VALUES (3, 7, '-60302029489319384366844949868013911738.2322712404088283093870869198708849258097125725036189625900174440196153781995220721511009855207486224837798752903681993777275846325950111427710563453217985216966456785944859989497422927661683538629473170704026975786513125842675604577233871570629808699803522400038975396500769162308448069085909755023233588510630417065084295051270219462289785473643946404281422516357503746700705970360169619852905053433235726497292406142332833');
INSERT INTO x VALUES (3, 7, '49383414785234649002982046297226894664526726187218771083.0993243619030008310875293647868815940421844461627295157812843657782639833900543200310573708100000958929315945039020410482966753145208427035917753919085618457760620513481628641658765820294863970581642745379331727722585319163262763708386199720411053619449096019862596221607526610103408936214184850115071874430846697061554769773328338028749631552202705583855831155461651414320570061181212214810086436100771547030013079997847086');
INSERT INTO x VALUES (3, 7, '73634737013325927185.787791148221519354461791539553527545166847382784629235192342551464898036004011575416717008403527685470842765455409054592207142526523023201841973047779202013398235864494503216973882479116841765663948294836180515686647139678530220909072497288527276378202532400736141014848907023234659020093073127450778982904578906877634654521825977382116752537063128793631412296206704078569268566614023846282524151679028060869175439188773864994186109445961525301841201265289707928211114515861536069733921800160245586536759625418951427346236213019358749196674633237197452976517130405065120577692737021174118093373953642724512531935525024447977867020930500433287279183436509990047372809400167546185096048971157700858970777301410692908939206693154161335335755844997198191427289546263182822280127912118140820265025555165337881999926');
INSERT INTO x VALUES (3, 8, '-60302029489319384367663884399588771256.5916339968771732477072012126949734214868901845505193155307646111690097978112797961939995859130827784737422228762767014427842766445950111427710563453217985216966456785944859989497422927661683538629473170704026975786513125842675604577233871570629808699803522400038975396500769162308448069085909755023233588510630417065084295051270219462289785473643946404281422516357503746700705970360169619852905053433235726497292406142332833');
INSERT INTO x VALUES (3, 8, '-60302029489319384367663884416582743703.8729084839404833710669726270467964301325349604567186096492702768702209585877643481082023851284144664938175277044596973126708926205950111427710563453217985216966456785944859989497422927661683538629473170704026975786513125842675604577233871570629808699803522400038975396500769162308448069085909755023233588510630417065084295051270219462289785473643946404281422516357503746700705970360169619852905053433235726497292406142332833');
INSERT INTO x VALUES (3, 8, '-512385513828318260570283740065493064477880918352.732624553690077857674083796435724202494963885926573907185100543184828131859183999195040110586155435203949963570735841632689374488877298209082579317039061893012560130258753218955057387206477423088065663401594359617882154814262843273526859406265633827109554791772242178864873774889091687515990672487380368975556580539271333144212685871370972163560839446696514092637412587953506052848750866803569213269271165856310101244342151576488190595936869490659700946174362872797854591188391982770203203644172999264143929484089237665313698600170041324566984832357000400');
INSERT INTO x VALUES (3, 8, '-7096872691348467943606706217.907270287823269424282176534343841939501231816905820949045946136373255017076943323578903040918266385724756894003692978391468202345397178445216069294845721607024056189567609414049207292919519881725733381453217071918292453682942046440563446278374996563501512335133749731529362537349288419883140401056747081065947774593869673146309163791076953204291951821124894409171722911526435445719071769008713367057971351892550570642991097981458696464929009464411568672010548002196406312721789582428747564855324072212842315229302959908665089850886951261233852165624100634055045684536311382452553544676139507899503993644452161529145849579200003677255968757773363970434791501820320494192909660871475590637419913907191608957830524390049664686282439567943053924245852983990958276537000732363895444894582579142752920882750130052682');
INSERT INTO x VALUES (3, 9, '-60302029489319384367663884408030893999.8854209703537480818248540990234567956069965340942024890856088355839135538265116174644003927269495876835324407641642359213535695803871472434650475144516723617632059130297610134243891145006222068960999879308472500422640481972089756410157246974765071949782242392661524488959954348903412713930092273629207697480131360047867213863018127928853922173643946404281422516357503746700705970360169619852905053433235726497292406142332833');
INSERT INTO x VALUES (3, 9, '-60302029489319384367663884408140620960.5791215104639085369493197407183130560124286109130354360944260524553172025725325268378015783145476572840273098165721628341015996848028750420770651761919246816300854441592109844750954710317145008297946462099581451150385769713261452744310496166494545449824802407416426304041583975713483424241727236417259479541129474082301376239522310995725648773643946404281422516357503746700705970360169619852905053433235726497292406142332833');
INSERT INTO x VALUES (3, 9, '-3308379209762459471107480259839508279070920437.883503980178028214343751083865562028455061662673132221930429904398963590401793045470444301883103141901787466923883803951815572606105617157736442670792467625964359169270739534412932791178258858918086886061702512427989129732248215348301444245772127142869263635282888226326427510486246184233225114523636171202034558843515894542952126988613018789833835507734620046994907453602573865012044120483116345444810078666601100257620969379968264504287700045822481492526688635364586344704730579892342786173395802035361824932075736340405960099542224953439044947229246847140957298841482874444906129049023002897135347878048572628834749795298712449864571996898774444932083319581439741625832405434317985988163261591679157437224404970927012111196724239860528859217322132733404472897289');
INSERT INTO x VALUES (3, 9, '-1099128766678422054524173986658.839339966689456265703816212189145237878729886466041806078542573981227645802109969871638687985985845489422516004202630099080709709893022100481258818112345013009059633421290241583864468453396484606925071369550998772875840640325758308835852391176503689677263605949075815552026731067384737231681068134099746550363063940273625924224721503126912810251607546172009765059506591787282558727077669973711491157840340631805422942099954647016059576777054339588421998882440726473698513560202030309804089250300097589174314677765341104767702983421063649104691583044460507666600260994707192787133590502137391691330098102374713996115782701417107878938473243874299874872852713499024851414757892169376458916467621226859152075901273014182163212783658933754507272478777304254191033562324994395916168496097385872331012258027431094381');
INSERT INTO x VALUES (4, 0, '5329378275943663322215245.24931765987630429629836382184742348353920297283690739124220773955591340709935970062776650204659187764581615597720798385015942389765692769739983054442503547211560297249686289665792078548480268091496050883021187158502798880896590227542729659940394038802461081290690995869705131152889309663639310553909874081663091069118126221594338242710530718836025225507189149221049928936955230868771875644038572888630664890573507822342998964954667474300944699078658989010257103569231493090050659723450626338923049035040974032671138430612839043269997482582763267536489504794826476836323549796385028155416935072959933315468068930689064483178204550825728947252440604703474049780550458442808479096492346910001692358508618202898514895453589357');
INSERT INTO x VALUES (4, 0, '5329378275943663322215245.24931765987630429629836382184742348353920297283690739124220773955591340709935970062776650204659187764581615597720798385015942389765692769739983054442503547211560297249686289665792078548480268091496050883021187158502798880896590227542729659940394038802461081290690995869705131152889309663639310553909874081663091069118126221594338242710530718836025225507189149221049928936955230868771875644038572888630664890573507822342998964954667474300944699078658989010257103569231493090050659723450626338923049035040974032671138430612839043269997482582763267536489504794826476836323549796385028155416935072959933315468068930689064483178204550825728947252440604703474049780550458442808479096492346910001692358508618202898514895453589357');
INSERT INTO x VALUES (4, 0, '0');
INSERT INTO x VALUES (4, 0, 'NaN');
INSERT INTO x VALUES (4, 1, '5329378275943663322300488.64471790965256505869684245785528331091076155554650629138833809683459634328609777839510066435612911583108717191216693735823717997111970662575497378762952496582183738308720094529950793570383580785385569873278068217936841324404119828637880370718028782103860007754579779716996004352284614661690063919125301052941328989181561787543541920734755989452320799185700078241880935083616978140555713297241612718277766918005268951861880490889884082730841740604517529391011862694381726143520658746305661338923049035040974032671138430612839043269997482582763267536489504794826476836323549796385028155416935072959933315468068930689064483178204550825728947252440604703474049780550458442808479096492346910001692358508618202898514895453589357');
INSERT INTO x VALUES (4, 1, '5329378275943663322130001.85391741010004353389988518583956365616764439012730849109607738227723047091262162286043233973705463946054514004224903034208166782419414876904468730122054597840936856190652484801633363526576955397606531892764306099068756437389060626447578949162759295501062154826802212022414257953494004665588557188694447110384853149054690655645134564686305448219729651828678220200218922790293483596988037990835533058983562863141746692824117439019450865871047657552800448629502344444081260036580660700595591338923049035040974032671138430612839043269997482582763267536489504794826476836323549796385028155416935072959933315468068930689064483178204550825728947252440604703474049780550458442808479096492346910001692358508618202898514895453589357');
INSERT INTO x VALUES (4, 1, '454294299613767152878025320780.534199313974295807138790763501115780294529340799108297697573066187975311338382917022391830256203305238757334106943821060545424417350991354829668286194840925251162479496893943917530660694097932059166013476064988623431110002057735318529554555260199417935495388243829261809007709919225000608711536928171687251088217591210419208480251102484043683131687013687838713055660405381318396419588727500715930145098362997142075433472039319292466570912777345841400769387321465602989947078951135489852486382469990409873227894248208197179481868230244584527040573428134962626267135732247029762468417273891700661832893497067151409134724061246612631376075173287264787886064622106855886785805818642123776489793586531950438285720668411465570116161790343538663297713926678759640594912243360541590368666922379919514826022141331900181');
INSERT INTO x VALUES (4, 1, '62519544780217042176.800424689664850775296526267109332647921183817056683200043718160298562843864918741523494444361916531159341418970534833628106062976341639276761669219281771109561175175033739624472497927501467465456946098280878993371659461957361369508794842102784763955539708800574418468150309301129490186416766691183270872711413796386178009615777589066235359283212636467980113350635181915492452697347977967985810294150853782607014649150457138118264698071689065469752702524632313088938504181640435324554007553994564705401249228914199354821595855823113730697333390936834057091883654016371107974899726642500486005445063301647520527084320363513388355471718583708935211830796440056542408492723718088396437530207347815505844074508948817594746824098278470533148171941442049323578854023683167934569551595335539887777638716651319134577441');
INSERT INTO x VALUES (4, 2, '-994877520673428596810678826533995.79421257464236160757218576989993781147390382997132644206786872350652200243563770552469933194637146474528320738725486418004701192337175478117026439697031462361180324038544450723753402846519731908503949116978812841497201119103409772457270340059605961197538918709309004130294868847110690336360689446090125918336908930881873778405661757289469281163974774492810850778950071063044769131228124355961427111369335109426492177657001035045332525699055300921341010989742896430768506909949340276549373661076950964959025967328861569387160956730002517417236732463510495205173523163676450203614971844583064927040066684531931069310935516821795449174271052747559395296525950219449541557191520903507653089998307641491381797101485104546410643');
INSERT INTO x VALUES (4, 2, '994877531332185148698005470964486.29284789439497020016891341359478477855230977564514122455228420261834881663435710678023233603955522003691551934167083188036585971868561017596992548582038556784300918537917030055337559943480268091496050883021187158502798880896590227542729659940394038802461081290690995869705131152889309663639310553909874081663091069118126221594338242710530718836025225507189149221049928936955230868771875644038572888630664890573507822342998964954667474300944699078658989010257103569231493090050659723450626338923049035040974032671138430612839043269997482582763267536489504794826476836323549796385028155416935072959933315468068930689064483178204550825728947252440604703474049780550458442808479096492346910001692358508618202898514895453589357');
INSERT INTO x VALUES (4, 2, '-5302078674303935968062773235453828254014583744527466365136.236414807326868572353809920518232561005161225922028750078608989965741402418802255050636954800114792425419735155504035469350521800895164087027043476055514245942961100610551646034472084954313670284875310691807937254054948742125729353864014122131419164449567115006621212424805182687707372956385102095255735458593389920872596796806885847543910224476727171570873698525606016990229936284811067826588349092841322512643043008589065847223683467371925773023109720951609815041012521485326120380123169545818055967455575736140138663815073081494226676896278654189873597341203197903408668523514375373841493189836809506003729379742035629498519683885268256481104619815130659628225053833297766479068686119691010593208135616363994230674606991733148502293102108193522604968743948323130517040609601859735899914987426089053869350663');
INSERT INTO x VALUES (4, 2, '-.000000005356818439105666775800262590702859770599410113087721172791624002387236505438218124867814437523686300450045582100868990117124343222534568799037421944272316277130975314766456260710406160143182498931595199129228915695802952695510723443157825968340043198200740606202264287904755124946591110599335909404657109057432686191440989434662797205973563889238804413861126260401987949920244286377128599413927273444061572120561496904543200956508673923547626768641271397088562966176629018606103663605145666976048261236691866387601532424530473754175270500777679603569715192364542901360534980926452487443629100484491344001509360344122933911316486556042277769848194790964257060927912344609376571637126617813506411190014141992988288983968823792971270853369317867326071952900448455162898476163801382836761898292684175721846');
INSERT INTO x VALUES (4, 3, '-60302029489314054989387940744763542234.98295358053252401308872309802346144227050959966671157134780970446370197110016237152333448347415674483796371931316021552756816073493808344537122580089676304958104270609762310229182150728136567294798680824019082599362332377530165818229609055765904048195574142709698758095302560470195171027219786996322461803443213101532716728918363951912367135900414238535625075942525108530051828834829820554490477645701692374399416239080329365045332525699055300921341010989742896430768506909949340276549373661076950964959025967328861569387160956730002517417236732463510495205173523163676450203614971844583064927040066684531931069310935516821795449174271052747559395296525950219449541557191520903507653089998307641491381797101485104546410643');
INSERT INTO x VALUES (4, 3, '60302029489324713745939828071407972725.48158890028513260568545074171830840934891554534052635383222518357552878529888177277886748756734050012959603126757618322788700853025193884017088688974683399381224865109134889560766307825097103477790782590061456916367930139323346273315068375646692125800496305291080749834712822775973790354498408104142209966769395239768969172107040437333428573572464689550003374384624966403962290572373571842567623422963022155546431883766327294954667474300944699078658989010257103569231493090050659723450626338923049035040974032671138430612839043269997482582763267536489504794826476836323549796385028155416935072959933315468068930689064483178204550825728947252440604703474049780550458442808479096492346910001692358508618202898514895453589357');
INSERT INTO x VALUES (4, 3, '-321372325955692885069615337209737469749246561535004445508427591.072860243358366933071485495726715620133686420023451450292996945184959542770492705998350644739298629407567812798540119555932604687814429669592481327761428042980782672136901602006622227365754036664912989085940235439697789102358431343119457114603363936544931303133371137532006899162833369543279729021228901466728220729625107362063321334489394782322741444425117731922691457341543446841167138481424319752111748042440994701571955325673470021626946676976482516292402239416632497972073915818846704053624707839813514171497746804751780741682011937606462260710753056669269928580460921188286249923152921382198282201761171043384698319895970192114563900025573490442674225227682235790590616707857188385274186584856872573669591460447105688151281208238908470285147895678001948902280493477604361481216667716971590499226735103039');
INSERT INTO x VALUES (4, 3, '-.000000000000088378091435340426596348183959201660680284222502095357746364378698792730669202270228092348823133529449019715406417264278615046537007844589547485282959556860316942508808911542109265489435572674031608663747132688980867386885961271358592278360097086532747883342438036287136994589308551796702164612609710942175900921197001888540314760352113821737014875886635147123114456910985089625906448913621495025509697742196814421833448856595853403450682101743559369637786458968714240975228615283970739279506239628546165569688434254286341567486905374255702980370754235630955328837646999003123103831262789115646588779721625156078607919060762857866951417867378220773543985422722165221371084387943737083254760594128718841665355053236168688218864433967871311858292181233490194833547273501436630325295640020916257836404');
INSERT INTO x VALUES (4, 4, '10658756551887326644430490.49863531975260859259672764369484696707840594567381478248441547911182681419871940125553300409318375529163231195441596770031884779531385539479966108885007094423120594499372579331584157096960536182992101766042374317005597761793180455085459319880788077604922162581381991739410262305778619327278621107819748163326182138236252443188676485421061437672050451014378298442099857873910461737543751288077145777261329781147015644685997929909334948601889398157317978020514207138462986180101319446901252677846098070081948065342276861225678086539994965165526535072979009589652953672647099592770056310833870145919866630936137861378128966356409101651457894504881209406948099561100916885616958192984693820003384717017236405797029790907178714');
INSERT INTO x VALUES (4, 4, '0');
INSERT INTO x VALUES (4, 4, '28402272808100253242547006276715304015308580784958.804614276533085644370816876160290159450291717634111299841065255625515058118012211808741402904995080624675460593676923639082981788732031193774047612589113654423166826140872334380708795266307037944059108148612979119729408762532396036043629484049508789880964586236575769826806092391573178899640321403656891487586452524427223891405519836671312830183895761747460911777623703557946796784873885800089025388390522992806365773290733075927321101736155663727528284512100509273076328103465333687228713897893434161293693971954442699482857938492961830350598789444266860160794913830991304996676299650460125000959751177037694425217989910261807246272771711816326991282202653917488360776928533800529297474279497910326579608191975246060946079639658615178160271122713225105861574160788280907842327681375920919676063500116492292319');
INSERT INTO x VALUES (4, 4, '1.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000');
INSERT INTO x VALUES (4, 5, '5329378275943662669459614.81475694159581596077242547133292502869630735172901157043010370467618244548786897684821457816189831652076071977025794948484549600736179389638319303817478693948215387894509009504287664213474693208847025374388286162907794727810231557001266897729978691844410171412189947386181530441402903608214502713480332746271552746231631136145916685939539173054989927058122097304419584979598595477177513004218594211597809300517607260841648610322863666300637648662611916496850248528515936635845594390453288113296413254893687029540384176335735114863908372780241463999450547422213639667099644505472777149095004849805371205203850993689064483178204550825728947252440604703474049780550458442808479096492346910001692358508618202898514895453589357');
INSERT INTO x VALUES (4, 5, '5329378275943663974970875.68387837815679263182430217236192193838209859394480321205431177443564436871085042440731842593128543877087159218415801821547335178795206149841646805067528400474905206604863569827296492883485842974145076391654088154097803033982948898084192422150809385760511991169192044353228731864375715719064118394339415417054629392004621307042759799481522264617060523956256201137680272894311866260366238283858551565663520480629408383844349319586471282301251749494706061523663958609947049544255725056447964564549684815188261035801892684889942971676086592385285071073528462167439314005547455087297279161738865296114495425732286867689064483178204550825728947252440604703474049780550458442808479096492346910001692358508618202898514895453589357');
INSERT INTO x VALUES (4, 5, '-3478781676337858247983014311182511.567538638808357215203593479841446379226774481291286361639429856698999485760647422501864626078375852610019829111004807806660731243672830787729048847342063218718651165150612717759770504648306347926061960607388621011846314969634048226452709389995594961695723139571002939804473057725442880410434039783304583526414509590532906062732322732569475349107437896717416548237633532805602064623969799081086996320156575550896200848758685986331692388099427314008504506503745527468550106879602399030419569897808150076298414568875477195447656904373310322813412927463518325927626891046356679526447117311923853482118502868148386882363449163182892615259995945992014431502761210899772725227648729095696228388558331052524469604046072203605897109629560683446827492904111565278516043939137760721315953500281379039771826554155511347152');
INSERT INTO x VALUES (4, 5, '-8164430956184510.184223536017248184022252663660196916321116266103608317725855237211273642694947892658721606226082017525816544904635887836163201565923338826779819876742736219975639586566502584026349778499211535661173597356253186281116862244165796632756909578140184577853088376334255860281874385669242675881761388233070861374295536603371778669602656670852115614651462552069294889723058758969660566508798011830996965570446030123780674316363670374970480994905368006454513642480180066435609577311074332150098288374616437489163254821095377348025470309665651059603665062887597814064136313866690824972464351274062540825405003954064175728198182815347642172934453828192850870808373638597839434504241236228591053696481146252072190903430582534862988719805163692697482513169856291048966811374872266165034373412719593685881972700171726777938');
INSERT INTO x VALUES (4, 6, '5329378275943663322215245.29625473207137544719284446115519970394719946335145777492574745992986971075733570324679065009803281404581615597720798385015942389765692769739983054442503547211560297249686289665792078548480268091496050883021187158502798880896590227542729659940394038802461081290690995869705131152889309663639310553909874081663091069118126221594338242710530718836025225507189149221049928936955230868771875644038572888630664890573507822342998964954667474300944699078658989010257103569231493090050659723450626338923049035040974032671138430612839043269997482582763267536489504794826476836323549796385028155416935072959933315468068930689064483178204550825728947252440604703474049780550458442808479096492346910001692358508618202898514895453589357');
INSERT INTO x VALUES (4, 6, '5329378275943663322215245.20238058768123314540388318253964726313120648232235700755866801918195710344138369800874235399515094124581615597720798385015942389765692769739983054442503547211560297249686289665792078548480268091496050883021187158502798880896590227542729659940394038802461081290690995869705131152889309663639310553909874081663091069118126221594338242710530718836025225507189149221049928936955230868771875644038572888630664890573507822342998964954667474300944699078658989010257103569231493090050659723450626338923049035040974032671138430612839043269997482582763267536489504794826476836323549796385028155416935072959933315468068930689064483178204550825728947252440604703474049780550458442808479096492346910001692358508618202898514895453589357');
INSERT INTO x VALUES (4, 6, '250145412892811547138949.592621291590152419206270097656346630226508074074623894951308487425470437268130465956063593951784820669318897182831355375451719125809800516979013437732298382708070979871283132689492336823087794373113039154669229889503700598930220858275174342776478898670277868700384853696009897221747924643343353942154528501454689084608965009561564638167714973711022212547096732831847202912862290958304510651828842182545311077713664465815992616213663619529378061133917572474298028065850515876361609671565914027186063801852554353160801534696062207299890867876199323530337336273950892723090754719547285920090419070001019943385293110663922226230169381423410428577990604776655422105400452217085311617728003688836185608912367677734364834577573255789160419371322775733777518997638403409000055707558465286469808848200141192627396502735');
INSERT INTO x VALUES (4, 6, '113543048739697485358574290.758354267447744932153707340542459183720907885610125346262898114677742971240785031722334497858930434531517077525413654346644836353208132641713415396062580605566225794048569430676355036264762949452090151450855446984773994337170590068740235544320694721909983307239491151139099779296496785240814600627140543144068640768857707110930453204162312973998304574796413938461971472337040811785231390930046688391955000749644938061585377150632133417156866197053052425576957646564943278156977176976876921235395711611898108821587442609611001702344783440618040704066809035404237786023075676374788819144406909313755996914145273176359246052899650387182222905558751208368173052381982668563471143298720677965028880626152749773712037769548408324298835212547215352657271696665387200792785056233953536347605130973626194099064678842085');
INSERT INTO x VALUES (4, 7, '5329377457009123250369503.24931765987630429629836382184742348353920297283690739124220773955591340709935970062776650204659187764581615597720798385015942389765692769739983054442503547211560297249686289665792078548480268091496050883021187158502798880896590227542729659940394038802461081290690995869705131152889309663639310553909874081663091069118126221594338242710530718836025225507189149221049928936955230868771875644038572888630664890573507822342998964954667474300944699078658989010257103569231493090050659723450626338923049035040974032671138430612839043269997482582763267536489504794826476836323549796385028155416935072959933315468068930689064483178204550825728947252440604703474049780550458442808479096492346910001692358508618202898514895453589357');
INSERT INTO x VALUES (4, 7, '5329379094878203394060987.24931765987630429629836382184742348353920297283690739124220773955591340709935970062776650204659187764581615597720798385015942389765692769739983054442503547211560297249686289665792078548480268091496050883021187158502798880896590227542729659940394038802461081290690995869705131152889309663639310553909874081663091069118126221594338242710530718836025225507189149221049928936955230868771875644038572888630664890573507822342998964954667474300944699078658989010257103569231493090050659723450626338923049035040974032671138430612839043269997482582763267536489504794826476836323549796385028155416935072959933315468068930689064483178204550825728947252440604703474049780550458442808479096492346910001692358508618202898514895453589357');
INSERT INTO x VALUES (4, 7, '-4364411947278810125327066890819882483326918.05664098958260550284395870948992407314161088028674246708928421994893923699743452802989464864039994566042797942433140378990308345483670828497915478397481687305406460330009319949623844175096007381662809083363069100235985794575399268709260901964834244796150883807308976949196661411035264619638771824190014274817662519438658481432363824187693821267613212631153175155634316128036152465184903927860719447693468054624663668062006049759837326188252927823612718163916100588143128358998656306593393889422386501730237442526450419990376323903182669190482615734972147533221144682538647497701130447816148459762464395194383090936159579764712919396391813914821973715879062992249315474841639591907249142779103650773383644785606333916967894');
INSERT INTO x VALUES (4, 7, '-6507697.520580964829176145824902679560705744817573189143227837387224410616222039115571544850095278317993922427931439719549137387753697989249394347047436951117850128104928719365703899136632100669607126357491484781141296021264049762417528697619931558728863308905257358126654378784709213859234056696519305650316810797382293500878834933984458810656133463638442959750083607649924453935287420620424368291770694630751828333903156364366745210911640207075765008558904788350844410055253643515389003711759818446776538393914018427075074171758415188027562645239606914126802490579848138218395145734902830046359100742374008993296019987093605275289913663224324033923096998194326249508491872193747944673057257521552387923218450155737056841633810711295424578984452176016198348344913655301417872189073133147510027427530833694019910340299');
INSERT INTO x VALUES (4, 8, '5329378275943671819201468.88995490340795935797824952902333498786202536079000703830146057240651898748760197658486790165425772165585380839129948178510273188565692769739983054442503547211560297249686289665792078548480268091496050883021187158502798880896590227542729659940394038802461081290690995869705131152889309663639310553909874081663091069118126221594338242710530718836025225507189149221049928936955230868771875644038572888630664890573507822342998964954667474300944699078658989010257103569231493090050659723450626338923049035040974032671138430612839043269997482582763267536489504794826476836323549796385028155416935072959933315468068930689064483178204550825728947252440604703474049780550458442808479096492346910001692358508618202898514895453589357');
INSERT INTO x VALUES (4, 8, '5329378275943654825229021.60868041634464923461847811467151197921638058488380774418295490670530782671111742467066510243892603363577850356311648591521611590965692769739983054442503547211560297249686289665792078548480268091496050883021187158502798880896590227542729659940394038802461081290690995869705131152889309663639310553909874081663091069118126221594338242710530718836025225507189149221049928936955230868771875644038572888630664890573507822342998964954667474300944699078658989010257103569231493090050659723450626338923049035040974032671138430612839043269997482582763267536489504794826476836323549796385028155416935072959933315468068930689064483178204550825728947252440604703474049780550458442808479096492346910001692358508618202898514895453589357');
INSERT INTO x VALUES (4, 8, '45283653791262997781451381354094822.762732909505051438036873220502792213670540454778361182993875916509061144859281577740137081988678361247725064336120451090222456518107029158304937620179032477664627949959143233370320432203497828243297406462513350790251761540074946469824444452248386782451723637769289822576372357189700319768797708375563651655860093365309717823602754924352327588945034832436331911584742966378275504545736896430718939807674966738116698454215555860047859161126694019895490767779791933882712567492115664113775047192011252893773389940988533801360010782816196288710063568554147458866942816721046004257953642508395867837127678980002737669139369781058046396738606563716339660654364541530532834806205571191828994250708412638796240377704994928921528330863683630622922959130920715261879547446054261914770022377059156125037157979236658010950');
INSERT INTO x VALUES (4, 8, '627208063620965.397582272040628872773601055303353339700043792111288801181637510303989399395425313995651311362368773096988861977687484912995632130587762386590996099363383976320342247076516604162469063709298438133327434461462906199160715395064249299615054970359309619951777972710299484596875999967582794277241285253106817446259313281064844416249524876385699646393555435017820686376877981018047574348711991428666249794623006175739581915209218834701034964043360823844816042368184094857692062884223864639972005010863342567608351008172649209459933114800143792514183138995700133608613158857147417653998048890116531052767737435620558349226865105888201598712435680481803901906613772821370519525404423549161696526405320391828194356063547089626322474164332505209233143121068245585662919687001395119229263995765376465304715643388771609446');
INSERT INTO x VALUES (4, 9, '5329378275943663377078725.59616792993138452386059664269485161374191901124632386474661634799161523147237015531446709484039091244606359050341194730653343894986479159670583937529516163204904273806158788218327396375034882788180783796976731912141525319602448709213495905899041406302673881364465504945113279286939663215197485367850132991968081639290297033476859158044889351836025225507189149221049928936955230868771875644038572888630664890573507822342998964954667474300944699078658989010257103569231493090050659723450626338923049035040974032671138430612839043269997482582763267536489504794826476836323549796385028155416935072959933315468068930689064483178204550825728947252440604703474049780550458442808479096492346910001692358508618202898514895453589357');
INSERT INTO x VALUES (4, 9, '5329378275943663267351764.90246738982122406873613100099999535333648693442749091773779913112021158272634924594106590925279284284556872145100402039378540884544906379809382171355490931218216320693213791113256760721925653394811317969065642404864072442190731745871963413981746671302248281216916486794296983018838956112081135739969615171358100498945955409711817327376172085836025225507189149221049928936955230868771875644038572888630664890573507822342998964954667474300944699078658989010257103569231493090050659723450626338923049035040974032671138430612839043269997482582763267536489504794826476836323549796385028155416935072959933315468068930689064483178204550825728947252440604703474049780550458442808479096492346910001692358508618202898514895453589357');
INSERT INTO x VALUES (4, 9, '292388240303165948041827159734686.255558469787242316676287235194652580157149226950109397295920730296960145548003120827363226435916209781396711693581454960342091452830648929118261388933297036933167543189308061917640517578583521401267417187854611829815212778183983326568586118831109538377828156118900313778053576483381085207892754728937946691892849474364477434665960112125254104966566712906532318984871145605839506991591027939136026602051635433295687547552796828217859648186757719639965988287173297286034098497871707197092627676226053609131138590878743560287292934815277894463305001278326023708395571840850120055316276256138004565442099731931051413153564744766098053176049414330146267604802971221161572130161432525297614616942172815141372973870720928125699420370428856022295499447755488148545048400795053604349570217878099721865670458104653570360');
INSERT INTO x VALUES (4, 9, '97138902640718538.241246716463110895614166618530828908023040947887095196830690221211560526562522274118188963051412359798837957512805692731972838989047910709158995922699598619854907969493232150042212406549916252602794415099066259707018021422154933830674786488990033885447289593742424717170197810316367637885248684134204152352748803532396210051700193575105804898183523770153431536054848843504020390623875664696278263569145547515663340450903772852615789980257449146000410036925975898331113013857953289990299253584950458042598491897496393582249411290555264437893099880371008957017323366523688894303458743415715114628052487518110654201696604914159777300997374156315186315524817636714210119873791848535246674326877611945112249137224923201544452904111118569299934059002046318394345055859769572070097973298522564724884895879226870720839');
INSERT INTO x VALUES (5, 0, '-652755630.43456071828048833552593835051449845484289562110789582081210403487973096161149072377955192388469356112505543620695003436531392789029513380101663750625024853263344909355177280161504414335005574882649025508632900995595004153086358670541462762210415346958050909878501048483523600711486406055424807840429541335391538322886495085448421556770991545781035298449067051916630343957356635391594362639819978677032855590055900561501350354631803808000307050416047072513406855040715556454205065332997338225626635780147287003130754254277103928406089109802521803537038957372612837169223905290912251006321930223154562110264217937');
INSERT INTO x VALUES (5, 0, '-652755630.43456071828048833552593835051449845484289562110789582081210403487973096161149072377955192388469356112505543620695003436531392789029513380101663750625024853263344909355177280161504414335005574882649025508632900995595004153086358670541462762210415346958050909878501048483523600711486406055424807840429541335391538322886495085448421556770991545781035298449067051916630343957356635391594362639819978677032855590055900561501350354631803808000307050416047072513406855040715556454205065332997338225626635780147287003130754254277103928406089109802521803537038957372612837169223905290912251006321930223154562110264217937');
INSERT INTO x VALUES (5, 0, '0');
INSERT INTO x VALUES (5, 0, 'NaN');
INSERT INTO x VALUES (5, 1, '-652670387.03916046850422757312745971450663862747133703839829692066597367760104802542475264601221776157515632293978442027199108085723617181683235487266149426304575903892721468296143475297345699313102262188759506518376019936160961709578829069446312051432780603656651983414612264636232727512091101057374054475214114364113300402823059519499217878746766275164739724770556122895799337810694888119810524986616938847385753562624139431982468828696587199570410008890188532132652095915565323400735066310142303225626635780147287003130754254277103928406089109802521803537038957372612837169223905290912251006321930223154562110264217937');
INSERT INTO x VALUES (5, 1, '-652840873.82996096805674909792441698652235828221445420381749472095823439215841389779822880154688608619423079931032645214190898787339168396375791272937178074945473802633968350414211085025663129356908887576538544498889782055029046596593888271636613472988050090259449836342389832330814473910881711053475561205644968306669776242949930651397625234795216816397330872127577980937461350104018382663378200293023018506679957617487661691020231880567020416430204091941905612894161614165865789507675064355852373225626635780147287003130754254277103928406089109802521803537038957372612837169223905290912251006321930223154562110264217937');
INSERT INTO x VALUES (5, 1, '-55643106304872.575994253221940844841058071061962511162776681458310912066379595519265546225338405882027547140476045378015935579066580347282075024392379464189067155567624835346798806677988850250198082355055954078446421075165109896091047534711081616362392995575466807084807876544560268050611445006601394735810211678919646667455478469014906335433468365011768049600750224822391684377238242162320161552720449713229523135506671063115436813348612986916614320012995541575293478341408982118538094438068036422562665160411591652618670802973618768526197813319204816293073794413317669922144705633308090832805914096147659820167569140291210526520361556881576175809360614782817717579318298657744021133210954279487777567785280633309576696708168342539425395482429923273623865667723482418178781573723597156804085501875735112311466228778929147929');
INSERT INTO x VALUES (5, 1, '-7657.550797567691019915353529993301413746369700087741672762343206271266232635965032053368224472333368713006346867984576168784127503674579531243603836945595880917241997606783133673324236134063757452734295148763280059050480246827193380861494669624151921824660313516974440913733511526807313019192263170823268678149435664224184903925632177789052038092611394447709922076676981043877747276056677801802695466205531230350209787298926245402046182150996849906836743231861317120171583577624262765589605263477198809166390259128339127005924586833372241946051704497188891325715185091060185547236923494393813210904033520844572880475265306843414506359253445517738473745552980984097762509546161690823646176501838559393690565709795724159196133663168004773260451322595899506776323262195323943138344537866088159583331807728944620284996');
INSERT INTO x VALUES (5, 2, '-994877526002806872754342801504871.47809095279915423939648794226185974985600242391612965412218049794216637114648812993201775787765690351615479957141288239552036371132381627958673244764559862836085530643408020551049895730005574882649025508632900995595004153086358670541462762210415346958050909878501048483523600711486406055424807840429541335391538322886495085448421556770991545781035298449067051916630343957356635391594362639819978677032855590055900561501350354631803808000307050416047072513406855040715556454205065332997338225626635780147287003130754254277103928406089109802521803537038957372612837169223905290912251006321930223154562110264217937');
INSERT INTO x VALUES (5, 2, '994877526002806872754341495993610.60896951623817756834461124123286284017021118170033801249797242818270444792350668237291391010826978126604392715751281366489250793073354867755345743514510156309395711933053460228041067059994425117350974491367099004404995846913641329458537237789584653041949090121498951516476399288513593944575192159570458664608461677113504914551578443229008454218964701550932948083369656042643364608405637360180021322967144409944099438498649645368196191999692949583952927486593144959284443545794934667002661774373364219852712996869245745722896071593910890197478196462961042627387162830776094709087748993678069776845437889735782063');
INSERT INTO x VALUES (5, 2, '649411906691138274293985410502516861224852.2323455192714410716272307781034189160865613770320102043319541634113746032638191509585045862973333645830298922352816245477556264222094036953195419857712804755170632292914187367964994214922001758104594052499795564860466055599417895782179851297585155129541589802249540436678824225950907268084876110445460948679383611117263673106597132046331719468816839434908155684738864149955129235751738204036443603521478609787295079710078973503970964790273461142497259987849074597264522099648376356902360358310245001183020992360260836105404118742418040965190000718736837422434593694808973939805954329718232693154128543253581495885789333274488461716809104532693754070810202831113003978085636579574171344721710232931261731022478029314435363413498991740750878099825781577297965642009156858479681236085226911858782115');
INSERT INTO x VALUES (5, 2, '.000000000000000000000000656116570506105776235076334177868550033347254561166417969910286926369599900073757929714260350320362090452092025380232792749476245042480546813848702351830607516880397305138543526307608094143028291193163613755680419049060162928958489964834941920423432354996040147818253087783193280640282263490705632002572757216731766513434035163528102590524432221718194164133959630768718395847710529339782880381264265894322494716854757290930538739000043383104085867828258790010654331660516512156519838978751447311068903958136482041673109857552178367614498426226323001399275980281507353231821022591045797658991388304873240910526149138339658220844723880158150606035181559877351791752701872877147074033569061408920725522180134133183999181370354585872214368766629114773129541658653693832843354053701079334077');
INSERT INTO x VALUES (5, 3, '-60302029489319384367663884408738513110.66683195868931664491302527038538338065260819361151478340212147889934633981101279593065290940544218360883531149731823374304151252289014494378769385157204705433009477214625880056478643611622410268943757215673170753460135411513114716313801477916713433956086133878890802448531292334570886746283905390661877220497842493537338035961123751393889400517474762491881277080205381424363695095196058838349029211365212855028824622924678684631803808000307050416047072513406855040715556454205065332997338225626635780147287003130754254277103928406089109802521803537038957372612837169223905290912251006321930223154562110264217937');
INSERT INTO x VALUES (5, 3, '60302029489319384367663884407433001849.79771052212833997386114856935638647096681695139572314177791340913988441658803134837154906163605506135872443908341816501241365674229987734175441883907154998906319658504271319733469814941611260503645706198407368762270127105340397375230875953495882740039984314121888705481484090911598074635434289709802794549714765847764347865064280637851906308955404165593747173246944693509650424312007333558709071857299501674917023499921977975368196191999692949583952927486593144959284443545794934667002661774373364219852712996869245745722896071593910890197478196462961042627387162830776094709087748993678069776845437889735782063');
INSERT INTO x VALUES (5, 3, '39362489275784146262776411377472433635883331946.794473520543457442955620133347015506556162839462623905489255080102447195050109095701660164272430316804466254467810714209179752718730906325952685817112992943656292503112803950215110778476301809440329937774061163668461957943313261962261081942055908935814323069621279128270849852239727888939033546870208376394878842958202403235309372240005941467570230067124830916866857395233038346727879951123599893174252558078732888910139309038957525961212820831321973219557165558911222848692996406741318948607549825343491479728117062814094258484536263158005174429922237853707635743736923521032098496725445243775790161216159399180889906705265012270270348146530113428221072591696851818281866095288773371414866822270689959827332258348570976075184933893434327278299820594014788148344260948638847457822697682605612771344335201258128');
INSERT INTO x VALUES (5, 3, '.000000000000000000000000000010824770508763323320533297369674519056450544793568147911931789010432012750062661590994728968589403602468229106206242395792957238667714358401601098858606386995096923432407249369639633268143022787987190106724545750803196130511146323174462918572423414631798141263222875752767731279138952850500369328934959764805948568471324562210715908420467881411844098258193571194910997918428786213948547748701831331312040839544355427357749520227124858111324859160114175254197992204974033767300989488517391063188153561391320190653403747521648794370679322504188364455328709488846777004202196382575648619395139553279192346251133156445942281048959845827006761160755031086836046398020850814350246219929303018051720203943879538087954853996826539712240458022307680912400297508925714946398031304516583939283');
INSERT INTO x VALUES (5, 4, '5329378275943662669459614.81475694159581596077242547133292502869630735172901157043010370467618244548786897684821457816189831652076071977025794948484549600736179389638319303817478693948215387894509009504287664213474693208847025374388286162907794727810231557001266897729978691844410171412189947386181530441402903608214502713480332746271552746231631136145916685939539173054989927058122097304419584979598595477177513004218594211597809300517607260841648610322863666300637648662611916496850248528515936635845594390453288113296413254893687029540384176335735114863908372780241463999450547422213639667099644505472777149095004849805371205203850993689064483178204550825728947252440604703474049780550458442808479096492346910001692358508618202898514895453589357');
INSERT INTO x VALUES (5, 4, '-5329378275943663974970875.68387837815679263182430217236192193838209859394480321205431177443564436871085042440731842593128543877087159218415801821547335178795206149841646805067528400474905206604863569827296492883485842974145076391654088154097803033982948898084192422150809385760511991169192044353228731864375715719064118394339415417054629392004621307042759799481522264617060523956256201137680272894311866260366238283858551565663520480629408383844349319586471282301251749494706061523663958609947049544255725056447964564549684815188261035801892684889942971676086592385285071073528462167439314005547455087297279161738865296114495425732286867689064483178204550825728947252440604703474049780550458442808479096492346910001692358508618202898514895453589357');
INSERT INTO x VALUES (5, 4, '-3478781676337858247983014311182511.567538638808357215203593479841446379226774481291286361639429856698999485760647422501864626078375852610019829111004807806660731243672830787729048847342063218718651165150612717759770504648306347926061960607388621011846314969634048226452709389995594961695723139571002939804473057725442880410434039783304583526414509590532906062732322732569475349107437896717416548237633532805602064623969799081086996320156575550896200848758685986331692388099427314008504506503745527468550106879602399030419569897808150076298414568875477195447656904373310322813412927463518325927626891046356679526447117311923853482118502868148386882363449163182892615259995945992014431502761210899772725227648729095696228388558331052524469604046072203605897109629560683446827492904111565278516043939137760721315953500281379039771826554155511347152');
INSERT INTO x VALUES (5, 4, '-.000000000000000122482510461124748279475400009367345900846466958806966807399903713411658400733717078392550780910604704603123670767210550800752620037863340961255721285160854785449315208955654408132775022766783343331151895973970395232686910362226184006990485313002943710214511418310741271074710741339586430026286272098156531835438969774325517509155992092194349661122678547097423264670055720422496527272118788005921590521726691666219504214087867030003203385360001614199656989667055583749577099440092378355805901262289841168751608673297446473709956390142112843400255748161809121986096092991616144443486023218404881798896685413932215981950393130292001833627899480153863300557853617312991880655905907971211246077450786084079040513198340644157868678782195341316027563717617074364438885981635394382733697473265872796207');
INSERT INTO x VALUES (5, 5, '-1305511260.86912143656097667105187670102899690968579124221579164162420806975946192322298144755910384776938712225011087241390006873062785578059026760203327501250049706526689818710354560323008828670011149765298051017265801991190008306172717341082925524420830693916101819757002096967047201422972812110849615680859082670783076645772990170896843113541983091562070596898134103833260687914713270783188725279639957354065711180111801123002700709263607616000614100832094145026813710081431112908410130665994676451253271560294574006261508508554207856812178219605043607074077914745225674338447810581824502012643860446309124220528435874');
INSERT INTO x VALUES (5, 5, '0');
INSERT INTO x VALUES (5, 5, '426089913064020811.057708378200224487694731586862745370027417544052374884336177893807736467646454486029424673621605232432043672119510371547153895504456723242262639262542904151307250842477327375961936454637964429999741717244285121019840463692418987118402683746281993192269229200465080358289645050337976214115902915692028162689089167194843185708212911364017271332623359100711545479273675423617018342297822477514128997410642005300368966199980354369928371655155437291469427189561877718971914040675572136507472590254222870537216617260612835805368361975725573009455402822669103118872235140158440342063571894152305875004532651814592458133460160514384171804043127771746596286988679698684698755896736275307574630777027620558428909546664763675431701332632828281070572045822129984625797185173815273651376003614106277727279230096226977335510');
INSERT INTO x VALUES (5, 5, '1.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000');
INSERT INTO x VALUES (5, 6, '-652755630.38762364608541718463145771120672223443489913059334543712856431450577465795351472116052777583325262472505543620695003436531392789029513380101663750625024853263344909355177280161504414335005574882649025508632900995595004153086358670541462762210415346958050909878501048483523600711486406055424807840429541335391538322886495085448421556770991545781035298449067051916630343957356635391594362639819978677032855590055900561501350354631803808000307050416047072513406855040715556454205065332997338225626635780147287003130754254277103928406089109802521803537038957372612837169223905290912251006321930223154562110264217937');
INSERT INTO x VALUES (5, 6, '-652755630.48149779047555948642041898982227467525089211162244620449564375525368726526946672639857607193613449752505543620695003436531392789029513380101663750625024853263344909355177280161504414335005574882649025508632900995595004153086358670541462762210415346958050909878501048483523600711486406055424807840429541335391538322886495085448421556770991545781035298449067051916630343957356635391594362639819978677032855590055900561501350354631803808000307050416047072513406855040715556454205065332997338225626635780147287003130754254277103928406089109802521803537038957372612837169223905290912251006321930223154562110264217937');
INSERT INTO x VALUES (5, 6, '-30638438.151446159804025029882398388155309149089870990062944469684482366692824338098201222171115395923414887930224163525189097571163687285244255335505387733673499447610577050114902372990462064696637481657064525319516004273769831260452832960893174173254560250804003884280384718123289136453955482855362019158401218620018346500189769819687260476334734259702665316562988639223597110627626759216850014150105605927773639897638043177685498804811787888811168524202700283461266793154726325540776914500415140842975457394524215869103737379109516024460317825645645301237375972914247141703084877141866316168268901439172491577729880760950895760711857112463508064820414904611059588717092145484656103798852859978690742216940980929562068');
INSERT INTO x VALUES (5, 6, '-13907037655.047994416383638650569341223199042786813441967582376077478024677494832069402897226848055043557486983268019376307288565911231748501636517992289743940159005664424461285010295150828744259113760652210086696250085454819340987566229400805422509198052317518991183515696724846560872057916862620762789778660622787735923967096950195583369113574365386627110408307941105082873469072519133330718161987781080307947247163619814890462416622144825161521790673339279047700672881113718394727610096366361422482794458375587355933614201638489194194834709433413694420512869179976485096875057742460003147602405353823942488343056906912173170809084207937229591627643451380735179767199816663168139837088183577975769442341678933576388936845704303859241320794255052627716474860113993958556604381707826493168941926878481079724185426298004604');
INSERT INTO x VALUES (5, 7, '-818934540724601372.43456071828048833552593835051449845484289562110789582081210403487973096161149072377955192388469356112505543620695003436531392789029513380101663750625024853263344909355177280161504414335005574882649025508632900995595004153086358670541462762210415346958050909878501048483523600711486406055424807840429541335391538322886495085448421556770991545781035298449067051916630343957356635391594362639819978677032855590055900561501350354631803808000307050416047072513406855040715556454205065332997338225626635780147287003130754254277103928406089109802521803537038957372612837169223905290912251006321930223154562110264217937');
INSERT INTO x VALUES (5, 7, '818934539419090111.56543928171951166447406164948550154515710437889210417918789596512026903838850927622044807611530643887494456379304996563468607210970486619898336249374975146736655090644822719838495585664994425117350974491367099004404995846913641329458537237789584653041949090121498951516476399288513593944575192159570458664608461677113504914551578443229008454218964701550932948083369656042643364608405637360180021322967144409944099438498649645368196191999692949583952927486593144959284443545794934667002661774373364219852712996869245745722896071593910890197478196462961042627387162830776094709087748993678069776845437889735782063');
INSERT INTO x VALUES (5, 7, '534564131989234694540350103.27821462973515555648644772098605028371173048154132108733819196629002548296868548691993248746628993380136454426833349407578676005545111508293942736555269938962058196496152360848131645787941032968937794930046928523006455386861100809286408671908320322523368135203881520526880998279355848280412933152306299256343179622513731096363088094541514890135766460631462465021694553063366717467560655272004461368865264059368514271105464855575429914212085797297268595943955105608543373940035636033207568676745293499106348500559628723682588033431457023964317090780615020801564861497990103549650624438425421690193862533733474254');
INSERT INTO x VALUES (5, 7, '.000000000797079129642393611556079160915147221153735075943759104977169600937534508973732991117540626046659124172765761873705978811124901421049332579161931652390647472911517923131800238903184679028518657818755558526885018755394697157094867449047655737107085020874974955627907737126958129710597811740696534189608639914753884882702680512272194316887744972931453458445314561564591875764930680945589486999586667912816485821717403892703364322658245615895415781719033810595358092343690359557942948213374234065052300866661453767599465059289920067095083062096458980564265691295895672503728815182981118876144075942348853666085714846210822847053889733510154276933759200630639642310562242207518883342516103725757482864105340008709446643820864294556778969997115586027866760708448174502158738150605938364482719960251612464993');
INSERT INTO x VALUES (5, 8, '7844230593.20607652525116672615394735666141304947992676684520382624714879797087461877675155217754947572297228288498221620714146356962938009770486619898336249374975146736655090644822719838495585664994425117350974491367099004404995846913641329458537237789584653041949090121498951516476399288513593944575192159570458664608461677113504914551578443229008454218964701550932948083369656042643364608405637360180021322967144409944099438498649645368196191999692949583952927486593144959284443545794934667002661774373364219852712996869245745722896071593910890197478196462961042627387162830776094709087748993678069776845437889735782063');
INSERT INTO x VALUES (5, 8, '-9149741854.07519796181214339720582405769040995916571800906099546787135686773033654199973299973665332349235940513509308862104153230025723587829513380101663750625024853263344909355177280161504414335005574882649025508632900995595004153086358670541462762210415346958050909878501048483523600711486406055424807840429541335391538322886495085448421556770991545781035298449067051916630343957356635391594362639819978677032855590055900561501350354631803808000307050416047072513406855040715556454205065332997338225626635780147287003130754254277103928406089109802521803537038957372612837169223905290912251006321930223154562110264217937');
INSERT INTO x VALUES (5, 8, '-5546455599206321494.0676583421119904300307105296377723816472192007866147764761501865875232824814135783697976183493106885436876081315217834621720906478074798596116645640251460842350553806256223963023430631066024389364515688765194373161385579258482225808660340732705687558150699172147896486727530192499184101617379930846663835628510376484675411350654979679181852179924386290069790336316958202582966248703889464308649631486542724072047294216362186036638115240070658004553260251510288423749333873893917690832829128021808383128393431810674177390352413548658782609064839524756041501835115152819802758773711821322162752064589750295542985780512921839490040396053737870038534216948323935020460307350020911362024271167085905714873548388570602799432705061561572854498075600');
INSERT INTO x VALUES (5, 8, '-.076822018213756690975099471985461347542955923191183223634407380481978143225129486622351714276452369661632980197282261508936298649901018470846144321441236073683990324039849865750139470288565622579952182053792815638469841531577235191276257498209844422440366423136595067535337374223115507557306455001792362506235886189722508617024948653046102060677266555476719102193278190540414934812073355995577639986512222998268934000209944414236509139290657402937840986061987219441410741189615344050459067454369371094189930607834375561948483494321255500497786795636801854613881105643003358210407867114145806225724880370339074242480071595684502491827709175732777776915682786771730423733673667248186336046898260378049328204094804755195626798951644386924178161926128482002518979482630732440619051262620098544265763306253807191182');
INSERT INTO x VALUES (5, 9, '-597892150.08771044822540810796370552966707032464017958269847934730769542644402913723848026909285133109089452632480800168074607090893991283808726990171062867538012237270000932798704781608969096508450960185964292594677356241956277714380500188870696516251767979457838109804726539408115452577436052503866633026489282425086547752714324273565900641436632912781035298449067051916630343957356635391594362639819978677032855590055900561501350354631803808000307050416047072513406855040715556454205065332997338225626635780147287003130754254277103928406089109802521803537038957372612837169223905290912251006321930223154562110264217937');
INSERT INTO x VALUES (5, 9, '-707619110.78141098833556856308817117136192658504561165951731229431651264331543278598450117846625251667849259592530287073315399782168794294250299770032264633712037469256688885911649778714039732161560189579333758422588445749233730591792217152212229008169062714458263709952275557558931748845536759606982982654369800245696528893058665897330942472105350178781035298449067051916630343957356635391594362639819978677032855590055900561501350354631803808000307050416047072513406855040715556454205065332997338225626635780147287003130754254277103928406089109802521803537038957372612837169223905290912251006321930223154562110264217937');
INSERT INTO x VALUES (5, 9, '-35812445701642379.972368737320206275515144213236752803936806738624588812089615098329765811617509505790110909629109400553415312470540217508070421816878544125783329593128638405659896184248784794258084116406472768709113030915308410565617764394827427154923321461158387012978726512246146545834669665093228316853342805604075936530371665576147966721599968786161939347726656168798065647411457701453987215491345496003650288850096338695703984042549594979897253521041581573388369367579323607093487743440894765114619634001789457486407909224339065748496715380572175183589195611952939575073075140094901024063428239223964510824958346570603142906309198033196987949067156046076497974760641964978711558209708743776024313916111738542765749928287600981397080809041007714387564206594515733287925008053261840295560398311905155157989225181164097547541');
INSERT INTO x VALUES (5, 9, '-11.897816658873986795664687519069203701902563457968097729876034796143085813450454323128600602495745166997629078984618283588337379184733369491549230343315369634754204412939757136108898254582353378508832611703989221079986765793923635928759179573599208612516427628403686659479459867527627014558600521732194240404211484706621458983727740143568799713006127585168144158660566534382037451913967363675002134687952374080694449905223371627606557311710348820900963340884001770733452314715448053233208783321215998063958966729954113843581448912079950334969908657535514847005768455377990262943747367245613296497099716892292154137652893990339292671106003657659470243633112063075297194691349631518467702876183897580432003030164590920118726657290102377710611324297862045849839571689192181090062958059281673245670440852080202548743');
INSERT INTO x VALUES (6, 0, '.0469370721950711508944806393077762204079964905145503836835397203739563036579760026190241480514409364');
INSERT INTO x VALUES (6, 0, '.0469370721950711508944806393077762204079964905145503836835397203739563036579760026190241480514409364');
INSERT INTO x VALUES (6, 0, '0');
INSERT INTO x VALUES (6, 0, 'NaN');
INSERT INTO x VALUES (6, 1, '85243.44233732197133191329295927531563604777955507322414928382967007765263923984471408038635831036097817458527101593495895350807775607346277892835514324320448949370623441059033804864158715021903312693889518990256881059434042443507529601095150710777634743301398926463888783847290873199395304998050753365215426971278237920063435565949203678024225270616295573678510929020831006146661747271783837653203039829647102027431761129518881525935216608429897041525858540380754759125150233053469999022855035');
INSERT INTO x VALUES (6, 1, '-85243.34846317758118961150399799670008360696356209219504851646259063690472663252876207514831001425809630178527101593495895350807775607346277892835514324320448949370623441059033804864158715021903312693889518990256881059434042443507529601095150710777634743301398926463888783847290873199395304998050753365215426971278237920063435565949203678024225270616295573678510929020831006146661747271783837653203039829647102027431761129518881525935216608429897041525858540380754759125150233053469999022855035');
INSERT INTO x VALUES (6, 1, '4001.075404054519813215296429095020391062109905613738157927030437221793757373268325953178030040276107574363822832168160758728653712686313134828282109532831190239521843808940611025488601517574653932032236616573457735900045655665690517797280666732780030171712864961531623060353548802466577910774711998056232872212688464691036260746751992072745518373073825852119460094113694393273456369345499434994672730920070410547163082189385645712866100999708173472360864669110044660667614583576570496399103026286828660558854973376227247132815728164629722965145778698957093136175449225024685874279280018547740');
INSERT INTO x VALUES (6, 1, '.000000550624150700285432940805295709861455424264970126953321538967550091614148982212874391026630805836518138806917934859138493583812313778188030836027246840794439412443826640206464415527687555214009725107630387889854278497875708390050387195108441635824296563108288712340902423706104029452615686971019125750530034798026103476074158922893374911891438688457439945897348811702908216883650280617098402133628688982793791562476980709924382381505517834196446365877784931355599480881104446907801805570471686295270927836995181422963320376948188855989986414581755633425437161760674162177776773597848142496583128607548351599750592863590334617838124741567654525843413232313914310487355539260264225486180000012813397807525203822863232682089295055713257835007742845010741137213301116647610033909062369843750685396196342928455');
INSERT INTO x VALUES (6, 2, '-994877526002806872754342148749240.99659316232359475297606895243958507460511031229368344962653674268847910587702140353344168594152240599109936336446284803020643582102868247857009494139535009572740621288230740389545481395');
INSERT INTO x VALUES (6, 2, '994877526002806872754342148749241.09046730671373705476503023105513751542110329332278421699361618343639171319297340877148998204440427879109936336446284803020643582102868247857009494139535009572740621288230740389545481395');
INSERT INTO x VALUES (6, 2, '-46696638263247522384986521136500.479312417066793299922708112595886608370451213741279484136907754744903470430131032928908162742687359367826808123516519335458861613010646992354378739165872253762686683966945711430182491860196341344982195078000259063231136011430995647812149294224699587849791008794261026932467933475782780');
INSERT INTO x VALUES (6, 2, '-.000000000000000000000000000000000047178744084866106587600962473825168237820701199970144691815329658682341685812472535816245052671243808078367856957579485152424914481414614360809698177236664771558713606961423658442962083541733004775309314926918118528217478256885324362912426275407382550929085958089798861918760121727491366034496581249711153289495601712583077918760003840368008056353090552282274780428335438032908213783490070198414584291402513547386013689752310173492320159738977752795528725029134841933604057954874523842273790958618375118974623107241366036640538085329921129023905888674299774726871808862832797230915933851225308164365269753526489223540580759951230801125605963901491073619448437890841032149898629231552019804656219062534881074125995130202820302133432951999011667568746004715268323913437054078537');
INSERT INTO x VALUES (6, 3, '-60302029489319384367663884408085757480.1853341682137571584926062805631087054017160819890685789064777236456590745415460695320768374693076860837798752903681993777275846325950111427710563453217985216966456785944859989497422927661683538629473170704026975786513125842675604577233871570629808699803522400038975396500769162308448069085909755023233588510630417065084295051270219462289785473643946404281422516357503746700705970360169619852905053433235726497292406142332833');
INSERT INTO x VALUES (6, 3, '60302029489319384367663884408085757480.2792083126038994602815675591786611462177090630181693462735571643935716818574980747701251335721895588837798752903681993777275846325950111427710563453217985216966456785944859989497422927661683538629473170704026975786513125842675604577233871570629808699803522400038975396500769162308448069085909755023233588510630417065084295051270219462289785473643946404281422516357503746700705970360169619852905053433235726497292406142332833');
INSERT INTO x VALUES (6, 3, '-2830400711649493468815157129316992649.40542786074520931471973065281957756940496588853021620372179463538053123396140685749478530925306163968207226329985017644835203709485594362663495728106061878665324856417118064730721101615473194292620972173690618491026470353143141125614124440035267592258385099934706896692953497971326605145704135723011753705907329979207428661473172503098296622281647255008204864404416199384701720347319806375450632245634238172654086373193251877533131784268854289406126119630708578053354762596511353053106459297339360827562281168219966099848212');
INSERT INTO x VALUES (6, 3, '-.000000000000000000000000000000000000000778366376597400971124059102619954214055884926284646546105035591052258074563706355894551049631537984053410850060739107742208523938741961208742831871056600773325053133977559789796700130019975964192371715826863472981072974742704091801166438465082519558956925444635729210849210496466189037623555622901738570979273502405907969114110345815802999687171113749364073269902319653450479463404003706147915064100959774312307195946966281098140229199529866429134937742584938255441169541436021827079647129394362379406256722903991353136733939395366152312959281905058592776286736536360235356737359904478313225848562436632109470589310799000750518904145312512621838935796912993778920622238202744037977772169066929474233952081158212174549695244127987299282384885288897893503991509410567351494');
INSERT INTO x VALUES (6, 4, '5329378275943663322215245.29625473207137544719284446115519970394719946335145777492574745992986971075733570324679065009803281404581615597720798385015942389765692769739983054442503547211560297249686289665792078548480268091496050883021187158502798880896590227542729659940394038802461081290690995869705131152889309663639310553909874081663091069118126221594338242710530718836025225507189149221049928936955230868771875644038572888630664890573507822342998964954667474300944699078658989010257103569231493090050659723450626338923049035040974032671138430612839043269997482582763267536489504794826476836323549796385028155416935072959933315468068930689064483178204550825728947252440604703474049780550458442808479096492346910001692358508618202898514895453589357');
INSERT INTO x VALUES (6, 4, '-5329378275943663322215245.20238058768123314540388318253964726313120648232235700755866801918195710344138369800874235399515094124581615597720798385015942389765692769739983054442503547211560297249686289665792078548480268091496050883021187158502798880896590227542729659940394038802461081290690995869705131152889309663639310553909874081663091069118126221594338242710530718836025225507189149221049928936955230868771875644038572888630664890573507822342998964954667474300944699078658989010257103569231493090050659723450626338923049035040974032671138430612839043269997482582763267536489504794826476836323549796385028155416935072959933315468068930689064483178204550825728947252440604703474049780550458442808479096492346910001692358508618202898514895453589357');
INSERT INTO x VALUES (6, 4, '250145412892811547138949.592621291590152419206270097656346630226508074074623894951308487425470437268130465956063593951784820669318897182831355375451719125809800516979013437732298382708070979871283132689492336823087794373113039154669229889503700598930220858275174342776478898670277868700384853696009897221747924643343353942154528501454689084608965009561564638167714973711022212547096732831847202912862290958304510651828842182545311077713664465815992616213663619529378061133917572474298028065850515876361609671565914027186063801852554353160801534696062207299890867876199323530337336273950892723090754719547285920090419070001019943385293110663922226230169381423410428577990604776655422105400452217085311617728003688836185608912367677734364834577573255789160419371322775733777518997638403409000055707558465286469808848200141192627396502735');
INSERT INTO x VALUES (6, 4, '.000000000000000000000000008807232244507937251856465017967626593430084223212999583902527587737263981869382895220711835510154989851222501080395520249593128253795609198666884523792646863341248402687314509176781281863891589925961900674092953408613128961234166906173266411035009516545964362406728942021813644419154548354247112601793685146960840364604115937119024575638240439041250900118977183124605578660115160551830946251713350556181960983267689939549506518185340972020820080460565392359379680036788592213479105831301723237102710863182596413567756605711230290883888612188805367801369264231165178487334557824054205160222371548005742602736713668548450400926514169967213301919971189065307721110805424950794015852531342286935114651278691214233054575660712537044810163930633456573860895791198853393107188289695511873068');
INSERT INTO x VALUES (6, 5, '-652755630.38762364608541718463145771120672223443489913059334543712856431450577465795351472116052777583325262472505543620695003436531392789029513380101663750625024853263344909355177280161504414335005574882649025508632900995595004153086358670541462762210415346958050909878501048483523600711486406055424807840429541335391538322886495085448421556770991545781035298449067051916630343957356635391594362639819978677032855590055900561501350354631803808000307050416047072513406855040715556454205065332997338225626635780147287003130754254277103928406089109802521803537038957372612837169223905290912251006321930223154562110264217937');
INSERT INTO x VALUES (6, 5, '652755630.48149779047555948642041898982227467525089211162244620449564375525368726526946672639857607193613449752505543620695003436531392789029513380101663750625024853263344909355177280161504414335005574882649025508632900995595004153086358670541462762210415346958050909878501048483523600711486406055424807840429541335391538322886495085448421556770991545781035298449067051916630343957356635391594362639819978677032855590055900561501350354631803808000307050416047072513406855040715556454205065332997338225626635780147287003130754254277103928406089109802521803537038957372612837169223905290912251006321930223154562110264217937');
INSERT INTO x VALUES (6, 5, '-30638438.151446159804025029882398388155309149089870990062944469684482366692824338098201222171115395923414887930224163525189097571163687285244255335505387733673499447610577050114902372990462064696637481657064525319516004273769831260452832960893174173254560250804003884280384718123289136453955482855362019158401218620018346500189769819687260476334734259702665316562988639223597110627626759216850014150105605927773639897638043177685498804811787888811168524202700283461266793154726325540776914500415140842975457394524215869103737379109516024460317825645645301237375972914247141703084877141866316168268901439172491577729880760950895760711857112463508064820414904611059588717092145484656103798852859978690742216940980929562068');
INSERT INTO x VALUES (6, 5, '-.000000000071906039575366987930696117572143566208825430801491864851999044659045681114433294052065377679745375399878664822361548237094424148992770296383642432040129230180142339557437679166815114510467763288057917694948929009212876391059413439647163295629904270262780935228234994930653489111444964446097124407804311494588517082748514970905563707392765567625639455978464081409330528324962333492925267647686759704415549221137291475247571296491073010175087298752769122449499990102435819414671847617062560524758344361194566796343756743243766853291113852464023843527189221162680613675369708907935197867458588904367993736363321133720345058432019986643353417257503619558797249295232894674255060861358071309619524800424087896023710729815248847792174290644245138831518072176198607255346603270853333176255533974364728342822');
INSERT INTO x VALUES (6, 6, '.0938741443901423017889612786155524408159929810291007673670794407479126073159520052380482961028818728');
INSERT INTO x VALUES (6, 6, '0');
INSERT INTO x VALUES (6, 6, '.00220308874624532134736695825088747995945783791378828770826401323533973395137378460250799184832278118133622563295093909508983301127615815865216895482784469538070133388154961402881325731054433770884496');
INSERT INTO x VALUES (6, 6, '1.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000');
INSERT INTO x VALUES (6, 7, '-818934540071845741.9530629278049288491055193606922237795920035094854496163164602796260436963420239973809758519485590636');
INSERT INTO x VALUES (6, 7, '818934540071845742.0469370721950711508944806393077762204079964905145503836835397203739563036579760026190241480514409364');
INSERT INTO x VALUES (6, 7, '-38438389630389612.0042045464692275627184627672063157323631169405883031379129843031477339360597564128205768842448328088');
INSERT INTO x VALUES (6, 7, '-.000000000000000000057314803440765029050667129936880528769333499793237773980613524885506515999851858649385968476426313207429914995755091541422893944525222307473169425244462149015717526718376299808423552027796204632286454853167559026787019718806449038446612978917236245943248168920696452018925986743620392955122431521581268518101342690974749463089739042586011924590503136498488946387508310209984849243014542648765897536338824721211252335866349509669538308454367849024503312249951727948786393404944555844863805495937835281927012430439403132382055464307180153473189842433614777883826783689904293115204700185380661601223693428304020047393499702811581067120117405280772944184877279069842269329959037186324135435468322336398566440055479142909170224780318371473684868152271947368867666706912563225912012901437076773416');
INSERT INTO x VALUES (6, 8, '8496986223.68757431572672621257436634648368772473081887846765003074279255322456188404621827857612554765910678041003765241409149793494330798800');
INSERT INTO x VALUES (6, 8, '-8496986223.59370017133658391078540506786813528391482589743854926337571311247664927673026627333807725155622490761003765241409149793494330798800');
INSERT INTO x VALUES (6, 8, '398823655.819545574205652791249227663407026876411660299394659390409794761643751582473390322547798567169668246138880832642141417531427935520467563318363116897177899262525720710134129529640376020947774470933902793259531840625444267816319963200');
INSERT INTO x VALUES (6, 8, '.000000000005523967081937952184172713994498918048454262874017009201501812494019618863622631634736130436187167745347383745890248619882896153083428308074678908731005176810208100004498415662458272149380846809398637385270265351808328466537502823071145089961996689711299405627596294988646826454676198092260759424935699382655736524042353938814268760468122584678267125994645166955751211397353140569987758938572953312303398024147927938612934833827734142292697389251052485981023756760420972614486278837214553818521196182883489483756785207650821722660455451660719560529693418375773124813290305501923899840247103166971466167032437598057958226806335324315214908788839919408525748236713611579486768218564733151121028172253396652755590051310396973181595992981076269789287489208817712754098019817792758730835341151711523474207');
INSERT INTO x VALUES (6, 9, '54863480.39378734225015137845671346015520435061071252892396685718794832880965812803098645730572474084523997120024743452620396345637401505220786389930600883087012615993343976556472498552535317826554614696684732913955544753638726438705858481670766245958647367500212800073774509075408148134050353551558174813940258910304990570172170811882520915334358633');
INSERT INTO x VALUES (6, 9, '-54863480.29991319786000907666775218153965190979471954789486608982086888806174552071503445206767644474235809840024743452620396345637401505220786389930600883087012615993343976556472498552535317826554614696684732913955544753638726438705858481670766245958647367500212800073774509075408148134050353551558174813940258910304990570172170811882520915334358633');
INSERT INTO x VALUES (6, 9, '2575131.137912978352131546639620215541477987701194164886305951830806120142596646541302305984776928560906754259789485960991272272782091464270104432109904222200473616116525297615725803495463468272171161659654385929185160689572943852767523792651123455283534072794326647404332228203001469884016996499768656263775233430922446983838511590562929268821678518640501686017030536100955531423152839988008496919169395159653034847677470665418765966542111749439412');
INSERT INTO x VALUES (6, 9, '.000000000855524875533453524582534418967571681572635027972658867593464437484123442242521660317156546196609749230372398872487667521984251509483676665788527375343148382604836976332389890799079878151841905152004537926201190193814594954194044560537664560344224646197027029681984683465852110060077865421064400958821808374370779297676624123638191407441015008434084079839721156870032377372497814037418047056438760664237367081226979226606227037631073946209105678283624370820396871058367779887709720661001099338250009251834581804647326512873792849059661525874160414378459696930831877643599421297749483849526695657467708603491876916749718079725746259119898269814551222336219537198318796277931946529242436502235147453584237994498566122973953203597470078105606906752099294162422474758048436539653041606499637623370030079916');
INSERT INTO x VALUES (7, 0, '-818934540071845742');
INSERT INTO x VALUES (7, 0, '-818934540071845742');
INSERT INTO x VALUES (7, 0, '0');
INSERT INTO x VALUES (7, 0, 'NaN');
INSERT INTO x VALUES (7, 1, '-818934540071760498.60459975022373923760152136399214017262844141729040109985386964272131706381326192223266583769046276181472898406504104649192224392653722107164485675679551050629376558940966195135841284978096687306110481009743118940565957556492470398904849289222365256698601073536111216152709126800604695001949246634784573028721762079936564434050796321975774729383704426321489070979168993853338252728216162346796960170352897972568238870481118474064783391570102958474141459619245240874849766946530000977144965');
INSERT INTO x VALUES (7, 1, '-818934540071930985.39540024977626076239847863600785982737155858270959890014613035727868293618673807776733416230953723818527101593495895350807775607346277892835514324320448949370623441059033804864158715021903312693889518990256881059434042443507529601095150710777634743301398926463888783847290873199395304998050753365215426971278237920063435565949203678024225270616295573678510929020831006146661747271783837653203039829647102027431761129518881525935216608429897041525858540380754759125150233053469999022855035');
INSERT INTO x VALUES (7, 1, '-69808760806266041400340.70700818693892852138813934414383886494691670042143650609934777814995087699409404201920249076407981012095999320858479644760715204999741683528746097757549835956359129287002171391961763797857794730120426599135099619822532290339000466211195776337667123320942107370731349851576864242697412616810236323676004067839744992733887503405311090677026008324895177587064547630828026123718296429295638934384446325302964896473296829265805737112709269803814942537657996725913938408781715328945194948010970');
INSERT INTO x VALUES (7, 1, '-9607014551997.140858001442365669993007297071681832468350855627077185145567261170534005832165603932891201648027598773639089125980996652005412450490063683624648655909636499261774535015914730479401090227915382926027949990128880284298688443593909017437720828163877690126019616194376778317148693270900349151496295698078575648169637635898560612738481294674167553369445426793073304518646116539082953755973571046622684332425840412198776081251646424875405772676893185726872613804612566569794177506268399878105117763696990094108960076591684779180089885283939385808214239337829666227427148603057941899878123459708920227867371285837642561064461118016739395972994827327543594846953341750907541716807985738518071480209106185726125017342997283356926976052909493074301401955202616191210810331245427141945840542129607439703255628683506772979');
INSERT INTO x VALUES (7, 2, '-994877526002807691688882220594983.04353023451866590387054959174736129501310680280823383331007646306243540953499740615246583399296334239109936336446284803020643582102868247857009494139535009572740621288230740389545481395');
INSERT INTO x VALUES (7, 2, '994877526002806053819802076903499.04353023451866590387054959174736129501310680280823383331007646306243540953499740615246583399296334239109936336446284803020643582102868247857009494139535009572740621288230740389545481395');
INSERT INTO x VALUES (7, 2, '814739569184924399102711674444306584731316176345067.39834031417849342571224916231092924046722938910652929295271097903377854123984307101079073134405782275535446337229706620713104545454319555885847481531722101704765783025789147453570970090');
INSERT INTO x VALUES (7, 2, '.000000000000000823151110229758332661330617426417726331211894330147399760458555778324097596176117291103184653828305857999638466183347321835058943563347767579219763002258622507889760416640758842509635599414768344140175277742935564567127659688612699366182158030839083982896107176174766408199870924563237827899202849733606842856491701660599599211106794572237923985121475458446997860253437578966578617985764298513928307852082168209458400544457824307270777530312648199364084272310536024283945598340590403612752287693234647719354745060851129534452514828239800716088248915975054881011343555492596002595181046121935660176097475159074973635534016835214952415720717896518544064238656360099884889450237541254761746029507300068198731306211736696956568648033834554273602524147075895460874922913883751452403825099444642503437');
INSERT INTO x VALUES (7, 3, '-60302029489319384368482818948157603222.2322712404088283093870869198708849258097125725036189625900174440196153781995220721511009855207486224837798752903681993777275846325950111427710563453217985216966456785944859989497422927661683538629473170704026975786513125842675604577233871570629808699803522400038975396500769162308448069085909755023233588510630417065084295051270219462289785473643946404281422516357503746700705970360169619852905053433235726497292406142332833');
INSERT INTO x VALUES (7, 3, '60302029489319384366844949868013911738.2322712404088283093870869198708849258097125725036189625900174440196153781995220721511009855207486224837798752903681993777275846325950111427710563453217985216966456785944859989497422927661683538629473170704026975786513125842675604577233871570629808699803522400038975396500769162308448069085909755023233588510630417065084295051270219462289785473643946404281422516357503746700705970360169619852905053433235726497292406142332833');
INSERT INTO x VALUES (7, 3, '49383414785234649002982046297226894664526726187218771083.0993243619030008310875293647868815940421844461627295157812843657782639833900543200310573708100000958929315945039020410482966753145208427035917753919085618457760620513481628641658765820294863970581642745379331727722585319163262763708386199720411053619449096019862596221607526610103408936214184850115071874430846697061554769773328338028749631552202705583855831155461651414320570061181212214810086436100771547030013079997847086');
INSERT INTO x VALUES (7, 3, '.000000000000000000013580546907080371873577430837141172674171921610919544849037647398734065712983603204704663262116138799357430947986241590690589753181299773842880079777640016786921825609617596862828930939366173224366864448436461306602680780407912534492687474933386043505172346330210659476505435994582446405414027199938970759003336829722057241708213838318628292667946636226143164221380503228191376939596663443230082698085439531600756771639601022064620204571458766303985028143400866776954225590745596639602613498355332049777798367675438365442468743270334407716567057368347458892075084694158566383133325959042076573734408841629149903649365079563374278550978052491499304166424686842598833319515705663176855033865872333988551611996194856472662292344160194821687681312501127516922809221030420253714666026321243515830');
INSERT INTO x VALUES (7, 4, '5329377457009123250369503.24931765987630429629836382184742348353920297283690739124220773955591340709935970062776650204659187764581615597720798385015942389765692769739983054442503547211560297249686289665792078548480268091496050883021187158502798880896590227542729659940394038802461081290690995869705131152889309663639310553909874081663091069118126221594338242710530718836025225507189149221049928936955230868771875644038572888630664890573507822342998964954667474300944699078658989010257103569231493090050659723450626338923049035040974032671138430612839043269997482582763267536489504794826476836323549796385028155416935072959933315468068930689064483178204550825728947252440604703474049780550458442808479096492346910001692358508618202898514895453589357');
INSERT INTO x VALUES (7, 4, '-5329379094878203394060987.24931765987630429629836382184742348353920297283690739124220773955591340709935970062776650204659187764581615597720798385015942389765692769739983054442503547211560297249686289665792078548480268091496050883021187158502798880896590227542729659940394038802461081290690995869705131152889309663639310553909874081663091069118126221594338242710530718836025225507189149221049928936955230868771875644038572888630664890573507822342998964954667474300944699078658989010257103569231493090050659723450626338923049035040974032671138430612839043269997482582763267536489504794826476836323549796385028155416935072959933315468068930689064483178204550825728947252440604703474049780550458442808479096492346910001692358508618202898514895453589357');
INSERT INTO x VALUES (7, 4, '-4364411947278810125327066890819882483326918.05664098958260550284395870948992407314161088028674246708928421994893923699743452802989464864039994566042797942433140378990308345483670828497915478397481687305406460330009319949623844175096007381662809083363069100235985794575399268709260901964834244796150883807308976949196661411035264619638771824190014274817662519438658481432363824187693821267613212631153175155634316128036152465184903927860719447693468054624663668062006049759837326188252927823612718163916100588143128358998656306593393889422386501730237442526450419990376323903182669190482615734972147533221144682538647497701130447816148459762464395194383090936159579764712919396391813914821973715879062992249315474841639591907249142779103650773383644785606333916967894');
INSERT INTO x VALUES (7, 4, '-.000000153664179510102140733858340480800294287837601105047285453457000254577644933901525444082336054243749405512900867540483190494113677173628646221933766421338612376123824684592850465460156248403574333545090544920568230979754949827013129083778435107488003838746926270955224758508832133483591156567868631938590248213604979638895901933775098150684618378235712437137852195098700137765601802898366867034641606131280434771339920637353140131159441790904703083143627590062236537714415872864218260252838432414759890832271190606933534662897006726154587341385852258168335058931957995901987808602365467861573344491265289043037273815504867254228957776127752540924854546837197432384563153608878864912196453587628891285275067452280357349897203095502806923463147414086919014592380804424300739713935051357374227246098303140106');
INSERT INTO x VALUES (7, 5, '-818934540724601372.43456071828048833552593835051449845484289562110789582081210403487973096161149072377955192388469356112505543620695003436531392789029513380101663750625024853263344909355177280161504414335005574882649025508632900995595004153086358670541462762210415346958050909878501048483523600711486406055424807840429541335391538322886495085448421556770991545781035298449067051916630343957356635391594362639819978677032855590055900561501350354631803808000307050416047072513406855040715556454205065332997338225626635780147287003130754254277103928406089109802521803537038957372612837169223905290912251006321930223154562110264217937');
INSERT INTO x VALUES (7, 5, '-818934539419090111.56543928171951166447406164948550154515710437889210417918789596512026903838850927622044807611530643887494456379304996563468607210970486619898336249374975146736655090644822719838495585664994425117350974491367099004404995846913641329458537237789584653041949090121498951516476399288513593944575192159570458664608461677113504914551578443229008454218964701550932948083369656042643364608405637360180021322967144409944099438498649645368196191999692949583952927486593144959284443545794934667002661774373364219852712996869245745722896071593910890197478196462961042627387162830776094709087748993678069776845437889735782063');
INSERT INTO x VALUES (7, 5, '534564131989234694540350103.27821462973515555648644772098605028371173048154132108733819196629002548296868548691993248746628993380136454426833349407578676005545111508293942736555269938962058196496152360848131645787941032968937794930046928523006455386861100809286408671908320322523368135203881520526880998279355848280412933152306299256343179622513731096363088094541514890135766460631462465021694553063366717467560655272004461368865264059368514271105464855575429914212085797297268595943955105608543373940035636033207568676745293499106348500559628723682588033431457023964317090780615020801564861497990103549650624438425421690193862533733474254');
INSERT INTO x VALUES (7, 5, '1254580584.048971438599349046867230181719371038956756285986415773300837165755558702217197735811549684202279755101552533605390208155708695952004683670878589028717509749282693444655857296902117478518511492735290086040573521482737598395369632843374456793385511847676556826348943588519880411018079886373631771830925920986588708409208527042927229627786932908015502292313887561198156623702404977221789649731458241770690830680067801377815840764873662400590343236662968218256211697981048576328148435241545372543075051594952109757428031762469834781538302930957095080167901199455226976113347018972534334210416375400979738414416582588689496706548495076287263281908191770792203069614447622517839588243746755480572371988630084226963919158931419126724681617069720048557166545204944250492282054791996953359013543036918134163144772567093');
INSERT INTO x VALUES (7, 6, '-818934540071845741.9530629278049288491055193606922237795920035094854496163164602796260436963420239973809758519485590636');
INSERT INTO x VALUES (7, 6, '-818934540071845742.0469370721950711508944806393077762204079964905145503836835397203739563036579760026190241480514409364');
INSERT INTO x VALUES (7, 6, '-38438389630389612.0042045464692275627184627672063157323631169405883031379129843031477339360597564128205768842448328088');
INSERT INTO x VALUES (7, 6, '-17447499423661151023.558342555162228919125358089491573318627107322332520978657843895009110781773496490472817700487707134216424855867015781267287628022535529641238372370292374146871103236048507252055787621394728096799222976387108688980537900309311204203302960751747509648304056939321473462375648710590981564101023812800603438271190184064874290215309040519813024962909469701968804925443161094255632624090623433640078421818321246597728308302979223833487133268472455479442002005374793705431817866798804822885690193667521606781156962792120052947767160957903073698536973292205899421787948529970837601521657406211962967291912148632072929662185840265855612193255596825032457033402506154930851214421895488796227471490998190312007513478459049382774782886773158311656817014322925167278223360446454868236479549745612973293185989975394307678926');
INSERT INTO x VALUES (7, 7, '-1637869080143691484');
INSERT INTO x VALUES (7, 7, '0');
INSERT INTO x VALUES (7, 7, '670653780922685519356619170643530564');
INSERT INTO x VALUES (7, 7, '1.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000');
INSERT INTO x VALUES (7, 8, '-818934531574859518.35936275646834493832011429282408849567717761204690035294074716714939441961175772404289860039233415598996234758590850206505669201200');
INSERT INTO x VALUES (7, 8, '-818934548568831965.64063724353165506167988570717591150432282238795309964705925283285060558038824227595710139960766584401003765241409149793494330798800');
INSERT INTO x VALUES (7, 8, '-6958475505053954666339703437.48985528725312694198056665033448258303533387675711770743843194274181580881296671866212320171337132096489224277825857521033238709600');
INSERT INTO x VALUES (7, 8, '-96379412.478435590945480884955616049873645089637121682284625533034225619945532704111492738646389632607594293500930307222576571876059094206480673293295865214240456906965855425738072430281475736130342229749511650392658808510082775031098547507966544723255869156056349218776847523349173551313282283869146710349521487706884633419341568648959204688757523312579312713453540395840470692533267158388401676533369105590789036132185107859069994833345453200014884023709597817280132465224778002071890368479648934317322270613208789859930618055792958996389145963056607200020526949699302565905917600478429628844015684879886549766473809801710003649193772354147104446894109928903223843036925147624639466770660174828940577089095480826473544099693433597812637069287644606693066736302793687011165899362920686114156254982709172925265118077531');
INSERT INTO x VALUES (7, 9, '-818934540016982261.65314972994491977243776717915257186979728396159058352649559139156429817562698954531329940720620096519975256547379603654362598494779213610069399116912987384006656023443527501447464682173445385303315267086044455246361273561294141518329233754041352632499787199926225490924591851865949646448441825186059741089695009429827829188117479084665641367');
INSERT INTO x VALUES (7, 9, '-818934540126709222.34685027005508022756223282084742813020271603840941647350440860843570182437301045468670059279379903480024743452620396345637401505220786389930600883087012615993343976556472498552535317826554614696684732913955544753638726438705858481670766245958647367500212800073774509075408148134050353551558174813940258910304990570172170811882520915334358633');
INSERT INTO x VALUES (7, 9, '-44929599044588573810654775.83678007633232843418115790847152455559258007804727916986432256198687661496804050903769496933400455947645400628259699874770581538122521805603947464462448454681701547899144129061961394870320463199545502030106801911915987309444301341575451240764927967432593181449618816978119423290767783843864768557371257918447461479570164065303599994081990686');
INSERT INTO x VALUES (7, 9, '-14926769772.797708334489652004325241753714626257641081061212878627972973992233480868793527325656854681817156284203427388055525855608883067129036717726368707982450450575794623567027457808927082390474261155500697096284790656757163047499531247323702909360444831707029353441147768321257650234732286165724178549576948957405037843360446785505536809409054071975214796532504678683693402401018726571884721963641317944453797513145055081061680091585467186975354801535734149952115333241283186621720677488342266420359417174224757781125498130120775969091933838082305123652811689513300403051544682523761263183781206840940347226802620226164265210810994106136738030959199259066517106713585343004140573604437146025585149934286364795122716971496775012412420105368351774715982565252533025207453326002101655121126631180162560463548157187175671');
INSERT INTO x VALUES (8, 0, '8496986223.64063724353165506167988570717591150432282238795309964705925283285060558038824227595710139960766584401003765241409149793494330798800');
INSERT INTO x VALUES (8, 0, '8496986223.64063724353165506167988570717591150432282238795309964705925283285060558038824227595710139960766584401003765241409149793494330798800');
INSERT INTO x VALUES (8, 0, '0');
INSERT INTO x VALUES (8, 0, 'NaN');
INSERT INTO x VALUES (8, 1, '8497071467.03603749330791582407836434318377133169438097066269854720538319012928851657498035372443556191720308219530866834905045144302106406146277892835514324320448949370623441059033804864158715021903312693889518990256881059434042443507529601095150710777634743301398926463888783847290873199395304998050753365215426971278237920063435565949203678024225270616295573678510929020831006146661747271783837653203039829647102027431761129518881525935216608429897041525858540380754759125150233053469999022855035');
INSERT INTO x VALUES (8, 1, '8496900980.24523699375539429928140707116805167695126380524350074691312247557192264420150419818976723729812860582476663647913254442686555191453722107164485675679551050629376558940966195135841284978096687306110481009743118940565957556492470398904849289222365256698601073536111216152709126800604695001949246634784573028721762079936564434050796321975774729383704426321489070979168993853338252728216162346796960170352897972568238870481118474064783391570102958474141459619245240874849766946530000977144965');
INSERT INTO x VALUES (8, 1, '724311956372274.0135050255361637906710330203036651743488213007179039756514944640108625580172737414192938789413338554327986697518463087452612658955180411327002900979574347739956600177846996063741787205122007268468674386396156638261992679442768654367111433834151087792255469957061758837789341439211010331332174981459471333376067541234901538285101103690622656631026001337239036711179989456674399137008584021283568040818388709554256523118702728176420022080138548890713013682480239784198421500241995499841675772793497485550923152267616622892846304530712344886979674416990935007952941652591352603797627920865960622077762568060903908151958000');
INSERT INTO x VALUES (8, 1, '99679.115123747637190903598543851248555278745675862923884476564848911494649941770503156134872464666625927195645517181131678518619856156844072856993813601495176097972982587061507650426363887871820112714099226501603733968262566093655417466145183587899155614471697804006772915054739361437054029183182533671508695646413074668188590846200362324428338974890534273352188276373478524543505805545661569395314989170104140776362043880099775594658817242753124957385625811310332354760117110779649164022618274859298031549851269619167173746259018497289174255201452265070501056913033329291819570027877856677145579673495987354805150868813877928857472561883332547900866904764950837506993759536410161752469488392566682723027340638271076406246129989851281210810196699482980833204884400423019400653089825859983062096326294783573417554749');
INSERT INTO x VALUES (8, 2, '-994877526002806872754333651763017.40289299098701084219066388457144979069028441485513418625082363021182982914675513019536443438529749838106171095037135009526312783302868247857009494139535009572740621288230740389545481395');
INSERT INTO x VALUES (8, 2, '994877526002806872754350645735464.68416747805032096555043529892327279933592919076133348036932929591304098992323968210956723360062918640113701577855434596514974380902868247857009494139535009572740621288230740389545481395');
INSERT INTO x VALUES (8, 2, '-8453460632655529853033389979024265783461224.3195241893307807116624750282852146303290708492834695194274289713076935297734670940696121761483641291930931061232942894577813178566088927221374036301485916497770984757492912292002695944367308880163698595015497307574177176409203214324418237020500352652934909632442547242092296504047310806151851207329042221920888326000');
INSERT INTO x VALUES (8, 2, '-.000000000000000000000008540735921314463871578184793632135730756619558669911183806487803411545406462244216408739432325839683804021466133071768612386706692296158696852363349481716813410857655324486448455846562309041306880675446880859847445987588059144788756984750993583865748280824370754934966494724951583311563735533173023858438364336214213295786266815116844775733072416507474834701984381586060478606371028156925222726225495235702395502085206072985373035972506738983640539009567237336002073370431753469632428303255926718930619221521257726366850472572830063284204851204189447233044832163423057501488364913539948261528280564870049935369825245920984413480757133585498984374354957754078525161296201228031555280486615145365039415418251448980923331334883673792135893857917681235883506783408111446970710546686739582471');
INSERT INTO x VALUES (8, 3, '-60302029489319384367663884399588771256.5916339968771732477072012126949734214868901845505193155307646111690097978112797961939995859130827784737422228762767014427842766445950111427710563453217985216966456785944859989497422927661683538629473170704026975786513125842675604577233871570629808699803522400038975396500769162308448069085909755023233588510630417065084295051270219462289785473643946404281422516357503746700705970360169619852905053433235726497292406142332833');
INSERT INTO x VALUES (8, 3, '60302029489319384367663884416582743703.8729084839404833710669726270467964301325349604567186096492702768702209585877643481082023851284144664938175277044596973126708926205950111427710563453217985216966456785944859989497422927661683538629473170704026975786513125842675604577233871570629808699803522400038975396500769162308448069085909755023233588510630417065084295051270219462289785473643946404281422516357503746700705970360169619852905053433235726497292406142332833');
INSERT INTO x VALUES (8, 3, '-512385513828318260570283740065493064477880918352.732624553690077857674083796435724202494963885926573907185100543184828131859183999195040110586155435203949963570735841632689374488877298209082579317039061893012560130258753218955057387206477423088065663401594359617882154814262843273526859406265633827109554791772242178864873774889091687515990672487380368975556580539271333144212685871370972163560839446696514092637412587953506052848750866803569213269271165856310101244342151576488190595936869490659700946174362872797854591188391982770203203644172999264143929484089237665313698600170041324566984832357000400');
INSERT INTO x VALUES (8, 3, '-.000000000000000000000000000140907135225782279761112255989433531718277338909398600029580768021365259747075253760824424092983497958717844671162530550507041138147836569244869107757945370200122955794509365120853536859837243314494576053441804831018954867623755033888264275704547752628348151132333655667171970175829826792355986148522268067032057293494927558322394395160508723637192234110428953945018965078022622950949911124494740703606109543716688008516750321047603009424529696862953094999450658951089435460411028678817795100630449046993274191915359520936265372754315076684798942557329584282177053819106884196674660057281227248874819417305259132106690385871316407455034281900110779740008476645291647094776093567400422266906817555937149628005629880142615126571231411138926043531449659320501743591992888328328980526602');
INSERT INTO x VALUES (8, 4, '5329378275943671819201468.88995490340795935797824952902333498786202536079000703830146057240651898748760197658486790165425772165585380839129948178510273188565692769739983054442503547211560297249686289665792078548480268091496050883021187158502798880896590227542729659940394038802461081290690995869705131152889309663639310553909874081663091069118126221594338242710530718836025225507189149221049928936955230868771875644038572888630664890573507822342998964954667474300944699078658989010257103569231493090050659723450626338923049035040974032671138430612839043269997482582763267536489504794826476836323549796385028155416935072959933315468068930689064483178204550825728947252440604703474049780550458442808479096492346910001692358508618202898514895453589357');
INSERT INTO x VALUES (8, 4, '-5329378275943654825229021.60868041634464923461847811467151197921638058488380774418295490670530782671111742467066510243892603363577850356311648591521611590965692769739983054442503547211560297249686289665792078548480268091496050883021187158502798880896590227542729659940394038802461081290690995869705131152889309663639310553909874081663091069118126221594338242710530718836025225507189149221049928936955230868771875644038572888630664890573507822342998964954667474300944699078658989010257103569231493090050659723450626338923049035040974032671138430612839043269997482582763267536489504794826476836323549796385028155416935072959933315468068930689064483178204550825728947252440604703474049780550458442808479096492346910001692358508618202898514895453589357');
INSERT INTO x VALUES (8, 4, '45283653791262997781451381354094822.762732909505051438036873220502792213670540454778361182993875916509061144859281577740137081988678361247725064336120451090222456518107029158304937620179032477664627949959143233370320432203497828243297406462513350790251761540074946469824444452248386782451723637769289822576372357189700319768797708375563651655860093365309717823602754924352327588945034832436331911584742966378275504545736896430718939807674966738116698454215555860047859161126694019895490767779791933882712567492115664113775047192011252893773389940988533801360010782816196288710063568554147458866942816721046004257953642508395867837127678980002737669139369781058046396738606563716339660654364541530532834806205571191828994250708412638796240377704994928921528330863683630622922959130920715261879547446054261914770022377059156125037157979236658010950');
INSERT INTO x VALUES (8, 4, '.000000000000001594367257057971052149628499448029056279649281098852958322409409919964709324200796473211884339143791758566019217634542932882694487712398244322522748736692741288668885362384266615527166964187404128216235057387796054457728789109537338988453837993084016408244895452291151218602815057669592284587317035387004942691671916981967449109983992675125005085762403043329820872839739877674121174083273716295673230993049263574856197011389828478636779342320299895806297835595427859271617831720398457416685435560152182883615601663820189195644140652141180949257192740185075408019971747810015931542757445763460947106918998459997631117642552273815713467150465548031203738878873114842844016176922502916339025283749846225376341878386377192605865913018132981323065698049618379727531925408677611856682983907951667054819');
INSERT INTO x VALUES (8, 5, '7844230593.20607652525116672615394735666141304947992676684520382624714879797087461877675155217754947572297228288498221620714146356962938009770486619898336249374975146736655090644822719838495585664994425117350974491367099004404995846913641329458537237789584653041949090121498951516476399288513593944575192159570458664608461677113504914551578443229008454218964701550932948083369656042643364608405637360180021322967144409944099438498649645368196191999692949583952927486593144959284443545794934667002661774373364219852712996869245745722896071593910890197478196462961042627387162830776094709087748993678069776845437889735782063');
INSERT INTO x VALUES (8, 5, '9149741854.07519796181214339720582405769040995916571800906099546787135686773033654199973299973665332349235940513509308862104153230025723587829513380101663750625024853263344909355177280161504414335005574882649025508632900995595004153086358670541462762210415346958050909878501048483523600711486406055424807840429541335391538322886495085448421556770991545781035298449067051916630343957356635391594362639819978677032855590055900561501350354631803808000307050416047072513406855040715556454205065332997338225626635780147287003130754254277103928406089109802521803537038957372612837169223905290912251006321930223154562110264217937');
INSERT INTO x VALUES (8, 5, '-5546455599206321494.0676583421119904300307105296377723816472192007866147764761501865875232824814135783697976183493106885436876081315217834621720906478074798596116645640251460842350553806256223963023430631066024389364515688765194373161385579258482225808660340732705687558150699172147896486727530192499184101617379930846663835628510376484675411350654979679181852179924386290069790336316958202582966248703889464308649631486542724072047294216362186036638115240070658004553260251510288423749333873893917690832829128021808383128393431810674177390352413548658782609064839524756041501835115152819802758773711821322162752064589750295542985780512921839490040396053737870038534216948323935020460307350020911362024271167085905714873548388570602799432705061561572854498075600');
INSERT INTO x VALUES (8, 5, '-13.017101389051085341042057308965769356145255575582875626848796382322826525772114256699384710400140437710569924703769685567402446691691210934185000959063158239023412379691360587119206695513775971704926722817528818197919265145207032750407924774510773427697188520818450702875142190949766251178733262143962213111236591970766836685919581025629742334704854852196126735685421250263035895756028805974153787560164935038227108975229771590754808331856162035119882347418116049174638416621093907738608991987582465865527947015457540650512339263071898410531735438556948115098562123055444965056347091625748703503220861221718449714020622377233272042277814766996198081939221253025243417993701684007826177845003391944496774674489538520354606358872276671998045196738090133576377830721671972381371985771591052597345572374064920279182');
INSERT INTO x VALUES (8, 6, '8496986223.68757431572672621257436634648368772473081887846765003074279255322456188404621827857612554765910678041003765241409149793494330798800');
INSERT INTO x VALUES (8, 6, '8496986223.59370017133658391078540506786813528391482589743854926337571311247664927673026627333807725155622490761003765241409149793494330798800');
INSERT INTO x VALUES (8, 6, '398823655.819545574205652791249227663407026876411660299394659390409794761643751582473390322547798567169668246138880832642141417531427935520467563318363116897177899262525720710134129529640376020947774470933902793259531840625444267816319963200');
INSERT INTO x VALUES (8, 6, '181029319177.110996740664566780784253502559986936959009611748146099327460471609593148344991059106574612143724330935988823134137686051475120980257829276671900076859337187540608483895641504622910361858962883971613675309676443079313179200981488761707281247447120551917205792352229666049191991270809865110506639390610910481490688182068719005593641339338678014189749279508731647492051879768743158839680867283217578754666643688259810863605002821607490100820241093473083445658378988069593782353275713240897038366242558466047071334385431080003439842348547427066389352198560236731403235927478177780757802759046212921140424771887928786549573201311120885052685761195784207710933764480136690216943336587118385525047554334029388869436622866247240903231799829259264158812528305210833683370536416861544931420820452512390255774498188962903');
INSERT INTO x VALUES (8, 7, '-818934531574859518.35936275646834493832011429282408849567717761204690035294074716714939441961175772404289860039233415598996234758590850206505669201200');
INSERT INTO x VALUES (8, 7, '818934548568831965.64063724353165506167988570717591150432282238795309964705925283285060558038824227595710139960766584401003765241409149793494330798800');
INSERT INTO x VALUES (8, 7, '-6958475505053954666339703437.48985528725312694198056665033448258303533387675711770743843194274181580881296671866212320171337132096489224277825857521033238709600');
INSERT INTO x VALUES (8, 7, '-.000000010375659845651632013446652385870617923988120764298690164486716047614260682259722116360931978511176121353975789418625836899338225571166376573732227571704071000348895791547943896682585450808398324252224265156214259224488248639550967292466343168350213394398101712526534464002532408445204630441167137710565437434313424987517531891145368203998329086865151248833625645567863740298397742783405267970015165358620026813812552194344790169289440822038223606218360105618852154152168496637886434061050281055613760360200323363465925493033734895631921307644481639236601187225135325401868178006133838932915485272554505684060229409404902185944047523033315868230944723282246159741659387362889777495094736963530708159604929268812778894177095572578862150793098548829744006499229853198046828954650334595737117597239208825268');
INSERT INTO x VALUES (8, 8, '16993972447.28127448706331012335977141435182300864564477590619929411850566570121116077648455191420279921533168802007530482818299586988661597600');
INSERT INTO x VALUES (8, 8, '0');
INSERT INTO x VALUES (8, 8, '72198774884738777393.8687539247642452953425155400068591498151280875559609979248583367700231031634872342122563819478919600402159024059794279536786611373504966204744811722007869415559012475160471227957857756325962941799428857291371597146319816910515366298862558849452235442246081440000');
INSERT INTO x VALUES (8, 8, '1.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000');
INSERT INTO x VALUES (8, 9, '8551849703.98748751358673528924211852802333963452553842636251612056366144128630740476125273064380199240146487881028508694029546139131732304020786389930600883087012615993343976556472498552535317826554614696684732913955544753638726438705858481670766245958647367500212800073774509075408148134050353551558174813940258910304990570172170811882520915334358633');
INSERT INTO x VALUES (8, 9, '8442122743.29378697347657483411765288632848337412010634954368317355484422441490375601523182127040080681386680920979021788788753447856929293579213610069399116912987384006656023443527501447464682173445385303315267086044455246361273561294141518329233754041352632499787199926225490924591851865949646448441825186059741089695009429827829188117479084665641367');
INSERT INTO x VALUES (8, 9, '466174236688165594.9218054325256670866060556227711696100465581464881295978997280335378678072434776702952026828137140986670189756965420183565968027969700090735690246176791371115610886533930223141650377886909408268207750238603105232560663571044993507074695683027062426288270199495225881785499139012931143826099668999261931834700467395442768201666740663642498098541516326470052372008385656719236306238735524802875519713512894448940917708118676095378518264553310312628830009314653641136566040400');
INSERT INTO x VALUES (8, 9, '154.875085756903716715488911525453064308758123952566428258639786597308109810869086867746263482721081985848551254298524280231489145092826397833394044637104667137816928932471315095067524966582810436282901424423215992139000153713476369887383242289102867530775908269805285313842050961754114751975054515055089553180717444020378611767296609130477264722612784088270193199394531972594028420402254831778715196248487757266330454269044609134602570688339750190391651801546906342796660819535014295618246236706572780627362908121159003488810140236665846928586992082180006454824311789091323774002510945263351862712964422865623934112293184149374573706760114682326698881257123280119140924775171374360283137569618025005229268057970275164869735173660958715166148344076027212231446680947914004346760896298312286730627916684448923824769');
INSERT INTO x VALUES (9, 0, '54863480.34685027005508022756223282084742813020271603840941647350440860843570182437301045468670059279379903480024743452620396345637401505220786389930600883087012615993343976556472498552535317826554614696684732913955544753638726438705858481670766245958647367500212800073774509075408148134050353551558174813940258910304990570172170811882520915334358633');
INSERT INTO x VALUES (9, 0, '54863480.34685027005508022756223282084742813020271603840941647350440860843570182437301045468670059279379903480024743452620396345637401505220786389930600883087012615993343976556472498552535317826554614696684732913955544753638726438705858481670766245958647367500212800073774509075408148134050353551558174813940258910304990570172170811882520915334358633');
INSERT INTO x VALUES (9, 0, '0');
INSERT INTO x VALUES (9, 0, 'NaN');
INSERT INTO x VALUES (9, 1, '54948723.74225051983134098996071145685528795757427462111901537365053896571438476055974853245403475510333627298551845046116291696445177112567064282766115207407461565363967417615506303416694032848457927390574251904212425813072768882213388082765916956736282110801611726537663292922699021333445658549608928179155685881583228490235606377831724593358583903616295573678510929020831006146661747271783837653203039829647102027431761129518881525935216608429897041525858540380754759125150233053469999022855035');
INSERT INTO x VALUES (9, 1, '54778236.95145002027881946516375418483956830283115745569981757335827825115701888818627237691936643048426179661497641859124500994829625897874508497095086558766563666622720535497438693688376602804651302002795213923698663694204683995198328880575615535181012624198813873609885725228117274934655048553507421448724831939026752650108735245933317237310133362383704426321489070979168993853338252728216162346796960170352897972568238870481118474064783391570102958474141459619245240874849766946530000977144965');
INSERT INTO x VALUES (9, 1, '4676749348240.390309875431213992853550297086049749814750492488995108783145961719774217441193547534210468967573344456866203963659951312519988497979489304488948342258375915152429008993288817366720647491166024151209542534474867042837694499222928509320280684557676243780452100132238968233413333851595648146954975713386711764268506890884764704949969602122157394714663532141060559896359465918874990769222345665160127552795532197771168442486088776803398878354288847069602460071745966589164282641033852314335279121191855487126430176047553895892632834940595958394834437871886013513058514896870683979585091413977173250824451205330441299000850618134248917380244749589254309567551846327349592529960432446947239714236828401206843011440433362544797025114476612133622499094287321570559088587999417440664282418005102546343020409520421747216');
INSERT INTO x VALUES (9, 1, '643.609749344751131516972294140174556703217311736700045690413622699888869645595256683013323517984528456698303984909359393772036036540901870537096836621035845014213031549051156299974682317824766457362427063305495772666640279328909129870227828460705733995380145417663304348663705694070309475835826101153850359826502235923289787750107778906593010060115662191620280031872002110849782776325630424918493602259707267214006217268630948545349980430128422952869610116216278256812581821942763705098526140427280008360043829906543029486315209818099697988089748683904695870401517598840185535891464842870210715421728852789815860153472208176465166954851895457846723102438114697692610933532992841803219018495137378534010155991355251803548866919409031477821173935696065078362044927492034445482457329200246282082707380974745411383781');
INSERT INTO x VALUES (9, 2, '-994877526002806872754342093885760.69667996446358567630831677089993316481039076439881735980566785462673358516198695146576524119916430759085192883825888457383242076882081857926408611052522393579396644731758241837010163568445385303315267086044455246361273561294141518329233754041352632499787199926225490924591851865949646448441825186059741089695009429827829188117479084665641367');
INSERT INTO x VALUES (9, 2, '994877526002806872754342203612721.39038050457374613143278241259478942521582284121765030681448507149813723390800786083916642678676237719134679789066681148658045087323654637787610377226547625566084597844703238942080799221554614696684732913955544753638726438705858481670766245958647367500212800073774509075408148134050353551558174813940258910304990570172170811882520915334358633');
INSERT INTO x VALUES (9, 2, '-54582443595378013373024060492546032003692.4875677735896411267274323339692558458420972958075073392126734000341372096298914875892612108329218081214550050039133117695428196702128258481789017059073444323729583900855712795086447886053552786449313809589992185978097430132940882612817775035217244553616977182049775786664446683332098226841743818600819221587510039430478859412452506872131851471967577741190323481953867845129745440745526578327709351120432530702446916035797432129052518980799424635406993848916727957825620638983706180841278402925286540375225365057191075559133035');
INSERT INTO x VALUES (9, 2, '-.000000000000000000000000055145964114074763360265614481666934002579974728749248345352023099030383962250681574081874554842623852433135871821620640200582985140388676650602814646133317791813938390695683843848260103199745295436998313216878337673674660966362155480524935736646623766057029148471463569162153009963312016563281545776175277904913263614668092319707343286073000287493274965714031678784835459999763925833141049057636632430975424499618419962303087175237320046300285962065818926167792812657620724550768858763098967149546312995222223400007044549870620849992226072041407997925405957501929449911416474388622107825120486594723448780503829317691081601820425151593487431389373265285594626753418140874747955925763163132984655078996173911578832035721963554569605730262976354029623260224710106409129114204296314733036');
INSERT INTO x VALUES (9, 3, '-60302029489319384367663884408030893999.8854209703537480818248540990234567956069965340942024890856088355839135538265116174644003927269495876835324407641642359213535695803871472434650475144516723617632059130297610134243891145006222068960999879308472500422640481972089756410157246974765071949782242392661524488959954348903412713930092273629207697480131360047867213863018127928853922173643946404281422516357503746700705970360169619852905053433235726497292406142332833');
INSERT INTO x VALUES (9, 3, '60302029489319384367663884408140620960.5791215104639085369493197407183130560124286109130354360944260524553172025725325268378015783145476572840273098165721628341015996848028750420770651761919246816300854441592109844750954710317145008297946462099581451150385769713261452744310496166494545449824802407416426304041583975713483424241727236417259479541129474082301376239522310995725648773643946404281422516357503746700705970360169619852905053433235726497292406142332833');
INSERT INTO x VALUES (9, 3, '-3308379209762459471107480259839508279070920437.883503980178028214343751083865562028455061662673132221930429904398963590401793045470444301883103141901787466923883803951815572606105617157736442670792467625964359169270739534412932791178258858918086886061702512427989129732248215348301444245772127142869263635282888226326427510486246184233225114523636171202034558843515894542952126988613018789833835507734620046994907453602573865012044120483116345444810078666601100257620969379968264504287700045822481492526688635364586344704730579892342786173395802035361824932075736340405960099542224953439044947229246847140957298841482874444906129049023002897135347878048572628834749795298712449864571996898774444932083319581439741625832405434317985988163261591679157437224404970927012111196724239860528859217322132733404472897289');
INSERT INTO x VALUES (9, 3, '-.000000000000000000000000000000909811507365065002714756487495210579371808512079908127938523896001746219475805196061435010714649189975968123072269549018826343830061696154665503565341929634172463095299662727352635590451263034658630449260378893723785917860125051787451512267088404686342938118993621396641623525252649748977992770709930435013456855344203854749977414354164157192885125263071636468941596567220391082793700307461350484216679632552883058303710297475827456761138832914743429330069022439380297715971317819244718196187172770061156794130040674050533617155253444764036426045091327368023602807193742585178432544430741520636125146531502042579276206322507516332917325631822606079220413965396706334639331097621824106950192993127113903265025719013680733760540930122186345919977470628988674677630636632053583144327');
INSERT INTO x VALUES (9, 4, '5329378275943663377078725.59616792993138452386059664269485161374191901124632386474661634799161523147237015531446709484039091244606359050341194730653343894986479159670583937529516163204904273806158788218327396375034882788180783796976731912141525319602448709213495905899041406302673881364465504945113279286939663215197485367850132991968081639290297033476859158044889351836025225507189149221049928936955230868771875644038572888630664890573507822342998964954667474300944699078658989010257103569231493090050659723450626338923049035040974032671138430612839043269997482582763267536489504794826476836323549796385028155416935072959933315468068930689064483178204550825728947252440604703474049780550458442808479096492346910001692358508618202898514895453589357');
INSERT INTO x VALUES (9, 4, '-5329378275943663267351764.90246738982122406873613100099999535333648693442749091773779913112021158272634924594106590925279284284556872145100402039378540884544906379809382171355490931218216320693213791113256760721925653394811317969065642404864072442190731745871963413981746671302248281216916486794296983018838956112081135739969615171358100498945955409711817327376172085836025225507189149221049928936955230868771875644038572888630664890573507822342998964954667474300944699078658989010257103569231493090050659723450626338923049035040974032671138430612839043269997482582763267536489504794826476836323549796385028155416935072959933315468068930689064483178204550825728947252440604703474049780550458442808479096492346910001692358508618202898514895453589357');
INSERT INTO x VALUES (9, 4, '292388240303165948041827159734686.255558469787242316676287235194652580157149226950109397295920730296960145548003120827363226435916209781396711693581454960342091452830648929118261388933297036933167543189308061917640517578583521401267417187854611829815212778183983326568586118831109538377828156118900313778053576483381085207892754728937946691892849474364477434665960112125254104966566712906532318984871145605839506991591027939136026602051635433295687547552796828217859648186757719639965988287173297286034098497871707197092627676226053609131138590878743560287292934815277894463305001278326023708395571840850120055316276256138004565442099731931051413153564744766098053176049414330146267604802971221161572130161432525297614616942172815141372973870720928125699420370428856022295499447755488148545048400795053604349570217878099721865670458104653570360');
INSERT INTO x VALUES (9, 4, '.000000000000000010294536718194523982241053267404812827031741197656209184880073175960433631103885281961037127283726462743623757855378209281373475473018922090781553213750339001555832360656399849031527008437303091226051008068950896796359518673740801770866360774945096397034708173365378527676779736929035450380795854046109380272505550244458858231227568118355064007614608452292270378691774826689216790090661497154742954386244856792006376222923780801296832612827123778915598893970651480451509706836620045721191411824060983487064555397842027454385628620582036592315345973096405447742002746762099231557054678593446667904250189208490698468539396733604833688133512716508825505666644390119877423938820483653319376926639295680552194966870285838815705038244628263602997511842285889300557188773128635554621378148419364876651');
INSERT INTO x VALUES (9, 5, '-597892150.08771044822540810796370552966707032464017958269847934730769542644402913723848026909285133109089452632480800168074607090893991283808726990171062867538012237270000932798704781608969096508450960185964292594677356241956277714380500188870696516251767979457838109804726539408115452577436052503866633026489282425086547752714324273565900641436632912781035298449067051916630343957356635391594362639819978677032855590055900561501350354631803808000307050416047072513406855040715556454205065332997338225626635780147287003130754254277103928406089109802521803537038957372612837169223905290912251006321930223154562110264217937');
INSERT INTO x VALUES (9, 5, '707619110.78141098833556856308817117136192658504561165951731229431651264331543278598450117846625251667849259592530287073315399782168794294250299770032264633712037469256688885911649778714039732161560189579333758422588445749233730591792217152212229008169062714458263709952275557558931748845536759606982982654369800245696528893058665897330942472105350178781035298449067051916630343957356635391594362639819978677032855590055900561501350354631803808000307050416047072513406855040715556454205065332997338225626635780147287003130754254277103928406089109802521803537038957372612837169223905290912251006321930223154562110264217937');
INSERT INTO x VALUES (9, 5, '-35812445701642379.972368737320206275515144213236752803936806738624588812089615098329765811617509505790110909629109400553415312470540217508070421816878544125783329593128638405659896184248784794258084116406472768709113030915308410565617764394827427154923321461158387012978726512246146545834669665093228316853342805604075936530371665576147966721599968786161939347726656168798065647411457701453987215491345496003650288850096338695703984042549594979897253521041581573388369367579323607093487743440894765114619634001789457486407909224339065748496715380572175183589195611952939575073075140094901024063428239223964510824958346570603142906309198033196987949067156046076497974760641964978711558209708743776024313916111738542765749928287600981397080809041007714387564206594515733287925008053261840295560398311905155157989225181164097547541');
INSERT INTO x VALUES (9, 5, '-.084049034261605466896663277055600903951276881294745183935726262038673990196778002490449355450474227878560465916800470848046625257516764244432096856845087412397406701521972651300484716852035267197801389708234913163750232707469240634303111868882057393120649919262424619226282082184091177505826009374043368623853156698509808569378758387708910629731005691079770517679511879694426434724918004419953301426679939010592502325130576915399009756468717124460489039474155719834555522581553817856854607844133431854471292027873672356863673617090151801474016666978499651970627896504709551656249007718965259502928591648533670568214972768900993459927860068104745163979267716597907297073374689384723943955361288974065531322408839914599555769945298758102515352082822617428033648130099822033393662643586331479103933840387663729387');
INSERT INTO x VALUES (9, 6, '54863480.39378734225015137845671346015520435061071252892396685718794832880965812803098645730572474084523997120024743452620396345637401505220786389930600883087012615993343976556472498552535317826554614696684732913955544753638726438705858481670766245958647367500212800073774509075408148134050353551558174813940258910304990570172170811882520915334358633');
INSERT INTO x VALUES (9, 6, '54863480.29991319786000907666775218153965190979471954789486608982086888806174552071503445206767644474235809840024743452620396345637401505220786389930600883087012615993343976556472498552535317826554614696684732913955544753638726438705858481670766245958647367500212800073774509075408148134050353551558174813940258910304990570172170811882520915334358633');
INSERT INTO x VALUES (9, 6, '2575131.137912978352131546639620215541477987701194164886305951830806120142596646541302305984776928560906754259789485960991272272782091464270104432109904222200473616116525297615725803495463468272171161659654385929185160689572943852767523792651123455283534072794326647404332228203001469884016996499768656263775233430922446983838511590562929268821678518640501686017030536100955531423152839988008496919169395159653034847677470665418765966542111749439412');
INSERT INTO x VALUES (9, 6, '1168873084.346566233232746391559830634361431940000227460271861554316197556566224118756340501278103405856646766537018954185964066240457859194626558143313125824412559635129130086906976028635444060218797992547370132082916380788496584864016645155338102476357490305222392452114945853620686975383081427840791892729407194179236897452655907829255937027286698570784397487382242990326347080472574546312522326038419753951437799831430690304084087684303035538181812523230890783372773953961677974396907303758903934808035747944477277528267001070234880092255363221274303820343225415479126819937070570562654065195009839593938440374000473302075568746771126391307584779249330981594640387657042725725493800876630516005713789705652827210295338592985225924959199657729900181287069808881130884115897407246324220524401243575641227725030779990490');
INSERT INTO x VALUES (9, 7, '-818934540016982261.65314972994491977243776717915257186979728396159058352649559139156429817562698954531329940720620096519975256547379603654362598494779213610069399116912987384006656023443527501447464682173445385303315267086044455246361273561294141518329233754041352632499787199926225490924591851865949646448441825186059741089695009429827829188117479084665641367');
INSERT INTO x VALUES (9, 7, '818934540126709222.34685027005508022756223282084742813020271603840941647350440860843570182437301045468670059279379903480024743452620396345637401505220786389930600883087012615993343976556472498552535317826554614696684732913955544753638726438705858481670766245958647367500212800073774509075408148134050353551558174813940258910304990570172170811882520915334358633');
INSERT INTO x VALUES (9, 7, '-44929599044588573810654775.83678007633232843418115790847152455559258007804727916986432256198687661496804050903769496933400455947645400628259699874770581538122521805603947464462448454681701547899144129061961394870320463199545502030106801911915987309444301341575451240764927967432593181449618816978119423290767783843864768557371257918447461479570164065303599994081990686');
INSERT INTO x VALUES (9, 7, '-.000000000066993731076524206362744068866774567920404984046399050881532938231826344009126898802592302273719505485084766150904380671495128604515800845609713368334606489445184535043833069145643553083555507533900955661105251251918425885537513359541698046533092111969478225528665278023069818968531644884466229545497943710817187632203193468836772459599856856811131193744272314519908999458320275710240994009061040198159739169960258978462113813370513611735006229733329565083659159456172425715216475781507996483885669437855000029758892126410922067202159414570164537031153818197618428471046051340835826664787585016361564969663413176434498159140395476980277574789931364078570781760777773379636490084338326576889857824344578398580499610233575273027387501809967324874264742269453420400624883982643066864175851881870402856698');
INSERT INTO x VALUES (9, 8, '8551849703.98748751358673528924211852802333963452553842636251612056366144128630740476125273064380199240146487881028508694029546139131732304020786389930600883087012615993343976556472498552535317826554614696684732913955544753638726438705858481670766245958647367500212800073774509075408148134050353551558174813940258910304990570172170811882520915334358633');
INSERT INTO x VALUES (9, 8, '-8442122743.29378697347657483411765288632848337412010634954368317355484422441490375601523182127040080681386680920979021788788753447856929293579213610069399116912987384006656023443527501447464682173445385303315267086044455246361273561294141518329233754041352632499787199926225490924591851865949646448441825186059741089695009429827829188117479084665641367');
INSERT INTO x VALUES (9, 8, '466174236688165594.9218054325256670866060556227711696100465581464881295978997280335378678072434776702952026828137140986670189756965420183565968027969700090735690246176791371115610886533930223141650377886909408268207750238603105232560663571044993507074695683027062426288270199495225881785499139012931143826099668999261931834700467395442768201666740663642498098541516326470052372008385656719236306238735524802875519713512894448940917708118676095378518264553310312628830009314653641136566040400');
INSERT INTO x VALUES (9, 8, '.006456816440893715330247418029019114736889626790871612141686117271826070935285769018710680035004320626745647926106882508048159628931624522666638442625219959259156539178378186912871506893482633695438850964052285542425753626455183282159259999492971992739484319464700978750304962671213318202670228197968646486740006148091321740497272644910882302412140576608739962605210964504469426861972705740810533465451230811358870068391007718532021526225893542801514255726272411690175555142385382688220121052891017808391607717500701760375927811435030512071347521837090721052128992926357375527600337655573639413811262412492632491693179011503973930804928749370652038245414768103001067902012962988384812280453070895781287237746786414435546976395632454474312533482077585837153357017362048554313154580576238549196250793055676215164');
INSERT INTO x VALUES (9, 9, '109726960.69370054011016045512446564169485626040543207681883294700881721687140364874602090937340118558759806960049486905240792691274803010441572779861201766174025231986687953112944997105070635653109229393369465827911089507277452877411716963341532491917294735000425600147549018150816296268100707103116349627880517820609981140344341623765041830668717266');
INSERT INTO x VALUES (9, 9, '0');
INSERT INTO x VALUES (9, 9, '3010001475769225.8286280957637941018500905354415197182850820227163907782811814730309044010416886791014702373809932926301368137684091094408663914110947072451332976891128659038142954192986392936981664792370678656287232795203974766040821110221158579481177539669363513848425151485663431478439528936592701070340012569297177488556353760756495238304538439278682066056721729656193616571456456325016960870401748115848423105783116854283646624807603476682295234280408938557209608025246638166902335016025467565869375885610813662767004038102486303756741615124814580306266901273803721191779461890468156043551004644728343579032524687612403663816107770451694666844862368101122025340182510019516924578414085461628689');
INSERT INTO x VALUES (9, 9, '1.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000');
COMMIT;
BEGIN;
INSERT INTO x VALUES (0, '0');
INSERT INTO x VALUES (1, '291.964716019333021494947753821238960905461614737525349376826064492714634914263808902604580614735501799528494357560837535773816469841426747889103714048646989532842972129124080559131220979335403729022278994440514872845756198274805589586120535745968205107562348427941379641465378272611453955517402598409789621997041856848783989993820946766177453801729783316269310186191833995557234577548740940419224137195404391193633808203715191863638616433190672511651125299379882126530500870287424768024674231651229908224729856278167033444719242144302972892419034855417126978468296581589282861879645409909873113678361180607775255758820910366926076380306290306477790931129670172989289536405788838857428768869345763784112862591549008321546447442552533919976570125718481191724503352619626562352280522949665158335559389298720990302071');
INSERT INTO x VALUES (2, '31541679188064906.712574384704440356216787857626740375004266523720148374188511622980520374202725176835435173058936870163875556102907654264048353814040480579464700545975346621546520503928314632418705230212623378642743044255181848913683862360044189531298446109955034944189751302497670367665492719604026161836224535961347218522748523360100432275693829501972749859329753224444694962089604095212784768854310289429208671271394086829270986183171968944659703708706544668326267327938226750760690620258967209626420981505237183055363540806281098871221581265173394406715458619627534396065960117454160969749739483126059760636526242783235685190739315590041294766649891987044641492234243404608847939002062827210734973778130441825067858641461599799772535304379732674727995848518807202053316225824685704785148921785964036119338754973714515974054');
INSERT INTO x VALUES (3, '7765438138915239878.949520541017683429203286303188179443533225547096446554008374834292278237558244698868300666061834105683999048386497322007336816482648302911579331582895326423063492240235074387242190187374869842856897538718280497895072291181675294000739548676781615025944675912072664211455701112700937190832332966000160156597821149428032612782336278939437593991008833233156511435294360065004167893309428565243314846456225604669764879344135321428948841659419438769652686215993544390780212859309497190065178705035652106614050448518931820975038314187040226298661787490226917902356569717171481159691409131778764973037046501816919243659681416263730519167614043077472097520207347950292377914586524327206547377189493301153212000966249655331053184913579513686655963686155890934436604123384536027235444923674128269748280097789270784333442');
INSERT INTO x VALUES (4, '2308544622905.016172868282330339228589083058636874526727829838244942341440716909466939214393597311710652963849541394758298277969240038668406494621950956862959196896847352631445328917063551082418729435554972200530109505384839391233286173517804321019323644218483570886304028175359854335870835404627608254205407525763332087823548640923282031978903399118139052814618531713327991857575390136755426466065839913887477577516426991104516201265995293600539957187007068885368699949673989051443005684755994465547159213587471972139403333249259808344536605314911144950465968669770276463111776581675944967401948957460097365849699783091843609965345747287667911324039374314413430490112443463386381631812537639503425989372084906324702158112088898424705684574998783112519152403201231176840068666882123684602080460378627639651465436618032671756');
INSERT INTO x VALUES (5, '25549.082770905117529972076915050747181125832857399138345044265535151111965091602789684342996759657333588444489085160336703294705499665424408218434077722506748278242942379566431768762487954917389137120540138359870652558814224523699917122023018717544160579704907452934297025088008618627873220397030397424422097405152321366495319708580932627092620533785271831833326130796638935296720064431288560292191928489034307645738331451165431755179025359993690642194334018457793169983249853388987495489562746304107188105521296156525984787815685365255240654972150342496329030279439124533240114879332406941960563154881888172285475336782757262639979527682925214971861707635327995621436598536743180180978457735632181738067997521785965451385630326464388080990200265186437768409003553910194212076755448477164192901658547251079126833187');
INSERT INTO x VALUES (6, '.216649653115510782473161631235601739254284877523828136703593069337209747459679979369185882839688430004369697316986054374456779366220242645866798278985273820408495361607183119980716020227424205519727777568954933592987351750339481522149106749713967143685591960510946511796062486795368200503801097611436787402191532618456991115230272084771674098613479989808680789347124789253499967359190605681912854639520917409710307182238065185749856554472717209097115325999946728168357936779767099041518574001682560265549916593333117469681763348860131760281253987626822958726920016922608371657319505153308390495179319529587670415367205193280809809356733443291197315823747505896510820272670040485083775482983378341120809542502350385555577946098824446199419354197416933858522419312733314383889554606932774046771497129486979593226');
INSERT INTO x VALUES (7, '904950020.759072496304165474991957396337281699986101765045213964054286624338102141970514306010139529492299343393832200631760194440206005974547202512275476562767685193838576516154915404389465528270010938533075930081897392863141132529694804621418663424569202655893682412466871297412964570322984865326770090075582481194532433411398133265643849129084449161396724635797324126396071308557057830046688990212282866035593809633839882468628249964862932050189148498591642162462777480125024786829078066012617362076651920045684345679767223337287825546294839320770903419463644110383560050404456170063805115223954191445548226706113970164823214416171441655706141596091717118495955441099867737827763335880891937222647408575142200256804313345924443344596462585960919126827045197885802122062165934504665811115031150357820196176799560314653');
INSERT INTO x VALUES (8, '92179.098626752893864900181023972781406074846653380680747862421481598042923358730531575438403865501429843141967819802251116774924400485954931201776260931315313253827346015775662310076094882239170765060649024538403329505426563390044695320714825481746233901773893996663258170360232639353378395244461670781152793416950717050461856097473105730100523010642696332151571372764781034028324977128554099993021459338419164426784774496292405945103200724413639660488309795423335142455569853549710795692020963174011003447023610692365550245567840477105794884132665155376243735213346877116105595296043532605899184658904822980397411096930267453332143879534914237169761039374689145860503772331147367757318826885494994339695470190886515765452545019167989882527248872835783707554463866334705735781549392895480816605355996057201589681125');
INSERT INTO x VALUES (9, '7406.988615277484686670011157489572203134420118818648711986549881046321377798441006745317356200279801348355202517703531020643333388857073977704009782384103170022716610432579974132111487533733493986910583223121269323909760573942980360508642443245341392335557152177332615977623338526935953706604224108508582338123915133189529507760875123300397933931420500010248194253078118618381590347297853307090813639981736227771834732256867579490224181748450683295253634852775448770576585177080941820456051588076218688792321741398867304684922665590162004919486643750098085197190000638539994723704724550600891137853975703823903659121582583388450687255538838161486019214242094423895463814933532217776443473765708693285683261505695170847285063013324823850724236845500162436661946026097459146424122412596018946436589967013641971183281');
COMMIT;
BEGIN;
INSERT INTO x VALUES (0, 'NaN');
INSERT INTO x VALUES (1, '11.353265918833698201334218522735144514838241118349715803442713722607336732214173255618762341321138898556011520430414052782971985419141860417968593746833898952016980791997105866598425597066404919489902082738711038276194174786383758877067916049129476352925010880025206629976454341252818402788928939407784629386362069592202090897264194883276572978998896242281239126931595483958092059051047739223830394259082355969005503976135238921488192773135287876801394308064862257453262299764712613486466254696464150007113953810688169396432889052881763511661127351872408811370081346456019961324265446884877073712053408327408917588393884214304220369626106333713688792094943405258431214313197283237071070354654837081449831786573831004911008790533179001070424813584405346221388686999574752038655226138085374176702005198770598232862');
INSERT INTO x VALUES (2, '75.980172429959420723484178622920965327708652620924912610122049843800380131746381968266727388919414524075492921510147435877107720844487333947572033626887969846858337336557672107987074468763307953130616555202495401302128216460637786993535376622372745654109623249396257174895352222213037880060756992073605135503615371392439827458529942230210514752764526895030759481226199720092008002458654297737883219558685499445394647863430593136350562417924068100891680398878483362058595716232013516337079804607378041880078724811071904523716775991447489914128580100888252698281559809224785596795038122963619830942475652745611551345360922016753939774272970008770647516790944335173711498988149783075646985898883858697162003144539047532603946093022417842140993960433780913606807466518632121884254341907122163281927271483110212890483');
INSERT INTO x VALUES (3, '86.992429107491709045555322727377654177072455841678650084144967727028762699430180506209786297136121512625728883607972513154010138109866327600596617277403558404624813332464431424791338402731178416819791932126837396086742033973404980654712734845137075562739300866280737071167943367603243180515859476717635339619107593771719314284984269343476343816253634799874584843436046260962736006310389088154751401911743739429257286834178656182340416539923956100441369280015412718483971113838923221170027312390404790743389872757674342133486652087007983701950040432125562287337697971646750563062524010514537132255605131615248097901911480464339325353279118429890601202554448469387179349495284716473293965884844451619766312048304583068386805927433174443889441171878078987788018564357316138422561213329104267180509029624308926098065');
INSERT INTO x VALUES (4, '56.935276817066740776567329017240462885579486075188456418197311631774373422196025180114152248099799048545382060930401786002025479108787121595516444894009593031141335985913019897883627990503003577804436730367402618412514152465206336556967419434371593632864308139215157721913158949066717186782560422199668568894551013785702491365073449320535603830475158258853167712460432995074161536886421366716995573365924430692151761737886552457036412140640821310927642146210426044265504978418405684030862182425702683702307323138985481047994648222224089112998195621687911787785594701557252468626097576375468916953563766801336922479861708649876362257086586679701715813254414915314296890025577780265459584203893089574567331742100451277992780400302806430264717887468808962517029442262560742822875484362427192693300423729233467613910');
INSERT INTO x VALUES (5, '20.296713391219923821414834924710998522858242536565236229645868008008504475111229451635162536658197320282791428572861452713483981402773630985812066048575864982038046409484905688236579134672910905547858248343712686247795669280482288748331949478864729205285910525962001251260319741279139167559906461672936902355959755164523720443059989357054368460911050707727029320725144824995614445423492687177126412520389766864793826362309254124276325522276592246655562770110024099522184080118637524912964002223613671995639705240767929562023556724031894855094820328152633412077228479168557819219970917880393852962560319397442566813746504969336443969816954424715197797253670026862362130664772772977978222813915593329422557592316429203293264572088112274848838446633519530653849595288125585730314673691986554304725866754516304420665');
INSERT INTO x VALUES (6, '-3.058947463851998053084898503420969773173569760507671013593014983772013099601022840164736581595033399273677583253456908293015637115395777673836877852797643436458673662566205707359569792482081945396989472318998080581824382006377064185813936544714612287417301161454496258176319380348780934551188852900784476213986897306897793456700682073399936398243222895442594762628402487110466705108765286617060826203345783502301472192906817785365563881556293576463515218574477264521950513789471494214626744754200844840310516235570475410854073969787604451971790833680742315518808178608136598148628107328076871698598743664423452623124027059698038466681488746505289551548778131621576387262707147068500249466398507704796800459013580425992071957391417767257856002976954566094297724379688683375704613872658653366052459242767328235849');
INSERT INTO x VALUES (7, '41.246780548917246608934265057073076900048579756649769602488660179351587788197892095257027979113051775079905924990472069951828742350559917110289416201523653941731339141666097617614477426376799479821365070373247490598890520285155435501242427296281987676879064510605563522117334502131946383957407685328562874307957108543536378261847119286989184256009392692140821396916222386573424618796707564187152459973446833193743614720624765332006827171872712331032607870580880807058576154429597725560836582655488602546786785520452359711161305828045237044625934404295366273012300148250900116489718279757540843657039519736455668388572899273464839528462223812926410544976290646668870192676914370659142463304861500879195867873346447316374869974900582948166687948531910220128160490935170837209017355954301127162240133341813847180541');
INSERT INTO x VALUES (8, '22.862977375646110045361670561177818139082238721442691850491173190000619222046296383571431877856442345505931635735363450488731186880557789439424987680284612480261693386095598289519783790826332183796775862215503493910816035128476952347072320869461206895223935484838130924268616681347949695029657753251443811448783435000569829291535036468240771401957519222523032235686030017496209956550934543164421459898155836108824017735809352580723262896259290484291175350770265895317482371895188221452083719817251845416195168686335127805092334984596224320638378502008767433534450949989322562311171685891891122105437154553106840103473941148230953978989145470651955269817951560544095229079088083494695756914405635176899994279484466773598435268700064279990885608144109747858515514066444373797446449729058958270758597627587968112958');
INSERT INTO x VALUES (9, '17.820358481980064387183481028572263407130633079314879566896470101569251997264841660326428805413719418277889123643557369421967068805165885825106611310020187894256310674762734896979157570968168599492401269694048046876387337971177513661006711375440365724346137980004810780215236524986274043416621637509807126148966029923572853117418545426960105154053049098579812135003711132897895016476695223444397389521434633067499404903493027304737402519428197015899833229473322655155458942323004249812974150129789653469524573801259946118454333405580647485894435301530550214095993989552176497867244278699359917247910082169086524111229983698975613609318418313798992088206507831757327320958918656453341769110558376097374227592021075267882222057385413453949580066342977546145482215220982989992069525148522710254796105001938615214263');
COMMIT;
BEGIN;
INSERT INTO x VALUES (0, 'NaN');
INSERT INTO x VALUES (1, '4.930660740129727276654889314296515979425461685461970306647398411855044094312185293195497201658739777714943974003690119189101973212927970410047992001003936259467465542044528955416040460487922970233600641954269411521809500203864460110903973264337093883907933081597350982496469748131390809569321256206859934619579029279954574676601709408712255490686948453752571699579252140062805776361984468580258289509013081691778727372026090522694670379557247829136504595898935235926069699309392675806881162434168418505908116911054206058735257796918687777716036307205415038158583184624809880157060625643069601549803887864772092583549388533013233603450097615537162442973385137488450178790573546382354482351187412256794374383453695483855501587939419102008302408157959291557415763034668013452188944554607063362933134950906875499201');
INSERT INTO x VALUES (2, '32.997769620388965086774969704518222090258389987679691893351902336370051104718852164011301929506188893338106627980171059175447833290713847317665944354651476245003161501753612545484635275306181777040447675475670149066399611203341262105766118892586541910243351018829302798733989560900125591073082441126709911019648451232244139674063434385451279378543163944005973452562993913383659295688375546058256196254319767218634546732685705517341998116744642480938405113447415486950667007645850519659606476727681944251201236366198374488204017630268083077471516734133869728427050843306716313813724061560369884508660845630727190444623729815564381063131729592825825486515070406390371638817503915214206586939112681762984038333298146999891250107667687034785493312416966635780188163871680959873288697497561452228182734430749066579749');
INSERT INTO x VALUES (3, '37.780331928743475574895606142114739140772838801045013007323050327909196792739138159615327729728110344767302636436234256468332011934881494997184865617793179255006442447189720642997935223133982347184994174261506212652322213673745795726283311685835974151422721233207287206894148660531800622455957268888702309499182978182878524951883775154983702898237404558813230370364953160102391101897560104513279410610948028599674950811462114131673380477843456965645417025376374320207504913806546872166094337441573669261285052323206348035827948287081776955945081345131570610652073053464020209215624179904586956137079321655773178387441622685682721151900601340680061607114354850640946256225260430676099781727317540719923791064452012925902993317349390523278687089530234444415688602090547516647302454865526291471706301790881694022223');
INSERT INTO x VALUES (4, '24.726676547286224970759328746582840552419566534667446425423046931401641497155587075591229106937829957279943690528061985864558314570189069764367933957499905044566413640017549478921384160584906257607957223101377816440084188042395098536074479064548620374152344954289432050971466476174493306432228880930006524504974367146536665170956555486181410864034862861231267121149652317599303804477688621597163730470970207231328339082779056152481480926452142005969020950341307977091850953883445808399574256295803245530993204179747743812544604144379381347499056545148243304041538981954204310612049423688645476667184129189153715486929216331980316967699254518020077226689317148303152585009031597809279387172427408557115400021035692880631275593381822805377317270568779655383061987766693697518921188619814204902583361096973421134004');
INSERT INTO x VALUES (5, '8.814750626578650238811431417807018895270298639823442501111235973209197727215795256506525221092818797578008152140054383421240180435087611869193019443372556081555311825248667278358330916098378127100899126895012782320751838528480712942601038190627182482614147263228588284866661508052724762701223357327343090598060805245853527435948381893458352744679795853650453594546267600486696643924152372736774331080527157374379043696696647158270918245668579680394279565181670004245143555617589138267976417280970718829942998800499312890580011246294669585429723974582350357991472101919333996770115834067969654217063942059882195268353998096891812525364797586486311202350700339609637274043915687880562465121559531284337603363356183320193656553931871200575467929714875483123706358278876389849119105053294688326141759401230994901405');
INSERT INTO x VALUES (6, '-1.328484003982869642690619298690906747763234110040562640557173509402512757735587333095924652711056556491908059708986413635120656426593745303715671199761364516107844087845783714418487426723538440387069985879601248897538855843115404484229652166941838283489828419407478748732927617251897244190697443966424660881366993754577233476597163021768156814527570512834684713730559883782625870597080940193303268818336816535968869931456641949301731046034660616615392129109391145214470757259042172416816936479713743188047425796931722546185493217275537303458837771965375448968719169174136287532752370175863826715450565025635651343928205805494319778539652563499901671319955144823432132740582617949774638538594081514904904341299199113721131520557004571803778698005652464301037962272085633628653321081368256925971558076970172779715');
INSERT INTO x VALUES (7, '17.913249188669140643510654105014358282516966474257460687880559542190804665566625978925406311113121982595279826214959603627387555578965653325278444455875162277940655989601428868642914577248262147833499137348602966573601719040813549936948178463592211685237720748377879836890106515699728652218324794927458352954247096536337594789471529493944292143186953509162522579060020018226817623648563806559917579317916242706559131476179714031602207057714677845347616752450567251644277767418397621490301286115159509360375419599968738067461569666699939732107480135216621373057421990702923042287910730395998082514702629760389192370666675364405730936537832803383367187639209534697198515928978064543150195911463663617683085348965065679311986715357338675515370634753254774665197233934933271954463040729779956682570415317734489164385');
INSERT INTO x VALUES (8, '9.929264914121995501917993119394933531225401243275938207624866270551448544301376913376130982251708700134720886862945040266148728213253651323129942781577143957084726727561987639140151337848818195806259935747329665025823709044567138449084349729747202164413995795609659711723455165142329822773177102845804114214340046404641970845707372809306219463962664551623665322610139794354769767829380018857313559373283673392337954610346290037758389035140213224696023751541663171574697035012610534455189013755134090933979479069288110010954211669067225249755249337768792642303351914884187159646984708862430789018895140670365476746734456807215043628059581947593694929159076346249490593187993386780521089745819640214783614157516171005086731241769146397577246387886107367648843380733370112546792442909347322732196805316614555689762');
INSERT INTO x VALUES (9, '7.739283354261751283625223433456284905560931805428759681411970457812279544250432389511382263439324085689734710188041049046660480575958686859942980599595036769090747781359217248301544587434077376812293034848418204834388504169166350770257248896025815531248627658465029806509131631454856186387892627989218208026727504548130018922325585619738185507999433763118148418722504204066578294826264005398891049629199412773138457218976050467479292777172717500219850781664314597312411301296201533610562886229900497272268364496763758868455934979903774531992886483396489868888731578355541611359130188566524240259770918423445785338175040098706500034487703124623745259139247432324145633151895802637182446905097253961951018926565652497920605819785424451050191604602898777804133717341512568151920576684198443843944721398831404081859');
COMMIT;
BEGIN;
INSERT INTO x VALUES (0, 'NaN');
INSERT INTO x VALUES (1, '225561990715.277245515991117670624124484084762557459065170589803293759247930753528436379932442146759103295277479258327642314622036941865221478746258727236601688778946696303277607709407496616423493315166963938393760548678730128692212077086588682984700837334554241405763691119669847463520746595280034536307041368063462023793177898200220207765205127584303464304601759554817607633012272490650155253979182893585119965271975927569080191838676053084168631217591768468344106219831174026139608715965691941366334940196517120885214887008671956523579678156919416435031020452971977153991139145404842034138317592877675821045409772456977018293365238179815614004574330200783530118851005077771478448804470170641452481992602803877112958872108069738434946694089025321283178188028224338756015337492913115267362635647236447601252924834642796058');
INSERT INTO x VALUES (2, '9553718264533556311125292459627965006385666643531070061102266984368939757379.536714147420215784125170401370065894858487440153494392538261078415409784085960333028254155527328359894197540839556987826344995348426293585457768226283066583722499658006242709930685932246087653832230889613022921575445199055131152661556678809191264086381976922223866204038615136758192929883317207903579770917317641181652055458721731297347443662717939116561947785705140374908203404860090658919334137955075887697259604047657534191202566335372150375993361370075961180728155127447781364264047857624746079509591666068708743260905728661917791822925979235918475633100283148558978385583805341715868143937062092264994833222352433299015979561976964779350640064096690062929265992966564232453102431600199173711947391200249130712039686700111791790265309426741120465259677894665532560198051256215915373145226284270408649736509');
INSERT INTO x VALUES (3, '982718444846268846508445482774217796844461660819285525931206164100817251856409365450682.362683768066405322653747385034480250394145008573806022660379219602846285813744865438912887625784087005970975437905783802114553690522787857272953842288090141945268495451006273685577260054069522075046955466204804067271437138871789034722069934693546671607506851844248427950939791205412350536883779850165603116191193657054604569586553874805856647223849267039531773072343908345333155562072887754900969504551717514980465801806565999410206735831440712124661645970935112535081991606671600328471264697018198676317466846450405861359235297846597981143547119390922405594115478086038680663368675222949247096131378724350715530605691796680604309063173515781378545860473572389718345696107553363715518601596249508215455106779522851210398208919496668879040223859884166805448827948087400426315425231119801173387715922086154065273');
INSERT INTO x VALUES (4, '861542720105376650266753999919217194383259935058507531116.774511336660822591851369622743235084609149542494189385785321912210129989390054947787009383210009523204976629456268332186620016067379702483800883493431423160815760933380418976582725913410929214462739708321325884209636272001805871036779154087677637129248122540412937033791526383240502286607736226090213753913654673523613612439527815137888202973659987501649474772884055648603290154867585312925699571949539600328906295652872654314913539778815035321695215634102441494403825526533235061083947035338872599854931230001361227174477274708230470794066733245241594719912710139298949856243576688344051439047966427547889756037265151798639614843866387316916203238068277912991427278268083231579195846744438643659745041780103653332041031419793815914447232121937821142169172566753399257291244398531365781832297786941359729799400');
INSERT INTO x VALUES (5, '198021976607570296508.271597639984889464620426933601643322058775615235389194561064983706229795978402690473201671702614911129095149240715527556855309177671128442458698638704394974473956869419481315262823632891676087912529523219333012290621046361106033860210270638559271706082115529424772192777643046125905852037759566224116373416253787241195450409652089019290072319861181399387753223422998872180810295299831487867222464355713552301775702554189470264147325049133532522718679336524769566984150923939420759804463781082299907043016120177416779442865059261387111806785876531152192378576258351599534512031062777609734092707165605364139201322351960602280089186180302246827234844736393745487324460438448807241887783263546165171099497316415863122023114646876909575845860402164818094500541234974716577550807551946414081410743197768993152975501');
INSERT INTO x VALUES (6, '.000873076977206566818052116526263730226812004454463281371489634779519089200224205946321120805055212090024554381349223642352209212670470260295303361873760972918129853308169576675500721645609379420329169271088810484607337679253503247351324049221970104335289487989027621978310506220905131150125321713385148268584530413680037620544212746920563790371941626294733473967065607791756894237438288480748407449237446113996117912144587258434808327522518688617394025018756570740098795745692805352377041347367240475846033282850136270250633825482156304826383360291164928049344226886150285595932088884965511963310715773499733217615863523253012606066583814112265708693122563204149232245895551314975524172504103194858904869273185785182598234060315036187756490539352752560361560286717869643902435677448962235275054804452967413005');
INSERT INTO x VALUES (7, '176514565873872717825163931126806100435750.096278384530154766967061948052237623936423931849868926020451465515367348890410352640552194499619062823622476972850692557798609619250753020363520533767813563613425606228355802781302735485038377521515850536680425059519814786118919994914180918228654298075183514200191737597656810036850772127169441661576862538643715648802139886576391427423689320082366572297580054381937437005879583216745596935643579262248665490169331304003204939561361718554509909313409421397022626924406091551900222555950699170864234411017062042057683304265485826061096835531732950909546314722726990314852356462874701181085379772134121978510387397276859318242238150439474660772561390798432890789762504242822787017140808209820627435991445529404692793744568204608385843245177656436105160780897472099970336514833257055017279707999437302548655364559');
INSERT INTO x VALUES (8, '72941951052009383458167.300747500436981484566111756088702608000390737594784514635592222758882092500858797317505303492923829092720870826490477962201959426813271424853341826896270963213736922458746003100613943600855942721319226948714369219316345322636075285343544788982588956431405042577296229122673590336976893594798942025893296105815818487227300314490440902574022885833779324177053242170024559675073866612316965636832258283516275906085642459351367507561963945012828379111856700009391438637054015804558386733558956649061672420804826896303889067785497738203077050774825608647969196321506624991188638449047860249367840775936911749905927108478444112230174584693363226143549933224252679398881354887872642908328737917862751077365602631600279486028043329404269490375935308156815477700961014566228692743960491745353377403533037122586797765130');
INSERT INTO x VALUES (9, '661239032819374816.097553651299556484820492272269662685578275493609248662925676004753503494252951243895572437264999063878330704584509915845096232798927524470286655554736724913758600775591269525423912692080421094644542553026831758426157681271572808657664918053119324646138457659418857926209701677786068580819823633713337632456905824562235373422309621872998037966404189020165296080436871220718574009921789858751384547836431858428729570977259373272041837411903005303672798845573379758630607982213326716018594073712340609488043353995410508475153538231445235003980586600882223782814368245305160648543466496726973755388826656879616734762068443462618454921858705377028522664844761719759342490380417060255776725333319537746890406213693117052223545525717132695297770810635066731941724108167146710297146989770382041617889670713111888375717');
COMMIT;
BEGIN;
INSERT INTO x VALUES (0, '0');
INSERT INTO x VALUES (1, '85243.39540024977626076239847863600785982737155858270959890014613035727868293618673807776733416230953723818527101593495895350807775607346277892835514324320448949370623441059033804864158715021903312693889518990256881059434042443507529601095150710777634743301398926463888783847290873199395304998050753365215426971278237920063435565949203678024225270616295573678510929020831006146661747271783837653203039829647102027431761129518881525935216608429897041525858540380754759125150233053469999022855035');
INSERT INTO x VALUES (2, '-994877526002806872754342148749241.04353023451866590387054959174736129501310680280823383331007646306243540953499740615246583399296334239109936336446284803020643582102868247857009494139535009572740621288230740389545481395');
INSERT INTO x VALUES (3, '-60302029489319384367663884408085757480.2322712404088283093870869198708849258097125725036189625900174440196153781995220721511009855207486224837798752903681993777275846325950111427710563453217985216966456785944859989497422927661683538629473170704026975786513125842675604577233871570629808699803522400038975396500769162308448069085909755023233588510630417065084295051270219462289785473643946404281422516357503746700705970360169619852905053433235726497292406142332833');
INSERT INTO x VALUES (4, '5329378275943663322215245.24931765987630429629836382184742348353920297283690739124220773955591340709935970062776650204659187764581615597720798385015942389765692769739983054442503547211560297249686289665792078548480268091496050883021187158502798880896590227542729659940394038802461081290690995869705131152889309663639310553909874081663091069118126221594338242710530718836025225507189149221049928936955230868771875644038572888630664890573507822342998964954667474300944699078658989010257103569231493090050659723450626338923049035040974032671138430612839043269997482582763267536489504794826476836323549796385028155416935072959933315468068930689064483178204550825728947252440604703474049780550458442808479096492346910001692358508618202898514895453589357');
INSERT INTO x VALUES (5, '-652755630.43456071828048833552593835051449845484289562110789582081210403487973096161149072377955192388469356112505543620695003436531392789029513380101663750625024853263344909355177280161504414335005574882649025508632900995595004153086358670541462762210415346958050909878501048483523600711486406055424807840429541335391538322886495085448421556770991545781035298449067051916630343957356635391594362639819978677032855590055900561501350354631803808000307050416047072513406855040715556454205065332997338225626635780147287003130754254277103928406089109802521803537038957372612837169223905290912251006321930223154562110264217937');
INSERT INTO x VALUES (6, '0.0469370721950711508944806393077762204079964905145503836835397203739563036579760026190241480514409364');
INSERT INTO x VALUES (7, '-818934540071845742');
INSERT INTO x VALUES (8, '8496986223.64063724353165506167988570717591150432282238795309964705925283285060558038824227595710139960766584401003765241409149793494330798800');
INSERT INTO x VALUES (9, '054863480.34685027005508022756223282084742813020271603840941647350440860843570182437301045468670059279379903480024743452620396345637401505220786389930600883087012615993343976556472498552535317826554614696684732913955544753638726438705858481670766245958647367500212800073774509075408148134050353551558174813940258910304990570172170811882520915334358633');
COMMIT;
/* ****************************** */ /* * Create indices for faster checks */ /* ****************************** */ CREATE UNIQUE INDEX x ON x(x NULLS LAST, x NULLS LAST);
CREATE UNIQUE INDEX x ON x(x NULLS LAST, x NULLS LAST);
CREATE UNIQUE INDEX x ON x(x NULLS LAST, x NULLS LAST);
CREATE UNIQUE INDEX x ON x(x NULLS LAST, x NULLS LAST);
CREATE UNIQUE INDEX x ON x(x NULLS LAST);
CREATE UNIQUE INDEX x ON x(x NULLS LAST);
CREATE UNIQUE INDEX x ON x(x NULLS LAST);
CREATE UNIQUE INDEX x ON x(x NULLS LAST);
VACUUM ANALYZE num_exp_add;
VACUUM ANALYZE num_exp_sub;
VACUUM ANALYZE num_exp_div;
VACUUM ANALYZE num_exp_mul;
VACUUM ANALYZE num_exp_sqrt;
VACUUM ANALYZE num_exp_ln;
VACUUM ANALYZE num_exp_log10;
VACUUM ANALYZE num_exp_power_10_ln;
/* ****************************** */ /* * Now check the behaviour of the NUMERIC type */ /* ****************************** */ /* ****************************** */ /* * Addition check */ /* ****************************** */ DELETE FROM x;
INSERT INTO x SELECT x.x, x.x, x.x + x.x FROM x AS x, x AS x;
SELECT x.x, x.x, x.x, x.x FROM x AS x, x AS x WHERE x.x = x.x AND x.x = x.x AND x.x <> x.x;
DELETE FROM x;
INSERT INTO x SELECT x.x, x.x, ROUND(x.x + x.x, 10) FROM x AS x, x AS x;
SELECT x.x, x.x, x.x, ROUND(x.x, 10) AS x FROM x AS x, x AS x WHERE x.x = x.x AND x.x = x.x AND x.x <> ROUND(x.x, 10);
/* ****************************** */ /* * Subtraction check */ /* ****************************** */ DELETE FROM x;
INSERT INTO x SELECT x.x, x.x, x.x - x.x FROM x AS x, x AS x;
SELECT x.x, x.x, x.x, x.x FROM x AS x, x AS x WHERE x.x = x.x AND x.x = x.x AND x.x <> x.x;
DELETE FROM x;
INSERT INTO x SELECT x.x, x.x, ROUND(x.x - x.x, 40) FROM x AS x, x AS x;
SELECT x.x, x.x, x.x, ROUND(x.x, 40) FROM x AS x, x AS x WHERE x.x = x.x AND x.x = x.x AND x.x <> ROUND(x.x, 40);
/* ****************************** */ /* * Multiply check */ /* ****************************** */ DELETE FROM x;
INSERT INTO x SELECT x.x, x.x, x.x * x.x FROM x AS x, x AS x;
SELECT x.x, x.x, x.x, x.x FROM x AS x, x AS x WHERE x.x = x.x AND x.x = x.x AND x.x <> x.x;
DELETE FROM x;
INSERT INTO x SELECT x.x, x.x, ROUND(x.x * x.x, 30) FROM x AS x, x AS x;
SELECT x.x, x.x, x.x, ROUND(x.x, 30) AS x FROM x AS x, x AS x WHERE x.x = x.x AND x.x = x.x AND x.x <> ROUND(x.x, 30);
/* ****************************** */ /* * Division check */ /* ****************************** */ DELETE FROM x;
INSERT INTO x SELECT x.x, x.x, x.x / x.x FROM x AS x, x AS x WHERE x.x <> '0.0';
SELECT x.x, x.x, x.x, x.x FROM x AS x, x AS x WHERE x.x = x.x AND x.x = x.x AND x.x <> x.x;
DELETE FROM x;
INSERT INTO x SELECT x.x, x.x, ROUND(x.x / x.x, 80) FROM x AS x, x AS x WHERE x.x <> '0.0';
SELECT x.x, x.x, x.x, ROUND(x.x, 80) AS x FROM x AS x, x AS x WHERE x.x = x.x AND x.x = x.x AND x.x <> ROUND(x.x, 80);
/* ****************************** */ /* * Square root check */ /* ****************************** */ DELETE FROM x;
INSERT INTO x SELECT x, 0, SQRT(ABS(x)) FROM x;
SELECT x.x, x.x, x.x FROM x AS x, x AS x WHERE x.x = x.x AND x.x <> x.x;
/* ****************************** */ /* * Natural logarithm check */ /* ****************************** */ DELETE FROM x;
INSERT INTO x SELECT x, 0, LN(ABS(x)) FROM x WHERE x <> '0.0';
SELECT x.x, x.x, x.x FROM x AS x, x AS x WHERE x.x = x.x AND x.x <> x.x;
/* ****************************** */ /* * Logarithm base 10 check */ /* ****************************** */ DELETE FROM x;
INSERT INTO x SELECT x, 0, LOG(CAST('10' AS DECIMAL), ABS(x)) FROM x WHERE x <> '0.0';
SELECT x.x, x.x, x.x FROM x AS x, x AS x WHERE x.x = x.x AND x.x <> x.x;
/* ****************************** */ /* * POW(10, LN(value)) check */ /* ****************************** */ DELETE FROM x;
INSERT INTO x SELECT x, 0, POWER(CAST('10' AS DECIMAL), LN(ABS(ROUND(x, 1000)))) FROM x WHERE x <> '0.0';
SELECT x.x, x.x, x.x FROM x AS x, x AS x WHERE x.x = x.x AND x.x <> x.x;
/* Inputs close to overflow */ /* bc(1) results computed with a scale of 2700 and truncated to 4 decimal */ /* places. */ WITH x AS (SELECT * FROM (VALUES (0.12, -2829.8369, 58463948950011752465280493160293790845494328939320966633018493248607815580903065923369555885857984675501574162389726507612128133630191173383130639968378879506624785786843501848666498440326970769604109017960864573408272864266102690849952650095786874354625921641729880352858506454246180842452983243549491658464046163869265572232996388827878976066830374513768599285647145439771472435206769249126377164951470622827631950210853282324510655982757098065657709137845327135766013147354253426364240746381620690117663724329288646510198895137275207992825719846135857839292915100523542874885080351683587865157015032404901182924720371819942957083390475846809517968191151435281268695782594904484795360890092607679215675240583291240729468370895035823777914792823688291214492607109455017754453939895630226174304357121900605689015734289765672740769194115142607443713769825894380064727556869268488695795705030158832909348803019429370973064732712469794182891757241046263341655894972953512257981661670321890336672832647028099324621932563236459127918144141230217523147304565594514812518826936144181257723061181656522095236928347413997136815409159361412494284201481609684892562646522086577634100783077813105675590737823924220663206479031113753135119759722725207724879578900186075841393115040465401462266086907464970054073340036852442184414587772177753008511913377364966775792477387717262694468450099866775550614257191941835797445874557362115814601886902749237439492398087966544817154173072811937702110580330775581851211123491341435883319798273456296794954514173820352334127081705706502510709179711510240917772628308487366740741280043704807717608366220401933596364641284631036907635403895053036499618723044314773148779735006542501244942039455169872946018271985844759209768927953340447524637670938413827595013338859796135512187473850161303598087634723542727044978083220970836296653305188470017342167913572166172051819741354902582606590658382067039498769674611071582171914886494269818475850690414812481252963932223686078322390396586222238852602472958831686564971334200490182175112490433364675164900946902818404704835106260174052265784055642968397240262737313737007322288203637798365320295080314524864099419556398713380156353062937736280885716820226469419928595465390700629307079710611273715705695938635644841913194091407807776191951797748706106000922803167645881087385311847268311361092838264814899353459146959869764278464187826798546290981492648723002412475976344071283321798061003719251864595518596639432393032991023409676558943539937377229130132816883146259468718344018277257037013406135980469482324577407154032999045733141275895.3432), (1.2, 32908.8896, 58463467728170833376633133695001863276259293590926929026251227859007891876739460057725441400966420577009060860805883032969522911803372870882799865787473726926215148161529632590083389287080925059682489116446754279752928005457087175157581627230586554364417068189211136840990661174760199073702207450133797324318403866058202372178813998850887986769280847189341565507156189065295823921162851958925352114220880236114784962150135485415106748467247897246441194126125699204912883449386043559785865023459356275014504597646990160571664166410683323036984805434677654413174177920726210827006973855410386789516533036723888687725436216478665958434776205940192130053647653715221076841771578099896259902368829351569726536927952661429685419815305418450230567773264738536471211804481206474781470237730069753206249915908804615495060673071058534441654604668770343616386612119048579369195201590008082689834456232255266932976831478404670192731621439902738547169253818323045451045749609624500171633897705543164388470746657118050314064066768449450440405619135824055131398727045420324382226572368236570500391463795989258779677208133531636928003546809249007993065200108076924439703799231711400266122025052209803513232429907231051873161206025860851056337427740362763618748092029386371493898291580557004812947013231371383576580415676519066503391905962989205397824064923920045371823949776899815750413244195402085917098964452866825666226141169411712884994564949174271056284898570445214367063763956186792886147126466387576513166370247576466566827375268334148320298849218878848928271566491769458471357076035396330179659440244425914213309776100351793665960978678576150833311810944729586040624059867137538839913141142139636023129691775489034134511666020819676247950267220131499463010350308195762769192775344260909521732256844149916046793599150786757764962585268686580124987490115873389726527572428003433405659445349155536369077209682951123806333170190998931670309088422483075609203671527331975811507450670132060984691061148836994322505371265263690017938762760088575875666254883673433331627055180154954694693433502522592907190906966067656027637884202418119121728966267936832338377284832958974299187166554160783467156478554899314000348357280306042140481751668215838656488457943830180819301102535170705017482946779698265096226184239631924271857062033454725540956591929965181603262502135610768915716020374362368495244256420143645126927013882334008435586481691725030031204304273292938132599127402133470745819213047706793887965197191137237066440328777206799072470374264316425913530947082957300047105685634407092811630672103242089966046839626911122.7149)) AS x) SELECT x, x, x, POWER(x, x) AS x, POWER(x, x) - x AS x FROM x;
/* inputs with 1000 decimal places */ /* bc(1) results computed with a scale of 2000 and rounded to 1000 decimal */ /* places */ WITH x AS (SELECT * FROM (VALUES (484990182159328900690402236933516249572671683638747490717351807610531884491845416923860371219625151551889257298200816555016472471293780254009492949585031653913930735918829139712249577547959394351523545901788627247613322896296041868431769047433229466634098452564756860190085118463828382895145244362033728480588969626012192733802377468089120757046364393407262957242230928854711898925295251902007136232994524624903257456111389508582206404271734668422903183500589303866613158037169610592539145461637447957948521714058034772237111009429638870236361143304703683377693378577075353794118557951847394763531830696578809001981568860219578880229402696449243344235099860421846016326538272155937175661905904288335499593232232926636205909086901191153907183842087577811871344870731324067822883041265129394268082883745408414994.8967939438561591657171240282983703914075472645212002662497023142663831371447287624846942598424990784971781730103682951722370983277124599054059027055336437808366784501932987082321905202623642371063626378290734289114618092750984153422293450048717769065428713836637664433167768445609659527458911187829232316677137895259433038764404970599325009178297626038331436654541552998098529141205301472138026818453893127265938030066392881979113522757891639646670670272542401773230506961559808927249585675430838495658225557294666522469887436551840596777627408780618586500922973500018513068499587683746133637919751545157547095670767246977244726331271787622126889459658539988980096764323712767863722912919120929339399753431689512753214200090670880647731689804555417871258907716687575767185444541243606329768784843125926070743277339790277626515824924290352180761378846035233155198504033292692893297993698953705472933411199778880561376633444249703838589180474329586470353212010427945060694794274109764269805332803290229, 1864.3702986939570026328504202935192533137907736189919154633800554877738455118081651650863235106905871352085850240570561347180517240105510505203972860921397909573687877993477806728098306202020229409548306695695574102950949468160529713610952021974630774784174851619325758380143625473386495586347322798415543385655090746985183329114860118551572428921774322172798724455202876781611633419444058398798142214904998877857425038669920064728855823072107227506485770367799671977282350083029452784747350395161797215115525867416898416360638482342253129160308632504217096916335590470843180746834864303790913372081974355613359678634194879425862536147988835528973291020680020540866655622823550861337486588647231688134992810403147262346312159819432914207194632564009749236609081399504118359354620598232725290537215007867979331582119891661859015726276335168158288396939655310210558566592649049602925182137256134162660116182293851038854455437841571331011002023088829768308520393956515509475418031437505751407687618234418262), (87190145885430429849953615409019208993240447426362428988181639909267773304254748257120061524000254226856815085523676417146197197996896030672521334101413071112068202429835905642444187493717977611730127126387257253646790849384975208460867137315507010888782632024640844766297185244443116696943912406389670302370461137850160539373600494054874979342373255280815156048999900951842673141766630630919020492255966628630634124452614590400422133958133100159154995520080124736657520969784129924799670552560034302960877087853678350801769339861812435411200669026902417951572668727488315537985378304242438181615160041688723201917323705450185975141141262578884689500612295576288125956289035673242989906973367691922065122033180281670221390667818909912035903387888639331486823729897326624516015340.0330856710565117793999512551468220085711713631167607285185762046751452975325645379302403715842570486302993296501788672462090620871511446272026693318239212657949496275318383141403236705902077406660768573015707706831878445598837931116223956945944726162551477136715847593742032488181481888084716920605114101902724395659898621880016853548602514706686907951229872573180602614761229992106144727082722940736406782659562775289407005631298246624198606031298081220736931229256511054595028182057216042683060059115371651410352645266000330509331097811566633211452233019461903115970558624057877018778178814946285827512359903934291318219271464841957435711594154280905473802599888081783098187210283997106131616471807951265003903143099667366508222327805543948921694362089860577380749774036318574113007382111997454202845559941557812813566442364810680529092880773126707073967537693927177460459341763934709686530005721141046645111784404932103241501569571235364365556796422998363930810983452790309019295181282099408260156, 1793.5767085750017553306932533574391150814202249805881581227430032600579405884415934520704053351781361105595296647510475380766428668443641914861849764330704062323054023252886955844207807229267936432730818329225450152491146839618683772020068682795388746108876393249306737841247788224204701299467519965182171772253974884845661168860422489046657965359832930382114760565628765599962013955588754803194908990025689040598990346417563277021386852342928910383706995866844541160576254266641602065102228267316550706943783591722246885978355472097314691737807509436806788803362444745551013400341861820755594413819894154786253014501454443272120342005711761286524843010157182464200556865694401941794983935172457481497909987740544409272349152397774548604845897687504977786762391359552407068124283290504752932824699865504970420939586707791994870941813718246825616335675307740641350673558328821461530563823677144691877374809441673507467507447891562257806191361453045937798278733402269265623588493124129181374135958668436774), (93936642222690597390233191619858485419795942047468396309991947772747208870873993801669373075421461116465960407843923269693395211616591453397070258466704654943689268224479477016161636938138334729982904232438440955361656138189836032891825113139184685132178764873033678116450665758561650355252211196676137179184043639278410827092182700922151290703747496962700158844772453483316974221113826173404445159281421213715669245417896170368554410830320000019029956317336703559699859949692222685614036912057150632902650913831404804982509990655560731349634628713944739168096272097122388116038119844786988276635032016787352796502360718569977397214936366251320294621522016.6483354941025384161536675750898007896744690911429670830432784905421638721478353275821072200938900938046264210604940707974410950770029535636602548377806284157951164875821446035013896786653932045182167021839184824627082391478016195098055107001433336586881395912782883663046617432598969149948351689103230162742769845955320418573803127107923535948653168889411316007796459064267436246637115946581149511513369842911210359447262641996566147462977170742544980481275049898092152042927981394239266559286915303786701737610786594006685748456635797125029722684151298695274097006242412384086302106763844070230264910503179385988626477852818174114043927841085089058972074427820150462261941575665882880501074676800316585217150509780489224388148722603385921057007086785238310735038314861960410473809826927329368597558806004392175746233568789445929554890241140656324160187253042639339549705859147930476532359840809944163908006480881926041259363654863689570520534301207043189181147254153307163555433328278834311658232337, 1510.4332713542154696529645934345554302578243896764921637693542962119938599884313210100957753316832762996428481801312323020427109678979117469716796746760060470871840325255146954580681101106876674367471955788143763250819168311353856748872452260808797135108102729064040463343792765872545182299889360257515315869180266759715933989413256377582681707188367254513700731642913479683031478361835565783219287780434673712341147656477670848734998849030451414278832848680301511646182446524915091598080243532068451726548537866633622180283865668708517173065893429240665300584705585310049892047293928733753369421499719516009692095913169665213597158441636480707309244604139865130782756488091268094213446272360006907802989573582755585110277620911226015342778471352130366770729972784317323917141031824334355639769512749560550167491709646539950725523461943580211843652293561678342656010571108219244870234329176123205423872844099992204896411752620881541000940129833754169391528449211839693800724450201835161044717173715867437)) AS x) SELECT TRIM_SCALE(LN(CAST(x AS DECIMAL)) - x) AS x FROM x;
/* Tests for LOG() (base 10) */ /* input very small, exact result known */ WITH x AS (SELECT '1e-' || x FROM x AS x) SELECT x, LOG(CAST(x AS DECIMAL)) FROM x;
/* input very large, exact result known */ WITH x AS (SELECT '1e' || x FROM x AS x) SELECT x, LOG(CAST(x AS DECIMAL)) FROM x;
/* NUMEROLOGY */ /* Test various combinations of numeric types and functions. */ /* numeric literals */ SELECT 37;
SELECT 0 AS x;
SELECT 1071;
/* cases near int4 overflow */ SELECT 2147483647;
SELECT 2147483648;
SELECT 0 AS x;
SELECT 0 AS x;
SELECT 2147483647;
SELECT 2147483648;
SELECT -2147483648;
SELECT -2147483649;
SELECT -0 AS x;
SELECT -0 AS x;
SELECT -2147483648;
SELECT -2147483649;
/* cases near int8 overflow */ SELECT 9223372036854775807;
SELECT 9223372036854775808;
SELECT 0 AS x;
SELECT 0 AS x;
SELECT 9223372036854775807;
SELECT 9223372036854775808;
SELECT -9223372036854775808;
SELECT -9223372036854775809;
SELECT -0 AS x;
SELECT -0 AS x;
SELECT -9223372036854775808;
SELECT -9223372036854775809;
/* error cases */ SELECT 123 AS x;
SELECT "x";
SELECT 0. AS x;
SELECT 0.0 AS x;
SELECT 0.0 AS x;
SELECT 0.0e1 AS x;
SELECT 0.0e;
SELECT 0.0e+ AS x;
PREPARE p1 AS SELECT $1a;
PREPARE p1 AS SELECT $2147483648;
SELECT "x";
SELECT 1 AS x;
SELECT "x";
SELECT 0 AS x;
SELECT 1 AS x;
SELECT 0 AS x;
SELECT "x";
SELECT 1 AS x;
SELECT "x";
/* underscores */ SELECT 1 AS x;
SELECT 1 AS x;
SELECT 518979583;
SELECT 0 AS x;
SELECT 0.000 AS x;
BEGIN FOR i IN 1_001..1_003 LOOP     RAISE NOTICE 'i = %', i;
/* error cases */ SELECT x;
SELECT 100 AS x;
SELECT 100 AS x;
SELECT x.5;
PREPARE p1 AS SELECT $0_1;
/* Test implicit type conversions */ /* This fails for Postgres v6.1 (and earlier?) */ /*  so let's try explicit conversions for now - tgl 97/05/07 */ CREATE TABLE x (x DOUBLE);
INSERT INTO x (x) SELECT FLOAT8(x) FROM x;
INSERT INTO x (x) SELECT FLOAT8(x) FROM x;
SELECT x FROM x ORDER BY x NULLS LAST;
/* int4 */ CREATE TABLE x (x INT);
INSERT INTO x (x) SELECT INT4(x) FROM x WHERE (x > -2147483647) AND (x < 2147483647);
INSERT INTO x (x) SELECT INT4(x) FROM x;
SELECT x FROM x ORDER BY x NULLS LAST;
/* int2 */ CREATE TABLE x (x SMALLINT);
INSERT INTO x (x) SELECT INT2(x) FROM x WHERE (x >= -32767) AND (x <= 32767);
INSERT INTO x (x) SELECT INT2(x) FROM x WHERE (x >= -32767) AND (x <= 32767);
SELECT x FROM x ORDER BY x NULLS LAST;
/* Group-by combinations */ CREATE TABLE x (x INT, x INT, x DOUBLE);
INSERT INTO x SELECT 1, (-x.x), (-x.x) FROM x AS x, x AS x;
INSERT INTO x SELECT 2, x.x, x.x FROM x AS x, x AS x;
SELECT DISTINCT x AS x FROM x ORDER BY 1 NULLS LAST;
SELECT x AS x, MAX(x) AS x, MIN(x) AS x FROM x GROUP BY x ORDER BY x NULLS LAST, x NULLS LAST, x NULLS LAST;
/* GROUP BY a result column name is not legal per SQL92, but we accept it */ /* anyway (if the name is not the name of any column exposed by FROM). */ SELECT x AS x, MAX(x) AS x, MIN(x) AS x FROM x GROUP BY x ORDER BY x NULLS LAST, x NULLS LAST, x NULLS LAST;
SELECT x AS x, (MAX(x) + 1) AS x, (MIN(x) - 1) AS x FROM x GROUP BY x ORDER BY x NULLS LAST, x NULLS LAST;
SELECT x AS x, MAX(x) + MIN(x) AS x, MIN(x) - 1 AS x FROM x GROUP BY x ORDER BY x NULLS LAST, x NULLS LAST;
DROP TABLE x;
DROP TABLE x;
DROP TABLE x;
DROP TABLE x;
SET x = 'warning' /* Test for pg_get_object_address */ /* Clean up in case a prior regression run failed */;
DROP ROLE IF EXISTS regress_addr_user;
RESET client_min_messages;
CREATE USER regress_addr_user;
/* Test generic object addressing/identification functions */ CREATE SCHEMA x.x;
SET x = 'addr_nsp';
CREATE FOREIGN DATA WRAPPER addr_fdw;
CREATE SERVER addr_fserv FOREIGN DATA WRAPPER addr_fdw;
CREATE TEXT SEARCH DICTIONARY addr_ts_dict (template=simple);
CREATE TEXT SEARCH CONFIGURATION addr_ts_conf (copy=english);
CREATE TEXT SEARCH TEMPLATE addr_ts_temp (lexize=dsimple_lexize);
CREATE TEXT SEARCH PARSER addr_ts_prs     (start = prsd_start, gettoken = prsd_nexttoken, end = prsd_end, lextypes = prsd_lextype);
CREATE TABLE x.x (x SERIAL PRIMARY KEY CONSTRAINT x CHECK (x > 0), x TEXT DEFAULT 'hello');
CREATE TABLE x.x (x INT PRIMARY KEY) WITH (PARTITIONED_BY=RANGE(x));
CREATE VIEW x.x AS SELECT * FROM x.x;
CREATE MATERIALIZED VIEW x.x AS SELECT * FROM x.x;
CREATE TYPE addr_nsp.gencomptype AS (a int);
CREATE TYPE addr_nsp.genenum AS ENUM ('one', 'two');
CREATE FOREIGN TABLE addr_nsp.genftable (a int) SERVER addr_fserv;
CREATE AGGREGATE addr_nsp.genaggr(int4) (sfunc = int4pl, stype = int4);
CREATE DOMAIN addr_nsp.gendomain AS int4 CONSTRAINT domconstr CHECK (value > 0);
CREATE TRIGGER t BEFORE INSERT ON addr_nsp.gentable FOR EACH ROW EXECUTE PROCEDURE addr_nsp.trig();
CREATE POLICY genpol ON addr_nsp.gentable;
CREATE PROCEDURE x.x(x) LANGUAGE SQL AS $$ $$;
CREATE SERVER "integer" FOREIGN DATA WRAPPER addr_fdw;
CREATE USER MAPPING FOR regress_addr_user SERVER "integer";
ALTER DEFAULT PRIVILEGES FOR ROLE regress_addr_user IN SCHEMA public GRANT ALL ON TABLES TO regress_addr_user;
ALTER DEFAULT PRIVILEGES FOR ROLE regress_addr_user REVOKE DELETE ON TABLES FROM regress_addr_user;
SET x = 'ERROR' /* suppress warning that depends on wal_level */;
CREATE PUBLICATION addr_pub FOR TABLE addr_nsp.gentable;
CREATE PUBLICATION addr_pub_schema FOR TABLES IN SCHEMA addr_nsp;
RESET client_min_messages;
CREATE SUBSCRIPTION regress_addr_sub CONNECTION '' PUBLICATION bar WITH (connect = false, slot_name = NONE);
CREATE STATISTICS addr_nsp.gentable_stat ON a, b FROM addr_nsp.gentable;
/* test some error cases */ SELECT PG_GET_OBJECT_ADDRESS('stone', '{}', '{}');
SELECT PG_GET_OBJECT_ADDRESS('table', '{}', '{}');
SELECT PG_GET_OBJECT_ADDRESS('table', '{NULL}', '{}');
BEGIN FOR objtype IN VALUES ('toast table'), ('index column'), ('sequence column'),         ('toast table column'), ('view column'), ('materialized view column')     LOOP         BEGIN             PERFORM pg_get_object_address(objtype, '{one}', '{}');
COMMIT;
COMMIT;
/* miscellaneous other errors */ SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
BEGIN FOR objtype IN VALUES         ('table'), ('index'), ('sequence'), ('view'),         ('materialized view'), ('foreign table'),         ('table column'), ('foreign table column'),         ('aggregate'), ('function'), ('procedure'), ('type'), ('cast'),         ('table constraint'), ('domain constraint'), ('conversion'), ('default value'),         ('operator'), ('operator class'), ('operator family'), ('rule'), ('trigger'),         ('text search parser'), ('text search dictionary'),         ('text search template'), ('text search configuration'),         ('policy'), ('user mapping'), ('default acl'), ('transform'),         ('operator of access method'), ('function of access method'),         ('publication namespace'), ('publication relation')     LOOP         FOR names IN VALUES ('{eins}'), ('{addr_nsp, zwei}'), ('{eins, zwei, drei}')         LOOP             FOR args IN VALUES ('{}'), ('{integer}')             LOOP                 BEGIN                     PERFORM pg_get_object_address(objtype, names, args);
COMMIT;
COMMIT;
/* these object types cannot be qualified names */ SELECT PG_GET_OBJECT_ADDRESS('language', '{one}', '{}');
SELECT PG_GET_OBJECT_ADDRESS('language', '{one,two}', '{}');
SELECT PG_GET_OBJECT_ADDRESS('large object', '{123}', '{}');
SELECT PG_GET_OBJECT_ADDRESS('large object', '{123,456}', '{}');
SELECT PG_GET_OBJECT_ADDRESS('large object', '{blargh}', '{}');
SELECT PG_GET_OBJECT_ADDRESS('schema', '{one}', '{}');
SELECT PG_GET_OBJECT_ADDRESS('schema', '{one,two}', '{}');
SELECT PG_GET_OBJECT_ADDRESS('role', '{one}', '{}');
SELECT PG_GET_OBJECT_ADDRESS('role', '{one,two}', '{}');
SELECT PG_GET_OBJECT_ADDRESS('database', '{one}', '{}');
SELECT PG_GET_OBJECT_ADDRESS('database', '{one,two}', '{}');
SELECT PG_GET_OBJECT_ADDRESS('tablespace', '{one}', '{}');
SELECT PG_GET_OBJECT_ADDRESS('tablespace', '{one,two}', '{}');
SELECT PG_GET_OBJECT_ADDRESS('foreign-data wrapper', '{one}', '{}');
SELECT PG_GET_OBJECT_ADDRESS('foreign-data wrapper', '{one,two}', '{}');
SELECT PG_GET_OBJECT_ADDRESS('server', '{one}', '{}');
SELECT PG_GET_OBJECT_ADDRESS('server', '{one,two}', '{}');
SELECT PG_GET_OBJECT_ADDRESS('extension', '{one}', '{}');
SELECT PG_GET_OBJECT_ADDRESS('extension', '{one,two}', '{}');
SELECT PG_GET_OBJECT_ADDRESS('event trigger', '{one}', '{}');
SELECT PG_GET_OBJECT_ADDRESS('event trigger', '{one,two}', '{}');
SELECT PG_GET_OBJECT_ADDRESS('access method', '{one}', '{}');
SELECT PG_GET_OBJECT_ADDRESS('access method', '{one,two}', '{}');
SELECT PG_GET_OBJECT_ADDRESS('publication', '{one}', '{}');
SELECT PG_GET_OBJECT_ADDRESS('publication', '{one,two}', '{}');
SELECT PG_GET_OBJECT_ADDRESS('subscription', '{one}', '{}');
SELECT PG_GET_OBJECT_ADDRESS('subscription', '{one,two}', '{}');
/* - */ /* - Cleanup resources */ /* - */ DROP FOREIGN DATA WRAPPER addr_fdw CASCADE;
DROP PUBLICATION addr_pub;
DROP PUBLICATION addr_pub_schema;
DROP SUBSCRIPTION regress_addr_sub;
DROP SCHEMA x.x CASCADE;
DROP OWNED BY regress_addr_user;
DROP USER regress_addr_user;
/* Checks for invalid objects */ /* Keep this list in the same order as getObjectIdentityParts() */ /* in objectaddress.c. */ WITH x AS (SELECT * FROM (VALUES (CAST('pg_class' AS REGCLASS), 0, 0) /* no relation */, (CAST('pg_class' AS REGCLASS), CAST('pg_class' AS REGCLASS), 100) /* no column for relation */, (CAST('pg_proc' AS REGCLASS), 0, 0) /* no function */, (CAST('pg_type' AS REGCLASS), 0, 0) /* no type */, (CAST('pg_cast' AS REGCLASS), 0, 0) /* no cast */, (CAST('pg_collation' AS REGCLASS), 0, 0) /* no collation */, (CAST('pg_constraint' AS REGCLASS), 0, 0) /* no constraint */, (CAST('pg_conversion' AS REGCLASS), 0, 0) /* no conversion */, (CAST('pg_attrdef' AS REGCLASS), 0, 0) /* no default attribute */, (CAST('pg_language' AS REGCLASS), 0, 0) /* no language */, (CAST('pg_largeobject' AS REGCLASS), 0, 0) /* no large object, no error */, (CAST('pg_operator' AS REGCLASS), 0, 0) /* no operator */, (CAST('pg_opclass' AS REGCLASS), 0, 0) /* no opclass, no need to check for no access method */, (CAST('pg_opfamily' AS REGCLASS), 0, 0) /* no opfamily */, (CAST('pg_am' AS REGCLASS), 0, 0) /* no access method */, (CAST('pg_amop' AS REGCLASS), 0, 0) /* no AM operator */, (CAST('pg_amproc' AS REGCLASS), 0, 0) /* no AM proc */, (CAST('pg_rewrite' AS REGCLASS), 0, 0) /* no rewrite */, (CAST('pg_trigger' AS REGCLASS), 0, 0) /* no trigger */, (CAST('pg_namespace' AS REGCLASS), 0, 0) /* no schema */, (CAST('pg_statistic_ext' AS REGCLASS), 0, 0) /* no statistics */, (CAST('pg_ts_parser' AS REGCLASS), 0, 0) /* no TS parser */, (CAST('pg_ts_dict' AS REGCLASS), 0, 0) /* no TS dictionary */, (CAST('pg_ts_template' AS REGCLASS), 0, 0) /* no TS template */, (CAST('pg_ts_config' AS REGCLASS), 0, 0) /* no TS configuration */, (CAST('pg_authid' AS REGCLASS), 0, 0) /* no role */, (CAST('pg_auth_members' AS REGCLASS), 0, 0) /* no role membership */, (CAST('pg_database' AS REGCLASS), 0, 0) /* no database */, (CAST('pg_tablespace' AS REGCLASS), 0, 0) /* no tablespace */, (CAST('pg_foreign_data_wrapper' AS REGCLASS), 0, 0) /* no FDW */, (CAST('pg_foreign_server' AS REGCLASS), 0, 0) /* no server */, (CAST('pg_user_mapping' AS REGCLASS), 0, 0) /* no user mapping */, (CAST('pg_default_acl' AS REGCLASS), 0, 0) /* no default ACL */, (CAST('pg_extension' AS REGCLASS), 0, 0) /* no extension */, (CAST('pg_event_trigger' AS REGCLASS), 0, 0) /* no event trigger */, (CAST('pg_parameter_acl' AS REGCLASS), 0, 0) /* no parameter ACL */, (CAST('pg_policy' AS REGCLASS), 0, 0) /* no policy */, (CAST('pg_publication' AS REGCLASS), 0, 0) /* no publication */, (CAST('pg_publication_namespace' AS REGCLASS), 0, 0) /* no publication namespace */, (CAST('pg_publication_rel' AS REGCLASS), 0, 0) /* no publication relation */, (CAST('pg_subscription' AS REGCLASS), 0, 0) /* no subscription */, (CAST('pg_transform' AS REGCLASS), 0, 0) /* no transformation */) AS x) SELECT ROW(PG_IDENTIFY_OBJECT(x.x, x.x, x.x)) AS x, ROW(PG_IDENTIFY_OBJECT_AS_ADDRESS(x.x, x.x, x.x)) AS x, PG_DESCRIBE_OBJECT(x.x, x.x, x.x) AS x FROM x ORDER BY x.x NULLS LAST, x.x NULLS LAST, x.x NULLS LAST;
/* OID */ CREATE TABLE x (x OID);
INSERT INTO x (x) VALUES ('1234');
INSERT INTO x (x) VALUES ('1235');
INSERT INTO x (x) VALUES ('987');
INSERT INTO x (x) VALUES ('-1040');
INSERT INTO x (x) VALUES ('99999999');
INSERT INTO x (x) VALUES ('5     ');
INSERT INTO x (x) VALUES ('   10  ');
/* leading/trailing hard tab is also allowed */ INSERT INTO x (x) VALUES ('	  15 	  ');
/* bad inputs */ INSERT INTO x (x) VALUES ('');
INSERT INTO x (x) VALUES ('    ');
INSERT INTO x (x) VALUES ('asdfasd');
INSERT INTO x (x) VALUES ('99asdfasd');
INSERT INTO x (x) VALUES ('5    d');
INSERT INTO x (x) VALUES ('    5d');
INSERT INTO x (x) VALUES ('5    5');
INSERT INTO x (x) VALUES (' - 500');
INSERT INTO x (x) VALUES ('32958209582039852935');
INSERT INTO x (x) VALUES ('-23582358720398502385');
SELECT * FROM x;
/* Also try it with non-error-throwing API */ SELECT PG_INPUT_IS_VALID('1234', 'oid');
SELECT PG_INPUT_IS_VALID('01XYZ', 'oid');
SELECT * FROM x;
SELECT PG_INPUT_IS_VALID('9999999999', 'oid');
SELECT * FROM x;
/* While we're here, check oidvector as well */ SELECT PG_INPUT_IS_VALID(' 1 2  4 ', 'oidvector');
SELECT PG_INPUT_IS_VALID('01 01XYZ', 'oidvector');
SELECT * FROM x;
SELECT PG_INPUT_IS_VALID('01 9999999999', 'oidvector');
SELECT * FROM x;
SELECT x.* FROM x AS x WHERE x.x = 1234;
SELECT x.* FROM x AS x WHERE x.x <> '1234';
SELECT x.* FROM x AS x WHERE x.x <= '1234';
SELECT x.* FROM x AS x WHERE x.x < '1234';
SELECT x.* FROM x AS x WHERE x.x >= '1234';
SELECT x.* FROM x AS x WHERE x.x > '1234';
DROP TABLE x;
x AS x;
x AS x;
x AS x;
BEGIN for fk in select * from pg_get_catalog_foreign_keys()   loop     raise notice 'checking % % => % %',       fk.fktable, fk.fkcols, fk.pktable, fk.pkcols;
x := ARRAY_LENGTH(x.x);
x := 'SELECT ctid';
if fk.is_array then       cmd := cmd || ' FROM (SELECT ctid';
x := x || ', unnest(' || QUOTE_IDENT(x.x[x]);
x := x || ') as ' || QUOTE_IDENT(x.x[x]);
x := x || ' FROM ' || CAST(x.x AS TEXT) || ') fk WHERE ';
if fk.is_opt then       for i in 1 .. nkeys loop         cmd := cmd || quote_ident(fk.fkcols[i]) || ' != 0 AND ';
x := x || 'NOT EXISTS(SELECT 1 FROM ' || CAST(x.x AS TEXT) || ' pk WHERE ';
x := x || 'pk.' || QUOTE_IDENT(x.x[x]);
x := x || ' = fk.' || QUOTE_IDENT(x.x[x]);
x := x || ')';
/* OPR_SANITY */ /* Sanity checks for common errors in making operator/procedure system tables: */ /* pg_operator, pg_proc, pg_cast, pg_conversion, pg_aggregate, pg_am, */ /* pg_amop, pg_amproc, pg_opclass, pg_opfamily, pg_index. */ /* Every test failure in this file should be closely inspected. */ /* The description of the failing test should be read carefully before */ /* adjusting the expected output.  In most cases, the queries should */ /* not find *any* matching entries. */ /* NB: we assume the oidjoins test will have caught any dangling links, */ /* that is OID or REGPROC fields that are not zero and do not match some */ /* row in the linked-to table.  However, if we want to enforce that a link */ /* field can't be 0, we have to check it here. */ /* NB: run this test earlier than the create_operator test, because */ /* that test creates some bogus operators... */ /* **************** pg_proc **************** */ /* Look for illegal values in pg_proc fields. */ SELECT x.x, x.x FROM x AS x WHERE x.x = 0 OR x.x = 0 OR x.x < 0 OR x.x < 0 OR x.x > x.x OR ARRAY_LOWER(x.x, 1) <> 0 OR ARRAY_UPPER(x.x, 1) <> x.x - 1 OR CAST(0 AS OID) = ANY(x.x) OR x <= 0 OR CASE WHEN x THEN x <= 0 ELSE x <> 0 END OR NOT x IN ('f', 'a', 'w', 'p') OR NOT x IN ('i', 's', 'v') OR NOT x IN ('s', 'r', 'u');
SELECT x.x, x.x FROM x AS x WHERE (x = '' OR x = '-') AND x IS NULL;
/* proretset should only be set for normal functions */ SELECT x.x, x.x FROM x AS x WHERE x AND x <> 'f';
/* this might change in future, but there will probably never be many. */ SELECT x.x, x.x FROM x AS x WHERE x ORDER BY 1 NULLS LAST;
/* pronargdefaults should be 0 iff proargdefaults is null */ SELECT x.x, x.x FROM x AS x WHERE (x <> 0) <> (NOT x IS NULL);
/* probin should be non-empty for C functions, null everywhere else */ SELECT x.x, x.x FROM x AS x WHERE x = 13 AND (x IS NULL OR x = '' OR x = '-');
SELECT x.x, x.x FROM x AS x WHERE x <> 13 AND NOT x IS NULL;
/* Look for conflicting proc definitions (same names and input datatypes). */ /* (This test should be dead code now that we have the unique index */ /* pg_proc_proname_args_nsp_index, but I'll leave it in anyway.) */ SELECT x.x, x.x, x.x, x.x FROM x AS x, x AS x WHERE x.x <> x.x AND x.x = x.x AND x.x = x.x AND x.x = x.x;
/* Look for uses of different type OIDs in the argument/result type fields */ /* for different aliases of the same built-in function. */ /* This indicates that the types are being presumed to be binary-equivalent, */ /* or that the built-in function is prepared to deal with different types. */ /* That's not wrong, necessarily, but we make lists of all the types being */ /* so treated.  Note that the expected output of this part of the test will */ /* need to be modified whenever new pairs of types are made binary-equivalent, */ /* or when new polymorphic built-in functions are added! */ /* Note: ignore aggregate functions here, since they all point to the same */ /* dummy built-in function.  Likewise, ignore range and multirange constructor */ /* functions. */ SELECT DISTINCT CAST(x.x AS REGTYPE), CAST(x.x AS REGTYPE) FROM x AS x, x AS x WHERE x.x <> x.x AND x.x = x.x AND x.x = 12 AND x.x = 12 AND x.x <> 'a' AND x.x <> 'a' AND NOT x.x LIKE range\\_constructor_ AND NOT x.x LIKE range\\_constructor_ AND NOT x.x LIKE multirange\\_constructor_ AND NOT x.x LIKE multirange\\_constructor_ AND (x.x < x.x) ORDER BY 1 NULLS LAST, 2 NULLS LAST;
SELECT DISTINCT CAST(x.x[-1] AS REGTYPE), CAST(x.x[-1] AS REGTYPE) FROM x AS x, x AS x WHERE x.x <> x.x AND x.x = x.x AND x.x = 12 AND x.x = 12 AND x.x <> 'a' AND x.x <> 'a' AND NOT x.x LIKE range\\_constructor_ AND NOT x.x LIKE range\\_constructor_ AND NOT x.x LIKE multirange\\_constructor_ AND NOT x.x LIKE multirange\\_constructor_ AND (x.x[-1] < x.x[-1]) ORDER BY 1 NULLS LAST, 2 NULLS LAST;
SELECT DISTINCT CAST(x.x[0] AS REGTYPE), CAST(x.x[0] AS REGTYPE) FROM x AS x, x AS x WHERE x.x <> x.x AND x.x = x.x AND x.x = 12 AND x.x = 12 AND x.x <> 'a' AND x.x <> 'a' AND NOT x.x LIKE range\\_constructor_ AND NOT x.x LIKE range\\_constructor_ AND NOT x.x LIKE multirange\\_constructor_ AND NOT x.x LIKE multirange\\_constructor_ AND (x.x[0] < x.x[0]) ORDER BY 1 NULLS LAST, 2 NULLS LAST;
SELECT DISTINCT CAST(x.x[1] AS REGTYPE), CAST(x.x[1] AS REGTYPE) FROM x AS x, x AS x WHERE x.x <> x.x AND x.x = x.x AND x.x = 12 AND x.x = 12 AND x.x <> 'a' AND x.x <> 'a' AND (x.x[1] < x.x[1]) ORDER BY 1 NULLS LAST, 2 NULLS LAST;
SELECT DISTINCT CAST(x.x[2] AS REGTYPE), CAST(x.x[2] AS REGTYPE) FROM x AS x, x AS x WHERE x.x <> x.x AND x.x = x.x AND x.x = 12 AND x.x = 12 AND x.x <> 'a' AND x.x <> 'a' AND (x.x[2] < x.x[2]) ORDER BY 1 NULLS LAST, 2 NULLS LAST;
SELECT DISTINCT CAST(x.x[3] AS REGTYPE), CAST(x.x[3] AS REGTYPE) FROM x AS x, x AS x WHERE x.x <> x.x AND x.x = x.x AND x.x = 12 AND x.x = 12 AND x.x <> 'a' AND x.x <> 'a' AND (x.x[3] < x.x[3]) ORDER BY 1 NULLS LAST, 2 NULLS LAST;
SELECT DISTINCT CAST(x.x[4] AS REGTYPE), CAST(x.x[4] AS REGTYPE) FROM x AS x, x AS x WHERE x.x <> x.x AND x.x = x.x AND x.x = 12 AND x.x = 12 AND x.x <> 'a' AND x.x <> 'a' AND (x.x[4] < x.x[4]) ORDER BY 1 NULLS LAST, 2 NULLS LAST;
SELECT DISTINCT CAST(x.x[5] AS REGTYPE), CAST(x.x[5] AS REGTYPE) FROM x AS x, x AS x WHERE x.x <> x.x AND x.x = x.x AND x.x = 12 AND x.x = 12 AND x.x <> 'a' AND x.x <> 'a' AND (x.x[5] < x.x[5]) ORDER BY 1 NULLS LAST, 2 NULLS LAST;
SELECT DISTINCT CAST(x.x[6] AS REGTYPE), CAST(x.x[6] AS REGTYPE) FROM x AS x, x AS x WHERE x.x <> x.x AND x.x = x.x AND x.x = 12 AND x.x = 12 AND x.x <> 'a' AND x.x <> 'a' AND (x.x[6] < x.x[6]) ORDER BY 1 NULLS LAST, 2 NULLS LAST;
/* Look for functions that return type "internal" and do not have any */ /* "internal" argument.  Such a function would be a security hole since */ /* it might be used to call an internal function from an SQL command. */ /* As of 7.3 this query should find only internal_in, which is safe because */ /* it always throws an error when called. */ SELECT x.x, x.x FROM x AS x WHERE x.x = CAST('internal' AS REGTYPE) AND NOT CAST('internal' AS REGTYPE) = ANY(x.x);
/* Look for functions that return a polymorphic type and do not have any */ /* polymorphic argument.  Calls of such functions would be unresolvable */ /* at parse time.  As of 9.6 this query should find only some input functions */ /* and GiST support functions associated with these pseudotypes. */ SELECT x.x, x.x FROM x AS x WHERE x.x IN (CAST('anyelement' AS REGTYPE), CAST('anyarray' AS REGTYPE), CAST('anynonarray' AS REGTYPE), CAST('anyenum' AS REGTYPE)) AND NOT (CAST('anyelement' AS REGTYPE) = ANY(x.x) OR CAST('anyarray' AS REGTYPE) = ANY(x.x) OR CAST('anynonarray' AS REGTYPE) = ANY(x.x) OR CAST('anyenum' AS REGTYPE) = ANY(x.x) OR CAST('anyrange' AS REGTYPE) = ANY(x.x) OR CAST('anymultirange' AS REGTYPE) = ANY(x.x)) ORDER BY 2 NULLS LAST;
/* anyrange and anymultirange are tighter than the rest, can only resolve */ /* from each other */ SELECT x.x, x.x FROM x AS x WHERE x.x IN (CAST('anyrange' AS REGTYPE), CAST('anymultirange' AS REGTYPE)) AND NOT (CAST('anyrange' AS REGTYPE) = ANY(x.x) OR CAST('anymultirange' AS REGTYPE) = ANY(x.x)) ORDER BY 2 NULLS LAST;
/* similarly for the anycompatible family */ SELECT x.x, x.x FROM x AS x WHERE x.x IN (CAST('anycompatible' AS REGTYPE), CAST('anycompatiblearray' AS REGTYPE), CAST('anycompatiblenonarray' AS REGTYPE)) AND NOT (CAST('anycompatible' AS REGTYPE) = ANY(x.x) OR CAST('anycompatiblearray' AS REGTYPE) = ANY(x.x) OR CAST('anycompatiblenonarray' AS REGTYPE) = ANY(x.x) OR CAST('anycompatiblerange' AS REGTYPE) = ANY(x.x)) ORDER BY 2 NULLS LAST;
SELECT x.x, x.x FROM x AS x WHERE x.x = CAST('anycompatiblerange' AS REGTYPE) AND NOT CAST('anycompatiblerange' AS REGTYPE) = ANY(x.x) ORDER BY 2 NULLS LAST;
/* text should be used instead, because cstring lacks suitable casts. */ /* As of 9.6 this query should find only cstring_out and cstring_send. */ /* However, we must manually exclude shell_in, which might or might not be */ /* rejected by the EXISTS clause depending on whether there are currently */ /* any shell types. */ SELECT x.x, x.x FROM x AS x WHERE CAST('cstring' AS REGTYPE) = ANY(x.x) AND NOT EXISTS(SELECT 1 FROM x WHERE x = x.x) AND NOT EXISTS(SELECT 1 FROM x WHERE x = x.x) AND x.x <> CAST('shell_in(cstring)' AS REGPROCEDURE) ORDER BY 1 NULLS LAST;
/* Likewise, look for functions that return cstring and aren't datatype output */ /* functions nor typmod output functions. */ /* As of 9.6 this query should find only cstring_in and cstring_recv. */ /* However, we must manually exclude shell_out. */ SELECT x.x, x.x FROM x AS x WHERE x.x = CAST('cstring' AS REGTYPE) AND NOT EXISTS(SELECT 1 FROM x WHERE x = x.x) AND NOT EXISTS(SELECT 1 FROM x WHERE x = x.x) AND x.x <> CAST('shell_out(void)' AS REGPROCEDURE) ORDER BY 1 NULLS LAST;
/* Check for length inconsistencies between the various argument-info arrays. */ SELECT x.x, x.x FROM x AS x WHERE NOT x IS NULL AND ARRAY_LENGTH(x) < ARRAY_LENGTH(x);
SELECT x.x, x.x FROM x AS x WHERE NOT x IS NULL AND ARRAY_LENGTH(x) < ARRAY_LENGTH(x);
SELECT x.x, x.x FROM x AS x WHERE NOT x IS NULL AND ARRAY_LENGTH(x) < ARRAY_LENGTH(x);
SELECT x.x, x.x FROM x AS x WHERE NOT x IS NULL AND NOT x IS NULL AND ARRAY_LENGTH(x) <> ARRAY_LENGTH(x);
SELECT x.x, x.x FROM x AS x WHERE NOT x IS NULL AND NOT x IS NULL AND ARRAY_LENGTH(x) <> ARRAY_LENGTH(x);
SELECT x.x, x.x FROM x AS x WHERE NOT x IS NULL AND NOT x IS NULL AND ARRAY_LENGTH(x) <> ARRAY_LENGTH(x);
/* Check that proallargtypes matches proargtypes */ SELECT x.x, x.x, x.x, x.x, x.x FROM x AS x WHERE NOT x IS NULL AND ARRAY(SELECT EXPLODE(x)) <> ARRAY(SELECT x[x] FROM x AS x WHERE x IS NULL OR x[x] IN ('i', 'b', 'v'));
/* Check that all and only those functions with a variadic type have */ /* a variadic argument. */ SELECT CAST(x AS REGPROCEDURE), x, x FROM x WHERE (NOT x IS NULL AND 'v' = ANY(x)) IS DISTINCT FROM (x <> 0);
/* Check for prosupport functions with the wrong signature */ SELECT x.x, x.x, x.x, x.x FROM x AS x, x AS x WHERE x.x = x.x AND (x.x <> CAST('internal' AS REGTYPE) OR x.x OR x.x <> 1 OR x.x[-1] <> CAST('internal' AS REGTYPE));
/* Insist that all built-in pg_proc entries have descriptions */ SELECT x.x, x.x FROM x AS x LEFT JOIN x AS x ON x.x = x.x AND x.x = x.x AND x.x = 0 WHERE x.x IS NULL AND x.x <= 9999;
/* Check that functions without argument are not marked as leakproof. */ SELECT CAST(x.x AS REGPROCEDURE) FROM x AS x JOIN x AS x ON x = x.x WHERE x = 'pg_catalog' AND x AND x = 0 ORDER BY 1 NULLS LAST;
/* Check that all immutable functions are marked parallel safe */ SELECT x.x, x.x FROM x AS x WHERE x = 'i' AND x = 'u';
/* **************** pg_cast **************** */ /* Catch bogus values in pg_cast columns (other than cases detected by */ /* oidjoins test). */ SELECT * FROM x AS x WHERE x = 0 OR x = 0 OR NOT x IN ('e', 'a', 'i') OR NOT x IN ('f', 'b', 'i');
/* Check that castfunc is nonzero only for cast methods that need a function, */ /* and zero otherwise */ SELECT * FROM x AS x WHERE (x = 'f' AND x = 0) OR (x IN ('b', 'i') AND x <> 0);
/* Look for casts to/from the same type that aren't length coercion functions. */ /* (We assume they are length coercions if they take multiple arguments.) */ /* Such entries are not necessarily harmful, but they are useless. */ SELECT * FROM x AS x WHERE x = x AND x = 0;
SELECT x.* FROM x AS x, x AS x WHERE x.x = x.x AND x.x < 2 AND x = x;
/* Look for cast functions that don't have the right signature.  The */ /* argument and result types in pg_proc must be the same as, or binary */ /* compatible with, what it says in pg_cast. */ /* As a special case, we allow casts from CHAR(n) that use functions */ /* declared to take TEXT.  This does not pass the binary-coercibility test */ /* because CHAR(n)-to-TEXT normally invokes rtrim().  However, the results */ /* are the same, so long as the function is one that ignores trailing blanks. */ SELECT x.* FROM x AS x, x AS x WHERE x.x = x.x AND (x.x < 1 OR x.x > 3 OR NOT (BINARY_COERCIBLE(x.x, x.x[-1]) OR (x.x = CAST('character' AS REGTYPE) AND x.x[-1] = CAST('text' AS REGTYPE))) OR NOT BINARY_COERCIBLE(x.x, x.x));
SELECT x.* FROM x AS x, x AS x WHERE x.x = x.x AND ((x.x > 1 AND x.x[0] <> CAST('int4' AS REGTYPE)) OR (x.x > 2 AND x.x[1] <> CAST('bool' AS REGTYPE)));
/* Look for binary compatible casts that do not have the reverse */ /* direction registered as well, or where the reverse direction is not */ /* also binary compatible.  This is legal, but usually not intended. */ /* As of 7.4, this finds the casts from text and varchar to bpchar, because */ /* those are binary-compatible while the reverse way goes through rtrim(). */ /* As of 8.2, this finds the cast from cidr to inet, because that is a */ /* trivial binary coercion while the other way goes through inet_to_cidr(). */ /* As of 8.3, this finds the casts from xml to text, varchar, and bpchar, */ /* because those are binary-compatible while the reverse goes through */ /* texttoxml(), which does an XML syntax check. */ /* As of 9.1, this finds the cast from pg_node_tree to text, which we */ /* intentionally do not provide a reverse pathway for. */ SELECT CAST(x AS REGTYPE), CAST(x AS REGTYPE), x, x FROM x AS x WHERE x.x = 'b' AND NOT EXISTS(SELECT 1 FROM x AS x WHERE x.x = 'b' AND x.x = x.x AND x.x = x.x);
/* **************** pg_conversion **************** */ /* Look for illegal values in pg_conversion fields. */ SELECT x.x, x.x FROM x AS x WHERE x.x = 0 OR PG_ENCODING_TO_CHAR(x) = '' OR PG_ENCODING_TO_CHAR(x) = '';
/* Look for conprocs that don't have the expected signature. */ SELECT x.x, x.x, x.x, x.x FROM x AS x, x AS x WHERE x.x = x.x AND (x.x <> CAST('int4' AS REGTYPE) OR x.x OR x.x <> 6 OR x.x[-1] <> CAST('int4' AS REGTYPE) OR x.x[0] <> CAST('int4' AS REGTYPE) OR x.x[1] <> CAST('cstring' AS REGTYPE) OR x.x[2] <> CAST('internal' AS REGTYPE) OR x.x[3] <> CAST('int4' AS REGTYPE) OR x.x[4] <> CAST('bool' AS REGTYPE));
/* **************** pg_operator **************** */ /* Look for illegal values in pg_operator fields. */ SELECT x.x, x.x FROM x AS x WHERE (x.x <> 'b' AND x.x <> 'l') OR x.x = 0 OR x.x = 0;
/* Look for missing or unwanted operand types */ SELECT x.x, x.x FROM x AS x WHERE (x.x = 0 AND x.x <> 'l') OR (x.x <> 0 AND x.x = 'l') OR x.x = 0;
/* Look for conflicting operator definitions (same names and input datatypes). */ SELECT x.x, x.x, x.x, x.x FROM x AS x, x AS x WHERE x.x <> x.x AND x.x = x.x AND x.x = x.x AND x.x = x.x AND x.x = x.x;
/* Make a list of the names of operators that are claimed to be commutator */ /* pairs.  This list will grow over time, but before accepting a new entry */ /* make sure you didn't link the wrong operators. */ SELECT DISTINCT x.x AS x, x.x AS x FROM x AS x, x AS x WHERE x.x = x.x AND x.x <= x.x ORDER BY 1 NULLS LAST, 2 NULLS LAST;
/* Likewise for negator pairs. */ SELECT DISTINCT x.x AS x, x.x AS x FROM x AS x, x AS x WHERE x.x = x.x AND x.x <= x.x ORDER BY 1 NULLS LAST, 2 NULLS LAST;
/* A mergejoinable or hashjoinable operator must be binary, must return */ /* boolean, and must have a commutator (itself, unless it's a cross-type */ /* operator). */ SELECT x.x, x.x FROM x AS x WHERE (x.x OR x.x) AND NOT (x.x = 'b' AND x.x = CAST('bool' AS REGTYPE) AND x.x <> 0);
/* What's more, the commutator had better be mergejoinable/hashjoinable too. */ SELECT x.x, x.x, x.x, x.x FROM x AS x, x AS x WHERE x.x = x.x AND (x.x <> x.x OR x.x <> x.x);
/* Mergejoinable operators should appear as equality members of btree index */ /* opfamilies. */ SELECT x.x, x.x FROM x AS x WHERE x.x AND NOT EXISTS(SELECT 1 FROM x WHERE x = (SELECT x FROM x WHERE x = 'btree') AND x = x.x AND x = 3);
/* And the converse. */ SELECT x.x, x.x, x.x FROM x AS x, x AS x WHERE x = x.x AND x = (SELECT x FROM x WHERE x = 'btree') AND x = 3 AND NOT x.x;
/* Hashable operators should appear as members of hash index opfamilies. */ SELECT x.x, x.x FROM x AS x WHERE x.x AND NOT EXISTS(SELECT 1 FROM x WHERE x = (SELECT x FROM x WHERE x = 'hash') AND x = x.x AND x = 1);
/* And the converse. */ SELECT x.x, x.x, x.x FROM x AS x, x AS x WHERE x = x.x AND x = (SELECT x FROM x WHERE x = 'hash') AND NOT x.x;
/* Check that each operator defined in pg_operator matches its oprcode entry */ /* in pg_proc.  Easiest to do this separately for each oprkind. */ SELECT x.x, x.x, x.x, x.x FROM x AS x, x AS x WHERE x.x = x.x AND x.x = 'b' AND (x.x <> 2 OR NOT BINARY_COERCIBLE(x.x, x.x) OR NOT BINARY_COERCIBLE(x.x, x.x[-1]) OR NOT BINARY_COERCIBLE(x.x, x.x[0]));
SELECT x.x, x.x, x.x, x.x FROM x AS x, x AS x WHERE x.x = x.x AND x.x = 'l' AND (x.x <> 1 OR NOT BINARY_COERCIBLE(x.x, x.x) OR NOT BINARY_COERCIBLE(x.x, x.x[-1]) OR x.x <> 0);
/* If the operator is mergejoinable or hashjoinable, its underlying function */ /* should not be volatile. */ SELECT x.x, x.x, x.x, x.x FROM x AS x, x AS x WHERE x.x = x.x AND (x.x OR x.x) AND x.x = 'v';
/* If oprrest is set, the operator must return boolean, */ /* and it must link to a proc with the right signature */ /* to be a restriction selectivity estimator. */ /* The proc signature we want is: float8 proc(internal, oid, internal, int4) */ SELECT x.x, x.x, x.x, x.x FROM x AS x, x AS x WHERE x.x = x.x AND (x.x <> CAST('bool' AS REGTYPE) OR x.x <> CAST('float8' AS REGTYPE) OR x.x OR x.x <> 4 OR x.x[-1] <> CAST('internal' AS REGTYPE) OR x.x[0] <> CAST('oid' AS REGTYPE) OR x.x[1] <> CAST('internal' AS REGTYPE) OR x.x[2] <> CAST('int4' AS REGTYPE));
/* If oprjoin is set, the operator must be a binary boolean op, */ /* and it must link to a proc with the right signature */ /* to be a join selectivity estimator. */ /* The proc signature we want is: float8 proc(internal, oid, internal, int2, internal) */ /* (Note: the old signature with only 4 args is still allowed, but no core */ /* estimator should be using it.) */ SELECT x.x, x.x, x.x, x.x FROM x AS x, x AS x WHERE x.x = x.x AND (x.x <> 'b' OR x.x <> CAST('bool' AS REGTYPE) OR x.x <> CAST('float8' AS REGTYPE) OR x.x OR x.x <> 5 OR x.x[-1] <> CAST('internal' AS REGTYPE) OR x.x[0] <> CAST('oid' AS REGTYPE) OR x.x[1] <> CAST('internal' AS REGTYPE) OR x.x[2] <> CAST('int2' AS REGTYPE) OR x.x[3] <> CAST('internal' AS REGTYPE));
/* Insist that all built-in pg_operator entries have descriptions */ SELECT x.x, x.x FROM x AS x LEFT JOIN x AS x ON x.x = x.x AND x.x = x.x AND x.x = 0 WHERE x.x IS NULL AND x.x <= 9999;
/* Operators that are commutator pairs should have identical volatility */ /* and leakproofness markings on their implementation functions. */ SELECT x.x, x.x, x.x, x.x FROM x AS x, x AS x, x AS x, x AS x WHERE x.x = x.x AND x.x = x.x AND x.x = x.x AND (x.x <> x.x OR x.x <> x.x);
/* Likewise for negator pairs. */ SELECT x.x, x.x, x.x, x.x FROM x AS x, x AS x, x AS x, x AS x WHERE x.x = x.x AND x.x = x.x AND x.x = x.x AND (x.x <> x.x OR x.x <> x.x);
/* Btree comparison operators' functions should have the same volatility */ /* and leakproofness markings as the associated comparison support function. */ SELECT CAST(x.x AS REGPROCEDURE) AS x, x.x AS x, x.x AS x, CAST(x.x AS REGPROCEDURE) AS x, x.x AS x, x.x AS x FROM x AS x, x AS x, x AS x, x AS x, x AS x WHERE x.x = x.x AND x.x = x.x AND x.x = x.x AND x.x = (SELECT x FROM x WHERE x = 'btree') AND x.x = x.x AND x.x = x.x AND x.x = x.x AND x.x = 1 AND (x.x <> x.x OR x.x <> x.x) ORDER BY 1 NULLS LAST;
/* **************** pg_aggregate **************** */ /* Look for illegal values in pg_aggregate fields. */ SELECT x, CAST(x AS OID) FROM x AS x WHERE x = 0 OR x = 0 OR NOT x IN ('n', 'o', 'h') OR x < 0 OR (x = 'n' AND x > 0) OR NOT x IN ('r', 's', 'w') OR NOT x IN ('r', 's', 'w') OR x = 0 OR x < 0 OR x < 0;
/* Make sure the matching pg_proc entry is sensible, too. */ SELECT CAST(x.x AS OID), x.x FROM x AS x, x AS x WHERE x.x = x.x AND (x.x <> 'a' OR x.x OR x.x < x.x);
/* Make sure there are no prokind = PROKIND_AGGREGATE pg_proc entries without matches. */ SELECT x, x FROM x AS x WHERE x.x = 'a' AND NOT EXISTS(SELECT 1 FROM x AS x WHERE x.x = x.x);
/* If there is no finalfn then the output type must be the transtype. */ SELECT CAST(x.x AS OID), x.x FROM x AS x, x AS x WHERE x.x = x.x AND x.x = 0 AND x.x <> x.x;
/* Cross-check transfn against its entry in pg_proc. */ SELECT CAST(x.x AS OID), x.x, x.x, x.x FROM x AS x, x AS x, x AS x WHERE x.x = x.x AND x.x = x.x AND (x.x OR NOT (x.x = CASE WHEN x.x = 'n' THEN x.x + 1 ELSE GREATEST(x.x - x.x, 1) + 1 END) OR NOT BINARY_COERCIBLE(x.x, x.x) OR NOT BINARY_COERCIBLE(x.x, x.x[-1]) OR (x.x > 0 AND NOT BINARY_COERCIBLE(x.x[-1], x.x[0])) OR (x.x > 1 AND NOT BINARY_COERCIBLE(x.x[0], x.x[1])) OR (x.x > 2 AND NOT BINARY_COERCIBLE(x.x[1], x.x[2])) OR (x.x > 3 AND NOT BINARY_COERCIBLE(x.x[2], x.x[3])) OR /* we could carry the check further, but 4 args is enough for now */ (x.x > 4));
/* Cross-check finalfn (if present) against its entry in pg_proc. */ SELECT CAST(x.x AS OID), x.x, x.x, x.x FROM x AS x, x AS x, x AS x WHERE x.x = x.x AND x.x = x.x AND (x.x OR NOT BINARY_COERCIBLE(x.x, x.x) OR NOT BINARY_COERCIBLE(x.x, x.x[-1]) OR CASE WHEN x.x THEN x.x <> x.x + 1 ELSE x.x <> x.x + 1 END OR (x.x > 1 AND NOT BINARY_COERCIBLE(x.x[-1], x.x[0])) OR (x.x > 2 AND NOT BINARY_COERCIBLE(x.x[0], x.x[1])) OR (x.x > 3 AND NOT BINARY_COERCIBLE(x.x[1], x.x[2])) OR /* we could carry the check further, but 4 args is enough for now */ (x.x > 4));
/* If transfn is strict then either initval should be non-NULL, or */ /* input type should match transtype so that the first non-null input */ /* can be assigned as the state value. */ SELECT CAST(x.x AS OID), x.x, x.x, x.x FROM x AS x, x AS x, x AS x WHERE x.x = x.x AND x.x = x.x AND x.x AND x.x IS NULL AND NOT BINARY_COERCIBLE(x.x[-1], x.x);
/* Check for inconsistent specifications of moving-aggregate columns. */ SELECT x, CAST(x AS OID) FROM x AS x WHERE x <> 0 AND (x = 0 OR x = 0);
SELECT x, CAST(x AS OID) FROM x AS x WHERE x = 0 AND (x <> 0 OR x <> 0 OR x <> 0 OR x <> 0 OR NOT x IS NULL);
/* If there is no mfinalfn then the output type must be the mtranstype. */ SELECT CAST(x.x AS OID), x.x FROM x AS x, x AS x WHERE x.x = x.x AND x.x <> 0 AND x.x = 0 AND x.x <> x.x;
/* Cross-check mtransfn (if present) against its entry in pg_proc. */ SELECT CAST(x.x AS OID), x.x, x.x, x.x FROM x AS x, x AS x, x AS x WHERE x.x = x.x AND x.x = x.x AND (x.x OR NOT (x.x = CASE WHEN x.x = 'n' THEN x.x + 1 ELSE GREATEST(x.x - x.x, 1) + 1 END) OR NOT BINARY_COERCIBLE(x.x, x.x) OR NOT BINARY_COERCIBLE(x.x, x.x[-1]) OR (x.x > 0 AND NOT BINARY_COERCIBLE(x.x[-1], x.x[0])) OR (x.x > 1 AND NOT BINARY_COERCIBLE(x.x[0], x.x[1])) OR (x.x > 2 AND NOT BINARY_COERCIBLE(x.x[1], x.x[2])) OR /* we could carry the check further, but 3 args is enough for now */ (x.x > 3));
/* Cross-check minvtransfn (if present) against its entry in pg_proc. */ SELECT CAST(x.x AS OID), x.x, x.x, x.x FROM x AS x, x AS x, x AS x WHERE x.x = x.x AND x.x = x.x AND (x.x OR NOT (x.x = CASE WHEN x.x = 'n' THEN x.x + 1 ELSE GREATEST(x.x - x.x, 1) + 1 END) OR NOT BINARY_COERCIBLE(x.x, x.x) OR NOT BINARY_COERCIBLE(x.x, x.x[-1]) OR (x.x > 0 AND NOT BINARY_COERCIBLE(x.x[-1], x.x[0])) OR (x.x > 1 AND NOT BINARY_COERCIBLE(x.x[0], x.x[1])) OR (x.x > 2 AND NOT BINARY_COERCIBLE(x.x[1], x.x[2])) OR /* we could carry the check further, but 3 args is enough for now */ (x.x > 3));
/* Cross-check mfinalfn (if present) against its entry in pg_proc. */ SELECT CAST(x.x AS OID), x.x, x.x, x.x FROM x AS x, x AS x, x AS x WHERE x.x = x.x AND x.x = x.x AND (x.x OR NOT BINARY_COERCIBLE(x.x, x.x) OR NOT BINARY_COERCIBLE(x.x, x.x[-1]) OR CASE WHEN x.x THEN x.x <> x.x + 1 ELSE x.x <> x.x + 1 END OR (x.x > 1 AND NOT BINARY_COERCIBLE(x.x[-1], x.x[0])) OR (x.x > 2 AND NOT BINARY_COERCIBLE(x.x[0], x.x[1])) OR (x.x > 3 AND NOT BINARY_COERCIBLE(x.x[1], x.x[2])) OR /* we could carry the check further, but 4 args is enough for now */ (x.x > 4));
/* If mtransfn is strict then either minitval should be non-NULL, or */ /* input type should match mtranstype so that the first non-null input */ /* can be assigned as the state value. */ SELECT CAST(x.x AS OID), x.x, x.x, x.x FROM x AS x, x AS x, x AS x WHERE x.x = x.x AND x.x = x.x AND x.x AND x.x IS NULL AND NOT BINARY_COERCIBLE(x.x[-1], x.x);
/* mtransfn and minvtransfn should have same strictness setting. */ SELECT CAST(x.x AS OID), x.x, x.x, x.x, x.x, x.x FROM x AS x, x AS x, x AS x, x AS x WHERE x.x = x.x AND x.x = x.x AND x.x = x.x AND x.x <> x.x;
/* Check that all combine functions have signature */ /* combine(transtype, transtype) returns transtype */ SELECT x.x, x.x FROM x AS x, x AS x WHERE x.x = x.x AND (x.x <> 2 OR x.x <> x.x[-1] OR x.x <> x.x[0] OR NOT BINARY_COERCIBLE(x.x, x.x[-1]));
/* Check that no combine function for an INTERNAL transtype is strict. */ SELECT x.x, x.x FROM x AS x, x AS x WHERE x.x = x.x AND x.x = CAST('internal' AS REGTYPE) AND x.x;
/* serialize/deserialize functions should be specified only for aggregates */ /* with transtype internal and a combine function, and we should have both */ /* or neither of them. */ SELECT x, x, x, x FROM x WHERE (x <> 0 OR x <> 0) AND (x <> CAST('internal' AS REGTYPE) OR x = 0 OR x = 0 OR x = 0);
/* Check that aggregates which have the same transition function also have */ /* the same combine, serialization, and deserialization functions. */ /* While that isn't strictly necessary, it's fishy if they don't. */ SELECT x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x FROM x AS x, x AS x WHERE x.x < x.x AND x.x = x.x AND (x.x <> x.x OR x.x <> x.x OR x.x <> x.x);
/* Cross-check aggsortop (if present) against pg_operator. */ /* We expect to find entries for bool_and, bool_or, every, max, and min. */ SELECT DISTINCT x, x FROM x AS x, x AS x, x AS x WHERE x.x = x.x AND x.x = x.x ORDER BY 1 NULLS LAST, 2 NULLS LAST;
/* Check datatypes match */ SELECT CAST(x.x AS OID), x.x FROM x AS x, x AS x, x AS x WHERE x.x = x.x AND x.x = x.x AND (x <> 'b' OR x <> CAST('boolean' AS REGTYPE) OR x <> x.x[-1] OR x <> x.x[-1]);
/* Check operator is a suitable btree opfamily member */ SELECT CAST(x.x AS OID), x.x FROM x AS x, x AS x, x AS x WHERE x.x = x.x AND x.x = x.x AND NOT EXISTS(SELECT 1 FROM x WHERE x = (SELECT x FROM x WHERE x = 'btree') AND x = x.x AND x = x.x AND x = x.x);
/* Check correspondence of btree strategies and names */ SELECT DISTINCT x, x, x FROM x AS x, x AS x, x AS x, x AS x WHERE x.x = x.x AND x.x = x.x AND x = x.x AND x = (SELECT x FROM x WHERE x = 'btree') ORDER BY 1 NULLS LAST, 2 NULLS LAST;
/* For the same reason, built-in aggregates with default arguments are no good. */ SELECT x, x FROM x AS x WHERE x = 'a' AND NOT x IS NULL;
/* For the same reason, we avoid creating built-in variadic aggregates, except */ /* that variadic ordered-set aggregates are OK (since they have special syntax */ /* that is not subject to the misplaced ORDER BY issue). */ SELECT x.x, x FROM x AS x JOIN x AS x ON x.x = x.x WHERE x = 'a' AND x <> 0 AND x.x = 'n';
/* **************** pg_opfamily **************** */ /* Look for illegal values in pg_opfamily fields */ SELECT x.x FROM x AS x WHERE x.x = 0 OR x.x = 0;
/* Look for opfamilies having no opclasses.  While most validation of */ /* opfamilies is now handled by AM-specific amvalidate functions, that's */ /* driven from pg_opclass entries below, so an empty opfamily would not */ /* get noticed. */ SELECT x, x FROM x AS x WHERE NOT EXISTS(SELECT 1 FROM x WHERE x = x.x);
/* **************** pg_opclass **************** */ /* Look for illegal values in pg_opclass fields */ SELECT x.x FROM x AS x WHERE x.x = 0 OR x.x = 0 OR x.x = 0 OR x.x = 0;
/* opcmethod must match owning opfamily's opfmethod */ SELECT x.x, x.x FROM x AS x, x AS x WHERE x.x = x.x AND x.x <> x.x;
/* There should not be multiple entries in pg_opclass with opcdefault true */ /* and the same opcmethod/opcintype combination. */ SELECT x.x, x.x FROM x AS x, x AS x WHERE x.x <> x.x AND x.x = x.x AND x.x = x.x AND x.x AND x.x;
/* Ask access methods to validate opclasses */ /* (this replaces a lot of SQL-level checks that used to be done in this file) */ SELECT x, x FROM x WHERE NOT AMVALIDATE(x);
/* **************** pg_am **************** */ /* Look for illegal values in pg_am fields */ SELECT x.x, x.x FROM x AS x WHERE x.x = 0;
/* Check for index amhandler functions with the wrong signature */ SELECT x.x, x.x, x.x, x.x FROM x AS x, x AS x WHERE x.x = x.x AND x.x = 'i' AND (x.x <> CAST('index_am_handler' AS REGTYPE) OR x.x OR x.x <> 1 OR x.x[-1] <> CAST('internal' AS REGTYPE));
/* Check for table amhandler functions with the wrong signature */ SELECT x.x, x.x, x.x, x.x FROM x AS x, x AS x WHERE x.x = x.x AND x.x = 't' AND (x.x <> CAST('table_am_handler' AS REGTYPE) OR x.x OR x.x <> 1 OR x.x[-1] <> CAST('internal' AS REGTYPE));
/* **************** pg_amop **************** */ /* Look for illegal values in pg_amop fields */ SELECT x.x, x.x FROM x AS x WHERE x.x = 0 OR x.x = 0 OR x.x = 0 OR x.x = 0 OR x.x = 0 OR x.x < 1;
SELECT x.x, x.x FROM x AS x WHERE NOT ((x.x = 's' AND x.x = 0) OR (x.x = 'o' AND x.x <> 0));
/* amopmethod must match owning opfamily's opfmethod */ SELECT x.x, x.x FROM x AS x, x AS x WHERE x.x = x.x AND x.x <> x.x;
/* Make a list of all the distinct operator names being used in particular */ /* strategy slots.  This is a bit hokey, since the list might need to change */ /* in future releases, but it's an effective way of spotting mistakes such as */ /* swapping two operators within a family. */ SELECT DISTINCT x, x, x FROM x AS x LEFT JOIN x AS x ON x = x.x ORDER BY 1 NULLS LAST, 2 NULLS LAST, 3 NULLS LAST;
/* Check that all opclass search operators have selectivity estimators. */ /* This is not absolutely required, but it seems a reasonable thing */ /* to insist on for all standard datatypes. */ SELECT x.x, x.x, x.x, x.x FROM x AS x, x AS x WHERE x.x = x.x AND x.x = 's' AND (x.x = 0 OR x.x = 0);
/* Check that each opclass in an opfamily has associated operators, that is */ /* ones whose oprleft matches opcintype (possibly by coercion). */ SELECT x.x, x.x FROM x AS x WHERE NOT EXISTS(SELECT 1 FROM x AS x WHERE x.x = x.x AND BINARY_COERCIBLE(x.x, x.x));
/* Check that each operator listed in pg_amop has an associated opclass, */ /* that is one whose opcintype matches oprleft (possibly by coercion). */ /* Otherwise the operator is useless because it cannot be matched to an index. */ /* (In principle it could be useful to list such operators in multiple-datatype */ /* btree opfamilies, but in practice you'd expect there to be an opclass for */ /* every datatype the family knows about.) */ SELECT x.x, x.x, x.x FROM x AS x WHERE NOT EXISTS(SELECT 1 FROM x AS x WHERE x.x = x.x AND BINARY_COERCIBLE(x.x, x.x));
/* Operators that are primary members of opclasses must be immutable (else */ /* it suggests that the index ordering isn't fixed).  Operators that are */ /* cross-type members need only be stable, since they are just shorthands */ /* for index probe queries. */ SELECT x.x, x.x, x.x, x.x FROM x AS x, x AS x, x AS x WHERE x.x = x.x AND x.x = x.x AND x.x = x.x AND x.x <> 'i';
SELECT x.x, x.x, x.x, x.x FROM x AS x, x AS x, x AS x WHERE x.x = x.x AND x.x = x.x AND x.x <> x.x AND x.x = 'v';
/* **************** pg_amproc **************** */ /* Look for illegal values in pg_amproc fields */ SELECT x.x, x.x FROM x AS x WHERE x.x = 0 OR x.x = 0 OR x.x = 0 OR x.x < 0 OR x.x = 0;
/* Support routines that are primary members of opfamilies must be immutable */ /* (else it suggests that the index ordering isn't fixed).  But cross-type */ /* members need only be stable, since they are just shorthands */ /* for index probe queries. */ SELECT x.x, x.x, x.x FROM x AS x, x AS x WHERE x.x = x.x AND x.x = x.x AND x.x <> 'i';
SELECT x.x, x.x, x.x FROM x AS x, x AS x WHERE x.x = x.x AND x.x <> x.x AND x.x = 'v';
/* Almost all of the core distribution's Btree opclasses can use one of the */ /* two generic "equalimage" functions as their support function 4.  Look for */ /* opclasses that don't allow deduplication unconditionally here. */ /* Newly added Btree opclasses don't have to support deduplication.  It will */ /* usually be trivial to add support, though.  Note that the expected output */ /* of this part of the test will need to be updated when a new opclass cannot */ /* support deduplication (by using btequalimage). */ SELECT CAST(x.x AS REGPROC) AS x, x.x AS x, x.x AS x, CAST(x.x AS REGTYPE) AS x FROM x AS x JOIN x AS x ON x.x = x.x JOIN x AS x ON x.x = x.x LEFT JOIN x AS x ON x.x = x.x AND x.x = x.x AND x.x = 4 WHERE x.x = 'btree' AND x.x IS DISTINCT FROM CAST('btequalimage' AS REGPROC) ORDER BY 1 NULLS LAST, 2 NULLS LAST, 3 NULLS LAST;
/* **************** pg_index **************** */ /* Look for illegal values in pg_index fields. */ SELECT x, x FROM x WHERE x = 0 OR x = 0 OR x <= 0 OR x > 32;
/* oidvector and int2vector fields should be of length indnatts. */ SELECT x, x FROM x WHERE ARRAY_LOWER(x, 1) <> 0 OR ARRAY_UPPER(x, 1) <> x - 1 OR ARRAY_LOWER(x, 1) <> 0 OR ARRAY_UPPER(x, 1) <> x - 1 OR ARRAY_LOWER(x, 1) <> 0 OR ARRAY_UPPER(x, 1) <> x - 1 OR ARRAY_LOWER(x, 1) <> 0 OR ARRAY_UPPER(x, 1) <> x - 1;
/* Check that opclasses and collations match the underlying columns. */ /* (As written, this test ignores expression indexes.) */ SELECT CAST(x AS REGCLASS), CAST(x AS REGCLASS), x, CAST(x AS REGTYPE), x FROM (SELECT x, x, EXPLODE(x) AS x, EXPLODE(x) AS x, EXPLODE(x) AS x FROM x) AS x, x AS x, x AS x WHERE x.x = x AND x.x = x AND x.x = x AND (NOT BINARY_COERCIBLE(x, x) OR x <> x);
/* For system catalogs, be even tighter: nearly all indexes should be */ /* exact type matches not binary-coercible matches.  At this writing */ /* the only exception is an OID index on a regproc column. */ SELECT CAST(x AS REGCLASS), CAST(x AS REGCLASS), x, CAST(x AS REGTYPE), x FROM (SELECT x, x, EXPLODE(x) AS x, EXPLODE(x) AS x, EXPLODE(x) AS x FROM x WHERE x < 16384) AS x, x AS x, x AS x WHERE x.x = x AND x.x = x AND x.x = x AND (x <> x OR x <> x) ORDER BY 1 NULLS LAST;
/* Check for system catalogs with collation-sensitive ordering.  This is not */ /* a representational error in pg_index, but simply wrong catalog design. */ /* It's bad because we expect to be able to clone template0 and assign the */ /* copy a different database collation.  It would especially not work for */ /* shared catalogs. */ SELECT x, x, x FROM x AS x, x AS x WHERE x.x = x AND x.x < 16384 AND x.x <> 'v' AND /* we don't care about columns in views */ x <> 0 AND x <> (SELECT x FROM x WHERE x = 'C');
/* Double-check that collation-sensitive indexes have "C" collation, too. */ SELECT CAST(x AS REGCLASS), CAST(x AS REGCLASS), x, x FROM (SELECT x, x, EXPLODE(x) AS x, EXPLODE(x) AS x FROM x WHERE x < 16384) AS x WHERE x <> 0 AND x <> (SELECT x FROM x WHERE x = 'C');
SET x = TRUE /* PARTITION_AGGREGATE */ /* Test partitionwise aggregation on partitioned tables */ /* Note: to ensure plan stability, it's a good idea to make the partitions of */ /* any one partitioned table in this test all have different numbers of rows. */ /* Enable partitionwise aggregate, which by default is disabled. */;
SET x = TRUE /* Enable partitionwise join, which by default is disabled. */;
SET x = 0 /* Disable parallel plans. */;
SET x = off /* Disable incremental sort, which can influence selected plans due to fuzz factor. */;
/* Tests for list partitioned tables. */ CREATE TABLE x (x INT, x INT, x TEXT, x INT) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN ('0000', '0001', '0002', '0003', '0004');
CREATE TABLE x PARTITION OF x FOR VALUES IN ('0005', '0006', '0007', '0008');
CREATE TABLE x PARTITION OF x FOR VALUES IN ('0009', '0010', '0011');
INSERT INTO x SELECT x % 20, x % 30, TIME_TO_STR(x % 12, 'FM0000'), x % 30 FROM x AS x;
ANALYZE x;
SELECT x, SUM(x), AVG(x), COUNT(*), MIN(x), MAX(x) FROM x GROUP BY x HAVING AVG(x) < 15 ORDER BY 1 NULLS LAST, 2 NULLS LAST, 3 NULLS LAST;
SELECT x, SUM(x), AVG(x), COUNT(*), MIN(x), MAX(x) FROM x GROUP BY x HAVING AVG(x) < 15 ORDER BY 1 NULLS LAST, 2 NULLS LAST, 3 NULLS LAST;
/* Check with multiple columns in GROUP BY */ EXPLAIN (COSTS OFF) SELECT a, c, count(*) FROM pagg_tab GROUP BY a, c;
/* Check with multiple columns in GROUP BY, order in GROUP BY is reversed */ EXPLAIN (COSTS OFF) SELECT a, c, count(*) FROM pagg_tab GROUP BY c, a;
/* Check with multiple columns in GROUP BY, order in target-list is reversed */ EXPLAIN (COSTS OFF) SELECT c, a, count(*) FROM pagg_tab GROUP BY a, c;
/* Test when input relation for grouping is dummy */ EXPLAIN (COSTS OFF) SELECT c, sum(a) FROM pagg_tab WHERE 1 = 2 GROUP BY c;
SELECT x, SUM(x) FROM x WHERE 1 = 2 GROUP BY x;
EXPLAIN (COSTS OFF) SELECT c, sum(a) FROM pagg_tab WHERE c = 'x' GROUP BY c;
SELECT x, SUM(x) FROM x WHERE x = 'x' GROUP BY x;
SET x = FALSE /* Test GroupAggregate paths by disabling hash aggregates. */;
/* When GROUP BY clause matches full aggregation is performed for each partition. */ EXPLAIN (COSTS OFF) SELECT c, sum(a), avg(b), count(*) FROM pagg_tab GROUP BY 1 HAVING avg(d) < 15 ORDER BY 1, 2, 3;
SELECT x, SUM(x), AVG(x), COUNT(*) FROM x GROUP BY 1 HAVING AVG(x) < 15 ORDER BY 1 NULLS LAST, 2 NULLS LAST, 3 NULLS LAST;
SELECT x, SUM(x), AVG(x), COUNT(*) FROM x GROUP BY 1 HAVING AVG(x) < 15 ORDER BY 1 NULLS LAST, 2 NULLS LAST, 3 NULLS LAST;
/* Test partitionwise grouping without any aggregates */ EXPLAIN (COSTS OFF) SELECT c FROM pagg_tab GROUP BY c ORDER BY 1;
SELECT x FROM x GROUP BY x ORDER BY 1 NULLS LAST;
EXPLAIN (COSTS OFF) SELECT a FROM pagg_tab WHERE a < 3 GROUP BY a ORDER BY 1;
SELECT x FROM x WHERE x < 3 GROUP BY x ORDER BY 1 NULLS LAST;
RESET enable_hashagg;
/* ROLLUP, partitionwise aggregation does not apply */ EXPLAIN (COSTS OFF) SELECT c, sum(a) FROM pagg_tab GROUP BY rollup(c) ORDER BY 1, 2;
/* JOIN query */ CREATE TABLE x (x INT, x INT) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (0) TO (10);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (10) TO (20);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (20) TO (30);
CREATE TABLE x (x INT, x INT) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (0) TO (10);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (10) TO (20);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (20) TO (30);
INSERT INTO x SELECT x % 30, x % 20 FROM x AS x;
INSERT INTO x SELECT x % 20, x % 30 FROM x AS x;
ANALYZE x;
ANALYZE x;
SELECT x.x, SUM(x.x), COUNT(*) FROM x AS x, x AS x WHERE x.x = x.x GROUP BY x.x ORDER BY 1 NULLS LAST, 2 NULLS LAST, 3 NULLS LAST;
SELECT x.x, SUM(x.x), COUNT(x) FROM x AS x, x AS x WHERE x.x = x.x GROUP BY x.x ORDER BY 1 NULLS LAST, 2 NULLS LAST, 3 NULLS LAST;
/* GROUP BY having other matching key */ EXPLAIN (COSTS OFF) SELECT t2.y, sum(t1.y), count(*) FROM pagg_tab1 t1, pagg_tab2 t2 WHERE t1.x = t2.y GROUP BY t2.y ORDER BY 1, 2, 3;
EXPLAIN (COSTS OFF) SELECT t1.y, sum(t1.x), count(*) FROM pagg_tab1 t1, pagg_tab2 t2 WHERE t1.x = t2.y GROUP BY t1.y HAVING avg(t1.x) > 10 ORDER BY 1, 2, 3;
SELECT x.x, SUM(x.x), COUNT(*) FROM x AS x, x AS x WHERE x.x = x.x GROUP BY x.x HAVING AVG(x.x) > 10 ORDER BY 1 NULLS LAST, 2 NULLS LAST, 3 NULLS LAST;
RESET enable_hashagg;
/* Check with LEFT/RIGHT/FULL OUTER JOINs which produces NULL values for */ /* aggregation */ /* LEFT JOIN, should produce partial partitionwise aggregation plan as */ /* GROUP BY is on nullable column */ EXPLAIN (COSTS OFF) SELECT b.y, sum(a.y) FROM pagg_tab1 a LEFT JOIN pagg_tab2 b ON a.x = b.y GROUP BY b.y ORDER BY 1 NULLS LAST;
SELECT x.x, SUM(x.x) FROM x AS x LEFT JOIN x AS x ON x.x = x.x GROUP BY x.x ORDER BY 1 NULLS LAST;
/* RIGHT JOIN, should produce full partitionwise aggregation plan as */ /* GROUP BY is on non-nullable column */ EXPLAIN (COSTS OFF) SELECT b.y, sum(a.y) FROM pagg_tab1 a RIGHT JOIN pagg_tab2 b ON a.x = b.y GROUP BY b.y ORDER BY 1 NULLS LAST;
SELECT x.x, SUM(x.x) FROM x AS x RIGHT JOIN x AS x ON x.x = x.x GROUP BY x.x ORDER BY 1 NULLS LAST;
/* FULL JOIN, should produce partial partitionwise aggregation plan as */ /* GROUP BY is on nullable column */ EXPLAIN (COSTS OFF) SELECT a.x, sum(b.x) FROM pagg_tab1 a FULL OUTER JOIN pagg_tab2 b ON a.x = b.y GROUP BY a.x ORDER BY 1 NULLS LAST;
SELECT x.x, SUM(x.x) FROM x AS x FULL OUTER JOIN x AS x ON x.x = x.x GROUP BY x.x ORDER BY 1 NULLS LAST;
/* LEFT JOIN, with dummy relation on right side, ideally */ /* should produce full partitionwise aggregation plan as GROUP BY is on */ /* non-nullable columns. */ /* But right now we are unable to do partitionwise join in this case. */ EXPLAIN (COSTS OFF) SELECT a.x, b.y, count(*) FROM (SELECT * FROM pagg_tab1 WHERE x < 20) a LEFT JOIN (SELECT * FROM pagg_tab2 WHERE y > 10) b ON a.x = b.y WHERE a.x > 5 or b.y < 20  GROUP BY a.x, b.y ORDER BY 1, 2;
SELECT x.x, x.x, COUNT(*) FROM (SELECT * FROM x WHERE x < 20) AS x LEFT JOIN (SELECT * FROM x WHERE x > 10) AS x ON x.x = x.x WHERE x.x > 5 OR x.x < 20 GROUP BY x.x, x.x ORDER BY 1 NULLS LAST, 2 NULLS LAST;
/* FULL JOIN, with dummy relations on both sides, ideally */ /* should produce partial partitionwise aggregation plan as GROUP BY is on */ /* nullable columns. */ /* But right now we are unable to do partitionwise join in this case. */ EXPLAIN (COSTS OFF) SELECT a.x, b.y, count(*) FROM (SELECT * FROM pagg_tab1 WHERE x < 20) a FULL JOIN (SELECT * FROM pagg_tab2 WHERE y > 10) b ON a.x = b.y WHERE a.x > 5 or b.y < 20  GROUP BY a.x, b.y ORDER BY 1, 2;
SELECT x.x, x.x, COUNT(*) FROM (SELECT * FROM x WHERE x < 20) AS x FULL JOIN (SELECT * FROM x WHERE x > 10) AS x ON x.x = x.x WHERE x.x > 5 OR x.x < 20 GROUP BY x.x, x.x ORDER BY 1 NULLS LAST, 2 NULLS LAST;
/* Empty join relation because of empty outer side, no partitionwise agg plan */ EXPLAIN (COSTS OFF) SELECT a.x, a.y, count(*) FROM (SELECT * FROM pagg_tab1 WHERE x = 1 AND x = 2) a LEFT JOIN pagg_tab2 b ON a.x = b.y GROUP BY a.x, a.y ORDER BY 1, 2;
SELECT x.x, x.x, COUNT(*) FROM (SELECT * FROM x WHERE x = 1 AND x = 2) AS x LEFT JOIN x AS x ON x.x = x.x GROUP BY x.x, x.x ORDER BY 1 NULLS LAST, 2 NULLS LAST;
/* Partition by multiple columns */ CREATE TABLE x (x INT, x INT, x INT) WITH (PARTITIONED_BY=RANGE(x, ((x + x) / 2)));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (0, 0) TO (12, 12);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (12, 12) TO (22, 22);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (22, 22) TO (30, 30);
INSERT INTO x SELECT x % 30, x % 40, x % 50 FROM x AS x;
ANALYZE x;
/* Partial aggregation as GROUP BY clause does not match with PARTITION KEY */ EXPLAIN (COSTS OFF) SELECT a, sum(b), avg(c), count(*) FROM pagg_tab_m GROUP BY a HAVING avg(c) < 22 ORDER BY 1, 2, 3;
SELECT x, SUM(x), AVG(x), COUNT(*) FROM x GROUP BY x HAVING AVG(x) < 22 ORDER BY 1 NULLS LAST, 2 NULLS LAST, 3 NULLS LAST;
/* Full aggregation as GROUP BY clause matches with PARTITION KEY */ EXPLAIN (COSTS OFF) SELECT a, sum(b), avg(c), count(*) FROM pagg_tab_m GROUP BY a, (a+b)/2 HAVING sum(b) < 50 ORDER BY 1, 2, 3;
SELECT x, SUM(x), AVG(x), COUNT(*) FROM x GROUP BY x, (x + x) / 2 HAVING SUM(x) < 50 ORDER BY 1 NULLS LAST, 2 NULLS LAST, 3 NULLS LAST;
/* Full aggregation as PARTITION KEY is part of GROUP BY clause */ EXPLAIN (COSTS OFF) SELECT a, c, sum(b), avg(c), count(*) FROM pagg_tab_m GROUP BY (a+b)/2, 2, 1 HAVING sum(b) = 50 AND avg(c) > 25 ORDER BY 1, 2, 3;
SELECT x, x, SUM(x), AVG(x), COUNT(*) FROM x GROUP BY (x + x) / 2, 2, 1 HAVING SUM(x) = 50 AND AVG(x) > 25 ORDER BY 1 NULLS LAST, 2 NULLS LAST, 3 NULLS LAST;
/* Test with multi-level partitioning scheme */ CREATE TABLE x (x INT, x INT, x TEXT) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (0) TO (12);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (12) TO (20) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN ('0000', '0001', '0002');
CREATE TABLE x PARTITION OF x FOR VALUES IN ('0003');
/* This level of partitioning has different column positions than the parent */ CREATE TABLE x (x INT, x TEXT, x INT) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x (x TEXT, x INT, x INT);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (7) TO (10);
ALTER TABLE pagg_tab_ml_p3 ATTACH PARTITION pagg_tab_ml_p3_s1 FOR VALUES FROM (0) TO (7);
ALTER TABLE pagg_tab_ml ATTACH PARTITION pagg_tab_ml_p3 FOR VALUES FROM (20) TO (30);
INSERT INTO x SELECT x % 30, x % 10, TIME_TO_STR(x % 4, 'FM0000') FROM x AS x;
ANALYZE x;
SET x = 2 /* For Parallel Append */;
SET x = 0;
/* Full aggregation at level 1 as GROUP BY clause matches with PARTITION KEY */ /* for level 1 only. For subpartitions, GROUP BY clause does not match with */ /* PARTITION KEY, but still we do not see a partial aggregation as array_agg() */ /* is not partial agg safe. */ EXPLAIN (COSTS OFF) SELECT a, sum(b), array_agg(distinct c), count(*) FROM pagg_tab_ml GROUP BY a HAVING avg(b) < 3 ORDER BY 1, 2, 3;
SELECT x, SUM(x), ARRAY_AGG(DISTINCT x), COUNT(*) FROM x GROUP BY x HAVING AVG(x) < 3 ORDER BY 1 NULLS LAST, 2 NULLS LAST, 3 NULLS LAST;
/* Without ORDER BY clause, to test Gather at top-most path */ EXPLAIN (COSTS OFF) SELECT a, sum(b), array_agg(distinct c), count(*) FROM pagg_tab_ml GROUP BY a HAVING avg(b) < 3;
RESET parallel_setup_cost;
/* Full aggregation at level 1 as GROUP BY clause matches with PARTITION KEY */ /* for level 1 only. For subpartitions, GROUP BY clause does not match with */ /* PARTITION KEY, thus we will have a partial aggregation for them. */ EXPLAIN (COSTS OFF) SELECT a, sum(b), count(*) FROM pagg_tab_ml GROUP BY a HAVING avg(b) < 3 ORDER BY 1, 2, 3;
SELECT x, SUM(x), COUNT(*) FROM x GROUP BY x HAVING AVG(x) < 3 ORDER BY 1 NULLS LAST, 2 NULLS LAST, 3 NULLS LAST;
/* Partial aggregation at all levels as GROUP BY clause does not match with */ /* PARTITION KEY */ EXPLAIN (COSTS OFF) SELECT b, sum(a), count(*) FROM pagg_tab_ml GROUP BY b ORDER BY 1, 2, 3;
SELECT x, SUM(x), COUNT(*) FROM x GROUP BY x HAVING AVG(x) < 15 ORDER BY 1 NULLS LAST, 2 NULLS LAST, 3 NULLS LAST;
/* Full aggregation at all levels as GROUP BY clause matches with PARTITION KEY */ EXPLAIN (COSTS OFF) SELECT a, sum(b), count(*) FROM pagg_tab_ml GROUP BY a, b, c HAVING avg(b) > 7 ORDER BY 1, 2, 3;
SELECT x, SUM(x), COUNT(*) FROM x GROUP BY x, x, x HAVING AVG(x) > 7 ORDER BY 1 NULLS LAST, 2 NULLS LAST, 3 NULLS LAST;
SET x = '8kB' /* Parallelism within partitionwise aggregates */;
SET x = 0;
/* Full aggregation at level 1 as GROUP BY clause matches with PARTITION KEY */ /* for level 1 only. For subpartitions, GROUP BY clause does not match with */ /* PARTITION KEY, thus we will have a partial aggregation for them. */ EXPLAIN (COSTS OFF) SELECT a, sum(b), count(*) FROM pagg_tab_ml GROUP BY a HAVING avg(b) < 3 ORDER BY 1, 2, 3;
SELECT x, SUM(x), COUNT(*) FROM x GROUP BY x HAVING AVG(x) < 3 ORDER BY 1 NULLS LAST, 2 NULLS LAST, 3 NULLS LAST;
/* Partial aggregation at all levels as GROUP BY clause does not match with */ /* PARTITION KEY */ EXPLAIN (COSTS OFF) SELECT b, sum(a), count(*) FROM pagg_tab_ml GROUP BY b ORDER BY 1, 2, 3;
SELECT x, SUM(x), COUNT(*) FROM x GROUP BY x HAVING AVG(x) < 15 ORDER BY 1 NULLS LAST, 2 NULLS LAST, 3 NULLS LAST;
/* Full aggregation at all levels as GROUP BY clause matches with PARTITION KEY */ EXPLAIN (COSTS OFF) SELECT a, sum(b), count(*) FROM pagg_tab_ml GROUP BY a, b, c HAVING avg(b) > 7 ORDER BY 1, 2, 3;
SELECT x, SUM(x), COUNT(*) FROM x GROUP BY x, x, x HAVING AVG(x) > 7 ORDER BY 1 NULLS LAST, 2 NULLS LAST, 3 NULLS LAST;
SET x = 10 /* Parallelism within partitionwise aggregates (single level) */ /* Add few parallel setup cost, so that we will see a plan which gathers */ /* partially created paths even for full aggregation and sticks a single Gather */ /* followed by finalization step. */ /* Without this, the cost of doing partial aggregation + Gather + finalization */ /* for each partition and then Append over it turns out to be same and this */ /* wins as we add it first. This parallel_setup_cost plays a vital role in */ /* costing such plans. */;
CREATE TABLE x (x INT, x INT) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (0) TO (12);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (12) TO (22);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (22) TO (30);
INSERT INTO x SELECT x % 30, x % 20 FROM x AS x;
ANALYZE x;
SELECT x, SUM(x), AVG(x), COUNT(*) FROM x GROUP BY x HAVING AVG(x) < 7 ORDER BY 1 NULLS LAST, 2 NULLS LAST, 3 NULLS LAST;
SELECT x, SUM(x), AVG(x), COUNT(*) FROM x GROUP BY x HAVING AVG(x) < 12 ORDER BY 1 NULLS LAST, 2 NULLS LAST, 3 NULLS LAST;
ALTER TABLE x SET x = 0 /* Test when parent can produce parallel paths but not any (or some) of its children */ /* (Use one more aggregate to tilt the cost estimates for the plan we want) */;
ALTER TABLE x SET x = 0;
ANALYZE x;
EXPLAIN (COSTS OFF) SELECT x, sum(y), avg(y), sum(x+y), count(*) FROM pagg_tab_para GROUP BY x HAVING avg(y) < 7 ORDER BY 1, 2, 3;
SELECT x, SUM(x), AVG(x), SUM(x + x), COUNT(*) FROM x GROUP BY x HAVING AVG(x) < 7 ORDER BY 1 NULLS LAST, 2 NULLS LAST, 3 NULLS LAST;
ALTER TABLE x SET x = 0;
ANALYZE x;
EXPLAIN (COSTS OFF) SELECT x, sum(y), avg(y), sum(x+y), count(*) FROM pagg_tab_para GROUP BY x HAVING avg(y) < 7 ORDER BY 1, 2, 3;
SELECT x, SUM(x), AVG(x), SUM(x + x), COUNT(*) FROM x GROUP BY x HAVING AVG(x) < 7 ORDER BY 1 NULLS LAST, 2 NULLS LAST, 3 NULLS LAST;
/* Reset parallelism parameters to get partitionwise aggregation plan. */ RESET min_parallel_table_scan_size;
RESET parallel_setup_cost;
EXPLAIN (COSTS OFF) SELECT x, sum(y), avg(y), count(*) FROM pagg_tab_para GROUP BY x HAVING avg(y) < 7 ORDER BY 1, 2, 3;
SELECT x, SUM(x), AVG(x), COUNT(*) FROM x GROUP BY x HAVING AVG(x) < 7 ORDER BY 1 NULLS LAST, 2 NULLS LAST, 3 NULLS LAST;
/* Tests for functions providing information about partitions */ SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT PG_PARTITION_ROOT(NULL);
SELECT PG_PARTITION_ROOT(0);
/* Test table partition trees */ CREATE TABLE x (x INT, x INT) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (MINVALUE) TO (0) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN (1);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (0) TO (100) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN (1);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (100) TO (200);
/* This partitioned table should remain with no partitions. */ CREATE TABLE x PARTITION OF x FOR VALUES FROM (200) TO (MAXVALUE) WITH (PARTITIONED_BY=LIST(x));
/* Test pg_partition_root for tables */ SELECT PG_PARTITION_ROOT('ptif_test');
SELECT PG_PARTITION_ROOT('ptif_test0');
SELECT PG_PARTITION_ROOT('ptif_test01');
SELECT PG_PARTITION_ROOT('ptif_test3');
ALTER INDEX ptif_test_index ATTACH PARTITION ptif_test0_index;
CREATE INDEX x ON x(x NULLS LAST);
ALTER INDEX ptif_test0_index ATTACH PARTITION ptif_test01_index;
ALTER INDEX ptif_test_index ATTACH PARTITION ptif_test1_index;
CREATE INDEX x ON x(x NULLS LAST);
ALTER INDEX ptif_test1_index ATTACH PARTITION ptif_test11_index;
CREATE INDEX x ON x(x NULLS LAST);
ALTER INDEX ptif_test_index ATTACH PARTITION ptif_test2_index;
CREATE INDEX x ON x(x NULLS LAST);
ALTER INDEX ptif_test_index ATTACH PARTITION ptif_test3_index;
/* Test pg_partition_root for indexes */ SELECT PG_PARTITION_ROOT('ptif_test_index');
SELECT PG_PARTITION_ROOT('ptif_test0_index');
SELECT PG_PARTITION_ROOT('ptif_test01_index');
SELECT PG_PARTITION_ROOT('ptif_test3_index');
/* List all tables members of the tree */ SELECT x, x, x, x FROM x;
/* List tables from an intermediate level */ SELECT x, x, x, x FROM x AS x JOIN x AS x ON (x.x = x.x);
/* List from leaf table */ SELECT x, x, x, x FROM x AS x JOIN x AS x ON (x.x = x.x);
/* List from partitioned table with no partitions */ SELECT x, x, x, x FROM x AS x JOIN x AS x ON (x.x = x.x);
/* List all ancestors of root and leaf tables */ SELECT * FROM x;
SELECT * FROM x;
/* List all members using pg_partition_root with leaf table reference */ SELECT x, x, x, x FROM x AS x JOIN x AS x ON (x.x = x.x);
/* List all indexes members of the tree */ SELECT x, x, x, x FROM x;
/* List indexes from an intermediate level */ SELECT x, x, x, x FROM x AS x JOIN x AS x ON (x.x = x.x);
/* List from leaf index */ SELECT x, x, x, x FROM x AS x JOIN x AS x ON (x.x = x.x);
/* List from partitioned index with no partitions */ SELECT x, x, x, x FROM x AS x JOIN x AS x ON (x.x = x.x);
/* List all members using pg_partition_root with leaf index reference */ SELECT x, x, x, x FROM x AS x JOIN x AS x ON (x.x = x.x);
/* List all ancestors of root and leaf indexes */ SELECT * FROM x;
SELECT * FROM x;
DROP TABLE x;
/* Table that is not part of any partition tree is not listed. */ CREATE TABLE x (x INT);
SELECT x, x, x, x FROM x;
SELECT * FROM x;
SELECT PG_PARTITION_ROOT('ptif_normal_table');
DROP TABLE x;
CREATE MATERIALIZED VIEW x AS SELECT 1;
CREATE TABLE x;
CREATE TABLE x INHERITS (x);
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT PG_PARTITION_ROOT('ptif_test_view');
SELECT PG_PARTITION_ROOT('ptif_test_matview');
SELECT PG_PARTITION_ROOT('ptif_li_parent');
SELECT PG_PARTITION_ROOT('ptif_li_child');
DROP VIEW x;
DROP MATERIALIZED VIEW x;
SET x = TRUE /* PARTITION_JOIN */ /* Test partitionwise join between partitioned tables */ /* Enable partitionwise join, which by default is disabled. */;
/* partitioned by a single column */ CREATE TABLE x (x INT, x INT, x VARCHAR) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (0) TO (250);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (500) TO (600);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (250) TO (500);
INSERT INTO x SELECT x, x % 25, TIME_TO_STR(x, 'FM0000') FROM x AS x WHERE x % 2 = 0;
CREATE INDEX x ON x(x NULLS LAST);
CREATE INDEX x ON x(x NULLS LAST);
CREATE INDEX x ON x(x NULLS LAST);
ANALYZE x;
CREATE TABLE x (x INT, x INT, x VARCHAR) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (0) TO (250);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (250) TO (500);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (500) TO (600);
INSERT INTO x SELECT x % 25, x, TIME_TO_STR(x, 'FM0000') FROM x AS x WHERE x % 3 = 0;
CREATE INDEX x ON x(x NULLS LAST);
CREATE INDEX x ON x(x NULLS LAST);
CREATE INDEX x ON x(x NULLS LAST);
ANALYZE x;
/* inner join */ EXPLAIN (COSTS OFF) SELECT t1.a, t1.c, t2.b, t2.c FROM prt1 t1, prt2 t2 WHERE t1.a = t2.b AND t1.b = 0 ORDER BY t1.a, t2.b;
SELECT x.x, x.x, x.x, x.x FROM x AS x, x AS x WHERE x.x = x.x AND x.x = 0 ORDER BY x.x NULLS LAST, x.x NULLS LAST;
/* inner join with partially-redundant join clauses */ EXPLAIN (COSTS OFF) SELECT t1.a, t1.c, t2.b, t2.c FROM prt1 t1, prt2 t2 WHERE t1.a = t2.a AND t1.a = t2.b ORDER BY t1.a, t2.b;
SELECT x.x, x.x, x.x, x.x FROM x AS x, x AS x WHERE x.x = x.x AND x.x = x.x ORDER BY x.x NULLS LAST, x.x NULLS LAST;
/* left outer join, 3-way */ EXPLAIN (COSTS OFF) SELECT COUNT(*) FROM prt1 t1   LEFT JOIN prt1 t2 ON t1.a = t2.a   LEFT JOIN prt1 t3 ON t2.a = t3.a;
SELECT COUNT(*) FROM x AS x LEFT JOIN x AS x ON x.x = x.x LEFT JOIN x AS x ON x.x = x.x;
SELECT x, x FROM x AS x LEFT JOIN x AS x ON x.x = x.x WHERE x.x = 0 ORDER BY x.x NULLS LAST, x.x NULLS LAST;
/* right outer join */ EXPLAIN (COSTS OFF) SELECT t1.a, t1.c, t2.b, t2.c FROM prt1 t1 RIGHT JOIN prt2 t2 ON t1.a = t2.b WHERE t2.a = 0 ORDER BY t1.a, t2.b;
SELECT x.x, x.x, x.x, x.x FROM x AS x RIGHT JOIN x AS x ON x.x = x.x WHERE x.x = 0 ORDER BY x.x NULLS LAST, x.x NULLS LAST;
/* full outer join, with placeholder vars */ EXPLAIN (COSTS OFF) SELECT t1.a, t1.c, t2.b, t2.c FROM (SELECT 50 phv, * FROM prt1 WHERE prt1.b = 0) t1 FULL JOIN (SELECT 75 phv, * FROM prt2 WHERE prt2.a = 0) t2 ON (t1.a = t2.b) WHERE t1.phv = t1.a OR t2.phv = t2.b ORDER BY t1.a, t2.b;
SELECT x.x, x.x, x.x, x.x FROM (SELECT 50 AS x, * FROM x WHERE x.x = 0) AS x FULL JOIN (SELECT 75 AS x, * FROM x WHERE x.x = 0) AS x ON (x.x = x.x) WHERE x.x = x.x OR x.x = x.x ORDER BY x.x NULLS LAST, x.x NULLS LAST;
/* Join with pruned partitions from joining relations */ EXPLAIN (COSTS OFF) SELECT t1.a, t1.c, t2.b, t2.c FROM prt1 t1, prt2 t2 WHERE t1.a = t2.b AND t1.a < 450 AND t2.b > 250 AND t1.b = 0 ORDER BY t1.a, t2.b;
SELECT x.x, x.x, x.x, x.x FROM x AS x, x AS x WHERE x.x = x.x AND x.x < 450 AND x.x > 250 AND x.x = 0 ORDER BY x.x NULLS LAST, x.x NULLS LAST;
/* Currently we can't do partitioned join if nullable-side partitions are pruned */ EXPLAIN (COSTS OFF) SELECT t1.a, t1.c, t2.b, t2.c FROM (SELECT * FROM prt1 WHERE a < 450) t1 LEFT JOIN (SELECT * FROM prt2 WHERE b > 250) t2 ON t1.a = t2.b WHERE t1.b = 0 ORDER BY t1.a, t2.b;
SELECT x.x, x.x, x.x, x.x FROM (SELECT * FROM x WHERE x < 450) AS x LEFT JOIN (SELECT * FROM x WHERE x > 250) AS x ON x.x = x.x WHERE x.x = 0 ORDER BY x.x NULLS LAST, x.x NULLS LAST;
/* Currently we can't do partitioned join if nullable-side partitions are pruned */ EXPLAIN (COSTS OFF) SELECT t1.a, t1.c, t2.b, t2.c FROM (SELECT * FROM prt1 WHERE a < 450) t1 FULL JOIN (SELECT * FROM prt2 WHERE b > 250) t2 ON t1.a = t2.b WHERE t1.b = 0 OR t2.a = 0 ORDER BY t1.a, t2.b;
SELECT x.x, x.x, x.x, x.x FROM (SELECT * FROM x WHERE x < 450) AS x FULL JOIN (SELECT * FROM x WHERE x > 250) AS x ON x.x = x.x WHERE x.x = 0 OR x.x = 0 ORDER BY x.x NULLS LAST, x.x NULLS LAST;
/* Semi-join */ EXPLAIN (COSTS OFF) SELECT t1.* FROM prt1 t1 WHERE t1.a IN (SELECT t2.b FROM prt2 t2 WHERE t2.a = 0) AND t1.b = 0 ORDER BY t1.a;
SELECT x.* FROM x AS x WHERE x.x IN (SELECT x.x FROM x AS x WHERE x.x = 0) AND x.x = 0 ORDER BY x.x NULLS LAST;
/* Anti-join with aggregates */ EXPLAIN (COSTS OFF) SELECT sum(t1.a), avg(t1.a), sum(t1.b), avg(t1.b) FROM prt1 t1 WHERE NOT EXISTS (SELECT 1 FROM prt2 t2 WHERE t1.a = t2.b);
SELECT SUM(x.x), AVG(x.x), SUM(x.x), AVG(x.x) FROM x AS x WHERE NOT EXISTS(SELECT 1 FROM x AS x WHERE x.x = x.x);
/* lateral reference */ EXPLAIN (COSTS OFF) SELECT * FROM prt1 t1 LEFT JOIN LATERAL 			  (SELECT t2.a AS t2a, t3.a AS t3a, least(t1.a,t2.a,t3.b) FROM prt1 t2 JOIN prt2 t3 ON (t2.a = t3.b)) ss 			  ON t1.a = ss.t2a WHERE t1.b = 0 ORDER BY t1.a;
SELECT * FROM x AS x LEFT JOIN LATERAL (SELECT x.x AS x, x.x AS x, LEAST(x.x, x.x, x.x) FROM x AS x JOIN x AS x ON (x.x = x.x)) AS x ON x.x = x.x WHERE x.x = 0 ORDER BY x.x NULLS LAST;
EXPLAIN (COSTS OFF) SELECT t1.a, ss.t2a, ss.t2c FROM prt1 t1 LEFT JOIN LATERAL 			  (SELECT t2.a AS t2a, t3.a AS t3a, t2.b t2b, t2.c t2c, least(t1.a,t2.a,t3.b) FROM prt1 t2 JOIN prt2 t3 ON (t2.a = t3.b)) ss 			  ON t1.c = ss.t2c WHERE (t1.b + coalesce(ss.t2b, 0)) = 0 ORDER BY t1.a;
SELECT x.x, x.x, x.x FROM x AS x LEFT JOIN LATERAL (SELECT x.x AS x, x.x AS x, x.x AS x, x.x AS x, LEAST(x.x, x.x, x.x) FROM x AS x JOIN x AS x ON (x.x = x.x)) AS x ON x.x = x.x WHERE (x.x + COALESCE(x.x, 0)) = 0 ORDER BY x.x NULLS LAST;
/* lateral reference in sample scan */ EXPLAIN (COSTS OFF) SELECT * FROM prt1 t1 JOIN LATERAL 			  (SELECT * FROM prt1 t2 TABLESAMPLE SYSTEM (t1.a) REPEATABLE(t1.b)) s 			  ON t1.a = s.a;
/* lateral reference in scan's restriction clauses */ EXPLAIN (COSTS OFF) SELECT count(*) FROM prt1 t1 LEFT JOIN LATERAL 			  (SELECT t1.b AS t1b, t2.* FROM prt2 t2) s 			  ON t1.a = s.b WHERE s.t1b = s.a;
SELECT COUNT(*) FROM x AS x LEFT JOIN LATERAL (SELECT x.x AS x, x.* FROM x AS x) AS x ON x.x = x.x WHERE x.x = x.x;
EXPLAIN (COSTS OFF) SELECT count(*) FROM prt1 t1 LEFT JOIN LATERAL 			  (SELECT t1.b AS t1b, t2.* FROM prt2 t2) s 			  ON t1.a = s.b WHERE s.t1b = s.b;
SELECT COUNT(*) FROM x AS x LEFT JOIN LATERAL (SELECT x.x AS x, x.* FROM x AS x) AS x ON x.x = x.x WHERE x.x = x.x;
SET x = TRUE /* bug with inadequate sort key representation */;
SET x = FALSE;
EXPLAIN (COSTS OFF) SELECT a, b FROM prt1 FULL JOIN prt2 p2(b,a,c) USING(a,b)   WHERE a BETWEEN 490 AND 510   GROUP BY 1, 2 ORDER BY 1, 2;
SELECT x, x FROM x FULL JOIN x AS x USING (x, x) WHERE x BETWEEN 490 AND 510 GROUP BY 1, 2 ORDER BY 1 NULLS LAST, 2 NULLS LAST;
RESET enable_partitionwise_aggregate;
RESET enable_hashjoin;
/* bug in freeing the SpecialJoinInfo of a child-join */ EXPLAIN (COSTS OFF) SELECT * FROM prt1 t1 JOIN prt1 t2 ON t1.a = t2.a WHERE t1.a IN (SELECT a FROM prt1 t3);
/* partitioned by expression */ CREATE TABLE x (x INT, x INT, x INT) WITH (PARTITIONED_BY=RANGE(((x + x) / 2)));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (0) TO (250);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (250) TO (500);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (500) TO (600);
INSERT INTO x SELECT x, x, x % 25 FROM x AS x;
CREATE INDEX x ON x(((x + x) / 2) NULLS LAST);
CREATE INDEX x ON x(((x + x) / 2) NULLS LAST);
CREATE INDEX x ON x(((x + x) / 2) NULLS LAST);
ANALYZE x;
CREATE TABLE x (x INT, x INT, x INT) WITH (PARTITIONED_BY=RANGE(((x + x) / 2)));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (0) TO (250);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (250) TO (500);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (500) TO (600);
INSERT INTO x SELECT x, x, x % 25 FROM x AS x;
ANALYZE x;
EXPLAIN (COSTS OFF) SELECT t1.a, t1.c, t2.b, t2.c FROM prt1_e t1, prt2_e t2 WHERE (t1.a + t1.b)/2 = (t2.b + t2.a)/2 AND t1.c = 0 ORDER BY t1.a, t2.b;
SELECT x.x, x.x, x.x, x.x FROM x AS x, x AS x WHERE (x.x + x.x) / 2 = (x.x + x.x) / 2 AND x.x = 0 ORDER BY x.x NULLS LAST, x.x NULLS LAST;
/* N-way join */ EXPLAIN (COSTS OFF) SELECT t1.a, t1.c, t2.b, t2.c, t3.a + t3.b, t3.c FROM prt1 t1, prt2 t2, prt1_e t3 WHERE t1.a = t2.b AND t1.a = (t3.a + t3.b)/2 AND t1.b = 0 ORDER BY t1.a, t2.b;
SELECT x.x, x.x, x.x, x.x, x.x + x.x, x.x FROM x AS x, x AS x, x AS x WHERE x.x = x.x AND x.x = (x.x + x.x) / 2 AND x.x = 0 ORDER BY x.x NULLS LAST, x.x NULLS LAST;
EXPLAIN (COSTS OFF) SELECT t1.a, t1.c, t2.b, t2.c, t3.a + t3.b, t3.c FROM (prt1 t1 LEFT JOIN prt2 t2 ON t1.a = t2.b) LEFT JOIN prt1_e t3 ON (t1.a = (t3.a + t3.b)/2) WHERE t1.b = 0 ORDER BY t1.a, t2.b, t3.a + t3.b;
SELECT x.x, x.x, x.x, x.x, x.x + x.x, x.x FROM (x AS x LEFT JOIN x AS x ON x.x = x.x) LEFT JOIN x AS x ON (x.x = (x.x + x.x) / 2) WHERE x.x = 0 ORDER BY x.x NULLS LAST, x.x NULLS LAST, x.x + x.x NULLS LAST;
EXPLAIN (COSTS OFF) SELECT t1.a, t1.c, t2.b, t2.c, t3.a + t3.b, t3.c FROM (prt1 t1 LEFT JOIN prt2 t2 ON t1.a = t2.b) RIGHT JOIN prt1_e t3 ON (t1.a = (t3.a + t3.b)/2) WHERE t3.c = 0 ORDER BY t1.a, t2.b, t3.a + t3.b;
SELECT x.x, x.x, x.x, x.x, x.x + x.x, x.x FROM (x AS x LEFT JOIN x AS x ON x.x = x.x) RIGHT JOIN x AS x ON (x.x = (x.x + x.x) / 2) WHERE x.x = 0 ORDER BY x.x NULLS LAST, x.x NULLS LAST, x.x + x.x NULLS LAST;
/* 3-way full join */ EXPLAIN (COSTS OFF) SELECT COUNT(*) FROM prt1 FULL JOIN prt2 p2(b,a,c) USING(a,b) FULL JOIN prt2 p3(b,a,c) USING (a, b)   WHERE a BETWEEN 490 AND 510;
SELECT COUNT(*) FROM x FULL JOIN x AS x USING (x, x) FULL JOIN x AS x USING (x, x) WHERE x BETWEEN 490 AND 510;
/* 4-way full join */ EXPLAIN (COSTS OFF) SELECT COUNT(*) FROM prt1 FULL JOIN prt2 p2(b,a,c) USING(a,b) FULL JOIN prt2 p3(b,a,c) USING (a, b) FULL JOIN prt1 p4 (a,b,c) USING (a, b)   WHERE a BETWEEN 490 AND 510;
SELECT COUNT(*) FROM x FULL JOIN x AS x USING (x, x) FULL JOIN x AS x USING (x, x) FULL JOIN x AS x USING (x, x) WHERE x BETWEEN 490 AND 510;
/* make sure these go to null as expected */ EXPLAIN (COSTS OFF) SELECT t1.a, t1.phv, t2.b, t2.phv, t3.a + t3.b, t3.phv FROM ((SELECT 50 phv, * FROM prt1 WHERE prt1.b = 0) t1 FULL JOIN (SELECT 75 phv, * FROM prt2 WHERE prt2.a = 0) t2 ON (t1.a = t2.b)) FULL JOIN (SELECT 50 phv, * FROM prt1_e WHERE prt1_e.c = 0) t3 ON (t1.a = (t3.a + t3.b)/2) WHERE t1.a = t1.phv OR t2.b = t2.phv OR (t3.a + t3.b)/2 = t3.phv ORDER BY t1.a, t2.b, t3.a + t3.b;
SELECT x.x, x.x, x.x, x.x, x.x + x.x, x.x FROM ((SELECT 50 AS x, * FROM x WHERE x.x = 0) AS x FULL JOIN (SELECT 75 AS x, * FROM x WHERE x.x = 0) AS x ON (x.x = x.x)) FULL JOIN (SELECT 50 AS x, * FROM x WHERE x.x = 0) AS x ON (x.x = (x.x + x.x) / 2) WHERE x.x = x.x OR x.x = x.x OR (x.x + x.x) / 2 = x.x ORDER BY x.x NULLS LAST, x.x NULLS LAST, x.x + x.x NULLS LAST;
/* Semi-join */ EXPLAIN (COSTS OFF) SELECT t1.* FROM prt1 t1 WHERE t1.a IN (SELECT t1.b FROM prt2 t1, prt1_e t2 WHERE t1.a = 0 AND t1.b = (t2.a + t2.b)/2) AND t1.b = 0 ORDER BY t1.a;
SELECT x.* FROM x AS x WHERE x.x IN (SELECT x.x FROM x AS x, x AS x WHERE x.x = 0 AND x.x = (x.x + x.x) / 2) AND x.x = 0 ORDER BY x.x NULLS LAST;
EXPLAIN (COSTS OFF) SELECT t1.* FROM prt1 t1 WHERE t1.a IN (SELECT t1.b FROM prt2 t1 WHERE t1.b IN (SELECT (t1.a + t1.b)/2 FROM prt1_e t1 WHERE t1.c = 0)) AND t1.b = 0 ORDER BY t1.a;
SELECT x.* FROM x AS x WHERE x.x IN (SELECT x.x FROM x AS x WHERE x.x IN (SELECT (x.x + x.x) / 2 FROM x AS x WHERE x.x = 0)) AND x.x = 0 ORDER BY x.x NULLS LAST;
SET x = off /* test merge joins */;
SET x = off;
EXPLAIN (COSTS OFF) SELECT t1.* FROM prt1 t1 WHERE t1.a IN (SELECT t1.b FROM prt2 t1 WHERE t1.b IN (SELECT (t1.a + t1.b)/2 FROM prt1_e t1 WHERE t1.c = 0)) AND t1.b = 0 ORDER BY t1.a;
SELECT x.* FROM x AS x WHERE x.x IN (SELECT x.x FROM x AS x WHERE x.x IN (SELECT (x.x + x.x) / 2 FROM x AS x WHERE x.x = 0)) AND x.x = 0 ORDER BY x.x NULLS LAST;
EXPLAIN (COSTS OFF) SELECT t1.a, t1.c, t2.b, t2.c, t3.a + t3.b, t3.c FROM (prt1 t1 LEFT JOIN prt2 t2 ON t1.a = t2.b) RIGHT JOIN prt1_e t3 ON (t1.a = (t3.a + t3.b)/2) WHERE t3.c = 0 ORDER BY t1.a, t2.b, t3.a + t3.b;
SELECT x.x, x.x, x.x, x.x, x.x + x.x, x.x FROM (x AS x LEFT JOIN x AS x ON x.x = x.x) RIGHT JOIN x AS x ON (x.x = (x.x + x.x) / 2) WHERE x.x = 0 ORDER BY x.x NULLS LAST, x.x NULLS LAST, x.x + x.x NULLS LAST;
/* MergeAppend on nullable column */ /* This should generate a partitionwise join, but currently fails to */ EXPLAIN (COSTS OFF) SELECT t1.a, t2.b FROM (SELECT * FROM prt1 WHERE a < 450) t1 LEFT JOIN (SELECT * FROM prt2 WHERE b > 250) t2 ON t1.a = t2.b WHERE t1.b = 0 ORDER BY t1.a, t2.b;
SELECT x.x, x.x FROM (SELECT * FROM x WHERE x < 450) AS x LEFT JOIN (SELECT * FROM x WHERE x > 250) AS x ON x.x = x.x WHERE x.x = 0 ORDER BY x.x NULLS LAST, x.x NULLS LAST;
/* partitionwise join does not apply */ EXPLAIN (COSTS OFF) SELECT t1.a, t2.b FROM prt1 t1, prt2 t2 WHERE t1::text = t2::text AND t1.a = t2.b ORDER BY t1.a;
SELECT x.x, x.x FROM x AS x, x AS x WHERE CAST(x AS TEXT) = CAST(x AS TEXT) AND x.x = x.x ORDER BY x.x NULLS LAST;
RESET enable_hashjoin;
RESET enable_nestloop;
/* partitioned by multiple columns */ CREATE TABLE x (x INT, x INT, x INT) WITH (PARTITIONED_BY=RANGE(x, ((x + x) / 2)));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (0, 0) TO (250, 250);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (250, 250) TO (500, 500);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (500, 500) TO (600, 600);
INSERT INTO x SELECT x, x, x % 25 FROM x AS x;
ANALYZE x;
CREATE TABLE x (x INT, x INT, x INT) WITH (PARTITIONED_BY=RANGE(((x + x) / 2), x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (0, 0) TO (250, 250);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (250, 250) TO (500, 500);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (500, 500) TO (600, 600);
INSERT INTO x SELECT x, x, x % 25 FROM x AS x;
ANALYZE x;
EXPLAIN (COSTS OFF) SELECT t1.a, t1.c, t2.b, t2.c FROM (SELECT * FROM prt1_m WHERE prt1_m.c = 0) t1 FULL JOIN (SELECT * FROM prt2_m WHERE prt2_m.c = 0) t2 ON (t1.a = (t2.b + t2.a)/2 AND t2.b = (t1.a + t1.b)/2) ORDER BY t1.a, t2.b;
SELECT x.x, x.x, x.x, x.x FROM (SELECT * FROM x WHERE x.x = 0) AS x FULL JOIN (SELECT * FROM x WHERE x.x = 0) AS x ON (x.x = (x.x + x.x) / 2 AND x.x = (x.x + x.x) / 2) ORDER BY x.x NULLS LAST, x.x NULLS LAST;
/* tests for list partitioned tables. */ CREATE TABLE x (x INT, x INT, x TEXT) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN ('0000', '0003', '0004', '0010');
CREATE TABLE x PARTITION OF x FOR VALUES IN ('0001', '0005', '0002', '0009');
CREATE TABLE x PARTITION OF x FOR VALUES IN ('0006', '0007', '0008', '0011');
INSERT INTO x SELECT x, x, TIME_TO_STR(x / 50, 'FM0000') FROM x AS x;
ANALYZE x;
CREATE TABLE x (x INT, x INT, x TEXT) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN ('0000', '0003', '0004', '0010');
CREATE TABLE x PARTITION OF x FOR VALUES IN ('0001', '0005', '0002', '0009');
CREATE TABLE x PARTITION OF x FOR VALUES IN ('0006', '0007', '0008', '0011');
INSERT INTO x SELECT x, x, TIME_TO_STR(x / 50, 'FM0000') FROM x AS x;
ANALYZE x;
/* list partitioned by expression */ CREATE TABLE x (x INT, x INT, x TEXT) WITH (PARTITIONED_BY=LIST(LTRIM(x, 'A')));
CREATE TABLE x PARTITION OF x FOR VALUES IN ('0000', '0003', '0004', '0010');
CREATE TABLE x PARTITION OF x FOR VALUES IN ('0001', '0005', '0002', '0009');
CREATE TABLE x PARTITION OF x FOR VALUES IN ('0006', '0007', '0008', '0011');
INSERT INTO x SELECT x, x, 'A' || TIME_TO_STR(x / 50, 'FM0000') FROM x AS x;
ANALYZE x;
/* test partition matching with N-way join */ EXPLAIN (COSTS OFF) SELECT avg(t1.a), avg(t2.b), avg(t3.a + t3.b), t1.c, t2.c, t3.c FROM plt1 t1, plt2 t2, plt1_e t3 WHERE t1.b = t2.b AND t1.c = t2.c AND ltrim(t3.c, 'A') = t1.c GROUP BY t1.c, t2.c, t3.c ORDER BY t1.c, t2.c, t3.c;
SELECT AVG(x.x), AVG(x.x), AVG(x.x + x.x), x.x, x.x, x.x FROM x AS x, x AS x, x AS x WHERE x.x = x.x AND x.x = x.x AND LTRIM(x.x, 'A') = x.x GROUP BY x.x, x.x, x.x ORDER BY x.x NULLS LAST, x.x NULLS LAST, x.x NULLS LAST;
/* joins where one of the relations is proven empty */ EXPLAIN (COSTS OFF) SELECT t1.a, t1.c, t2.b, t2.c FROM prt1 t1, prt2 t2 WHERE t1.a = t2.b AND t1.a = 1 AND t1.a = 2;
EXPLAIN (COSTS OFF) SELECT t1.a, t1.c, t2.b, t2.c FROM (SELECT * FROM prt1 WHERE a = 1 AND a = 2) t1 LEFT JOIN prt2 t2 ON t1.a = t2.b;
EXPLAIN (COSTS OFF) SELECT t1.a, t1.c, t2.b, t2.c FROM (SELECT * FROM prt1 WHERE a = 1 AND a = 2) t1 RIGHT JOIN prt2 t2 ON t1.a = t2.b, prt1 t3 WHERE t2.b = t3.a;
EXPLAIN (COSTS OFF) SELECT t1.a, t1.c, t2.b, t2.c FROM (SELECT * FROM prt1 WHERE a = 1 AND a = 2) t1 FULL JOIN prt2 t2 ON t1.a = t2.b WHERE t2.a = 0 ORDER BY t1.a, t2.b;
/* tests for hash partitioned tables. */ CREATE TABLE x (x INT, x INT, x TEXT) WITH (PARTITIONED_BY=HASH(x));
CREATE TABLE x PARTITION OF x FOR VALUES WITH (MODULUS 3, REMAINDER 0);
CREATE TABLE x PARTITION OF x FOR VALUES WITH (MODULUS 3, REMAINDER 1);
CREATE TABLE x PARTITION OF x FOR VALUES WITH (MODULUS 3, REMAINDER 2);
INSERT INTO x SELECT x, x, TIME_TO_STR(x / 50, 'FM0000') FROM x AS x;
ANALYZE x;
CREATE TABLE x (x INT, x INT, x TEXT) WITH (PARTITIONED_BY=HASH(x));
CREATE TABLE x PARTITION OF x FOR VALUES WITH (MODULUS 3, REMAINDER 0);
CREATE TABLE x PARTITION OF x FOR VALUES WITH (MODULUS 3, REMAINDER 1);
CREATE TABLE x PARTITION OF x FOR VALUES WITH (MODULUS 3, REMAINDER 2);
INSERT INTO x SELECT x, x, TIME_TO_STR(x / 50, 'FM0000') FROM x AS x;
ANALYZE x;
/* hash partitioned by expression */ CREATE TABLE x (x INT, x INT, x TEXT) WITH (PARTITIONED_BY=HASH(LTRIM(x, 'A')));
CREATE TABLE x PARTITION OF x FOR VALUES WITH (MODULUS 3, REMAINDER 0);
CREATE TABLE x PARTITION OF x FOR VALUES WITH (MODULUS 3, REMAINDER 1);
CREATE TABLE x PARTITION OF x FOR VALUES WITH (MODULUS 3, REMAINDER 2);
INSERT INTO x SELECT x, x, 'A' || TIME_TO_STR(x / 50, 'FM0000') FROM x AS x;
ANALYZE x;
/* test partition matching with N-way join */ EXPLAIN (COSTS OFF) SELECT avg(t1.a), avg(t2.b), avg(t3.a + t3.b), t1.c, t2.c, t3.c FROM pht1 t1, pht2 t2, pht1_e t3 WHERE t1.b = t2.b AND t1.c = t2.c AND ltrim(t3.c, 'A') = t1.c GROUP BY t1.c, t2.c, t3.c ORDER BY t1.c, t2.c, t3.c;
SELECT AVG(x.x), AVG(x.x), AVG(x.x + x.x), x.x, x.x, x.x FROM x AS x, x AS x, x AS x WHERE x.x = x.x AND x.x = x.x AND LTRIM(x.x, 'A') = x.x GROUP BY x.x, x.x, x.x ORDER BY x.x NULLS LAST, x.x NULLS LAST, x.x NULLS LAST;
/* test default partition behavior for range */ ALTER TABLE prt1 DETACH PARTITION prt1_p3;
ALTER TABLE prt1 ATTACH PARTITION prt1_p3 DEFAULT;
ANALYZE x;
ALTER TABLE prt2 DETACH PARTITION prt2_p3;
ALTER TABLE prt2 ATTACH PARTITION prt2_p3 DEFAULT;
ANALYZE x;
EXPLAIN (COSTS OFF) SELECT t1.a, t1.c, t2.b, t2.c FROM prt1 t1, prt2 t2 WHERE t1.a = t2.b AND t1.b = 0 ORDER BY t1.a, t2.b;
/* test default partition behavior for list */ ALTER TABLE plt1 DETACH PARTITION plt1_p3;
ALTER TABLE plt1 ATTACH PARTITION plt1_p3 DEFAULT;
ANALYZE x;
ALTER TABLE plt2 DETACH PARTITION plt2_p3;
ALTER TABLE plt2 ATTACH PARTITION plt2_p3 DEFAULT;
ANALYZE x;
EXPLAIN (COSTS OFF) SELECT avg(t1.a), avg(t2.b), t1.c, t2.c FROM plt1 t1 RIGHT JOIN plt2 t2 ON t1.c = t2.c WHERE t1.a % 25 = 0 GROUP BY t1.c, t2.c ORDER BY t1.c, t2.c;
/* multiple levels of partitioning */ CREATE TABLE x (x INT, x INT, x VARCHAR) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (0) TO (250);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (250) TO (500) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN ('0000', '0001');
CREATE TABLE x PARTITION OF x FOR VALUES IN ('0002', '0003');
CREATE TABLE x PARTITION OF x FOR VALUES FROM (500) TO (600) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (0) TO (13);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (13) TO (25);
INSERT INTO x SELECT x, x % 25, TIME_TO_STR(x % 4, 'FM0000') FROM x AS x;
ANALYZE x;
CREATE TABLE x (x INT, x INT, x VARCHAR) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (0) TO (250);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (250) TO (500) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN ('0000', '0001');
CREATE TABLE x PARTITION OF x FOR VALUES IN ('0002', '0003');
CREATE TABLE x PARTITION OF x FOR VALUES FROM (500) TO (600) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (0) TO (13);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (13) TO (25);
INSERT INTO x SELECT x % 25, x, TIME_TO_STR(x % 4, 'FM0000') FROM x AS x;
ANALYZE x;
/* inner join, qual covering only top-level partitions */ EXPLAIN (COSTS OFF) SELECT t1.a, t1.c, t2.b, t2.c FROM prt1_l t1, prt2_l t2 WHERE t1.a = t2.b AND t1.b = 0 ORDER BY t1.a, t2.b;
SELECT x.x, x.x, x.x, x.x FROM x AS x, x AS x WHERE x.x = x.x AND x.x = 0 ORDER BY x.x NULLS LAST, x.x NULLS LAST;
/* inner join with partially-redundant join clauses */ EXPLAIN (COSTS OFF) SELECT t1.a, t1.c, t2.b, t2.c FROM prt1_l t1, prt2_l t2 WHERE t1.a = t2.a AND t1.a = t2.b AND t1.c = t2.c ORDER BY t1.a, t2.b;
SELECT x.x, x.x, x.x, x.x FROM x AS x, x AS x WHERE x.x = x.x AND x.x = x.x AND x.x = x.x ORDER BY x.x NULLS LAST, x.x NULLS LAST;
/* left join */ EXPLAIN (COSTS OFF) SELECT t1.a, t1.c, t2.b, t2.c FROM prt1_l t1 LEFT JOIN prt2_l t2 ON t1.a = t2.b AND t1.c = t2.c WHERE t1.b = 0 ORDER BY t1.a, t2.b;
SELECT x.x, x.x, x.x, x.x FROM x AS x LEFT JOIN x AS x ON x.x = x.x AND x.x = x.x WHERE x.x = 0 ORDER BY x.x NULLS LAST, x.x NULLS LAST;
/* right join */ EXPLAIN (COSTS OFF) SELECT t1.a, t1.c, t2.b, t2.c FROM prt1_l t1 RIGHT JOIN prt2_l t2 ON t1.a = t2.b AND t1.c = t2.c WHERE t2.a = 0 ORDER BY t1.a, t2.b;
SELECT x.x, x.x, x.x, x.x FROM x AS x RIGHT JOIN x AS x ON x.x = x.x AND x.x = x.x WHERE x.x = 0 ORDER BY x.x NULLS LAST, x.x NULLS LAST;
/* full join */ EXPLAIN (COSTS OFF) SELECT t1.a, t1.c, t2.b, t2.c FROM (SELECT * FROM prt1_l WHERE prt1_l.b = 0) t1 FULL JOIN (SELECT * FROM prt2_l WHERE prt2_l.a = 0) t2 ON (t1.a = t2.b AND t1.c = t2.c) ORDER BY t1.a, t2.b;
SELECT x.x, x.x, x.x, x.x FROM (SELECT * FROM x WHERE x.x = 0) AS x FULL JOIN (SELECT * FROM x WHERE x.x = 0) AS x ON (x.x = x.x AND x.x = x.x) ORDER BY x.x NULLS LAST, x.x NULLS LAST;
/* lateral partitionwise join */ EXPLAIN (COSTS OFF) SELECT * FROM prt1_l t1 LEFT JOIN LATERAL 			  (SELECT t2.a AS t2a, t2.c AS t2c, t2.b AS t2b, t3.b AS t3b, least(t1.a,t2.a,t3.b) FROM prt1_l t2 JOIN prt2_l t3 ON (t2.a = t3.b AND t2.c = t3.c)) ss 			  ON t1.a = ss.t2a AND t1.c = ss.t2c WHERE t1.b = 0 ORDER BY t1.a;
SELECT * FROM x AS x LEFT JOIN LATERAL (SELECT x.x AS x, x.x AS x, x.x AS x, x.x AS x, LEAST(x.x, x.x, x.x) FROM x AS x JOIN x AS x ON (x.x = x.x AND x.x = x.x)) AS x ON x.x = x.x AND x.x = x.x WHERE x.x = 0 ORDER BY x.x NULLS LAST;
/* partitionwise join with lateral reference in sample scan */ EXPLAIN (COSTS OFF) SELECT * FROM prt1_l t1 JOIN LATERAL 			  (SELECT * FROM prt1_l t2 TABLESAMPLE SYSTEM (t1.a) REPEATABLE(t1.b)) s 			  ON t1.a = s.a AND t1.b = s.b AND t1.c = s.c;
/* partitionwise join with lateral reference in scan's restriction clauses */ EXPLAIN (COSTS OFF) SELECT COUNT(*) FROM prt1_l t1 LEFT JOIN LATERAL 			  (SELECT t1.b AS t1b, t2.* FROM prt2_l t2) s 			  ON t1.a = s.b AND t1.b = s.a AND t1.c = s.c 			  WHERE s.t1b = s.a;
SELECT COUNT(*) FROM x AS x LEFT JOIN LATERAL (SELECT x.x AS x, x.* FROM x AS x) AS x ON x.x = x.x AND x.x = x.x AND x.x = x.x WHERE x.x = x.x;
/* join with one side empty */ EXPLAIN (COSTS OFF) SELECT t1.a, t1.c, t2.b, t2.c FROM (SELECT * FROM prt1_l WHERE a = 1 AND a = 2) t1 RIGHT JOIN prt2_l t2 ON t1.a = t2.b AND t1.b = t2.a AND t1.c = t2.c;
/* Test case to verify proper handling of subqueries in a partitioned delete. */ /* The weird-looking lateral join is just there to force creation of a */ /* nestloop parameter within the subquery, which exposes the problem if the */ /* planner fails to make multiple copies of the subquery as appropriate. */ EXPLAIN (COSTS OFF) DELETE FROM prt1_l WHERE EXISTS (   SELECT 1     FROM int4_tbl,          LATERAL (SELECT int4_tbl.f1 FROM int8_tbl LIMIT 2) ss     WHERE prt1_l.c IS NULL);
/* negative testcases */ CREATE TABLE x (x INT, x INT, x VARCHAR) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM ('0000') TO ('0250');
CREATE TABLE x PARTITION OF x FOR VALUES FROM ('0250') TO ('0500');
INSERT INTO x SELECT x, x, TIME_TO_STR(x, 'FM0000') FROM x AS x;
ANALYZE x;
CREATE TABLE x (x INT, x INT, x TEXT) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN ('0000', '0003', '0004', '0010', '0006', '0007');
CREATE TABLE x PARTITION OF x FOR VALUES IN ('0001', '0005', '0002', '0009', '0008', '0011');
INSERT INTO x SELECT x, x, TIME_TO_STR(x / 50, 'FM0000') FROM x AS x;
ANALYZE x;
CREATE TABLE x (x INT, x INT, x TEXT) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN ('0000', '0004', '0006', '0007');
CREATE TABLE x PARTITION OF x FOR VALUES IN ('0001', '0002', '0008', '0010');
CREATE TABLE x PARTITION OF x FOR VALUES IN ('0003', '0005', '0009', '0011');
INSERT INTO x SELECT x, x, TIME_TO_STR(x / 50, 'FM0000') FROM x AS x;
ANALYZE x;
CREATE TABLE x (x INT, x INT, x TEXT) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (0) TO (300);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (300) TO (500);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (500) TO (600);
INSERT INTO x SELECT x, x, TIME_TO_STR(x, 'FM0000') FROM x AS x;
ANALYZE x;
/* partitionwise join can not be applied if the partition ranges differ */ EXPLAIN (COSTS OFF) SELECT t1.a, t1.c, t2.b, t2.c FROM prt1 t1, prt4_n t2 WHERE t1.a = t2.a;
EXPLAIN (COSTS OFF) SELECT t1.a, t1.c, t2.b, t2.c FROM prt1 t1, prt4_n t2, prt2 t3 WHERE t1.a = t2.a and t1.a = t3.b;
/* partitionwise join can not be applied if there are no equi-join conditions */ /* between partition keys */ EXPLAIN (COSTS OFF) SELECT t1.a, t1.c, t2.b, t2.c FROM prt1 t1 LEFT JOIN prt2 t2 ON (t1.a < t2.b);
/* equi-join with join condition on partial keys does not qualify for */ /* partitionwise join */ EXPLAIN (COSTS OFF) SELECT t1.a, t1.c, t2.b, t2.c FROM prt1_m t1, prt2_m t2 WHERE t1.a = (t2.b + t2.a)/2;
/* equi-join between out-of-order partition key columns does not qualify for */ /* partitionwise join */ EXPLAIN (COSTS OFF) SELECT t1.a, t1.c, t2.b, t2.c FROM prt1_m t1 LEFT JOIN prt2_m t2 ON t1.a = t2.b;
/* equi-join between non-key columns does not qualify for partitionwise join */ EXPLAIN (COSTS OFF) SELECT t1.a, t1.c, t2.b, t2.c FROM prt1_m t1 LEFT JOIN prt2_m t2 ON t1.c = t2.c;
/* partitionwise join can not be applied for a join between list and range */ /* partitioned tables */ EXPLAIN (COSTS OFF) SELECT t1.a, t1.c, t2.b, t2.c FROM prt1_n t1 LEFT JOIN prt2_n t2 ON (t1.c = t2.c);
/* partitionwise join can not be applied between tables with different */ /* partition lists */ EXPLAIN (COSTS OFF) SELECT t1.a, t1.c, t2.b, t2.c FROM prt1_n t1 JOIN prt2_n t2 ON (t1.c = t2.c) JOIN plt1 t3 ON (t1.c = t3.c);
/* partitionwise join can not be applied for a join between key column and */ /* non-key column */ EXPLAIN (COSTS OFF) SELECT t1.a, t1.c, t2.b, t2.c FROM prt1_n t1 FULL JOIN prt1 t2 ON (t1.c = t2.c);
/* Test some other plan types in a partitionwise join (unfortunately, */ /* we need larger tables to get the planner to choose these plan types) */ CREATE TEMPORARY TABLE x (x INT, x INT, x INT) WITH (PARTITIONED_BY=RANGE(x));
CREATE TEMPORARY TABLE x PARTITION OF x FOR VALUES FROM (1) TO (11);
CREATE TEMPORARY TABLE x PARTITION OF x FOR VALUES FROM (11) TO (21);
CREATE TEMPORARY TABLE x PARTITION OF x FOR VALUES FROM (21) TO (31);
CREATE TEMPORARY TABLE x (x INT, x INT, x INT) WITH (PARTITIONED_BY=RANGE(x));
CREATE TEMPORARY TABLE x PARTITION OF x FOR VALUES FROM (1) TO (11);
CREATE TEMPORARY TABLE x PARTITION OF x FOR VALUES FROM (11) TO (21);
CREATE TEMPORARY TABLE x PARTITION OF x FOR VALUES FROM (21) TO (31);
INSERT INTO x SELECT 1 + x % 30, x, x FROM x AS x;
INSERT INTO x SELECT 1 + x % 30, x, x FROM x AS x, x AS x;
CREATE INDEX ON x(x NULLS LAST);
CREATE INDEX ON x(x NULLS LAST);
ANALYZE x;
ANALYZE x;
EXPLAIN (costs off) select * from prtx1 where not exists (select 1 from prtx2                   where prtx2.a=prtx1.a and prtx2.b=prtx1.b and prtx2.c=123)   and a<20 and c=120;
SELECT * FROM x WHERE NOT EXISTS(SELECT 1 FROM x WHERE x.x = x.x AND x.x = x.x AND x.x = 123) AND x < 20 AND x = 120;
EXPLAIN (costs off) select * from prtx1 where not exists (select 1 from prtx2                   where prtx2.a=prtx1.a and (prtx2.b=prtx1.b+1 or prtx2.c=99))   and a<20 and c=91;
SELECT * FROM x WHERE NOT EXISTS(SELECT 1 FROM x WHERE x.x = x.x AND (x.x = x.x + 1 OR x.x = 99)) AND x < 20 AND x = 91;
/* Test advanced partition-matching algorithm for partitioned join */ /* Tests for range-partitioned tables */ CREATE TABLE x (x INT, x INT, x VARCHAR) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (100) TO (200);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (200) TO (300);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (300) TO (400);
CREATE INDEX x ON x(x NULLS LAST);
INSERT INTO x SELECT x, x % 25, TIME_TO_STR(x, 'FM0000') FROM x AS x;
ANALYZE x;
CREATE TABLE x (x INT, x INT, x VARCHAR) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (100) TO (150);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (200) TO (300);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (350) TO (500);
CREATE INDEX x ON x(x NULLS LAST);
INSERT INTO x SELECT x % 25, x, TIME_TO_STR(x, 'FM0000') FROM x AS x;
INSERT INTO x SELECT x % 25, x, TIME_TO_STR(x, 'FM0000') FROM x AS x;
INSERT INTO x SELECT x % 25, x, TIME_TO_STR(x, 'FM0000') FROM x AS x;
ANALYZE x;
/* inner join */ EXPLAIN (COSTS OFF) SELECT t1.a, t1.c, t2.b, t2.c FROM prt1_adv t1 INNER JOIN prt2_adv t2 ON (t1.a = t2.b) WHERE t1.b = 0 ORDER BY t1.a, t2.b;
SELECT x.x, x.x, x.x, x.x FROM x AS x INNER JOIN x AS x ON (x.x = x.x) WHERE x.x = 0 ORDER BY x.x NULLS LAST, x.x NULLS LAST;
/* semi join */ EXPLAIN (COSTS OFF) SELECT t1.* FROM prt1_adv t1 WHERE EXISTS (SELECT 1 FROM prt2_adv t2 WHERE t1.a = t2.b) AND t1.b = 0 ORDER BY t1.a;
SELECT x.* FROM x AS x WHERE EXISTS(SELECT 1 FROM x AS x WHERE x.x = x.x) AND x.x = 0 ORDER BY x.x NULLS LAST;
/* left join */ EXPLAIN (COSTS OFF) SELECT t1.a, t1.c, t2.b, t2.c FROM prt1_adv t1 LEFT JOIN prt2_adv t2 ON (t1.a = t2.b) WHERE t1.b = 0 ORDER BY t1.a, t2.b;
SELECT x.x, x.x, x.x, x.x FROM x AS x LEFT JOIN x AS x ON (x.x = x.x) WHERE x.x = 0 ORDER BY x.x NULLS LAST, x.x NULLS LAST;
/* anti join */ EXPLAIN (COSTS OFF) SELECT t1.* FROM prt1_adv t1 WHERE NOT EXISTS (SELECT 1 FROM prt2_adv t2 WHERE t1.a = t2.b) AND t1.b = 0 ORDER BY t1.a;
SELECT x.* FROM x AS x WHERE NOT EXISTS(SELECT 1 FROM x AS x WHERE x.x = x.x) AND x.x = 0 ORDER BY x.x NULLS LAST;
/* full join */ EXPLAIN (COSTS OFF) SELECT t1.a, t1.c, t2.b, t2.c FROM (SELECT 175 phv, * FROM prt1_adv WHERE prt1_adv.b = 0) t1 FULL JOIN (SELECT 425 phv, * FROM prt2_adv WHERE prt2_adv.a = 0) t2 ON (t1.a = t2.b) WHERE t1.phv = t1.a OR t2.phv = t2.b ORDER BY t1.a, t2.b;
SELECT x.x, x.x, x.x, x.x FROM (SELECT 175 AS x, * FROM x WHERE x.x = 0) AS x FULL JOIN (SELECT 425 AS x, * FROM x WHERE x.x = 0) AS x ON (x.x = x.x) WHERE x.x = x.x OR x.x = x.x ORDER BY x.x NULLS LAST, x.x NULLS LAST;
/* Test cases where one side has an extra partition */ CREATE TABLE x PARTITION OF x FOR VALUES FROM (500) TO (MAXVALUE);
INSERT INTO x SELECT x % 25, x, TIME_TO_STR(x, 'FM0000') FROM x AS x;
ANALYZE x;
/* inner join */ EXPLAIN (COSTS OFF) SELECT t1.a, t1.c, t2.b, t2.c FROM prt1_adv t1 INNER JOIN prt2_adv t2 ON (t1.a = t2.b) WHERE t1.b = 0 ORDER BY t1.a, t2.b;
SELECT x.x, x.x, x.x, x.x FROM x AS x INNER JOIN x AS x ON (x.x = x.x) WHERE x.x = 0 ORDER BY x.x NULLS LAST, x.x NULLS LAST;
/* semi join */ EXPLAIN (COSTS OFF) SELECT t1.* FROM prt1_adv t1 WHERE EXISTS (SELECT 1 FROM prt2_adv t2 WHERE t1.a = t2.b) AND t1.b = 0 ORDER BY t1.a;
SELECT x.* FROM x AS x WHERE EXISTS(SELECT 1 FROM x AS x WHERE x.x = x.x) AND x.x = 0 ORDER BY x.x NULLS LAST;
/* left join */ EXPLAIN (COSTS OFF) SELECT t1.a, t1.c, t2.b, t2.c FROM prt1_adv t1 LEFT JOIN prt2_adv t2 ON (t1.a = t2.b) WHERE t1.b = 0 ORDER BY t1.a, t2.b;
SELECT x.x, x.x, x.x, x.x FROM x AS x LEFT JOIN x AS x ON (x.x = x.x) WHERE x.x = 0 ORDER BY x.x NULLS LAST, x.x NULLS LAST;
/* anti join */ EXPLAIN (COSTS OFF) SELECT t1.* FROM prt1_adv t1 WHERE NOT EXISTS (SELECT 1 FROM prt2_adv t2 WHERE t1.a = t2.b) AND t1.b = 0 ORDER BY t1.a;
SELECT x.* FROM x AS x WHERE NOT EXISTS(SELECT 1 FROM x AS x WHERE x.x = x.x) AND x.x = 0 ORDER BY x.x NULLS LAST;
/* 3-way join where not every pair of relations can do partitioned join */ EXPLAIN (COSTS OFF) SELECT t1.b, t1.c, t2.a, t2.c, t3.a, t3.c FROM prt2_adv t1 LEFT JOIN prt1_adv t2 ON (t1.b = t2.a) INNER JOIN prt1_adv t3 ON (t1.b = t3.a) WHERE t1.a = 0 ORDER BY t1.b, t2.a, t3.a;
SELECT x.x, x.x, x.x, x.x, x.x, x.x FROM x AS x LEFT JOIN x AS x ON (x.x = x.x) INNER JOIN x AS x ON (x.x = x.x) WHERE x.x = 0 ORDER BY x.x NULLS LAST, x.x NULLS LAST, x.x NULLS LAST;
DROP TABLE x;
/* Split prt2_adv_p3 into two partitions so that prt1_adv_p3 matches both */ CREATE TABLE x PARTITION OF x FOR VALUES FROM (350) TO (375);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (375) TO (500);
INSERT INTO x SELECT x % 25, x, TIME_TO_STR(x, 'FM0000') FROM x AS x;
ANALYZE x;
/* inner join */ EXPLAIN (COSTS OFF) SELECT t1.a, t1.c, t2.b, t2.c FROM prt1_adv t1 INNER JOIN prt2_adv t2 ON (t1.a = t2.b) WHERE t1.b = 0 ORDER BY t1.a, t2.b;
/* semi join */ EXPLAIN (COSTS OFF) SELECT t1.* FROM prt1_adv t1 WHERE EXISTS (SELECT 1 FROM prt2_adv t2 WHERE t1.a = t2.b) AND t1.b = 0 ORDER BY t1.a;
/* left join */ EXPLAIN (COSTS OFF) SELECT t1.a, t1.c, t2.b, t2.c FROM prt1_adv t1 LEFT JOIN prt2_adv t2 ON (t1.a = t2.b) WHERE t1.b = 0 ORDER BY t1.a, t2.b;
/* anti join */ EXPLAIN (COSTS OFF) SELECT t1.* FROM prt1_adv t1 WHERE NOT EXISTS (SELECT 1 FROM prt2_adv t2 WHERE t1.a = t2.b) AND t1.b = 0 ORDER BY t1.a;
/* full join */ EXPLAIN (COSTS OFF) SELECT t1.a, t1.c, t2.b, t2.c FROM (SELECT 175 phv, * FROM prt1_adv WHERE prt1_adv.b = 0) t1 FULL JOIN (SELECT 425 phv, * FROM prt2_adv WHERE prt2_adv.a = 0) t2 ON (t1.a = t2.b) WHERE t1.phv = t1.a OR t2.phv = t2.b ORDER BY t1.a, t2.b;
DROP TABLE x;
DROP TABLE x;
ANALYZE x;
/* Test default partitions */ ALTER TABLE prt1_adv DETACH PARTITION prt1_adv_p1;
/* Change prt1_adv_p1 to the default partition */ ALTER TABLE prt1_adv ATTACH PARTITION prt1_adv_p1 DEFAULT;
ALTER TABLE prt1_adv DETACH PARTITION prt1_adv_p3;
ANALYZE x;
/* We can do partitioned join even if only one of relations has the default */ /* partition */ EXPLAIN (COSTS OFF) SELECT t1.a, t1.c, t2.b, t2.c FROM prt1_adv t1 INNER JOIN prt2_adv t2 ON (t1.a = t2.b) WHERE t1.b = 0 ORDER BY t1.a, t2.b;
SELECT x.x, x.x, x.x, x.x FROM x AS x INNER JOIN x AS x ON (x.x = x.x) WHERE x.x = 0 ORDER BY x.x NULLS LAST, x.x NULLS LAST;
/* Restore prt1_adv_p3 */ ALTER TABLE prt1_adv ATTACH PARTITION prt1_adv_p3 FOR VALUES FROM (300) TO (400);
ANALYZE x;
/* Restore prt2_adv_p3 */ ALTER TABLE prt2_adv ATTACH PARTITION prt2_adv_p3 FOR VALUES FROM (350) TO (500);
ANALYZE x;
/* Partitioned join can't be applied because the default partition of prt1_adv */ /* matches prt2_adv_p1 and prt2_adv_p3 */ EXPLAIN (COSTS OFF) SELECT t1.a, t1.c, t2.b, t2.c FROM prt1_adv t1 INNER JOIN prt2_adv t2 ON (t1.a = t2.b) WHERE t1.b = 0 ORDER BY t1.a, t2.b;
ALTER TABLE prt2_adv DETACH PARTITION prt2_adv_p3;
/* Change prt2_adv_p3 to the default partition */ ALTER TABLE prt2_adv ATTACH PARTITION prt2_adv_p3 DEFAULT;
ANALYZE x;
/* Partitioned join can't be applied because the default partition of prt1_adv */ /* matches prt2_adv_p1 and prt2_adv_p3 */ EXPLAIN (COSTS OFF) SELECT t1.a, t1.c, t2.b, t2.c FROM prt1_adv t1 INNER JOIN prt2_adv t2 ON (t1.a = t2.b) WHERE t1.b = 0 ORDER BY t1.a, t2.b;
DROP TABLE x;
ANALYZE x;
DROP TABLE x;
ANALYZE x;
CREATE TABLE x (x INT, x INT, x VARCHAR) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (200) TO (300);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (300) TO (400);
CREATE INDEX x ON x(x NULLS LAST);
INSERT INTO x SELECT x, x % 25, TIME_TO_STR(x, 'FM0000') FROM x AS x;
ANALYZE x;
/* 3-way join to test the default partition of a join relation */ EXPLAIN (COSTS OFF) SELECT t1.a, t1.c, t2.b, t2.c, t3.a, t3.c FROM prt1_adv t1 LEFT JOIN prt2_adv t2 ON (t1.a = t2.b) LEFT JOIN prt3_adv t3 ON (t1.a = t3.a) WHERE t1.b = 0 ORDER BY t1.a, t2.b, t3.a;
SELECT x.x, x.x, x.x, x.x, x.x, x.x FROM x AS x LEFT JOIN x AS x ON (x.x = x.x) LEFT JOIN x AS x ON (x.x = x.x) WHERE x.x = 0 ORDER BY x.x NULLS LAST, x.x NULLS LAST, x.x NULLS LAST;
DROP TABLE x;
DROP TABLE x;
DROP TABLE x;
/* Test interaction of partitioned join with partition pruning */ CREATE TABLE x (x INT, x INT, x VARCHAR) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (100) TO (200);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (200) TO (300);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (300) TO (400);
CREATE INDEX x ON x(x NULLS LAST);
INSERT INTO x SELECT x, x % 25, TIME_TO_STR(x, 'FM0000') FROM x AS x;
ANALYZE x;
CREATE TABLE x (x INT, x INT, x VARCHAR) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (100) TO (200);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (200) TO (400);
CREATE INDEX x ON x(x NULLS LAST);
INSERT INTO x SELECT x % 25, x, TIME_TO_STR(x, 'FM0000') FROM x AS x;
ANALYZE x;
EXPLAIN (COSTS OFF) SELECT t1.a, t1.c, t2.b, t2.c FROM prt1_adv t1 INNER JOIN prt2_adv t2 ON (t1.a = t2.b) WHERE t1.a < 300 AND t1.b = 0 ORDER BY t1.a, t2.b;
SELECT x.x, x.x, x.x, x.x FROM x AS x INNER JOIN x AS x ON (x.x = x.x) WHERE x.x < 300 AND x.x = 0 ORDER BY x.x NULLS LAST, x.x NULLS LAST;
DROP TABLE x;
CREATE TABLE x PARTITION OF x DEFAULT;
ANALYZE x;
CREATE TABLE x PARTITION OF x DEFAULT;
ANALYZE x;
EXPLAIN (COSTS OFF) SELECT t1.a, t1.c, t2.b, t2.c FROM prt1_adv t1 INNER JOIN prt2_adv t2 ON (t1.a = t2.b) WHERE t1.a >= 100 AND t1.a < 300 AND t1.b = 0 ORDER BY t1.a, t2.b;
SELECT x.x, x.x, x.x, x.x FROM x AS x INNER JOIN x AS x ON (x.x = x.x) WHERE x.x >= 100 AND x.x < 300 AND x.x = 0 ORDER BY x.x NULLS LAST, x.x NULLS LAST;
DROP TABLE x;
DROP TABLE x;
/* Tests for list-partitioned tables */ CREATE TABLE x (x INT, x INT, x TEXT) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN ('0001', '0003');
CREATE TABLE x PARTITION OF x FOR VALUES IN ('0004', '0006');
CREATE TABLE x PARTITION OF x FOR VALUES IN ('0008', '0009');
INSERT INTO x SELECT x, x, TIME_TO_STR(x % 10, 'FM0000') FROM x AS x WHERE x % 10 IN (1, 3, 4, 6, 8, 9);
ANALYZE x;
CREATE TABLE x (x INT, x INT, x TEXT) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN ('0002', '0003');
CREATE TABLE x PARTITION OF x FOR VALUES IN ('0004', '0006');
CREATE TABLE x PARTITION OF x FOR VALUES IN ('0007', '0009');
INSERT INTO x SELECT x, x, TIME_TO_STR(x % 10, 'FM0000') FROM x AS x WHERE x % 10 IN (2, 3, 4, 6, 7, 9);
ANALYZE x;
/* inner join */ EXPLAIN (COSTS OFF) SELECT t1.a, t1.c, t2.a, t2.c FROM plt1_adv t1 INNER JOIN plt2_adv t2 ON (t1.a = t2.a AND t1.c = t2.c) WHERE t1.b < 10 ORDER BY t1.a;
SELECT x.x, x.x, x.x, x.x FROM x AS x INNER JOIN x AS x ON (x.x = x.x AND x.x = x.x) WHERE x.x < 10 ORDER BY x.x NULLS LAST;
/* semi join */ EXPLAIN (COSTS OFF) SELECT t1.* FROM plt1_adv t1 WHERE EXISTS (SELECT 1 FROM plt2_adv t2 WHERE t1.a = t2.a AND t1.c = t2.c) AND t1.b < 10 ORDER BY t1.a;
SELECT x.* FROM x AS x WHERE EXISTS(SELECT 1 FROM x AS x WHERE x.x = x.x AND x.x = x.x) AND x.x < 10 ORDER BY x.x NULLS LAST;
/* left join */ EXPLAIN (COSTS OFF) SELECT t1.a, t1.c, t2.a, t2.c FROM plt1_adv t1 LEFT JOIN plt2_adv t2 ON (t1.a = t2.a AND t1.c = t2.c) WHERE t1.b < 10 ORDER BY t1.a;
SELECT x.x, x.x, x.x, x.x FROM x AS x LEFT JOIN x AS x ON (x.x = x.x AND x.x = x.x) WHERE x.x < 10 ORDER BY x.x NULLS LAST;
/* anti join */ EXPLAIN (COSTS OFF) SELECT t1.* FROM plt1_adv t1 WHERE NOT EXISTS (SELECT 1 FROM plt2_adv t2 WHERE t1.a = t2.a AND t1.c = t2.c) AND t1.b < 10 ORDER BY t1.a;
SELECT x.* FROM x AS x WHERE NOT EXISTS(SELECT 1 FROM x AS x WHERE x.x = x.x AND x.x = x.x) AND x.x < 10 ORDER BY x.x NULLS LAST;
/* full join */ EXPLAIN (COSTS OFF) SELECT t1.a, t1.c, t2.a, t2.c FROM plt1_adv t1 FULL JOIN plt2_adv t2 ON (t1.a = t2.a AND t1.c = t2.c) WHERE coalesce(t1.b, 0) < 10 AND coalesce(t2.b, 0) < 10 ORDER BY t1.a, t2.a;
SELECT x.x, x.x, x.x, x.x FROM x AS x FULL JOIN x AS x ON (x.x = x.x AND x.x = x.x) WHERE COALESCE(x.x, 0) < 10 AND COALESCE(x.x, 0) < 10 ORDER BY x.x NULLS LAST, x.x NULLS LAST;
/* Test cases where one side has an extra partition */ CREATE TABLE x PARTITION OF x FOR VALUES IN ('0000');
INSERT INTO x VALUES (0, 0, '0000');
ANALYZE x;
/* inner join */ EXPLAIN (COSTS OFF) SELECT t1.a, t1.c, t2.a, t2.c FROM plt1_adv t1 INNER JOIN plt2_adv t2 ON (t1.a = t2.a AND t1.c = t2.c) WHERE t1.b < 10 ORDER BY t1.a;
SELECT x.x, x.x, x.x, x.x FROM x AS x INNER JOIN x AS x ON (x.x = x.x AND x.x = x.x) WHERE x.x < 10 ORDER BY x.x NULLS LAST;
/* semi join */ EXPLAIN (COSTS OFF) SELECT t1.* FROM plt1_adv t1 WHERE EXISTS (SELECT 1 FROM plt2_adv t2 WHERE t1.a = t2.a AND t1.c = t2.c) AND t1.b < 10 ORDER BY t1.a;
SELECT x.* FROM x AS x WHERE EXISTS(SELECT 1 FROM x AS x WHERE x.x = x.x AND x.x = x.x) AND x.x < 10 ORDER BY x.x NULLS LAST;
/* left join */ EXPLAIN (COSTS OFF) SELECT t1.a, t1.c, t2.a, t2.c FROM plt1_adv t1 LEFT JOIN plt2_adv t2 ON (t1.a = t2.a AND t1.c = t2.c) WHERE t1.b < 10 ORDER BY t1.a;
SELECT x.x, x.x, x.x, x.x FROM x AS x LEFT JOIN x AS x ON (x.x = x.x AND x.x = x.x) WHERE x.x < 10 ORDER BY x.x NULLS LAST;
/* anti join */ EXPLAIN (COSTS OFF) SELECT t1.* FROM plt1_adv t1 WHERE NOT EXISTS (SELECT 1 FROM plt2_adv t2 WHERE t1.a = t2.a AND t1.c = t2.c) AND t1.b < 10 ORDER BY t1.a;
SELECT x.* FROM x AS x WHERE NOT EXISTS(SELECT 1 FROM x AS x WHERE x.x = x.x AND x.x = x.x) AND x.x < 10 ORDER BY x.x NULLS LAST;
DROP TABLE x;
/* Split plt2_adv_p2 into two partitions so that plt1_adv_p2 matches both */ CREATE TABLE x PARTITION OF x FOR VALUES IN ('0004');
CREATE TABLE x PARTITION OF x FOR VALUES IN ('0006');
INSERT INTO x SELECT x, x, TIME_TO_STR(x % 10, 'FM0000') FROM x AS x WHERE x % 10 IN (4, 6);
ANALYZE x;
/* inner join */ EXPLAIN (COSTS OFF) SELECT t1.a, t1.c, t2.a, t2.c FROM plt1_adv t1 INNER JOIN plt2_adv t2 ON (t1.a = t2.a AND t1.c = t2.c) WHERE t1.b < 10 ORDER BY t1.a;
/* semi join */ EXPLAIN (COSTS OFF) SELECT t1.* FROM plt1_adv t1 WHERE EXISTS (SELECT 1 FROM plt2_adv t2 WHERE t1.a = t2.a AND t1.c = t2.c) AND t1.b < 10 ORDER BY t1.a;
/* left join */ EXPLAIN (COSTS OFF) SELECT t1.a, t1.c, t2.a, t2.c FROM plt1_adv t1 LEFT JOIN plt2_adv t2 ON (t1.a = t2.a AND t1.c = t2.c) WHERE t1.b < 10 ORDER BY t1.a;
/* anti join */ EXPLAIN (COSTS OFF) SELECT t1.* FROM plt1_adv t1 WHERE NOT EXISTS (SELECT 1 FROM plt2_adv t2 WHERE t1.a = t2.a AND t1.c = t2.c) AND t1.b < 10 ORDER BY t1.a;
/* full join */ EXPLAIN (COSTS OFF) SELECT t1.a, t1.c, t2.a, t2.c FROM plt1_adv t1 FULL JOIN plt2_adv t2 ON (t1.a = t2.a AND t1.c = t2.c) WHERE coalesce(t1.b, 0) < 10 AND coalesce(t2.b, 0) < 10 ORDER BY t1.a, t2.a;
DROP TABLE x;
DROP TABLE x;
/* Restore plt2_adv_p2 */ ALTER TABLE plt2_adv ATTACH PARTITION plt2_adv_p2 FOR VALUES IN ('0004', '0006');
/* Test NULL partitions */ ALTER TABLE plt1_adv DETACH PARTITION plt1_adv_p1;
/* Change plt1_adv_p1 to the NULL partition */ CREATE TABLE x PARTITION OF x FOR VALUES IN (NULL, '0001', '0003');
INSERT INTO x SELECT x, x, TIME_TO_STR(x % 10, 'FM0000') FROM x AS x WHERE x % 10 IN (1, 3);
INSERT INTO x VALUES (-1, -1, NULL);
ANALYZE x;
ALTER TABLE plt2_adv DETACH PARTITION plt2_adv_p3;
/* Change plt2_adv_p3 to the NULL partition */ CREATE TABLE x PARTITION OF x FOR VALUES IN (NULL, '0007', '0009');
INSERT INTO x SELECT x, x, TIME_TO_STR(x % 10, 'FM0000') FROM x AS x WHERE x % 10 IN (7, 9);
INSERT INTO x VALUES (-1, -1, NULL);
ANALYZE x;
/* inner join */ EXPLAIN (COSTS OFF) SELECT t1.a, t1.c, t2.a, t2.c FROM plt1_adv t1 INNER JOIN plt2_adv t2 ON (t1.a = t2.a AND t1.c = t2.c) WHERE t1.b < 10 ORDER BY t1.a;
SELECT x.x, x.x, x.x, x.x FROM x AS x INNER JOIN x AS x ON (x.x = x.x AND x.x = x.x) WHERE x.x < 10 ORDER BY x.x NULLS LAST;
/* semi join */ EXPLAIN (COSTS OFF) SELECT t1.* FROM plt1_adv t1 WHERE EXISTS (SELECT 1 FROM plt2_adv t2 WHERE t1.a = t2.a AND t1.c = t2.c) AND t1.b < 10 ORDER BY t1.a;
SELECT x.* FROM x AS x WHERE EXISTS(SELECT 1 FROM x AS x WHERE x.x = x.x AND x.x = x.x) AND x.x < 10 ORDER BY x.x NULLS LAST;
/* left join */ EXPLAIN (COSTS OFF) SELECT t1.a, t1.c, t2.a, t2.c FROM plt1_adv t1 LEFT JOIN plt2_adv t2 ON (t1.a = t2.a AND t1.c = t2.c) WHERE t1.b < 10 ORDER BY t1.a;
SELECT x.x, x.x, x.x, x.x FROM x AS x LEFT JOIN x AS x ON (x.x = x.x AND x.x = x.x) WHERE x.x < 10 ORDER BY x.x NULLS LAST;
/* anti join */ EXPLAIN (COSTS OFF) SELECT t1.* FROM plt1_adv t1 WHERE NOT EXISTS (SELECT 1 FROM plt2_adv t2 WHERE t1.a = t2.a AND t1.c = t2.c) AND t1.b < 10 ORDER BY t1.a;
SELECT x.* FROM x AS x WHERE NOT EXISTS(SELECT 1 FROM x AS x WHERE x.x = x.x AND x.x = x.x) AND x.x < 10 ORDER BY x.x NULLS LAST;
/* full join */ EXPLAIN (COSTS OFF) SELECT t1.a, t1.c, t2.a, t2.c FROM plt1_adv t1 FULL JOIN plt2_adv t2 ON (t1.a = t2.a AND t1.c = t2.c) WHERE coalesce(t1.b, 0) < 10 AND coalesce(t2.b, 0) < 10 ORDER BY t1.a, t2.a;
SELECT x.x, x.x, x.x, x.x FROM x AS x FULL JOIN x AS x ON (x.x = x.x AND x.x = x.x) WHERE COALESCE(x.x, 0) < 10 AND COALESCE(x.x, 0) < 10 ORDER BY x.x NULLS LAST, x.x NULLS LAST;
DROP TABLE x;
/* Restore plt1_adv_p1 */ ALTER TABLE plt1_adv ATTACH PARTITION plt1_adv_p1 FOR VALUES IN ('0001', '0003');
/* Add to plt1_adv the extra NULL partition containing only NULL values as the */ /* key values */ CREATE TABLE x PARTITION OF x FOR VALUES IN (NULL);
INSERT INTO x VALUES (-1, -1, NULL);
ANALYZE x;
DROP TABLE x;
/* Restore plt2_adv_p3 */ ALTER TABLE plt2_adv ATTACH PARTITION plt2_adv_p3 FOR VALUES IN ('0007', '0009');
ANALYZE x;
/* inner join */ EXPLAIN (COSTS OFF) SELECT t1.a, t1.c, t2.a, t2.c FROM plt1_adv t1 INNER JOIN plt2_adv t2 ON (t1.a = t2.a AND t1.c = t2.c) WHERE t1.b < 10 ORDER BY t1.a;
SELECT x.x, x.x, x.x, x.x FROM x AS x INNER JOIN x AS x ON (x.x = x.x AND x.x = x.x) WHERE x.x < 10 ORDER BY x.x NULLS LAST;
/* Add to plt2_adv the extra NULL partition containing only NULL values as the */ /* key values */ CREATE TABLE x PARTITION OF x FOR VALUES IN (NULL);
INSERT INTO x VALUES (-1, -1, NULL);
ANALYZE x;
/* inner join */ EXPLAIN (COSTS OFF) SELECT t1.a, t1.c, t2.a, t2.c FROM plt1_adv t1 INNER JOIN plt2_adv t2 ON (t1.a = t2.a AND t1.c = t2.c) WHERE t1.b < 10 ORDER BY t1.a;
SELECT x.x, x.x, x.x, x.x FROM x AS x INNER JOIN x AS x ON (x.x = x.x AND x.x = x.x) WHERE x.x < 10 ORDER BY x.x NULLS LAST;
/* left join */ EXPLAIN (COSTS OFF) SELECT t1.a, t1.c, t2.a, t2.c FROM plt1_adv t1 LEFT JOIN plt2_adv t2 ON (t1.a = t2.a AND t1.c = t2.c) WHERE t1.b < 10 ORDER BY t1.a;
SELECT x.x, x.x, x.x, x.x FROM x AS x LEFT JOIN x AS x ON (x.x = x.x AND x.x = x.x) WHERE x.x < 10 ORDER BY x.x NULLS LAST;
/* full join */ EXPLAIN (COSTS OFF) SELECT t1.a, t1.c, t2.a, t2.c FROM plt1_adv t1 FULL JOIN plt2_adv t2 ON (t1.a = t2.a AND t1.c = t2.c) WHERE coalesce(t1.b, 0) < 10 AND coalesce(t2.b, 0) < 10 ORDER BY t1.a, t2.a;
SELECT x.x, x.x, x.x, x.x FROM x AS x FULL JOIN x AS x ON (x.x = x.x AND x.x = x.x) WHERE COALESCE(x.x, 0) < 10 AND COALESCE(x.x, 0) < 10 ORDER BY x.x NULLS LAST, x.x NULLS LAST;
/* 3-way join to test the NULL partition of a join relation */ EXPLAIN (COSTS OFF) SELECT t1.a, t1.c, t2.a, t2.c, t3.a, t3.c FROM plt1_adv t1 LEFT JOIN plt2_adv t2 ON (t1.a = t2.a AND t1.c = t2.c) LEFT JOIN plt1_adv t3 ON (t1.a = t3.a AND t1.c = t3.c) WHERE t1.b < 10 ORDER BY t1.a;
SELECT x.x, x.x, x.x, x.x, x.x, x.x FROM x AS x LEFT JOIN x AS x ON (x.x = x.x AND x.x = x.x) LEFT JOIN x AS x ON (x.x = x.x AND x.x = x.x) WHERE x.x < 10 ORDER BY x.x NULLS LAST;
DROP TABLE x;
DROP TABLE x;
/* Test default partitions */ ALTER TABLE plt1_adv DETACH PARTITION plt1_adv_p1;
/* Change plt1_adv_p1 to the default partition */ ALTER TABLE plt1_adv ATTACH PARTITION plt1_adv_p1 DEFAULT;
DROP TABLE x;
ANALYZE x;
DROP TABLE x;
ANALYZE x;
/* We can do partitioned join even if only one of relations has the default */ /* partition */ EXPLAIN (COSTS OFF) SELECT t1.a, t1.c, t2.a, t2.c FROM plt1_adv t1 INNER JOIN plt2_adv t2 ON (t1.a = t2.a AND t1.c = t2.c) WHERE t1.b < 10 ORDER BY t1.a;
SELECT x.x, x.x, x.x, x.x FROM x AS x INNER JOIN x AS x ON (x.x = x.x AND x.x = x.x) WHERE x.x < 10 ORDER BY x.x NULLS LAST;
ALTER TABLE plt2_adv DETACH PARTITION plt2_adv_p2;
/* Change plt2_adv_p2 to contain '0005' in addition to '0004' and '0006' as */ /* the key values */ CREATE TABLE x PARTITION OF x FOR VALUES IN ('0004', '0005', '0006');
INSERT INTO x SELECT x, x, TIME_TO_STR(x % 10, 'FM0000') FROM x AS x WHERE x % 10 IN (4, 5, 6);
ANALYZE x;
/* Partitioned join can't be applied because the default partition of plt1_adv */ /* matches plt2_adv_p1 and plt2_adv_p2_ext */ EXPLAIN (COSTS OFF) SELECT t1.a, t1.c, t2.a, t2.c FROM plt1_adv t1 INNER JOIN plt2_adv t2 ON (t1.a = t2.a AND t1.c = t2.c) WHERE t1.b < 10 ORDER BY t1.a;
ALTER TABLE plt2_adv DETACH PARTITION plt2_adv_p2_ext;
/* Change plt2_adv_p2_ext to the default partition */ ALTER TABLE plt2_adv ATTACH PARTITION plt2_adv_p2_ext DEFAULT;
ANALYZE x;
/* Partitioned join can't be applied because the default partition of plt1_adv */ /* matches plt2_adv_p1 and plt2_adv_p2_ext */ EXPLAIN (COSTS OFF) SELECT t1.a, t1.c, t2.a, t2.c FROM plt1_adv t1 INNER JOIN plt2_adv t2 ON (t1.a = t2.a AND t1.c = t2.c) WHERE t1.b < 10 ORDER BY t1.a;
DROP TABLE x;
/* Restore plt2_adv_p2 */ ALTER TABLE plt2_adv ATTACH PARTITION plt2_adv_p2 FOR VALUES IN ('0004', '0006');
ANALYZE x;
CREATE TABLE x (x INT, x INT, x TEXT) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN ('0004', '0006');
CREATE TABLE x PARTITION OF x FOR VALUES IN ('0007', '0009');
INSERT INTO x SELECT x, x, TIME_TO_STR(x % 10, 'FM0000') FROM x AS x WHERE x % 10 IN (4, 6, 7, 9);
ANALYZE x;
/* 3-way join to test the default partition of a join relation */ EXPLAIN (COSTS OFF) SELECT t1.a, t1.c, t2.a, t2.c, t3.a, t3.c FROM plt1_adv t1 LEFT JOIN plt2_adv t2 ON (t1.a = t2.a AND t1.c = t2.c) LEFT JOIN plt3_adv t3 ON (t1.a = t3.a AND t1.c = t3.c) WHERE t1.b < 10 ORDER BY t1.a;
SELECT x.x, x.x, x.x, x.x, x.x, x.x FROM x AS x LEFT JOIN x AS x ON (x.x = x.x AND x.x = x.x) LEFT JOIN x AS x ON (x.x = x.x AND x.x = x.x) WHERE x.x < 10 ORDER BY x.x NULLS LAST;
/* Test cases where one side has the default partition while the other side */ /* has the NULL partition */ DROP TABLE x;
/* Add the NULL partition to plt2_adv */ CREATE TABLE x PARTITION OF x FOR VALUES IN (NULL, '0001', '0003');
INSERT INTO x SELECT x, x, TIME_TO_STR(x % 10, 'FM0000') FROM x AS x WHERE x % 10 IN (1, 3);
INSERT INTO x VALUES (-1, -1, NULL);
ANALYZE x;
EXPLAIN (COSTS OFF) SELECT t1.a, t1.c, t2.a, t2.c FROM plt1_adv t1 INNER JOIN plt2_adv t2 ON (t1.a = t2.a AND t1.c = t2.c) WHERE t1.b < 10 ORDER BY t1.a;
SELECT x.x, x.x, x.x, x.x FROM x AS x INNER JOIN x AS x ON (x.x = x.x AND x.x = x.x) WHERE x.x < 10 ORDER BY x.x NULLS LAST;
DROP TABLE x;
/* Add the NULL partition that contains only NULL values as the key values */ CREATE TABLE x PARTITION OF x FOR VALUES IN (NULL);
INSERT INTO x VALUES (-1, -1, NULL);
ANALYZE x;
EXPLAIN (COSTS OFF) SELECT t1.a, t1.c, t2.a, t2.c FROM plt1_adv t1 INNER JOIN plt2_adv t2 ON (t1.a = t2.a AND t1.c = t2.c) WHERE t1.b < 10 ORDER BY t1.a;
SELECT x.x, x.x, x.x, x.x FROM x AS x INNER JOIN x AS x ON (x.x = x.x AND x.x = x.x) WHERE x.x < 10 ORDER BY x.x NULLS LAST;
DROP TABLE x;
DROP TABLE x;
DROP TABLE x;
/* Test interaction of partitioned join with partition pruning */ CREATE TABLE x (x INT, x INT, x TEXT) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN ('0001');
CREATE TABLE x PARTITION OF x FOR VALUES IN ('0002');
CREATE TABLE x PARTITION OF x FOR VALUES IN ('0003');
CREATE TABLE x PARTITION OF x FOR VALUES IN (NULL, '0004', '0005');
INSERT INTO x SELECT x, x, TIME_TO_STR(x % 10, 'FM0000') FROM x AS x WHERE x % 10 IN (1, 2, 3, 4, 5);
INSERT INTO x VALUES (-1, -1, NULL);
ANALYZE x;
CREATE TABLE x (x INT, x INT, x TEXT) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN ('0001', '0002');
CREATE TABLE x PARTITION OF x FOR VALUES IN (NULL);
CREATE TABLE x PARTITION OF x FOR VALUES IN ('0003');
CREATE TABLE x PARTITION OF x FOR VALUES IN ('0004', '0005');
INSERT INTO x SELECT x, x, TIME_TO_STR(x % 10, 'FM0000') FROM x AS x WHERE x % 10 IN (1, 2, 3, 4, 5);
INSERT INTO x VALUES (-1, -1, NULL);
ANALYZE x;
EXPLAIN (COSTS OFF) SELECT t1.a, t1.c, t2.a, t2.c FROM plt1_adv t1 INNER JOIN plt2_adv t2 ON (t1.a = t2.a AND t1.c = t2.c) WHERE t1.c IN ('0003', '0004', '0005') AND t1.b < 10 ORDER BY t1.a;
SELECT x.x, x.x, x.x, x.x FROM x AS x INNER JOIN x AS x ON (x.x = x.x AND x.x = x.x) WHERE x.x IN ('0003', '0004', '0005') AND x.x < 10 ORDER BY x.x NULLS LAST;
EXPLAIN (COSTS OFF) SELECT t1.a, t1.c, t2.a, t2.c FROM plt1_adv t1 LEFT JOIN plt2_adv t2 ON (t1.a = t2.a AND t1.c = t2.c) WHERE t1.c IS NULL AND t1.b < 10 ORDER BY t1.a;
SELECT x.x, x.x, x.x, x.x FROM x AS x LEFT JOIN x AS x ON (x.x = x.x AND x.x = x.x) WHERE x.x IS NULL AND x.x < 10 ORDER BY x.x NULLS LAST;
CREATE TABLE x PARTITION OF x DEFAULT;
ANALYZE x;
CREATE TABLE x PARTITION OF x DEFAULT;
ANALYZE x;
EXPLAIN (COSTS OFF) SELECT t1.a, t1.c, t2.a, t2.c FROM plt1_adv t1 INNER JOIN plt2_adv t2 ON (t1.a = t2.a AND t1.c = t2.c) WHERE t1.c IN ('0003', '0004', '0005') AND t1.b < 10 ORDER BY t1.a;
SELECT x.x, x.x, x.x, x.x FROM x AS x INNER JOIN x AS x ON (x.x = x.x AND x.x = x.x) WHERE x.x IN ('0003', '0004', '0005') AND x.x < 10 ORDER BY x.x NULLS LAST;
EXPLAIN (COSTS OFF) SELECT t1.a, t1.c, t2.a, t2.c FROM plt1_adv t1 LEFT JOIN plt2_adv t2 ON (t1.a = t2.a AND t1.c = t2.c) WHERE t1.c IS NULL AND t1.b < 10 ORDER BY t1.a;
SELECT x.x, x.x, x.x, x.x FROM x AS x LEFT JOIN x AS x ON (x.x = x.x AND x.x = x.x) WHERE x.x IS NULL AND x.x < 10 ORDER BY x.x NULLS LAST;
DROP TABLE x;
DROP TABLE x;
/* Test the process_outer_partition() code path */ CREATE TABLE x (x INT, x INT, x TEXT) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN ('0000', '0001', '0002');
CREATE TABLE x PARTITION OF x FOR VALUES IN ('0003', '0004');
INSERT INTO x SELECT x, x, TIME_TO_STR(x % 5, 'FM0000') FROM x AS x;
ANALYZE x;
CREATE TABLE x (x INT, x INT, x TEXT) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN ('0002');
CREATE TABLE x PARTITION OF x FOR VALUES IN ('0003', '0004');
INSERT INTO x SELECT x, x, TIME_TO_STR(x % 5, 'FM0000') FROM x AS x WHERE x % 5 IN (2, 3, 4);
ANALYZE x;
CREATE TABLE x (x INT, x INT, x TEXT) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN ('0001');
CREATE TABLE x PARTITION OF x FOR VALUES IN ('0003', '0004');
INSERT INTO x SELECT x, x, TIME_TO_STR(x % 5, 'FM0000') FROM x AS x WHERE x % 5 IN (1, 3, 4);
ANALYZE x;
/* This tests that when merging partitions from plt1_adv and plt2_adv in */ /* merge_list_bounds(), process_outer_partition() returns an already-assigned */ /* merged partition when re-called with plt1_adv_p1 for the second list value */ /* '0001' of that partition */ EXPLAIN (COSTS OFF) SELECT t1.a, t1.c, t2.a, t2.c, t3.a, t3.c FROM (plt1_adv t1 LEFT JOIN plt2_adv t2 ON (t1.c = t2.c)) FULL JOIN plt3_adv t3 ON (t1.c = t3.c) WHERE coalesce(t1.a, 0) % 5 != 3 AND coalesce(t1.a, 0) % 5 != 4 ORDER BY t1.c, t1.a, t2.a, t3.a;
SELECT x.x, x.x, x.x, x.x, x.x, x.x FROM (x AS x LEFT JOIN x AS x ON (x.x = x.x)) FULL JOIN x AS x ON (x.x = x.x) WHERE COALESCE(x.x, 0) % 5 <> 3 AND COALESCE(x.x, 0) % 5 <> 4 ORDER BY x.x NULLS LAST, x.x NULLS LAST, x.x NULLS LAST, x.x NULLS LAST;
DROP TABLE x;
DROP TABLE x;
DROP TABLE x;
/* Tests for multi-level partitioned tables */ CREATE TABLE x (x DOUBLE, x INT, x TEXT) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM ('-Infinity') TO (0) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (0) TO (10.0) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (100) TO (200);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (200) TO (300);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (300) TO (400);
CREATE TABLE x PARTITION OF x FOR VALUES IN ('0001', '0003');
CREATE TABLE x PARTITION OF x FOR VALUES IN ('0004', '0006');
CREATE TABLE x PARTITION OF x FOR VALUES IN ('0008', '0009');
INSERT INTO x SELECT -1.0, x, TIME_TO_STR(x % 10, 'FM0000') FROM x AS x WHERE x % 10 IN (1, 3, 4, 6, 8, 9);
INSERT INTO x SELECT 1.0, x, TIME_TO_STR(x % 10, 'FM0000') FROM x AS x WHERE x % 10 IN (1, 3, 4, 6, 8, 9);
ANALYZE x;
CREATE TABLE x (x DOUBLE, x INT, x TEXT) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (-10.0) TO (0) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (0) TO ('Infinity') WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (100) TO (150);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (200) TO (300);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (350) TO (500);
CREATE TABLE x PARTITION OF x FOR VALUES IN ('0002', '0003');
CREATE TABLE x PARTITION OF x FOR VALUES IN ('0004', '0006');
CREATE TABLE x PARTITION OF x FOR VALUES IN ('0007', '0009');
INSERT INTO x SELECT -1.0, x, TIME_TO_STR(x % 10, 'FM0000') FROM x AS x WHERE x % 10 IN (2, 3, 4, 6, 7, 9);
INSERT INTO x SELECT -1.0, x, TIME_TO_STR(x % 10, 'FM0000') FROM x AS x WHERE x % 10 IN (2, 3, 4, 6, 7, 9);
INSERT INTO x SELECT -1.0, x, TIME_TO_STR(x % 10, 'FM0000') FROM x AS x WHERE x % 10 IN (2, 3, 4, 6, 7, 9);
INSERT INTO x SELECT 1.0, x, TIME_TO_STR(x % 10, 'FM0000') FROM x AS x WHERE x % 10 IN (2, 3, 4, 6, 7, 9);
INSERT INTO x SELECT 1.0, x, TIME_TO_STR(x % 10, 'FM0000') FROM x AS x WHERE x % 10 IN (2, 3, 4, 6, 7, 9);
INSERT INTO x SELECT 1.0, x, TIME_TO_STR(x % 10, 'FM0000') FROM x AS x WHERE x % 10 IN (2, 3, 4, 6, 7, 9);
ANALYZE x;
EXPLAIN (COSTS OFF) SELECT t1.*, t2.* FROM alpha t1 INNER JOIN beta t2 ON (t1.a = t2.a AND t1.b = t2.b) WHERE t1.b >= 125 AND t1.b < 225 ORDER BY t1.a, t1.b;
SELECT x.*, x.* FROM x AS x INNER JOIN x AS x ON (x.x = x.x AND x.x = x.x) WHERE x.x >= 125 AND x.x < 225 ORDER BY x.x NULLS LAST, x.x NULLS LAST;
EXPLAIN (COSTS OFF) SELECT t1.*, t2.* FROM alpha t1 INNER JOIN beta t2 ON (t1.a = t2.a AND t1.c = t2.c) WHERE ((t1.b >= 100 AND t1.b < 110) OR (t1.b >= 200 AND t1.b < 210)) AND ((t2.b >= 100 AND t2.b < 110) OR (t2.b >= 200 AND t2.b < 210)) AND t1.c IN ('0004', '0009') ORDER BY t1.a, t1.b, t2.b;
SELECT x.*, x.* FROM x AS x INNER JOIN x AS x ON (x.x = x.x AND x.x = x.x) WHERE ((x.x >= 100 AND x.x < 110) OR (x.x >= 200 AND x.x < 210)) AND ((x.x >= 100 AND x.x < 110) OR (x.x >= 200 AND x.x < 210)) AND x.x IN ('0004', '0009') ORDER BY x.x NULLS LAST, x.x NULLS LAST, x.x NULLS LAST;
EXPLAIN (COSTS OFF) SELECT t1.*, t2.* FROM alpha t1 INNER JOIN beta t2 ON (t1.a = t2.a AND t1.b = t2.b AND t1.c = t2.c) WHERE ((t1.b >= 100 AND t1.b < 110) OR (t1.b >= 200 AND t1.b < 210)) AND ((t2.b >= 100 AND t2.b < 110) OR (t2.b >= 200 AND t2.b < 210)) AND t1.c IN ('0004', '0009') ORDER BY t1.a, t1.b;
SELECT x.*, x.* FROM x AS x INNER JOIN x AS x ON (x.x = x.x AND x.x = x.x AND x.x = x.x) WHERE ((x.x >= 100 AND x.x < 110) OR (x.x >= 200 AND x.x < 210)) AND ((x.x >= 100 AND x.x < 110) OR (x.x >= 200 AND x.x < 210)) AND x.x IN ('0004', '0009') ORDER BY x.x NULLS LAST, x.x NULLS LAST;
/* partitionwise join with fractional paths */ CREATE TABLE x (x BIGINT, PRIMARY KEY (x NULLS LAST)) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM ('0') TO ('1000');
CREATE TABLE x PARTITION OF x FOR VALUES FROM ('1000') TO ('2000');
/* insert data */ INSERT INTO x (x) (SELECT UNNEST(GENERATE_SERIES(0, 1999)));
ANALYZE x;
SET x = on;
EXPLAIN (COSTS OFF) SELECT x.id, y.id FROM fract_t x LEFT JOIN fract_t y USING (id) ORDER BY x.id ASC LIMIT 10;
EXPLAIN (COSTS OFF) SELECT x.id, y.id FROM fract_t x LEFT JOIN fract_t y USING (id) ORDER BY x.id DESC LIMIT 10;
/* Test Append's fractional paths */ CREATE INDEX x ON x(x NULLS LAST);
/* SeqScan might be the best choice if we need one single tuple */ EXPLAIN (COSTS OFF) SELECT * FROM pht1 p1 JOIN pht1 p2 USING (c) LIMIT 1;
/* Increase number of tuples requested and an IndexScan will be chosen */ EXPLAIN (COSTS OFF) SELECT * FROM pht1 p1 JOIN pht1 p2 USING (c) LIMIT 100;
/* If almost all the data should be fetched - prefer SeqScan */ EXPLAIN (COSTS OFF) SELECT * FROM pht1 p1 JOIN pht1 p2 USING (c) LIMIT 1000;
SET x = 1;
SET x = on;
/* Partial paths should also be smart enough to employ limits */ EXPLAIN (COSTS OFF) SELECT * FROM pht1 p1 JOIN pht1 p2 USING (c) LIMIT 100;
RESET debug_parallel_query;
/* Remove indexes from the partitioned table and its partitions */ DROP INDEX x CASCADE;
/* cleanup */ DROP TABLE x;
RESET max_parallel_workers_per_gather;
RESET enable_partitionwise_join;
BEGIN for ln in         execute format('explain (analyze, costs off, summary off, timing off, buffers off) %s',             query)     loop         ln := regexp_replace(ln, 'Maximum Storage: \d+', 'Maximum Storage: N');
COMMIT;
SET x = force_generic_plan /* Force generic plans to be used for all prepared statements in this file. */;
CREATE TABLE x (x CHAR) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x DEFAULT;
CREATE TABLE x PARTITION OF x FOR VALUES IN ('e', 'f');
CREATE TABLE x PARTITION OF x FOR VALUES IN ('a', 'd');
CREATE TABLE x PARTITION OF x FOR VALUES IN ('b', 'c');
CREATE TABLE x PARTITION OF x FOR VALUES IN ('g');
CREATE TABLE x PARTITION OF x FOR VALUES IN (NULL);
EXPLAIN (costs off) select * from lp;
EXPLAIN (costs off) select * from lp where a > 'a' and a < 'd';
EXPLAIN (costs off) select * from lp where a > 'a' and a <= 'd';
EXPLAIN (costs off) select * from lp where a = 'a';
EXPLAIN (costs off) select * from lp where 'a' = a;
/* commuted */ EXPLAIN (costs off) select * from lp where a is not null;
EXPLAIN (costs off) select * from lp where a is null;
EXPLAIN (costs off) select * from lp where a = 'a' or a = 'c';
EXPLAIN (costs off) select * from lp where a is not null and (a = 'a' or a = 'c');
EXPLAIN (costs off) select * from lp where a <> 'g';
EXPLAIN (costs off) select * from lp where a <> 'a' and a <> 'd';
EXPLAIN (costs off) select * from lp where a not in ('a', 'd');
/* collation matches the partitioning collation, pruning works */ CREATE TABLE x (x TEXT COLLATE "x") WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN ('a');
CREATE TABLE x PARTITION OF x FOR VALUES IN ('b');
CREATE TABLE x PARTITION OF x DEFAULT;
EXPLAIN (costs off) select * from coll_pruning where a collate "C" = 'a' collate "C";
/* collation doesn't match the partitioning collation, no pruning occurs */ EXPLAIN (costs off) select * from coll_pruning where a collate "POSIX" = 'a' collate "POSIX";
CREATE TABLE x (x INT, x VARCHAR) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x DEFAULT WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x DEFAULT;
CREATE TABLE x PARTITION OF x FOR VALUES IN (10);
CREATE TABLE x PARTITION OF x FOR VALUES IN (30);
CREATE TABLE x PARTITION OF x FOR VALUES IN (NULL);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (MINVALUE) TO (1);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (1) TO (10);
CREATE TABLE x PARTITION OF x DEFAULT;
CREATE TABLE x PARTITION OF x FOR VALUES IN ('ab', 'cd');
CREATE TABLE x PARTITION OF x FOR VALUES IN ('ef', 'gh');
CREATE TABLE x PARTITION OF x FOR VALUES IN (NULL, 'xy');
alter table rlp attach partition rlp3 for values from (15) to (20);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (20) TO (30) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x DEFAULT;
CREATE TABLE x PARTITION OF x FOR VALUES FROM (20) TO (25);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (25) TO (29);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (31) TO (MAXVALUE) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x DEFAULT;
CREATE TABLE x PARTITION OF x FOR VALUES FROM (31) TO (40);
EXPLAIN (costs off) select * from rlp where a < 1;
EXPLAIN (costs off) select * from rlp where 1 > a;
/* commuted */ EXPLAIN (costs off) select * from rlp where a <= 1;
EXPLAIN (costs off) select * from rlp where a = 1;
EXPLAIN (costs off) select * from rlp where a = 1::bigint;
/* same as above */ EXPLAIN (costs off) select * from rlp where a = 1::numeric;
/* no pruning */ EXPLAIN (costs off) select * from rlp where a <= 10;
EXPLAIN (costs off) select * from rlp where a > 10;
EXPLAIN (costs off) select * from rlp where a < 15;
EXPLAIN (costs off) select * from rlp where a <= 15;
EXPLAIN (costs off) select * from rlp where a > 15 and b = 'ab';
EXPLAIN (costs off) select * from rlp where a = 16;
EXPLAIN (costs off) select * from rlp where a = 16 and b in ('not', 'in', 'here');
EXPLAIN (costs off) select * from rlp where a = 16 and b < 'ab';
EXPLAIN (costs off) select * from rlp where a = 16 and b <= 'ab';
EXPLAIN (costs off) select * from rlp where a = 16 and b is null;
EXPLAIN (costs off) select * from rlp where a = 16 and b is not null;
EXPLAIN (costs off) select * from rlp where a is null;
EXPLAIN (costs off) select * from rlp where a is not null;
EXPLAIN (costs off) select * from rlp where a > 30;
EXPLAIN (costs off) select * from rlp where a = 30;
/* only default is scanned */ EXPLAIN (costs off) select * from rlp where a <= 31;
EXPLAIN (costs off) select * from rlp where a = 1 or a = 7;
EXPLAIN (costs off) select * from rlp where a = 1 or b = 'ab';
EXPLAIN (costs off) select * from rlp where a > 20 and a < 27;
EXPLAIN (costs off) select * from rlp where a = 29;
EXPLAIN (costs off) select * from rlp where a >= 29;
EXPLAIN (costs off) select * from rlp where a < 1 or (a > 20 and a < 25);
/* where clause contradicts sub-partition's constraint */ EXPLAIN (costs off) select * from rlp where a = 20 or a = 40;
EXPLAIN (costs off) select * from rlp3 where a = 20;
/* empty */ /* redundant clauses are eliminated */ EXPLAIN (costs off) select * from rlp where a > 1 and a = 10;
/* only default */ EXPLAIN (costs off) select * from rlp where a > 1 and a >=15;
/* rlp3 onwards, including default */ EXPLAIN (costs off) select * from rlp where a = 1 and a = 3;
/* empty */ EXPLAIN (costs off) select * from rlp where (a = 1 and a = 3) or (a > 1 and a = 15);
/* multi-column keys */ CREATE TABLE x (x INT, x INT, x INT) WITH (PARTITIONED_BY=RANGE(x, ABS(x), x));
CREATE TABLE x PARTITION OF x DEFAULT;
CREATE TABLE x PARTITION OF x FOR VALUES FROM (MINVALUE, MINVALUE, MINVALUE) TO (1, 1, 1);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (1, 1, 1) TO (10, 5, 10);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (10, 5, 10) TO (10, 10, 10);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (10, 10, 10) TO (10, 10, 20);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (10, 10, 20) TO (10, MAXVALUE, MAXVALUE);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (11, 1, 1) TO (20, 10, 10);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (20, 10, 10) TO (20, 20, 20);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (20, 20, 20) TO (MAXVALUE, MAXVALUE, MAXVALUE);
EXPLAIN (costs off) select * from mc3p where a = 1;
EXPLAIN (costs off) select * from mc3p where a = 1 and abs(b) < 1;
EXPLAIN (costs off) select * from mc3p where a = 1 and abs(b) = 1;
EXPLAIN (costs off) select * from mc3p where a = 1 and abs(b) = 1 and c < 8;
EXPLAIN (costs off) select * from mc3p where a = 10 and abs(b) between 5 and 35;
EXPLAIN (costs off) select * from mc3p where a > 10;
EXPLAIN (costs off) select * from mc3p where a >= 10;
EXPLAIN (costs off) select * from mc3p where a < 10;
EXPLAIN (costs off) select * from mc3p where a <= 10 and abs(b) < 10;
EXPLAIN (costs off) select * from mc3p where a = 11 and abs(b) = 0;
EXPLAIN (costs off) select * from mc3p where a = 20 and abs(b) = 10 and c = 100;
EXPLAIN (costs off) select * from mc3p where a > 20;
EXPLAIN (costs off) select * from mc3p where a >= 20;
EXPLAIN (costs off) select * from mc3p where (a = 1 and abs(b) = 1 and c = 1) or (a = 10 and abs(b) = 5 and c = 10) or (a > 11 and a < 20);
EXPLAIN (costs off) select * from mc3p where (a = 1 and abs(b) = 1 and c = 1) or (a = 10 and abs(b) = 5 and c = 10) or (a > 11 and a < 20) or a < 1;
EXPLAIN (costs off) select * from mc3p where (a = 1 and abs(b) = 1 and c = 1) or (a = 10 and abs(b) = 5 and c = 10) or (a > 11 and a < 20) or a < 1 or a = 1;
EXPLAIN (costs off) select * from mc3p where a = 1 or abs(b) = 1 or c = 1;
EXPLAIN (costs off) select * from mc3p where (a = 1 and abs(b) = 1) or (a = 10 and abs(b) = 10);
EXPLAIN (costs off) select * from mc3p where (a = 1 and abs(b) = 1) or (a = 10 and abs(b) = 9);
/* a simpler multi-column keys case */ CREATE TABLE x (x INT, x INT) WITH (PARTITIONED_BY=RANGE(x, x));
CREATE TABLE x PARTITION OF x DEFAULT;
CREATE TABLE x PARTITION OF x FOR VALUES FROM (MINVALUE, MINVALUE) TO (1, MINVALUE);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (1, MINVALUE) TO (1, 1);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (1, 1) TO (2, MINVALUE);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (2, MINVALUE) TO (2, 1);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (2, 1) TO (2, MAXVALUE);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (2, MAXVALUE) TO (MAXVALUE, MAXVALUE);
EXPLAIN (costs off) select * from mc2p where a < 2;
EXPLAIN (costs off) select * from mc2p where a = 2 and b < 1;
EXPLAIN (costs off) select * from mc2p where a > 1;
EXPLAIN (costs off) select * from mc2p where a = 1 and b > 1;
/* all partitions but the default one should be pruned */ EXPLAIN (costs off) select * from mc2p where a = 1 and b is null;
EXPLAIN (costs off) select * from mc2p where a is null and b is null;
EXPLAIN (costs off) select * from mc2p where a is null and b = 1;
EXPLAIN (costs off) select * from mc2p where a is null;
EXPLAIN (costs off) select * from mc2p where b is null;
/* boolean partitioning */ CREATE TABLE x (x BOOLEAN) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x DEFAULT;
CREATE TABLE x PARTITION OF x FOR VALUES IN ('true');
CREATE TABLE x PARTITION OF x FOR VALUES IN ('false');
INSERT INTO x VALUES (TRUE), (FALSE), (NULL);
EXPLAIN (costs off) select * from boolpart where a in (true, false);
EXPLAIN (costs off) select * from boolpart where a = false;
EXPLAIN (costs off) select * from boolpart where not a = false;
EXPLAIN (costs off) select * from boolpart where a is true or a is not true;
EXPLAIN (costs off) select * from boolpart where a is not true;
EXPLAIN (costs off) select * from boolpart where a is not true and a is not false;
EXPLAIN (costs off) select * from boolpart where a is unknown;
EXPLAIN (costs off) select * from boolpart where a is not unknown;
SELECT * FROM x WHERE x IN (TRUE, FALSE);
SELECT * FROM x WHERE x = FALSE;
SELECT * FROM x WHERE NOT x = FALSE;
SELECT * FROM x WHERE x IS TRUE OR NOT x IS TRUE;
SELECT * FROM x WHERE NOT x IS TRUE;
SELECT * FROM x WHERE NOT x IS TRUE AND NOT x IS FALSE;
/* try some other permutations with a NULL partition instead of a DEFAULT */ DELETE FROM x WHERE x IS NULL;
CREATE TABLE x PARTITION OF x FOR VALUES IN (NULL);
INSERT INTO x VALUES (NULL);
EXPLAIN (costs off) select * from boolpart where a is not true;
EXPLAIN (costs off) select * from boolpart where a is not true and a is not false;
EXPLAIN (costs off) select * from boolpart where a is not false;
EXPLAIN (costs off) select * from boolpart where a is not unknown;
SELECT * FROM x WHERE NOT x IS TRUE;
SELECT * FROM x WHERE NOT x IS TRUE AND NOT x IS FALSE;
SELECT * FROM x WHERE NOT x IS FALSE;
/* check that all partitions are pruned when faced with conflicting clauses */ EXPLAIN (costs off) select * from boolpart where a is not unknown and a is unknown;
EXPLAIN (costs off) select * from boolpart where a is false and a is unknown;
EXPLAIN (costs off) select * from boolpart where a is true and a is unknown;
/* inverse boolean partitioning - a seemingly unlikely design, but we've got */ /* code for it, so we'd better test it. */ CREATE TABLE x (x BOOLEAN) WITH (PARTITIONED_BY=LIST((NOT x)));
CREATE TABLE x PARTITION OF x DEFAULT;
CREATE TABLE x PARTITION OF x FOR VALUES IN ('true');
CREATE TABLE x PARTITION OF x FOR VALUES IN ('false');
INSERT INTO x VALUES (TRUE), (FALSE), (NULL);
EXPLAIN (costs off) select * from iboolpart where a in (true, false);
EXPLAIN (costs off) select * from iboolpart where a = false;
EXPLAIN (costs off) select * from iboolpart where not a = false;
EXPLAIN (costs off) select * from iboolpart where a is true or a is not true;
EXPLAIN (costs off) select * from iboolpart where a is not true;
EXPLAIN (costs off) select * from iboolpart where a is not true and a is not false;
EXPLAIN (costs off) select * from iboolpart where a is unknown;
EXPLAIN (costs off) select * from iboolpart where a is not unknown;
SELECT * FROM x WHERE x IN (TRUE, FALSE);
SELECT * FROM x WHERE x = FALSE;
SELECT * FROM x WHERE NOT x = FALSE;
SELECT * FROM x WHERE x IS TRUE OR NOT x IS TRUE;
SELECT * FROM x WHERE NOT x IS TRUE;
SELECT * FROM x WHERE NOT x IS TRUE AND NOT x IS FALSE;
/* Try some other permutations with a NULL partition instead of a DEFAULT */ DELETE FROM x WHERE x IS NULL;
CREATE TABLE x PARTITION OF x FOR VALUES IN (NULL);
INSERT INTO x VALUES (NULL);
/* Pruning shouldn't take place for these.  Just check the result is correct */ SELECT * FROM x WHERE NOT x IS TRUE;
SELECT * FROM x WHERE NOT x IS TRUE AND NOT x IS FALSE;
SELECT * FROM x WHERE NOT x IS FALSE;
CREATE TABLE x (x BOOLEAN, x BOOLEAN, x INT) WITH (PARTITIONED_BY=RANGE(x, x, x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM ('true', 'false', 0) TO ('true', 'false', 100);
CREATE TABLE x PARTITION OF x FOR VALUES FROM ('false', 'true', 0) TO ('false', 'true', 100);
CREATE TABLE x PARTITION OF x FOR VALUES FROM ('false', 'false', 0) TO ('false', 'false', 50);
CREATE TABLE x PARTITION OF x FOR VALUES FROM ('false', 'false', 50) TO ('false', 'false', 100);
CREATE TABLE x PARTITION OF x DEFAULT;
/* try a more complex case that's been known to trip up pruning in the past */ EXPLAIN (costs off)  select * from boolrangep where not a and not b and c = 25;
/* ensure we prune boolrangep_tf */ EXPLAIN (costs off)  select * from boolrangep where a is not true and not b and c = 25;
/* ensure we prune everything apart from boolrangep_tf and boolrangep_null */ EXPLAIN (costs off)  select * from boolrangep where a is not false and not b and c = 25;
/* test scalar-to-array operators */ CREATE TABLE x (x VARCHAR) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN ('ab');
CREATE TABLE x PARTITION OF x FOR VALUES IN ('bc');
CREATE TABLE x PARTITION OF x FOR VALUES IN ('cd');
EXPLAIN (costs off) select * from coercepart where a in ('ab', to_char(125, '999'));
EXPLAIN (costs off) select * from coercepart where a ~ any ('{ab}');
EXPLAIN (costs off) select * from coercepart where a !~ all ('{ab}');
EXPLAIN (costs off) select * from coercepart where a ~ any ('{ab,bc}');
EXPLAIN (costs off) select * from coercepart where a !~ all ('{ab,bc}');
EXPLAIN (costs off) select * from coercepart where a = any ('{ab,bc}');
EXPLAIN (costs off) select * from coercepart where a = any ('{ab,null}');
EXPLAIN (costs off) select * from coercepart where a = any (null::text[]);
EXPLAIN (costs off) select * from coercepart where a = all ('{ab}');
EXPLAIN (costs off) select * from coercepart where a = all ('{ab,bc}');
EXPLAIN (costs off) select * from coercepart where a = all ('{ab,null}');
EXPLAIN (costs off) select * from coercepart where a = all (null::text[]);
DROP TABLE x;
CREATE TABLE x (x INT, x INT) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN (-2, -1, 0, 1, 2);
CREATE TABLE x PARTITION OF x DEFAULT WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x DEFAULT;
CREATE TABLE x (x INT, x INT, x INT);
ALTER TABLE part ATTACH PARTITION part_rev FOR VALUES IN (3);
ALTER TABLE x DROP COLUMN x /* fail */;
ALTER TABLE part ATTACH PARTITION part_rev FOR VALUES IN (3);
/* now it's ok */ INSERT INTO x VALUES (-1, -1), (1, 1), (2, NULL), (NULL, -2), (NULL, NULL);
EXPLAIN (COSTS OFF) SELECT tableoid::regclass as part, a, b FROM part WHERE a IS NULL ORDER BY 1, 2, 3;
EXPLAIN (VERBOSE, COSTS OFF) SELECT * FROM part p(x) ORDER BY x;
/* some more cases */ /* pruning for partitioned table appearing inside a sub-query */ /* pruning won't work for mc3p, because some keys are Params */ EXPLAIN (costs off) select * from mc2p t1, lateral (select count(*) from mc3p t2 where t2.a = t1.b and abs(t2.b) = 1 and t2.c = 1) s where t1.a = 1;
/* pruning should work fine, because values for a prefix of keys (a, b) are */ /* available */ EXPLAIN (costs off) select * from mc2p t1, lateral (select count(*) from mc3p t2 where t2.c = t1.b and abs(t2.b) = 1 and t2.a = 1) s where t1.a = 1;
/* also here, because values for all keys are provided */ EXPLAIN (costs off) select * from mc2p t1, lateral (select count(*) from mc3p t2 where t2.a = 1 and abs(t2.b) = 1 and t2.c = 1) s where t1.a = 1;
/* pruning with clauses containing <> operator */ /* doesn't prune range partitions */ CREATE TABLE x (x INT) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (MINVALUE) TO (1);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (1) TO (2);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (2) TO (MAXVALUE);
EXPLAIN (costs off) select * from rp where a <> 1;
EXPLAIN (costs off) select * from rp where a <> 1 and a <> 2;
/* null partition should be eliminated due to strict <> clause. */ EXPLAIN (costs off) select * from lp where a <> 'a';
EXPLAIN (costs off) select * from lp where (a <> 'a' and a <> 'd') or a is null;
/* check that it also works for a partitioned table that's not root, */ /* which in this case are partitions of rlp that are themselves */ /* list-partitioned on b */ EXPLAIN (costs off) select * from rlp where a = 15 and b <> 'ab' and b <> 'cd' and b <> 'xy' and b is not null;
/* different collations for different keys with same expression */ CREATE TABLE x (x TEXT) WITH (PARTITIONED_BY=RANGE(SUBSTRING(x, 1) COLLATE "x", SUBSTRING(x, 1) COLLATE "x"));
CREATE TABLE x PARTITION OF x FOR VALUES FROM ('a', 'a') TO ('a', 'e');
CREATE TABLE x PARTITION OF x FOR VALUES FROM ('a', 'e') TO ('a', 'z');
CREATE TABLE x PARTITION OF x FOR VALUES FROM ('b', 'a') TO ('b', 'e');
/* no pruning, because no value for the leading key */ EXPLAIN (costs off) select * from coll_pruning_multi where substr(a, 1) = 'e' collate "C";
/* pruning, with a value provided for the leading key */ EXPLAIN (costs off) select * from coll_pruning_multi where substr(a, 1) = 'a' collate "POSIX";
/* pruning, with values provided for both keys */ EXPLAIN (costs off) select * from coll_pruning_multi where substr(a, 1) = 'e' collate "C" and substr(a, 1) = 'a' collate "POSIX";
/* LIKE operators don't prune */ CREATE TABLE x (x TEXT) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN ('ABC');
CREATE TABLE x PARTITION OF x FOR VALUES IN ('BCD');
EXPLAIN (costs off) select * from like_op_noprune where a like '%BC';
/* tests wherein clause value requires a cross-type comparison function */ CREATE TABLE x (x SMALLINT) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN (1);
CREATE TABLE x PARTITION OF x FOR VALUES IN (16384);
EXPLAIN (costs off) select * from lparted_by_int2 where a = 100_000_000_000_000;
CREATE TABLE x (x SMALLINT) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (1) TO (10);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (10) TO (16384);
/* all partitions pruned */ EXPLAIN (costs off) select * from rparted_by_int2 where a > 100_000_000_000_000;
CREATE TABLE x PARTITION OF x FOR VALUES FROM (16384) TO (MAXVALUE);
/* all partitions but rparted_by_int2_maxvalue pruned */ EXPLAIN (costs off) select * from rparted_by_int2 where a > 100_000_000_000_000;
/* check that AlternativeSubPlan within a pruning expression gets cleaned up */ CREATE TABLE x (x INT PRIMARY KEY) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (0) TO (1);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (1) TO (2);
EXPLAIN (costs off) select * from   (select exists (select 1 from int4_tbl tinner where f1 = touter.f1) as b    from int4_tbl touter) ss,   asptab where asptab.id > ss.b::int;
DROP TABLE x;
CREATE TABLE x PARTITION OF x FOR VALUES WITH (MODULUS 4, REMAINDER 0);
CREATE TABLE x PARTITION OF x FOR VALUES WITH (MODULUS 4, REMAINDER 3);
CREATE TABLE x PARTITION OF x FOR VALUES WITH (MODULUS 4, REMAINDER 1);
CREATE TABLE x PARTITION OF x FOR VALUES WITH (MODULUS 4, REMAINDER 2);
INSERT INTO x VALUES (NULL, NULL, 0);
INSERT INTO x VALUES (1, NULL, 1);
INSERT INTO x VALUES (1, 'xxx', 2);
INSERT INTO x VALUES (NULL, 'xxx', 3);
INSERT INTO x VALUES (2, 'xxx', 4);
INSERT INTO x VALUES (1, 'abcde', 5);
SELECT CAST(x AS REGCLASS), * FROM x ORDER BY x NULLS LAST;
/* partial keys won't prune, nor would non-equality conditions */ EXPLAIN (costs off) select * from hp where a = 1;
EXPLAIN (costs off) select * from hp where b = 'xxx';
EXPLAIN (costs off) select * from hp where a is null;
EXPLAIN (costs off) select * from hp where b is null;
EXPLAIN (costs off) select * from hp where a < 1 and b = 'xxx';
EXPLAIN (costs off) select * from hp where a <> 1 and b = 'yyy';
EXPLAIN (costs off) select * from hp where a <> 1 and b <> 'xxx';
/* pruning should work if either a value or a IS NULL clause is provided for */ /* each of the keys */ EXPLAIN (costs off) select * from hp where a is null and b is null;
EXPLAIN (costs off) select * from hp where a = 1 and b is null;
EXPLAIN (costs off) select * from hp where a = 1 and b = 'xxx';
EXPLAIN (costs off) select * from hp where a is null and b = 'xxx';
EXPLAIN (costs off) select * from hp where a = 2 and b = 'xxx';
EXPLAIN (costs off) select * from hp where a = 1 and b = 'abcde';
EXPLAIN (costs off) select * from hp where (a = 1 and b = 'abcde') or (a = 2 and b = 'xxx') or (a is null and b is null);
/* test pruning when not all the partitions exist */ DROP TABLE x;
DROP TABLE x;
EXPLAIN (costs off) select * from hp where a = 1 and b = 'abcde';
EXPLAIN (costs off) select * from hp where a = 1 and b = 'abcde' and   (c = 2 or c = 3);
DROP TABLE x;
EXPLAIN (costs off) select * from hp where a = 1 and b = 'abcde' and   (c = 2 or c = 3);
/* Test runtime partition pruning */ CREATE TABLE x (x INT NOT NULL, x INT NOT NULL) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN (2) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN (1);
CREATE TABLE x PARTITION OF x FOR VALUES IN (2);
CREATE TABLE x PARTITION OF x FOR VALUES IN (3);
CREATE TABLE x PARTITION OF x FOR VALUES IN (1) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN (1);
CREATE TABLE x PARTITION OF x FOR VALUES IN (2);
CREATE TABLE x PARTITION OF x FOR VALUES IN (3);
CREATE TABLE x PARTITION OF x FOR VALUES IN (3) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN (1);
CREATE TABLE x PARTITION OF x FOR VALUES IN (2);
CREATE TABLE x PARTITION OF x FOR VALUES IN (3);
SET x = off /* Disallow index only scans as concurrent transactions may stop visibility */ /* bits being set causing "Heap Fetches" to be unstable in the EXPLAIN ANALYZE */ /* output. */;
PREPARE ab_q1 (int, int, int) as select * from ab where a between $1 and $2 and b <= $3;
EXPLAIN (analyze, costs off, summary off, timing off, buffers off) execute ab_q1 (2, 2, 3);
EXPLAIN (analyze, costs off, summary off, timing off, buffers off) execute ab_q1 (1, 2, 3);
x AS x;
/* Runtime pruning after optimizer pruning */ PREPARE ab_q1 (int, int) as select a from ab where a between $1 and $2 and b < 3;
EXPLAIN (analyze, costs off, summary off, timing off, buffers off) execute ab_q1 (2, 2);
EXPLAIN (analyze, costs off, summary off, timing off, buffers off) execute ab_q1 (2, 4);
/* Ensure a mix of PARAM_EXTERN and PARAM_EXEC Params work together at */ /* different levels of partitioning. */ PREPARE ab_q2 (int, int) as select a from ab where a between $1 and $2 and b < (select 3);
EXPLAIN (analyze, costs off, summary off, timing off, buffers off) execute ab_q2 (2, 2);
/* As above, but swap the PARAM_EXEC Param to the first partition level */ PREPARE ab_q3 (int, int) as select a from ab where b between $1 and $2 and a < (select 3);
EXPLAIN (analyze, costs off, summary off, timing off, buffers off) execute ab_q3 (2, 2);
/* Test runtime pruning with hash partitioned tables */ /* recreate partitions dropped above */ CREATE TABLE x PARTITION OF x FOR VALUES WITH (MODULUS 4, REMAINDER 1);
CREATE TABLE x PARTITION OF x FOR VALUES WITH (MODULUS 4, REMAINDER 2);
CREATE TABLE x PARTITION OF x FOR VALUES WITH (MODULUS 4, REMAINDER 3);
/* Ensure we correctly prune unneeded partitions when there is an IS NULL qual */ PREPARE hp_q1 (text) as select * from hp where a is null and b = $1;
EXPLAIN (costs off) execute hp_q1('xxx');
x AS x;
DROP TABLE x;
/* Test a backwards Append scan */ CREATE TABLE x (x INT) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN (1);
CREATE TABLE x PARTITION OF x FOR VALUES IN (2);
CREATE TABLE x PARTITION OF x FOR VALUES IN (3);
CREATE TABLE x PARTITION OF x FOR VALUES IN (4);
INSERT INTO x SELECT UNNEST(GENERATE_SERIES(1, 4));
BEGIN;
/* Don't select an actual value out of the table as the order of the Append's */ /* subnodes may not be stable. */ DECLARE cur SCROLL CURSOR for select 1 from list_part where a > (select 1) and a < (select 4);
/* Ensure we get two rows. */ FETCH backward all from cur;
COMMIT;
BEGIN;
COMMIT;
/* Ensure pruning works using a stable function containing no Vars */ EXPLAIN (analyze, costs off, summary off, timing off, buffers off) select * from list_part where a = list_part_fn(1);
/* Ensure pruning does not take place when the function has a Var parameter */ EXPLAIN (analyze, costs off, summary off, timing off, buffers off) select * from list_part where a = list_part_fn(a);
/* Ensure pruning does not take place when the expression contains a Var. */ EXPLAIN (analyze, costs off, summary off, timing off, buffers off) select * from list_part where a = list_part_fn(1) + a;
ROLLBACK;
DROP TABLE x;
BEGIN for ln in         execute format('explain (analyze, costs off, summary off, timing off, buffers off) %s',             $1)     loop         ln := regexp_replace(ln, 'Workers Launched: \d+', 'Workers Launched: N');
x := REGEXP_REPLACE(x, 'actual rows=\d+(?:\.\d+)? loops=\d+', 'actual rows=N loops=N');
x := REGEXP_REPLACE(x, 'Rows Removed by Filter: \d+', 'Rows Removed by Filter: N');
if found then           continue;
COMMIT;
PREPARE ab_q4 (int, int) as select avg(a) from ab where a between $1 and $2 and b < 4;
SET x = 0 /* Encourage use of parallel plans */;
SET x = 0;
SET x = 0;
SET x = 2;
SELECT EXPLAIN_PARALLEL_APPEND('execute ab_q4 (2, 2)');
/* Test run-time pruning with IN lists. */ PREPARE ab_q5 (int, int, int) as select avg(a) from ab where a in($1,$2,$3) and b < 4;
SELECT EXPLAIN_PARALLEL_APPEND('execute ab_q5 (1, 1, 1)');
SELECT EXPLAIN_PARALLEL_APPEND('execute ab_q5 (2, 3, 3)');
/* Try some params whose values do not belong to any partition. */ SELECT EXPLAIN_PARALLEL_APPEND('execute ab_q5 (33, 44, 55)');
/* Test Parallel Append with PARAM_EXEC Params */ SELECT EXPLAIN_PARALLEL_APPEND('select count(*) from ab where (a = (select 1) or a = (select 3)) and b = 2');
/* Test pruning during parallel nested loop query */ CREATE TABLE x (x INT NOT NULL);
/* Insert some values we won't find in ab */ INSERT INTO x SELECT 0 FROM x;
/* and insert some values that we should find. */ INSERT INTO x VALUES (1), (1);
ANALYZE x;
CREATE INDEX x ON x(x NULLS LAST);
CREATE INDEX x ON x(x NULLS LAST);
CREATE INDEX x ON x(x NULLS LAST);
CREATE INDEX x ON x(x NULLS LAST);
CREATE INDEX x ON x(x NULLS LAST);
CREATE INDEX x ON x(x NULLS LAST);
CREATE INDEX x ON x(x NULLS LAST);
CREATE INDEX x ON x(x NULLS LAST);
CREATE INDEX x ON x(x NULLS LAST);
SET x = 0;
SET x = 0;
SET x = 0;
SELECT EXPLAIN_PARALLEL_APPEND('select avg(ab.a) from ab inner join lprt_a a on ab.a = a.a where a.a in(0, 0, 1)');
/* Ensure the same partitions are pruned when we make the nested loop */ /* parameter an Expr rather than a plain Param. */ SELECT EXPLAIN_PARALLEL_APPEND('select avg(ab.a) from ab inner join lprt_a a on ab.a = a.a + 0 where a.a in(0, 0, 1)');
INSERT INTO x VALUES (3), (3);
SELECT EXPLAIN_PARALLEL_APPEND('select avg(ab.a) from ab inner join lprt_a a on ab.a = a.a where a.a in(1, 0, 3)');
SELECT EXPLAIN_PARALLEL_APPEND('select avg(ab.a) from ab inner join lprt_a a on ab.a = a.a where a.a in(1, 0, 0)');
DELETE FROM x WHERE x = 1;
SELECT EXPLAIN_PARALLEL_APPEND('select avg(ab.a) from ab inner join lprt_a a on ab.a = a.a where a.a in(1, 0, 0)');
RESET enable_hashjoin;
RESET enable_mergejoin;
RESET enable_memoize;
RESET parallel_setup_cost;
RESET parallel_tuple_cost;
RESET min_parallel_table_scan_size;
RESET max_parallel_workers_per_gather;
/* Test run-time partition pruning with an initplan */ EXPLAIN (analyze, costs off, summary off, timing off, buffers off) select * from ab where a = (select max(a) from lprt_a) and b = (select max(a)-1 from lprt_a);
/* Test run-time partition pruning with UNION ALL parents */ EXPLAIN (analyze, costs off, summary off, timing off, buffers off) select * from (select * from ab where a = 1 union all select * from ab) ab where b = (select 1);
/* A case containing a UNION ALL with a non-partitioned child. */ EXPLAIN (analyze, costs off, summary off, timing off, buffers off) select * from (select * from ab where a = 1 union all (values(10,5)) union all select * from ab) ab where b = (select 1);
/* Another UNION ALL test, but containing a mix of exec init and exec run-time pruning. */ CREATE TABLE x (x INT, x INT);
INSERT INTO x VALUES (100, -10);
SET x = 0;
SET x = 0;
PREPARE ab_q6 as select * from ( 	select tableoid::regclass,a,b from ab union all 	select tableoid::regclass,x,y from xy_1 union all 	select tableoid::regclass,a,b from ab ) ab where a = $1 and b = (select -10);
/* Ensure the xy_1 subplan is not pruned. */ EXPLAIN (analyze, costs off, summary off, timing off, buffers off) execute ab_q6(1);
/* Ensure we see just the xy_1 row. */ EXECUTE ab_q6(100);
RESET enable_bitmapscan;
RESET enable_indexscan;
x AS x;
x AS x;
x AS x;
x AS x;
x AS x;
x AS x;
/* UPDATE on a partition subtree has been seen to have problems. */ INSERT INTO x VALUES (1, 2);
x AS x;
TRUNCATE TABLE x /* Test UPDATE where source relation has run-time pruning enabled */;
INSERT INTO x VALUES (1, 1), (1, 2), (1, 3), (2, 1);
SELECT CAST(x AS REGCLASS), * FROM x;
/* Join */ CREATE TABLE x (x INT);
INSERT INTO x VALUES (501), (505);
/* Basic table */ CREATE TABLE x (x INT) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (1) TO (501);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (501) TO (1001);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (1001) TO (2001);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (2001) TO (3001);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (3001) TO (4001);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (4001) TO (5001);
CREATE INDEX x ON x(x NULLS LAST);
CREATE INDEX x ON x(x NULLS LAST);
CREATE INDEX x ON x(x NULLS LAST);
CREATE INDEX x ON x(x NULLS LAST);
CREATE INDEX x ON x(x NULLS LAST);
CREATE INDEX x ON x(x NULLS LAST);
INSERT INTO x VALUES (10), (20), (501), (502), (505), (1001), (4500);
SET x = off;
SET x = off;
EXPLAIN (analyze, costs off, summary off, timing off, buffers off) select * from tbl1 join tprt on tbl1.col1 > tprt.col1;
EXPLAIN (analyze, costs off, summary off, timing off, buffers off) select * from tbl1 join tprt on tbl1.col1 = tprt.col1;
SELECT x.x, x.x FROM x INNER JOIN x ON x.x > x.x ORDER BY x.x NULLS LAST, x.x NULLS LAST;
SELECT x.x, x.x FROM x INNER JOIN x ON x.x = x.x ORDER BY x.x NULLS LAST, x.x NULLS LAST;
/* Multiple partitions */ INSERT INTO x VALUES (1001), (1010), (1011);
EXPLAIN (analyze, costs off, summary off, timing off, buffers off) select * from tbl1 inner join tprt on tbl1.col1 > tprt.col1;
EXPLAIN (analyze, costs off, summary off, timing off, buffers off) select * from tbl1 inner join tprt on tbl1.col1 = tprt.col1;
SELECT x.x, x.x FROM x INNER JOIN x ON x.x > x.x ORDER BY x.x NULLS LAST, x.x NULLS LAST;
SELECT x.x, x.x FROM x INNER JOIN x ON x.x = x.x ORDER BY x.x NULLS LAST, x.x NULLS LAST;
/* Last partition */ DELETE FROM x;
INSERT INTO x VALUES (4400);
EXPLAIN (analyze, costs off, summary off, timing off, buffers off) select * from tbl1 join tprt on tbl1.col1 < tprt.col1;
SELECT x.x, x.x FROM x INNER JOIN x ON x.x < x.x ORDER BY x.x NULLS LAST, x.x NULLS LAST;
/* No matching partition */ DELETE FROM x;
INSERT INTO x VALUES (10000);
EXPLAIN (analyze, costs off, summary off, timing off, buffers off) select * from tbl1 join tprt on tbl1.col1 = tprt.col1;
SELECT x.x, x.x FROM x INNER JOIN x ON x.x = x.x ORDER BY x.x NULLS LAST, x.x NULLS LAST;
/* Test with columns defined in varying orders between each level */ CREATE TABLE x (x INT NOT NULL, x INT NOT NULL, x INT NOT NULL) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x (x INT NOT NULL, x INT NOT NULL, x INT NOT NULL) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x (x INT NOT NULL, x INT NOT NULL, x INT NOT NULL) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x (x INT NOT NULL, x INT NOT NULL, x INT NOT NULL);
alter table part_abc attach partition part_bac for values in(1);
alter table part_bac attach partition part_cab for values in(2);
alter table part_cab attach partition part_abc_p1 for values in(3);
PREPARE part_abc_q1 (int, int, int) as select * from part_abc where a = $1 and b = $2 and c = $3;
/* Single partition should be scanned. */ EXPLAIN (analyze, costs off, summary off, timing off, buffers off) execute part_abc_q1 (1, 2, 3);
x AS x;
DROP TABLE x;
/* Ensure that an Append node properly handles a sub-partitioned table */ /* matching without any of its leaf partitions matching the clause. */ CREATE TABLE x (x INT, x INT) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN (1) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN (1);
CREATE TABLE x PARTITION OF x FOR VALUES IN (2) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN (2);
SELECT * FROM x WHERE x = 1;
/* Ensure that an Append node properly can handle selection of all first level */ /* partitions before finally detecting the correct set of 2nd level partitions */ /* which match the given parameter. */ PREPARE q1 (int,int) as select * from listp where b in ($1,$2);
EXPLAIN (analyze, costs off, summary off, timing off, buffers off)  execute q1 (1,1);
EXPLAIN (analyze, costs off, summary off, timing off, buffers off)  execute q1 (2,2);
/* Try with no matching partitions. */ EXPLAIN (analyze, costs off, summary off, timing off, buffers off)  execute q1 (0,0);
x AS x;
/* Test more complex cases where a not-equal condition further eliminates partitions. */ PREPARE q1 (int,int,int,int) as select * from listp where b in($1,$2) and $3 <> b and $4 <> b;
/* Both partitions allowed by IN clause, but one disallowed by <> clause */ EXPLAIN (analyze, costs off, summary off, timing off, buffers off)  execute q1 (1,2,2,0);
/* Both partitions allowed by IN clause, then both excluded again by <> clauses. */ EXPLAIN (analyze, costs off, summary off, timing off, buffers off)  execute q1 (1,2,2,1);
/* Ensure Params that evaluate to NULL properly prune away all partitions */ EXPLAIN (analyze, costs off, summary off, timing off, buffers off) select * from listp where a = (select null::int);
DROP TABLE x;
/* check that stable query clauses are only used in run-time pruning */ CREATE TABLE x (x TIMESTAMP) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM ('2000-01-01') TO ('2000-02-01');
CREATE TABLE x PARTITION OF x FOR VALUES FROM ('2000-02-01') TO ('2000-03-01');
CREATE TABLE x PARTITION OF x FOR VALUES FROM ('3000-02-01') TO ('3000-03-01');
/* comparison against a stable value requires run-time pruning */ EXPLAIN (analyze, costs off, summary off, timing off, buffers off) select * from stable_qual_pruning where a < localtimestamp;
/* timestamp < timestamptz comparison is only stable, not immutable */ EXPLAIN (analyze, costs off, summary off, timing off, buffers off) select * from stable_qual_pruning where a < '2000-02-01'::timestamptz;
/* check ScalarArrayOp cases */ EXPLAIN (analyze, costs off, summary off, timing off, buffers off) select * from stable_qual_pruning   where a = any(array['2010-02-01', '2020-01-01']::timestamp[]);
EXPLAIN (analyze, costs off, summary off, timing off, buffers off) select * from stable_qual_pruning   where a = any(array['2000-02-01', '2010-01-01']::timestamp[]);
EXPLAIN (analyze, costs off, summary off, timing off, buffers off) select * from stable_qual_pruning   where a = any(array['2000-02-01', localtimestamp]::timestamp[]);
EXPLAIN (analyze, costs off, summary off, timing off, buffers off) select * from stable_qual_pruning   where a = any(array['2010-02-01', '2020-01-01']::timestamptz[]);
EXPLAIN (analyze, costs off, summary off, timing off, buffers off) select * from stable_qual_pruning   where a = any(array['2000-02-01', '2010-01-01']::timestamptz[]);
EXPLAIN (analyze, costs off, summary off, timing off, buffers off) select * from stable_qual_pruning   where a = any(null::timestamptz[]);
DROP TABLE x;
/* Check that pruning with composite range partitioning works correctly when */ /* it must ignore clauses for trailing keys once it has seen a clause with */ /* non-inclusive operator for an earlier key */ CREATE TABLE x (x INT, x INT, x INT) WITH (PARTITIONED_BY=RANGE(x, ABS(x), x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (0, 0, 0) TO (0, MAXVALUE, MAXVALUE);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (1, 1, 1) TO (2, MINVALUE, MINVALUE);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (2, MINVALUE, MINVALUE) TO (3, MAXVALUE, MAXVALUE);
INSERT INTO x VALUES (0, 1, 1), (1, 1, 1), (2, 1, 1);
EXPLAIN (analyze, costs off, summary off, timing off, buffers off) select * from mc3p where a < 3 and abs(b) = 1;
/* Check that pruning with composite range partitioning works correctly when */ /* a combination of runtime parameters is specified, not all of whose values */ /* are available at the same time */ PREPARE ps1 as   select * from mc3p where a = $1 and abs(b) < (select 3);
EXPLAIN (analyze, costs off, summary off, timing off, buffers off) execute ps1(1);
x AS x;
PREPARE ps2 as   select * from mc3p where a <= $1 and abs(b) < (select 3);
EXPLAIN (analyze, costs off, summary off, timing off, buffers off) execute ps2(1);
x AS x;
DROP TABLE x;
/* Ensure runtime pruning works with initplans params with boolean types */ CREATE TABLE x (x BOOLEAN NOT NULL);
INSERT INTO x VALUES ('t'), ('f');
CREATE TABLE x (x BOOLEAN) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN ('t');
CREATE TABLE x PARTITION OF x FOR VALUES IN ('f');
EXPLAIN (analyze, costs off, summary off, timing off, buffers off) select * from boolp where a = (select value from boolvalues where value);
EXPLAIN (analyze, costs off, summary off, timing off, buffers off) select * from boolp where a = (select value from boolvalues where not value);
DROP TABLE x;
SET x = off /* Test run-time pruning of MergeAppend subnodes */;
SET x = off;
CREATE TABLE x (x INT, x INT) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (0) TO (10);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (10) TO (20);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (20) TO (30);
INSERT INTO x SELECT x, x FROM x AS x;
CREATE INDEX ON x(x NULLS LAST);
ANALYZE x;
PREPARE mt_q1 (int) as select a from ma_test where a >= $1 and a % 10 = 5 order by b;
EXPLAIN (analyze, costs off, summary off, timing off, buffers off) execute mt_q1(15);
EXECUTE mt_q1(15);
EXPLAIN (analyze, costs off, summary off, timing off, buffers off) execute mt_q1(25);
EXECUTE mt_q1(25);
/* Ensure MergeAppend behaves correctly when no subplans match */ EXPLAIN (analyze, costs off, summary off, timing off, buffers off) execute mt_q1(35);
EXECUTE mt_q1(35);
x AS x;
PREPARE mt_q2 (int) as select * from ma_test where a >= $1 order by b limit 1;
/* Ensure output list looks sane when the MergeAppend has no subplans. */ EXPLAIN (analyze, verbose, costs off, summary off, timing off, buffers off) execute mt_q2 (35);
x AS x;
/* ensure initplan params properly prune partitions */ EXPLAIN (analyze, costs off, summary off, timing off, buffers off) select * from ma_test where a >= (select min(b) from ma_test_p2) order by b;
RESET enable_seqscan;
RESET enable_sort;
DROP TABLE x;
RESET enable_indexonlyscan;
/* check that pruning works properly when the partition key is of a */ /* pseudotype */ /* array type list partition key */ CREATE TABLE x (x ARRAY<INT>) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN ('{1}');
CREATE TABLE x PARTITION OF x FOR VALUES IN ('{2, 3}', '{4, 5}');
EXPLAIN (costs off) select * from pp_arrpart where a = '{1}';
EXPLAIN (costs off) select * from pp_arrpart where a = '{1, 2}';
EXPLAIN (costs off) select * from pp_arrpart where a in ('{4, 5}', '{1}');
EXPLAIN (costs off) update pp_arrpart set a = a where a = '{1}';
EXPLAIN (costs off) delete from pp_arrpart where a = '{1}';
DROP TABLE x;
/* array type hash partition key */ CREATE TABLE x (x ARRAY<INT>) WITH (PARTITIONED_BY=HASH(x));
CREATE TABLE x PARTITION OF x FOR VALUES WITH (MODULUS 2, REMAINDER 0);
CREATE TABLE x PARTITION OF x FOR VALUES WITH (MODULUS 2, REMAINDER 1);
INSERT INTO x VALUES ('{1}'), ('{1, 2}'), ('{4, 5}');
SELECT CAST(x AS REGCLASS), * FROM x ORDER BY 1 NULLS LAST;
EXPLAIN (costs off) select * from pph_arrpart where a = '{1}';
EXPLAIN (costs off) select * from pph_arrpart where a = '{1, 2}';
EXPLAIN (costs off) select * from pph_arrpart where a in ('{4, 5}', '{1}');
DROP TABLE x;
/* enum type list partition key */ create type pp_colors as enum ('green', 'blue', 'black');
CREATE TABLE x (x pp_colors) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN ('green');
CREATE TABLE x PARTITION OF x FOR VALUES IN ('blue');
EXPLAIN (costs off) select * from pp_enumpart where a = 'blue';
EXPLAIN (costs off) select * from pp_enumpart where a = 'black';
DROP TABLE x;
drop type pp_colors;
/* record type as partition key */ create type pp_rectype as (a int, b int);
CREATE TABLE x (x pp_rectype) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN ('(1,1)');
CREATE TABLE x PARTITION OF x FOR VALUES IN ('(2,3)');
EXPLAIN (costs off) select * from pp_recpart where a = '(1,1)'::pp_rectype;
EXPLAIN (costs off) select * from pp_recpart where a = '(1,2)'::pp_rectype;
DROP TABLE x;
drop type pp_rectype;
/* range type partition key */ CREATE TABLE x (x INT4RANGE) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN ('[1,2]');
CREATE TABLE x PARTITION OF x FOR VALUES IN ('[2,)');
EXPLAIN (costs off) select * from pp_intrangepart where a = '[1,2]'::int4range;
EXPLAIN (costs off) select * from pp_intrangepart where a = '(1,2)'::int4range;
DROP TABLE x;
/* Ensure the enable_partition_prune GUC properly disables partition pruning. */ CREATE TABLE x (x INT, x INT) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN (1);
CREATE TABLE x PARTITION OF x FOR VALUES IN (2);
EXPLAIN (costs off) select * from pp_lp where a = 1;
EXPLAIN (costs off) update pp_lp set value = 10 where a = 1;
EXPLAIN (costs off) delete from pp_lp where a = 1;
SET x = off;
SET x = 'partition';
/* this should not affect the result. */ EXPLAIN (costs off) select * from pp_lp where a = 1;
EXPLAIN (costs off) update pp_lp set value = 10 where a = 1;
EXPLAIN (costs off) delete from pp_lp where a = 1;
SET x = 'off';
/* this should not affect the result. */ EXPLAIN (costs off) select * from pp_lp where a = 1;
EXPLAIN (costs off) update pp_lp set value = 10 where a = 1;
EXPLAIN (costs off) delete from pp_lp where a = 1;
DROP TABLE x;
/* Ensure enable_partition_prune does not affect non-partitioned tables. */ CREATE TABLE x (x INT, x INT);
CREATE TABLE x (x INT, x INT, CHECK (x = 1)) INHERITS (x);
CREATE TABLE x (x INT, x INT, CHECK (x = 2)) INHERITS (x);
SET x = 'partition';
/* inh_lp2 should be removed in the following 3 cases. */ EXPLAIN (costs off) select * from inh_lp where a = 1;
EXPLAIN (costs off) update inh_lp set value = 10 where a = 1;
EXPLAIN (costs off) delete from inh_lp where a = 1;
/* Ensure we don't exclude normal relations when we only expect to exclude */ /* inheritance children */ EXPLAIN (costs off) update inh_lp1 set value = 10 where a = 2;
DROP TABLE x CASCADE;
RESET enable_partition_pruning;
RESET constraint_exclusion;
/* Check pruning for a partition tree containing only temporary relations */ CREATE TEMPORARY TABLE x (x INT) WITH (PARTITIONED_BY=LIST(x));
CREATE TEMPORARY TABLE x PARTITION OF x FOR VALUES IN (1);
CREATE TEMPORARY TABLE x PARTITION OF x DEFAULT;
EXPLAIN (costs off) select * from pp_temp_parent where true;
EXPLAIN (costs off) select * from pp_temp_parent where a = 2;
DROP TABLE x;
/* Stress run-time partition pruning a bit more, per bug reports */ CREATE TEMPORARY TABLE x (x INT, x INT, x INT) WITH (PARTITIONED_BY=LIST(x));
CREATE TEMPORARY TABLE x PARTITION OF x FOR VALUES IN (1);
CREATE TEMPORARY TABLE x PARTITION OF x FOR VALUES IN (2);
CREATE TEMPORARY TABLE x (x INT, x INT, x INT) WITH (PARTITIONED_BY=LIST(x));
CREATE TEMPORARY TABLE x PARTITION OF x FOR VALUES IN (1) WITH (PARTITIONED_BY=LIST(x));
CREATE TEMPORARY TABLE x PARTITION OF x FOR VALUES IN (1) WITH (PARTITIONED_BY=LIST(x));
CREATE TEMPORARY TABLE x PARTITION OF x FOR VALUES IN (1);
CREATE TEMPORARY TABLE x PARTITION OF x FOR VALUES IN (2) WITH (PARTITIONED_BY=LIST(x));
CREATE TEMPORARY TABLE x PARTITION OF x FOR VALUES IN (1);
CREATE TEMPORARY TABLE x PARTITION OF x FOR VALUES IN (2);
INSERT INTO x VALUES (2, 2, 3);
EXPLAIN (costs off) select * from (       select * from p       union all       select * from q1       union all       select 1, 1, 1      ) s(a, b, c) where s.a = 1 and s.b = 1 and s.c = (select 1);
SELECT * FROM (SELECT * FROM x UNION ALL SELECT * FROM x UNION ALL SELECT 1, 1, 1) AS x WHERE x.x = 1 AND x.x = 1 AND x.x = (SELECT 1);
PREPARE q (int, int) as select * from (       select * from p       union all       select * from q1       union all       select 1, 1, 1      ) s(a, b, c) where s.a = $1 and s.b = $2 and s.c = (select 1);
EXPLAIN (costs off) execute q (1, 1);
EXECUTE q (1, 1);
/* Ensure run-time pruning works correctly when we match a partitioned table */ /* on the first level but find no matching partitions on the second level. */ CREATE TABLE x (x INT, x INT) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN (1);
CREATE TABLE x PARTITION OF x FOR VALUES IN (2) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN (10);
EXPLAIN (analyze, costs off, summary off, timing off, buffers off) select * from listp where a = (select 2) and b <> 10;
SET x = off /* check that a partition directly accessed in a query is excluded with */ /* constraint_exclusion = on */ /* turn off partition pruning, so that it doesn't interfere */;
SET x = 'partition' /* setting constraint_exclusion to 'partition' disables exclusion */;
EXPLAIN (costs off) select * from listp1 where a = 2;
EXPLAIN (costs off) update listp1 set a = 1 where a = 2;
SET x = 'on' /* constraint exclusion enabled */;
EXPLAIN (costs off) select * from listp1 where a = 2;
EXPLAIN (costs off) update listp1 set a = 1 where a = 2;
RESET constraint_exclusion;
RESET enable_partition_pruning;
DROP TABLE x;
SET x = 0 /* Ensure run-time pruning works correctly for nested Append nodes */;
SET x = 0;
CREATE TABLE x (x INT) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN (1, 2) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN (1);
CREATE TABLE x PARTITION OF x FOR VALUES IN (2);
ALTER TABLE x SET x = 0 /* Force the 2nd subnode of the Append to be non-parallel.  This results in */ /* a nested Append node because the mixed parallel / non-parallel paths cannot */ /* be pulled into the top-level Append. */;
DROP TABLE x;
RESET parallel_tuple_cost;
RESET parallel_setup_cost;
SET x = 0 /* Test case for run-time pruning with a nested Merge Append */;
CREATE TABLE x (x INT, x INT) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (0) TO (100) WITH (PARTITIONED_BY=LIST(x));
/* We need 3 sub-partitions. 1 to validate pruning worked and another two */ /* because a single remaining partition would be pulled up to the main Append. */ CREATE TABLE x PARTITION OF x FOR VALUES IN (1);
CREATE TABLE x PARTITION OF x FOR VALUES IN (2);
CREATE TABLE x PARTITION OF x FOR VALUES IN (3);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (100) TO (200);
CREATE INDEX ON x(x NULLS LAST);
/* Ensure run-time pruning works on the nested Merge Append */ EXPLAIN (analyze on, costs off, timing off, summary off, buffers off) select * from rangep where b IN((select 1),(select 2)) order by a;
RESET enable_sort;
DROP TABLE x;
/* Check that gen_prune_steps_from_opexps() works well for various cases of */ /* clauses for different partition keys */ CREATE TABLE x (x INT, x VARCHAR) WITH (PARTITIONED_BY=RANGE(x, x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (1, 'a') TO (1, 'b');
CREATE TABLE x PARTITION OF x FOR VALUES FROM (2, 'a') TO (2, 'b');
/* Don't call get_steps_using_prefix() with the last partition key b plus */ /* an empty prefix */ EXPLAIN (costs off) select * from rp_prefix_test1 where a <= 1 and b = 'a';
CREATE TABLE x (x INT, x INT, x INT) WITH (PARTITIONED_BY=RANGE(x, x, x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (1, 1, 0) TO (1, 1, 10);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (2, 2, 0) TO (2, 2, 10);
/* Don't call get_steps_using_prefix() with the last partition key c plus */ /* an invalid prefix (ie, b = 1) */ EXPLAIN (costs off) select * from rp_prefix_test2 where a <= 1 and b = 1 and c >= 0;
CREATE TABLE x (x INT, x INT, x INT, x INT) WITH (PARTITIONED_BY=RANGE(x, x, x, x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (1, 1, 1, 0) TO (1, 1, 1, 10);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (2, 2, 2, 0) TO (2, 2, 2, 10);
/* Test that get_steps_using_prefix() handles a prefix that contains multiple */ /* clauses for the partition key b (ie, b >= 1 and b >= 2) */ EXPLAIN (costs off) select * from rp_prefix_test3 where a >= 1 and b >= 1 and b >= 2 and c >= 2 and d >= 0;
/* Test that get_steps_using_prefix() handles a prefix that contains multiple */ /* clauses for the partition key b (ie, b >= 1 and b = 2)  (This also tests */ /* that the caller arranges clauses in that prefix in the required order) */ EXPLAIN (costs off) select * from rp_prefix_test3 where a >= 1 and b >= 1 and b = 2 and c = 2 and d >= 0;
DROP TABLE x;
DROP TABLE x;
DROP TABLE x;
create operator class part_test_int4_ops2 for type int4 using hash as operator 1 ===, function 2 part_hashint4_noop(int4, int8);
CREATE TABLE x PARTITION OF x FOR VALUES WITH (MODULUS 2, REMAINDER 0);
CREATE TABLE x PARTITION OF x FOR VALUES WITH (MODULUS 2, REMAINDER 1);
EXPLAIN (costs off) select * from hp_contradict_test where a is null and a === 1 and b === 1;
EXPLAIN (costs off) select * from hp_contradict_test where a === 1 and b === 1 and a is null;
DROP TABLE x;
drop operator class part_test_int4_ops2 using hash;
drop operator ===(int4, int4);
DROP FUNCTION x (TEXT);
/* Runtime pruning on UPDATE using WITH CHECK OPTIONS and RETURNING */ CREATE TABLE x (x INT, x TEXT, x BOOLEAN) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x (x TEXT, x INT, x BOOLEAN);
CREATE TABLE x (x INT, x BOOLEAN, x TEXT);
alter table part_abc attach partition part_abc_1 for values in (1);
alter table part_abc attach partition part_abc_2 for values in (2);
INSERT INTO x VALUES (1, 'b', TRUE);
INSERT INTO x VALUES (2, 'c', TRUE);
create view part_abc_view as select * from part_abc where b <> 'a' with check option;
PREPARE update_part_abc_view as update part_abc_view set b = $2 where a = $1 returning *;
/* Only the unpruned partition should be shown in the list of relations to be */ /* updated */ EXPLAIN (costs off) execute update_part_abc_view (1, 'd');
EXECUTE update_part_abc_view (1, 'd');
EXPLAIN (costs off) execute update_part_abc_view (2, 'a');
EXECUTE update_part_abc_view (2, 'a');
/* All pruned. */ EXPLAIN (costs off) execute update_part_abc_view (3, 'a');
EXECUTE update_part_abc_view (3, 'a');
x AS x;
COMMIT;
EXPLAIN (costs off) merge into part_abc_view pt using (select stable_one() as pid) as q join part_abc_1 pt1 on (q.pid = pt1.a) on pt.a = pt1.a when matched then delete returning pt.a;
x AS x;
/* All pruned. */ EXPLAIN (costs off) merge into part_abc_view pt using (select stable_one() + 2 as pid) as q join part_abc_1 pt1 on (q.pid = pt1.a) on pt.a = pt1.a when matched then delete returning pt.a;
x AS x;
/* A case with nested MergeAppend with its own PartitionPruneInfo. */ CREATE INDEX ON x(x NULLS LAST);
ALTER TABLE x ADD COLUMN x INT;
CREATE TABLE x PARTITION OF x FOR VALUES IN (3, 4) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (MINVALUE) TO (1);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (1) TO (100);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (100) TO (MAXVALUE);
EXPLAIN (costs off) select min(a) over (partition by a order by a) from part_abc where a >= stable_one() + 1 and d <= stable_one() union all select min(a) over (partition by a order by a) from part_abc where a >= stable_one() + 1 and d >= stable_one();
DROP VIEW x;
DROP TABLE x;
SET x = 'novalue' /* Tests for password types */ /* Tests for GUC password_encryption */;
SET x = TRUE /* error */;
SET x = 'md5' /* error */;
SET x = 'scram-sha-256' /* ok */;
SET x = 'md5' /* ok */ /* consistency of password entries */;
CREATE ROLE regress_passwd1;
ALTER ROLE regress_passwd1 PASSWORD 'role_pwd1';
CREATE ROLE regress_passwd2;
ALTER ROLE regress_passwd2 PASSWORD 'role_pwd2';
SET x = 'scram-sha-256';
CREATE ROLE regress_passwd3 PASSWORD 'role_pwd3';
CREATE ROLE regress_passwd4 PASSWORD NULL;
/* check list of created entries */ /* The scram secret will look something like: */ /* SCRAM-SHA-256$4096:E4HxLGtnRzsYwg==$6YtlR4t69SguDiwFvbVgVZtuz6gpJQQqUMZ7IQJK5yI=:ps75jrHeYU4lXCcXI4O8oIdJ3eO8o2jirjruw9phBTo= */ /* Since the salt is random, the exact value stored will be different on every test */ /* run. Use a regular expression to mask the changing parts. */ SELECT x, REGEXP_REPLACE(x, '(SCRAM-SHA-256)\$(\d+):([a-zA-Z0-9+/=]+)\$([a-zA-Z0-9+=/]+):([a-zA-Z0-9+/=]+)', '\1$\2:<salt>$<storedkey>:<serverkey>') AS x FROM x WHERE x LIKE 'regress_passwd%' ORDER BY x NULLS LAST, x NULLS LAST;
/* Rename a role */ ALTER ROLE regress_passwd2 RENAME TO regress_passwd2_new;
/* md5 entry should have been removed */ SELECT x, x FROM x WHERE x LIKE 'regress_passwd2_new' ORDER BY x NULLS LAST, x NULLS LAST;
ALTER ROLE regress_passwd2_new RENAME TO regress_passwd2;
SET x = 'md5' /* Change passwords with ALTER USER. With plaintext or already-encrypted */ /* passwords. */;
/* encrypt with MD5 */ ALTER ROLE regress_passwd2 PASSWORD 'foo';
/* already encrypted, use as they are */ ALTER ROLE regress_passwd1 PASSWORD 'md5cd3578025fe2c3d7ed1b9a9b26238b70';
ALTER ROLE regress_passwd3 PASSWORD 'SCRAM-SHA-256$4096:VLK4RMaQLCvNtQ==$6YtlR4t69SguDiwFvbVgVZtuz6gpJQQqUMZ7IQJK5yI=:ps75jrHeYU4lXCcXI4O8oIdJ3eO8o2jirjruw9phBTo=';
SET x = 'scram-sha-256';
/* create SCRAM secret */ ALTER ROLE  regress_passwd4 PASSWORD 'foo';
/* already encrypted with MD5, use as it is */ CREATE ROLE regress_passwd5 PASSWORD 'md5e73a4b11df52a6068f8b39f90be36023';
/* This looks like a valid SCRAM-SHA-256 secret, but it is not */ /* so it should be hashed with SCRAM-SHA-256. */ CREATE ROLE regress_passwd6 PASSWORD 'SCRAM-SHA-256$1234';
/* These may look like valid MD5 secrets, but they are not, so they */ /* should be hashed with SCRAM-SHA-256. */ /* trailing garbage at the end */ CREATE ROLE regress_passwd7 PASSWORD 'md5012345678901234567890123456789zz';
/* invalid length */ CREATE ROLE regress_passwd8 PASSWORD 'md501234567890123456789012345678901zz';
SET x = 1024 /* Changing the SCRAM iteration count */;
CREATE ROLE regress_passwd9 PASSWORD 'alterediterationcount';
SELECT x, REGEXP_REPLACE(x, '(SCRAM-SHA-256)\$(\d+):([a-zA-Z0-9+/=]+)\$([a-zA-Z0-9+=/]+):([a-zA-Z0-9+/=]+)', '\1$\2:<salt>$<storedkey>:<serverkey>') AS x FROM x WHERE x LIKE 'regress_passwd%' ORDER BY x NULLS LAST, x NULLS LAST;
/* An empty password is not allowed, in any form */ CREATE ROLE regress_passwd_empty PASSWORD '';
ALTER ROLE regress_passwd_empty PASSWORD 'md585939a5ce845f1a1b620742e3c659e0a';
ALTER ROLE regress_passwd_empty PASSWORD 'SCRAM-SHA-256$4096:hpFyHTUsSWcR7O9P$LgZFIt6Oqdo27ZFKbZ2nV+vtnYM995pDh9ca6WSi120=:qVV5NeluNfUPkwm7Vqat25RjSPLkGeoZBQs6wVv+um4=';
SELECT x FROM x WHERE x = 'regress_passwd_empty';
/* Test with invalid stored and server keys. */ /* The first is valid, to act as a control. The others have too long */ /* stored/server keys. They will be re-hashed. */ CREATE ROLE regress_passwd_sha_len0 PASSWORD 'SCRAM-SHA-256$4096:A6xHKoH/494E941doaPOYg==$Ky+A30sewHIH3VHQLRN9vYsuzlgNyGNKCh37dy96Rqw=:COPdlNiIkrsacU5QoxydEuOH6e/KfiipeETb/bPw8ZI=';
CREATE ROLE regress_passwd_sha_len1 PASSWORD 'SCRAM-SHA-256$4096:A6xHKoH/494E941doaPOYg==$Ky+A30sewHIH3VHQLRN9vYsuzlgNyGNKCh37dy96RqwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=:COPdlNiIkrsacU5QoxydEuOH6e/KfiipeETb/bPw8ZI=';
CREATE ROLE regress_passwd_sha_len2 PASSWORD 'SCRAM-SHA-256$4096:A6xHKoH/494E941doaPOYg==$Ky+A30sewHIH3VHQLRN9vYsuzlgNyGNKCh37dy96Rqw=:COPdlNiIkrsacU5QoxydEuOH6e/KfiipeETb/bPw8ZIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=';
/* Check that the invalid secrets were re-hashed. A re-hashed secret */ /* should not contain the original salt. */ SELECT x, NOT x LIKE '%A6xHKoH/494E941doaPOYg==%' AS x FROM x WHERE x LIKE 'regress_passwd_sha_len%' ORDER BY x NULLS LAST;
/* Test that valid hashes that are too long are rejected */ CREATE ROLE regress_passwd10 PASSWORD 'SCRAM-SHA-256$000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004096:wNFxNSk1hAXBkgub8py3bg==$65zC6E+R0U7tiYTC9+Wtq4Thw6gUDj3eDCINij8TflU=:rC1I7tcVugrHEY2DT0iPjGyjM4aJxkMM9n8WBxtUtHU=';
ALTER ROLE regress_passwd9 PASSWORD 'SCRAM-SHA-256$000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004096:wNFxNSk1hAXBkgub8py3bg==$65zC6E+R0U7tiYTC9+Wtq4Thw6gUDj3eDCINij8TflU=:rC1I7tcVugrHEY2DT0iPjGyjM4aJxkMM9n8WBxtUtHU=';
DROP ROLE regress_passwd1;
DROP ROLE regress_passwd2;
DROP ROLE regress_passwd3;
DROP ROLE regress_passwd4;
DROP ROLE regress_passwd5;
DROP ROLE regress_passwd6;
DROP ROLE regress_passwd7;
DROP ROLE regress_passwd8;
DROP ROLE regress_passwd9;
DROP ROLE regress_passwd_empty;
DROP ROLE regress_passwd_sha_len0;
DROP ROLE regress_passwd_sha_len1;
DROP ROLE regress_passwd_sha_len2;
/* all entries should have been removed */ SELECT x, x FROM x WHERE x LIKE 'regress_passwd%' ORDER BY x NULLS LAST, x NULLS LAST;
CREATE TABLE x (x path);
INSERT INTO x VALUES ('[(1,2),(3,4)]');
INSERT INTO x VALUES (' ( ( 1 , 2 ) , ( 3 , 4 ) ) ');
INSERT INTO x VALUES ('[ (0,0),(3,0),(4,5),(1,6) ]');
INSERT INTO x VALUES ('((1,2) ,(3,4 ))');
INSERT INTO x VALUES ('1,2 ,3,4 ');
INSERT INTO x VALUES (' [1,2,3, 4] ');
INSERT INTO x VALUES ('((10,20))');
/* Only one point */ INSERT INTO x VALUES ('[ 11,12,13,14 ]');
INSERT INTO x VALUES ('( 11,12,13,14) ');
/* bad values for parser testing */ INSERT INTO x VALUES ('[]');
INSERT INTO x VALUES ('[(,2),(3,4)]');
INSERT INTO x VALUES ('[(1,2),(3,4)');
INSERT INTO x VALUES ('(1,2,3,4');
INSERT INTO x VALUES ('(1,2),(3,4)]');
SELECT x AS x FROM x WHERE ISOPEN(x);
SELECT x AS x FROM x WHERE ISCLOSED(x);
SELECT PCLOSE(x) AS x FROM x;
SELECT POPEN(x) AS x FROM x;
/* test non-error-throwing API for some core types */ SELECT PG_INPUT_IS_VALID('[(1,2),(3)]', 'path');
SELECT * FROM x;
SELECT PG_INPUT_IS_VALID('[(1,2,6),(3,4,6)]', 'path');
SELECT * FROM x;
/* PG_LSN */ CREATE TABLE x (x pg_lsn);
/* Largest and smallest input */ INSERT INTO x VALUES ('0/0');
INSERT INTO x VALUES ('FFFFFFFF/FFFFFFFF');
/* Incorrect input */ INSERT INTO x VALUES ('G/0');
INSERT INTO x VALUES ('-1/0');
INSERT INTO x VALUES (' 0/12345678');
INSERT INTO x VALUES ('ABCD/');
INSERT INTO x VALUES ('/ABCD');
/* Also try it with non-error-throwing API */ SELECT PG_INPUT_IS_VALID('16AE7F7', 'pg_lsn');
SELECT * FROM x;
/* Min/Max aggregation */ SELECT MIN(x), MAX(x) FROM x;
DROP TABLE x;
/* Operators */ SELECT '0/16AE7F8' = CAST('0/16AE7F8' AS pg_lsn);
SELECT CAST('0/16AE7F8' AS pg_lsn) <> '0/16AE7F7';
SELECT '0/16AE7F7' < CAST('0/16AE7F8' AS pg_lsn);
SELECT CAST('0/16AE7F7' AS pg_lsn) - CAST('0/16AE7F8' AS pg_lsn);
SELECT CAST('0/16AE7F8' AS pg_lsn) - CAST('0/16AE7F7' AS pg_lsn);
SELECT CAST('0/16AE7F7' AS pg_lsn) + CAST(16 AS DECIMAL);
SELECT CAST(16 AS DECIMAL) + CAST('0/16AE7F7' AS pg_lsn);
SELECT CAST('0/16AE7F7' AS pg_lsn) - CAST(16 AS DECIMAL);
SELECT CAST('FFFFFFFF/FFFFFFFE' AS pg_lsn) + CAST(1 AS DECIMAL);
SELECT CAST('FFFFFFFF/FFFFFFFE' AS pg_lsn) + CAST(2 AS DECIMAL);
/* out of range error */ SELECT CAST('0/1' AS pg_lsn) - CAST(1 AS DECIMAL);
SELECT CAST('0/1' AS pg_lsn) - CAST(2 AS DECIMAL);
/* out of range error */ SELECT CAST('0/0' AS pg_lsn) + (CAST('FFFFFFFF/FFFFFFFF' AS pg_lsn) - CAST('0/0' AS pg_lsn));
SELECT CAST('FFFFFFFF/FFFFFFFF' AS pg_lsn) - (CAST('FFFFFFFF/FFFFFFFF' AS pg_lsn) - CAST('0/0' AS pg_lsn));
SELECT CAST('0/16AE7F7' AS pg_lsn) + CAST('NaN' AS DECIMAL);
SELECT CAST('0/16AE7F7' AS pg_lsn) - CAST('NaN' AS DECIMAL);
/* Check btree and hash opclasses */ EXPLAIN (COSTS OFF) SELECT DISTINCT (i || '/' || j)::pg_lsn f   FROM generate_series(1, 10) i,        generate_series(1, 10) j,        generate_series(1, 5) k   WHERE i <= 10 AND j > 0 AND j <= 10   ORDER BY f;
SELECT DISTINCT CAST((x || '/' || x) AS pg_lsn) AS x FROM x AS x, x AS x, x AS x WHERE x <= 10 AND x > 0 AND x <= 10 ORDER BY x NULLS LAST;
/* Tests to exercise the plan caching/invalidation mechanism */ CREATE TEMPORARY TABLE x AS SELECT * FROM x;
/* create and use a cached plan */ PREPARE prepstmt AS SELECT * FROM pcachetest;
EXECUTE prepstmt;
/* and one with parameters */ PREPARE prepstmt2(bigint) AS SELECT * FROM pcachetest WHERE q1 = $1;
EXECUTE prepstmt2(123);
/* invalidate the plans and see what happens */ DROP TABLE x;
EXECUTE prepstmt;
EXECUTE prepstmt2(123);
/* recreate the temp table (this demonstrates that the raw plan is */ /* purely textual and doesn't depend on OIDs, for instance) */ CREATE TEMPORARY TABLE x AS SELECT * FROM x ORDER BY 2 NULLS LAST;
EXECUTE prepstmt;
EXECUTE prepstmt2(123);
ALTER TABLE x ADD COLUMN x BIGINT /* prepared statements should prevent change in output tupdesc, */ /* since clients probably aren't expecting that to change on the fly */;
EXECUTE prepstmt;
EXECUTE prepstmt2(123);
ALTER TABLE x DROP COLUMN x /* but we're nice guys and will let you undo your mistake */;
EXECUTE prepstmt;
EXECUTE prepstmt2(123);
/* Try it with a view, which isn't directly used in the resulting plan */ /* but should trigger invalidation anyway */ CREATE TEMPORARY VIEW x AS SELECT * FROM x;
PREPARE vprep AS SELECT * FROM pcacheview;
EXECUTE vprep;
CREATE OR REPLACE TEMPORARY VIEW x AS SELECT x, x / 2 AS x FROM x;
EXECUTE vprep;
BEGIN create temp table t1(f1 int);
INSERT INTO x VALUES (@1);
INSERT INTO x VALUES (11);
INSERT INTO x VALUES (12);
INSERT INTO x VALUES (13);
CREATE TABLE x AS SELECT SUM(x) FROM x;
DROP TABLE x;
x AS x;
SELECT CACHE_TEST(1);
SELECT CACHE_TEST(2);
SELECT CACHE_TEST(3);
/* Check invalidation of plpgsql "simple expression" */ CREATE TEMPORARY VIEW x AS SELECT 2 + 2 AS x;
SELECT CACHE_TEST_2();
CREATE OR REPLACE TEMPORARY VIEW x AS SELECT 2 + 2 + 4 AS x;
SELECT CACHE_TEST_2();
CREATE OR REPLACE TEMPORARY VIEW x AS SELECT 2 + 2 + 4 + (SELECT MAX(x) FROM x) AS x;
SELECT CACHE_TEST_2();
/* - Check that change of search_path is honored when re-using cached plan */ create schema s1   create table abc (f1 int);
create schema s2   create table abc (f1 int);
INSERT INTO x.x VALUES (123);
INSERT INTO x.x VALUES (456);
SET x = s1;
PREPARE p1 as select f1 from abc;
EXECUTE p1;
SET x = s2;
SELECT x FROM x;
EXECUTE p1;
ALTER TABLE x.x ADD COLUMN x DOUBLE;
/* force replan */ EXECUTE p1;
DROP SCHEMA x.x CASCADE;
DROP SCHEMA x.x CASCADE;
RESET search_path;
/* Check that invalidation deals with regclass constants */ CREATE TEMPORARY SEQUENCE x;
PREPARE p2 as select nextval('seq');
EXECUTE p2;
DROP SEQUENCE x;
CREATE TEMPORARY SEQUENCE x;
EXECUTE p2;
BEGIN drop table if exists temptable cascade;
CREATE TEMPORARY TABLE x AS SELECT * FROM x AS x;
CREATE TEMPORARY VIEW x AS SELECT * FROM x;
SELECT CACHEBUG();
SELECT CACHEBUG();
/* Check that addition or removal of any partition is correctly dealt with by */ /* default partition table when it is being used in prepared statement. */ CREATE TABLE x (x INT) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN (NULL);
CREATE TABLE x PARTITION OF x FOR VALUES IN (1);
CREATE TABLE x PARTITION OF x DEFAULT;
PREPARE pstmt_def_insert (int) as insert into pc_list_part_def values($1);
/* should fail */ EXECUTE pstmt_def_insert(null);
EXECUTE pstmt_def_insert(1);
CREATE TABLE x PARTITION OF x FOR VALUES IN (2);
EXECUTE pstmt_def_insert(2);
alter table pc_list_parted detach partition pc_list_part_null;
/* should be ok */ EXECUTE pstmt_def_insert(null);
DROP TABLE x;
/* should be ok */ EXECUTE pstmt_def_insert(1);
x AS x;
/* Test plan_cache_mode */ CREATE TABLE x (x INT);
INSERT INTO x SELECT 1 FROM x UNION ALL SELECT 2;
CREATE INDEX ON x(x NULLS LAST);
ANALYZE x;
PREPARE test_mode_pp (int) as select count(*) from test_mode where a = $1;
SELECT x, x, x FROM x WHERE x = 'test_mode_pp';
SET x = auto /* up to 5 executions, custom plan is used */;
EXPLAIN (costs off) execute test_mode_pp(2);
SELECT x, x, x FROM x WHERE x = 'test_mode_pp';
SET x = force_generic_plan /* force generic plan */;
EXPLAIN (costs off) execute test_mode_pp(2);
SELECT x, x, x FROM x WHERE x = 'test_mode_pp';
SET x = auto /* get to generic plan by 5 executions */;
EXECUTE test_mode_pp(1);
/* 1x */ EXECUTE test_mode_pp(1);
/* 2x */ EXECUTE test_mode_pp(1);
/* 3x */ EXECUTE test_mode_pp(1);
/* 4x */ SELECT x, x, x FROM x WHERE x = 'test_mode_pp';
EXECUTE test_mode_pp(1);
/* 5x */ SELECT x, x, x FROM x WHERE x = 'test_mode_pp';
/* we should now get a really bad plan */ EXPLAIN (costs off) execute test_mode_pp(2);
SET x = force_custom_plan /* but we can force a custom plan */;
EXPLAIN (costs off) execute test_mode_pp(2);
SELECT x, x, x FROM x WHERE x = 'test_mode_pp';
DROP TABLE x;
/* PLPGSQL */ /* Scenario: */ /*     A building with a modern TP cable installation where any */ /*     of the wall connectors can be used to plug in phones, */ /*     ethernet interfaces or local office hubs. The backside */ /*     of the wall connectors is wired to one of several patch- */ /*     fields in the building. */ /*     In the patchfields, there are hubs and all the slots */ /*     representing the wall connectors. In addition there are */ /*     slots that can represent a phone line from the central */ /*     phone system. */ /*     Triggers ensure consistency of the patching information. */ /*     Functions are used to build up powerful views that let */ /*     you look behind the wall when looking at a patchfield */ /*     or into a room. */ CREATE TABLE x (x CHAR(8), x TEXT);
CREATE UNIQUE INDEX x ON x USING btree(x x NULLS LAST);
CREATE TABLE x (x CHAR(20), x CHAR(8), x CHAR(20), x CHAR(20));
CREATE UNIQUE INDEX x ON x USING btree(x x NULLS LAST);
CREATE TABLE x (x TEXT, x TEXT);
CREATE UNIQUE INDEX x ON x USING btree(x x NULLS LAST);
CREATE TABLE x (x CHAR(20), x TEXT, x CHAR(20), x CHAR(20));
CREATE UNIQUE INDEX x ON x USING btree(x x NULLS LAST);
CREATE TABLE x (x CHAR(20), x CHAR(20), x TEXT, x CHAR(20));
CREATE UNIQUE INDEX x ON x USING btree(x x NULLS LAST);
CREATE TABLE x (x CHAR(14), x TEXT, x INT);
CREATE UNIQUE INDEX x ON x USING btree(x x NULLS LAST);
CREATE TABLE x (x CHAR(20), x CHAR(14), x INT, x CHAR(20));
CREATE UNIQUE INDEX x ON x USING btree(x x NULLS LAST);
CREATE INDEX x ON x USING btree(x x NULLS LAST);
CREATE TABLE x (x TEXT, x TEXT);
CREATE UNIQUE INDEX x ON x USING btree(x x NULLS LAST);
CREATE TABLE x (x CHAR(20), x TEXT, x TEXT, x CHAR(20));
CREATE UNIQUE INDEX x ON x USING btree(x x NULLS LAST);
CREATE TABLE x (x CHAR(20), x TEXT, x CHAR(20));
CREATE UNIQUE INDEX x ON x USING btree(x x NULLS LAST);
x AS x;
COMMIT;
create trigger tg_room_au after update     on Room for each row execute procedure tg_room_au();
x AS x;
COMMIT;
create trigger tg_room_ad after delete     on Room for each row execute procedure tg_room_ad();
x AS x;
COMMIT;
create trigger tg_wslot_biu before insert or update     on WSlot for each row execute procedure tg_wslot_biu();
x AS x;
COMMIT;
create trigger tg_pfield_au after update     on PField for each row execute procedure tg_pfield_au();
x AS x;
COMMIT;
create trigger tg_pfield_ad after delete     on PField for each row execute procedure tg_pfield_ad();
BEGIN select into pfrec * from PField where name = ps.pfname;
if not found then         raise exception $$Patchfield "%" does not exist$$, ps.pfname;
x AS x;
COMMIT;
create trigger tg_pslot_biu before insert or update     on PSlot for each row execute procedure tg_pslot_biu();
x AS x;
COMMIT;
create trigger tg_system_au after update     on System for each row execute procedure tg_system_au();
x AS x;
BEGIN select into sysrec * from system where name = new.sysname;
if not found then         raise exception $q$system "%" does not exist$q$, new.sysname;
x := 'IF.' || x.x;
x := x || '.';
x := x || x.x;
if length(sname) > 20 then         raise exception 'IFace slotname "%" too long (20 char max)', sname;
x.x := x;
x AS x;
COMMIT;
create trigger tg_iface_biu before insert or update     on IFace for each row execute procedure tg_iface_biu();
x AS x;
BEGIN if tg_op = ''INSERT'' then 	dummy := tg_hub_adjustslots(new.name, 0, new.nslots);
x AS x;
if tg_op = ''UPDATE'' then 	if new.name != old.name then 	    update HSlot set hubname = new.name where hubname = old.name;
x := TG_HUB_ADJUSTSLOTS(x.x, x.x, x.x);
x AS x;
if tg_op = ''DELETE'' then 	dummy := tg_hub_adjustslots(old.name, old.nslots, 0);
x AS x;
COMMIT;
create trigger tg_hub_a after insert or update or delete     on Hub for each row execute procedure tg_hub_a();
if newnslots < oldnslots then         delete from HSlot where hubname = hname and slotno > newnslots;
COMMENT ON FUNCTION x(x, x, x) IS 'function with args' /* Test comments */;
COMMENT ON FUNCTION x(x, x, x) IS 'function with args';
x AS x;
BEGIN select into hubrec * from Hub where name = new.hubname;
if not found then         raise exception ''no manual manipulation of HSlot'';
if new.slotno < 1 or new.slotno > hubrec.nslots then         raise exception ''no manual manipulation of HSlot'';
if tg_op = ''UPDATE'' and new.hubname != old.hubname then 	if count(*) > 0 from Hub where name = old.hubname then 	    raise exception ''no manual manipulation of HSlot'';
x := x || ''.'';
x := x || CAST(x.x AS TEXT);
if length(sname) > 20 then         raise exception ''HSlot slotname "%" too long (20 char max)'', sname;
x.x := x;
x AS x;
COMMIT;
create trigger tg_hslot_biu before insert or update     on HSlot for each row execute procedure tg_hslot_biu();
BEGIN select into hubrec * from Hub where name = old.hubname;
if not found then         return old;
if old.slotno > hubrec.nslots then         return old;
COMMIT;
create trigger tg_hslot_bd before delete     on HSlot for each row execute procedure tg_hslot_bd();
x AS x;
COMMIT;
create trigger tg_chkslotname before insert     on PSlot for each row execute procedure tg_chkslotname('PS');
create trigger tg_chkslotname before insert     on WSlot for each row execute procedure tg_chkslotname('WS');
create trigger tg_chkslotname before insert     on PLine for each row execute procedure tg_chkslotname('PL');
create trigger tg_chkslotname before insert     on IFace for each row execute procedure tg_chkslotname('IF');
create trigger tg_chkslotname before insert     on PHone for each row execute procedure tg_chkslotname('PH');
x AS x;
COMMIT;
create trigger tg_chkslotlink before insert or update     on PSlot for each row execute procedure tg_chkslotlink();
create trigger tg_chkslotlink before insert or update     on WSlot for each row execute procedure tg_chkslotlink();
create trigger tg_chkslotlink before insert or update     on IFace for each row execute procedure tg_chkslotlink();
create trigger tg_chkslotlink before insert or update     on HSlot for each row execute procedure tg_chkslotlink();
create trigger tg_chkslotlink before insert or update     on PHone for each row execute procedure tg_chkslotlink();
x AS x;
COMMIT;
create trigger tg_chkbacklink before insert or update     on PSlot for each row execute procedure tg_chkbacklink();
create trigger tg_chkbacklink before insert or update     on WSlot for each row execute procedure tg_chkbacklink();
create trigger tg_chkbacklink before insert or update     on PLine for each row execute procedure tg_chkbacklink();
INSERT INTO x (x, x, x, x) VALUES (x.x, x.x, x.x, x.x);
x AS x;
x AS x;
COMMIT;
create trigger tg_pslot_bu before update     on PSlot for each row execute procedure tg_pslot_bu();
INSERT INTO x (x, x, x, x) VALUES (x.x, x.x, x.x, x.x);
x AS x;
x AS x;
COMMIT;
create trigger tg_wslot_bu before update     on WSlot for each row execute procedure tg_Wslot_bu();
INSERT INTO x (x, x, x, x) VALUES (x.x, x.x, x.x, x.x);
x AS x;
x AS x;
COMMIT;
create trigger tg_pline_bu before update     on PLine for each row execute procedure tg_pline_bu();
INSERT INTO x (x, x, x, x) VALUES (x.x, x.x, x.x, x.x);
x AS x;
x AS x;
COMMIT;
create trigger tg_iface_bu before update     on IFace for each row execute procedure tg_iface_bu();
INSERT INTO x (x, x, x, x) VALUES (x.x, x.x, x.x, x.x);
x AS x;
x AS x;
COMMIT;
create trigger tg_hslot_bu before update     on HSlot for each row execute procedure tg_hslot_bu();
INSERT INTO x (x, x, x) VALUES (x.x, x.x, x.x);
x AS x;
x AS x;
COMMIT;
create trigger tg_phone_bu before update     on PHone for each row execute procedure tg_phone_bu();
BEGIN if tg_op = ''INSERT'' then         if new.backlink != '''' then 	    dummy := tg_backlink_set(new.backlink, new.slotname);
x AS x;
if tg_op = ''UPDATE'' then         if new.backlink != old.backlink then 	    if old.backlink != '''' then 	        dummy := tg_backlink_unset(old.backlink, old.slotname);
if new.backlink != '''' then 	        dummy := tg_backlink_set(new.backlink, new.slotname);
x AS x;
if tg_op = ''DELETE'' then         if old.backlink != '''' then 	    dummy := tg_backlink_unset(old.backlink, old.slotname);
x AS x;
COMMIT;
create trigger tg_backlink_a after insert or update or delete     on PSlot for each row execute procedure tg_backlink_a('PS');
create trigger tg_backlink_a after insert or update or delete     on WSlot for each row execute procedure tg_backlink_a('WS');
create trigger tg_backlink_a after insert or update or delete     on PLine for each row execute procedure tg_backlink_a('PL');
x AS x;
BEGIN mytype := substr(myname, 1, 2);
x := x || SUBSTRING(x, 1, 2);
if link = ''PLPL'' then         raise exception 		''backlink between two phone lines does not make sense'';
if link in (''PLWS'', ''WSPL'') then         raise exception 		''direct link of phone line to wall slot not permitted'';
if mytype = ''PS'' then         select into rec * from PSlot where slotname = myname;
if not found then 	    raise exception ''% does not exist'', myname;
if rec.backlink != blname then 	    update PSlot set backlink = blname where slotname = myname;
if mytype = ''WS'' then         select into rec * from WSlot where slotname = myname;
if not found then 	    raise exception ''% does not exist'', myname;
if rec.backlink != blname then 	    update WSlot set backlink = blname where slotname = myname;
if mytype = ''PL'' then         select into rec * from PLine where slotname = myname;
if not found then 	    raise exception ''% does not exist'', myname;
if rec.backlink != blname then 	    update PLine set backlink = blname where slotname = myname;
COMMIT;
x AS x;
BEGIN mytype := substr(myname, 1, 2);
if mytype = ''PS'' then         select into rec * from PSlot where slotname = myname;
if not found then 	    return 0;
if rec.backlink = blname then 	    update PSlot set backlink = '''' where slotname = myname;
if mytype = ''WS'' then         select into rec * from WSlot where slotname = myname;
if not found then 	    return 0;
if rec.backlink = blname then 	    update WSlot set backlink = '''' where slotname = myname;
if mytype = ''PL'' then         select into rec * from PLine where slotname = myname;
if not found then 	    return 0;
if rec.backlink = blname then 	    update PLine set backlink = '''' where slotname = myname;
BEGIN if tg_op = ''INSERT'' then         if new.slotlink != '''' then 	    dummy := tg_slotlink_set(new.slotlink, new.slotname);
x AS x;
if tg_op = ''UPDATE'' then         if new.slotlink != old.slotlink then 	    if old.slotlink != '''' then 	        dummy := tg_slotlink_unset(old.slotlink, old.slotname);
if new.slotlink != '''' then 	        dummy := tg_slotlink_set(new.slotlink, new.slotname);
x AS x;
if tg_op = ''DELETE'' then         if old.slotlink != '''' then 	    dummy := tg_slotlink_unset(old.slotlink, old.slotname);
x AS x;
COMMIT;
create trigger tg_slotlink_a after insert or update or delete     on PSlot for each row execute procedure tg_slotlink_a('PS');
create trigger tg_slotlink_a after insert or update or delete     on WSlot for each row execute procedure tg_slotlink_a('WS');
create trigger tg_slotlink_a after insert or update or delete     on IFace for each row execute procedure tg_slotlink_a('IF');
create trigger tg_slotlink_a after insert or update or delete     on HSlot for each row execute procedure tg_slotlink_a('HS');
create trigger tg_slotlink_a after insert or update or delete     on PHone for each row execute procedure tg_slotlink_a('PH');
x AS x;
BEGIN mytype := substr(myname, 1, 2);
x := x || SUBSTRING(x, 1, 2);
if link = ''PHPH'' then         raise exception 		''slotlink between two phones does not make sense'';
if link in (''PHHS'', ''HSPH'') then         raise exception 		''link of phone to hub does not make sense'';
if link in (''PHIF'', ''IFPH'') then         raise exception 		''link of phone to hub does not make sense'';
if link in (''PSWS'', ''WSPS'') then         raise exception 		''slotlink from patchslot to wallslot not permitted'';
if mytype = ''PS'' then         select into rec * from PSlot where slotname = myname;
if not found then 	    raise exception ''% does not exist'', myname;
if rec.slotlink != blname then 	    update PSlot set slotlink = blname where slotname = myname;
if mytype = ''WS'' then         select into rec * from WSlot where slotname = myname;
if not found then 	    raise exception ''% does not exist'', myname;
if rec.slotlink != blname then 	    update WSlot set slotlink = blname where slotname = myname;
if mytype = ''IF'' then         select into rec * from IFace where slotname = myname;
if not found then 	    raise exception ''% does not exist'', myname;
if rec.slotlink != blname then 	    update IFace set slotlink = blname where slotname = myname;
if mytype = ''HS'' then         select into rec * from HSlot where slotname = myname;
if not found then 	    raise exception ''% does not exist'', myname;
if rec.slotlink != blname then 	    update HSlot set slotlink = blname where slotname = myname;
if mytype = ''PH'' then         select into rec * from PHone where slotname = myname;
if not found then 	    raise exception ''% does not exist'', myname;
if rec.slotlink != blname then 	    update PHone set slotlink = blname where slotname = myname;
COMMIT;
x AS x;
BEGIN mytype := substr(myname, 1, 2);
if mytype = ''PS'' then         select into rec * from PSlot where slotname = myname;
if not found then 	    return 0;
if rec.slotlink = blname then 	    update PSlot set slotlink = '''' where slotname = myname;
if mytype = ''WS'' then         select into rec * from WSlot where slotname = myname;
if not found then 	    return 0;
if rec.slotlink = blname then 	    update WSlot set slotlink = '''' where slotname = myname;
if mytype = ''IF'' then         select into rec * from IFace where slotname = myname;
if not found then 	    return 0;
if rec.slotlink = blname then 	    update IFace set slotlink = '''' where slotname = myname;
if mytype = ''HS'' then         select into rec * from HSlot where slotname = myname;
if not found then 	    return 0;
if rec.slotlink = blname then 	    update HSlot set slotlink = '''' where slotname = myname;
if mytype = ''PH'' then         select into rec * from PHone where slotname = myname;
if not found then 	    return 0;
if rec.slotlink = blname then 	    update PHone set slotlink = '''' where slotname = myname;
COMMIT;
x AS x;
BEGIN select into rec * from PSlot where slotname = $1;
if not found then         return '''';
if rec.backlink = '''' then         return ''-'';
x := SUBSTRING(x.x, 1, 2);
if bltype = ''PL'' then         declare 	    rec		record;
BEGIN select into rec * from PLine where slotname = "outer".rec.backlink;
if rec.comment != '''' then 	        retval := retval || '' ('';
x := x || x.x;
x AS x;
COMMIT;
if bltype = ''WS'' then         select into rec * from WSlot where slotname = rec.backlink;
x := x || TRIM(x.x);
x := x || JSON_EXTRACT('', '$[""]');
COMMIT;
x AS x;
BEGIN select into psrec * from PSlot where slotname = $1;
if not found then         return '''';
if psrec.slotlink = '''' then         return ''-'';
x := SUBSTRING(x.x, 1, 2);
if sltype = ''PS'' then 	retval := trim(psrec.slotlink) || '' -> '';
if sltype = ''HS'' then         retval := comment from Hub H, HSlot HS 			where HS.slotname = psrec.slotlink 			  and H.name = HS.hubname;
x AS x;
COMMIT;
x AS x;
BEGIN select into rec * from WSlot where slotname = $1;
if not found then         return '''';
if rec.slotlink = '''' then         return ''-'';
x := SUBSTRING(x.x, 1, 2);
if sltype = ''PH'' then         select into rec * from PHone where slotname = rec.slotlink;
if rec.comment != '''' then 	    retval := retval || '' ('';
x := x || x.x;
x AS x;
if sltype = ''IF'' then 	declare 	    syrow	System%RowType;
BEGIN select into ifrow * from IFace where slotname = rec.slotlink;
CREATE TABLE x AS SELECT FROM x WHERE x = x.x;
x := x || x.x;
if syrow.comment != '''' then 	        retval := retval || '' ('';
x := x || x.x;
x AS x;
COMMIT;
COMMIT;
/* ************************************************************ */ /* * View of a patchfield describing backside and patches */ /* ************************************************************ */ CREATE VIEW x AS SELECT x.x, x.x, PSLOT_BACKLINK_VIEW(x.x) AS x, PSLOT_SLOTLINK_VIEW(x.x) AS x FROM x AS x;
/* First we build the house - so we create the rooms */ INSERT INTO x VALUES ('001', 'Entrance');
INSERT INTO x VALUES ('002', 'Office');
INSERT INTO x VALUES ('003', 'Office');
INSERT INTO x VALUES ('004', 'Technical');
INSERT INTO x VALUES ('101', 'Office');
INSERT INTO x VALUES ('102', 'Conference');
INSERT INTO x VALUES ('103', 'Restroom');
INSERT INTO x VALUES ('104', 'Technical');
INSERT INTO x VALUES ('105', 'Office');
INSERT INTO x VALUES ('106', 'Office');
/* Second we install the wall connectors */ INSERT INTO x VALUES ('WS.001.1a', '001', '', '');
INSERT INTO x VALUES ('WS.001.1b', '001', '', '');
INSERT INTO x VALUES ('WS.001.2a', '001', '', '');
INSERT INTO x VALUES ('WS.001.2b', '001', '', '');
INSERT INTO x VALUES ('WS.001.3a', '001', '', '');
INSERT INTO x VALUES ('WS.001.3b', '001', '', '');
INSERT INTO x VALUES ('WS.002.1a', '002', '', '');
INSERT INTO x VALUES ('WS.002.1b', '002', '', '');
INSERT INTO x VALUES ('WS.002.2a', '002', '', '');
INSERT INTO x VALUES ('WS.002.2b', '002', '', '');
INSERT INTO x VALUES ('WS.002.3a', '002', '', '');
INSERT INTO x VALUES ('WS.002.3b', '002', '', '');
INSERT INTO x VALUES ('WS.003.1a', '003', '', '');
INSERT INTO x VALUES ('WS.003.1b', '003', '', '');
INSERT INTO x VALUES ('WS.003.2a', '003', '', '');
INSERT INTO x VALUES ('WS.003.2b', '003', '', '');
INSERT INTO x VALUES ('WS.003.3a', '003', '', '');
INSERT INTO x VALUES ('WS.003.3b', '003', '', '');
INSERT INTO x VALUES ('WS.101.1a', '101', '', '');
INSERT INTO x VALUES ('WS.101.1b', '101', '', '');
INSERT INTO x VALUES ('WS.101.2a', '101', '', '');
INSERT INTO x VALUES ('WS.101.2b', '101', '', '');
INSERT INTO x VALUES ('WS.101.3a', '101', '', '');
INSERT INTO x VALUES ('WS.101.3b', '101', '', '');
INSERT INTO x VALUES ('WS.102.1a', '102', '', '');
INSERT INTO x VALUES ('WS.102.1b', '102', '', '');
INSERT INTO x VALUES ('WS.102.2a', '102', '', '');
INSERT INTO x VALUES ('WS.102.2b', '102', '', '');
INSERT INTO x VALUES ('WS.102.3a', '102', '', '');
INSERT INTO x VALUES ('WS.102.3b', '102', '', '');
INSERT INTO x VALUES ('WS.105.1a', '105', '', '');
INSERT INTO x VALUES ('WS.105.1b', '105', '', '');
INSERT INTO x VALUES ('WS.105.2a', '105', '', '');
INSERT INTO x VALUES ('WS.105.2b', '105', '', '');
INSERT INTO x VALUES ('WS.105.3a', '105', '', '');
INSERT INTO x VALUES ('WS.105.3b', '105', '', '');
INSERT INTO x VALUES ('WS.106.1a', '106', '', '');
INSERT INTO x VALUES ('WS.106.1b', '106', '', '');
INSERT INTO x VALUES ('WS.106.2a', '106', '', '');
INSERT INTO x VALUES ('WS.106.2b', '106', '', '');
INSERT INTO x VALUES ('WS.106.3a', '106', '', '');
INSERT INTO x VALUES ('WS.106.3b', '106', '', '');
/* Now create the patch fields and their slots */ INSERT INTO x VALUES ('PF0_1', 'Wallslots basement');
/* The cables for these will be made later, so they are unconnected for now */ INSERT INTO x VALUES ('PS.base.a1', 'PF0_1', '', '');
INSERT INTO x VALUES ('PS.base.a2', 'PF0_1', '', '');
INSERT INTO x VALUES ('PS.base.a3', 'PF0_1', '', '');
INSERT INTO x VALUES ('PS.base.a4', 'PF0_1', '', '');
INSERT INTO x VALUES ('PS.base.a5', 'PF0_1', '', '');
INSERT INTO x VALUES ('PS.base.a6', 'PF0_1', '', '');
/* These are already wired to the wall connectors */ INSERT INTO x VALUES ('PS.base.b1', 'PF0_1', '', 'WS.002.1a');
INSERT INTO x VALUES ('PS.base.b2', 'PF0_1', '', 'WS.002.1b');
INSERT INTO x VALUES ('PS.base.b3', 'PF0_1', '', 'WS.002.2a');
INSERT INTO x VALUES ('PS.base.b4', 'PF0_1', '', 'WS.002.2b');
INSERT INTO x VALUES ('PS.base.b5', 'PF0_1', '', 'WS.002.3a');
INSERT INTO x VALUES ('PS.base.b6', 'PF0_1', '', 'WS.002.3b');
INSERT INTO x VALUES ('PS.base.c1', 'PF0_1', '', 'WS.003.1a');
INSERT INTO x VALUES ('PS.base.c2', 'PF0_1', '', 'WS.003.1b');
INSERT INTO x VALUES ('PS.base.c3', 'PF0_1', '', 'WS.003.2a');
INSERT INTO x VALUES ('PS.base.c4', 'PF0_1', '', 'WS.003.2b');
INSERT INTO x VALUES ('PS.base.c5', 'PF0_1', '', 'WS.003.3a');
INSERT INTO x VALUES ('PS.base.c6', 'PF0_1', '', 'WS.003.3b');
/* This patchfield will be renamed later into PF0_2 - so its */ /* slots references in pfname should follow */ INSERT INTO x VALUES ('PF0_X', 'Phonelines basement');
INSERT INTO x VALUES ('PS.base.ta1', 'PF0_X', '', '');
INSERT INTO x VALUES ('PS.base.ta2', 'PF0_X', '', '');
INSERT INTO x VALUES ('PS.base.ta3', 'PF0_X', '', '');
INSERT INTO x VALUES ('PS.base.ta4', 'PF0_X', '', '');
INSERT INTO x VALUES ('PS.base.ta5', 'PF0_X', '', '');
INSERT INTO x VALUES ('PS.base.ta6', 'PF0_X', '', '');
INSERT INTO x VALUES ('PS.base.tb1', 'PF0_X', '', '');
INSERT INTO x VALUES ('PS.base.tb2', 'PF0_X', '', '');
INSERT INTO x VALUES ('PS.base.tb3', 'PF0_X', '', '');
INSERT INTO x VALUES ('PS.base.tb4', 'PF0_X', '', '');
INSERT INTO x VALUES ('PS.base.tb5', 'PF0_X', '', '');
INSERT INTO x VALUES ('PS.base.tb6', 'PF0_X', '', '');
INSERT INTO x VALUES ('PF1_1', 'Wallslots first floor');
INSERT INTO x VALUES ('PS.first.a1', 'PF1_1', '', 'WS.101.1a');
INSERT INTO x VALUES ('PS.first.a2', 'PF1_1', '', 'WS.101.1b');
INSERT INTO x VALUES ('PS.first.a3', 'PF1_1', '', 'WS.101.2a');
INSERT INTO x VALUES ('PS.first.a4', 'PF1_1', '', 'WS.101.2b');
INSERT INTO x VALUES ('PS.first.a5', 'PF1_1', '', 'WS.101.3a');
INSERT INTO x VALUES ('PS.first.a6', 'PF1_1', '', 'WS.101.3b');
INSERT INTO x VALUES ('PS.first.b1', 'PF1_1', '', 'WS.102.1a');
INSERT INTO x VALUES ('PS.first.b2', 'PF1_1', '', 'WS.102.1b');
INSERT INTO x VALUES ('PS.first.b3', 'PF1_1', '', 'WS.102.2a');
INSERT INTO x VALUES ('PS.first.b4', 'PF1_1', '', 'WS.102.2b');
INSERT INTO x VALUES ('PS.first.b5', 'PF1_1', '', 'WS.102.3a');
INSERT INTO x VALUES ('PS.first.b6', 'PF1_1', '', 'WS.102.3b');
INSERT INTO x VALUES ('PS.first.c1', 'PF1_1', '', 'WS.105.1a');
INSERT INTO x VALUES ('PS.first.c2', 'PF1_1', '', 'WS.105.1b');
INSERT INTO x VALUES ('PS.first.c3', 'PF1_1', '', 'WS.105.2a');
INSERT INTO x VALUES ('PS.first.c4', 'PF1_1', '', 'WS.105.2b');
INSERT INTO x VALUES ('PS.first.c5', 'PF1_1', '', 'WS.105.3a');
INSERT INTO x VALUES ('PS.first.c6', 'PF1_1', '', 'WS.105.3b');
INSERT INTO x VALUES ('PS.first.d1', 'PF1_1', '', 'WS.106.1a');
INSERT INTO x VALUES ('PS.first.d2', 'PF1_1', '', 'WS.106.1b');
INSERT INTO x VALUES ('PS.first.d3', 'PF1_1', '', 'WS.106.2a');
INSERT INTO x VALUES ('PS.first.d4', 'PF1_1', '', 'WS.106.2b');
INSERT INTO x VALUES ('PS.first.d5', 'PF1_1', '', 'WS.106.3a');
INSERT INTO x VALUES ('PS.first.d6', 'PF1_1', '', 'WS.106.3b');
/* Now we wire the wall connectors 1a-2a in room 001 to the */ /* patchfield. In the second update we make an error, and */ /* correct it after */ UPDATE x SET x = 'WS.001.1a' WHERE x = 'PS.base.a1';
UPDATE x SET x = 'WS.001.1b' WHERE x = 'PS.base.a3';
SELECT * FROM x WHERE x = '001' ORDER BY x NULLS LAST;
SELECT * FROM x WHERE REGEXP_LIKE(x, 'PS.base.a') ORDER BY x NULLS LAST;
UPDATE x SET x = 'WS.001.2a' WHERE x = 'PS.base.a3';
SELECT * FROM x WHERE x = '001' ORDER BY x NULLS LAST;
SELECT * FROM x WHERE REGEXP_LIKE(x, 'PS.base.a') ORDER BY x NULLS LAST;
UPDATE x SET x = 'WS.001.1b' WHERE x = 'PS.base.a2';
SELECT * FROM x WHERE x = '001' ORDER BY x NULLS LAST;
SELECT * FROM x WHERE REGEXP_LIKE(x, 'PS.base.a') ORDER BY x NULLS LAST;
/* Same procedure for 2b-3b but this time updating the WSlot instead */ /* of the PSlot. Due to the triggers the result is the same: */ /* WSlot and corresponding PSlot point to each other. */ UPDATE x SET x = 'PS.base.a4' WHERE x = 'WS.001.2b';
UPDATE x SET x = 'PS.base.a6' WHERE x = 'WS.001.3a';
SELECT * FROM x WHERE x = '001' ORDER BY x NULLS LAST;
SELECT * FROM x WHERE REGEXP_LIKE(x, 'PS.base.a') ORDER BY x NULLS LAST;
UPDATE x SET x = 'PS.base.a6' WHERE x = 'WS.001.3b';
SELECT * FROM x WHERE x = '001' ORDER BY x NULLS LAST;
SELECT * FROM x WHERE REGEXP_LIKE(x, 'PS.base.a') ORDER BY x NULLS LAST;
UPDATE x SET x = 'PS.base.a5' WHERE x = 'WS.001.3a';
SELECT * FROM x WHERE x = '001' ORDER BY x NULLS LAST;
SELECT * FROM x WHERE REGEXP_LIKE(x, 'PS.base.a') ORDER BY x NULLS LAST;
INSERT INTO x VALUES ('PF1_2', 'Phonelines first floor');
INSERT INTO x VALUES ('PS.first.ta1', 'PF1_2', '', '');
INSERT INTO x VALUES ('PS.first.ta2', 'PF1_2', '', '');
INSERT INTO x VALUES ('PS.first.ta3', 'PF1_2', '', '');
INSERT INTO x VALUES ('PS.first.ta4', 'PF1_2', '', '');
INSERT INTO x VALUES ('PS.first.ta5', 'PF1_2', '', '');
INSERT INTO x VALUES ('PS.first.ta6', 'PF1_2', '', '');
INSERT INTO x VALUES ('PS.first.tb1', 'PF1_2', '', '');
INSERT INTO x VALUES ('PS.first.tb2', 'PF1_2', '', '');
INSERT INTO x VALUES ('PS.first.tb3', 'PF1_2', '', '');
INSERT INTO x VALUES ('PS.first.tb4', 'PF1_2', '', '');
INSERT INTO x VALUES ('PS.first.tb5', 'PF1_2', '', '');
INSERT INTO x VALUES ('PS.first.tb6', 'PF1_2', '', '');
/* Fix the wrong name for patchfield PF0_2 */ UPDATE x SET x = 'PF0_2' WHERE x = 'PF0_X';
SELECT * FROM x ORDER BY x NULLS LAST;
SELECT * FROM x ORDER BY x NULLS LAST;
/* Install the central phone system and create the phone numbers. */ /* They are wired on insert to the patchfields. Again the */ /* triggers automatically tell the PSlots to update their */ /* backlink field. */ INSERT INTO x VALUES ('PL.001', '-0', 'Central call', 'PS.base.ta1');
INSERT INTO x VALUES ('PL.002', '-101', '', 'PS.base.ta2');
INSERT INTO x VALUES ('PL.003', '-102', '', 'PS.base.ta3');
INSERT INTO x VALUES ('PL.004', '-103', '', 'PS.base.ta5');
INSERT INTO x VALUES ('PL.005', '-104', '', 'PS.base.ta6');
INSERT INTO x VALUES ('PL.006', '-106', '', 'PS.base.tb2');
INSERT INTO x VALUES ('PL.007', '-108', '', 'PS.base.tb3');
INSERT INTO x VALUES ('PL.008', '-109', '', 'PS.base.tb4');
INSERT INTO x VALUES ('PL.009', '-121', '', 'PS.base.tb5');
INSERT INTO x VALUES ('PL.010', '-122', '', 'PS.base.tb6');
INSERT INTO x VALUES ('PL.015', '-134', '', 'PS.first.ta1');
INSERT INTO x VALUES ('PL.016', '-137', '', 'PS.first.ta3');
INSERT INTO x VALUES ('PL.017', '-139', '', 'PS.first.ta4');
INSERT INTO x VALUES ('PL.018', '-362', '', 'PS.first.tb1');
INSERT INTO x VALUES ('PL.019', '-363', '', 'PS.first.tb2');
INSERT INTO x VALUES ('PL.020', '-364', '', 'PS.first.tb3');
INSERT INTO x VALUES ('PL.021', '-365', '', 'PS.first.tb5');
INSERT INTO x VALUES ('PL.022', '-367', '', 'PS.first.tb6');
INSERT INTO x VALUES ('PL.028', '-501', 'Fax entrance', 'PS.base.ta2');
INSERT INTO x VALUES ('PL.029', '-502', 'Fax first floor', 'PS.first.ta1');
/* Buy some phones, plug them into the wall and patch the */ /* phone lines to the corresponding patchfield slots. */ INSERT INTO x VALUES ('PH.hc001', 'Hicom standard', 'WS.001.1a');
UPDATE x SET x = 'PS.base.ta1' WHERE x = 'PS.base.a1';
INSERT INTO x VALUES ('PH.hc002', 'Hicom standard', 'WS.002.1a');
UPDATE x SET x = 'PS.base.ta5' WHERE x = 'PS.base.b1';
INSERT INTO x VALUES ('PH.hc003', 'Hicom standard', 'WS.002.2a');
UPDATE x SET x = 'PS.base.tb2' WHERE x = 'PS.base.b3';
INSERT INTO x VALUES ('PH.fax001', 'Canon fax', 'WS.001.2a');
UPDATE x SET x = 'PS.base.ta2' WHERE x = 'PS.base.a3';
/* Install a hub at one of the patchfields, plug a computers */ /* ethernet interface into the wall and patch it to the hub. */ INSERT INTO x VALUES ('base.hub1', 'Patchfield PF0_1 hub', 16);
INSERT INTO x VALUES ('orion', 'PC');
INSERT INTO x VALUES ('IF', 'orion', 'eth0', 'WS.002.1b');
UPDATE x SET x = 'HS.base.hub1.1' WHERE x = 'PS.base.b2';
/* Now we take a look at the patchfield */ SELECT * FROM x WHERE x = 'PF0_1' ORDER BY x NULLS LAST;
SELECT * FROM x WHERE x = 'PF0_2' ORDER BY x NULLS LAST;
/* Finally we want errors */ INSERT INTO x VALUES ('PF1_1', 'should fail due to unique index');
UPDATE x SET x = 'WS.not.there' WHERE x = 'PS.base.a1';
UPDATE x SET x = 'XX.illegal' WHERE x = 'PS.base.a1';
UPDATE x SET x = 'PS.not.there' WHERE x = 'PS.base.a1';
UPDATE x SET x = 'XX.illegal' WHERE x = 'PS.base.a1';
INSERT INTO x VALUES ('HS', 'base.hub1', 1, '');
INSERT INTO x VALUES ('HS', 'base.hub1', 20, '');
DELETE FROM x;
INSERT INTO x VALUES ('IF', 'notthere', 'eth0', '');
INSERT INTO x VALUES ('IF', 'orion', 'ethernet_interface_name_too_long', '');
BEGIN IF $1 <= 0 THEN         rslt = CAST($2 AS TEXT);
x AS x;
COMMIT;
SELECT RECURSION_TEST(4, 3);
/* Test the FOUND magic variable */ CREATE TABLE x (x INT);
if FOUND then      insert into found_test_tbl values (2);
UPDATE x SET x = 100 WHERE x = 1;
if FOUND then     insert into found_test_tbl values (3);
DELETE FROM x WHERE x = 9999;
if not FOUND then     insert into found_test_tbl values (4);
if FOUND then     insert into found_test_tbl values (5);
if not FOUND then     insert into found_test_tbl values (6);
x AS x;
COMMIT;
SELECT TEST_FOUND();
SELECT * FROM x;
BEGIN FOR rec IN select * from found_test_tbl LOOP 		RETURN NEXT rec;
x;
COMMIT;
SELECT * FROM x;
BEGIN FOR row IN select * from found_test_tbl LOOP 		RETURN NEXT row;
x;
COMMIT;
SELECT * FROM x;
BEGIN FOR i IN $1 .. $2 LOOP 		RETURN NEXT i + 1;
x;
COMMIT;
SELECT * FROM x;
BEGIN IF $1 > 10 THEN 		SELECT INTO retval 5, 10, 15;
x;
COMMIT;
SELECT * FROM x AS _t0;
SELECT * FROM x AS _t0;
BEGIN IF $1 > 10 THEN 		SELECT INTO retval 5, 10, 15;
x AS x;
x AS x;
COMMIT;
SELECT * FROM x AS _t0;
SELECT * FROM x AS _t0;
SELECT F1(42) AS x, F1(4.5) AS x;
SELECT F1(POINT(3, 4));
SELECT F1(42) AS x, F1(4.5) AS x;
SELECT F1(ARRAY(2, 4)) AS x, F1(ARRAY(4.5, 7.7)) AS x;
SELECT F1(x) FROM x;
SELECT F1(ARRAY(2, 4)) AS x, F1(ARRAY(4.5, 7.7)) AS x;
SELECT F1(x) FROM x;
SELECT F1(INT4RANGE(42, 49)) AS x, F1(FLOAT8RANGE(4.5, 7.8)) AS x;
SELECT F1(2, 4) AS x, F1(2, 4.5) AS x;
SELECT F1(INT4RANGE(42, 49), 11, CAST(2 AS SMALLINT)) AS x, F1(FLOAT8RANGE(4.5, 7.8), 7.8, CAST(11 AS FLOAT)) AS x;
SELECT F1(INT4RANGE(42, 49), 11, 4.5) AS x;
SELECT F1(INT4RANGE(42, 49), ARRAY(11)) AS x, F1(FLOAT8RANGE(4.5, 7.8), ARRAY(7)) AS x;
x := ARRAY(x, x);
SELECT x, PG_TYPEOF(x), x, PG_TYPEOF(x) FROM x;
SELECT x, PG_TYPEOF(x), x, PG_TYPEOF(x) FROM x;
SELECT x, PG_TYPEOF(x), x, PG_TYPEOF(x) FROM x;
SELECT x, PG_TYPEOF(x), x, PG_TYPEOF(x) FROM x;
x;
SELECT F1(42);
SELECT * FROM x;
SELECT F1(42);
SELECT * FROM x;
DROP FUNCTION x (INT);
x AS x;
x := x + 2;
x AS x;
x;
SELECT * FROM x;
DROP FUNCTION x (INT);
x := x + 1;
x := 'foo';
SELECT F1(42);
SELECT * FROM x;
DROP FUNCTION x (INT);
x := 'foo';
x AS x;
x := x + 1;
x := 'foot';
x AS x;
SELECT * FROM x;
DROP FUNCTION x (INT);
x := ARRAY(x, x);
x;
SELECT * FROM x;
SELECT * FROM x;
DROP FUNCTION x (anyelement);
x := ARRAY(LOWER(x), UPPER(x));
x;
SELECT * FROM x;
SELECT * FROM x;
DROP FUNCTION x (anycompatiblerange);
/* test PERFORM */ CREATE TABLE x (x INT, x INT);
x AS x;
COMMIT;
IF FOUND then 		INSERT INTO perform_test VALUES (100, 100);
IF FOUND then 		INSERT INTO perform_test VALUES (100, 100);
x;
COMMIT;
SELECT PERFORM_TEST_FUNC();
SELECT * FROM x;
DROP TABLE x;
/* Test proper snapshot handling in simple expressions */ CREATE TEMPORARY TABLE x (x TEXT, x SERIAL);
BEGIN select into x id from users where login = a_login;
if found then return x;
INSERT INTO x VALUES ('user1');
SELECT SP_ID_USER('user1');
SELECT SP_ID_USER('userx');
BEGIN my_id_user = sp_id_user( a_login );
IF my_id_user > 0 THEN     RETURN -1;
INSERT INTO x (x) VALUES (x);
x = SP_ID_USER(x);
IF my_id_user = 0 THEN     RETURN -2;
x AS x;
SELECT SP_ADD_USER('user1');
SELECT SP_ADD_USER('user2');
SELECT SP_ADD_USER('user2');
SELECT SP_ADD_USER('user3');
SELECT SP_ADD_USER('user3');
DROP FUNCTION x (TEXT);
DROP FUNCTION x (TEXT);
/* tests for refcursors */ CREATE TABLE x (x INT, x INT);
COPY INTO x FROM x;
BEGIN open rc for select a from rc_test;
x AS x;
x AS x;
BEGIN rc := return_unnamed_refcursor();
FETCH next from rc into x;
SELECT USE_REFCURSOR(RETURN_UNNAMED_REFCURSOR());
x AS x;
x AS @1;
BEGIN;
SELECT REFCURSOR_TEST1('test1');
FETCH next in test1;
SELECT REFCURSOR_TEST1('test2');
FETCH all from test2;
COMMIT;
/* should fail */ FETCH next from test1;
x AS x;
BEGIN open c1($1, $2);
FETCH c1 into nonsense;
x AS x;
if found then         return true;
SELECT REFCURSOR_TEST2(20000, 20000) AS "x", REFCURSOR_TEST2(20, 20) AS "x";
BEGIN open rc for select a from rc_test;
x AS x;
SELECT CONSTANT_REFCURSOR();
BEGIN open rc for select a from rc_test;
x AS x;
SELECT CONSTANT_REFCURSOR();
x AS x;
BEGIN open c1(param12 := $2, param1 := $1);
FETCH c1 into nonsense;
x AS x;
if found then         return true;
SELECT NAMEDPARMCURSOR_TEST1(20000, 20000) AS "x", NAMEDPARMCURSOR_TEST1(20, 20) AS "x";
x AS x;
BEGIN open c1(param1 := $1, $2);
FETCH c1 into nonsense;
x AS x;
if found then         return true;
SELECT NAMEDPARMCURSOR_TEST2(20, 20);
BEGIN open c1(param2 := 20, 21);
BEGIN open c1(20, param1 := 21);
BEGIN open c1 (p2 := 77, p2 := 42);
BEGIN open c1 (p2 := 77);
BEGIN open c1 (p2 := 77, p1 := 42/0);
SELECT NAMEDPARMCURSOR_TEST7();
x AS x;
BEGIN open c1 (77 -- test   , 42);
FETCH c1 into n;
x AS x;
SELECT NAMEDPARMCURSOR_TEST8();
x AS x;
BEGIN -- use both supported syntaxes for named arguments   open c1 (p1 := p1, p2 => p2, debug => 2);
FETCH c1 into n;
x AS x;
SELECT NAMEDPARMCURSOR_TEST9(6);
x AS @1;
COMMIT;
x AS @1;
COMMIT;
x AS @1;
COMMIT;
SELECT RAISE_TEST3(1);
x;
COMMIT;
COMMIT;
COMMIT;
SELECT RERAISE_TEST();
BEGIN a := 5;
x AS x;
x := 10;
x AS x;
BEGIN for r in select I fought the law, the law won LOOP         raise notice 'in loop';
COMMIT;
COMMIT;
COMMIT;
COMMIT;
SELECT VOID_RETURN_EXPR();
COMMIT;
SELECT MISSING_RETURN_EXPR();
DROP FUNCTION x;
DROP FUNCTION x;
/* EXECUTE ... INTO test */ CREATE TABLE x (x INT, x INT);
create type eitype as (i integer, y integer);
x AS x;
x AS x;
x AS x;
x AS x;
BEGIN execute 'insert into '||$1||' values(10,15)';
EXECUTE 'select (row).* from (select row(10,1)::eifoo) s' into _r;
EXECUTE 'select * from '||$1||' limit 1' into _rt;
EXECUTE 'select *, 20 from '||$1||' limit 1' into i, j, k;
EXECUTE 'select 1,2' into _v;
x AS x;
COMMIT;
SELECT EXECUTE_INTO_TEST('eifoo');
DROP TABLE x CASCADE;
drop type eitype cascade;
COMMIT;
/* should fail: SQLSTATE and SQLERRM are only in defined EXCEPTION */ /* blocks */ SELECT EXCPT_TEST1();
COMMIT;
COMMIT;
COMMIT;
/* should fail */ SELECT EXCPT_TEST2();
BEGIN raise notice '% %', sqlstate, sqlerrm;
COMMIT;
COMMIT;
COMMIT;
SELECT EXCPT_TEST3();
COMMIT;
COMMIT;
SELECT EXCPT_TEST4();
DROP FUNCTION x;
DROP FUNCTION x;
DROP FUNCTION x;
DROP FUNCTION x;
x AS x;
BEGIN i := 2;
COMMIT;
SELECT RAISE_EXPRS();
DROP FUNCTION x;
x AS x;
BEGIN select into x,y unique1/p1, unique1/$1 from tenk1 group by unique1/p1;
SELECT MULTI_DATUM_USE(42);
/* Test STRICT limiter in both planned and EXECUTE invocations. */ /* Note that a data-modifying query is quasi strict (disallow multi rows) */ /* by default in the planned case, but not in EXECUTE. */ CREATE TEMPORARY TABLE x (x INT, x INT);
INSERT INTO x VALUES (1, 2), (3, 4);
BEGIN -- should work   insert into foo values(5,6) returning * into x;
SELECT STRICTTEST();
BEGIN -- should fail due to implicit strict   insert into foo values(7,8),(9,10) returning * into x;
SELECT STRICTTEST();
BEGIN -- should work   execute 'insert into foo values(5,6) returning *' into x;
SELECT STRICTTEST();
BEGIN -- this should work since EXECUTE isn't as picky   execute 'insert into foo values(7,8),(9,10) returning *' into x;
SELECT STRICTTEST();
SELECT * FROM x;
BEGIN -- should work   select * from foo where f1 = 3 into strict x;
SELECT STRICTTEST();
BEGIN -- should fail, no rows   select * from foo where f1 = 0 into strict x;
SELECT STRICTTEST();
BEGIN -- should fail, too many rows   select * from foo where f1 > 3 into strict x;
SELECT STRICTTEST();
BEGIN -- should work   execute 'select * from foo where f1 = 3' into strict x;
SELECT STRICTTEST();
BEGIN -- should fail, no rows   execute 'select * from foo where f1 = 0' into strict x;
SELECT STRICTTEST();
BEGIN -- should fail, too many rows   execute 'select * from foo where f1 > 3' into strict x;
SELECT STRICTTEST();
DROP FUNCTION x;
SET x.x = TRUE /* test printing parameters after failure due to STRICT */;
BEGIN -- no rows   select * from foo where f1 = p1 and f1::text = p3 into strict x;
SELECT STRICTTEST();
BEGIN -- no rows   select * from foo where f1 = p1 and f1::text = p3 into strict x;
SELECT STRICTTEST();
BEGIN -- too many rows   select * from foo where f1 > p1 or f1::text = p3  into strict x;
SELECT STRICTTEST();
BEGIN -- too many rows, no params   select * from foo where f1 > 3 into strict x;
SELECT STRICTTEST();
BEGIN -- no rows   execute 'select * from foo where f1 = $1 or f1::text = $2' using 0, 'foo' into strict x;
SELECT STRICTTEST();
BEGIN -- too many rows   execute 'select * from foo where f1 > $1' using 1 into strict x;
SELECT STRICTTEST();
BEGIN -- too many rows, no parameters   execute 'select * from foo where f1 > 3' into strict x;
SELECT STRICTTEST();
BEGIN -- too many rows   select * from foo where f1 > p1 or f1::text = p3  into strict x;
SELECT STRICTTEST();
RESET plpgsql.print_strict_params;
BEGIN -- too many rows   select * from foo where f1 > p1 or f1::text = p3  into strict x;
SELECT STRICTTEST();
SET x.x = 'all' /* test warnings and errors */;
SET x.x = 'none';
SET x.x = 'all';
SET x.x = 'none';
SET x.x = 'shadowed_variables' /* test warnings when shadowing a variable */;
x AS x;
SELECT SHADOWTEST(1);
SET x.x = 'shadowed_variables';
SELECT SHADOWTEST(1);
x AS x;
SELECT SHADOWTEST(1);
DROP FUNCTION x (INT);
BEGIN declare 	f1 int;
BEGIN end;
DROP FUNCTION x;
BEGIN declare 	in1 int;
BEGIN end;
DROP FUNCTION x (INT);
BEGIN end$$ language plpgsql;
DROP FUNCTION x;
SET x.x = 'shadowed_variables' /* test errors when shadowing a variable */;
BEGIN return 1;
SELECT SHADOWTEST(1);
RESET plpgsql.extra_errors;
RESET plpgsql.extra_warnings;
BEGIN return 1;
SELECT SHADOWTEST(1);
SET x.x = 'too_many_rows' /* runtime extra checks */;
BEGIN select v from generate_series(1,2) g(v) into x;
COMMIT;
SET x.x = 'too_many_rows';
BEGIN select v from generate_series(1,2) g(v) into x;
COMMIT;
RESET plpgsql.extra_errors;
RESET plpgsql.extra_warnings;
SET x.x = 'strict_multi_assignment';
x AS x;
BEGIN select 1 into x, y;
CREATE TABLE x AS SELECT 1, 2, x;
CREATE TABLE x AS SELECT 1, 2, 3, x;
SET x.x = 'strict_multi_assignment';
x AS x;
BEGIN select 1 into x, y;
CREATE TABLE x AS SELECT 1, 2, x;
CREATE TABLE x AS SELECT 1, 2, 3, x;
CREATE TABLE x (x INT, x INT, x INT);
ALTER TABLE x DROP COLUMN x;
/* the check is active only when source table is not empty */ INSERT INTO x VALUES (10, 20);
x AS x;
BEGIN select * from test_01 into x, y;
COMMIT /* should to fail */ /* should to fail */;
BEGIN select 1, 2 into t;
CREATE TABLE x AS SELECT 1, 2, 3;
COMMIT;
BEGIN select 1 into t;
COMMIT;
DROP TABLE x;
RESET plpgsql.extra_errors;
RESET plpgsql.extra_warnings;
x AS x;
BEGIN open c;
FETCH last from c into x;
FETCH prior from c into x;
x AS x;
COMMIT;
SELECT * FROM x;
x AS x;
BEGIN open c;
FETCH last from c into x;
FETCH prior from c into x;
x AS x;
COMMIT;
SELECT * FROM x;
x AS x;
BEGIN open c scroll for select f1 from int4_tbl;
FETCH last from c into x;
FETCH prior from c into x;
x AS x;
COMMIT;
SELECT * FROM x;
x AS x;
BEGIN open c scroll for execute 'select f1 from int4_tbl';
FETCH last from c into x;
FETCH relative -2 from c into x;
x AS x;
COMMIT;
SELECT * FROM x;
x AS x;
BEGIN open c scroll for execute 'select f1 from int4_tbl';
FETCH last from c into x;
FETCH relative -1 from c into x;
x AS x;
COMMIT;
SELECT * FROM x;
x AS x;
BEGIN open c;
if not found then           exit;
FETCH next from c into x;
if found then           return next x;
x AS x;
COMMIT;
SELECT * FROM x;
x AS x;
BEGIN open c;
FETCH backward from c into x;
if found then     return next x;
x AS x;
COMMIT;
SELECT * FROM x;
DROP FUNCTION x;
BEGIN <<innerblock>>   declare     param1 int := 2;
BEGIN raise notice 'param1 = %', param1;
COMMIT;
COMMIT;
SELECT PL_QUAL_NAMES(42);
DROP FUNCTION x (INT);
@2 := -2;
x AS x;
x AS x;
COMMIT;
SELECT * FROM x;
create type record_type as (x text, y int, z boolean);
COMMIT;
SELECT * FROM x;
BEGIN for i in execute 'select * from generate_series(1,$1)' using $1+1 loop     raise notice '%', i;
EXECUTE 'select $2 + $2*3 + length($1)' into i using $2,$1;
x AS x;
SELECT EXC_USING(5, 'foobar');
DROP FUNCTION x (INT, TEXT);
x AS x;
BEGIN open c for execute 'select * from generate_series(1,$1)' using $1+1;
x AS x;
x;
COMMIT;
SELECT EXC_USING(5);
DROP FUNCTION x (INT);
BEGIN -- assign portal names to cursors to get stable output   c := 'c';
x := 'c2';
x := 'special_name';
x := NULL;
x;
COMMIT;
SELECT FORC01();
/* try updating the cursor's current row */ CREATE TEMPORARY TABLE x AS SELECT x AS x, x AS x FROM x AS x;
BEGIN for r in c loop     raise notice '%, %', r.i, r.j;
COMMIT;
SELECT FORC01();
SELECT * FROM x;
x AS x;
BEGIN open c for select * from forc_test;
COMMIT;
SELECT FORC01();
SELECT * FROM x;
DROP FUNCTION x;
BEGIN for r1 in c1 loop     declare c1 cursor for select * from forc_test;
BEGIN for r2 in c1 loop         cnt := cnt + 1;
COMMIT;
BEGIN for r in c loop     raise notice '%', r.i;
COMMIT;
COMMIT;
SELECT * FROM x;
DROP FUNCTION x;
/* test RETURN QUERY with dropped columns */ CREATE TABLE x (x INT, x INT, x INT, x INT);
INSERT INTO x VALUES (10, 20, 30, 40), (50, 60, 70, 80);
COMMIT;
SELECT * FROM x;
ALTER TABLE x DROP COLUMN x;
SELECT * FROM x;
ALTER TABLE x DROP COLUMN x;
SELECT * FROM x;
ALTER TABLE x ADD COLUMN x INT;
SELECT * FROM x;
DROP FUNCTION x;
DROP TABLE x;
/* Tests for composite-type results */ create type compostype as (x int, y varchar);
BEGIN v := (1, 'hello');
x AS x;
COMMIT;
SELECT COMPOS();
BEGIN v := (1, 'hello'::varchar);
x AS x;
COMMIT;
SELECT COMPOS();
COMMIT;
SELECT COMPOS();
COMMIT;
SELECT COMPOS();
COMMIT;
SELECT COMPOS();
DROP FUNCTION x;
BEGIN v := (1, 'hello');
x AS x;
COMMIT;
SELECT COMPOSREC();
COMMIT;
SELECT COMPOSREC();
DROP FUNCTION x;
COMMIT;
SELECT * FROM x;
DROP FUNCTION x;
COMMIT;
SELECT COMPOS();
BEGIN return x;
COMMIT;
SELECT * FROM x;
DROP FUNCTION x;
BEGIN v := (1, 'hello');
x AS x;
COMMIT;
SELECT COMPOS();
COMMIT;
SELECT COMPOS();
DROP FUNCTION x;
drop type compostype;
COMMIT;
SELECT RAISE_TEST();
x;
COMMIT;
SELECT RAISE_TEST();
x;
COMMIT;
SELECT RAISE_TEST();
x;
COMMIT;
SELECT RAISE_TEST();
x;
COMMIT;
SELECT RAISE_TEST();
COMMIT;
SELECT RAISE_TEST();
COMMIT;
SELECT RAISE_TEST();
COMMIT;
SELECT RAISE_TEST();
COMMIT;
SELECT RAISE_TEST();
COMMIT;
SELECT RAISE_TEST();
COMMIT;
SELECT RAISE_TEST();
COMMIT;
SELECT RAISE_TEST();
BEGIN return 10 / v;
COMMIT;
COMMIT;
x AS x;
x AS x;
BEGIN perform zero_divide();
COMMIT;
SELECT STACKED_DIAGNOSTICS_TEST();
x AS x;
x AS x;
BEGIN perform raise_test();
COMMIT;
SELECT STACKED_DIAGNOSTICS_TEST();
x AS x;
x AS x;
BEGIN get stacked diagnostics         _message = message_text,         _detail = pg_exception_detail,         _hint = pg_exception_hint;
COMMIT;
SELECT STACKED_DIAGNOSTICS_TEST();
DROP FUNCTION x;
COMMIT;
SET x = on;
EXPLAIN (verbose, costs off) select error_trap_test();
SELECT ERROR_TRAP_TEST();
RESET debug_parallel_query;
DROP FUNCTION x;
DROP FUNCTION x;
COMMIT;
SELECT RAISE_TEST();
DROP FUNCTION x;
x AS x;
x AS x;
x AS x;
x AS x;
BEGIN raise exception using     column = '>>some column name<<',     constraint = '>>some constraint name<<',     datatype = '>>some datatype name<<',     table = '>>some table name<<',     schema = '>>some schema name<<';
COMMIT;
SELECT STACKED_DIAGNOSTICS_TEST();
DROP FUNCTION x;
COMMIT;
SELECT VARI(1, 2, 3, 4, 5);
SELECT VARI(3, 4, 5);
DROP FUNCTION x (ARRAY<INT>);
BEGIN for i in array_lower($1,1)+1..array_upper($1,1) loop     if $1[i] < aux then aux := $1[i];
x AS x;
COMMIT;
SELECT PLEAST(10, 1, 2, 3, -16);
SELECT PLEAST(10.2, 2.2, -1.1);
SELECT PLEAST(10.2, 10, -20);
SELECT PLEAST(10, 20, -1.0);
x AS @1;
COMMIT;
SELECT PLEAST(10);
DROP FUNCTION x (ARRAY<DECIMAL>);
DROP FUNCTION x (DECIMAL);
COMMIT;
SELECT * FROM x;
x := x + 1;
x AS x;
x := x * 10;
x := x * 10 + 1;
x AS x;
COMMIT;
SELECT * FROM x;
DROP FUNCTION x (INT);
BEGIN return query values(10),(20);
COMMIT;
SELECT * FROM x;
COMMIT;
SELECT * FROM x;
COMMIT;
SELECT * FROM x;
SELECT * FROM x;
DROP FUNCTION x;
BEGIN BEGIN     v_var := (leaker_2(fail)).error_code;
COMMIT;
COMMIT;
x := 1;
x := 1;
x;
COMMIT;
SELECT * FROM x;
SELECT * FROM x;
DROP FUNCTION x (BOOLEAN);
DROP FUNCTION x (BOOLEAN);
x AS x;
x AS x;
BEGIN arr := array[array['foo','bar'], array['baz', 'quux']];
x := 'fool';
x := 1;
x /* use sub-SELECTs to make expressions non-simple */[(SELECT x)][(SELECT x + 1)] := (SELECT x);
x AS x;
COMMIT;
SELECT NONSIMPLE_EXPR_TEST();
DROP FUNCTION x;
BEGIN begin     i := (SELECT NULL::integer);
COMMIT;
x AS x;
COMMIT;
SELECT NONSIMPLE_EXPR_TEST();
DROP FUNCTION x;
COMMIT;
SELECT RECURSE(10);
CREATE FUNCTION x(x) RETURNS TEXT LANGUAGE sql AS $$ SELECT relname::text FROM pg_class c WHERE c.oid = $1::regclass $$;
x;
BEGIN;
CREATE TABLE x.x (x TEXT);
x AS x;
SELECT ERROR2('nonexistent.stuffs');
ROLLBACK TO x;
SELECT ERROR2('public.stuffs');
ROLLBACK;
DROP FUNCTION x (TEXT);
/* Test for proper handling of cast-expression caching */ CREATE FUNCTION x(x) RETURNS DATE LANGUAGE sql IMMUTABLE STRICT AS $$ select $1::text::date $$;
create cast (integer as date) with function sql_to_date(integer) as assignment;
SELECT CAST_INVOKER(20150717);
SELECT CAST_INVOKER(20150718);
/* second call crashed in pre-release 9.5 */ BEGIN;
SELECT CAST_INVOKER(20150717);
SELECT CAST_INVOKER(20150718);
x AS x;
SELECT CAST_INVOKER(20150718);
SELECT CAST_INVOKER(-1);
ROLLBACK TO x /* fails */;
SELECT CAST_INVOKER(20150719);
SELECT CAST_INVOKER(20150720);
COMMIT;
DROP FUNCTION x (INT);
DROP FUNCTION x (INT) CASCADE;
/* Test handling of cast cache inside DO blocks */ /* (to check the original crash case, this must be a cast not previously */ /* used in this session) */ BEGIN;
BEGIN x := '{1.23, 4.56}'::numeric[];
BEGIN x := '{1.23, 4.56}'::numeric[];
COMMIT;
SELECT FAIL();
SELECT FAIL();
DROP FUNCTION x;
SET x = off /* Test handling of string literals. */;
SELECT STRTEST();
SELECT STRTEST();
SET x = on;
SELECT STRTEST();
SELECT STRTEST();
DROP FUNCTION x;
BEGIN FOR r IN SELECT rtrim(roomno) AS roomno, comment FROM Room ORDER BY roomno     LOOP         RAISE NOTICE '%, %', r.roomno, r.comment;
x;
x;
BEGIN FOR r IN SELECT rtrim(roomno) AS roomno, foo FROM Room ORDER BY roomno     LOOP         RAISE NOTICE '%, %', r.roomno, r.comment;
x;
BEGIN x := 1 / x;
COMMIT;
@x$;
COMMIT;
COMMIT;
@uter$;
/* error */ BEGIN raise notice 'x = %', x;
COMMIT;
BEGIN raise notice 'x = %, y = %', x, y;
COMMIT;
BEGIN raise notice 'x = %, y = %', x, y;
COMMIT;
BEGIN declare y int := x + 1;
BEGIN raise notice 'x = %, y = %, z = %', x, y, z;
COMMIT;
COMMIT;
SET x.x = error /* Check handling of conflicts between plpgsql vars and table columns. */;
BEGIN for r in select q1,q2 from int8_tbl loop     return next r;
COMMIT;
SELECT * FROM x;
BEGIN for r in select q1,q2 from int8_tbl loop     return next r;
COMMIT;
SELECT * FROM x;
BEGIN for r in select q1,q2 from int8_tbl loop     return next r;
COMMIT;
SELECT * FROM x;
DROP FUNCTION x;
BEGIN forward := forward * 2;
x AS x;
SELECT UNRESERVED_TEST();
BEGIN return := return + 1;
x AS x;
SELECT UNRESERVED_TEST();
BEGIN comment := comment * 2;
COMMENT ON function x() IS 'this is a test';
x AS x;
SELECT UNRESERVED_TEST();
SELECT OBJ_DESCRIPTION(CAST('unreserved_test()' AS REGPROCEDURE), 'pg_proc');
DROP FUNCTION x;
BEGIN foreach x in array $1   loop     raise notice '%', x;
COMMIT;
SELECT FOREACH_TEST(ARRAY(1, 2, 3, 4));
SELECT FOREACH_TEST(ARRAY(ARRAY(1, 2), ARRAY(3, 4)));
BEGIN foreach x slice 1 in array $1   loop     raise notice '%', x;
COMMIT;
/* should fail */ SELECT FOREACH_TEST(ARRAY(1, 2, 3, 4));
SELECT FOREACH_TEST(ARRAY(ARRAY(1, 2), ARRAY(3, 4)));
BEGIN foreach x slice 1 in array $1   loop     raise notice '%', x;
COMMIT;
SELECT FOREACH_TEST(ARRAY(1, 2, 3, 4));
SELECT FOREACH_TEST(ARRAY(ARRAY(1, 2), ARRAY(3, 4)));
BEGIN foreach x slice 2 in array $1   loop     raise notice '%', x;
COMMIT;
/* should fail */ SELECT FOREACH_TEST(ARRAY(1, 2, 3, 4));
/* ok */ SELECT FOREACH_TEST(ARRAY(ARRAY(1, 2), ARRAY(3, 4)));
SELECT FOREACH_TEST(ARRAY(ARRAY(ARRAY(1, 2)), ARRAY(ARRAY(3, 4))));
create type xy_tuple AS (x int, y int);
BEGIN foreach r in array $1   loop     raise notice '%', r;
COMMIT;
SELECT FOREACH_TEST(CAST(ARRAY((10, 20), (40, 69), (35, 78)) AS ARRAY<xy_tuple>));
SELECT FOREACH_TEST(CAST(ARRAY(ARRAY((10, 20), (40, 69)), ARRAY((35, 78), (88, 76))) AS ARRAY<xy_tuple>));
x AS x;
BEGIN foreach x, y in array $1   loop     raise notice 'x = %, y = %', x, y;
COMMIT;
SELECT FOREACH_TEST(CAST(ARRAY((10, 20), (40, 69), (35, 78)) AS ARRAY<xy_tuple>));
SELECT FOREACH_TEST(CAST(ARRAY(ARRAY((10, 20), (40, 69)), ARRAY((35, 78), (88, 76))) AS ARRAY<xy_tuple>));
BEGIN foreach x slice 1 in array $1   loop     raise notice '%', x;
COMMIT;
SELECT FOREACH_TEST(CAST(ARRAY((10, 20), (40, 69), (35, 78)) AS ARRAY<xy_tuple>));
SELECT FOREACH_TEST(CAST(ARRAY(ARRAY((10, 20), (40, 69)), ARRAY((35, 78), (88, 76))) AS ARRAY<xy_tuple>));
DROP FUNCTION x (anyarray);
drop type xy_tuple;
/* Assorted tests for array subscript assignment */ CREATE TEMPORARY TABLE x (x INT, x ARRAY<TEXT>);
BEGIN r := row(12, '{foo,bar,baz}')::rtype;
x.x[1] := 'replace';
x;
SELECT ARRAYASSIGN1();
SELECT ARRAYASSIGN1();
/* try again to exercise internal caching */ create domain orderedarray as int[2]   constraint sorted check (value[1] < value[2]);
SELECT CAST('{1,2}' AS orderedarray);
SELECT CAST('{2,1}' AS orderedarray);
BEGIN res := array[x1, x2];
x[1] := x;
x AS x;
x;
SELECT TESTOA(1, 2, 3);
SELECT TESTOA(1, 2, 3);
/* try again to exercise internal caching */ SELECT TESTOA(2, 1, 3);
/* fail at initial assign */ SELECT TESTOA(1, 2, 1);
/* fail at update */ DROP FUNCTION x;
BEGIN r := array[$1, $1];
x AS x;
COMMIT;
COMMIT;
SELECT CONSUMES_RW_ARRAY(RETURNS_RW_ARRAY(42));
/* bug #14174 */ EXPLAIN (verbose, costs off) select i, a from   (select returns_rw_array(1) as a offset 0) ss,   lateral consumes_rw_array(a) i;
SELECT x, x FROM (SELECT RETURNS_RW_ARRAY(1) AS x OFFSET 0) AS x, LATERAL CONSUMES_RW_ARRAY(x) AS x;
EXPLAIN (verbose, costs off) select consumes_rw_array(a), a from returns_rw_array(1) a;
SELECT CONSUMES_RW_ARRAY(x), x FROM x AS x;
EXPLAIN (verbose, costs off) select consumes_rw_array(a), a from   (values (returns_rw_array(1)), (returns_rw_array(2))) v(a);
SELECT CONSUMES_RW_ARRAY(x), x FROM (VALUES (RETURNS_RW_ARRAY(1)), (RETURNS_RW_ARRAY(2))) AS x;
BEGIN a := a || 3;
x;
BEGIN get diagnostics _context = pg_context;
COMMIT;
BEGIN raise notice 'calling down into inner_func()';
x := INNER_FUNC(@1);
x AS x;
COMMIT;
BEGIN raise notice 'calling down into outer_func()';
x := OUTER_FUNC(@1);
x AS x;
COMMIT;
SELECT OUTER_OUTER_FUNC(10);
/* repeated call should work */ SELECT OUTER_OUTER_FUNC(20);
DROP FUNCTION x (INT);
DROP FUNCTION x (INT);
DROP FUNCTION x (INT);
BEGIN begin     perform sx / 0;
COMMIT;
COMMIT;
BEGIN raise notice 'calling down into inner_func()';
x := INNER_FUNC(@1);
x AS x;
COMMIT;
BEGIN raise notice 'calling down into outer_func()';
x := OUTER_FUNC(@1);
x AS x;
COMMIT;
SELECT OUTER_OUTER_FUNC(10);
/* repeated call should work */ SELECT OUTER_OUTER_FUNC(20);
DROP FUNCTION x (INT);
DROP FUNCTION x (INT);
DROP FUNCTION x (INT);
BEGIN get diagnostics fn_oid = pg_routine_oid;
x AS x;
COMMIT;
SELECT CURRENT_FUNCTION('foo');
DROP FUNCTION x (TEXT);
BEGIN get diagnostics fn_oid = pg_routine_oid;
COMMIT;
COMMIT /* should succeed */ /* should succeed */;
COMMIT /* should fail */ /* should fail */;
COMMIT /* should fail */ /* should fail */;
SET x.x = off /* check controlling GUC */;
COMMIT /* won't be tested */ /* won't be tested */;
RESET plpgsql.check_asserts;
BEGIN assert 1=0, format('assertion failed, var = "%s"', var);
COMMIT;
COMMIT /* do nothing */ /* do nothing */;
create domain plpgsql_domain as integer check(plpgsql_domain_check(value));
BEGIN v_test := 1;
COMMIT;
BEGIN v_test := 0;
COMMIT /* fail */ /* fail */;
create domain plpgsql_arr_domain as int[] check(plpgsql_arr_domain_check(value));
BEGIN v_test := array[1];
x := x || 2;
COMMIT;
BEGIN v_test := 0 || v_test;
COMMIT /* fail */ /* fail */;
/* test usage of transition tables in AFTER triggers */ CREATE TABLE x (x INT PRIMARY KEY, x TEXT);
x AS x;
BEGIN t = '';
x AS x;
COMMIT;
CREATE TRIGGER transition_table_base_ins_trig   AFTER INSERT ON transition_table_base   REFERENCING OLD TABLE AS oldtable NEW TABLE AS newtable   FOR EACH STATEMENT   EXECUTE PROCEDURE transition_table_base_ins_func();
CREATE TRIGGER transition_table_base_ins_trig   AFTER INSERT ON transition_table_base   REFERENCING NEW TABLE AS newtable   FOR EACH STATEMENT   EXECUTE PROCEDURE transition_table_base_ins_func();
INSERT INTO x VALUES (1, 'One'), (2, 'Two');
INSERT INTO x VALUES (3, 'Three'), (4, 'Four');
x AS x;
BEGIN t = '';
x AS x;
COMMIT;
CREATE TRIGGER transition_table_base_upd_trig   AFTER UPDATE ON transition_table_base   REFERENCING OLD TABLE AS oldtable NEW TABLE AS newtable   FOR EACH STATEMENT   EXECUTE PROCEDURE transition_table_base_upd_func();
UPDATE x SET x = '*' || x || '*' WHERE x BETWEEN 2 AND 3;
CREATE TABLE transition_table_level1 (       level1_no serial NOT NULL ,       level1_node_name varchar(255),        PRIMARY KEY (level1_no) ) WITHOUT OIDS;
CREATE TABLE transition_table_level2 (       level2_no serial NOT NULL ,       parent_no int NOT NULL,       level1_node_name varchar(255),        PRIMARY KEY (level2_no) ) WITHOUT OIDS;
CREATE TABLE transition_table_status (       level int NOT NULL,       node_no int NOT NULL,       status int,        PRIMARY KEY (level, node_no) ) WITHOUT OIDS;
BEGIN PERFORM FROM p JOIN transition_table_level2 c ON c.parent_no = p.level1_no;
IF FOUND THEN       RAISE EXCEPTION 'RI error';
x AS x;
COMMIT;
CREATE TRIGGER transition_table_level1_ri_parent_del_trigger   AFTER DELETE ON transition_table_level1   REFERENCING OLD TABLE AS p   FOR EACH STATEMENT EXECUTE PROCEDURE     transition_table_level1_ri_parent_del_func();
BEGIN WITH p AS (SELECT level1_no, sum(delta) cnt                  FROM (SELECT level1_no, 1 AS delta FROM i                        UNION ALL                        SELECT level1_no, -1 AS delta FROM d) w                  GROUP BY level1_no                  HAVING sum(delta) < 0)     SELECT level1_no       FROM p JOIN transition_table_level2 c ON c.parent_no = p.level1_no       INTO x;
IF FOUND THEN       RAISE EXCEPTION 'RI error';
x AS x;
COMMIT;
CREATE TRIGGER transition_table_level1_ri_parent_upd_trigger   AFTER UPDATE ON transition_table_level1   REFERENCING OLD TABLE AS d NEW TABLE AS i   FOR EACH STATEMENT EXECUTE PROCEDURE     transition_table_level1_ri_parent_upd_func();
IF FOUND THEN       RAISE EXCEPTION 'RI error';
x AS x;
COMMIT;
CREATE TRIGGER transition_table_level2_ri_child_ins_trigger   AFTER INSERT ON transition_table_level2   REFERENCING NEW TABLE AS i   FOR EACH STATEMENT EXECUTE PROCEDURE     transition_table_level2_ri_child_insupd_func();
CREATE TRIGGER transition_table_level2_ri_child_upd_trigger   AFTER UPDATE ON transition_table_level2   REFERENCING NEW TABLE AS i   FOR EACH STATEMENT EXECUTE PROCEDURE     transition_table_level2_ri_child_insupd_func();
/* create initial test data */ INSERT INTO x (x) SELECT UNNEST(GENERATE_SERIES(1, 200));
ANALYZE x;
INSERT INTO x (x, x) SELECT x, x / 50 + 1 AS x FROM x AS x;
ANALYZE x;
INSERT INTO x (x, x, x) SELECT 1, x, 0 FROM x;
INSERT INTO x (x, x, x) SELECT 2, x, 0 FROM x;
ANALYZE x;
INSERT INTO x (x) SELECT UNNEST(GENERATE_SERIES(201, 1000));
ANALYZE x;
x AS x;
COMMIT;
CREATE TRIGGER transition_table_level2_bad_usage_trigger   AFTER DELETE ON transition_table_level2   REFERENCING OLD TABLE AS dx   FOR EACH STATEMENT EXECUTE PROCEDURE     transition_table_level2_bad_usage_func();
DELETE FROM x WHERE x BETWEEN 301 AND 305;
DROP TRIGGER transition_table_level2_bad_usage_trigger   ON transition_table_level2;
/* attempt modifications which would break RI (should all fail) */ DELETE FROM x WHERE x = 25;
UPDATE x SET x = -1 WHERE x = 30;
INSERT INTO x (x, x) VALUES (10000, 10000);
UPDATE x SET x = 2000 WHERE x = 40;
/* attempt modifications which would not break RI (should all succeed) */ DELETE FROM x WHERE x BETWEEN 201 AND 1000;
DELETE FROM x WHERE x BETWEEN 100000000 AND 100000010;
SELECT COUNT(*) FROM x;
DELETE FROM x WHERE x BETWEEN 211 AND 220;
SELECT COUNT(*) FROM x;
CREATE TABLE x (x INT PRIMARY KEY, x TEXT);
x AS x;
COMMIT;
/* should fail, TRUNCATE is not compatible with transition tables */ CREATE TRIGGER alter_table_under_transition_tables_upd_trigger   AFTER TRUNCATE OR UPDATE ON alter_table_under_transition_tables   REFERENCING OLD TABLE AS d NEW TABLE AS i   FOR EACH STATEMENT EXECUTE PROCEDURE     alter_table_under_transition_tables_upd_func();
/* should work */ CREATE TRIGGER alter_table_under_transition_tables_upd_trigger   AFTER UPDATE ON alter_table_under_transition_tables   REFERENCING OLD TABLE AS d NEW TABLE AS i   FOR EACH STATEMENT EXECUTE PROCEDURE     alter_table_under_transition_tables_upd_func();
INSERT INTO x VALUES (1, '1'), (2, '2'), (3, '3');
UPDATE x SET x = x || x;
ALTER TABLE x ALTER COLUMN x SET DATA TYPE INT USING CAST(x AS INT) /* now change 'name' to an integer to see what happens... */;
UPDATE x SET x = CAST((CAST(x AS TEXT) || CAST(x AS TEXT)) AS INT);
ALTER TABLE x DROP COLUMN x /* now drop column 'name' */;
UPDATE x SET x = x;
/* Test multiple reference to a transition table */ CREATE TABLE x (x INT);
INSERT INTO x VALUES (1);
x AS x;
x;
CREATE TRIGGER my_trigger AFTER UPDATE ON multi_test   REFERENCING NEW TABLE AS new_test OLD TABLE as old_test   FOR EACH STATEMENT EXECUTE PROCEDURE multi_test_trig();
UPDATE x SET x = x;
DROP TABLE x;
DROP FUNCTION x;
/* Check type parsing and record fetching from partitioned tables */ CREATE TABLE x (x INT, x TEXT) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN (1);
CREATE TABLE x PARTITION OF x FOR VALUES IN (2);
INSERT INTO x VALUES (1, 'Row 1');
INSERT INTO x VALUES (2, 'Row 2');
BEGIN a_val := $1;
CREATE TABLE x AS SELECT * FROM x WHERE x = x;
x AS x;
COMMIT;
SELECT * FROM x AS x;
BEGIN FOR row IN SELECT * FROM public.partitioned_table ORDER BY a LOOP         a_val := row.a;
x;
COMMIT;
SELECT * FROM x AS x;
x;
COMMIT;
SET x = 0 /* POINT */ /* avoid bit-exact output here because operations may not be bit-exact. */;
/* point_tbl was already created and filled in test_setup.sql. */ /* Here we just try to insert bad values. */ INSERT INTO x (x) VALUES ('asdfasdf');
INSERT INTO x (x) VALUES ('(10.0 10.0)');
INSERT INTO x (x) VALUES ('(10.0, 10.0) x');
INSERT INTO x (x) VALUES ('(10.0,10.0');
INSERT INTO x (x) VALUES ('(10.0, 1e+500)');
/* Out of range */ SELECT * FROM x;
/* left of */ SELECT x.* FROM x AS x WHERE x.x << '(0.0, 0.0)';
/* right of */ SELECT x.* FROM x AS x WHERE '(0.0,0.0)' >> x.x;
SELECT x.x AS x, x.x AS x, x.x <-> x.x AS x FROM x AS x, x AS x ORDER BY x NULLS LAST, x.x[-1] NULLS LAST, x.x[-1] NULLS LAST;
SELECT x.x AS x, x.x AS x FROM x AS x, x AS x WHERE (x.x <-> x.x) > 3;
/* put distance result into output to allow sorting with GEQ optimizer - tgl 97/05/10 */ SELECT x.x AS x, x.x AS x, (x.x <-> x.x) AS x FROM x AS x, x AS x WHERE (x.x <-> x.x) > 3 AND x.x << x.x ORDER BY x NULLS LAST, x.x[-1] NULLS LAST, x.x[-1] NULLS LAST;
/* Test that GiST indexes provide same behavior as sequential scan */ CREATE TEMPORARY TABLE x (x point);
INSERT INTO x SELECT '(0,0)' FROM x;
CREATE INDEX x ON x USING gist(x NULLS LAST);
INSERT INTO x VALUES ('(0.0000009,0.0000009)');
SET x = TRUE;
SET x = FALSE;
SET x = FALSE;
SELECT COUNT(*) FROM x WHERE CAST('(0.0000009,0.0000009),(0.0000009,0.0000009)' AS box) @> x;
SET x = FALSE;
SET x = TRUE;
SET x = TRUE;
SELECT COUNT(*) FROM x WHERE CAST('(0.0000009,0.0000009),(0.0000009,0.0000009)' AS box) @> x;
RESET enable_seqscan;
RESET enable_indexscan;
RESET enable_bitmapscan;
/* test non-error-throwing API for some core types */ SELECT PG_INPUT_IS_VALID('1,y', 'point');
SELECT * FROM x;
/* POLYGON */ /* polygon logic */ CREATE TABLE x (x polygon);
INSERT INTO x (x) VALUES ('(2.0,0.0),(2.0,4.0),(0.0,0.0)');
INSERT INTO x (x) VALUES ('(3.0,1.0),(3.0,3.0),(1.0,0.0)');
INSERT INTO x (x) VALUES ('(1,2),(3,4),(5,6),(7,8)');
INSERT INTO x (x) VALUES ('(7,8),(5,6),(3,4),(1,2)');
/* Reverse */ INSERT INTO x (x) VALUES ('(1,2),(7,8),(5,6),(3,-4)');
/* degenerate polygons */ INSERT INTO x (x) VALUES ('(0.0,0.0)');
INSERT INTO x (x) VALUES ('(0.0,1.0),(0.0,1.0)');
/* bad polygon input strings */ INSERT INTO x (x) VALUES ('0.0');
INSERT INTO x (x) VALUES ('(0.0 0.0');
INSERT INTO x (x) VALUES ('(0,1,2)');
INSERT INTO x (x) VALUES ('(0,1,2,3');
INSERT INTO x (x) VALUES ('asdf');
SELECT * FROM x;
/* Test the SP-GiST index */ CREATE TABLE x (x INT, x polygon);
INSERT INTO x SELECT (x - 1) * 100 + x, POLYGON(CIRCLE(POINT(x * 10, x * 10), 1 + (x + x) % 10)) FROM x AS x, x AS x;
INSERT INTO x VALUES (11001, NULL), (11002, NULL), (11003, NULL);
CREATE INDEX x ON x USING spgist(x NULLS LAST);
SET x = ON /* get reference results for ORDER BY distance from seq scan */;
SET x = OFF;
SET x = OFF;
SET x = OFF /* check results from index scan */;
SET x = OFF;
SET x = ON;
EXPLAIN (COSTS OFF) SELECT count(*) FROM quad_poly_tbl WHERE p << polygon '((300,300),(400,600),(600,500),(700,200))';
EXPLAIN (COSTS OFF) SELECT count(*) FROM quad_poly_tbl WHERE p &< polygon '((300,300),(400,600),(600,500),(700,200))';
EXPLAIN (COSTS OFF) SELECT count(*) FROM quad_poly_tbl WHERE p && polygon '((300,300),(400,600),(600,500),(700,200))';
EXPLAIN (COSTS OFF) SELECT count(*) FROM quad_poly_tbl WHERE p &> polygon '((300,300),(400,600),(600,500),(700,200))';
EXPLAIN (COSTS OFF) SELECT count(*) FROM quad_poly_tbl WHERE p >> polygon '((300,300),(400,600),(600,500),(700,200))';
EXPLAIN (COSTS OFF) SELECT count(*) FROM quad_poly_tbl WHERE p <<| polygon '((300,300),(400,600),(600,500),(700,200))';
EXPLAIN (COSTS OFF) SELECT count(*) FROM quad_poly_tbl WHERE p &<| polygon '((300,300),(400,600),(600,500),(700,200))';
EXPLAIN (COSTS OFF) SELECT count(*) FROM quad_poly_tbl WHERE p |&> polygon '((300,300),(400,600),(600,500),(700,200))';
EXPLAIN (COSTS OFF) SELECT count(*) FROM quad_poly_tbl WHERE p |>> polygon '((300,300),(400,600),(600,500),(700,200))';
EXPLAIN (COSTS OFF) SELECT count(*) FROM quad_poly_tbl WHERE p <@ polygon '((300,300),(400,600),(600,500),(700,200))';
EXPLAIN (COSTS OFF) SELECT count(*) FROM quad_poly_tbl WHERE p @> polygon '((340,550),(343,552),(341,553))';
EXPLAIN (COSTS OFF) SELECT count(*) FROM quad_poly_tbl WHERE p ~= polygon '((200, 300),(210, 310),(230, 290))';
SET x = ON /* test ORDER BY distance */;
SET x = OFF;
EXPLAIN (COSTS OFF) SELECT rank() OVER (ORDER BY p <-> point '123,456') n, p <-> point '123,456' dist, id FROM quad_poly_tbl WHERE p <@ polygon '((300,300),(400,600),(600,500),(700,200))';
SELECT * FROM x AS x FULL JOIN x AS x ON x.x = x.x AND x.x = x.x AND (x.x = x.x OR x.x IS NULL AND x.x IS NULL) WHERE x.x IS NULL OR x.x IS NULL;
RESET enable_seqscan;
RESET enable_indexscan;
RESET enable_bitmapscan;
/* test non-error-throwing API for some core types */ SELECT PG_INPUT_IS_VALID('(2.0,0.8,0.1)', 'polygon');
SELECT * FROM x;
SELECT PG_INPUT_IS_VALID('(2.0,xyz)', 'polygon');
SELECT * FROM x;
/* Tests for polymorphic SQL functions and aggregates based on them. */ /* Tests for other features related to function-calling have snuck in, too. */ CREATE FUNCTION x(x anyelement) RETURNS anyelement LANGUAGE sql AS $$   select x + 1 $$;
SELECT POLYF(42) AS x, POLYF(4.5) AS x;
SELECT POLYF(POINT(3, 4));
CREATE FUNCTION x(x anyelement) RETURNS anyarray LANGUAGE sql AS $$   select array[x + 1, x + 2] $$;
SELECT POLYF(42) AS x, POLYF(4.5) AS x;
CREATE FUNCTION x(x anyarray) RETURNS anyelement LANGUAGE sql AS $$   select x[1] $$;
SELECT POLYF(ARRAY(2, 4)) AS x, POLYF(ARRAY(4.5, 7.7)) AS x;
SELECT POLYF(x) FROM x;
CREATE FUNCTION x(x anyarray) RETURNS anyarray LANGUAGE sql AS $$   select x $$;
SELECT POLYF(ARRAY(2, 4)) AS x, POLYF(ARRAY(4.5, 7.7)) AS x;
SELECT POLYF(x) FROM x;
/* fail, can't infer type: */ CREATE FUNCTION x(x anyelement) RETURNS anyrange LANGUAGE sql AS $$   select array[x + 1, x + 2] $$;
CREATE FUNCTION x(x anyrange) RETURNS anyarray LANGUAGE sql AS $$   select array[lower(x), upper(x)] $$;
SELECT POLYF(INT4RANGE(42, 49)) AS x, POLYF(FLOAT8RANGE(4.5, 7.8)) AS x;
CREATE FUNCTION x(x anycompatible, x anycompatible) RETURNS anycompatiblearray LANGUAGE sql AS $$   select array[x, y] $$;
SELECT POLYF(2, 4) AS x, POLYF(2, 4.5) AS x;
CREATE FUNCTION x(x anycompatiblerange, x anycompatible, x anycompatible) RETURNS anycompatiblearray LANGUAGE sql AS $$   select array[lower(x), upper(x), y, z] $$;
SELECT POLYF(INT4RANGE(42, 49), 11, CAST(2 AS SMALLINT)) AS x, POLYF(FLOAT8RANGE(4.5, 7.8), 7.8, CAST(11 AS FLOAT)) AS x;
SELECT POLYF(INT4RANGE(42, 49), 11, 4.5) AS x;
CREATE FUNCTION x(x anycompatiblemultirange, x anycompatible, x anycompatible) RETURNS anycompatiblearray LANGUAGE sql AS $$   select array[lower(x), upper(x), y, z] $$;
SELECT POLYF(MULTIRANGE(INT4RANGE(42, 49)), 11, CAST(2 AS SMALLINT)) AS x, POLYF(MULTIRANGE(FLOAT8RANGE(4.5, 7.8)), 7.8, CAST(11 AS FLOAT)) AS x;
SELECT POLYF(MULTIRANGE(INT4RANGE(42, 49)), 11, 4.5) AS x;
/* fail, can't infer type: */ CREATE FUNCTION x(x anycompatible) RETURNS anycompatiblerange LANGUAGE sql AS $$   select array[x + 1, x + 2] $$;
CREATE FUNCTION x(x anycompatiblerange, x anycompatiblearray) RETURNS anycompatiblerange LANGUAGE sql AS $$   select x $$;
SELECT POLYF(INT4RANGE(42, 49), ARRAY(11)) AS x, POLYF(FLOAT8RANGE(4.5, 7.8), ARRAY(7)) AS x;
/* fail, can't infer type: */ CREATE FUNCTION x(x anycompatible) RETURNS anycompatiblemultirange LANGUAGE sql AS $$   select array[x + 1, x + 2] $$;
CREATE FUNCTION x(x anycompatiblemultirange, x anycompatiblearray) RETURNS anycompatiblemultirange LANGUAGE sql AS $$   select x $$;
SELECT POLYF(MULTIRANGE(INT4RANGE(42, 49)), ARRAY(11)) AS x, POLYF(MULTIRANGE(FLOAT8RANGE(4.5, 7.8)), ARRAY(7)) AS x;
SELECT x, PG_TYPEOF(x), x, PG_TYPEOF(x) FROM x;
SELECT x, PG_TYPEOF(x), x, PG_TYPEOF(x) FROM x;
SELECT x, PG_TYPEOF(x), x, PG_TYPEOF(x) FROM x;
SELECT x, PG_TYPEOF(x), x, PG_TYPEOF(x) FROM x;
SELECT POLYF(INT4RANGE(1, 10));
SELECT POLYF(NULL);
DROP FUNCTION x (anyrange);
SELECT POLYF(INT4MULTIRANGE(INT4RANGE(1, 10), INT4RANGE(20, 30)));
SELECT POLYF(NULL);
DROP FUNCTION x (anymultirange);
SELECT POLYF(INT4RANGE(1, 10));
SELECT POLYF(NULL);
DROP FUNCTION x (anycompatiblerange);
SELECT POLYF(INT4MULTIRANGE(INT4RANGE(1, 10), INT4RANGE(20, 30)));
SELECT POLYF(NULL);
DROP FUNCTION x (anymultirange);
SELECT POLYF(INT4MULTIRANGE(INT4RANGE(1, 10), INT4RANGE(20, 30)));
SELECT POLYF(NULL);
DROP FUNCTION x (anycompatiblemultirange);
SELECT POLYF(INT4MULTIRANGE(INT4RANGE(1, 10), INT4RANGE(20, 30)));
SELECT POLYF(NULL);
DROP FUNCTION x (anycompatiblemultirange);
/* Polymorphic aggregate tests */ /* Legend: */ /* --------- */ /* A = type is ANY */ /* P = type is polymorphic */ /* N = type is non-polymorphic */ /* B = aggregate base type */ /* S = aggregate state type */ /* R = aggregate return type */ /* 1 = arg1 of a function */ /* 2 = arg2 of a function */ /* ag = aggregate */ /* tf = trans (state) function */ /* ff = final function */ /* rt = return type of a function */ /* -> = implies */ /* => = allowed */ /* !> = not allowed */ /* E  = exists */ /* NE = not-exists */ /* Possible states: */ /* ---------------- */ /* B = (A || P || N) */ /*   when (B = A) -> (tf2 = NE) */ /* S = (P || N) */ /* ff = (E || NE) */ /* tf1 = (P || N) */ /* tf2 = (NE || P || N) */ /* R = (P || N) */ /* create functions for use as tf and ff with the needed combinations of */ /* argument polymorphism, but within the constraints of valid aggregate */ /* functions, i.e. tf arg1 and tf return type must match */ /* polymorphic single arg transfn */ CREATE FUNCTION x(x) RETURNS anyarray LANGUAGE SQL AS 'select $1';
/* dual polymorphic transfn */ CREATE FUNCTION x(x, x) RETURNS anyarray LANGUAGE SQL AS 'select $1 || $2';
/* arg1 only polymorphic transfn */ CREATE FUNCTION x(x, x) RETURNS anyarray LANGUAGE SQL AS 'select $1';
/* multi-arg polymorphic */ CREATE FUNCTION x(x, x, x) RETURNS anyelement LANGUAGE sql STRICT AS 'select $1+$2+$3';
/* finalfn polymorphic */ CREATE FUNCTION x(x) RETURNS anyarray LANGUAGE SQL AS 'select $1';
/* Try to cover all the possible states: */ /* Note: in Cases 1 & 2, we are trying to return P. Therefore, if the transfn */ /* is stfnp, tfnp, or tf2p, we must use ffp as finalfn, because stfnp, tfnp, */ /* and tf2p do not return P. Conversely, in Cases 3 & 4, we are trying to */ /* return N. Therefore, if the transfn is stfp, tfp, or tf1p, we must use ffnp */ /* as finalfn, because stfp, tfp, and tf1p do not return N. */ /*     Case1 (R = P) && (B = A) */ /*     ------------------------ */ /*     S    tf1 */ /*     ------- */ /*     N    N */ /* should CREATE */ CREATE AGGREGATE myaggp01a(*) (SFUNC = stfnp, STYPE = int4[],   FINALFUNC = ffp, INITCOND = '{}');
/*     P    N */ /* should ERROR: stfnp(anyarray) not matched by stfnp(int[]) */ CREATE AGGREGATE myaggp02a(*) (SFUNC = stfnp, STYPE = anyarray,   FINALFUNC = ffp, INITCOND = '{}');
/*     N    P */ /* should CREATE */ CREATE AGGREGATE myaggp03a(*) (SFUNC = stfp, STYPE = int4[],   FINALFUNC = ffp, INITCOND = '{}');
CREATE AGGREGATE myaggp03b(*) (SFUNC = stfp, STYPE = int4[],   INITCOND = '{}');
/*     P    P */ /* should ERROR: we have no way to resolve S */ CREATE AGGREGATE myaggp04a(*) (SFUNC = stfp, STYPE = anyarray,   FINALFUNC = ffp, INITCOND = '{}');
CREATE AGGREGATE myaggp04b(*) (SFUNC = stfp, STYPE = anyarray,   INITCOND = '{}');
/*    Case2 (R = P) && ((B = P) || (B = N)) */ /*    ------------------------------------- */ /*    S    tf1      B    tf2 */ /*    ----------------------- */ /*    N    N        N    N */ /* should CREATE */ CREATE AGGREGATE myaggp05a(BASETYPE = int, SFUNC = tfnp, STYPE = int[],   FINALFUNC = ffp, INITCOND = '{}');
/*    N    N        N    P */ /* should CREATE */ CREATE AGGREGATE myaggp06a(BASETYPE = int, SFUNC = tf2p, STYPE = int[],   FINALFUNC = ffp, INITCOND = '{}');
/*    N    N        P    N */ /* should ERROR: tfnp(int[], anyelement) not matched by tfnp(int[], int) */ CREATE AGGREGATE myaggp07a(BASETYPE = anyelement, SFUNC = tfnp, STYPE = int[],   FINALFUNC = ffp, INITCOND = '{}');
/*    N    N        P    P */ /* should CREATE */ CREATE AGGREGATE myaggp08a(BASETYPE = anyelement, SFUNC = tf2p, STYPE = int[],   FINALFUNC = ffp, INITCOND = '{}');
/*    N    P        N    N */ /* should CREATE */ CREATE AGGREGATE myaggp09a(BASETYPE = int, SFUNC = tf1p, STYPE = int[],   FINALFUNC = ffp, INITCOND = '{}');
CREATE AGGREGATE myaggp09b(BASETYPE = int, SFUNC = tf1p, STYPE = int[],   INITCOND = '{}');
/*    N    P        N    P */ /* should CREATE */ CREATE AGGREGATE myaggp10a(BASETYPE = int, SFUNC = tfp, STYPE = int[],   FINALFUNC = ffp, INITCOND = '{}');
CREATE AGGREGATE myaggp10b(BASETYPE = int, SFUNC = tfp, STYPE = int[],   INITCOND = '{}');
/*    N    P        P    N */ /* should ERROR: tf1p(int[],anyelement) not matched by tf1p(anyarray,int) */ CREATE AGGREGATE myaggp11a(BASETYPE = anyelement, SFUNC = tf1p, STYPE = int[],   FINALFUNC = ffp, INITCOND = '{}');
CREATE AGGREGATE myaggp11b(BASETYPE = anyelement, SFUNC = tf1p, STYPE = int[],   INITCOND = '{}');
/*    N    P        P    P */ /* should ERROR: tfp(int[],anyelement) not matched by tfp(anyarray,anyelement) */ CREATE AGGREGATE myaggp12a(BASETYPE = anyelement, SFUNC = tfp, STYPE = int[],   FINALFUNC = ffp, INITCOND = '{}');
CREATE AGGREGATE myaggp12b(BASETYPE = anyelement, SFUNC = tfp, STYPE = int[],   INITCOND = '{}');
/*    P    N        N    N */ /* should ERROR: tfnp(anyarray, int) not matched by tfnp(int[],int) */ CREATE AGGREGATE myaggp13a(BASETYPE = int, SFUNC = tfnp, STYPE = anyarray,   FINALFUNC = ffp, INITCOND = '{}');
/*    P    N        N    P */ /* should ERROR: tf2p(anyarray, int) not matched by tf2p(int[],anyelement) */ CREATE AGGREGATE myaggp14a(BASETYPE = int, SFUNC = tf2p, STYPE = anyarray,   FINALFUNC = ffp, INITCOND = '{}');
/*    P    N        P    N */ /* should ERROR: tfnp(anyarray, anyelement) not matched by tfnp(int[],int) */ CREATE AGGREGATE myaggp15a(BASETYPE = anyelement, SFUNC = tfnp,   STYPE = anyarray, FINALFUNC = ffp, INITCOND = '{}');
/*    P    N        P    P */ /* should ERROR: tf2p(anyarray, anyelement) not matched by tf2p(int[],anyelement) */ CREATE AGGREGATE myaggp16a(BASETYPE = anyelement, SFUNC = tf2p,   STYPE = anyarray, FINALFUNC = ffp, INITCOND = '{}');
/*    P    P        N    N */ /* should ERROR: we have no way to resolve S */ CREATE AGGREGATE myaggp17a(BASETYPE = int, SFUNC = tf1p, STYPE = anyarray,   FINALFUNC = ffp, INITCOND = '{}');
CREATE AGGREGATE myaggp17b(BASETYPE = int, SFUNC = tf1p, STYPE = anyarray,   INITCOND = '{}');
/*    P    P        N    P */ /* should ERROR: tfp(anyarray, int) not matched by tfp(anyarray, anyelement) */ CREATE AGGREGATE myaggp18a(BASETYPE = int, SFUNC = tfp, STYPE = anyarray,   FINALFUNC = ffp, INITCOND = '{}');
CREATE AGGREGATE myaggp18b(BASETYPE = int, SFUNC = tfp, STYPE = anyarray,   INITCOND = '{}');
/*    P    P        P    N */ /* should ERROR: tf1p(anyarray, anyelement) not matched by tf1p(anyarray, int) */ CREATE AGGREGATE myaggp19a(BASETYPE = anyelement, SFUNC = tf1p,   STYPE = anyarray, FINALFUNC = ffp, INITCOND = '{}');
CREATE AGGREGATE myaggp19b(BASETYPE = anyelement, SFUNC = tf1p,   STYPE = anyarray, INITCOND = '{}');
/*    P    P        P    P */ /* should CREATE */ CREATE AGGREGATE myaggp20a(BASETYPE = anyelement, SFUNC = tfp,   STYPE = anyarray, FINALFUNC = ffp, INITCOND = '{}');
CREATE AGGREGATE myaggp20b(BASETYPE = anyelement, SFUNC = tfp,   STYPE = anyarray, INITCOND = '{}');
/*     Case3 (R = N) && (B = A) */ /*     ------------------------ */ /*     S    tf1 */ /*     ------- */ /*     N    N */ /* should CREATE */ CREATE AGGREGATE myaggn01a(*) (SFUNC = stfnp, STYPE = int4[],   FINALFUNC = ffnp, INITCOND = '{}');
CREATE AGGREGATE myaggn01b(*) (SFUNC = stfnp, STYPE = int4[],   INITCOND = '{}');
/*     P    N */ /* should ERROR: stfnp(anyarray) not matched by stfnp(int[]) */ CREATE AGGREGATE myaggn02a(*) (SFUNC = stfnp, STYPE = anyarray,   FINALFUNC = ffnp, INITCOND = '{}');
CREATE AGGREGATE myaggn02b(*) (SFUNC = stfnp, STYPE = anyarray,   INITCOND = '{}');
/*     N    P */ /* should CREATE */ CREATE AGGREGATE myaggn03a(*) (SFUNC = stfp, STYPE = int4[],   FINALFUNC = ffnp, INITCOND = '{}');
/*     P    P */ /* should ERROR: ffnp(anyarray) not matched by ffnp(int[]) */ CREATE AGGREGATE myaggn04a(*) (SFUNC = stfp, STYPE = anyarray,   FINALFUNC = ffnp, INITCOND = '{}');
/*    Case4 (R = N) && ((B = P) || (B = N)) */ /*    ------------------------------------- */ /*    S    tf1      B    tf2 */ /*    ----------------------- */ /*    N    N        N    N */ /* should CREATE */ CREATE AGGREGATE myaggn05a(BASETYPE = int, SFUNC = tfnp, STYPE = int[],   FINALFUNC = ffnp, INITCOND = '{}');
CREATE AGGREGATE myaggn05b(BASETYPE = int, SFUNC = tfnp, STYPE = int[],   INITCOND = '{}');
/*    N    N        N    P */ /* should CREATE */ CREATE AGGREGATE myaggn06a(BASETYPE = int, SFUNC = tf2p, STYPE = int[],   FINALFUNC = ffnp, INITCOND = '{}');
CREATE AGGREGATE myaggn06b(BASETYPE = int, SFUNC = tf2p, STYPE = int[],   INITCOND = '{}');
/*    N    N        P    N */ /* should ERROR: tfnp(int[], anyelement) not matched by tfnp(int[], int) */ CREATE AGGREGATE myaggn07a(BASETYPE = anyelement, SFUNC = tfnp, STYPE = int[],   FINALFUNC = ffnp, INITCOND = '{}');
CREATE AGGREGATE myaggn07b(BASETYPE = anyelement, SFUNC = tfnp, STYPE = int[],   INITCOND = '{}');
/*    N    N        P    P */ /* should CREATE */ CREATE AGGREGATE myaggn08a(BASETYPE = anyelement, SFUNC = tf2p, STYPE = int[],   FINALFUNC = ffnp, INITCOND = '{}');
CREATE AGGREGATE myaggn08b(BASETYPE = anyelement, SFUNC = tf2p, STYPE = int[],   INITCOND = '{}');
/*    N    P        N    N */ /* should CREATE */ CREATE AGGREGATE myaggn09a(BASETYPE = int, SFUNC = tf1p, STYPE = int[],   FINALFUNC = ffnp, INITCOND = '{}');
/*    N    P        N    P */ /* should CREATE */ CREATE AGGREGATE myaggn10a(BASETYPE = int, SFUNC = tfp, STYPE = int[],   FINALFUNC = ffnp, INITCOND = '{}');
/*    N    P        P    N */ /* should ERROR: tf1p(int[],anyelement) not matched by tf1p(anyarray,int) */ CREATE AGGREGATE myaggn11a(BASETYPE = anyelement, SFUNC = tf1p, STYPE = int[],   FINALFUNC = ffnp, INITCOND = '{}');
/*    N    P        P    P */ /* should ERROR: tfp(int[],anyelement) not matched by tfp(anyarray,anyelement) */ CREATE AGGREGATE myaggn12a(BASETYPE = anyelement, SFUNC = tfp, STYPE = int[],   FINALFUNC = ffnp, INITCOND = '{}');
/*    P    N        N    N */ /* should ERROR: tfnp(anyarray, int) not matched by tfnp(int[],int) */ CREATE AGGREGATE myaggn13a(BASETYPE = int, SFUNC = tfnp, STYPE = anyarray,   FINALFUNC = ffnp, INITCOND = '{}');
CREATE AGGREGATE myaggn13b(BASETYPE = int, SFUNC = tfnp, STYPE = anyarray,   INITCOND = '{}');
/*    P    N        N    P */ /* should ERROR: tf2p(anyarray, int) not matched by tf2p(int[],anyelement) */ CREATE AGGREGATE myaggn14a(BASETYPE = int, SFUNC = tf2p, STYPE = anyarray,   FINALFUNC = ffnp, INITCOND = '{}');
CREATE AGGREGATE myaggn14b(BASETYPE = int, SFUNC = tf2p, STYPE = anyarray,   INITCOND = '{}');
/*    P    N        P    N */ /* should ERROR: tfnp(anyarray, anyelement) not matched by tfnp(int[],int) */ CREATE AGGREGATE myaggn15a(BASETYPE = anyelement, SFUNC = tfnp,   STYPE = anyarray, FINALFUNC = ffnp, INITCOND = '{}');
CREATE AGGREGATE myaggn15b(BASETYPE = anyelement, SFUNC = tfnp,   STYPE = anyarray, INITCOND = '{}');
/*    P    N        P    P */ /* should ERROR: tf2p(anyarray, anyelement) not matched by tf2p(int[],anyelement) */ CREATE AGGREGATE myaggn16a(BASETYPE = anyelement, SFUNC = tf2p,   STYPE = anyarray, FINALFUNC = ffnp, INITCOND = '{}');
CREATE AGGREGATE myaggn16b(BASETYPE = anyelement, SFUNC = tf2p,   STYPE = anyarray, INITCOND = '{}');
/*    P    P        N    N */ /* should ERROR: ffnp(anyarray) not matched by ffnp(int[]) */ CREATE AGGREGATE myaggn17a(BASETYPE = int, SFUNC = tf1p, STYPE = anyarray,   FINALFUNC = ffnp, INITCOND = '{}');
/*    P    P        N    P */ /* should ERROR: tfp(anyarray, int) not matched by tfp(anyarray, anyelement) */ CREATE AGGREGATE myaggn18a(BASETYPE = int, SFUNC = tfp, STYPE = anyarray,   FINALFUNC = ffnp, INITCOND = '{}');
/*    P    P        P    N */ /* should ERROR: tf1p(anyarray, anyelement) not matched by tf1p(anyarray, int) */ CREATE AGGREGATE myaggn19a(BASETYPE = anyelement, SFUNC = tf1p,   STYPE = anyarray, FINALFUNC = ffnp, INITCOND = '{}');
/*    P    P        P    P */ /* should ERROR: ffnp(anyarray) not matched by ffnp(int[]) */ CREATE AGGREGATE myaggn20a(BASETYPE = anyelement, SFUNC = tfp,   STYPE = anyarray, FINALFUNC = ffnp, INITCOND = '{}');
/* multi-arg polymorphic */ CREATE AGGREGATE mysum2(anyelement,anyelement) (SFUNC = sum3,   STYPE = anyelement, INITCOND = '0');
/* create test data for polymorphic aggregates */ CREATE TEMPORARY TABLE x (x INT, x ARRAY<INT>, x TEXT);
INSERT INTO x VALUES (1, ARRAY(1), 'a');
INSERT INTO x VALUES (1, ARRAY(11), 'b');
INSERT INTO x VALUES (1, ARRAY(111), 'c');
INSERT INTO x VALUES (2, ARRAY(2), 'a');
INSERT INTO x VALUES (2, ARRAY(22), 'b');
INSERT INTO x VALUES (2, ARRAY(222), 'c');
INSERT INTO x VALUES (3, ARRAY(3), 'a');
INSERT INTO x VALUES (3, ARRAY(3), 'b');
/* test the successfully created polymorphic aggregates */ SELECT x, MYAGGP01A(*) FROM x GROUP BY x ORDER BY x NULLS LAST;
SELECT x, MYAGGP03A(*) FROM x GROUP BY x ORDER BY x NULLS LAST;
SELECT x, MYAGGP03B(*) FROM x GROUP BY x ORDER BY x NULLS LAST;
SELECT x, MYAGGP05A(x) FROM x GROUP BY x ORDER BY x NULLS LAST;
SELECT x, MYAGGP06A(x) FROM x GROUP BY x ORDER BY x NULLS LAST;
SELECT x, MYAGGP08A(x) FROM x GROUP BY x ORDER BY x NULLS LAST;
SELECT x, MYAGGP09A(x) FROM x GROUP BY x ORDER BY x NULLS LAST;
SELECT x, MYAGGP09B(x) FROM x GROUP BY x ORDER BY x NULLS LAST;
SELECT x, MYAGGP10A(x) FROM x GROUP BY x ORDER BY x NULLS LAST;
SELECT x, MYAGGP10B(x) FROM x GROUP BY x ORDER BY x NULLS LAST;
SELECT x, MYAGGP20A(x) FROM x GROUP BY x ORDER BY x NULLS LAST;
SELECT x, MYAGGP20B(x) FROM x GROUP BY x ORDER BY x NULLS LAST;
SELECT x, MYAGGN01A(*) FROM x GROUP BY x ORDER BY x NULLS LAST;
SELECT x, MYAGGN01B(*) FROM x GROUP BY x ORDER BY x NULLS LAST;
SELECT x, MYAGGN03A(*) FROM x GROUP BY x ORDER BY x NULLS LAST;
SELECT x, MYAGGN05A(x) FROM x GROUP BY x ORDER BY x NULLS LAST;
SELECT x, MYAGGN05B(x) FROM x GROUP BY x ORDER BY x NULLS LAST;
SELECT x, MYAGGN06A(x) FROM x GROUP BY x ORDER BY x NULLS LAST;
SELECT x, MYAGGN06B(x) FROM x GROUP BY x ORDER BY x NULLS LAST;
SELECT x, MYAGGN08A(x) FROM x GROUP BY x ORDER BY x NULLS LAST;
SELECT x, MYAGGN08B(x) FROM x GROUP BY x ORDER BY x NULLS LAST;
SELECT x, MYAGGN09A(x) FROM x GROUP BY x ORDER BY x NULLS LAST;
SELECT x, MYAGGN10A(x) FROM x GROUP BY x ORDER BY x NULLS LAST;
SELECT MYSUM2(x, x + 1) FROM x;
x AS @1;
CREATE FUNCTION x(x, x, x) RETURNS anyelement LANGUAGE sql AS $$ select case when $1 then $2 else $3 end $$;
/* Note this would fail with integer overflow, never mind wrong bleat() output, */ /* if the CASE expression were not successfully inlined */ SELECT x, SQL_IF(x > 0, BLEAT(x), BLEAT(x + 1)) FROM x;
SELECT x, SQL_IF(x > 0, x, x + 1) FROM x;
/* another sort of polymorphic aggregate */ CREATE AGGREGATE array_larger_accum (anyarray) (     sfunc = array_larger,     stype = anyarray,     initcond = '{}' );
SELECT ARRAY_LARGER_ACCUM(x) FROM (VALUES (ARRAY(1, 2)), (ARRAY(3, 4))) AS x;
SELECT ARRAY_LARGER_ACCUM(x) FROM (VALUES (ARRAY(ROW(1, 2), ROW(3, 4))), (ARRAY(ROW(5, 6), ROW(7, 8)))) AS x;
if array_upper(grp, 1) < size then     return grp || ad;
x AS x;
COMMIT;
create aggregate build_group(anyelement, integer) (   SFUNC = add_group,   STYPE = anyarray );
SELECT BUILD_GROUP(x, 3) FROM x;
/* this should fail because stype isn't compatible with arg */ create aggregate build_group(int8, integer) (   SFUNC = add_group,   STYPE = int2[] );
/* but we can make a non-poly agg from a poly sfunc if types are OK */ create aggregate build_group(int8, integer) (   SFUNC = add_group,   STYPE = int8[] );
/* check proper resolution of data types for polymorphic transfn/finalfn */ CREATE FUNCTION x(x, x) RETURNS anyarray LANGUAGE sql IMMUTABLE AS 'select $1 || $2';
CREATE FUNCTION x(x) RETURNS anyelement LANGUAGE sql STRICT IMMUTABLE AS 'select $1[1]';
create aggregate first_el_agg_f8(float8) (   SFUNC = array_append,   STYPE = float8[],   FINALFUNC = first_el );
create aggregate first_el_agg_any(anyelement) (   SFUNC = first_el_transfn,   STYPE = anyarray,   FINALFUNC = first_el );
SELECT FIRST_EL_AGG_F8(CAST(x AS DOUBLE)) FROM x AS x;
SELECT FIRST_EL_AGG_ANY(x) FROM x AS x;
SELECT FIRST_EL_AGG_F8(CAST(x AS DOUBLE)) OVER (ORDER BY x NULLS LAST) FROM x AS x;
SELECT FIRST_EL_AGG_ANY(x) OVER (ORDER BY x NULLS LAST) FROM x AS x;
/* check that we can apply functions taking ANYARRAY to pg_stats */ SELECT DISTINCT ARRAY_NDIMS(x) FROM x WHERE NOT x IS NULL;
/* such functions must protect themselves if varying element type isn't OK */ /* (WHERE clause here is to avoid possibly getting a collation error instead) */ SELECT MAX(x) FROM x WHERE x = 'pg_am';
/* another corner case is the input functions for polymorphic pseudotypes */ SELECT ARRAY_IN('{1,2,3}', CAST('int4' AS REGTYPE), -1);
/* this has historically worked */ SELECT * FROM x;
/* this not */ SELECT ANYRANGE_IN('[10,20)', CAST('int4range' AS REGTYPE), -1);
/* test variadic polymorphic functions */ CREATE FUNCTION x(x anyarray) RETURNS anyelement LANGUAGE sql IMMUTABLE STRICT AS $$   select min($1[i]) from generate_subscripts($1,1) g(i) $$;
SELECT MYLEAST(10, 1, 20, 33);
SELECT MYLEAST(1.1, 0.22, 0.55);
SELECT MYLEAST(CAST('z' AS TEXT));
SELECT MYLEAST();
SELECT CONCAT(COALESCE('%', ''), COALESCE(1, ''), COALESCE(2, ''), COALESCE(3, ''), COALESCE(4, ''), COALESCE(5, ''));
SELECT CONCAT(COALESCE('|', ''), COALESCE(CAST('a' AS TEXT), ''), COALESCE('b', ''), COALESCE('c', ''));
DROP FUNCTION x (TEXT, anyarray);
SELECT FORMARRAY(1, 2, 3, 4, 5);
SELECT FORMARRAY(1.1, ARRAY(1.2, 55.5));
/* fail without variadic */ SELECT FORMARRAY(1, CAST('x' AS TEXT));
/* test pg_typeof() function */ SELECT PG_TYPEOF(NULL);
/* unknown */ SELECT PG_TYPEOF(0);
/* integer */ SELECT PG_TYPEOF(0.0);
/* numeric */ SELECT PG_TYPEOF(1 + 1 = 2);
/* boolean */ SELECT PG_TYPEOF('x');
/* unknown */ SELECT PG_TYPEOF('' || '');
/* text */ SELECT PG_TYPEOF(PG_TYPEOF(0));
/* regtype */ SELECT PG_TYPEOF(ARRAY(1.2, 55.5));
/* numeric[] */ SELECT PG_TYPEOF(MYLEAST(10, 1, 20, 33));
SELECT DFUNC();
SELECT DFUNC(10);
SELECT DFUNC(10, 20);
SELECT DFUNC(10, 20, 30);
/* fail */ DROP FUNCTION x;
/* fail */ DROP FUNCTION x (INT);
/* fail */ DROP FUNCTION x (INT, INT);
SELECT DFUNC();
SELECT DFUNC();
SELECT DFUNC();
/* fail: which dfunc should be called? int or text */ SELECT DFUNC('Hi');
/* ok */ SELECT DFUNC('Hi', 'City');
/* ok */ SELECT DFUNC(0);
/* ok */ SELECT DFUNC(10, 20);
/* ok */ DROP FUNCTION x (INT, INT);
DROP FUNCTION x (TEXT, TEXT);
/* Now, dfunc(nargs = 2) and dfunc(nargs = 4) are ambiguous when called */ /* with 0 to 2 arguments. */ SELECT DFUNC();
/* fail */ SELECT DFUNC(1);
/* fail */ SELECT DFUNC(1, 2);
/* fail */ SELECT DFUNC(1, 2, 3);
/* ok */ SELECT DFUNC(1, 2, 3, 4);
/* ok */ DROP FUNCTION x (INT, INT);
DROP FUNCTION x (INT, INT, INT, INT);
SELECT DFUNC();
SELECT DFUNC(0);
SELECT DFUNC(STR_TO_DATE('20081215', '%Y%m%d'));
SELECT DFUNC(CAST('City' AS TEXT));
DROP FUNCTION x (anyelement);
SELECT DFUNC();
/* fail */ SELECT DFUNC(10);
SELECT DFUNC(10, 20);
SELECT DFUNC();
/* now ok */ SELECT DFUNC(10);
SELECT DFUNC(10, 20);
/* dfunc(narg=2) and dfunc(narg=3) are ambiguous */ SELECT DFUNC(1);
/* fail */ /* but this works since the ambiguous functions aren't preferred anyway */ SELECT DFUNC('Hi');
DROP FUNCTION x (INT, INT, INT);
DROP FUNCTION x (INT, INT);
DROP FUNCTION x (TEXT);
SELECT (DFUNC(10, 20, 30)).*;
SELECT (DFUNC(x := 10, x := 20, x := 30)).*;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
/* fail */ SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
/* fail, duplicate name */ SELECT * FROM x;
/* fail, named args must be last */ SELECT * FROM x;
/* fail, unknown param */ SELECT * FROM x;
/* fail, a overlaps positional parameter */ SELECT * FROM x;
/* fail, no value for b */ DROP FUNCTION x (INT, INT, INT, INT);
SELECT (DFUNC('Hello World', 20, CAST('2009-07-25' AS DATE))).*;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
/* fail */ DROP FUNCTION x (VARCHAR, DECIMAL, DATE);
SELECT (DFUNC()).*;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
DROP FUNCTION x (VARCHAR, DECIMAL);
SELECT TESTPOLYM(37);
DROP FUNCTION x (INT);
SELECT * FROM x;
DROP FUNCTION x (INT);
SELECT DFUNC(1, 2);
SELECT DFUNC(CAST('a' AS TEXT), 'b');
/* positional notation with default */ SELECT DFUNC(x := 1, x := 2);
SELECT DFUNC(x := CAST('a' AS TEXT), x := 'b');
SELECT DFUNC(x := CAST('a' AS TEXT), x := 'b', x := FALSE);
/* named notation */ SELECT DFUNC(x := CAST('b' AS TEXT), x := 'a');
/* named notation with default */ SELECT DFUNC(x := CAST('a' AS TEXT), x := TRUE);
/* named notation with default */ SELECT DFUNC(x := CAST('a' AS TEXT), x := FALSE);
/* named notation with default */ SELECT DFUNC(x := CAST('b' AS TEXT), x := 'a', x := TRUE);
/* named notation */ SELECT DFUNC(CAST('a' AS TEXT), 'b', FALSE);
/* full positional notation */ SELECT DFUNC(CAST('a' AS TEXT), 'b', x := FALSE);
/* mixed notation */ SELECT DFUNC(CAST('a' AS TEXT), 'b', TRUE);
/* full positional notation */ SELECT DFUNC(CAST('a' AS TEXT), 'b', x := TRUE);
/* mixed notation */ /* ansi/sql syntax */ SELECT DFUNC(a => 1, b => 2);
SELECT DFUNC(a => CAST('a' AS TEXT), b => 'b');
SELECT DFUNC(a => CAST('a' AS TEXT), b => 'b', flag => FALSE);
/* named notation */ SELECT DFUNC(b => CAST('b' AS TEXT), a => 'a');
/* named notation with default */ SELECT DFUNC(a => CAST('a' AS TEXT), flag => TRUE);
/* named notation with default */ SELECT DFUNC(a => CAST('a' AS TEXT), flag => FALSE);
/* named notation with default */ SELECT DFUNC(b => CAST('b' AS TEXT), a => 'a', flag => TRUE);
/* named notation */ SELECT DFUNC(CAST('a' AS TEXT), 'b', FALSE);
/* full positional notation */ SELECT DFUNC(CAST('a' AS TEXT), 'b', flag => FALSE);
/* mixed notation */ SELECT DFUNC(CAST('a' AS TEXT), 'b', TRUE);
/* full positional notation */ SELECT DFUNC(CAST('a' AS TEXT), 'b', flag => TRUE);
/* mixed notation */ /* this tests lexer edge cases around => */ SELECT DFUNC(a => -1);
SELECT DFUNC(a => 1);
SELECT DFUNC(a => 1);
SELECT DFUNC(a => 1);
BEGIN select dfunc(a=>-- comment       1) into r;
COMMIT;
/* check reverse-listing of named-arg calls */ CREATE VIEW x AS SELECT x, x, DFUNC(x, x, x := x > x) AS x, DFUNC(x, x := x < x, x := x) AS x FROM x;
SELECT * FROM x;
DROP FUNCTION x (anyelement, anyelement, BOOLEAN);
/* Tests for ANYCOMPATIBLE polymorphism family */ CREATE FUNCTION x(x, x) RETURNS anycompatible LANGUAGE sql AS $$   select greatest($1, $2) $$;
SELECT x, PG_TYPEOF(x) FROM x AS x;
SELECT x, PG_TYPEOF(x) FROM x AS x;
SELECT x, PG_TYPEOF(x) FROM x AS x;
/* fail */ SELECT x, PG_TYPEOF(x) FROM x AS x;
/* defaults to text */ DROP FUNCTION x (anycompatible, anycompatible);
CREATE FUNCTION x(x, x) RETURNS anycompatiblearray LANGUAGE sql AS $$   select array[$1, $2] $$;
SELECT x, PG_TYPEOF(x) FROM x AS x;
SELECT x, PG_TYPEOF(x) FROM x AS x;
SELECT x, PG_TYPEOF(x) FROM x AS x;
/* fail */ DROP FUNCTION x (anycompatible, anycompatible);
CREATE FUNCTION x(x, x) RETURNS anycompatiblearray LANGUAGE sql AS $$   select array[$1] || $2 $$;
SELECT x, PG_TYPEOF(x) FROM x AS x;
SELECT x, PG_TYPEOF(x) FROM x AS x;
SELECT x, PG_TYPEOF(x) FROM x AS x;
SELECT x, PG_TYPEOF(x) FROM x AS x;
SELECT x, PG_TYPEOF(x) FROM x AS x;
/* fail */ SELECT x, PG_TYPEOF(x) FROM x AS x;
/* fail */ DROP FUNCTION x (anycompatible, anycompatiblearray);
CREATE FUNCTION x(x, x) RETURNS anycompatiblerange LANGUAGE sql AS $$   select $2 $$;
SELECT x, PG_TYPEOF(x) FROM x AS x;
SELECT x, PG_TYPEOF(x) FROM x AS x;
SELECT x, PG_TYPEOF(x) FROM x AS x;
/* fail */ SELECT x, PG_TYPEOF(x) FROM x AS x;
/* fail */ SELECT x, PG_TYPEOF(x) FROM x AS x;
/* fail */ DROP FUNCTION x (anycompatible, anycompatiblerange);
CREATE FUNCTION x(x, x) RETURNS anycompatible LANGUAGE sql AS $$   select lower($1) + upper($2) $$;
SELECT x, PG_TYPEOF(x) FROM x AS x;
SELECT x, PG_TYPEOF(x) FROM x AS x;
/* fail */ DROP FUNCTION x (anycompatiblerange, anycompatiblerange);
/* fail, can't infer result type: */ CREATE FUNCTION x(x) RETURNS anycompatiblerange LANGUAGE sql AS $$   select $1 $$;
CREATE FUNCTION x(x, x) RETURNS anycompatiblemultirange LANGUAGE sql AS $$   select $2 $$;
SELECT x, PG_TYPEOF(x) FROM x AS x;
SELECT x, PG_TYPEOF(x) FROM x AS x;
SELECT x, PG_TYPEOF(x) FROM x AS x;
/* fail */ SELECT x, PG_TYPEOF(x) FROM x AS x;
/* fail */ SELECT x, PG_TYPEOF(x) FROM x AS x;
/* fail */ DROP FUNCTION x (anycompatible, anycompatiblemultirange);
CREATE FUNCTION x(x, x) RETURNS anycompatible LANGUAGE sql AS $$   select lower($1) + upper($2) $$;
SELECT x, PG_TYPEOF(x) FROM x AS x;
SELECT x, PG_TYPEOF(x) FROM x AS x;
/* fail */ DROP FUNCTION x (anycompatiblemultirange, anycompatiblemultirange);
/* fail, can't infer result type: */ CREATE FUNCTION x(x) RETURNS anycompatiblemultirange LANGUAGE sql AS $$   select $1 $$;
CREATE FUNCTION x(x, x) RETURNS anycompatiblearray LANGUAGE sql AS $$   select array[$1, $2] $$;
SELECT x, PG_TYPEOF(x) FROM x AS x;
SELECT x, PG_TYPEOF(x) FROM x AS x;
SELECT x, PG_TYPEOF(x) FROM x AS x;
/* fail */ DROP FUNCTION x (anycompatiblenonarray, anycompatiblenonarray);
CREATE FUNCTION x(x anyelement, x anyarray, x anycompatible, x anycompatible) RETURNS anycompatiblearray LANGUAGE sql AS $$   select array[c, d] $$;
SELECT x, PG_TYPEOF(x) FROM x AS x;
SELECT x, PG_TYPEOF(x) FROM x AS x;
SELECT x, PG_TYPEOF(x) FROM x AS x;
SELECT x, PG_TYPEOF(x) FROM x AS x;
CREATE FUNCTION x(x anycompatiblearray) RETURNS anycompatiblearray LANGUAGE sql AS $$   select $1 $$;
SELECT x, PG_TYPEOF(x) FROM x AS x;
SELECT x, PG_TYPEOF(x) FROM x AS x;
SELECT x, PG_TYPEOF(x) FROM x AS x;
SELECT x, PG_TYPEOF(x) FROM x AS x;
/* Cursor regression tests */ BEGIN;
DECLARE foo1 SCROLL CURSOR FOR SELECT * FROM tenk1 ORDER BY unique2;
DECLARE foo2 SCROLL CURSOR FOR SELECT * FROM tenk2;
DECLARE foo3 SCROLL CURSOR FOR SELECT * FROM tenk1 ORDER BY unique2;
DECLARE foo4 SCROLL CURSOR FOR SELECT * FROM tenk2;
DECLARE foo5 SCROLL CURSOR FOR SELECT * FROM tenk1 ORDER BY unique2;
DECLARE foo6 SCROLL CURSOR FOR SELECT * FROM tenk2;
DECLARE foo7 SCROLL CURSOR FOR SELECT * FROM tenk1 ORDER BY unique2;
DECLARE foo8 SCROLL CURSOR FOR SELECT * FROM tenk2;
DECLARE foo9 SCROLL CURSOR FOR SELECT * FROM tenk1 ORDER BY unique2;
DECLARE foo10 SCROLL CURSOR FOR SELECT * FROM tenk2;
DECLARE foo11 SCROLL CURSOR FOR SELECT * FROM tenk1 ORDER BY unique2;
DECLARE foo12 SCROLL CURSOR FOR SELECT * FROM tenk2;
DECLARE foo13 SCROLL CURSOR FOR SELECT * FROM tenk1 ORDER BY unique2;
DECLARE foo14 SCROLL CURSOR FOR SELECT * FROM tenk2;
DECLARE foo15 SCROLL CURSOR FOR SELECT * FROM tenk1 ORDER BY unique2;
DECLARE foo16 SCROLL CURSOR FOR SELECT * FROM tenk2;
DECLARE foo17 SCROLL CURSOR FOR SELECT * FROM tenk1 ORDER BY unique2;
DECLARE foo18 SCROLL CURSOR FOR SELECT * FROM tenk2;
DECLARE foo19 SCROLL CURSOR FOR SELECT * FROM tenk1 ORDER BY unique2;
DECLARE foo20 SCROLL CURSOR FOR SELECT * FROM tenk2;
DECLARE foo21 SCROLL CURSOR FOR SELECT * FROM tenk1 ORDER BY unique2;
DECLARE foo22 SCROLL CURSOR FOR SELECT * FROM tenk2;
DECLARE foo23 SCROLL CURSOR FOR SELECT * FROM tenk1 ORDER BY unique2;
FETCH 1 in foo1;
FETCH 2 in foo2;
FETCH 3 in foo3;
FETCH 4 in foo4;
FETCH 5 in foo5;
FETCH 6 in foo6;
FETCH 7 in foo7;
FETCH 8 in foo8;
FETCH 9 in foo9;
FETCH 10 in foo10;
FETCH 11 in foo11;
FETCH 12 in foo12;
FETCH 13 in foo13;
FETCH 14 in foo14;
FETCH 15 in foo15;
FETCH 16 in foo16;
FETCH 17 in foo17;
FETCH 18 in foo18;
FETCH 19 in foo19;
FETCH 20 in foo20;
FETCH 21 in foo21;
FETCH 22 in foo22;
FETCH 23 in foo23;
FETCH backward 1 in foo23;
FETCH backward 2 in foo22;
FETCH backward 3 in foo21;
FETCH backward 4 in foo20;
FETCH backward 5 in foo19;
FETCH backward 6 in foo18;
FETCH backward 7 in foo17;
FETCH backward 8 in foo16;
FETCH backward 9 in foo15;
FETCH backward 10 in foo14;
FETCH backward 11 in foo13;
FETCH backward 12 in foo12;
FETCH backward 13 in foo11;
FETCH backward 14 in foo10;
FETCH backward 15 in foo9;
FETCH backward 16 in foo8;
FETCH backward 17 in foo7;
FETCH backward 18 in foo6;
FETCH backward 19 in foo5;
FETCH backward 20 in foo4;
FETCH backward 21 in foo3;
FETCH backward 22 in foo2;
FETCH backward 23 in foo1;
x AS x;
x AS x;
x AS x;
x AS x;
x AS x;
x AS x;
x AS x;
x AS x;
x AS x;
x AS x;
x AS x;
x AS x;
/* leave some cursors open, to test that auto-close works. */ /* record this in the system view as well (don't query the time field there */ /* however) */ SELECT x, x, x, x, x FROM x ORDER BY 1 NULLS LAST;
COMMIT;
SELECT x, x, x, x, x FROM x;
/* NO SCROLL disallows backward fetching */ BEGIN;
DECLARE foo24 NO SCROLL CURSOR FOR SELECT * FROM tenk1 ORDER BY unique2;
FETCH 1 FROM foo24;
FETCH BACKWARD 1 FROM foo24;
COMMIT /* should fail */ /* should fail */;
BEGIN;
DECLARE foo24 NO SCROLL CURSOR FOR SELECT * FROM tenk1 ORDER BY unique2;
FETCH 1 FROM foo24;
FETCH ABSOLUTE 2 FROM foo24;
/* allowed */ FETCH ABSOLUTE 1 FROM foo24;
COMMIT /* should fail */ /* should fail */;
/* Cursors outside transaction blocks */ SELECT x, x, x, x, x FROM x;
BEGIN;
DECLARE foo25 SCROLL CURSOR WITH HOLD FOR SELECT * FROM tenk2;
FETCH FROM foo25;
FETCH FROM foo25;
COMMIT;
FETCH FROM foo25;
FETCH BACKWARD FROM foo25;
FETCH ABSOLUTE -1 FROM foo25;
SELECT x, x, x, x, x FROM x;
x AS x;
BEGIN;
DECLARE foo25ns NO SCROLL CURSOR WITH HOLD FOR SELECT * FROM tenk2;
FETCH FROM foo25ns;
FETCH FROM foo25ns;
COMMIT;
FETCH FROM foo25ns;
FETCH ABSOLUTE 4 FROM foo25ns;
FETCH ABSOLUTE 4 FROM foo25ns;
/* fail */ SELECT x, x, x, x, x FROM x;
x AS x;
/* ROLLBACK should close holdable cursors */ BEGIN;
DECLARE foo26 CURSOR WITH HOLD FOR SELECT * FROM tenk1 ORDER BY unique2;
ROLLBACK;
/* should fail */ FETCH FROM foo26;
/* Parameterized DECLARE needs to insert param values into the cursor portal */ BEGIN;
SELECT DECLARES_CURSOR('AB%');
FETCH ALL FROM c;
ROLLBACK;
/* in particular we want to see what happens during commit of a holdable */ /* cursor */ CREATE TEMPORARY TABLE x (x INT);
CREATE FUNCTION x() RETURNS BIGINT LANGUAGE sql VOLATILE AS 'select count(*) from tt1';
CREATE FUNCTION x() RETURNS BIGINT LANGUAGE sql STABLE AS 'select count(*) from tt1';
BEGIN;
INSERT INTO x VALUES (1);
DECLARE c1 cursor for select count_tt1_v(), count_tt1_s();
INSERT INTO x VALUES (2);
FETCH all from c1;
ROLLBACK;
BEGIN;
INSERT INTO x VALUES (1);
DECLARE c2 cursor with hold for select count_tt1_v(), count_tt1_s();
INSERT INTO x VALUES (2);
COMMIT;
DELETE FROM x;
FETCH all from c2;
DROP FUNCTION x;
DROP FUNCTION x;
/* Create a cursor with the BINARY option and check the pg_cursors view */ BEGIN;
SELECT x, x, x, x, x FROM x;
DECLARE bc BINARY CURSOR FOR SELECT * FROM tenk1;
SELECT x, x, x, x, x FROM x ORDER BY 1 NULLS LAST;
ROLLBACK;
/* We should not see the portal that is created internally to */ /* implement EXECUTE in pg_cursors */ PREPARE cprep AS   SELECT name, statement, is_holdable, is_binary, is_scrollable FROM pg_cursors;
EXECUTE cprep;
SELECT x FROM x ORDER BY 1 NULLS LAST;
x AS x;
SELECT x FROM x ORDER BY 1 NULLS LAST;
BEGIN;
DECLARE foo1 CURSOR WITH HOLD FOR SELECT 1;
DECLARE foo2 CURSOR WITHOUT HOLD FOR SELECT 1;
SELECT x FROM x ORDER BY 1 NULLS LAST;
x AS x;
SELECT x FROM x ORDER BY 1 NULLS LAST;
COMMIT;
/* Tests for updatable cursors */ CREATE TEMPORARY TABLE x (x INT, x TEXT);
INSERT INTO x VALUES (1, 'one'), (2, 'two'), (3, 'three');
SELECT * FROM x;
/* Check DELETE WHERE CURRENT */ BEGIN;
DECLARE c1 CURSOR FOR SELECT * FROM uctest;
FETCH 2 FROM c1;
/* should show deletion */ SELECT * FROM x;
/* cursor did not move */ FETCH ALL FROM c1;
FETCH ALL FROM c1;
COMMIT;
/* should still see deletion */ SELECT * FROM x;
DECLARE c1 CURSOR FOR SELECT * FROM uctest FOR UPDATE;
FETCH c1;
SELECT * FROM x;
COMMIT;
SELECT * FROM x;
/* Check repeated-update and update-then-delete cases */ BEGIN;
DECLARE c1 CURSOR FOR SELECT * FROM uctest;
FETCH c1;
SELECT * FROM x;
SELECT * FROM x;
/* insensitive cursor should not show effects of updates or deletes */ FETCH RELATIVE 0 FROM c1;
SELECT * FROM x;
/* no-op */ SELECT * FROM x;
/* no-op */ SELECT * FROM x;
FETCH RELATIVE 0 FROM c1;
ROLLBACK;
SELECT * FROM x;
BEGIN;
DECLARE c1 CURSOR FOR SELECT * FROM uctest FOR UPDATE;
FETCH c1;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
/* no-op */ SELECT * FROM x;
/* no-op */ SELECT * FROM x;
/* - FOR UPDATE cursors can't currently scroll back, so this is an error: */ FETCH RELATIVE 0 FROM c1;
ROLLBACK;
SELECT * FROM x;
/* Check insensitive cursor with INSERT */ /* (The above tests don't test the SQL notion of an insensitive cursor */ /* correctly, because per SQL standard, changes from WHERE CURRENT OF */ /* commands should be visible in the cursor.  So here we make the */ /* changes with a command that is independent of the cursor.) */ BEGIN;
DECLARE c1 INSENSITIVE CURSOR FOR SELECT * FROM uctest;
INSERT INTO x VALUES (10, 'ten');
FETCH NEXT FROM c1;
FETCH NEXT FROM c1;
FETCH NEXT FROM c1;
COMMIT /* insert not visible */ /* insert not visible */;
SELECT * FROM x;
DELETE FROM x WHERE x = 10;
/* restore test table state */ /* Check inheritance cases */ CREATE TEMPORARY TABLE x INHERITS (x);
INSERT INTO x VALUES (100, 'hundred');
SELECT * FROM x;
BEGIN;
DECLARE c1 CURSOR FOR SELECT * FROM uctest FOR UPDATE;
FETCH 1 FROM c1;
FETCH 1 FROM c1;
FETCH 1 FROM c1;
FETCH 1 FROM c1;
COMMIT;
SELECT * FROM x;
/* Can update from a self-join, but only if FOR UPDATE says which to use */ BEGIN;
DECLARE c1 CURSOR FOR SELECT * FROM uctest a, uctest b WHERE a.f1 = b.f1 + 5;
FETCH 1 FROM c1;
ROLLBACK /* fail */ /* fail */;
BEGIN;
DECLARE c1 CURSOR FOR SELECT * FROM uctest a, uctest b WHERE a.f1 = b.f1 + 5 FOR UPDATE;
FETCH 1 FROM c1;
ROLLBACK /* fail */ /* fail */;
BEGIN;
DECLARE c1 CURSOR FOR SELECT * FROM uctest a, uctest b WHERE a.f1 = b.f1 + 5 FOR SHARE OF a;
FETCH 1 FROM c1;
SELECT * FROM x;
ROLLBACK;
/* fail, no such cursor */ DECLARE cx CURSOR WITH HOLD FOR SELECT * FROM uctest;
/* fail, can't use held cursor */ BEGIN;
DECLARE c CURSOR FOR SELECT * FROM tenk2;
ROLLBACK /* fail, cursor on wrong table */ /* fail, cursor on wrong table */;
BEGIN;
DECLARE c CURSOR FOR SELECT * FROM tenk2 FOR SHARE;
ROLLBACK /* fail, cursor on wrong table */ /* fail, cursor on wrong table */;
BEGIN;
DECLARE c CURSOR FOR SELECT * FROM tenk1 JOIN tenk2 USING (unique1);
ROLLBACK /* fail, cursor is on a join */ /* fail, cursor is on a join */;
BEGIN;
DECLARE c CURSOR FOR SELECT f1,count(*) FROM uctest GROUP BY f1;
ROLLBACK /* fail, cursor is on aggregation */ /* fail, cursor is on aggregation */;
BEGIN;
DECLARE c1 CURSOR FOR SELECT * FROM uctest;
ROLLBACK /* fail, no current row */ /* fail, no current row */;
BEGIN;
DECLARE c1 CURSOR FOR SELECT MIN(f1) FROM uctest FOR UPDATE;
ROLLBACK;
/* WHERE CURRENT OF may someday work with views, but today is not that day. */ /* For now, just make sure it errors out cleanly. */ CREATE TEMPORARY VIEW x AS SELECT * FROM x;
CREATE RULE ucrule AS ON DELETE TO ucview DO INSTEAD   DELETE FROM uctest WHERE f1 = OLD.f1;
BEGIN;
DECLARE c1 CURSOR FOR SELECT * FROM ucview;
FETCH FROM c1;
ROLLBACK /* fail, views not supported */ /* fail, views not supported */;
/* Check WHERE CURRENT OF with an index-only scan */ BEGIN;
EXPLAIN (costs off) DECLARE c1 CURSOR FOR SELECT stringu1 FROM onek WHERE stringu1 = 'DZAAAA';
DECLARE c1 CURSOR FOR SELECT stringu1 FROM onek WHERE stringu1 = 'DZAAAA';
FETCH FROM c1;
SELECT x FROM x WHERE x = 'DZAAAA';
ROLLBACK;
/* Check behavior with rewinding to a previous child scan node, */ /* as per bug #15395 */ BEGIN;
CREATE TABLE x (x INT, x TEXT);
CREATE TABLE x INHERITS (x);
CREATE TABLE x INHERITS (x);
INSERT INTO x SELECT x, 'p' || x FROM x AS x;
INSERT INTO x SELECT x, 'P' || x FROM x AS x;
DECLARE c1 SCROLL CURSOR FOR SELECT * FROM current_check;
/* This tests the fetch-backwards code path */ FETCH ABSOLUTE 12 FROM c1;
FETCH ABSOLUTE 8 FROM c1;
/* This tests the ExecutorRewind code path */ FETCH ABSOLUTE 13 FROM c1;
FETCH ABSOLUTE 1 FROM c1;
SELECT * FROM x;
ROLLBACK;
/* Make sure snapshot management works okay, per bug report in */ /* 235395b90909301035v7228ce63q392931f15aa74b31@mail.gmail.com */ BEGIN;
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
CREATE TABLE x (x INT);
INSERT INTO x VALUES (1);
DECLARE c1 NO SCROLL CURSOR FOR SELECT * FROM cursor FOR UPDATE;
UPDATE x SET x = 2;
FETCH ALL FROM c1;
COMMIT;
DROP TABLE x;
/* Check rewinding a cursor containing a stable function in LIMIT, */ /* per bug report in 8336843.9833.1399385291498.JavaMail.root@quick */ BEGIN;
CREATE FUNCTION x(x) RETURNS INT LANGUAGE sql STABLE AS 'select $1 limit 1';
DECLARE c cursor for select * from int8_tbl limit nochange(3);
FETCH all from c;
FETCH all from c;
ROLLBACK;
/* Check handling of non-backwards-scan-capable plans with scroll cursors */ BEGIN;
EXPLAIN (costs off) declare c1 cursor for select (select 42) as x;
EXPLAIN (costs off) declare c1 scroll cursor for select (select 42) as x;
DECLARE c1 scroll cursor for select (select 42) as x;
FETCH all in c1;
FETCH backward all in c1;
ROLLBACK;
BEGIN;
EXPLAIN (costs off) declare c2 cursor for select generate_series(1,3) as g;
EXPLAIN (costs off) declare c2 scroll cursor for select generate_series(1,3) as g;
DECLARE c2 scroll cursor for select generate_series(1,3) as g;
FETCH all in c2;
FETCH backward all in c2;
ROLLBACK;
/* Check fetching of toasted datums via cursors. */ BEGIN;
SET x = 'pglz' /* Other compression algorithms may cause the compressed data to be stored */ /* inline.  Use pglz to ensure consistent results. */;
CREATE TABLE x (x ARRAY<INT>);
INSERT INTO x SELECT ARRAY_AGG(x) FROM x AS x;
DECLARE local_portal cursor for select * from toasted_data;
FETCH all in local_portal;
DECLARE held_portal cursor with hold for select * from toasted_data;
COMMIT;
DROP TABLE x;
FETCH all in held_portal;
RESET default_toast_compression;
/* PORTALS_P2 */ BEGIN;
DECLARE foo13 CURSOR FOR    SELECT * FROM onek WHERE unique1 = 50;
DECLARE foo14 CURSOR FOR    SELECT * FROM onek WHERE unique1 = 51;
DECLARE foo15 CURSOR FOR    SELECT * FROM onek WHERE unique1 = 52;
DECLARE foo16 CURSOR FOR    SELECT * FROM onek WHERE unique1 = 53;
DECLARE foo17 CURSOR FOR    SELECT * FROM onek WHERE unique1 = 54;
DECLARE foo18 CURSOR FOR    SELECT * FROM onek WHERE unique1 = 55;
DECLARE foo19 CURSOR FOR    SELECT * FROM onek WHERE unique1 = 56;
DECLARE foo20 CURSOR FOR    SELECT * FROM onek WHERE unique1 = 57;
DECLARE foo21 CURSOR FOR    SELECT * FROM onek WHERE unique1 = 58;
DECLARE foo22 CURSOR FOR    SELECT * FROM onek WHERE unique1 = 59;
DECLARE foo23 CURSOR FOR    SELECT * FROM onek WHERE unique1 = 60;
DECLARE foo24 CURSOR FOR    SELECT * FROM onek2 WHERE unique1 = 50;
DECLARE foo25 CURSOR FOR    SELECT * FROM onek2 WHERE unique1 = 60;
FETCH all in foo13;
FETCH all in foo14;
FETCH all in foo15;
FETCH all in foo16;
FETCH all in foo17;
FETCH all in foo18;
FETCH all in foo19;
FETCH all in foo20;
FETCH all in foo21;
FETCH all in foo22;
FETCH all in foo23;
FETCH all in foo24;
FETCH all in foo25;
x AS x;
x AS x;
x AS x;
x AS x;
x AS x;
x AS x;
x AS x;
x AS x;
x AS x;
x AS x;
x AS x;
x AS x;
x AS x;
COMMIT;
/* Tests for predicate handling */ /* Test that restrictions that are always true are ignored, and that are always */ /* false are replaced with constant-FALSE */ /* Currently we only check for NullTest quals and OR clauses that include */ /* NullTest quals.  We may extend it in the future. */ CREATE TABLE x (x INT NOT NULL, x INT, x INT NOT NULL);
/* Test restriction clauses */ /* Ensure the IS_NOT_NULL qual is ignored when the column is non-nullable */ EXPLAIN (COSTS OFF) SELECT * FROM pred_tab t WHERE t.a IS NOT NULL;
/* Ensure the IS_NOT_NULL qual is not ignored on a nullable column */ EXPLAIN (COSTS OFF) SELECT * FROM pred_tab t WHERE t.b IS NOT NULL;
/* Ensure the IS_NULL qual is reduced to constant-FALSE for non-nullable */ /* columns */ EXPLAIN (COSTS OFF) SELECT * FROM pred_tab t WHERE t.a IS NULL;
/* Ensure the IS_NULL qual is not reduced to constant-FALSE on nullable */ /* columns */ EXPLAIN (COSTS OFF) SELECT * FROM pred_tab t WHERE t.b IS NULL;
/* Tests for OR clauses in restriction clauses */ /* Ensure the OR clause is ignored when an OR branch is always true */ EXPLAIN (COSTS OFF) SELECT * FROM pred_tab t WHERE t.a IS NOT NULL OR t.b = 1;
/* Ensure the OR clause is not ignored for NullTests that can't be proven */ /* always true */ EXPLAIN (COSTS OFF) SELECT * FROM pred_tab t WHERE t.b IS NOT NULL OR t.a = 1;
/* Ensure the OR clause is reduced to constant-FALSE when all branches are */ /* provably false */ EXPLAIN (COSTS OFF) SELECT * FROM pred_tab t WHERE t.a IS NULL OR t.c IS NULL;
/* Ensure the OR clause is not reduced to constant-FALSE when not all branches */ /* are provably false */ EXPLAIN (COSTS OFF) SELECT * FROM pred_tab t WHERE t.b IS NULL OR t.c IS NULL;
/* Test join clauses */ /* Ensure the IS_NOT_NULL qual is ignored, since a) it's on a NOT NULL column, */ /* and b) its Var is not nullable by any outer joins */ EXPLAIN (COSTS OFF) SELECT * FROM pred_tab t1     LEFT JOIN pred_tab t2 ON t1.a IS NOT NULL;
/* Ensure the IS_NOT_NULL qual is not ignored when columns are made nullable */ /* by an outer join */ EXPLAIN (COSTS OFF) SELECT * FROM pred_tab t1     FULL JOIN pred_tab t2 ON t1.a = t2.a     LEFT JOIN pred_tab t3 ON t2.a IS NOT NULL;
/* Ensure the IS_NULL qual is reduced to constant-FALSE, since a) it's on a NOT */ /* NULL column, and b) its Var is not nullable by any outer joins */ EXPLAIN (COSTS OFF) SELECT * FROM pred_tab t1     LEFT JOIN pred_tab t2 ON t1.a IS NULL;
/* Ensure the IS_NULL qual is not reduced to constant-FALSE when the column is */ /* nullable by an outer join */ EXPLAIN (COSTS OFF) SELECT * FROM pred_tab t1     LEFT JOIN pred_tab t2 ON t1.a = 1     LEFT JOIN pred_tab t3 ON t2.a IS NULL;
/* Tests for OR clauses in join clauses */ /* Ensure the OR clause is ignored when an OR branch is provably always true */ EXPLAIN (COSTS OFF) SELECT * FROM pred_tab t1     LEFT JOIN pred_tab t2 ON t1.a IS NOT NULL OR t2.b = 1;
/* Ensure the NullTest is not ignored when the column is nullable by an outer */ /* join */ EXPLAIN (COSTS OFF) SELECT * FROM pred_tab t1     FULL JOIN pred_tab t2 ON t1.a = t2.a     LEFT JOIN pred_tab t3 ON t2.a IS NOT NULL OR t2.b = 1;
/* Ensure the OR clause is reduced to constant-FALSE when all OR branches are */ /* provably false */ EXPLAIN (COSTS OFF) SELECT * FROM pred_tab t1     LEFT JOIN pred_tab t2 ON (t1.a IS NULL OR t1.c IS NULL);
/* Ensure the OR clause is not reduced to constant-FALSE when a column is */ /* made nullable from an outer join */ EXPLAIN (COSTS OFF) SELECT * FROM pred_tab t1     LEFT JOIN pred_tab t2 ON t1.a = 1     LEFT JOIN pred_tab t3 ON t2.a IS NULL OR t2.c IS NULL;
DROP TABLE x;
/* Validate we handle IS NULL and IS NOT NULL quals correctly with inheritance */ /* parents. */ CREATE TABLE x (x INT);
CREATE TABLE x INHERITS (x);
ALTER TABLE ONLY x ALTER COLUMN x SET NOT NULL;
/* Ensure that the scan on pred_child contains the IS NOT NULL qual. */ EXPLAIN (COSTS OFF) SELECT * FROM pred_parent WHERE a IS NOT NULL;
/* Ensure we only scan pred_child and not pred_parent */ EXPLAIN (COSTS OFF) SELECT * FROM pred_parent WHERE a IS NULL;
ALTER TABLE x ALTER COLUMN x DROP NOT NULL;
ALTER TABLE x ALTER COLUMN x SET NOT NULL;
/* Ensure the IS NOT NULL qual is removed from the pred_child scan. */ EXPLAIN (COSTS OFF) SELECT * FROM pred_parent WHERE a IS NOT NULL;
/* Ensure we only scan pred_parent and not pred_child */ EXPLAIN (COSTS OFF) SELECT * FROM pred_parent WHERE a IS NULL;
/* Validate we do not reduce a clone clause to a constant true or false */ CREATE TABLE x (x INT, x INT);
CREATE TABLE x (x INT, x INT NOT NULL);
INSERT INTO x VALUES (1, 1);
INSERT INTO x VALUES (2, 2);
INSERT INTO x VALUES (2, 2);
INSERT INTO x VALUES (3, 3);
ANALYZE x;
ANALYZE x;
/* Ensure the IS_NOT_NULL qual is not reduced to constant true and removed */ EXPLAIN (COSTS OFF) SELECT * FROM pred_tab t1     LEFT JOIN pred_tab t2 ON TRUE     LEFT JOIN pred_tab_notnull t3 ON t2.a = t3.a     LEFT JOIN pred_tab t4 ON t3.b IS NOT NULL;
SELECT * FROM x AS x LEFT JOIN x AS x ON TRUE LEFT JOIN x AS x ON x.x = x.x LEFT JOIN x AS x ON NOT x.x IS NULL;
/* Ensure the IS_NULL qual is not reduced to constant false */ EXPLAIN (COSTS OFF) SELECT * FROM pred_tab t1     LEFT JOIN pred_tab t2 ON TRUE     LEFT JOIN pred_tab_notnull t3 ON t2.a = t3.a     LEFT JOIN pred_tab t4 ON t3.b IS NULL AND t3.a IS NOT NULL;
SELECT * FROM x AS x LEFT JOIN x AS x ON TRUE LEFT JOIN x AS x ON x.x = x.x LEFT JOIN x AS x ON x.x IS NULL AND NOT x.x IS NULL;
DROP TABLE x;
DROP TABLE x;
/* Regression tests for prepareable statements. We query the content */ /* of the pg_prepared_statements view as prepared statements are */ /* created and removed. */ SELECT x, x, x, x FROM x;
PREPARE q1 AS SELECT 1 AS a;
EXECUTE q1;
SELECT x, x, x, x FROM x;
/* should fail */ PREPARE q1 AS SELECT 2;
x AS x /* should succeed */;
PREPARE q1 AS SELECT 2;
EXECUTE q1;
PREPARE q2 AS SELECT 2 AS b;
SELECT x, x, x, x FROM x;
SELECT x, x, x, x FROM x;
/* the view should return the empty set again */ SELECT x, x, x, x FROM x;
/* parameterized queries */ PREPARE q2(text) AS 	SELECT datname, datistemplate, datallowconn 	FROM pg_database WHERE datname = $1;
EXECUTE q2('postgres');
PREPARE q3(text, int, float, boolean, smallint) AS 	SELECT * FROM tenk1 WHERE string4 = $1 AND (four = $2 OR 	ten = $3::bigint OR true = $4 OR odd = $5::int) 	ORDER BY unique1;
EXECUTE q3('AAAAxx', 5::smallint, 10.5::float, false, 4::bigint);
/* too few params */ EXECUTE q3('bool');
/* too many params */ EXECUTE q3('bytea', 5::smallint, 10.5::float, false, 4::bigint, true);
/* wrong param types */ EXECUTE q3(5::smallint, 10.5::float, false, 4::bigint, 'bytea');
/* invalid type */ PREPARE q4(nonexistenttype) AS SELECT $1;
/* create table as execute */ PREPARE q5(int, text) AS 	SELECT * FROM tenk1 WHERE unique1 = $1 OR stringu1 = $2 	ORDER BY unique1;
CREATE TEMPORARY TABLE x EXECUTE AS Q5(200, 'DTAAAA');
SELECT * FROM x;
CREATE TEMPORARY TABLE x EXECUTE AS Q5(200, 'DTAAAA') WITH NO DATA;
SELECT * FROM x;
/* unknown or unspecified parameter types: should succeed */ PREPARE q6 AS     SELECT * FROM tenk1 WHERE unique1 = $1 AND stringu1 = $2;
PREPARE q7(unknown) AS     SELECT * FROM road WHERE thepath = $1;
/* DML statements */ PREPARE q8 AS     UPDATE tenk1 SET stringu1 = $2 WHERE unique1 = $1;
SELECT x, x, x, x FROM x ORDER BY x NULLS LAST;
x AS x;
SELECT x, x, x FROM x ORDER BY x NULLS LAST;
/* PREPARED TRANSACTIONS (two-phase commit) */ /* We can't readily test persistence of prepared xacts within the */ /* regression script framework, unfortunately.  Note that a crash */ /* isn't really needed ... stopping and starting the postmaster would */ /* be enough, but we can't even do that here. */ /* create a simple table that we'll use in the tests */ CREATE TABLE x (x VARCHAR(10));
INSERT INTO x VALUES ('aaa');
BEGIN /* Test PREPARE TRANSACTION */;
UPDATE x SET x = 'bbb' WHERE x = 'aaa';
SELECT * FROM x;
PREPARE TRANSACTION 'regress_foo1';
SELECT * FROM x;
/* Test pg_prepared_xacts system view */ SELECT x FROM x WHERE REGEXP_LIKE(x, '^regress_') ORDER BY x NULLS LAST;
SELECT * FROM x;
SELECT x FROM x WHERE REGEXP_LIKE(x, '^regress_') ORDER BY x NULLS LAST;
BEGIN /* Test COMMIT PREPARED */;
INSERT INTO x VALUES ('ddd');
SELECT * FROM x;
PREPARE TRANSACTION 'regress_foo2';
SELECT * FROM x;
SELECT * FROM x;
BEGIN /* Test duplicate gids */;
UPDATE x SET x = 'eee' WHERE x = 'ddd';
SELECT * FROM x;
PREPARE TRANSACTION 'regress_foo3';
SELECT x FROM x WHERE REGEXP_LIKE(x, '^regress_') ORDER BY x NULLS LAST;
BEGIN;
INSERT INTO x VALUES ('fff');
/* This should fail, because the gid foo3 is already in use */ PREPARE TRANSACTION 'regress_foo3';
SELECT * FROM x;
SELECT * FROM x;
BEGIN /* Test serialization failure (SSI) */;
UPDATE x SET x = 'eee' WHERE x = 'ddd';
SELECT * FROM x;
PREPARE TRANSACTION 'regress_foo4';
SELECT x FROM x WHERE REGEXP_LIKE(x, '^regress_') ORDER BY x NULLS LAST;
BEGIN;
SELECT * FROM x;
/* This should fail, because the two transactions have a write-skew anomaly */ INSERT INTO x VALUES ('fff');
PREPARE TRANSACTION 'regress_foo5';
SELECT x FROM x WHERE REGEXP_LIKE(x, '^regress_') ORDER BY x NULLS LAST;
SELECT x FROM x WHERE REGEXP_LIKE(x, '^regress_') ORDER BY x NULLS LAST;
/* Clean up */ DROP TABLE x;
/* Test detection of session-level and xact-level locks on same object */ BEGIN;
SELECT PG_ADVISORY_LOCK(1);
SELECT PG_ADVISORY_XACT_LOCK_SHARED(1);
PREPARE TRANSACTION 'regress_foo6';
BEGIN /* fails */ /* Test subtransactions */;
CREATE TABLE x (x INT);
INSERT INTO x VALUES (1);
x AS x;
INSERT INTO x VALUES (2);
ROLLBACK TO x;
x AS x;
INSERT INTO x VALUES (3);
PREPARE TRANSACTION 'regress_sub1';
CREATE TABLE x (x INT);
BEGIN /* Test shared invalidation */;
DROP TABLE x;
CREATE TABLE x (x INT);
INSERT INTO x VALUES (1);
INSERT INTO x VALUES (2);
DECLARE foo CURSOR FOR SELECT * FROM pxtest4;
/* Fetch 1 tuple, keeping the cursor open */ FETCH 1 FROM foo;
PREPARE TRANSACTION 'regress_sub2';
/* No such cursor */ FETCH 1 FROM foo;
/* Table doesn't exist, the creation hasn't been committed yet */ SELECT * FROM x;
/* There should be two prepared transactions */ SELECT x FROM x WHERE REGEXP_LIKE(x, '^regress_') ORDER BY x NULLS LAST;
/* pxtest3 should be locked because of the pending DROP */ BEGIN;
ROLLBACK;
/* pxtest3 should still be locked because of the pending DROP */ BEGIN;
ROLLBACK;
/* There should be one prepared transaction */ SELECT x FROM x WHERE REGEXP_LIKE(x, '^regress_') ORDER BY x NULLS LAST;
SELECT * FROM x;
/* There should be no prepared transactions */ SELECT x FROM x WHERE REGEXP_LIKE(x, '^regress_') ORDER BY x NULLS LAST;
/* Clean up */ DROP TABLE x;
DROP TABLE x;
/* will still be there if prepared xacts are disabled */ DROP TABLE x;
SET x = 'warning' /* Test access privileges */ /* Clean up in case a prior regression run failed */ /* Suppress NOTICE messages when users/groups don't exist */;
DROP ROLE IF EXISTS regress_priv_group1;
DROP ROLE IF EXISTS regress_priv_group2;
DROP ROLE IF EXISTS regress_priv_user1;
DROP ROLE IF EXISTS regress_priv_user2;
DROP ROLE IF EXISTS regress_priv_user3;
DROP ROLE IF EXISTS regress_priv_user4;
DROP ROLE IF EXISTS regress_priv_user5;
DROP ROLE IF EXISTS regress_priv_user6;
DROP ROLE IF EXISTS regress_priv_user7;
SELECT LO_UNLINK(x) FROM x WHERE x >= 1000 AND x < 3000 ORDER BY x NULLS LAST;
RESET client_min_messages;
/* test proper begins here */ CREATE USER regress_priv_user1;
CREATE USER regress_priv_user2;
CREATE USER regress_priv_user3;
CREATE USER regress_priv_user4;
CREATE USER regress_priv_user5;
CREATE USER regress_priv_user5;
/* duplicate */ CREATE USER regress_priv_user6;
CREATE USER regress_priv_user7;
CREATE USER regress_priv_user8;
CREATE USER regress_priv_user9;
CREATE USER regress_priv_user10;
CREATE ROLE regress_priv_role;
/* circular ADMIN OPTION grants should be disallowed */ GRANT regress_priv_user1 TO regress_priv_user2 WITH ADMIN OPTION;
GRANT regress_priv_user1 TO regress_priv_user3 WITH ADMIN OPTION GRANTED BY regress_priv_user2;
GRANT regress_priv_user1 TO regress_priv_user2 WITH ADMIN OPTION GRANTED BY regress_priv_user3;
/* need CASCADE to revoke grant or admin option if dependent grants exist */ REVOKE ADMIN OPTION FOR regress_priv_user1 FROM regress_priv_user2;
/* fail */ REVOKE regress_priv_user1 FROM regress_priv_user2;
/* fail */ SELECT CAST(x AS REGROLE), x FROM x WHERE x = CAST('regress_priv_user1' AS REGROLE);
BEGIN;
REVOKE ADMIN OPTION FOR regress_priv_user1 FROM regress_priv_user2 CASCADE;
SELECT CAST(x AS REGROLE), x FROM x WHERE x = CAST('regress_priv_user1' AS REGROLE);
ROLLBACK;
REVOKE regress_priv_user1 FROM regress_priv_user2 CASCADE;
SELECT CAST(x AS REGROLE), x FROM x WHERE x = CAST('regress_priv_user1' AS REGROLE);
/* inferred grantor must be a role with ADMIN OPTION */ GRANT regress_priv_user1 TO regress_priv_user2 WITH ADMIN OPTION;
GRANT regress_priv_user2 TO regress_priv_user3;
SET ROLE regress_priv_user3;
GRANT regress_priv_user1 TO regress_priv_user4;
SELECT CAST(x AS REGROLE) FROM x WHERE x = CAST('regress_priv_user1' AS REGROLE) AND x = CAST('regress_priv_user4' AS REGROLE);
RESET ROLE;
REVOKE regress_priv_user2 FROM regress_priv_user3;
REVOKE regress_priv_user1 FROM regress_priv_user2 CASCADE;
/* test GRANTED BY with DROP OWNED and REASSIGN OWNED */ GRANT regress_priv_user1 TO regress_priv_user2 WITH ADMIN OPTION;
GRANT regress_priv_user1 TO regress_priv_user3 GRANTED BY regress_priv_user2;
DROP ROLE regress_priv_user2;
DROP ROLE regress_priv_user2;
/* still fail, REASSIGN OWNED doesn't help */ DROP OWNED BY regress_priv_user2;
DROP ROLE regress_priv_user2;
/* ok now, DROP OWNED does the job */ /* test that removing granted role or grantee role removes dependency */ GRANT regress_priv_user1 TO regress_priv_user3 WITH ADMIN OPTION;
GRANT regress_priv_user1 TO regress_priv_user4 GRANTED BY regress_priv_user3;
DROP ROLE regress_priv_user3;
/* should fail, dependency */ DROP ROLE regress_priv_user4;
/* ok */ DROP ROLE regress_priv_user3;
/* ok now */ GRANT regress_priv_user1 TO regress_priv_user5 WITH ADMIN OPTION;
GRANT regress_priv_user1 TO regress_priv_user6 GRANTED BY regress_priv_user5;
DROP ROLE regress_priv_user5;
/* should fail, dependency */ DROP ROLE regress_priv_user1, regress_priv_user5;
/* ok, despite order */ /* recreate the roles we just dropped */ CREATE USER regress_priv_user1;
CREATE USER regress_priv_user2;
CREATE USER regress_priv_user3;
CREATE USER regress_priv_user4;
CREATE USER regress_priv_user5;
/* DROP OWNED should also act on granted and granted-to roles */ GRANT regress_priv_user1 TO regress_priv_user2;
GRANT regress_priv_user2 TO regress_priv_user3;
SELECT CAST(x AS REGROLE), CAST(x AS REGROLE) FROM x WHERE x IN (CAST('regress_priv_user1' AS REGROLE), CAST('regress_priv_user2' AS REGROLE)) ORDER BY CAST(CAST(x AS REGROLE) AS TEXT) NULLS LAST;
/* no effect */ SELECT CAST(x AS REGROLE), CAST(x AS REGROLE) FROM x WHERE x IN (CAST('regress_priv_user1' AS REGROLE), CAST('regress_priv_user2' AS REGROLE)) ORDER BY CAST(CAST(x AS REGROLE) AS TEXT) NULLS LAST;
DROP OWNED BY regress_priv_user2;
/* removes both grants */ SELECT CAST(x AS REGROLE), CAST(x AS REGROLE) FROM x WHERE x IN (CAST('regress_priv_user1' AS REGROLE), CAST('regress_priv_user2' AS REGROLE)) ORDER BY CAST(CAST(x AS REGROLE) AS TEXT) NULLS LAST;
GRANT pg_read_all_data TO regress_priv_user6;
GRANT pg_write_all_data TO regress_priv_user7;
GRANT pg_read_all_settings TO regress_priv_user8 WITH ADMIN OPTION;
GRANT regress_priv_user9 TO regress_priv_user8;
SET SESSION AUTHORIZATION regress_priv_user8;
GRANT pg_read_all_settings TO regress_priv_user9 WITH ADMIN OPTION;
SET SESSION AUTHORIZATION regress_priv_user9;
GRANT pg_read_all_settings TO regress_priv_user10;
SET SESSION AUTHORIZATION regress_priv_user8;
REVOKE pg_read_all_settings FROM regress_priv_user10 GRANTED BY regress_priv_user9;
REVOKE ADMIN OPTION FOR pg_read_all_settings FROM regress_priv_user9;
REVOKE pg_read_all_settings FROM regress_priv_user9;
RESET SESSION AUTHORIZATION;
REVOKE regress_priv_user9 FROM regress_priv_user8;
REVOKE ADMIN OPTION FOR pg_read_all_settings FROM regress_priv_user8;
SET SESSION AUTHORIZATION regress_priv_user8;
SET ROLE pg_read_all_settings;
RESET ROLE;
RESET SESSION AUTHORIZATION;
REVOKE SET OPTION FOR pg_read_all_settings FROM regress_priv_user8;
GRANT pg_read_all_stats TO regress_priv_user8 WITH SET FALSE;
SET SESSION AUTHORIZATION regress_priv_user8;
SET ROLE pg_read_all_settings;
/* fail, no SET option any more */ SET ROLE pg_read_all_stats;
/* fail, granted without SET option */ RESET ROLE;
RESET SESSION AUTHORIZATION;
/* test interaction of SET SESSION AUTHORIZATION and SET ROLE, */ /* as well as propagation of these settings to parallel workers */ GRANT regress_priv_user9 TO regress_priv_user8;
SET SESSION AUTHORIZATION regress_priv_user8;
SET ROLE regress_priv_user9;
SET x = 0;
SELECT x, x, CURRENT_USER(), CURRENT_SETTING('role') AS x;
SET x = 1;
SELECT x, x, CURRENT_USER(), CURRENT_SETTING('role') AS x;
BEGIN;
SET SESSION AUTHORIZATION regress_priv_user10;
SET x = 0;
SELECT x, x, CURRENT_USER(), CURRENT_SETTING('role') AS x;
SET x = 1;
SELECT x, x, CURRENT_USER(), CURRENT_SETTING('role') AS x;
ROLLBACK;
SET x = 0;
SELECT x, x, CURRENT_USER(), CURRENT_SETTING('role') AS x;
SET x = 1;
SELECT x, x, CURRENT_USER(), CURRENT_SETTING('role') AS x;
RESET SESSION AUTHORIZATION;
SET x = 0 /* session_user at this point is installation-dependent */;
SELECT x = x AS x, x = CURRENT_USER() AS x, CURRENT_SETTING('role') AS x;
SET x = 1;
SELECT x = x AS x, x = CURRENT_USER() AS x, CURRENT_SETTING('role') AS x;
RESET debug_parallel_query;
REVOKE pg_read_all_settings FROM regress_priv_user8;
DROP USER regress_priv_user10;
DROP USER regress_priv_user9;
DROP USER regress_priv_user8;
CREATE GROUP regress_priv_group1;
CREATE GROUP regress_priv_group2 WITH ADMIN regress_priv_user1 USER regress_priv_user2;
ALTER GROUP regress_priv_group1 ADD USER regress_priv_user4;
GRANT regress_priv_group2 TO regress_priv_user2 GRANTED BY regress_priv_user1;
SET SESSION AUTHORIZATION regress_priv_user3;
ALTER GROUP regress_priv_group2 ADD USER regress_priv_user2;
/* fail */ ALTER GROUP regress_priv_group2 DROP USER regress_priv_user2;
/* fail */ SET SESSION AUTHORIZATION regress_priv_user1;
ALTER GROUP regress_priv_group2 ADD USER regress_priv_user2;
ALTER GROUP regress_priv_group2 ADD USER regress_priv_user2;
/* duplicate */ ALTER GROUP regress_priv_group2 DROP USER regress_priv_user2;
ALTER USER regress_priv_user2 PASSWORD 'verysecret';
/* not permitted */ RESET SESSION AUTHORIZATION;
ALTER GROUP regress_priv_group2 DROP USER regress_priv_user2;
REVOKE ADMIN OPTION FOR regress_priv_group2 FROM regress_priv_user1;
GRANT regress_priv_group2 TO regress_priv_user4 WITH ADMIN OPTION;
/* prepare non-leakproof function for later */ CREATE FUNCTION x(x, x) RETURNS BOOLEAN LANGUAGE internal IMMUTABLE STRICT AS 'int4lt';
/* but deliberately not LEAKPROOF */ ALTER FUNCTION leak(integer,integer) OWNER TO regress_priv_user1;
/* test owner privileges */ GRANT regress_priv_role TO regress_priv_user1 WITH ADMIN OPTION GRANTED BY regress_priv_role;
/* error, doesn't have ADMIN OPTION */ GRANT regress_priv_role TO regress_priv_user1 WITH ADMIN OPTION GRANTED BY CURRENT_ROLE;
REVOKE ADMIN OPTION FOR regress_priv_role FROM regress_priv_user1 GRANTED BY foo;
/* error */ REVOKE ADMIN OPTION FOR regress_priv_role FROM regress_priv_user1 GRANTED BY regress_priv_user2;
/* warning, noop */ REVOKE ADMIN OPTION FOR regress_priv_role FROM regress_priv_user1 GRANTED BY CURRENT_USER;
REVOKE regress_priv_role FROM regress_priv_user1 GRANTED BY CURRENT_ROLE;
DROP ROLE regress_priv_role;
SET SESSION AUTHORIZATION regress_priv_user1;
SELECT x, CURRENT_USER();
CREATE TABLE x (x INT, x TEXT);
SELECT * FROM x;
INSERT INTO x VALUES (1, 'one');
DELETE FROM x;
UPDATE x SET x = 1 WHERE x = 'blech';
TRUNCATE TABLE x;
BEGIN;
COMMIT;
REVOKE ALL ON atest1 FROM PUBLIC;
SELECT * FROM x;
GRANT ALL ON x TO x;
GRANT SELECT ON x TO x, x;
SELECT * FROM x;
CREATE TABLE x (x VARCHAR(10), x BOOLEAN);
SELECT PG_GET_ACL(CAST('pg_class' AS REGCLASS), CAST(CAST('atest2' AS REGCLASS) AS OID), 0);
GRANT SELECT ON x TO x;
GRANT UPDATE ON x TO x;
GRANT INSERT ON atest2 TO regress_priv_user4 GRANTED BY CURRENT_USER;
GRANT TRUNCATE ON atest2 TO regress_priv_user5 GRANTED BY CURRENT_ROLE;
SELECT EXPLODE(PG_GET_ACL(CAST('pg_class' AS REGCLASS), CAST(CAST('atest2' AS REGCLASS) AS OID), 0));
/* Invalid inputs */ SELECT PG_GET_ACL(CAST('pg_class' AS REGCLASS), 0, 0);
/* null */ SELECT PG_GET_ACL(0, 0, 0);
/* null */ GRANT TRUNCATE ON atest2 TO regress_priv_user4 GRANTED BY regress_priv_user5;
/* error */ SET SESSION AUTHORIZATION regress_priv_user2;
SELECT x, CURRENT_USER();
/* try various combinations of queries on atest1 and atest2 */ SELECT * FROM x;
/* ok */ SELECT * FROM x;
/* ok */ INSERT INTO x VALUES (2, 'two');
/* ok */ INSERT INTO x VALUES ('foo', TRUE);
/* fail */ INSERT INTO x SELECT 1, x FROM x;
/* ok */ UPDATE x SET x = 1 WHERE x = 2;
/* ok */ UPDATE x SET x = NOT x;
/* fail */ SELECT * FROM x;
/* ok */ SELECT * FROM x;
/* fail */ DELETE FROM x;
TRUNCATE TABLE x /* fail */;
/* fail */ BEGIN;
COMMIT /* fail */ /* fail */;
COPY INTO x FROM x;
GRANT ALL ON x TO x /* fail */;
/* fail */ /* checks in subquery, both ok */ SELECT * FROM x WHERE (x IN (SELECT x FROM x));
SELECT * FROM x WHERE (x IN (SELECT x FROM x));
SET SESSION AUTHORIZATION regress_priv_user6;
SELECT * FROM x;
/* ok */ SELECT * FROM x;
/* ok */ INSERT INTO x VALUES ('foo', TRUE);
/* fail */ SET SESSION AUTHORIZATION regress_priv_user7;
SELECT * FROM x;
/* fail */ SELECT * FROM x;
/* fail */ INSERT INTO x VALUES ('foo', TRUE);
/* ok */ UPDATE x SET x = TRUE;
/* ok */ DELETE FROM x;
/* ok */ /* Make sure we are not able to modify system catalogs */ UPDATE x.x SET x = '123';
/* fail */ DELETE FROM x.x;
/* fail */ UPDATE x.x SET x = 1;
/* fail */ SET SESSION AUTHORIZATION regress_priv_user3;
SELECT x, CURRENT_USER();
SELECT * FROM x;
/* ok */ SELECT * FROM x;
/* fail */ INSERT INTO x VALUES (2, 'two');
/* fail */ INSERT INTO x VALUES ('foo', TRUE);
/* fail */ INSERT INTO x SELECT 1, x FROM x;
/* fail */ UPDATE x SET x = 1 WHERE x = 2;
/* fail */ UPDATE x SET x = NULL;
/* ok */ UPDATE x SET x = NOT x;
/* ok */ SELECT * FROM x;
/* fail */ SELECT * FROM x;
/* fail */ DELETE FROM x;
TRUNCATE TABLE x /* fail */;
/* fail */ BEGIN;
COMMIT /* ok */ /* ok */;
COPY INTO x FROM x;
/* fail */ /* checks in subquery, both fail */ SELECT * FROM x WHERE (x IN (SELECT x FROM x));
SELECT * FROM x WHERE (x IN (SELECT x FROM x));
SET SESSION AUTHORIZATION regress_priv_user4;
COPY INTO x FROM x;
/* ok */ /* test leaky-function protections in selfuncs */ /* regress_priv_user1 will own a table and provide views for it. */ SET SESSION AUTHORIZATION regress_priv_user1;
CREATE TABLE x AS SELECT x AS x, 10001 - x AS x FROM x AS x;
CREATE INDEX ON x(x NULLS LAST);
CREATE INDEX ON x(ABS(x) NULLS LAST);
ALTER TABLE x SET x = x /* results below depend on having quite accurate stats for atest12, so... */;
SET x = 10000;
VACUUM ANALYZE atest12;
RESET default_statistics_target;
CREATE OPERATOR <<< (procedure = leak, leftarg = integer, rightarg = integer,                      restrict = scalarltsel);
GRANT SELECT ON x TO x;
GRANT SELECT ON x TO x;
/* This plan should use nestloop, knowing that few rows will be selected. */ EXPLAIN (COSTS OFF) SELECT * FROM atest12v x, atest12v y WHERE x.a = y.b;
/* And this one. */ EXPLAIN (COSTS OFF) SELECT * FROM atest12 x, atest12 y   WHERE x.a = y.b and abs(y.a) <<< 5;
/* This should also be a nestloop, but the security barrier forces the inner */ /* scan to be materialized */ EXPLAIN (COSTS OFF) SELECT * FROM atest12sbv x, atest12sbv y WHERE x.a = y.b;
/* Check if regress_priv_user2 can break security. */ SET SESSION AUTHORIZATION regress_priv_user2;
CREATE OPERATOR >>> (procedure = leak2, leftarg = integer, rightarg = integer,                      restrict = scalargtsel);
/* This should not show any "leak" notices before failing. */ EXPLAIN (COSTS OFF) SELECT * FROM atest12 WHERE a >>> 0;
/* These plans should continue to use a nestloop, since they execute with the */ /* privileges of the view owner. */ EXPLAIN (COSTS OFF) SELECT * FROM atest12v x, atest12v y WHERE x.a = y.b;
EXPLAIN (COSTS OFF) SELECT * FROM atest12sbv x, atest12sbv y WHERE x.a = y.b;
/* A non-security barrier view does not guard against information leakage. */ EXPLAIN (COSTS OFF) SELECT * FROM atest12v x, atest12v y   WHERE x.a = y.b and abs(y.a) <<< 5;
/* But a security barrier view isolates the leaky operator. */ EXPLAIN (COSTS OFF) SELECT * FROM atest12sbv x, atest12sbv y   WHERE x.a = y.b and abs(y.a) <<< 5;
/* Now regress_priv_user1 grants sufficient access to regress_priv_user2. */ SET SESSION AUTHORIZATION regress_priv_user1;
GRANT SELECT(x, x) ON x TO x;
SET SESSION AUTHORIZATION regress_priv_user2;
/* regress_priv_user2 should continue to get a good row estimate. */ EXPLAIN (COSTS OFF) SELECT * FROM atest12v x, atest12v y WHERE x.a = y.b;
/* But not for this, due to lack of table-wide permissions needed */ /* to make use of the expression index's statistics. */ EXPLAIN (COSTS OFF) SELECT * FROM atest12 x, atest12 y   WHERE x.a = y.b and abs(y.a) <<< 5;
/* clean up (regress_priv_user1's objects are all dropped later) */ DROP FUNCTION x (INT, INT) CASCADE;
/* groups */ SET SESSION AUTHORIZATION regress_priv_user3;
CREATE TABLE x (x INT, x INT, x INT);
GRANT DELETE ON x TO GROUP x;
SET SESSION AUTHORIZATION regress_priv_user1;
SELECT * FROM x;
/* fail */ DELETE FROM x;
/* ok */ BEGIN;
RESET SESSION AUTHORIZATION;
ALTER ROLE regress_priv_user1 NOINHERIT;
SET SESSION AUTHORIZATION regress_priv_user1;
x AS x;
DELETE FROM x;
ROLLBACK TO x /* ok because grant-level option is unchanged */;
RESET SESSION AUTHORIZATION;
GRANT regress_priv_group2 TO regress_priv_user1 WITH INHERIT FALSE;
SET SESSION AUTHORIZATION regress_priv_user1;
DELETE FROM x;
ROLLBACK TO x /* fail */;
RESET SESSION AUTHORIZATION;
REVOKE INHERIT OPTION FOR regress_priv_group2 FROM regress_priv_user1;
SET SESSION AUTHORIZATION regress_priv_user1;
DELETE FROM x;
ROLLBACK /* also fail */ /* also fail */;
/* views */ SET SESSION AUTHORIZATION regress_priv_user3;
CREATE VIEW x AS SELECT * FROM x;
/* ok */ /* The next *should* fail, but it's not implemented that way yet. */ CREATE VIEW x AS SELECT * FROM x;
CREATE VIEW x AS SELECT * FROM x;
/* ok */ /* Empty view is a corner case that failed in 9.2. */ CREATE VIEW x AS SELECT 0 AS x WHERE FALSE;
/* ok */ SELECT * FROM x;
/* ok */ SELECT * FROM x;
/* fail */ GRANT SELECT ON atestv1, atestv3 TO regress_priv_user4;
GRANT SELECT ON x TO x;
SET SESSION AUTHORIZATION regress_priv_user4;
SELECT * FROM x;
/* ok */ SELECT * FROM x;
/* fail */ SELECT * FROM x;
/* ok */ SELECT * FROM x;
/* fail */ /* Appendrels excluded by constraints failed to check permissions in 8.4-9.2. */ SELECT * FROM ((SELECT x.x AS x FROM x AS x OFFSET 0) UNION ALL (SELECT x.x AS x FROM x AS x OFFSET 0)) AS x WHERE FALSE;
SET x = on;
SELECT * FROM ((SELECT x.x AS x, RAND() FROM x AS x WHERE x > 0) UNION ALL (SELECT x.x AS x, RAND() FROM x AS x WHERE x > 0)) AS x WHERE x < 0;
RESET constraint_exclusion;
CREATE VIEW x AS SELECT * FROM x;
/* nested view */ SELECT * FROM x;
GRANT SELECT ON x TO x /* ok */;
SET SESSION AUTHORIZATION regress_priv_user2;
/* Two complex cases: */ SELECT * FROM x;
/* fail */ SELECT * FROM x;
/* ok (even though regress_priv_user2 cannot access underlying atestv3) */ SELECT * FROM x;
/* ok */ SELECT * FROM x;
/* fail (even though regress_priv_user2 can access underlying atest2) */ /* Test column level permissions */ SET SESSION AUTHORIZATION regress_priv_user1;
CREATE TABLE x (x INT, x INT UNIQUE, x INT, x INT UNIQUE);
CREATE TABLE x (x INT, x INT, x INT);
GRANT SELECT(x), INSERT(x), UPDATE(x) ON x TO x;
GRANT ALL(x) ON x TO x;
SELECT EXPLODE(PG_GET_ACL(CAST('pg_class' AS REGCLASS), CAST(CAST('atest5' AS REGCLASS) AS OID), 1));
SELECT EXPLODE(PG_GET_ACL(CAST('pg_class' AS REGCLASS), CAST(CAST('atest5' AS REGCLASS) AS OID), 2));
SELECT EXPLODE(PG_GET_ACL(CAST('pg_class' AS REGCLASS), CAST(CAST('atest5' AS REGCLASS) AS OID), 3));
SELECT EXPLODE(PG_GET_ACL(CAST('pg_class' AS REGCLASS), CAST(CAST('atest5' AS REGCLASS) AS OID), 4));
INSERT INTO x VALUES (1, 2, 3);
SET SESSION AUTHORIZATION regress_priv_user4;
SELECT * FROM x;
/* fail */ SELECT x FROM x;
COPY INTO x (x) TO x /* ok */;
/* ok */ SELECT x FROM x;
COPY INTO x (x) TO x /* fail */;
/* fail */ SELECT x FROM x;
COPY INTO x (x, x) TO x /* fail */;
/* fail */ SELECT 1 FROM x;
/* ok */ SELECT 1 FROM x AS x JOIN x AS x USING (x);
/* ok */ SELECT 1 FROM x AS x JOIN x AS x USING (x);
/* fail */ SELECT 1 FROM x AS x NATURAL JOIN x AS x;
/* fail */ SELECT * FROM (x AS x JOIN x AS x USING (x)) AS x;
/* fail */ SELECT x.* FROM (x AS x JOIN x AS x USING (x)) AS x;
/* fail */ SELECT (x.*) IS NULL FROM (x AS x JOIN x AS x USING (x)) AS x;
/* fail */ SELECT x FROM (x AS x JOIN x AS x USING (x)) AS x;
/* ok */ SELECT x.x FROM (x AS x JOIN x AS x USING (x)) AS x;
/* ok */ SELECT x FROM (x AS x JOIN x AS x USING (x)) AS x;
/* fail */ SELECT x.x FROM (x AS x JOIN x AS x USING (x)) AS x;
/* fail */ SELECT x FROM (x AS x JOIN x AS x USING (x)) AS x;
/* fail */ SELECT x.x FROM (x AS x JOIN x AS x USING (x)) AS x;
/* fail */ SELECT * FROM (x AS x JOIN x AS x USING (x));
/* fail */ SELECT x.* FROM (x AS x JOIN x AS x USING (x));
/* fail */ SELECT (x.*) IS NULL FROM (x AS x JOIN x AS x USING (x));
/* fail */ SELECT x FROM (x AS x JOIN x AS x USING (x));
/* fail */ SELECT x.x FROM (x AS x JOIN x AS x USING (x));
/* fail */ SELECT x FROM (x AS x JOIN x AS x USING (x));
/* fail */ SELECT x.x FROM (x AS x JOIN x AS x USING (x));
/* fail */ SELECT x FROM (x AS x LEFT JOIN x AS x USING (x));
/* fail */ SELECT x.x FROM (x AS x LEFT JOIN x AS x USING (x));
/* fail */ SELECT x FROM (x AS x FULL JOIN x AS x USING (x));
/* fail */ SELECT x.x FROM (x AS x FULL JOIN x AS x USING (x));
/* fail */ SELECT 1 FROM x WHERE x = 2;
/* fail */ SELECT * FROM x, x;
/* fail */ SELECT x.* FROM x, x;
/* ok */ SELECT x.*, x.x FROM x, x;
/* ok */ SELECT x.*, x.x FROM x JOIN x ON (x.x = x.x);
/* fail */ SELECT x.*, x.x FROM x JOIN x ON (x.x = x.x);
/* ok */ SELECT x, x FROM x;
/* fail */ SET SESSION AUTHORIZATION regress_priv_user1;
GRANT SELECT(x, x) ON x TO x;
SET SESSION AUTHORIZATION regress_priv_user4;
SELECT x, x FROM x NATURAL JOIN x;
/* fail still */ SET SESSION AUTHORIZATION regress_priv_user1;
GRANT SELECT(x) ON x TO x;
SET SESSION AUTHORIZATION regress_priv_user4;
SELECT x, x FROM x NATURAL JOIN x;
/* ok now */ /* test column-level privileges for INSERT and UPDATE */ INSERT INTO x (x) VALUES (3);
COPY INTO x FROM x /* ok */;
COPY INTO x (x) FROM x /* fail */;
/* fail */ INSERT INTO x VALUES (5, 5, 5);
/* fail */ UPDATE x SET x = 10;
/* ok */ UPDATE x SET x = 8;
/* fail */ UPDATE x SET x = 5, x = 2;
/* fail */ /* Check that column level privs are enforced in RETURNING */ /* Ok. */ INSERT INTO x (x) VALUES (6) ON CONFLICT(x) DO UPDATE SET x = 10;
/* Error. No SELECT on column three. */ INSERT INTO x (x) VALUES (6) ON CONFLICT(x) DO UPDATE SET x = 10 RETURNING x.x;
/* Ok.  May SELECT on column "one": */ INSERT INTO x (x) VALUES (6) ON CONFLICT(x) DO UPDATE SET x = 10 RETURNING x.x;
/* Check that column level privileges are enforced for EXCLUDED */ /* Ok. we may select one */ INSERT INTO x (x) VALUES (6) ON CONFLICT(x) DO UPDATE SET x = x.x;
/* Error. No select rights on three */ INSERT INTO x (x) VALUES (6) ON CONFLICT(x) DO UPDATE SET x = x.x;
INSERT INTO x (x) VALUES (6) ON CONFLICT(x) DO UPDATE SET x = 8;
/* fails (due to UPDATE) */ INSERT INTO x (x) VALUES (4) ON CONFLICT(x) DO UPDATE SET x = 10;
/* fails (due to INSERT) */ /* Check that the columns in the inference require select privileges */ INSERT INTO x (x) VALUES (4);
/* fail */ SET SESSION AUTHORIZATION regress_priv_user1;
GRANT INSERT(x) ON x TO x;
SET SESSION AUTHORIZATION regress_priv_user4;
INSERT INTO x (x) VALUES (4) ON CONFLICT(x) DO UPDATE SET x = 3;
/* fails (due to SELECT) */ INSERT INTO x (x) VALUES (4) ON CONFLICT ON CONSTRAINT x DO UPDATE SET x = 3;
/* fails (due to SELECT) */ INSERT INTO x (x) VALUES (4);
/* ok */ SET SESSION AUTHORIZATION regress_priv_user1;
GRANT SELECT(x) ON x TO x;
SET SESSION AUTHORIZATION regress_priv_user4;
INSERT INTO x (x) VALUES (4) ON CONFLICT(x) DO UPDATE SET x = 3;
/* ok */ INSERT INTO x (x) VALUES (4) ON CONFLICT ON CONSTRAINT x DO UPDATE SET x = 3;
/* ok */ SET SESSION AUTHORIZATION regress_priv_user1;
REVOKE ALL (one) ON atest5 FROM regress_priv_user4;
GRANT SELECT(x, x, x) ON x TO x;
SET SESSION AUTHORIZATION regress_priv_user4;
SELECT x FROM x;
/* fail */ UPDATE x SET x = 1;
/* fail */ SELECT x FROM x;
COPY INTO x TO x /* ok */;
/* ok */ /* test column privileges with MERGE */ SET SESSION AUTHORIZATION regress_priv_user1;
CREATE TABLE x (x INT, x TEXT);
CREATE TABLE x (x INT, x TEXT);
INSERT INTO x VALUES (1, 'init1'), (2, 'init2');
INSERT INTO x VALUES (1, 'source1'), (2, 'source2'), (3, 'source3');
GRANT SELECT(x) ON x TO x;
GRANT SELECT(x) ON x TO x;
GRANT INSERT(x, x) ON x TO x;
GRANT UPDATE(x) ON x TO x;
SET SESSION AUTHORIZATION regress_priv_user4;
MERGE INTO x AS x USING x AS x ON x.x = x.x WHEN MATCHED THEN UPDATE SET x = x.x WHEN NOT MATCHED THEN INSERT VALUES (x, NULL) /* test source privileges */ /* fail (no SELECT priv on s.b) */;
MERGE INTO x AS x USING x AS x ON x.x = x.x WHEN MATCHED THEN UPDATE SET x = 'x' WHEN NOT MATCHED THEN INSERT VALUES (x, x) /* fail (s.b used in the INSERTed values) */;
MERGE INTO x AS x USING x AS x ON x.x = x.x WHEN MATCHED AND x.x = 'x' THEN UPDATE SET x = 'x' WHEN NOT MATCHED THEN INSERT VALUES (x, NULL) /* fail (s.b used in the WHEN quals) */;
/* this should be ok since only s.a is accessed */ BEGIN;
MERGE INTO x AS x USING x AS x ON x.x = x.x WHEN MATCHED THEN UPDATE SET x = 'ok' WHEN NOT MATCHED THEN INSERT VALUES (x, NULL);
ROLLBACK;
SET SESSION AUTHORIZATION regress_priv_user1;
GRANT SELECT(x) ON x TO x;
SET SESSION AUTHORIZATION regress_priv_user4;
/* should now be ok */ BEGIN;
MERGE INTO x AS x USING x AS x ON x.x = x.x WHEN MATCHED THEN UPDATE SET x = x.x WHEN NOT MATCHED THEN INSERT VALUES (x, x);
ROLLBACK;
MERGE INTO x AS x USING x AS x ON x.x = x.x WHEN MATCHED THEN UPDATE SET x = x.x WHEN NOT MATCHED THEN INSERT VALUES (x, NULL) /* test target privileges */ /* fail (no SELECT priv on t.b) */;
MERGE INTO x AS x USING x AS x ON x.x = x.x WHEN MATCHED THEN UPDATE SET x = x.x, x = x.x + 1 WHEN NOT MATCHED THEN INSERT VALUES (x, x) /* fail (no UPDATE on t.a) */;
MERGE INTO x AS x USING x AS x ON x.x = x.x WHEN MATCHED AND NOT x.x IS NULL THEN UPDATE SET x = x.x WHEN NOT MATCHED THEN INSERT VALUES (x, x) /* fail (no SELECT on t.b) */;
/* ok */ BEGIN;
MERGE INTO x AS x USING x AS x ON x.x = x.x WHEN MATCHED THEN UPDATE SET x = x.x;
ROLLBACK;
MERGE INTO x AS x USING x AS x ON x.x = x.x WHEN MATCHED AND NOT x.x IS NULL THEN DELETE /* fail (no DELETE) */;
/* grant delete privileges */ SET SESSION AUTHORIZATION regress_priv_user1;
GRANT DELETE ON x TO x;
/* should be ok now */ BEGIN;
MERGE INTO x AS x USING x AS x ON x.x = x.x WHEN MATCHED AND NOT x.x IS NULL THEN DELETE;
ROLLBACK;
/* check error reporting with column privs */ SET SESSION AUTHORIZATION regress_priv_user1;
CREATE TABLE x (x INT, x INT, x INT CHECK (x < 5), PRIMARY KEY (x NULLS LAST, x NULLS LAST));
GRANT SELECT(x) ON x TO x;
GRANT INSERT(x, x, x) ON x TO x;
GRANT UPDATE(x, x, x) ON x TO x;
/* seed data */ INSERT INTO x VALUES (1, 1, 1);
INSERT INTO x VALUES (1, 2, 1);
INSERT INTO x VALUES (2, 1, 2);
INSERT INTO x VALUES (2, 2, 2);
INSERT INTO x VALUES (3, 1, 3);
SET SESSION AUTHORIZATION regress_priv_user2;
INSERT INTO x (x, x) VALUES (1, 1);
/* fail, but row not shown */ UPDATE x SET x = 1;
/* fail, but row not shown */ INSERT INTO x (x, x) VALUES (NULL, NULL);
/* fail, but see columns being inserted */ INSERT INTO x (x) VALUES (NULL);
/* fail, but see columns being inserted or have SELECT */ INSERT INTO x (x) VALUES (5);
/* fail, but see columns being inserted or have SELECT */ UPDATE x SET x = 10;
/* fail, but see columns with SELECT rights, or being modified */ SET SESSION AUTHORIZATION regress_priv_user1;
DROP TABLE x;
/* check error reporting with column privs on a partitioned table */ CREATE TABLE x (x TEXT, x TEXT NOT NULL, x TEXT, x TEXT, x TEXT) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x (x TEXT, x TEXT, x TEXT, x TEXT NOT NULL, x TEXT);
CREATE TABLE x (x TEXT, x TEXT, x TEXT, x TEXT, x TEXT NOT NULL);
ALTER TABLE errtst ATTACH PARTITION errtst_part_1 FOR VALUES IN ('aaa');
ALTER TABLE errtst ATTACH PARTITION errtst_part_2 FOR VALUES IN ('aaaa');
GRANT SELECT(x, x, x) ON TABLE x TO x;
GRANT UPDATE(x, x, x) ON TABLE x TO x;
GRANT INSERT(x, x, x) ON TABLE x TO x;
INSERT INTO x (x, x, x, x, x) VALUES ('aaa', 'bbb', 'ccc', 'the body', 'is in the attic');
SET SESSION AUTHORIZATION regress_priv_user2;
/* Perform a few updates that violate the NOT NULL constraint. Make sure */ /* the error messages don't leak the secret fields. */ /* simple insert. */ INSERT INTO x (x, x) VALUES ('aaa', NULL);
/* simple update. */ UPDATE x SET x = NULL;
/* partitioning key is updated, doesn't move the row. */ UPDATE x SET x = 'aaa', x = NULL;
/* row is moved to another partition. */ UPDATE x SET x = 'aaaa', x = NULL;
/* row is moved to another partition. This differs from the previous case in */ /* that the new partition is excluded by constraint exclusion, so its */ /* ResultRelInfo is not created at ExecInitModifyTable, but needs to be */ /* constructed on the fly when the updated tuple is routed to it. */ UPDATE x SET x = 'aaaa', x = NULL WHERE x = 'aaa';
SET SESSION AUTHORIZATION regress_priv_user1;
DROP TABLE x;
/* test column-level privileges when involved with DELETE */ SET SESSION AUTHORIZATION regress_priv_user1;
ALTER TABLE x ADD COLUMN x INT;
GRANT DELETE ON x TO x;
GRANT SELECT(x) ON x TO x;
REVOKE ALL (one) ON atest5 FROM regress_priv_user3;
GRANT SELECT(x) ON x TO x;
SET SESSION AUTHORIZATION regress_priv_user4;
SELECT x FROM x;
/* fail */ SELECT x FROM x NATURAL JOIN x;
/* fail */ SET SESSION AUTHORIZATION regress_priv_user1;
ALTER TABLE x DROP COLUMN x;
SET SESSION AUTHORIZATION regress_priv_user4;
SELECT x FROM x;
/* ok */ SELECT x FROM x NATURAL JOIN x;
/* ok */ SET SESSION AUTHORIZATION regress_priv_user1;
ALTER TABLE x DROP COLUMN x;
REVOKE SELECT (one,blue) ON atest6 FROM regress_priv_user4;
SET SESSION AUTHORIZATION regress_priv_user4;
SELECT * FROM x;
/* fail */ SELECT 1 FROM x;
/* fail */ SET SESSION AUTHORIZATION regress_priv_user3;
DELETE FROM x WHERE x = 1;
/* fail */ DELETE FROM x WHERE x = 2;
/* ok */ /* check inheritance cases */ SET SESSION AUTHORIZATION regress_priv_user1;
CREATE TABLE x (x INT, x INT);
CREATE TABLE x (x INT, x INT);
CREATE TABLE x (x INT) INHERITS (x, x);
GRANT SELECT(x, x, x) ON x TO x;
GRANT SELECT(x) ON x TO x;
SET SESSION AUTHORIZATION regress_priv_user2;
SELECT x FROM x;
/* ok */ SELECT x FROM x;
/* ok */ SELECT x FROM x;
/* ok */ SELECT x FROM x;
/* ok */ SELECT x FROM x;
/* fail */ SET SESSION AUTHORIZATION regress_priv_user1;
GRANT SELECT(x, x) ON x TO x;
SET SESSION AUTHORIZATION regress_priv_user2;
SELECT x FROM x;
/* still ok */ SELECT x FROM x;
/* ok */ SELECT x FROM x;
/* ok */ SELECT x FROM x;
/* ok */ /* child's permissions do not apply when operating on parent */ SET SESSION AUTHORIZATION regress_priv_user1;
REVOKE ALL ON atestc FROM regress_priv_user2;
GRANT ALL ON x TO x;
SET SESSION AUTHORIZATION regress_priv_user2;
SELECT x FROM x;
/* ok */ SELECT x FROM x;
/* fail */ DELETE FROM x;
/* ok */ DELETE FROM x;
/* fail */ UPDATE x SET x = 1;
/* ok */ UPDATE x SET x = 1;
TRUNCATE TABLE x /* fail */;
TRUNCATE TABLE x /* ok */;
/* fail */ BEGIN;
COMMIT;
BEGIN;
COMMIT;
GRANT USAGE ON LANGUAGE sql TO regress_priv_user1;
/* ok */ GRANT USAGE ON LANGUAGE c TO PUBLIC;
/* fail */ SET SESSION AUTHORIZATION regress_priv_user1;
GRANT USAGE ON LANGUAGE sql TO regress_priv_user2;
CREATE AGGREGATE priv_testagg1(int) (sfunc = int4pl, stype = int4);
REVOKE ALL ON FUNCTION priv_testfunc1(int), priv_testfunc2(int), priv_testagg1(int) FROM PUBLIC;
GRANT EXECUTE ON FUNCTION priv_testfunc1(int), priv_testfunc2(int), priv_testagg1(int) TO regress_priv_user2;
REVOKE ALL ON FUNCTION priv_testproc1(int) FROM PUBLIC;
/* fail, not a function */ REVOKE ALL ON PROCEDURE priv_testproc1(int) FROM PUBLIC;
GRANT EXECUTE ON PROCEDURE x TO x;
GRANT USAGE ON FUNCTION x TO x;
GRANT USAGE ON FUNCTION x TO x /* semantic error */;
GRANT USAGE ON PROCEDURE x TO x /* semantic error */;
GRANT ALL PRIVILEGES ON FUNCTION x TO x /* semantic error */;
GRANT ALL PRIVILEGES ON FUNCTION x TO x;
GRANT ALL PRIVILEGES ON FUNCTION x TO x;
GRANT ALL PRIVILEGES ON PROCEDURE x TO x;
GRANT EXECUTE ON FUNCTION x TO x;
SET SESSION AUTHORIZATION regress_priv_user2;
SELECT PRIV_TESTFUNC1(5), PRIV_TESTFUNC2(5);
/* fail */ SELECT PRIV_TESTAGG1(x) FROM (VALUES (1), (2), (3)) AS x;
/* ok */ CALL priv_testproc1(6);
/* ok */ SET SESSION AUTHORIZATION regress_priv_user3;
SELECT PRIV_TESTFUNC1(5);
/* fail */ SELECT PRIV_TESTAGG1(x) FROM (VALUES (1), (2), (3)) AS x;
/* fail */ CALL priv_testproc1(6);
/* fail */ SELECT x FROM x WHERE x = TRUE;
/* fail */ SELECT PRIV_TESTFUNC4(TRUE);
/* ok */ SET SESSION AUTHORIZATION regress_priv_user4;
SELECT PRIV_TESTFUNC1(5);
/* ok */ SELECT PRIV_TESTAGG1(x) FROM (VALUES (1), (2), (3)) AS x;
/* ok */ CALL priv_testproc1(6);
/* ok */ DROP FUNCTION x (INT);
/* fail */ DROP AGGREGATE priv_testagg1(int);
/* fail */ DROP PROCEDURE x (INT);
/* ok */ /* restore to sanity */ GRANT ALL PRIVILEGES ON LANGUAGE sql TO PUBLIC;
/* verify privilege checks on array-element coercions */ BEGIN;
SELECT CAST(CAST('{1}' AS ARRAY<INT>) AS ARRAY<BIGINT>);
REVOKE ALL ON FUNCTION int8(integer) FROM PUBLIC;
SELECT CAST(CAST('{1}' AS ARRAY<INT>) AS ARRAY<BIGINT>);
/* superuser, succeed */ SET SESSION AUTHORIZATION regress_priv_user4;
SELECT CAST(CAST('{1}' AS ARRAY<INT>) AS ARRAY<BIGINT>);
ROLLBACK /* other user, fail */ /* other user, fail */;
REVOKE USAGE ON TYPE priv_testtype1 FROM PUBLIC;
GRANT USAGE ON TYPE priv_testtype1 TO regress_priv_user2;
GRANT USAGE ON TYPE _priv_testtype1 TO regress_priv_user2;
/* fail */ GRANT USAGE ON DOMAIN priv_testtype1 TO regress_priv_user2;
/* fail */ CREATE DOMAIN priv_testdomain1 AS int;
REVOKE USAGE on DOMAIN priv_testdomain1 FROM PUBLIC;
GRANT USAGE ON DOMAIN priv_testdomain1 TO regress_priv_user2;
GRANT USAGE ON TYPE priv_testdomain1 TO regress_priv_user2;
/* ok */ SET SESSION AUTHORIZATION regress_priv_user1;
/* commands that should fail */ CREATE AGGREGATE priv_testagg1a(priv_testdomain1) (sfunc = int4_sum, stype = bigint);
CREATE DOMAIN priv_testdomain2a AS priv_testdomain1;
CREATE DOMAIN priv_testdomain3a AS int;
CREATE FUNCTION x(x) RETURNS priv_testdomain3a LANGUAGE SQL AS $$ SELECT $1::priv_testdomain3a $$;
CREATE CAST (priv_testdomain1 AS priv_testdomain3a) WITH FUNCTION castfunc(int);
DROP FUNCTION x (INT) CASCADE;
DROP DOMAIN priv_testdomain3a;
CREATE FUNCTION x(x priv_testdomain1) RETURNS INT LANGUAGE SQL AS $$ SELECT $1 $$;
CREATE FUNCTION x(x INT) RETURNS priv_testdomain1 LANGUAGE SQL AS $$ SELECT $1::priv_testdomain1 $$;
CREATE OPERATOR !+! (PROCEDURE = int4pl, LEFTARG = priv_testdomain1, RIGHTARG = priv_testdomain1);
CREATE TABLE x (x INT, x priv_testdomain1);
CREATE TABLE test6a OF priv_testtype1;
CREATE TABLE x (x ARRAY<INT>, x ARRAY<priv_testtype1>);
CREATE TABLE x (x INT, x INT);
ALTER TABLE x ADD COLUMN x priv_testdomain1;
ALTER TABLE x ALTER COLUMN x SET DATA TYPE priv_testdomain1;
CREATE TYPE test7a AS (a int, b priv_testdomain1);
CREATE TYPE test8a AS (a int, b int);
ALTER TYPE test8a ADD ATTRIBUTE c priv_testdomain1;
ALTER TYPE test8a ALTER ATTRIBUTE b TYPE priv_testdomain1;
CREATE TABLE x AS (SELECT CAST(1 AS priv_testdomain1) AS x);
REVOKE ALL ON TYPE priv_testtype1 FROM PUBLIC;
SET SESSION AUTHORIZATION regress_priv_user2;
/* commands that should succeed */ CREATE AGGREGATE priv_testagg1b(priv_testdomain1) (sfunc = int4_sum, stype = bigint);
CREATE DOMAIN priv_testdomain2b AS priv_testdomain1;
CREATE DOMAIN priv_testdomain3b AS int;
CREATE FUNCTION x(x) RETURNS priv_testdomain3b LANGUAGE SQL AS $$ SELECT $1::priv_testdomain3b $$;
CREATE CAST (priv_testdomain1 AS priv_testdomain3b) WITH FUNCTION castfunc(int);
CREATE FUNCTION x(x priv_testdomain1) RETURNS INT LANGUAGE SQL AS $$ SELECT $1 $$;
CREATE FUNCTION x(x INT) RETURNS priv_testdomain1 LANGUAGE SQL AS $$ SELECT $1::priv_testdomain1 $$;
CREATE OPERATOR !! (PROCEDURE = priv_testfunc5b, RIGHTARG = priv_testdomain1);
CREATE TABLE x (x INT, x priv_testdomain1);
CREATE TABLE test6b OF priv_testtype1;
CREATE TABLE x (x ARRAY<INT>, x ARRAY<priv_testtype1>);
CREATE TABLE x (x INT, x INT);
ALTER TABLE x ADD COLUMN x priv_testdomain1;
ALTER TABLE x ALTER COLUMN x SET DATA TYPE priv_testdomain1;
CREATE TYPE test7b AS (a int, b priv_testdomain1);
CREATE TYPE test8b AS (a int, b int);
ALTER TYPE test8b ADD ATTRIBUTE c priv_testdomain1;
ALTER TYPE test8b ALTER ATTRIBUTE b TYPE priv_testdomain1;
CREATE TABLE x AS (SELECT CAST(1 AS priv_testdomain1) AS x);
REVOKE ALL ON TYPE priv_testtype1 FROM PUBLIC;
DROP DOMAIN priv_testdomain2b;
DROP OPERATOR !! (NONE, priv_testdomain1);
DROP TABLE x;
DROP TABLE x;
DROP TABLE x;
DROP TABLE x;
DROP TYPE test7b;
DROP TYPE test8b;
DROP CAST (priv_testdomain1 AS priv_testdomain3b);
DROP FUNCTION x (INT) CASCADE;
DROP DOMAIN priv_testdomain3b;
DROP TABLE x;
DROP TYPE priv_testtype1;
/* ok */ DROP DOMAIN priv_testdomain1;
/* ok */ /* truncate */ SET SESSION AUTHORIZATION regress_priv_user5;
TRUNCATE TABLE x;
TRUNCATE TABLE x /* ok */;
/* fail */ /* has_table_privilege function */ /* bad-input checks */ SELECT HAS_TABLE_PRIVILEGE(NULL, 'pg_authid', 'select');
SELECT HAS_TABLE_PRIVILEGE('pg_shad', 'select');
SELECT HAS_TABLE_PRIVILEGE('nosuchuser', 'pg_authid', 'select');
SELECT HAS_TABLE_PRIVILEGE('pg_authid', 'sel');
SELECT HAS_TABLE_PRIVILEGE(-999999, 'pg_authid', 'update');
SELECT HAS_TABLE_PRIVILEGE(1, 'select');
SELECT HAS_TABLE_PRIVILEGE(CURRENT_USER(), 'pg_authid', 'insert');
SELECT HAS_TABLE_PRIVILEGE(x.x, 'pg_authid', 'update') FROM (SELECT x FROM x WHERE x = CURRENT_USER()) AS x;
SELECT HAS_TABLE_PRIVILEGE(x.x, 'pg_authid', 'delete') FROM (SELECT x FROM x WHERE x = CURRENT_USER()) AS x;
SELECT HAS_TABLE_PRIVILEGE(CURRENT_USER(), x.x, 'references') FROM (SELECT x FROM x WHERE x = 'pg_authid') AS x;
SELECT HAS_TABLE_PRIVILEGE(x.x, x.x, 'select') FROM (SELECT x FROM x WHERE x = 'pg_authid') AS x, (SELECT x FROM x WHERE x = CURRENT_USER()) AS x;
SELECT HAS_TABLE_PRIVILEGE(x.x, x.x, 'insert') FROM (SELECT x FROM x WHERE x = 'pg_authid') AS x, (SELECT x FROM x WHERE x = CURRENT_USER()) AS x;
SELECT HAS_TABLE_PRIVILEGE('pg_authid', 'update');
SELECT HAS_TABLE_PRIVILEGE('pg_authid', 'delete');
SELECT HAS_TABLE_PRIVILEGE('pg_authid', 'truncate');
SELECT HAS_TABLE_PRIVILEGE(x.x, 'select') FROM (SELECT x FROM x WHERE x = 'pg_authid') AS x;
SELECT HAS_TABLE_PRIVILEGE(x.x, 'trigger') FROM (SELECT x FROM x WHERE x = 'pg_authid') AS x;
/* non-superuser */ SET SESSION AUTHORIZATION regress_priv_user3;
SELECT HAS_TABLE_PRIVILEGE(CURRENT_USER(), 'pg_class', 'select');
SELECT HAS_TABLE_PRIVILEGE(CURRENT_USER(), 'pg_class', 'insert');
SELECT HAS_TABLE_PRIVILEGE(x.x, 'pg_class', 'update') FROM (SELECT x FROM x WHERE x = CURRENT_USER()) AS x;
SELECT HAS_TABLE_PRIVILEGE(x.x, 'pg_class', 'delete') FROM (SELECT x FROM x WHERE x = CURRENT_USER()) AS x;
SELECT HAS_TABLE_PRIVILEGE(CURRENT_USER(), x.x, 'references') FROM (SELECT x FROM x WHERE x = 'pg_class') AS x;
SELECT HAS_TABLE_PRIVILEGE(x.x, x.x, 'select') FROM (SELECT x FROM x WHERE x = 'pg_class') AS x, (SELECT x FROM x WHERE x = CURRENT_USER()) AS x;
SELECT HAS_TABLE_PRIVILEGE(x.x, x.x, 'insert') FROM (SELECT x FROM x WHERE x = 'pg_class') AS x, (SELECT x FROM x WHERE x = CURRENT_USER()) AS x;
SELECT HAS_TABLE_PRIVILEGE('pg_class', 'update');
SELECT HAS_TABLE_PRIVILEGE('pg_class', 'delete');
SELECT HAS_TABLE_PRIVILEGE('pg_class', 'truncate');
SELECT HAS_TABLE_PRIVILEGE(x.x, 'select') FROM (SELECT x FROM x WHERE x = 'pg_class') AS x;
SELECT HAS_TABLE_PRIVILEGE(x.x, 'trigger') FROM (SELECT x FROM x WHERE x = 'pg_class') AS x;
SELECT HAS_TABLE_PRIVILEGE(CURRENT_USER(), 'atest1', 'select');
SELECT HAS_TABLE_PRIVILEGE(CURRENT_USER(), 'atest1', 'insert');
SELECT HAS_TABLE_PRIVILEGE(x.x, 'atest1', 'update') FROM (SELECT x FROM x WHERE x = CURRENT_USER()) AS x;
SELECT HAS_TABLE_PRIVILEGE(x.x, 'atest1', 'delete') FROM (SELECT x FROM x WHERE x = CURRENT_USER()) AS x;
SELECT HAS_TABLE_PRIVILEGE(CURRENT_USER(), x.x, 'references') FROM (SELECT x FROM x WHERE x = 'atest1') AS x;
SELECT HAS_TABLE_PRIVILEGE(x.x, x.x, 'select') FROM (SELECT x FROM x WHERE x = 'atest1') AS x, (SELECT x FROM x WHERE x = CURRENT_USER()) AS x;
SELECT HAS_TABLE_PRIVILEGE(x.x, x.x, 'insert') FROM (SELECT x FROM x WHERE x = 'atest1') AS x, (SELECT x FROM x WHERE x = CURRENT_USER()) AS x;
SELECT HAS_TABLE_PRIVILEGE('atest1', 'update');
SELECT HAS_TABLE_PRIVILEGE('atest1', 'delete');
SELECT HAS_TABLE_PRIVILEGE('atest1', 'truncate');
SELECT HAS_TABLE_PRIVILEGE(x.x, 'select') FROM (SELECT x FROM x WHERE x = 'atest1') AS x;
SELECT HAS_TABLE_PRIVILEGE(x.x, 'trigger') FROM (SELECT x FROM x WHERE x = 'atest1') AS x;
/* has_column_privilege function */ /* bad-input checks (as non-super-user) */ SELECT HAS_COLUMN_PRIVILEGE('pg_authid', NULL, 'select');
SELECT HAS_COLUMN_PRIVILEGE('pg_authid', 'nosuchcol', 'select');
SELECT HAS_COLUMN_PRIVILEGE(9999, 'nosuchcol', 'select');
SELECT HAS_COLUMN_PRIVILEGE(9999, CAST(99 AS SMALLINT), 'select');
SELECT HAS_COLUMN_PRIVILEGE('pg_authid', CAST(99 AS SMALLINT), 'select');
SELECT HAS_COLUMN_PRIVILEGE(9999, CAST(99 AS SMALLINT), 'select');
CREATE TEMPORARY TABLE x (x INT, x INT, x INT);
ALTER TABLE x DROP COLUMN x;
SELECT HAS_COLUMN_PRIVILEGE('mytable', 'f2', 'select');
SELECT HAS_COLUMN_PRIVILEGE('mytable', '........pg.dropped.2........', 'select');
SELECT HAS_COLUMN_PRIVILEGE('mytable', CAST(2 AS SMALLINT), 'select');
SELECT HAS_COLUMN_PRIVILEGE('mytable', CAST(99 AS SMALLINT), 'select');
REVOKE select on table mytable from regress_priv_user3;
SELECT HAS_COLUMN_PRIVILEGE('mytable', CAST(2 AS SMALLINT), 'select');
SELECT HAS_COLUMN_PRIVILEGE('mytable', CAST(99 AS SMALLINT), 'select');
DROP TABLE x;
/* Grant options */ SET SESSION AUTHORIZATION regress_priv_user1;
CREATE TABLE x (x INT);
GRANT SELECT ON x TO x WITH GRANT OPTION;
GRANT UPDATE ON x TO x;
GRANT SELECT ON x TO GROUP x WITH GRANT OPTION;
SET SESSION AUTHORIZATION regress_priv_user2;
GRANT SELECT ON x TO x;
GRANT UPDATE ON x TO x;
/* fail */ SET SESSION AUTHORIZATION regress_priv_user1;
REVOKE SELECT ON atest4 FROM regress_priv_user3;
/* does nothing */ SELECT HAS_TABLE_PRIVILEGE('regress_priv_user3', 'atest4', 'SELECT');
/* true */ REVOKE SELECT ON atest4 FROM regress_priv_user2;
/* fail */ REVOKE GRANT OPTION FOR SELECT ON atest4 FROM regress_priv_user2 CASCADE;
/* ok */ SELECT HAS_TABLE_PRIVILEGE('regress_priv_user2', 'atest4', 'SELECT');
/* true */ SELECT HAS_TABLE_PRIVILEGE('regress_priv_user3', 'atest4', 'SELECT');
/* false */ SELECT HAS_TABLE_PRIVILEGE('regress_priv_user1', 'atest4', 'SELECT WITH GRANT OPTION');
x AS @1;
COMMIT;
/* Create a table owned by regress_sro_user */ CREATE TABLE x (x INT);
ALTER TABLE sro_tab OWNER TO regress_sro_user;
INSERT INTO x VALUES (1), (2), (3);
/* Create an expression index with a predicate */ CREATE INDEX x ON x((SRO_IFUN(x) + SRO_IFUN(0)) NULLS LAST) WHERE SRO_IFUN(x + 10) > SRO_IFUN(10);
DROP INDEX x;
/* Do the same concurrently */ CREATE INDEX CONCURRENTLY x ON x((SRO_IFUN(x) + SRO_IFUN(0)) NULLS LAST) WHERE SRO_IFUN(x + 10) > SRO_IFUN(10);
/* REINDEX */ REINDEX TABLE sro_tab;
REINDEX INDEX sro_idx;
REINDEX TABLE CONCURRENTLY sro_tab;
DROP INDEX x;
/* CLUSTER */ CREATE INDEX x ON x((SRO_IFUN(x) + SRO_IFUN(0)) NULLS LAST);
DROP INDEX x;
/* BRIN index */ CREATE INDEX x ON x USING brin((SRO_IFUN(x) + SRO_IFUN(0)) NULLS LAST);
SELECT BRIN_DESUMMARIZE_RANGE('sro_brin', 0);
SELECT BRIN_SUMMARIZE_RANGE('sro_brin', 0);
DROP TABLE x;
/* Check with a partitioned table */ CREATE TABLE x (x INT) WITH (PARTITIONED_BY=RANGE(x));
ALTER TABLE sro_ptab OWNER TO regress_sro_user;
CREATE TABLE x PARTITION OF x FOR VALUES FROM (1) TO (10);
ALTER TABLE sro_part OWNER TO regress_sro_user;
INSERT INTO x VALUES (1), (2), (3);
CREATE INDEX x ON x((SRO_IFUN(x) + SRO_IFUN(0)) NULLS LAST) WHERE SRO_IFUN(x + 10) > SRO_IFUN(10);
REINDEX TABLE sro_ptab;
REINDEX INDEX CONCURRENTLY sro_pidx;
SET SESSION AUTHORIZATION regress_sro_user;
CREATE FUNCTION x() RETURNS void LANGUAGE sql AS 'GRANT regress_priv_group2 TO regress_sro_user';
/* REFRESH of this MV will queue a GRANT at end of transaction */ CREATE MATERIALIZED VIEW sro_mv AS SELECT mv_action() WITH NO DATA;
REFRESH MATERIALIZED VIEW sro_mv;
SET SESSION AUTHORIZATION regress_sro_user;
/* INSERT to this table will queue a GRANT at end of transaction */ CREATE TABLE x;
x AS x;
CREATE CONSTRAINT TRIGGER t AFTER INSERT ON sro_trojan_table     INITIALLY DEFERRED FOR EACH ROW EXECUTE PROCEDURE sro_trojan();
REFRESH MATERIALIZED VIEW sro_mv;
BEGIN;
SET CONSTRAINTS ALL IMMEDIATE;
REFRESH MATERIALIZED VIEW sro_mv;
COMMIT;
/* REFRESH MATERIALIZED VIEW CONCURRENTLY use of eval_const_expressions() */ SET SESSION AUTHORIZATION regress_sro_user;
x;
CREATE MATERIALIZED VIEW x AS SELECT 1 AS x;
CREATE UNIQUE INDEX ON x(x NULLS LAST) WHERE UNWANTED_GRANT_NOFAIL(1) > 0;
REFRESH MATERIALIZED VIEW sro_index_mv;
DROP OWNED BY regress_sro_user;
DROP ROLE regress_sro_user;
/* Admin options */ SET SESSION AUTHORIZATION regress_priv_user4;
CREATE FUNCTION x() RETURNS void LANGUAGE sql SECURITY DEFINER AS 'GRANT regress_priv_group2 TO regress_priv_user5';
GRANT regress_priv_group2 TO regress_priv_user5;
/* ok: had ADMIN OPTION */ SET ROLE regress_priv_group2;
GRANT regress_priv_group2 TO regress_priv_user5;
/* fails: SET ROLE suspended privilege */ SET SESSION AUTHORIZATION regress_priv_user1;
GRANT regress_priv_group2 TO regress_priv_user5;
/* fails: no ADMIN OPTION */ SELECT DOGRANT_OK();
/* ok: SECURITY DEFINER conveys ADMIN */ SET ROLE regress_priv_group2;
GRANT regress_priv_group2 TO regress_priv_user5;
/* fails: SET ROLE did not help */ SET SESSION AUTHORIZATION regress_priv_group2;
GRANT regress_priv_group2 TO regress_priv_user5;
/* fails: no self-admin */ SET SESSION AUTHORIZATION regress_priv_user4;
DROP FUNCTION x;
REVOKE regress_priv_group2 FROM regress_priv_user5;
GRANT USAGE ON x TO x;
SELECT HAS_SEQUENCE_PRIVILEGE('regress_priv_user1', 'atest1', 'SELECT');
SELECT HAS_SEQUENCE_PRIVILEGE('regress_priv_user1', 'x_seq', 'INSERT');
SELECT HAS_SEQUENCE_PRIVILEGE('regress_priv_user1', 'x_seq', 'SELECT');
SET SESSION AUTHORIZATION regress_priv_user2;
SELECT HAS_SEQUENCE_PRIVILEGE('x_seq', 'USAGE');
SELECT LO_CREATE(1001);
SELECT LO_CREATE(1002);
SELECT LO_CREATE(1003);
SELECT LO_CREATE(1004);
SELECT LO_CREATE(1005);
GRANT ALL ON LARGE OBJECT 1001 TO PUBLIC;
GRANT SELECT ON LARGE OBJECT 1003 TO regress_priv_user2;
GRANT SELECT,UPDATE ON LARGE OBJECT 1004 TO regress_priv_user2;
GRANT ALL ON LARGE OBJECT 1005 TO regress_priv_user2;
GRANT SELECT ON LARGE OBJECT 1005 TO regress_priv_user2 WITH GRANT OPTION;
GRANT SELECT, INSERT ON LARGE OBJECT 1001 TO PUBLIC;
/* to be failed */ GRANT SELECT, UPDATE ON LARGE OBJECT 1001 TO nosuchuser;
/* to be failed */ GRANT SELECT, UPDATE ON LARGE OBJECT  999 TO PUBLIC;
SELECT LO_CREATE(2001);
SELECT LO_CREATE(2002);
SELECT LOREAD(LO_OPEN(1001, CAST(131072 AS INT)), 32);
/* allowed, for now */ SELECT LOWRITE(LO_OPEN(1001, CAST(262144 AS INT)), 'abcd');
/* fail, wrong mode */ SELECT LOREAD(LO_OPEN(1001, CAST(262144 AS INT)), 32);
SELECT LOREAD(LO_OPEN(1002, CAST(262144 AS INT)), 32);
/* to be denied */ SELECT LOREAD(LO_OPEN(1003, CAST(262144 AS INT)), 32);
SELECT LOREAD(LO_OPEN(1004, CAST(262144 AS INT)), 32);
SELECT LOWRITE(LO_OPEN(1001, CAST(131072 AS INT)), 'abcd');
SELECT LOWRITE(LO_OPEN(1002, CAST(131072 AS INT)), 'abcd');
/* to be denied */ SELECT LOWRITE(LO_OPEN(1003, CAST(131072 AS INT)), 'abcd');
/* to be denied */ SELECT LOWRITE(LO_OPEN(1004, CAST(131072 AS INT)), 'abcd');
GRANT SELECT ON LARGE OBJECT 1005 TO regress_priv_user3;
GRANT UPDATE ON LARGE OBJECT 1006 TO regress_priv_user3;
/* to be denied */ REVOKE ALL ON LARGE OBJECT 2001, 2002 FROM PUBLIC;
GRANT ALL ON LARGE OBJECT 2001 TO regress_priv_user3;
SELECT LO_UNLINK(1001);
/* to be denied */ SELECT LO_UNLINK(2002);
SET SESSION AUTHORIZATION regress_priv_user3;
SELECT LOREAD(LO_OPEN(1001, CAST(262144 AS INT)), 32);
SELECT LOREAD(LO_OPEN(1003, CAST(262144 AS INT)), 32);
/* to be denied */ SELECT LOREAD(LO_OPEN(1005, CAST(262144 AS INT)), 32);
SELECT LO_TRUNCATE(LO_OPEN(1005, CAST(131072 AS INT)), 10);
/* to be denied */ SELECT LO_TRUNCATE(LO_OPEN(2001, CAST(131072 AS INT)), 10);
SELECT HAS_LARGEOBJECT_PRIVILEGE(1002, 'SELECT');
SELECT HAS_LARGEOBJECT_PRIVILEGE(1003, 'SELECT');
SELECT HAS_LARGEOBJECT_PRIVILEGE(1004, 'SELECT');
SELECT HAS_LARGEOBJECT_PRIVILEGE(1001, 'UPDATE');
SELECT HAS_LARGEOBJECT_PRIVILEGE(1002, 'UPDATE');
SELECT HAS_LARGEOBJECT_PRIVILEGE(1003, 'UPDATE');
SELECT HAS_LARGEOBJECT_PRIVILEGE(1004, 'UPDATE');
/* not-existing large object */ SELECT HAS_LARGEOBJECT_PRIVILEGE(9999, 'SELECT');
/* NULL */ /* non-superuser */ SET SESSION AUTHORIZATION regress_priv_user2;
SELECT HAS_LARGEOBJECT_PRIVILEGE(1001, 'SELECT');
SELECT HAS_LARGEOBJECT_PRIVILEGE(1002, 'SELECT');
/* false */ SELECT HAS_LARGEOBJECT_PRIVILEGE(1003, 'SELECT');
SELECT HAS_LARGEOBJECT_PRIVILEGE(1004, 'SELECT');
SELECT HAS_LARGEOBJECT_PRIVILEGE(1001, 'UPDATE');
SELECT HAS_LARGEOBJECT_PRIVILEGE(1002, 'UPDATE');
/* false */ SELECT HAS_LARGEOBJECT_PRIVILEGE(1003, 'UPDATE');
/* false */ SELECT HAS_LARGEOBJECT_PRIVILEGE(1004, 'UPDATE');
SELECT HAS_LARGEOBJECT_PRIVILEGE('regress_priv_user3', 1001, 'SELECT');
SELECT HAS_LARGEOBJECT_PRIVILEGE('regress_priv_user3', 1003, 'SELECT');
/* false */ SELECT HAS_LARGEOBJECT_PRIVILEGE('regress_priv_user3', 1005, 'SELECT');
SELECT HAS_LARGEOBJECT_PRIVILEGE('regress_priv_user3', 1005, 'UPDATE');
/* false */ SELECT HAS_LARGEOBJECT_PRIVILEGE('regress_priv_user3', 2001, 'UPDATE');
/* default setting */ SET SESSION AUTHORIZATION regress_priv_user4;
SELECT HAS_LARGEOBJECT_PRIVILEGE(1002, 'SELECT');
/* false */ SELECT HAS_LARGEOBJECT_PRIVILEGE(1002, 'UPDATE');
/* false */ SELECT LOREAD(LO_OPEN(1002, CAST(262144 AS INT)), 32);
/* to be denied */ SELECT LOWRITE(LO_OPEN(1002, CAST(131072 AS INT)), 'abcd');
/* to be denied */ SELECT LO_TRUNCATE(LO_OPEN(1002, CAST(131072 AS INT)), 10);
/* to be denied */ SELECT LO_PUT(1002, 1, 'abcd');
/* to be denied */ SELECT LO_UNLINK(1002);
/* to be denied */ SELECT LO_EXPORT(1001, '/dev/null');
/* to be denied */ SELECT LO_IMPORT('/dev/null');
/* to be denied */ SELECT LO_IMPORT('/dev/null', 2003);
/* compatibility mode */ SET SESSION AUTHORIZATION regress_priv_user4;
SELECT HAS_LARGEOBJECT_PRIVILEGE(1002, 'SELECT');
/* true */ SELECT HAS_LARGEOBJECT_PRIVILEGE(1002, 'UPDATE');
/* true */ SELECT LOREAD(LO_OPEN(1002, CAST(262144 AS INT)), 32);
SELECT LOWRITE(LO_OPEN(1002, CAST(131072 AS INT)), 'abcd');
SELECT LO_TRUNCATE(LO_OPEN(1002, CAST(131072 AS INT)), 10);
SELECT LO_UNLINK(1002);
SELECT LO_EXPORT(1001, '/dev/null');
SET SESSION AUTHORIZATION regress_priv_user1;
SELECT * FROM x LIMIT 0;
/* to be denied */ /* pg_signal_backend can't signal superusers */ RESET SESSION AUTHORIZATION;
BEGIN;
x;
ALTER FUNCTION terminate_nothrow OWNER TO pg_signal_backend;
SELECT x FROM x WHERE CASE WHEN COALESCE(x, 10) = 10 THEN TERMINATE_NOTHROW(x) END;
ROLLBACK;
/* test pg_database_owner */ RESET SESSION AUTHORIZATION;
GRANT pg_database_owner TO regress_priv_user1;
GRANT regress_priv_user1 TO pg_database_owner;
CREATE TABLE x;
ALTER TABLE datdba_only OWNER TO pg_database_owner;
REVOKE DELETE ON datdba_only FROM pg_database_owner;
SELECT PG_HAS_ROLE('regress_priv_user1', 'pg_database_owner', 'USAGE') AS x, PG_HAS_ROLE('regress_priv_user1', 'pg_database_owner', 'MEMBER') AS x, PG_HAS_ROLE('regress_priv_user1', 'pg_database_owner', 'MEMBER WITH ADMIN OPTION') AS x;
BEGIN;
x;
SELECT PG_HAS_ROLE('regress_priv_user1', 'pg_database_owner', 'USAGE') AS x, PG_HAS_ROLE('regress_priv_user1', 'pg_database_owner', 'MEMBER') AS x, PG_HAS_ROLE('regress_priv_user1', 'pg_database_owner', 'MEMBER WITH ADMIN OPTION') AS x;
SET SESSION AUTHORIZATION regress_priv_user1;
x AS x;
DELETE FROM x;
ROLLBACK TO x;
SET SESSION AUTHORIZATION regress_priv_user2;
ROLLBACK;
GRANT ALL ON SCHEMA x TO x;
CREATE TABLE x.x (x INT);
SELECT HAS_TABLE_PRIVILEGE('regress_priv_user1', 'testns.acltest1', 'SELECT');
/* no */ SELECT HAS_TABLE_PRIVILEGE('regress_priv_user1', 'testns.acltest1', 'INSERT');
/* no */ /* placeholder for test with duplicated schema and role names */ ALTER DEFAULT PRIVILEGES IN SCHEMA testns,testns GRANT SELECT ON TABLES TO public,public;
SELECT HAS_TABLE_PRIVILEGE('regress_priv_user1', 'testns.acltest1', 'SELECT');
/* no */ SELECT HAS_TABLE_PRIVILEGE('regress_priv_user1', 'testns.acltest1', 'INSERT');
/* no */ DROP TABLE x.x;
CREATE TABLE x.x (x INT);
SELECT HAS_TABLE_PRIVILEGE('regress_priv_user1', 'testns.acltest1', 'SELECT');
/* yes */ SELECT HAS_TABLE_PRIVILEGE('regress_priv_user1', 'testns.acltest1', 'INSERT');
/* no */ ALTER DEFAULT PRIVILEGES IN SCHEMA testns GRANT INSERT ON TABLES TO regress_priv_user1;
DROP TABLE x.x;
CREATE TABLE x.x (x INT);
SELECT HAS_TABLE_PRIVILEGE('regress_priv_user1', 'testns.acltest1', 'SELECT');
/* yes */ SELECT HAS_TABLE_PRIVILEGE('regress_priv_user1', 'testns.acltest1', 'INSERT');
/* yes */ ALTER DEFAULT PRIVILEGES IN SCHEMA testns REVOKE INSERT ON TABLES FROM regress_priv_user1;
DROP TABLE x.x;
CREATE TABLE x.x (x INT);
SELECT HAS_TABLE_PRIVILEGE('regress_priv_user1', 'testns.acltest1', 'SELECT');
/* yes */ SELECT HAS_TABLE_PRIVILEGE('regress_priv_user1', 'testns.acltest1', 'INSERT');
/* no */ ALTER DEFAULT PRIVILEGES FOR ROLE regress_priv_user1 REVOKE EXECUTE ON FUNCTIONS FROM public;
ALTER DEFAULT PRIVILEGES IN SCHEMA testns GRANT USAGE ON SCHEMAS TO regress_priv_user2;
/* error */ /* Test makeaclitem() */ SELECT MAKEACLITEM(CAST('regress_priv_user1' AS REGROLE), CAST('regress_priv_user2' AS REGROLE), 'SELECT', TRUE);
/* single privilege */ SELECT MAKEACLITEM(CAST('regress_priv_user1' AS REGROLE), CAST('regress_priv_user2' AS REGROLE), 'SELECT, INSERT,  UPDATE , DELETE  ', FALSE);
/* multiple privileges */ SELECT MAKEACLITEM(CAST('regress_priv_user1' AS REGROLE), CAST('regress_priv_user2' AS REGROLE), 'SELECT, fake_privilege', FALSE);
/* error */ /* Test non-throwing aclitem I/O */ SELECT PG_INPUT_IS_VALID('regress_priv_user1=r/regress_priv_user2', 'aclitem');
SELECT PG_INPUT_IS_VALID('regress_priv_user1=r/', 'aclitem');
SELECT * FROM x;
SELECT PG_INPUT_IS_VALID('regress_priv_user1=r/regress_no_such_user', 'aclitem');
SELECT * FROM x;
SELECT PG_INPUT_IS_VALID('regress_priv_user1=rY', 'aclitem');
SELECT * FROM x;
/* Testing blanket default grants is very hazardous since it might change */ /* the privileges attached to objects created by concurrent regression tests. */ /* To avoid that, be sure to revoke the privileges again before committing. */ BEGIN;
ALTER DEFAULT PRIVILEGES GRANT USAGE ON SCHEMAS TO regress_priv_user2;
CREATE SCHEMA x.x;
SELECT HAS_SCHEMA_PRIVILEGE('regress_priv_user2', 'testns2', 'USAGE');
/* yes */ SELECT HAS_SCHEMA_PRIVILEGE('regress_priv_user6', 'testns2', 'USAGE');
/* yes */ SELECT HAS_SCHEMA_PRIVILEGE('regress_priv_user2', 'testns2', 'CREATE');
/* no */ ALTER DEFAULT PRIVILEGES REVOKE USAGE ON SCHEMAS FROM regress_priv_user2;
CREATE SCHEMA x.x;
SELECT HAS_SCHEMA_PRIVILEGE('regress_priv_user2', 'testns3', 'USAGE');
/* no */ SELECT HAS_SCHEMA_PRIVILEGE('regress_priv_user2', 'testns3', 'CREATE');
/* no */ ALTER DEFAULT PRIVILEGES GRANT ALL ON SCHEMAS TO regress_priv_user2;
CREATE SCHEMA x.x;
SELECT HAS_SCHEMA_PRIVILEGE('regress_priv_user2', 'testns4', 'USAGE');
/* yes */ SELECT HAS_SCHEMA_PRIVILEGE('regress_priv_user2', 'testns4', 'CREATE');
/* yes */ ALTER DEFAULT PRIVILEGES REVOKE ALL ON SCHEMAS FROM regress_priv_user2;
COMMIT;
/* Test for DROP OWNED BY with shared dependencies.  This is done in a */ /* separate, rollbacked, transaction to avoid any trouble with other */ /* regression sessions. */ BEGIN;
ALTER DEFAULT PRIVILEGES GRANT ALL ON FUNCTIONS TO regress_priv_user2;
ALTER DEFAULT PRIVILEGES GRANT ALL ON SCHEMAS TO regress_priv_user2;
ALTER DEFAULT PRIVILEGES GRANT ALL ON SEQUENCES TO regress_priv_user2;
ALTER DEFAULT PRIVILEGES GRANT ALL ON TABLES TO regress_priv_user2;
ALTER DEFAULT PRIVILEGES GRANT ALL ON TYPES TO regress_priv_user2;
SELECT COUNT(*) FROM x WHERE x = 'a' AND x = CAST('regress_priv_user2' AS REGROLE) AND x = CAST('pg_default_acl' AS REGCLASS);
DROP OWNED BY regress_priv_user2, regress_priv_user2;
SELECT COUNT(*) FROM x WHERE x = 'a' AND x = CAST('regress_priv_user2' AS REGROLE) AND x = CAST('pg_default_acl' AS REGCLASS);
ROLLBACK;
CREATE SCHEMA x.x;
SELECT HAS_SCHEMA_PRIVILEGE('regress_priv_user2', 'testns5', 'USAGE');
/* no */ SELECT HAS_SCHEMA_PRIVILEGE('regress_priv_user2', 'testns5', 'CREATE');
/* no */ SET ROLE regress_priv_user1;
CREATE FUNCTION x.x() RETURNS INT LANGUAGE sql AS 'select 1';
CREATE AGGREGATE testns.agg1(int) (sfunc = int4pl, stype = int4);
CREATE PROCEDURE x.x() LANGUAGE sql AS 'select 1';
SELECT HAS_FUNCTION_PRIVILEGE('regress_priv_user2', 'testns.foo()', 'EXECUTE');
/* no */ SELECT HAS_FUNCTION_PRIVILEGE('regress_priv_user2', 'testns.agg1(int)', 'EXECUTE');
/* no */ SELECT HAS_FUNCTION_PRIVILEGE('regress_priv_user2', 'testns.bar()', 'EXECUTE');
/* no */ ALTER DEFAULT PRIVILEGES IN SCHEMA testns GRANT EXECUTE ON ROUTINES to public;
DROP FUNCTION x.x;
CREATE FUNCTION x.x() RETURNS INT LANGUAGE sql AS 'select 1';
DROP AGGREGATE testns.agg1(int);
CREATE AGGREGATE testns.agg1(int) (sfunc = int4pl, stype = int4);
DROP PROCEDURE x.x;
CREATE PROCEDURE x.x() LANGUAGE sql AS 'select 1';
SELECT HAS_FUNCTION_PRIVILEGE('regress_priv_user2', 'testns.foo()', 'EXECUTE');
/* yes */ SELECT HAS_FUNCTION_PRIVILEGE('regress_priv_user2', 'testns.agg1(int)', 'EXECUTE');
/* yes */ SELECT HAS_FUNCTION_PRIVILEGE('regress_priv_user2', 'testns.bar()', 'EXECUTE');
/* yes (counts as function here) */ DROP FUNCTION x.x;
DROP AGGREGATE testns.agg1(int);
DROP PROCEDURE x.x;
ALTER DEFAULT PRIVILEGES FOR ROLE regress_priv_user1 REVOKE USAGE ON TYPES FROM public;
CREATE DOMAIN testns.priv_testdomain1 AS int;
SELECT HAS_TYPE_PRIVILEGE('regress_priv_user2', 'testns.priv_testdomain1', 'USAGE');
/* no */ ALTER DEFAULT PRIVILEGES IN SCHEMA testns GRANT USAGE ON TYPES to public;
DROP DOMAIN testns.priv_testdomain1;
CREATE DOMAIN testns.priv_testdomain1 AS int;
SELECT HAS_TYPE_PRIVILEGE('regress_priv_user2', 'testns.priv_testdomain1', 'USAGE');
/* yes */ DROP DOMAIN testns.priv_testdomain1;
RESET ROLE;
SELECT COUNT(*) FROM x AS x LEFT JOIN x AS x ON x = x.x WHERE x = 'testns';
DROP SCHEMA x.x CASCADE;
DROP SCHEMA x.x CASCADE;
DROP SCHEMA x.x CASCADE;
DROP SCHEMA x.x CASCADE;
DROP SCHEMA x.x CASCADE;
SELECT x.* /* check that entries went away */ FROM x AS x LEFT JOIN x AS x ON x = x.x WHERE x IS NULL AND x <> 0;
CREATE TABLE x.x (x INT);
CREATE TABLE x.x (x INT);
SELECT HAS_TABLE_PRIVILEGE('regress_priv_user1', 'testns.t1', 'SELECT');
/* false */ GRANT ALL ON ALL TABLES IN SCHEMA testns TO regress_priv_user1;
SELECT HAS_TABLE_PRIVILEGE('regress_priv_user1', 'testns.t1', 'SELECT');
/* true */ SELECT HAS_TABLE_PRIVILEGE('regress_priv_user1', 'testns.t2', 'SELECT');
/* true */ REVOKE ALL ON ALL TABLES IN SCHEMA testns FROM regress_priv_user1;
SELECT HAS_TABLE_PRIVILEGE('regress_priv_user1', 'testns.t1', 'SELECT');
/* false */ SELECT HAS_TABLE_PRIVILEGE('regress_priv_user1', 'testns.t2', 'SELECT');
CREATE AGGREGATE testns.priv_testagg(int) (sfunc = int4pl, stype = int4);
CREATE PROCEDURE x.x(x) LANGUAGE sql AS 'select 3';
SELECT HAS_FUNCTION_PRIVILEGE('regress_priv_user1', 'testns.priv_testfunc(int)', 'EXECUTE');
/* true by default */ SELECT HAS_FUNCTION_PRIVILEGE('regress_priv_user1', 'testns.priv_testagg(int)', 'EXECUTE');
/* true by default */ SELECT HAS_FUNCTION_PRIVILEGE('regress_priv_user1', 'testns.priv_testproc(int)', 'EXECUTE');
/* true by default */ REVOKE ALL ON ALL FUNCTIONS IN SCHEMA testns FROM PUBLIC;
SELECT HAS_FUNCTION_PRIVILEGE('regress_priv_user1', 'testns.priv_testfunc(int)', 'EXECUTE');
/* false */ SELECT HAS_FUNCTION_PRIVILEGE('regress_priv_user1', 'testns.priv_testagg(int)', 'EXECUTE');
/* false */ SELECT HAS_FUNCTION_PRIVILEGE('regress_priv_user1', 'testns.priv_testproc(int)', 'EXECUTE');
/* still true, not a function */ REVOKE ALL ON ALL PROCEDURES IN SCHEMA testns FROM PUBLIC;
SELECT HAS_FUNCTION_PRIVILEGE('regress_priv_user1', 'testns.priv_testproc(int)', 'EXECUTE');
/* now false */ GRANT ALL ON ALL ROUTINES IN SCHEMA testns TO PUBLIC;
SELECT HAS_FUNCTION_PRIVILEGE('regress_priv_user1', 'testns.priv_testfunc(int)', 'EXECUTE');
/* true */ SELECT HAS_FUNCTION_PRIVILEGE('regress_priv_user1', 'testns.priv_testagg(int)', 'EXECUTE');
/* true */ SELECT HAS_FUNCTION_PRIVILEGE('regress_priv_user1', 'testns.priv_testproc(int)', 'EXECUTE');
/* true */ DROP SCHEMA x.x CASCADE;
CREATE ROLE regress_schemauser2 superuser login;
SET SESSION ROLE regress_schemauser1;
CREATE SCHEMA x.x;
SELECT x, x FROM x, x WHERE x.x = 'testns' AND x.x = x.x;
ALTER SCHEMA testns OWNER TO regress_schemauser2;
ALTER ROLE regress_schemauser2 RENAME TO regress_schemauser_renamed;
SELECT x, x FROM x, x WHERE x.x = 'testns' AND x.x = x.x;
set session role regress_schemauser_renamed;
DROP SCHEMA x.x CASCADE;
DROP ROLE regress_schemauser_renamed;
CREATE TABLE x (x INT);
GRANT SELECT ON x TO x WITH GRANT OPTION;
GRANT SELECT ON x TO x WITH GRANT OPTION;
set session role regress_priv_user2;
GRANT SELECT ON x TO x WITH GRANT OPTION;
set session role regress_priv_user3;
GRANT SELECT ON x TO x WITH GRANT OPTION;
set session role regress_priv_user4;
GRANT SELECT ON x TO x;
REVOKE select on dep_priv_test from regress_priv_user4 cascade;
REVOKE select on dep_priv_test from regress_priv_user4 cascade;
DROP TABLE x;
DROP AGGREGATE priv_testagg1(int);
DROP FUNCTION x (INT);
DROP FUNCTION x (BOOLEAN);
DROP PROCEDURE x (INT);
DROP VIEW x;
DROP VIEW x;
DROP VIEW x;
/* this should cascade to drop atestv4 */ DROP VIEW x CASCADE;
/* this should complain "does not exist" */ DROP VIEW x;
DROP TABLE x;
DROP TABLE x;
DROP TABLE x;
DROP TABLE x;
DROP TABLE x;
DROP TABLE x;
DROP TABLE x;
DROP TABLE x;
DROP TABLE x;
SELECT LO_UNLINK(x) FROM x WHERE x >= 1000 AND x < 3000 ORDER BY x NULLS LAST;
DROP GROUP regress_priv_group1;
DROP GROUP regress_priv_group2;
/* these are needed to clean up permissions */ REVOKE USAGE ON LANGUAGE sql FROM regress_priv_user1;
DROP OWNED BY regress_priv_user1;
DROP USER regress_priv_user1;
DROP USER regress_priv_user2;
DROP USER regress_priv_user3;
DROP USER regress_priv_user4;
DROP USER regress_priv_user5;
DROP USER regress_priv_user6;
DROP USER regress_priv_user7;
DROP USER regress_priv_user8;
/* does not exist */ /* permissions with LOCK TABLE */ CREATE USER regress_locktable_user;
CREATE TABLE x (x INT);
GRANT SELECT ON x TO x /* LOCK TABLE and SELECT permission */;
SET SESSION AUTHORIZATION regress_locktable_user;
BEGIN;
COMMIT /* should pass */ /* should pass */;
BEGIN;
ROLLBACK /* should fail */ /* should fail */;
BEGIN;
ROLLBACK /* should fail */ /* should fail */;
GRANT INSERT ON x TO x /* LOCK TABLE and INSERT permission */;
SET SESSION AUTHORIZATION regress_locktable_user;
BEGIN;
ROLLBACK /* should pass */ /* should pass */;
BEGIN;
COMMIT /* should pass */ /* should pass */;
BEGIN;
ROLLBACK /* should fail */ /* should fail */;
GRANT UPDATE ON x TO x /* LOCK TABLE and UPDATE permission */;
SET SESSION AUTHORIZATION regress_locktable_user;
BEGIN;
ROLLBACK /* should pass */ /* should pass */;
BEGIN;
COMMIT /* should pass */ /* should pass */;
BEGIN;
COMMIT /* should pass */ /* should pass */;
GRANT DELETE ON x TO x /* LOCK TABLE and DELETE permission */;
SET SESSION AUTHORIZATION regress_locktable_user;
BEGIN;
ROLLBACK /* should pass */ /* should pass */;
BEGIN;
COMMIT /* should pass */ /* should pass */;
BEGIN;
COMMIT /* should pass */ /* should pass */;
GRANT TRUNCATE ON x TO x /* LOCK TABLE and TRUNCATE permission */;
SET SESSION AUTHORIZATION regress_locktable_user;
BEGIN;
ROLLBACK /* should pass */ /* should pass */;
BEGIN;
COMMIT /* should pass */ /* should pass */;
BEGIN;
COMMIT /* should pass */ /* should pass */;
GRANT MAINTAIN ON x TO x /* LOCK TABLE and MAINTAIN permission */;
SET SESSION AUTHORIZATION regress_locktable_user;
BEGIN;
ROLLBACK /* should pass */ /* should pass */;
BEGIN;
COMMIT /* should pass */ /* should pass */;
BEGIN;
COMMIT /* should pass */ /* should pass */;
/* clean up */ DROP TABLE x;
DROP USER regress_locktable_user;
SELECT HAS_TABLE_PRIVILEGE('regress_readallstats', 'pg_backend_memory_contexts', 'SELECT');
/* no */ SELECT HAS_TABLE_PRIVILEGE('regress_readallstats', 'pg_shmem_allocations', 'SELECT');
/* no */ GRANT pg_read_all_stats TO regress_readallstats;
SELECT HAS_TABLE_PRIVILEGE('regress_readallstats', 'pg_backend_memory_contexts', 'SELECT');
/* yes */ SELECT HAS_TABLE_PRIVILEGE('regress_readallstats', 'pg_shmem_allocations', 'SELECT');
/* yes */ /* run query to ensure that functions within views can be executed */ SET ROLE regress_readallstats;
SELECT COUNT(*) >= 0 AS x FROM x;
SELECT COUNT(*) >= 0 AS x FROM x;
RESET ROLE;
/* clean up */ DROP ROLE regress_readallstats;
/* test role grantor machinery */ CREATE ROLE regress_group;
CREATE ROLE regress_group_direct_manager;
CREATE ROLE regress_group_indirect_manager;
CREATE ROLE regress_group_member;
GRANT regress_group TO regress_group_direct_manager WITH INHERIT FALSE, ADMIN TRUE;
GRANT regress_group_direct_manager TO regress_group_indirect_manager;
SET SESSION AUTHORIZATION regress_group_direct_manager;
GRANT regress_group TO regress_group_member;
SELECT CAST(CAST(x AS REGROLE) AS TEXT), CASE WHEN x = 10 THEN 'BOOTSTRAP SUPERUSER' ELSE CAST(CAST(x AS REGROLE) AS TEXT) END FROM x WHERE x = CAST('regress_group' AS REGROLE) ORDER BY 1 NULLS LAST, 2 NULLS LAST;
REVOKE regress_group FROM regress_group_member;
SET SESSION AUTHORIZATION regress_group_indirect_manager;
GRANT regress_group TO regress_group_member;
SELECT CAST(CAST(x AS REGROLE) AS TEXT), CASE WHEN x = 10 THEN 'BOOTSTRAP SUPERUSER' ELSE CAST(CAST(x AS REGROLE) AS TEXT) END FROM x WHERE x = CAST('regress_group' AS REGROLE) ORDER BY 1 NULLS LAST, 2 NULLS LAST;
REVOKE regress_group FROM regress_group_member;
RESET SESSION AUTHORIZATION;
DROP ROLE regress_group;
DROP ROLE regress_group_direct_manager;
DROP ROLE regress_group_indirect_manager;
DROP ROLE regress_group_member;
/* test SET and INHERIT options with object ownership changes */ CREATE ROLE regress_roleoption_protagonist;
CREATE ROLE regress_roleoption_donor;
CREATE ROLE regress_roleoption_recipient;
CREATE SCHEMA x.x;
GRANT CREATE, USAGE ON SCHEMA x TO x;
GRANT regress_roleoption_donor TO regress_roleoption_protagonist WITH INHERIT TRUE, SET FALSE;
GRANT regress_roleoption_recipient TO regress_roleoption_protagonist WITH INHERIT FALSE, SET TRUE;
SET SESSION AUTHORIZATION regress_roleoption_protagonist;
CREATE TABLE x.x (x INT);
CREATE TABLE x.x (x INT);
SET SESSION AUTHORIZATION regress_roleoption_donor;
CREATE TABLE x.x (x INT);
SET SESSION AUTHORIZATION regress_roleoption_recipient;
CREATE TABLE x.x (x INT);
SET SESSION AUTHORIZATION regress_roleoption_protagonist;
ALTER TABLE regress_roleoption.t1 OWNER TO regress_roleoption_donor;
/* fails, can't be come donor */ ALTER TABLE regress_roleoption.t2 OWNER TO regress_roleoption_recipient;
/* works */ ALTER TABLE regress_roleoption.t3 OWNER TO regress_roleoption_protagonist;
/* works */ ALTER TABLE regress_roleoption.t4 OWNER TO regress_roleoption_protagonist;
/* fails, we don't inherit from recipient */ RESET SESSION AUTHORIZATION;
DROP TABLE x.x;
DROP TABLE x.x;
DROP TABLE x.x;
DROP TABLE x.x;
DROP SCHEMA x.x;
DROP ROLE regress_roleoption_protagonist;
DROP ROLE regress_roleoption_donor;
DROP ROLE regress_roleoption_recipient;
/* MAINTAIN */ CREATE ROLE regress_no_maintain;
CREATE ROLE regress_maintain;
CREATE ROLE regress_maintain_all IN ROLE pg_maintain;
CREATE TABLE x (x INT);
CREATE INDEX ON x(x NULLS LAST);
GRANT MAINTAIN ON x TO x;
CREATE MATERIALIZED VIEW x AS SELECT 1;
GRANT MAINTAIN ON x TO x;
CREATE SCHEMA x.x;
VACUUM maintain_test;
ANALYZE x;
VACUUM (ANALYZE) maintain_test;
REFRESH MATERIALIZED VIEW refresh_test;
REINDEX TABLE maintain_test;
REINDEX INDEX maintain_test_a_idx;
REINDEX SCHEMA reindex_test;
RESET ROLE;
SET ROLE regress_maintain;
VACUUM maintain_test;
ANALYZE x;
VACUUM (ANALYZE) maintain_test;
REFRESH MATERIALIZED VIEW refresh_test;
REINDEX TABLE maintain_test;
REINDEX INDEX maintain_test_a_idx;
REINDEX SCHEMA reindex_test;
RESET ROLE;
SET ROLE regress_maintain_all;
VACUUM maintain_test;
ANALYZE x;
VACUUM (ANALYZE) maintain_test;
REFRESH MATERIALIZED VIEW refresh_test;
REINDEX TABLE maintain_test;
REINDEX INDEX maintain_test_a_idx;
REINDEX SCHEMA reindex_test;
RESET ROLE;
DROP TABLE x;
DROP MATERIALIZED VIEW x;
DROP SCHEMA x.x;
DROP ROLE regress_no_maintain;
DROP ROLE regress_maintain;
DROP ROLE regress_maintain_all;
/* grantor selection */ CREATE ROLE regress_grantor1;
CREATE ROLE regress_grantor2 ROLE regress_grantor1;
CREATE ROLE regress_grantor3;
CREATE TABLE x;
CREATE TABLE x;
CREATE TABLE x;
GRANT SELECT ON x TO x WITH GRANT OPTION;
GRANT SELECT, UPDATE ON x TO x WITH GRANT OPTION;
SET ROLE regress_grantor1;
GRANT SELECT, UPDATE ON x TO x;
GRANT SELECT, UPDATE ON x TO x;
GRANT SELECT, UPDATE ON x TO x;
RESET ROLE;
SELECT * FROM x.x AS x WHERE x LIKE 'regress_grantor%' ORDER BY ROW(x.*) NULLS LAST;
DROP ROLE regress_grantor1, regress_grantor2, regress_grantor3;
EXECUTE test \gdesc EXPLAIN EXECUTE test \gdesc  -- should fail cleanly - syntax error SELECT 1 + \gdesc  -- check behavior with empty results SELECT \gdesc CREATE TABLE bububu(a int) \gdesc  -- subject command should not have executed TABLE bububu;
BEGIN;
x;
/* \gexec */ CREATE TEMPORARY TABLE x (x INT, x TEXT, x DATE, x DOUBLE);
x AS x;
/* test single-line header and data */ PREPARE q as select repeat('x',2*n) as "0123456789abcdef", repeat('y',20-2*n) as "0123456789" from generate_series(1,10) as n;
x AS x;
CREATE ROLE regress_display_role;
ALTER SCHEMA tableam_display OWNER TO regress_display_role;
SET x = tableam_display;
CREATE ACCESS METHOD heap_psql TYPE TABLE HANDLER heap_tableam_handler;
SET x = regress_display_role;
/* Use only relations with a physical size of zero. */ CREATE TABLE x (x INT, x CHAR(100)) WITH (FORMAT=heap_psql);
CREATE TABLE x (x INT, x CHAR(100)) WITH (FORMAT=heap);
CREATE VIEW x AS SELECT x FROM x;
CREATE MATERIALIZED VIEW x WITH (FORMAT=heap_psql) AS SELECT x FROM x;
RESET search_path;
DROP SCHEMA x.x CASCADE;
DROP ACCESS METHOD heap_psql;
DROP ROLE regress_display_role;
x AS x;
x AS x;
SELECT '\.' AS x;
x AS x;
x AS x;
SELECT 'still okay';
/* test printing and clearing the query buffer */ SELECT 1;
SELECT 1 / (15 - x) FROM x ORDER BY x NULLS LAST LIMIT 19;
create role regress_partitioning_role;
alter schema testpart owner to regress_partitioning_role;
SET x = regress_partitioning_role;
SET x = testpart /* run test inside own schema and hide other partitions */;
CREATE TABLE x (x DATE);
CREATE TABLE x (x DATE);
CREATE INDEX x ON x(x NULLS LAST);
CREATE INDEX x ON x(x NULLS LAST);
CREATE TABLE x (x DATE) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x (x DATE) WITH (PARTITIONED_BY=RANGE(x));
CREATE INDEX x ON x(x NULLS LAST);
CREATE INDEX x ON x(x NULLS LAST);
DROP TABLE x;
DROP TABLE x;
DROP TABLE x;
CREATE TABLE x (x INT) WITH (PARTITIONED_BY=RANGE(x));
CREATE INDEX x ON x(x NULLS LAST);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (0) TO (10);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (10) TO (20);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (20) TO (30);
INSERT INTO x VALUES (UNNEST(GENERATE_SERIES(0, 29)));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (30) TO (40) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (30) TO (35);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (35) TO (40);
INSERT INTO x VALUES (UNNEST(GENERATE_SERIES(30, 39)));
DROP SCHEMA x.x;
SET x = default;
SET x = default;
drop role regress_partitioning_role;
BEGIN;
set session authorization regress_psql_user;
create function psql_df_internal (float8)   returns float8   language internal immutable parallel safe strict   as 'dsin';
CREATE FUNCTION x(x INT) RETURNS INT SECURITY DEFINER AS begin atomic select x + 1;
COMMIT;
COMMIT;
COMMENT ON function x() IS 'some comment';
drop role regress_psql_user;
COMMIT;
SELECT * FROM x;
COMMIT;
INSERT INTO x VALUES (2);
ROLLBACK;
SELECT * FROM x;
COMMIT;
BEGIN;
INSERT INTO x VALUES (3);
COMMIT;
SELECT * FROM x;
COMMIT;
BEGIN;
INSERT INTO x VALUES (4);
ROLLBACK;
SELECT * FROM x;
COMMIT;
SELECT * FROM x;
BEGIN;
INSERT INTO x VALUES (1);
INSERT INTO x VALUES ('foo');
INSERT INTO x VALUES (3);
COMMIT;
SELECT * FROM x;
BEGIN;
INSERT INTO x VALUES (4);
ROLLBACK;
SELECT * FROM x;
BEGIN;
INSERT INTO x VALUES (5);
COMMIT AND CHAIN;
INSERT INTO x VALUES (6);
COMMIT;
SELECT * FROM x;
DROP TABLE x;
x AS x;
SELECT 2 AS x;
SELECT 7;
/* with aborted transaction, stop on first error */ BEGIN \;
SELECT 10 AS x;
ROLLBACK /* close previously aborted transaction */ /* close previously aborted transaction */;
CREATE TABLE psql_comics(s TEXT) \;
TRUNCATE psql_comics \;
SELECT 'ok' AS "x";
SELECT 2 AS x;
SELECT x FROM x ORDER BY x NULLS LAST;
TRUNCATE TABLE x;
SELECT 3 AS x;
/* DML command status */ UPDATE x SET x = x WHERE FALSE;
SELECT x FROM x ORDER BY x NULLS LAST;
TRUNCATE TABLE x;
SELECT x FROM x ORDER BY x NULLS LAST;
TRUNCATE TABLE x;
COPY INTO (SELECT 'bar1') TO x;
SELECT x FROM x ORDER BY x NULLS LAST;
TRUNCATE TABLE x;
SELECT x FROM x ORDER BY x NULLS LAST;
DROP TABLE x;
ROLLBACK;
CREATE TABLE foo(s TEXT) \;
COMMIT;
ROLLBACK;
COMMIT;
CREATE TABLE foo(s TEXT) \;
COMMIT;
BEGIN \;
DROP TABLE x;
COMMIT;
CREATE TABLE x (x NO_SUCH_TYPE);
/* fails */ CREATE TABLE x (x TEXT);
/* succeeds */ SELECT PSQL_ERROR('oops!');
/* fails */ INSERT INTO x VALUES ('Calvin'), ('Hobbes');
COMMIT;
SELECT * FROM x ORDER BY 1 NULLS LAST;
BEGIN;
INSERT INTO x VALUES ('Susie');
/* failure */ SELECT 'after error' AS x;
/* will rollback */ SELECT PSQL_ERROR('bam!');
INSERT INTO x VALUES ('Miss Wormwood');
COMMIT /* succeeds */ /* succeeds */;
SELECT * FROM x ORDER BY 1 NULLS LAST;
/* succeeds */ SELECT PSQL_ERROR('bad!');
/* but be counted here */ SELECT PSQL_ERROR('bad!');
COMMIT /* implicit partial rollback */ /* implicit partial rollback */;
/* no mum here */ SELECT * FROM x ORDER BY 1 NULLS LAST;
COMMIT;
DROP FUNCTION x;
CREATE ROLE regress_du_role1;
CREATE ROLE regress_du_role2;
CREATE ROLE regress_du_admin;
GRANT regress_du_role0 TO regress_du_admin WITH ADMIN TRUE;
GRANT regress_du_role1 TO regress_du_admin WITH ADMIN TRUE;
GRANT regress_du_role2 TO regress_du_admin WITH ADMIN TRUE;
GRANT regress_du_role0 TO regress_du_role1 WITH ADMIN TRUE,  INHERIT TRUE,  SET TRUE  GRANTED BY regress_du_admin;
GRANT regress_du_role0 TO regress_du_role2 WITH ADMIN TRUE,  INHERIT FALSE, SET FALSE GRANTED BY regress_du_admin;
GRANT regress_du_role1 TO regress_du_role2 WITH ADMIN TRUE , INHERIT FALSE, SET TRUE  GRANTED BY regress_du_admin;
GRANT regress_du_role0 TO regress_du_role1 WITH ADMIN FALSE, INHERIT TRUE,  SET FALSE GRANTED BY regress_du_role1;
GRANT regress_du_role0 TO regress_du_role2 WITH ADMIN FALSE, INHERIT TRUE , SET TRUE  GRANTED BY regress_du_role1;
GRANT regress_du_role0 TO regress_du_role1 WITH ADMIN FALSE, INHERIT FALSE, SET TRUE  GRANTED BY regress_du_role2;
GRANT regress_du_role0 TO regress_du_role2 WITH ADMIN FALSE, INHERIT FALSE, SET FALSE GRANTED BY regress_du_role2;
DROP ROLE regress_du_role1;
DROP ROLE regress_du_role2;
DROP ROLE regress_du_admin;
/* Test display of empty privileges. */ BEGIN;
/* Create an owner for tested objects because output contains owner name. */ CREATE ROLE regress_zeropriv_owner;
SET LOCAL ROLE regress_zeropriv_owner;
CREATE DOMAIN regress_zeropriv_domain AS int;
REVOKE ALL ON DOMAIN regress_zeropriv_domain FROM CURRENT_USER, PUBLIC;
REVOKE ALL ON PROCEDURE regress_zeropriv_proc() FROM CURRENT_USER, PUBLIC;
REVOKE ALL ON TABLE regress_zeropriv_tbl FROM CURRENT_USER;
REVOKE ALL ON TYPE regress_zeropriv_type FROM CURRENT_USER, PUBLIC;
/* Test display of default privileges with \pset null. */ CREATE TABLE x (x INT);
/* \crosstabview */ CREATE TABLE x (x, x, x, x, x) AS VALUES ('v1', 'h2', 'foo', 3, CAST('2015-04-01' AS DATE)), ('v2', 'h1', 'bar', 3, '2015-01-02'), ('v1', 'h0', 'baz', NULL, '2015-07-12'), ('v0', 'h4', 'qux', 4, '2015-07-15'), ('v0', 'h4', 'dbl', -3, '2014-12-15'), ('v0', NULL, 'qux', 5, '2014-07-15'), ('v1', 'h2', 'quux', 7, '2015-04-04');
ANALYZE x /* make plans more stable */;
/* running \crosstabview after query uses query in buffer */ SELECT x, EXTRACT(YEAR FROM x), COUNT(*) FROM x GROUP BY 1, 2 ORDER BY 1 NULLS LAST, 2 NULLS LAST;
/* check error reporting (bug #14476) */ CREATE TABLE x (x INT, x INT, x TEXT);
INSERT INTO x SELECT 1, x, '*' || x FROM x AS x;
/* Tests using psql pipelining */ CREATE TABLE x (x INT PRIMARY KEY, x TEXT);
SELECT 1;
/* PUBLICATION */ CREATE ROLE regress_publication_user LOGIN SUPERUSER;
CREATE ROLE regress_publication_user2;
CREATE ROLE regress_publication_user_dummy LOGIN NOSUPERUSER;
SET SESSION AUTHORIZATION 'regress_publication_user';
SET x = 'ERROR' /* suppress warning that depends on wal_level */;
CREATE PUBLICATION testpub_default;
RESET client_min_messages;
COMMENT ON PUBLICATION testpub_default IS 'test publication';
SELECT OBJ_DESCRIPTION(x.x, 'pg_publication') FROM x AS x;
SET x = 'ERROR';
CREATE PUBLICATION testpub_ins_trunct WITH (publish = insert);
RESET client_min_messages;
ALTER PUBLICATION testpub_default SET (publish = update);
/* error cases */ CREATE PUBLICATION testpub_xxx WITH (foo);
CREATE PUBLICATION testpub_xxx WITH (publish = 'cluster, vacuum');
CREATE PUBLICATION testpub_xxx WITH (publish_via_partition_root = 'true', publish_via_partition_root = '0');
CREATE PUBLICATION testpub_xxx WITH (publish_generated_columns = stored, publish_generated_columns = none);
CREATE PUBLICATION testpub_xxx WITH (publish_generated_columns = foo);
CREATE TABLE x (x SERIAL PRIMARY KEY, x TEXT);
CREATE TABLE x.x (x INT, x INT);
CREATE VIEW x AS SELECT 1;
CREATE TABLE x (x INT) WITH (PARTITIONED_BY=LIST(x));
SET x = 'ERROR';
CREATE PUBLICATION testpub_foralltables FOR ALL TABLES WITH (publish = 'insert');
RESET client_min_messages;
ALTER PUBLICATION testpub_foralltables SET (publish = 'insert, update');
CREATE TABLE x (x SERIAL PRIMARY KEY, x TEXT);
/* fail - can't add to for all tables publication */ ALTER PUBLICATION testpub_foralltables ADD TABLE testpub_tbl2;
/* fail - can't drop from all tables publication */ ALTER PUBLICATION testpub_foralltables DROP TABLE testpub_tbl2;
/* fail - can't add to for all tables publication */ ALTER PUBLICATION testpub_foralltables SET TABLE pub_test.testpub_nopk;
/* fail - can't add schema to 'FOR ALL TABLES' publication */ ALTER PUBLICATION testpub_foralltables ADD TABLES IN SCHEMA pub_test;
/* fail - can't drop schema from 'FOR ALL TABLES' publication */ ALTER PUBLICATION testpub_foralltables DROP TABLES IN SCHEMA pub_test;
/* fail - can't set schema to 'FOR ALL TABLES' publication */ ALTER PUBLICATION testpub_foralltables SET TABLES IN SCHEMA pub_test;
SET x = 'ERROR';
CREATE PUBLICATION testpub_fortable FOR TABLE testpub_tbl1;
RESET client_min_messages;
/* should be able to add schema to 'FOR TABLE' publication */ ALTER PUBLICATION testpub_fortable ADD TABLES IN SCHEMA pub_test;
CREATE PUBLICATION testpub_forschema FOR TABLES IN SCHEMA pub_test;
/* should be able to create publication with schema and table of the same */ /* schema */ CREATE PUBLICATION testpub_for_tbl_schema FOR TABLES IN SCHEMA pub_test, TABLE pub_test.testpub_nopk;
RESET client_min_messages;
CREATE PUBLICATION testpub_parsertst FOR TABLES IN SCHEMA foo, test.foo;
/* should be able to add a table of the same schema to the schema publication */ ALTER PUBLICATION testpub_forschema ADD TABLE pub_test.testpub_nopk;
/* should be able to set table to schema publication */ ALTER PUBLICATION testpub_forschema SET TABLE pub_test.testpub_nopk;
DROP PUBLICATION testpub_foralltables, testpub_fortable, testpub_forschema, testpub_for_tbl_schema;
CREATE TABLE x (x INT);
CREATE TABLE x (x TEXT) INHERITS (x);
SET x = 'ERROR';
CREATE PUBLICATION testpub3 FOR TABLE testpub_tbl3;
CREATE PUBLICATION testpub4 FOR TABLE ONLY testpub_tbl3;
RESET client_min_messages;
DROP PUBLICATION testpub3, testpub4;
SET x = 'ERROR' /* Tests for partitioned tables */;
CREATE PUBLICATION testpub_forparted;
CREATE PUBLICATION testpub_forparted1;
RESET client_min_messages;
CREATE TABLE x (LIKE x);
CREATE TABLE x (LIKE x);
ALTER PUBLICATION testpub_forparted1 SET (publish='insert');
ALTER TABLE testpub_parted ATTACH PARTITION testpub_parted1 FOR VALUES IN (1);
ALTER TABLE testpub_parted ATTACH PARTITION testpub_parted2 FOR VALUES IN (2);
/* works despite missing REPLICA IDENTITY, because updates are not replicated */ UPDATE x SET x = 1;
/* only parent is listed as being in publication, not the partition */ ALTER PUBLICATION testpub_forparted ADD TABLE testpub_parted;
/* should now fail, because parent's publication replicates updates */ UPDATE x SET x = 1;
ALTER TABLE testpub_parted DETACH PARTITION testpub_parted1;
/* works again, because parent's publication is no longer considered */ UPDATE x SET x = 1;
ALTER PUBLICATION testpub_forparted SET (publish_via_partition_root = true);
ALTER PUBLICATION testpub_forparted DROP TABLE testpub_parted;
/* works again, because update is no longer replicated */ UPDATE x SET x = 2;
DROP PUBLICATION testpub_forparted, testpub_forparted1;
/* Tests for row filters */ CREATE TABLE x (x INT, x TEXT);
CREATE TABLE x (x TEXT, x INT);
CREATE TABLE x (x INT);
CREATE TABLE x (x TEXT);
CREATE TABLE x (x xml);
CREATE SCHEMA x.x;
CREATE TABLE x.x (x INT);
CREATE SCHEMA x.x;
CREATE TABLE x.x (x INT);
SET x = 'ERROR';
/* Firstly, test using the option publish='insert' because the row filter */ /* validation of referenced columns is less strict than for delete/update. */ CREATE PUBLICATION testpub5 FOR TABLE testpub_rf_tbl1, testpub_rf_tbl2 WHERE (c <> 'test' AND d < 5) WITH (publish = 'insert');
RESET client_min_messages;
CREATE PUBLICATION testpub_rf_yes FOR TABLE testpub_rf_tbl1 WHERE (a > 1) WITH (publish = 'insert');
CREATE PUBLICATION testpub_rf_no FOR TABLE testpub_rf_tbl1;
RESET client_min_messages;
SET x = 'ERROR' /* some more syntax tests to exercise other parser pathways */;
CREATE PUBLICATION testpub_syntax1 FOR TABLE testpub_rf_tbl1, ONLY testpub_rf_tbl3 WHERE (e < 999) WITH (publish = 'insert');
RESET client_min_messages;
SET x = 'ERROR';
CREATE PUBLICATION testpub_syntax2 FOR TABLE testpub_rf_tbl1, testpub_rf_schema1.testpub_rf_tbl5 WHERE (h < 999) WITH (publish = 'insert');
RESET client_min_messages;
SET x = 'ERROR' /* fail - schemas don't allow WHERE clause */;
CREATE PUBLICATION testpub_syntax3 FOR TABLES IN SCHEMA testpub_rf_schema1 WHERE (a = 123);
CREATE PUBLICATION testpub_syntax3 FOR TABLES IN SCHEMA testpub_rf_schema1, testpub_rf_schema1 WHERE (a = 123);
RESET client_min_messages;
SET x = 'ERROR' /* fail - duplicate tables are not allowed if that table has any WHERE clause */;
CREATE PUBLICATION testpub_dups FOR TABLE testpub_rf_tbl1 WHERE (a = 1), testpub_rf_tbl1 WITH (publish = 'insert');
CREATE PUBLICATION testpub_dups FOR TABLE testpub_rf_tbl1, testpub_rf_tbl1 WHERE (a = 2) WITH (publish = 'insert');
RESET client_min_messages;
/* fail - publication WHERE clause must be boolean */ ALTER PUBLICATION testpub5 SET TABLE testpub_rf_tbl3 WHERE (1234);
/* fail - aggregate functions not allowed in WHERE clause */ ALTER PUBLICATION testpub5 SET TABLE testpub_rf_tbl3 WHERE (e < AVG(e));
/* fail - user-defined operators are not allowed */ CREATE FUNCTION x(x, x) RETURNS BOOLEAN LANGUAGE SQL AS $$ SELECT hashint4($1) > $2 $$;
CREATE OPERATOR =#> (PROCEDURE = testpub_rf_func1, LEFTARG = integer, RIGHTARG = integer);
CREATE PUBLICATION testpub6 FOR TABLE testpub_rf_tbl3 WHERE (e =#> 27);
COMMIT;
ALTER PUBLICATION testpub5 ADD TABLE testpub_rf_tbl1 WHERE (a >= testpub_rf_func2());
/* fail - non-immutable functions are not allowed. random() is volatile. */ ALTER PUBLICATION testpub5 ADD TABLE testpub_rf_tbl1 WHERE (a < random());
/* fail - user-defined collations are not allowed */ CREATE COLLATION user_collation FROM "C";
ALTER PUBLICATION testpub5 ADD TABLE testpub_rf_tbl1 WHERE (b < '2' COLLATE user_collation);
/* ok - NULLIF is allowed */ ALTER PUBLICATION testpub5 SET TABLE testpub_rf_tbl1 WHERE (NULLIF(1,2) = a);
/* ok - built-in operators are allowed */ ALTER PUBLICATION testpub5 SET TABLE testpub_rf_tbl1 WHERE (a IS NULL);
ALTER PUBLICATION testpub5 SET TABLE testpub_rf_tbl1 WHERE ((a > 5) IS FALSE);
ALTER PUBLICATION testpub5 SET TABLE testpub_rf_tbl1 WHERE (a IS DISTINCT FROM 5);
ALTER PUBLICATION testpub5 SET TABLE testpub_rf_tbl1 WHERE ((a, a + 1) < (2, 3));
/* ok - built-in type coercions between two binary compatible datatypes are allowed */ ALTER PUBLICATION testpub5 SET TABLE testpub_rf_tbl1 WHERE (b::varchar < '2');
/* ok - immutable built-in functions are allowed */ ALTER PUBLICATION testpub5 SET TABLE testpub_rf_tbl4 WHERE (length(g) < 6);
/* fail - user-defined types are not allowed */ CREATE TYPE rf_bug_status AS ENUM ('new', 'open', 'closed');
CREATE TABLE x (x SERIAL, x TEXT, x rf_bug_status);
CREATE PUBLICATION testpub6 FOR TABLE rf_bug WHERE (status = 'open') WITH (publish = 'insert');
DROP TABLE x;
DROP TYPE rf_bug_status;
/* fail - row filter expression is not simple */ CREATE PUBLICATION testpub6 FOR TABLE testpub_rf_tbl1 WHERE (a IN (SELECT generate_series(1,5)));
/* fail - system columns are not allowed */ CREATE PUBLICATION testpub6 FOR TABLE testpub_rf_tbl1 WHERE ('(0,1)'::tid = ctid);
/* ok - conditional expressions are allowed */ ALTER PUBLICATION testpub5 SET TABLE testpub_rf_tbl5 WHERE (a IS DOCUMENT);
ALTER PUBLICATION testpub5 SET TABLE testpub_rf_tbl5 WHERE (xmlexists('//foo[text() = ''bar'']' PASSING BY VALUE a));
ALTER PUBLICATION testpub5 SET TABLE testpub_rf_tbl1 WHERE (NULLIF(1, 2) = a);
ALTER PUBLICATION testpub5 SET TABLE testpub_rf_tbl1 WHERE (CASE a WHEN 5 THEN true ELSE false END);
ALTER PUBLICATION testpub5 SET TABLE testpub_rf_tbl1 WHERE (COALESCE(b, 'foo') = 'foo');
ALTER PUBLICATION testpub5 SET TABLE testpub_rf_tbl1 WHERE (GREATEST(a, 10) > 10);
ALTER PUBLICATION testpub5 SET TABLE testpub_rf_tbl1 WHERE (a IN (2, 4, 6));
ALTER PUBLICATION testpub5 SET TABLE testpub_rf_tbl1 WHERE (ARRAY[a] <@ ARRAY[2, 4, 6]);
ALTER PUBLICATION testpub5 SET TABLE testpub_rf_tbl1 WHERE (ROW(a, 2) IS NULL);
/* fail - WHERE not allowed in DROP */ ALTER PUBLICATION testpub5 DROP TABLE testpub_rf_tbl1 WHERE (e < 27);
SET x = 'ERROR' /* fail - cannot ALTER SET table which is a member of a pre-existing schema */;
CREATE PUBLICATION testpub6 FOR TABLES IN SCHEMA testpub_rf_schema2;
/* should be able to set publication with schema and table of the same schema */ ALTER PUBLICATION testpub6 SET TABLES IN SCHEMA testpub_rf_schema2, TABLE testpub_rf_schema2.testpub_rf_tbl6 WHERE (i < 99);
RESET client_min_messages;
CREATE PUBLICATION testpub7 FOR TABLE testpub_rf_tbl6 WHERE (y > 100);
SET x = 'ERROR' /* test that SET EXPRESSION is rejected, because it could affect a row filter */;
CREATE PUBLICATION testpub8 FOR TABLE testpub_rf_tbl7 WHERE (y > 100);
ALTER TABLE x ALTER COLUMN x DROP DEFAULT, SET EXPRESSION AS (x * testpub_rf_func2());
RESET client_min_messages;
DROP TABLE x;
DROP TABLE x;
DROP TABLE x;
DROP TABLE x;
DROP TABLE x;
DROP TABLE x;
DROP TABLE x.x;
DROP TABLE x.x;
DROP SCHEMA x.x;
DROP SCHEMA x.x;
DROP PUBLICATION testpub5;
DROP PUBLICATION testpub6;
DROP PUBLICATION testpub8;
DROP TABLE x;
DROP OPERATOR =#>(integer, integer);
DROP FUNCTION x (INT, INT);
DROP FUNCTION x;
DROP COLLATION user_collation;
/* ====================================================== */ /* More row filter tests for validating column references */ CREATE TABLE x (x INT, x INT, x INT, x INT);
CREATE TABLE x (x INT, x INT, x INT, x INT, PRIMARY KEY (x NULLS LAST, x NULLS LAST));
CREATE TABLE x (x INT PRIMARY KEY, x INT) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x (x INT, x INT PRIMARY KEY);
ALTER TABLE rf_tbl_abcd_part_pk ATTACH PARTITION rf_tbl_abcd_part_pk_1 FOR VALUES FROM (1) TO (10);
SET x = 'ERROR' /* Case 1. REPLICA IDENTITY DEFAULT (means use primary key or nothing) */ /* 1a. REPLICA IDENTITY is DEFAULT and table has a PK. */;
CREATE PUBLICATION testpub6 FOR TABLE rf_tbl_abcd_pk WHERE (a > 99);
RESET client_min_messages;
/* ok - "a" is a PK col */ UPDATE x SET x = 1;
ALTER PUBLICATION testpub6 SET TABLE rf_tbl_abcd_pk WHERE (b > 99);
/* ok - "b" is a PK col */ UPDATE x SET x = 1;
ALTER PUBLICATION testpub6 SET TABLE rf_tbl_abcd_pk WHERE (c > 99);
/* fail - "c" is not part of the PK */ UPDATE x SET x = 1;
ALTER PUBLICATION testpub6 SET TABLE rf_tbl_abcd_pk WHERE (d > 99);
/* fail - "d" is not part of the PK */ UPDATE x SET x = 1;
/* 1b. REPLICA IDENTITY is DEFAULT and table has no PK */ ALTER PUBLICATION testpub6 SET TABLE rf_tbl_abcd_nopk WHERE (a > 99);
/* fail - "a" is not part of REPLICA IDENTITY */ UPDATE x SET x = 1;
/* Case 2. REPLICA IDENTITY FULL */ ALTER TABLE rf_tbl_abcd_pk REPLICA IDENTITY FULL;
ALTER TABLE rf_tbl_abcd_nopk REPLICA IDENTITY FULL;
ALTER PUBLICATION testpub6 SET TABLE rf_tbl_abcd_pk WHERE (c > 99);
/* ok - "c" is in REPLICA IDENTITY now even though not in PK */ UPDATE x SET x = 1;
ALTER PUBLICATION testpub6 SET TABLE rf_tbl_abcd_nopk WHERE (a > 99);
/* ok - "a" is in REPLICA IDENTITY now */ UPDATE x SET x = 1;
/* Case 3. REPLICA IDENTITY NOTHING */ ALTER TABLE rf_tbl_abcd_pk REPLICA IDENTITY NOTHING;
ALTER TABLE rf_tbl_abcd_nopk REPLICA IDENTITY NOTHING;
ALTER PUBLICATION testpub6 SET TABLE rf_tbl_abcd_pk WHERE (a > 99);
/* fail - "a" is in PK but it is not part of REPLICA IDENTITY NOTHING */ UPDATE x SET x = 1;
ALTER PUBLICATION testpub6 SET TABLE rf_tbl_abcd_pk WHERE (c > 99);
/* fail - "c" is not in PK and not in REPLICA IDENTITY NOTHING */ UPDATE x SET x = 1;
ALTER PUBLICATION testpub6 SET TABLE rf_tbl_abcd_nopk WHERE (a > 99);
/* fail - "a" is not in REPLICA IDENTITY NOTHING */ UPDATE x SET x = 1;
ALTER TABLE x ALTER COLUMN x SET NOT NULL /* Case 4. REPLICA IDENTITY INDEX */;
CREATE UNIQUE INDEX x ON x(x NULLS LAST);
ALTER TABLE rf_tbl_abcd_pk REPLICA IDENTITY USING INDEX idx_abcd_pk_c;
ALTER TABLE x ALTER COLUMN x SET NOT NULL;
CREATE UNIQUE INDEX x ON x(x NULLS LAST);
ALTER TABLE rf_tbl_abcd_nopk REPLICA IDENTITY USING INDEX idx_abcd_nopk_c;
ALTER PUBLICATION testpub6 SET TABLE rf_tbl_abcd_pk WHERE (a > 99);
/* fail - "a" is in PK but it is not part of REPLICA IDENTITY INDEX */ UPDATE x SET x = 1;
ALTER PUBLICATION testpub6 SET TABLE rf_tbl_abcd_pk WHERE (c > 99);
/* ok - "c" is not in PK but it is part of REPLICA IDENTITY INDEX */ UPDATE x SET x = 1;
ALTER PUBLICATION testpub6 SET TABLE rf_tbl_abcd_nopk WHERE (a > 99);
/* fail - "a" is not in REPLICA IDENTITY INDEX */ UPDATE x SET x = 1;
ALTER PUBLICATION testpub6 SET TABLE rf_tbl_abcd_nopk WHERE (c > 99);
/* ok - "c" is part of REPLICA IDENTITY INDEX */ UPDATE x SET x = 1;
/* Tests for partitioned table */ /* set PUBLISH_VIA_PARTITION_ROOT to false and test row filter for partitioned */ /* table */ ALTER PUBLICATION testpub6 SET (PUBLISH_VIA_PARTITION_ROOT=0);
/* fail - cannot use row filter for partitioned table */ ALTER PUBLICATION testpub6 SET TABLE rf_tbl_abcd_part_pk WHERE (a > 99);
/* ok - can use row filter for partition */ ALTER PUBLICATION testpub6 SET TABLE rf_tbl_abcd_part_pk_1 WHERE (a > 99);
/* ok - "a" is a PK col */ UPDATE x SET x = 1;
/* set PUBLISH_VIA_PARTITION_ROOT to true and test row filter for partitioned */ /* table */ ALTER PUBLICATION testpub6 SET (PUBLISH_VIA_PARTITION_ROOT=1);
/* ok - can use row filter for partitioned table */ ALTER PUBLICATION testpub6 SET TABLE rf_tbl_abcd_part_pk WHERE (a > 99);
/* ok - "a" is a PK col */ UPDATE x SET x = 1;
/* fail - cannot set PUBLISH_VIA_PARTITION_ROOT to false if any row filter is */ /* used for partitioned table */ ALTER PUBLICATION testpub6 SET (PUBLISH_VIA_PARTITION_ROOT=0);
/* remove partitioned table's row filter */ ALTER PUBLICATION testpub6 SET TABLE rf_tbl_abcd_part_pk;
/* ok - we don't have row filter for partitioned table. */ ALTER PUBLICATION testpub6 SET (PUBLISH_VIA_PARTITION_ROOT=0);
/* Now change the root filter to use a column "b" */ /* (which is not in the replica identity) */ ALTER PUBLICATION testpub6 SET TABLE rf_tbl_abcd_part_pk_1 WHERE (b > 99);
/* ok - we don't have row filter for partitioned table. */ ALTER PUBLICATION testpub6 SET (PUBLISH_VIA_PARTITION_ROOT=0);
/* fail - "b" is not in REPLICA IDENTITY INDEX */ UPDATE x SET x = 1;
/* set PUBLISH_VIA_PARTITION_ROOT to true */ /* can use row filter for partitioned table */ ALTER PUBLICATION testpub6 SET (PUBLISH_VIA_PARTITION_ROOT=1);
/* ok - can use row filter for partitioned table */ ALTER PUBLICATION testpub6 SET TABLE rf_tbl_abcd_part_pk WHERE (b > 99);
/* fail - "b" is not in REPLICA IDENTITY INDEX */ UPDATE x SET x = 1;
DROP PUBLICATION testpub6;
DROP TABLE x;
DROP TABLE x;
DROP TABLE x;
SET x = 'ERROR' /* ====================================================== */ /* ====================================================== */ /* Tests with generated column */;
/* stored */ CREATE TABLE x (x INT, x INT AS x + 1 NOT NULL);
CREATE UNIQUE INDEX x ON x(x NULLS LAST);
ALTER TABLE testpub_gencol REPLICA IDENTITY USING index testpub_gencol_idx;
/* error - generated column "b" must be published explicitly as it is */ /* part of the REPLICA IDENTITY index. */ CREATE PUBLICATION pub_gencol FOR TABLE testpub_gencol;
UPDATE x SET x = 100 WHERE x = 1;
/* error - generated column "b" must be published explicitly as it is */ /* part of the REPLICA IDENTITY. */ ALTER TABLE testpub_gencol REPLICA IDENTITY FULL;
UPDATE x SET x = 100 WHERE x = 1;
DROP PUBLICATION pub_gencol;
/* ok - generated column "b" is published explicitly */ CREATE PUBLICATION pub_gencol FOR TABLE testpub_gencol with (publish_generated_columns = stored);
UPDATE x SET x = 100 WHERE x = 1;
DROP PUBLICATION pub_gencol;
DROP TABLE x;
CREATE PUBLICATION pub_gencol FOR TABLE testpub_gencol;
/* error - generated column "b" must be published explicitly as it is */ /* part of the REPLICA IDENTITY. */ ALTER TABLE testpub_gencol REPLICA IDENTITY FULL;
UPDATE x SET x = 100 WHERE x = 1;
DROP PUBLICATION pub_gencol;
/* error - "stored" setting does not affect virtual column */ CREATE PUBLICATION pub_gencol FOR TABLE testpub_gencol with (publish_generated_columns = stored);
UPDATE x SET x = 100 WHERE x = 1;
DROP PUBLICATION pub_gencol;
DROP TABLE x;
RESET client_min_messages;
SET x = 'ERROR' /* ====================================================== */ /* fail - duplicate tables are not allowed if that table has any column lists */;
CREATE PUBLICATION testpub_dups FOR TABLE testpub_tbl1 (a), testpub_tbl1 WITH (publish = 'insert');
CREATE PUBLICATION testpub_dups FOR TABLE testpub_tbl1, testpub_tbl1 (a) WITH (publish = 'insert');
RESET client_min_messages;
SET x = 'ERROR' /* test for column lists */;
CREATE PUBLICATION testpub_fortable FOR TABLE testpub_tbl1;
CREATE PUBLICATION testpub_fortable_insert WITH (publish = 'insert');
RESET client_min_messages;
/* error: column "x" does not exist */ ALTER PUBLICATION testpub_fortable ADD TABLE testpub_tbl5 (a, x);
/* error: replica identity "a" not included in the column list */ ALTER PUBLICATION testpub_fortable ADD TABLE testpub_tbl5 (b, c);
UPDATE x SET x = 1;
ALTER PUBLICATION testpub_fortable DROP TABLE testpub_tbl5;
/* error: system attributes "ctid" not allowed in column list */ ALTER PUBLICATION testpub_fortable ADD TABLE testpub_tbl5 (a, ctid);
ALTER PUBLICATION testpub_fortable SET TABLE testpub_tbl1 (id, ctid);
/* error: duplicates not allowed in column list */ ALTER PUBLICATION testpub_fortable ADD TABLE testpub_tbl5 (a, a);
ALTER PUBLICATION testpub_fortable SET TABLE testpub_tbl5 (a, a);
/* ok */ ALTER PUBLICATION testpub_fortable ADD TABLE testpub_tbl5 (a, c);
ALTER TABLE x DROP COLUMN x;
/* no dice */ /* ok: for insert-only publication, any column list is acceptable */ ALTER PUBLICATION testpub_fortable_insert ADD TABLE testpub_tbl5 (b, c);
/* not all replica identities are good enough */ CREATE UNIQUE INDEX x ON x(x NULLS LAST, x NULLS LAST);
ALTER TABLE testpub_tbl5 ALTER b SET NOT NULL, ALTER c SET NOT NULL;
ALTER TABLE testpub_tbl5 REPLICA IDENTITY USING INDEX testpub_tbl5_b_key;
/* error: replica identity (b,c) is not covered by column list (a, c) */ UPDATE x SET x = 1;
ALTER PUBLICATION testpub_fortable DROP TABLE testpub_tbl5;
/* ok: stored generated column "d" can be in the list too */ ALTER PUBLICATION testpub_fortable ADD TABLE testpub_tbl5 (a, d);
ALTER PUBLICATION testpub_fortable DROP TABLE testpub_tbl5;
/* error: virtual generated column "e" can't be in list */ ALTER PUBLICATION testpub_fortable ADD TABLE testpub_tbl5 (a, e);
/* error: change the replica identity to "b", and column list to (a, c) */ /* then update fails, because (a, c) does not cover replica identity */ ALTER TABLE testpub_tbl5 REPLICA IDENTITY USING INDEX testpub_tbl5_b_key;
ALTER PUBLICATION testpub_fortable ADD TABLE testpub_tbl5 (a, c);
UPDATE x SET x = 1;
SET x = 'ERROR' /* But if upd/del are not published, it works OK */;
CREATE PUBLICATION testpub_table_ins WITH (publish = 'insert, truncate');
RESET client_min_messages;
ALTER PUBLICATION testpub_table_ins ADD TABLE testpub_tbl5 (a);
ALTER PUBLICATION testpub_fortable ADD TABLE testpub_tbl5d;
UPDATE x SET x = 1;
/* but works fine with FULL replica identity */ ALTER TABLE testpub_tbl5d REPLICA IDENTITY FULL;
UPDATE x SET x = 1;
DROP TABLE x;
/* tests with REPLICA IDENTITY FULL */ CREATE TABLE x (x INT, x TEXT, x TEXT);
ALTER TABLE testpub_tbl6 REPLICA IDENTITY FULL;
ALTER PUBLICATION testpub_fortable ADD TABLE testpub_tbl6 (a, b, c);
UPDATE x SET x = 1;
ALTER PUBLICATION testpub_fortable DROP TABLE testpub_tbl6;
ALTER PUBLICATION testpub_fortable ADD TABLE testpub_tbl6;
/* ok */ UPDATE x SET x = 1;
/* make sure changing the column list is propagated to the catalog */ CREATE TABLE x (x INT PRIMARY KEY, x TEXT, x TEXT);
ALTER PUBLICATION testpub_fortable ADD TABLE testpub_tbl7 (a, b);
/* first partition has replica identity "a" */ CREATE TABLE x PARTITION OF x FOR VALUES WITH (MODULUS 2, REMAINDER 0);
ALTER TABLE x ADD PRIMARY KEY (x NULLS LAST);
ALTER TABLE testpub_tbl8_0 REPLICA IDENTITY USING INDEX testpub_tbl8_0_pkey;
/* second partition has replica identity "b" */ CREATE TABLE x PARTITION OF x FOR VALUES WITH (MODULUS 2, REMAINDER 1);
ALTER TABLE x ADD PRIMARY KEY (x NULLS LAST);
ALTER TABLE testpub_tbl8_1 REPLICA IDENTITY USING INDEX testpub_tbl8_1_pkey;
SET x = 'ERROR' /* ok: column list covers both "a" and "b" */;
CREATE PUBLICATION testpub_col_list FOR TABLE testpub_tbl8 (a, b) WITH (publish_via_partition_root = 'true');
RESET client_min_messages;
/* ok: the same thing, but try plain ADD TABLE */ ALTER PUBLICATION testpub_col_list DROP TABLE testpub_tbl8;
ALTER PUBLICATION testpub_col_list ADD TABLE testpub_tbl8 (a, b);
UPDATE x SET x = 1;
/* failure: column list does not cover replica identity for the second partition */ ALTER PUBLICATION testpub_col_list DROP TABLE testpub_tbl8;
ALTER PUBLICATION testpub_col_list ADD TABLE testpub_tbl8 (a, c);
UPDATE x SET x = 1;
ALTER PUBLICATION testpub_col_list DROP TABLE testpub_tbl8;
/* failure: one of the partitions has REPLICA IDENTITY FULL */ ALTER TABLE testpub_tbl8_1 REPLICA IDENTITY FULL;
ALTER PUBLICATION testpub_col_list ADD TABLE testpub_tbl8 (a, c);
UPDATE x SET x = 1;
ALTER PUBLICATION testpub_col_list DROP TABLE testpub_tbl8;
/* add table and then try changing replica identity */ ALTER TABLE testpub_tbl8_1 REPLICA IDENTITY USING INDEX testpub_tbl8_1_pkey;
ALTER PUBLICATION testpub_col_list ADD TABLE testpub_tbl8 (a, b);
/* failure: replica identity full can't be used with a column list */ ALTER TABLE testpub_tbl8_1 REPLICA IDENTITY FULL;
UPDATE x SET x = 1;
ALTER TABLE x DROP CONSTRAINT x /* failure: replica identity has to be covered by the column list */;
ALTER TABLE x ADD PRIMARY KEY (x NULLS LAST);
ALTER TABLE testpub_tbl8_1 REPLICA IDENTITY USING INDEX testpub_tbl8_1_pkey;
UPDATE x SET x = 1;
DROP TABLE x;
/* column list for partitioned tables has to cover replica identities for */ /* all child relations */ CREATE TABLE x (x INT, x TEXT, x TEXT) WITH (PARTITIONED_BY=HASH(x));
ALTER PUBLICATION testpub_col_list ADD TABLE testpub_tbl8 (a, b);
/* first partition has replica identity "a" */ CREATE TABLE x (x INT, x TEXT, x TEXT);
ALTER TABLE x ADD PRIMARY KEY (x NULLS LAST);
ALTER TABLE testpub_tbl8_0 REPLICA IDENTITY USING INDEX testpub_tbl8_0_pkey;
/* second partition has replica identity "b" */ CREATE TABLE x (x INT, x TEXT, x TEXT);
ALTER TABLE x ADD PRIMARY KEY (x NULLS LAST);
ALTER TABLE testpub_tbl8_1 REPLICA IDENTITY USING INDEX testpub_tbl8_1_pkey;
/* ok: attaching first partition works, because (a) is in column list */ ALTER TABLE testpub_tbl8 ATTACH PARTITION testpub_tbl8_0 FOR VALUES WITH (modulus 2, remainder 0);
/* failure: second partition has replica identity (c), which si not in column list */ ALTER TABLE testpub_tbl8 ATTACH PARTITION testpub_tbl8_1 FOR VALUES WITH (modulus 2, remainder 1);
UPDATE x SET x = 1;
/* failure: changing replica identity to FULL for partition fails, because */ /* of the column list on the parent */ ALTER TABLE testpub_tbl8_0 REPLICA IDENTITY FULL;
UPDATE x SET x = 1;
SET x = 'ERROR' /* test that using column list for table is disallowed if any schemas are */ /* part of the publication */;
/* failure - cannot use column list and schema together */ CREATE PUBLICATION testpub_tbl9 FOR TABLES IN SCHEMA public, TABLE public.testpub_tbl7(a);
/* ok - only publish schema */ CREATE PUBLICATION testpub_tbl9 FOR TABLES IN SCHEMA public;
/* failure - add a table with column list when there is already a schema in the */ /* publication */ ALTER PUBLICATION testpub_tbl9 ADD TABLE public.testpub_tbl7(a);
/* ok - only publish table with column list */ ALTER PUBLICATION testpub_tbl9 SET TABLE public.testpub_tbl7(a);
/* failure - specify a schema when there is already a column list in the */ /* publication */ ALTER PUBLICATION testpub_tbl9 ADD TABLES IN SCHEMA public;
/* failure - cannot SET column list and schema together */ ALTER PUBLICATION testpub_tbl9 SET TABLES IN SCHEMA public, TABLE public.testpub_tbl7(a);
/* ok - drop table */ ALTER PUBLICATION testpub_tbl9 DROP TABLE public.testpub_tbl7;
/* failure - cannot ADD column list and schema together */ ALTER PUBLICATION testpub_tbl9 ADD TABLES IN SCHEMA public, TABLE public.testpub_tbl7(a);
RESET client_min_messages;
DROP PUBLICATION testpub_table_ins, testpub_fortable, testpub_fortable_insert, testpub_col_list, testpub_tbl9;
SET x = 'ERROR' /* ====================================================== */ /* Test combination of column list and row filter */;
CREATE PUBLICATION testpub_both_filters;
RESET client_min_messages;
CREATE TABLE x (x INT, x INT, x INT, PRIMARY KEY (x NULLS LAST, x NULLS LAST));
ALTER TABLE testpub_tbl_both_filters REPLICA IDENTITY USING INDEX testpub_tbl_both_filters_pkey;
ALTER PUBLICATION testpub_both_filters ADD TABLE testpub_tbl_both_filters (a,c) WHERE (c != 1);
DROP PUBLICATION testpub_both_filters;
/* ====================================================== */ /* More column list tests for validating column references */ CREATE TABLE x (x INT, x INT, x INT, x INT);
CREATE TABLE x (x INT, x INT, x INT, x INT, PRIMARY KEY (x NULLS LAST, x NULLS LAST));
CREATE TABLE x (x INT PRIMARY KEY, x INT) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x (x INT, x INT PRIMARY KEY);
ALTER TABLE rf_tbl_abcd_part_pk ATTACH PARTITION rf_tbl_abcd_part_pk_1 FOR VALUES FROM (1) TO (10);
SET x = 'ERROR' /* Case 1. REPLICA IDENTITY DEFAULT (means use primary key or nothing) */ /* 1a. REPLICA IDENTITY is DEFAULT and table has a PK. */;
CREATE PUBLICATION testpub6 FOR TABLE rf_tbl_abcd_pk (a, b);
RESET client_min_messages;
/* ok - (a,b) covers all PK cols */ UPDATE x SET x = 1;
ALTER PUBLICATION testpub6 SET TABLE rf_tbl_abcd_pk (a, b, c);
/* ok - (a,b,c) covers all PK cols */ UPDATE x SET x = 1;
ALTER PUBLICATION testpub6 SET TABLE rf_tbl_abcd_pk (a);
/* fail - "b" is missing from the column list */ UPDATE x SET x = 1;
ALTER PUBLICATION testpub6 SET TABLE rf_tbl_abcd_pk (b);
/* fail - "a" is missing from the column list */ UPDATE x SET x = 1;
/* 1b. REPLICA IDENTITY is DEFAULT and table has no PK */ ALTER PUBLICATION testpub6 SET TABLE rf_tbl_abcd_nopk (a);
/* ok - there's no replica identity, so any column list works */ /* note: it fails anyway, just a bit later because UPDATE requires RI */ UPDATE x SET x = 1;
/* Case 2. REPLICA IDENTITY FULL */ ALTER TABLE rf_tbl_abcd_pk REPLICA IDENTITY FULL;
ALTER TABLE rf_tbl_abcd_nopk REPLICA IDENTITY FULL;
ALTER PUBLICATION testpub6 SET TABLE rf_tbl_abcd_pk (c);
/* fail - with REPLICA IDENTITY FULL no column list is allowed */ UPDATE x SET x = 1;
ALTER PUBLICATION testpub6 SET TABLE rf_tbl_abcd_nopk (a, b, c, d);
/* fail - with REPLICA IDENTITY FULL no column list is allowed */ UPDATE x SET x = 1;
/* Case 3. REPLICA IDENTITY NOTHING */ ALTER TABLE rf_tbl_abcd_pk REPLICA IDENTITY NOTHING;
ALTER TABLE rf_tbl_abcd_nopk REPLICA IDENTITY NOTHING;
ALTER PUBLICATION testpub6 SET TABLE rf_tbl_abcd_pk (a);
/* ok - REPLICA IDENTITY NOTHING means all column lists are valid */ /* it still fails later because without RI we can't replicate updates */ UPDATE x SET x = 1;
ALTER PUBLICATION testpub6 SET TABLE rf_tbl_abcd_pk (a, b, c, d);
/* ok - REPLICA IDENTITY NOTHING means all column lists are valid */ /* it still fails later because without RI we can't replicate updates */ UPDATE x SET x = 1;
ALTER PUBLICATION testpub6 SET TABLE rf_tbl_abcd_nopk (d);
/* ok - REPLICA IDENTITY NOTHING means all column lists are valid */ /* it still fails later because without RI we can't replicate updates */ UPDATE x SET x = 1;
ALTER TABLE x ALTER COLUMN x SET NOT NULL /* Case 4. REPLICA IDENTITY INDEX */;
CREATE UNIQUE INDEX x ON x(x NULLS LAST);
ALTER TABLE rf_tbl_abcd_pk REPLICA IDENTITY USING INDEX idx_abcd_pk_c;
ALTER TABLE x ALTER COLUMN x SET NOT NULL;
CREATE UNIQUE INDEX x ON x(x NULLS LAST);
ALTER TABLE rf_tbl_abcd_nopk REPLICA IDENTITY USING INDEX idx_abcd_nopk_c;
ALTER PUBLICATION testpub6 SET TABLE rf_tbl_abcd_pk (a);
/* fail - column list "a" does not cover the REPLICA IDENTITY INDEX on "c" */ UPDATE x SET x = 1;
ALTER PUBLICATION testpub6 SET TABLE rf_tbl_abcd_pk (c);
/* ok - column list "c" does cover the REPLICA IDENTITY INDEX on "c" */ UPDATE x SET x = 1;
ALTER PUBLICATION testpub6 SET TABLE rf_tbl_abcd_nopk (a);
/* fail - column list "a" does not cover the REPLICA IDENTITY INDEX on "c" */ UPDATE x SET x = 1;
ALTER PUBLICATION testpub6 SET TABLE rf_tbl_abcd_nopk (c);
/* ok - column list "c" does cover the REPLICA IDENTITY INDEX on "c" */ UPDATE x SET x = 1;
/* Tests for partitioned table */ /* set PUBLISH_VIA_PARTITION_ROOT to false and test column list for partitioned */ /* table */ ALTER PUBLICATION testpub6 SET (PUBLISH_VIA_PARTITION_ROOT=0);
/* fail - cannot use column list for partitioned table */ ALTER PUBLICATION testpub6 SET TABLE rf_tbl_abcd_part_pk (a);
/* ok - can use column list for partition */ ALTER PUBLICATION testpub6 SET TABLE rf_tbl_abcd_part_pk_1 (a);
/* ok - "a" is a PK col */ UPDATE x SET x = 1;
/* set PUBLISH_VIA_PARTITION_ROOT to true and test column list for partitioned */ /* table */ ALTER PUBLICATION testpub6 SET (PUBLISH_VIA_PARTITION_ROOT=1);
/* ok - can use column list for partitioned table */ ALTER PUBLICATION testpub6 SET TABLE rf_tbl_abcd_part_pk (a);
/* ok - "a" is a PK col */ UPDATE x SET x = 1;
/* fail - cannot set PUBLISH_VIA_PARTITION_ROOT to false if any column list is */ /* used for partitioned table */ ALTER PUBLICATION testpub6 SET (PUBLISH_VIA_PARTITION_ROOT=0);
/* remove partitioned table's column list */ ALTER PUBLICATION testpub6 SET TABLE rf_tbl_abcd_part_pk;
/* ok - we don't have column list for partitioned table. */ ALTER PUBLICATION testpub6 SET (PUBLISH_VIA_PARTITION_ROOT=0);
/* Now change the root column list to use a column "b" */ /* (which is not in the replica identity) */ ALTER PUBLICATION testpub6 SET TABLE rf_tbl_abcd_part_pk_1 (b);
/* ok - we don't have column list for partitioned table. */ ALTER PUBLICATION testpub6 SET (PUBLISH_VIA_PARTITION_ROOT=0);
/* fail - "b" is not in REPLICA IDENTITY INDEX */ UPDATE x SET x = 1;
/* set PUBLISH_VIA_PARTITION_ROOT to true */ /* can use column list for partitioned table */ ALTER PUBLICATION testpub6 SET (PUBLISH_VIA_PARTITION_ROOT=1);
/* ok - can use column list for partitioned table */ ALTER PUBLICATION testpub6 SET TABLE rf_tbl_abcd_part_pk (b);
/* fail - "b" is not in REPLICA IDENTITY INDEX */ UPDATE x SET x = 1;
DROP PUBLICATION testpub6;
DROP TABLE x;
DROP TABLE x;
DROP TABLE x;
SET x = 'ERROR' /* ====================================================== */ /* Test cache invalidation FOR ALL TABLES publication */;
CREATE TABLE x (x INT);
INSERT INTO x VALUES (1);
UPDATE x SET x = 2;
CREATE PUBLICATION testpub_foralltables FOR ALL TABLES;
RESET client_min_messages;
/* fail missing REPLICA IDENTITY */ UPDATE x SET x = 3;
DROP PUBLICATION testpub_foralltables;
/* should pass after dropping the publication */ UPDATE x SET x = 3;
DROP TABLE x;
/* fail - view */ CREATE PUBLICATION testpub_fortbl FOR TABLE testpub_view;
CREATE TEMPORARY TABLE x (x INT);
/* fail - temporary table */ CREATE PUBLICATION testpub_fortemptbl FOR TABLE testpub_temptbl;
DROP TABLE x;
CREATE UNLOGGED TABLE x (x INT);
/* fail - unlogged table */ CREATE PUBLICATION testpub_forunloggedtbl FOR TABLE testpub_unloggedtbl;
DROP TABLE x;
/* fail - system table */ CREATE PUBLICATION testpub_forsystemtbl FOR TABLE pg_publication;
SET x = 'ERROR';
CREATE PUBLICATION testpub_fortbl FOR TABLE testpub_tbl1, pub_test.testpub_nopk;
RESET client_min_messages;
/* fail - already added */ ALTER PUBLICATION testpub_fortbl ADD TABLE testpub_tbl1;
/* fail - already added */ CREATE PUBLICATION testpub_fortbl FOR TABLE testpub_tbl1;
ALTER PUBLICATION testpub_default ADD TABLE testpub_tbl1;
ALTER PUBLICATION testpub_default SET TABLE testpub_tbl1;
ALTER PUBLICATION testpub_default ADD TABLE pub_test.testpub_nopk;
ALTER PUBLICATION testpub_ins_trunct ADD TABLE pub_test.testpub_nopk, testpub_tbl1;
/* fail - nonexistent */ ALTER PUBLICATION testpub_default DROP TABLE pub_test.testpub_nopk;
ALTER PUBLICATION testpub_default ADD TABLE pub_test.testpub_addpk;
INSERT INTO x.x VALUES (1, 11);
CREATE UNIQUE INDEX x ON x.x(x NULLS LAST);
/* fail: */ UPDATE x.x SET x = 2;
ALTER TABLE pub_test.testpub_addpk ADD PRIMARY KEY USING INDEX testpub_addpk_id_idx;
/* now it should work: */ UPDATE x.x SET x = 2;
DROP TABLE x.x;
/* permissions */ SET ROLE regress_publication_user2;
CREATE PUBLICATION testpub2;
/* fail */ SET ROLE regress_publication_user;
GRANT CREATE ON DATABASE x TO x;
SET ROLE regress_publication_user2;
SET x = 'ERROR';
CREATE PUBLICATION testpub2;
/* ok */ CREATE PUBLICATION testpub3 FOR TABLES IN SCHEMA pub_test;
/* fail */ CREATE PUBLICATION testpub3;
/* ok */ RESET client_min_messages;
ALTER PUBLICATION testpub2 ADD TABLE testpub_tbl1;
/* fail */ ALTER PUBLICATION testpub3 ADD TABLES IN SCHEMA pub_test;
/* fail */ SET ROLE regress_publication_user;
GRANT regress_publication_user TO regress_publication_user2;
SET ROLE regress_publication_user2;
ALTER PUBLICATION testpub2 ADD TABLE testpub_tbl1;
/* ok */ DROP PUBLICATION testpub2;
DROP PUBLICATION testpub3;
SET ROLE regress_publication_user;
CREATE ROLE regress_publication_user3;
GRANT regress_publication_user2 TO regress_publication_user3;
SET x = 'ERROR';
CREATE PUBLICATION testpub4 FOR TABLES IN SCHEMA pub_test;
RESET client_min_messages;
ALTER PUBLICATION testpub4 OWNER TO regress_publication_user3;
SET ROLE regress_publication_user3;
/* fail - new owner must be superuser */ ALTER PUBLICATION testpub4 owner to regress_publication_user2;
/* fail */ ALTER PUBLICATION testpub4 owner to regress_publication_user;
/* ok */ SET ROLE regress_publication_user;
DROP PUBLICATION testpub4;
DROP ROLE regress_publication_user3;
REVOKE CREATE ON DATABASE regression FROM regress_publication_user2;
DROP TABLE x;
DROP TABLE x;
ALTER PUBLICATION testpub_default RENAME TO testpub_dummy;
RESET ROLE;
ALTER PUBLICATION testpub_default RENAME TO testpub_foo;
ALTER PUBLICATION testpub_default OWNER TO regress_publication_user2;
CREATE SCHEMA x.x;
CREATE SCHEMA x.x;
CREATE SCHEMA "x".x;
CREATE TABLE x.x (x INT, x TEXT);
CREATE TABLE x.x (x SERIAL PRIMARY KEY, x TEXT);
CREATE TABLE x.x (x SERIAL PRIMARY KEY, x TEXT);
CREATE TABLE "x".x (x INT);
SET x = 'ERROR' /* suppress warning that depends on wal_level */;
CREATE PUBLICATION testpub1_forschema FOR TABLES IN SCHEMA pub_test1;
CREATE PUBLICATION testpub4_forschema FOR TABLES IN SCHEMA "CURRENT_SCHEMA";
CREATE PUBLICATION testpub5_forschema FOR TABLES IN SCHEMA CURRENT_SCHEMA, "CURRENT_SCHEMA";
CREATE PUBLICATION testpub6_forschema FOR TABLES IN SCHEMA "CURRENT_SCHEMA", CURRENT_SCHEMA;
CREATE PUBLICATION testpub_fortable FOR TABLE "CURRENT_SCHEMA"."CURRENT_SCHEMA";
RESET client_min_messages;
CREATE PUBLICATION testpub_forschema FOR TABLES IN SCHEMA CURRENT_SCHEMA;
RESET SEARCH_PATH;
/* check create publication on CURRENT_SCHEMA where TABLE/TABLES in SCHEMA */ /* is not specified */ CREATE PUBLICATION testpub_forschema1 FOR CURRENT_SCHEMA;
/* check create publication on CURRENT_SCHEMA along with FOR TABLE */ CREATE PUBLICATION testpub_forschema1 FOR TABLE CURRENT_SCHEMA;
/* check create publication on a schema that does not exist */ CREATE PUBLICATION testpub_forschema FOR TABLES IN SCHEMA non_existent_schema;
/* check create publication on a system schema */ CREATE PUBLICATION testpub_forschema FOR TABLES IN SCHEMA pg_catalog;
/* check create publication on an object which is not schema */ CREATE PUBLICATION testpub1_forschema1 FOR TABLES IN SCHEMA testpub_view;
/* dropping the schema should reflect the change in publication */ DROP SCHEMA x.x;
ALTER PUBLICATION testpub1_forschema ADD TABLES IN SCHEMA foo, bar (a, b);
/* cleanup pub_test1 schema for invalidation tests */ ALTER PUBLICATION testpub2_forschema DROP TABLES IN SCHEMA pub_test1;
DROP PUBLICATION testpub3_forschema, testpub4_forschema, testpub5_forschema, testpub6_forschema, testpub_fortable;
DROP SCHEMA "x".x CASCADE;
/* verify relation cache invalidations through update statement for the */ /* default REPLICA IDENTITY on the relation, if schema is part of the */ /* publication then update will fail because relation's relreplident */ /* option will be set, if schema is not part of the publication then update */ /* will be successful. */ INSERT INTO x.x VALUES (1, 'test');
/* fail */ UPDATE x.x SET x = 2;
ALTER PUBLICATION testpub1_forschema DROP TABLES IN SCHEMA pub_test1;
/* success */ UPDATE x.x SET x = 2;
ALTER PUBLICATION testpub1_forschema SET TABLES IN SCHEMA pub_test1;
/* fail */ UPDATE x.x SET x = 2;
/* verify invalidation of partition table having parent and child tables in */ /* different schema */ CREATE SCHEMA x.x;
CREATE SCHEMA x.x;
CREATE TABLE x.x (x INT) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x.x PARTITION OF x.x FOR VALUES IN (1);
INSERT INTO x.x VALUES (1);
UPDATE x.x SET x = 1;
SET x = 'ERROR';
CREATE PUBLICATION testpubpart_forschema FOR TABLES IN SCHEMA pub_testpart1;
RESET client_min_messages;
/* fail */ UPDATE x.x SET x = 1;
UPDATE x.x SET x = 1;
DROP PUBLICATION testpubpart_forschema;
/* verify invalidation of partition tables for schema publication that has */ /* parent and child tables of different partition hierarchies */ CREATE TABLE x.x (x INT) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x.x PARTITION OF x.x FOR VALUES IN (1);
INSERT INTO x.x VALUES (1);
UPDATE x.x SET x = 1;
SET x = 'ERROR';
CREATE PUBLICATION testpubpart_forschema FOR TABLES IN SCHEMA pub_testpart2;
RESET client_min_messages;
/* fail */ UPDATE x.x SET x = 1;
UPDATE x.x SET x = 1;
UPDATE x.x SET x = 1;
SET x = 'ERROR' /* alter publication set 'TABLES IN SCHEMA' on an empty publication. */;
CREATE PUBLICATION testpub3_forschema;
RESET client_min_messages;
CREATE PUBLICATION testpub_forschema_fortable FOR TABLES IN SCHEMA pub_test1, TABLE pub_test2.tbl1;
CREATE PUBLICATION testpub_fortable_forschema FOR TABLE pub_test2.tbl1, TABLES IN SCHEMA pub_test1;
RESET client_min_messages;
DROP VIEW x;
DROP PUBLICATION testpub_default;
DROP PUBLICATION testpub_ins_trunct;
DROP PUBLICATION testpub_fortbl;
DROP PUBLICATION testpub1_forschema;
DROP PUBLICATION testpub2_forschema;
DROP PUBLICATION testpub3_forschema;
DROP PUBLICATION testpub_forschema_fortable;
DROP PUBLICATION testpub_fortable_forschema;
DROP PUBLICATION testpubpart_forschema;
DROP SCHEMA x.x CASCADE;
DROP SCHEMA x.x CASCADE;
DROP SCHEMA x.x CASCADE;
DROP SCHEMA x.x CASCADE;
DROP SCHEMA x.x CASCADE;
SET x = 'ERROR' /* Test the list of partitions published with or without */ /* 'PUBLISH_VIA_PARTITION_ROOT' parameter */;
CREATE SCHEMA x.x;
CREATE SCHEMA x.x;
CREATE TABLE x.x (x INT) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x.x PARTITION OF x.x FOR VALUES FROM (1) TO (10);
/* Schema publication that does not include the schema that has the parent table */ CREATE PUBLICATION pub FOR TABLES IN SCHEMA sch2 WITH (PUBLISH_VIA_PARTITION_ROOT=1);
SELECT * FROM x;
DROP PUBLICATION pub;
/* Table publication that does not include the parent table */ CREATE PUBLICATION pub FOR TABLE sch2.tbl1_part1 WITH (PUBLISH_VIA_PARTITION_ROOT=1);
SELECT * FROM x;
/* Table publication that includes both the parent table and the child table */ ALTER PUBLICATION pub ADD TABLE sch1.tbl1;
SELECT * FROM x;
DROP PUBLICATION pub;
/* Schema publication that does not include the schema that has the parent table */ CREATE PUBLICATION pub FOR TABLES IN SCHEMA sch2 WITH (PUBLISH_VIA_PARTITION_ROOT=0);
SELECT * FROM x;
DROP PUBLICATION pub;
/* Table publication that does not include the parent table */ CREATE PUBLICATION pub FOR TABLE sch2.tbl1_part1 WITH (PUBLISH_VIA_PARTITION_ROOT=0);
SELECT * FROM x;
/* Table publication that includes both the parent table and the child table */ ALTER PUBLICATION pub ADD TABLE sch1.tbl1;
SELECT * FROM x;
DROP PUBLICATION pub;
DROP TABLE x.x;
DROP TABLE x.x;
CREATE TABLE x.x (x INT) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x.x PARTITION OF x.x FOR VALUES FROM (1) TO (10);
CREATE TABLE x.x PARTITION OF x.x FOR VALUES FROM (10) TO (20);
CREATE TABLE x.x (x INT) WITH (PARTITIONED_BY=RANGE(x));
ALTER TABLE sch1.tbl1 ATTACH PARTITION sch1.tbl1_part3 FOR VALUES FROM (20) to (30);
CREATE PUBLICATION pub FOR TABLES IN SCHEMA sch1 WITH (PUBLISH_VIA_PARTITION_ROOT=1);
SELECT * FROM x;
RESET client_min_messages;
DROP PUBLICATION pub;
DROP TABLE x.x;
DROP SCHEMA x.x CASCADE;
DROP SCHEMA x.x CASCADE;
SET x = 'ERROR' /* ====================================================== */ /* Test the 'publish_generated_columns' parameter with the following values: */ /* 'stored', 'none', and the default (no value specified), which defaults to */ /* 'stored'. */;
CREATE PUBLICATION pub1 FOR ALL TABLES WITH (publish_generated_columns = stored);
DROP PUBLICATION pub2;
DROP PUBLICATION pub3;
/* Test the 'publish_generated_columns' parameter as 'none' and 'stored' for */ /* different scenarios with/without generated columns in column lists. */ CREATE TABLE x (x INT, x INT AS x * 2);
/* Generated columns in column list, when 'publish_generated_columns'='none' */ CREATE PUBLICATION pub1 FOR table gencols(a, gen1) WITH (publish_generated_columns = none);
DROP PUBLICATION pub2;
DROP TABLE x;
RESET client_min_messages;
RESET SESSION AUTHORIZATION;
DROP ROLE regress_publication_user, regress_publication_user2;
DROP ROLE regress_publication_user_dummy;
/* RANDOM */ /* Test random() and allies */ /* Tests in this file may have a small probability of failure, */ /* since we are dealing with randomness.  Try to keep the failure */ /* risk for any one test case under 1e-9. */ /* There should be no duplicates in 1000 random() values. */ /* (Assuming 52 random bits in the float8 results, we could */ /* take as many as 3000 values and still have less than 1e-9 chance */ /* of failure, per https://en.wikipedia.org/wiki/Birthday_problem) */ SELECT x, COUNT(*) FROM (SELECT RAND() AS x FROM x) AS x GROUP BY x HAVING COUNT(*) > 1;
/* The range should be [0, 1).  We can expect that at least one out of 2000 */ /* random values is in the lowest or highest 1% of the range with failure */ /* probability less than about 1e-9. */ SELECT COUNT(*) FILTER(WHERE x < 0 OR x >= 1) AS x, (COUNT(*) FILTER(WHERE x < 0.01)) > 0 AS x, (COUNT(*) FILTER(WHERE x > 0.99)) > 0 AS x FROM (SELECT RAND() AS x FROM x) AS x;
x AS x /* Critical value for 99.9% confidence */;
BEGIN ok := (     WITH samples AS (       SELECT random() r FROM generate_series(1, n) ORDER BY 1     ), indexed_samples AS (       SELECT (row_number() OVER())-1.0 i, r FROM samples     )     SELECT max(abs(i/n-r)) < c / sqrt(n) FROM indexed_samples   );
x AS x;
/* As written, ks_test_uniform_random() returns true about 99.9% */ /* of the time.  To get down to a roughly 1e-9 test failure rate, */ /* just run it 3 times and accept if any one of them passes. */ SELECT KS_TEST_UNIFORM_RANDOM() OR KS_TEST_UNIFORM_RANDOM() OR KS_TEST_UNIFORM_RANDOM() AS x;
/* now test random_normal() */ /* As above, there should be no duplicates in 1000 random_normal() values. */ SELECT x, COUNT(*) FROM (SELECT RANDOM_NORMAL() AS x FROM x) AS x GROUP BY x HAVING COUNT(*) > 1;
/* ... unless we force the range (standard deviation) to zero. */ /* This is a good place to check that the mean input does something, too. */ SELECT x, COUNT(*) FROM (SELECT RANDOM_NORMAL(10, 0) AS x FROM x) AS x GROUP BY x;
SELECT x, COUNT(*) FROM (SELECT RANDOM_NORMAL(-10, 0) AS x FROM x) AS x GROUP BY x;
x AS x /* Critical value for 99.9% confidence */;
BEGIN ok := (     WITH samples AS (       SELECT random_normal() r FROM generate_series(1, n) ORDER BY 1     ), indexed_samples AS (       SELECT (row_number() OVER())-1.0 i, r FROM samples     )     SELECT max(abs((1+erf(r/sqrt(2)))/2 - i/n)) < c / sqrt(n)     FROM indexed_samples   );
x AS x;
/* As above, ks_test_normal_random() returns true about 99.9% */ /* of the time, so try it 3 times and accept if any test passes. */ SELECT KS_TEST_NORMAL_RANDOM() OR KS_TEST_NORMAL_RANDOM() OR KS_TEST_NORMAL_RANDOM() AS x;
/* Test random(min, max) */ /* invalid range bounds */ SELECT RAND(1);
SELECT RAND(1000000000001);
SELECT RAND(-2.0);
SELECT RAND(CAST('NaN' AS DECIMAL));
SELECT RAND(CAST('-Inf' AS DECIMAL));
SELECT RAND(0);
SELECT RAND(0);
/* empty range is OK */ SELECT RAND(101);
SELECT RAND(1000000000001);
SELECT RAND(3.14);
/* There should be no triple duplicates in 1000 full-range 32-bit random() */ /* values.  (Each of the C(1000, 3) choices of triplets from the 1000 values */ /* has a probability of 1/(2^32)^2 of being a triple duplicate, so the */ /* average number of triple duplicates is 1000 * 999 * 998 / 6 / 2^64, which */ /* is roughly 9e-12.) */ SELECT x, COUNT(*) FROM (SELECT RAND(-2147483648) AS x FROM x) AS x GROUP BY x HAVING COUNT(*) > 2;
/* There should be no duplicates in 1000 full-range 64-bit random() values. */ SELECT x, COUNT(*) FROM (SELECT RANDOM_NORMAL(-9223372036854775808, 9223372036854775807) AS x FROM x) AS x GROUP BY x HAVING COUNT(*) > 1;
/* There should be no duplicates in 1000 15-digit random() numeric values. */ SELECT x, COUNT(*) FROM (SELECT RANDOM_NORMAL(0, 1 - 1e-15) AS x FROM x) AS x GROUP BY x HAVING COUNT(*) > 1;
/* Expect at least one out of 2000 random values to be in the lowest and */ /* highest 1% of the range. */ SELECT (COUNT(*) FILTER(WHERE x < -2104533975)) > 0 AS x, (COUNT(*) FILTER(WHERE x > 2104533974)) > 0 AS x FROM (SELECT RAND(-2147483648) AS x FROM x) AS x;
SELECT COUNT(*) FILTER(WHERE x < -1500000000 OR x > 1500000000) AS x, (COUNT(*) FILTER(WHERE x < -1470000000)) > 0 AS x, (COUNT(*) FILTER(WHERE x > 1470000000)) > 0 AS x FROM (SELECT RAND(-1500000000) AS x FROM x) AS x;
SELECT (COUNT(*) FILTER(WHERE x < -9038904596117680292)) > 0 AS x, (COUNT(*) FILTER(WHERE x > 9038904596117680291)) > 0 AS x FROM (SELECT RAND(-9223372036854775808) AS x FROM x) AS x;
SELECT COUNT(*) FILTER(WHERE x < -1500000000000000 OR x > 1500000000000000) AS x, (COUNT(*) FILTER(WHERE x < -1470000000000000)) > 0 AS x, (COUNT(*) FILTER(WHERE x > 1470000000000000)) > 0 AS x FROM (SELECT RAND(-1500000000000000) AS x FROM x) AS x;
SELECT COUNT(*) FILTER(WHERE x < -1.5 OR x > 1.5) AS x, (COUNT(*) FILTER(WHERE x < -1.47)) > 0 AS x, (COUNT(*) FILTER(WHERE x > 1.47)) > 0 AS x FROM (SELECT RAND(-1.500000000000000) AS x FROM x) AS x;
/* Every possible value should occur at least once in 2500 random() values */ /* chosen from a range with 100 distinct values. */ SELECT MIN(x), MAX(x), COUNT(x) FROM (SELECT DISTINCT RAND(-50) AS x FROM x);
SELECT MIN(x), MAX(x), COUNT(x) FROM (SELECT DISTINCT RAND(123000000000) AS x FROM x);
SELECT MIN(x), MAX(x), COUNT(x) FROM (SELECT DISTINCT RAND(-0.5) AS x FROM x);
x AS x /* Critical value for 99.9% confidence */;
BEGIN ok := (     WITH samples AS (       SELECT random(0, 999999) / 1000000.0 r FROM generate_series(1, n) ORDER BY 1     ), indexed_samples AS (       SELECT (row_number() OVER())-1.0 i, r FROM samples     )     SELECT max(abs(i/n-r)) < c / sqrt(n) FROM indexed_samples   );
x AS x;
SELECT KS_TEST_UNIFORM_RANDOM_INT_IN_RANGE() OR KS_TEST_UNIFORM_RANDOM_INT_IN_RANGE() OR KS_TEST_UNIFORM_RANDOM_INT_IN_RANGE() AS x;
x AS x /* Critical value for 99.9% confidence */;
BEGIN ok := (     WITH samples AS (       SELECT random(0, 999999999999) / 1000000000000.0 r FROM generate_series(1, n) ORDER BY 1     ), indexed_samples AS (       SELECT (row_number() OVER())-1.0 i, r FROM samples     )     SELECT max(abs(i/n-r)) < c / sqrt(n) FROM indexed_samples   );
x AS x;
SELECT KS_TEST_UNIFORM_RANDOM_BIGINT_IN_RANGE() OR KS_TEST_UNIFORM_RANDOM_BIGINT_IN_RANGE() OR KS_TEST_UNIFORM_RANDOM_BIGINT_IN_RANGE() AS x;
x AS x /* Critical value for 99.9% confidence */;
BEGIN ok := (     WITH samples AS (       SELECT random(0, 0.999999) r FROM generate_series(1, n) ORDER BY 1     ), indexed_samples AS (       SELECT (row_number() OVER())-1.0 i, r FROM samples     )     SELECT max(abs(i/n-r)) < c / sqrt(n) FROM indexed_samples   );
x AS x;
SELECT KS_TEST_UNIFORM_RANDOM_NUMERIC_IN_RANGE() OR KS_TEST_UNIFORM_RANDOM_NUMERIC_IN_RANGE() OR KS_TEST_UNIFORM_RANDOM_NUMERIC_IN_RANGE() AS x;
/* setseed() should produce a reproducible series of random() values. */ SELECT SETSEED(0.5);
SELECT RAND() FROM x;
SELECT RANDOM_NORMAL() FROM x;
SELECT RANDOM_NORMAL(mean => 1, stddev => 0.1) AS x FROM x;
/* Reproducible random(min, max) values. */ SELECT RAND(1) FROM x;
SELECT RAND(-2147483648) FROM x;
SELECT RAND(-9223372036854775808) FROM x;
SELECT RAND(-1e30) FROM x;
SELECT RAND(-0.4) FROM x;
SELECT RAND(0) FROM x;
SELECT x, RAND(0) FROM x AS x;
CREATE TABLE x (x INT, x INT);
INSERT INTO x VALUES (1, 11);
INSERT INTO x VALUES (2, 22);
INSERT INTO x VALUES (1, 111);
/* function with ORDINALITY */ SELECT * FROM x WITH ORDINALITY AS x;
SELECT * FROM x WITH ORDINALITY AS x WHERE x > 100;
/* ordinal 2, not 1 */ /* ordinality vs. column names and types */ SELECT x, x, x FROM x WITH ORDINALITY AS x;
SELECT x, x FROM UNNEST(ARRAY('a', 'b')) WITH ORDINALITY AS x(x);
SELECT * FROM UNNEST(ARRAY('a', 'b')) WITH ORDINALITY AS x(x);
SELECT x, x FROM UNNEST(ARRAY(CAST(1.0 AS DOUBLE))) WITH ORDINALITY AS x(x);
SELECT * FROM UNNEST(ARRAY(CAST(1.0 AS DOUBLE))) WITH ORDINALITY AS x(x);
SELECT ROW_TO_JSON(x.*) FROM x WITH ORDINALITY AS x;
/* ordinality vs. views */ CREATE TEMPORARY VIEW x AS SELECT * FROM (VALUES (1)) AS x JOIN x WITH ORDINALITY AS x ON (x = x);
SELECT * FROM x;
SELECT x FROM x WHERE x = 'vw_ord';
DROP VIEW x;
/* multiple functions */ SELECT * FROM ROWS FROM (x, x) WITH ORDINALITY AS x;
CREATE TEMPORARY VIEW x AS SELECT * FROM (VALUES (1)) AS x JOIN ROWS FROM (x, x) WITH ORDINALITY AS x ON (x = x);
SELECT * FROM x;
SELECT x FROM x WHERE x = 'vw_ord';
DROP VIEW x;
/* expansions of unnest() */ SELECT * FROM UNNEST(ARRAY(10, 20), ARRAY('foo', 'bar'), ARRAY(1.0));
SELECT * FROM UNNEST(ARRAY(10, 20), ARRAY('foo', 'bar'), ARRAY(1.0)) WITH ORDINALITY AS x(x);
SELECT * FROM ROWS FROM (UNNEST(ARRAY(10, 20), ARRAY('foo', 'bar'), ARRAY(1.0))) WITH ORDINALITY AS x;
SELECT * FROM ROWS FROM (UNNEST(ARRAY(10, 20), ARRAY('foo', 'bar')), x) WITH ORDINALITY AS x;
CREATE TEMPORARY VIEW x AS SELECT * FROM UNNEST(ARRAY(10, 20), ARRAY('foo', 'bar'), ARRAY(1.0)) AS x;
SELECT * FROM x;
SELECT x FROM x WHERE x = 'vw_ord';
DROP VIEW x;
CREATE TEMPORARY VIEW x AS SELECT * FROM ROWS FROM (UNNEST(ARRAY(10, 20), ARRAY('foo', 'bar'), ARRAY(1.0))) AS x;
SELECT * FROM x;
SELECT x FROM x WHERE x = 'vw_ord';
DROP VIEW x;
CREATE TEMPORARY VIEW x AS SELECT * FROM ROWS FROM (UNNEST(ARRAY(10, 20), ARRAY('foo', 'bar')), x) AS x;
SELECT * FROM x;
SELECT x FROM x WHERE x = 'vw_ord';
DROP VIEW x;
/* ordinality and multiple functions vs. rewind and reverse scan */ BEGIN;
DECLARE rf_cur scroll cursor for select * from rows from(generate_series(1,5),generate_series(1,2)) with ordinality as g(i,j,o);
FETCH all from rf_cur;
FETCH backward all from rf_cur;
FETCH all from rf_cur;
FETCH next from rf_cur;
FETCH next from rf_cur;
FETCH prior from rf_cur;
FETCH absolute 1 from rf_cur;
FETCH next from rf_cur;
FETCH next from rf_cur;
FETCH next from rf_cur;
FETCH prior from rf_cur;
FETCH prior from rf_cur;
FETCH prior from rf_cur;
COMMIT;
/* function with implicit LATERAL */ SELECT * FROM x, x AS x WHERE x.x = x.x;
/* function with implicit LATERAL and explicit ORDINALITY */ SELECT * FROM x, x WITH ORDINALITY AS x WHERE x.x = x.x;
/* function in subselect */ SELECT * FROM x WHERE x IN (SELECT x FROM x AS x WHERE x.x = x.x) ORDER BY 1 NULLS LAST, 2 NULLS LAST;
/* function in subselect */ SELECT * FROM x WHERE x IN (SELECT x FROM x AS x WHERE x.x = x.x) ORDER BY 1 NULLS LAST, 2 NULLS LAST;
/* function in subselect */ SELECT * FROM x WHERE x IN (SELECT x FROM x AS x WHERE x.x = 1) ORDER BY 1 NULLS LAST, 2 NULLS LAST;
/* nested functions */ SELECT x.x, x.x FROM x ORDER BY 1 NULLS LAST, 2 NULLS LAST;
CREATE TABLE x (x INT, x INT, x TEXT, PRIMARY KEY (x NULLS LAST, x NULLS LAST));
INSERT INTO x VALUES (1, 1, 'Joe');
INSERT INTO x VALUES (1, 2, 'Ed');
INSERT INTO x VALUES (2, 1, 'Mary');
SELECT * FROM x AS x;
SELECT * FROM x WITH ORDINALITY AS x;
CREATE VIEW x AS SELECT * FROM x;
SELECT * FROM x;
DROP VIEW x;
CREATE VIEW x AS SELECT * FROM x WITH ORDINALITY AS x;
SELECT * FROM x;
DROP VIEW x;
SELECT * FROM x AS x;
SELECT * FROM x WITH ORDINALITY AS x;
CREATE VIEW x AS SELECT * FROM x;
SELECT * FROM x;
DROP VIEW x;
CREATE VIEW x AS SELECT * FROM x WITH ORDINALITY AS x;
SELECT * FROM x;
DROP VIEW x;
SELECT * FROM x AS x;
SELECT * FROM x WITH ORDINALITY AS x;
CREATE VIEW x AS SELECT * FROM x;
SELECT * FROM x;
DROP VIEW x;
CREATE VIEW x AS SELECT * FROM x WITH ORDINALITY AS x;
SELECT * FROM x;
DROP VIEW x;
SELECT * FROM x AS x;
SELECT * FROM x WITH ORDINALITY AS x;
CREATE VIEW x AS SELECT * FROM x;
SELECT * FROM x;
DROP VIEW x;
CREATE VIEW x AS SELECT * FROM x WITH ORDINALITY AS x;
SELECT * FROM x;
DROP VIEW x;
SELECT * FROM x AS x;
SELECT * FROM x WITH ORDINALITY AS x;
CREATE VIEW x AS SELECT * FROM x;
SELECT * FROM x;
DROP VIEW x;
CREATE VIEW x AS SELECT * FROM x WITH ORDINALITY AS x;
SELECT * FROM x;
DROP VIEW x;
SELECT * FROM x AS x;
SELECT * FROM ROWS FROM (x AS _t0) WITH ORDINALITY;
CREATE VIEW x AS SELECT * FROM x AS _t0;
SELECT * FROM x;
DROP VIEW x;
CREATE VIEW x AS SELECT * FROM ROWS FROM (x AS _t0) WITH ORDINALITY;
SELECT * FROM x;
DROP VIEW x;
SELECT * FROM x AS x;
SELECT * FROM ROWS FROM (x AS _t0) WITH ORDINALITY;
CREATE VIEW x AS SELECT * FROM x AS _t0;
SELECT * FROM x;
DROP VIEW x;
CREATE VIEW x AS SELECT * FROM ROWS FROM (x AS _t0) WITH ORDINALITY;
SELECT * FROM x;
DROP VIEW x;
BEGIN SELECT rngfuncid into rngfuncint FROM rngfunc WHERE rngfuncid = $1;
x AS x;
COMMIT;
SELECT * FROM x AS x;
SELECT * FROM x WITH ORDINALITY AS x;
CREATE VIEW x AS SELECT * FROM x;
SELECT * FROM x;
DROP VIEW x;
CREATE VIEW x AS SELECT * FROM x WITH ORDINALITY AS x;
SELECT * FROM x;
DROP VIEW x;
BEGIN SELECT * into rngfunctup FROM rngfunc WHERE rngfuncid = $1;
x AS x;
COMMIT;
SELECT * FROM x AS x;
SELECT * FROM x WITH ORDINALITY AS x;
CREATE VIEW x AS SELECT * FROM x;
SELECT * FROM x;
DROP VIEW x;
CREATE VIEW x AS SELECT * FROM x WITH ORDINALITY AS x;
SELECT * FROM x;
DROP VIEW x;
/* mix 'n match kinds, to exercise expandRTE and related logic */ SELECT * FROM ROWS FROM (x, x, x, x, x, x AS _t0, x AS _t1, x, x) WITH ORDINALITY AS x;
SELECT * FROM ROWS FROM (x, x, x AS _t0, x AS _t1, x, x, x, x, x) WITH ORDINALITY AS x;
CREATE TEMPORARY VIEW x AS SELECT * FROM ROWS FROM (x, x AS _t0, x) WITH ORDINALITY AS x;
SELECT * FROM x;
SELECT PG_GET_VIEWDEF('vw_rngfunc');
DROP VIEW x;
DROP FUNCTION x (INT);
DROP FUNCTION x (INT);
DROP FUNCTION x (INT);
DROP FUNCTION x (INT);
DROP FUNCTION x (INT);
DROP FUNCTION x (INT);
DROP FUNCTION x (INT);
DROP FUNCTION x (INT);
DROP FUNCTION x (INT);
DROP FUNCTION x (INT);
DROP TABLE x;
DROP TABLE x;
/* Rescan tests -- */ CREATE TEMPORARY SEQUENCE x;
CREATE TEMPORARY SEQUENCE x;
CREATE TYPE rngfunc_rescan_t AS (i integer, s bigint);
COMMIT;
/* invokes ExecReScanFunctionScan - all these cases should materialize the function only once */ /* LEFT JOIN on a condition that the planner can't prove to be true is used to ensure the function */ /* is on the inner path of a nestloop join */ SELECT SETVAL('rngfunc_rescan_seq1', 1, FALSE), SETVAL('rngfunc_rescan_seq2', 1, FALSE);
SELECT * FROM (VALUES (1), (2), (3)) AS x LEFT JOIN x ON (x + x) < 100;
SELECT SETVAL('rngfunc_rescan_seq1', 1, FALSE), SETVAL('rngfunc_rescan_seq2', 1, FALSE);
SELECT * FROM (VALUES (1), (2), (3)) AS x LEFT JOIN x WITH ORDINALITY AS x ON (x + x) < 100;
SELECT SETVAL('rngfunc_rescan_seq1', 1, FALSE), SETVAL('rngfunc_rescan_seq2', 1, FALSE);
SELECT * FROM (VALUES (1), (2), (3)) AS x LEFT JOIN x ON (x + x) < 100;
SELECT SETVAL('rngfunc_rescan_seq1', 1, FALSE), SETVAL('rngfunc_rescan_seq2', 1, FALSE);
SELECT * FROM (VALUES (1), (2), (3)) AS x LEFT JOIN x WITH ORDINALITY AS x ON (x + x) < 100;
SELECT SETVAL('rngfunc_rescan_seq1', 1, FALSE), SETVAL('rngfunc_rescan_seq2', 1, FALSE);
SELECT * FROM (VALUES (1), (2), (3)) AS x LEFT JOIN ROWS FROM (x, x) WITH ORDINALITY AS x ON (x + x + x) < 100;
SELECT * FROM (VALUES (1), (2), (3)) AS x LEFT JOIN x AS x ON (x + x) < 100;
SELECT * FROM (VALUES (1), (2), (3)) AS x LEFT JOIN x WITH ORDINALITY AS x ON (x + x) < 100;
SELECT * FROM (VALUES (1), (2), (3)) AS x LEFT JOIN UNNEST(ARRAY(10, 20, 30)) AS x ON (x + x) < 100;
SELECT * FROM (VALUES (1), (2), (3)) AS x LEFT JOIN UNNEST(ARRAY(10, 20, 30)) WITH ORDINALITY AS x(x) ON (x + x) < 100;
/* invokes ExecReScanFunctionScan with chgParam != NULL (using implied LATERAL) */ SELECT SETVAL('rngfunc_rescan_seq1', 1, FALSE), SETVAL('rngfunc_rescan_seq2', 1, FALSE);
SELECT * FROM (VALUES (1), (2), (3)) AS x, x;
SELECT SETVAL('rngfunc_rescan_seq1', 1, FALSE), SETVAL('rngfunc_rescan_seq2', 1, FALSE);
SELECT * FROM (VALUES (1), (2), (3)) AS x, x WITH ORDINALITY AS x;
SELECT SETVAL('rngfunc_rescan_seq1', 1, FALSE), SETVAL('rngfunc_rescan_seq2', 1, FALSE);
SELECT * FROM (VALUES (1), (2), (3)) AS x, x;
SELECT SETVAL('rngfunc_rescan_seq1', 1, FALSE), SETVAL('rngfunc_rescan_seq2', 1, FALSE);
SELECT * FROM (VALUES (1), (2), (3)) AS x, x WITH ORDINALITY AS x;
SELECT SETVAL('rngfunc_rescan_seq1', 1, FALSE), SETVAL('rngfunc_rescan_seq2', 1, FALSE);
SELECT * FROM (VALUES (11, 12), (13, 15), (16, 20)) AS x, x;
SELECT SETVAL('rngfunc_rescan_seq1', 1, FALSE), SETVAL('rngfunc_rescan_seq2', 1, FALSE);
SELECT * FROM (VALUES (11, 12), (13, 15), (16, 20)) AS x, x WITH ORDINALITY AS x;
SELECT SETVAL('rngfunc_rescan_seq1', 1, FALSE), SETVAL('rngfunc_rescan_seq2', 1, FALSE);
SELECT * FROM (VALUES (1), (2), (3)) AS x, x;
SELECT SETVAL('rngfunc_rescan_seq1', 1, FALSE), SETVAL('rngfunc_rescan_seq2', 1, FALSE);
SELECT * FROM (VALUES (1), (2), (3)) AS x, x WITH ORDINALITY AS x;
SELECT SETVAL('rngfunc_rescan_seq1', 1, FALSE), SETVAL('rngfunc_rescan_seq2', 1, FALSE);
SELECT * FROM (VALUES (1), (2), (3)) AS x, x;
SELECT SETVAL('rngfunc_rescan_seq1', 1, FALSE), SETVAL('rngfunc_rescan_seq2', 1, FALSE);
SELECT * FROM (VALUES (1), (2), (3)) AS x, x WITH ORDINALITY AS x;
SELECT SETVAL('rngfunc_rescan_seq1', 1, FALSE), SETVAL('rngfunc_rescan_seq2', 1, FALSE);
SELECT * FROM (VALUES (11, 12), (13, 15), (16, 20)) AS x, x;
SELECT SETVAL('rngfunc_rescan_seq1', 1, FALSE), SETVAL('rngfunc_rescan_seq2', 1, FALSE);
SELECT * FROM (VALUES (11, 12), (13, 15), (16, 20)) AS x, x WITH ORDINALITY AS x;
/* selective rescan of multiple functions: */ SELECT SETVAL('rngfunc_rescan_seq1', 1, FALSE), SETVAL('rngfunc_rescan_seq2', 1, FALSE);
SELECT * FROM (VALUES (1), (2), (3)) AS x, ROWS FROM (x, x);
SELECT SETVAL('rngfunc_rescan_seq1', 1, FALSE), SETVAL('rngfunc_rescan_seq2', 1, FALSE);
SELECT * FROM (VALUES (1), (2), (3)) AS x, ROWS FROM (x, x);
SELECT SETVAL('rngfunc_rescan_seq1', 1, FALSE), SETVAL('rngfunc_rescan_seq2', 1, FALSE);
SELECT * FROM (VALUES (1), (2), (3)) AS x, ROWS FROM (x, x);
SELECT SETVAL('rngfunc_rescan_seq1', 1, FALSE), SETVAL('rngfunc_rescan_seq2', 1, FALSE);
SELECT * FROM x AS x, x AS x, ROWS FROM (x, x);
SELECT * FROM (VALUES (1), (2), (3)) AS x, x AS x;
SELECT * FROM (VALUES (1), (2), (3)) AS x, x WITH ORDINALITY AS x;
SELECT * FROM (VALUES (1), (2), (3)) AS x, UNNEST(ARRAY(x * 10, x * 20, x * 30)) AS x;
SELECT * FROM (VALUES (1), (2), (3)) AS x, UNNEST(ARRAY(x * 10, x * 20, x * 30)) WITH ORDINALITY AS x(x);
/* deep nesting */ SELECT * FROM (VALUES (1), (2), (3)) AS x, LATERAL (SELECT x, * FROM (VALUES (10), (20), (30)) AS x LEFT JOIN x AS x ON ((x + x) < 100) OFFSET 0) AS x;
SELECT * FROM (VALUES (1), (2), (3)) AS x, LATERAL (SELECT x, * FROM (VALUES (10), (20), (30)) AS x LEFT JOIN x AS x ON ((x + x) < 100) OFFSET 0) AS x;
SELECT * FROM (VALUES (1), (2), (3)) AS x, LATERAL (SELECT x, * FROM (VALUES (10), (20), (30)) AS x LEFT JOIN x AS x ON ((x + x) < 100) OFFSET 0) AS x;
SELECT * FROM (VALUES (1), (2), (3)) AS x, LATERAL (SELECT x, * FROM (VALUES (10), (20), (30)) AS x LEFT JOIN x AS x ON ((x + x) < 100) OFFSET 0) AS x;
/* check handling of FULL JOIN with multiple lateral references (bug #15741) */ SELECT * FROM (VALUES (1), (2)) AS x LEFT JOIN LATERAL (SELECT * FROM x AS x LEFT JOIN LATERAL (SELECT * FROM x AS x LEFT JOIN x AS x ON TRUE) AS x ON TRUE FULL JOIN x AS x ON FALSE) AS x ON TRUE;
DROP FUNCTION x (INT, INT);
DROP FUNCTION x (INT, INT);
DROP SEQUENCE x;
DROP SEQUENCE x;
SELECT RNGFUNC(42);
SELECT * FROM x;
SELECT * FROM x AS x;
SELECT x, RNGFUNCR(x) FROM x;
SELECT * FROM x;
SELECT * FROM x AS x;
SELECT x, RNGFUNCB(x, x / 2) FROM x;
SELECT * FROM x;
SELECT * FROM x AS x;
/* Can reference function with or without OUT params for DROP, etc */ DROP FUNCTION x (INT);
SELECT DUP(22);
SELECT DUP('xyz');
/* fails */ SELECT DUP(CAST('xyz' AS TEXT));
SELECT * FROM x;
DROP FUNCTION x (anyelement);
SELECT DUP(22);
DROP FUNCTION x (anyelement);
SELECT DUP(22, ARRAY(44));
SELECT DUP(4.5, ARRAY(44));
SELECT DUP(22, ARRAY(CAST(44 AS BIGINT)));
SELECT *, PG_TYPEOF(x), PG_TYPEOF(x) FROM x;
SELECT DUP(INT4RANGE(4, 7));
SELECT DUP(NUMRANGE(4, 7));
SELECT DUP(TEXTRANGE('aaa', 'bbb'));
/* table functions */ CREATE OR REPLACE FUNCTION x() RETURNS TABLE (x INT) LANGUAGE sql AS $$ SELECT a FROM generate_series(1,5) a(a) $$;
SELECT * FROM x;
DROP FUNCTION x;
CREATE OR REPLACE FUNCTION x(x) RETURNS TABLE (x INT, x INT) LANGUAGE sql AS $$ SELECT a, b          FROM generate_series(1,$1) a(a),               generate_series(1,$1) b(b) $$;
SELECT * FROM x;
DROP FUNCTION x (INT);
/* case that causes change of typmod knowledge during inlining */ CREATE OR REPLACE FUNCTION x() RETURNS TABLE (x VARCHAR(5)) LANGUAGE sql STABLE AS $$ SELECT 'hello'::varchar(5) $$;
SELECT * FROM x GROUP BY 1;
DROP FUNCTION x;
/* some tests on SQL functions with RETURNING */ CREATE TEMPORARY TABLE x (x SERIAL, x TEXT);
CREATE FUNCTION x(x) RETURNS INT LANGUAGE sql AS $$ insert into tt(data) values($1) returning f1 $$;
SELECT INSERT_TT('foo');
SELECT INSERT_TT('bar');
SELECT * FROM x;
/* insert will execute to completion even if function needs just 1 row */ CREATE OR REPLACE FUNCTION x(x) RETURNS INT LANGUAGE sql AS $$ insert into tt(data) values($1),($1||$1) returning f1 $$;
SELECT INSERT_TT('fool');
SELECT * FROM x;
/* setof does what's expected */ create or replace function insert_tt2(text,text) returns setof int as $$ insert into tt(data) values($1),($2) returning f1 $$ language sql;
SELECT INSERT_TT2('foolish', 'barrish');
SELECT * FROM x;
SELECT * FROM x;
/* limit doesn't prevent execution to completion */ SELECT INSERT_TT2('foolish', 'barrish') LIMIT 1;
SELECT * FROM x;
x AS x;
create trigger tnoticetrigger after insert on tt for each row execute procedure noticetrigger();
SELECT INSERT_TT2('foolme', 'barme') LIMIT 1;
SELECT * FROM x;
/* and rules work */ CREATE TEMPORARY TABLE x (x INT, x TEXT);
create rule insert_tt_rule as on insert to tt do also   insert into tt_log values(new.*);
SELECT INSERT_TT2('foollog', 'barlog') LIMIT 1;
SELECT * FROM x;
/* note that nextval() gets executed a second time in the rule expansion, */ /* which is expected. */ SELECT * FROM x;
SET x = '64kB';
SELECT x.x, x, x.x FROM x AS x LIMIT 1;
RESET work_mem;
SELECT x.x, x, x.x FROM x AS x LIMIT 1;
/* test use of SQL functions returning record */ /* this is supported in some cases where the query doesn't specify */ /* the actual record type ... */ create function array_to_set(anyarray) returns setof record as $$   select i AS "index", $1[i] AS "value" from generate_subscripts($1, 1) i $$ language sql strict immutable;
SELECT ARRAY_TO_SET(ARRAY('one', 'two'));
SELECT * FROM x AS x;
SELECT * FROM x;
/* fail */ /* after-the-fact coercion of the columns is now possible, too */ SELECT * FROM x AS x;
/* and if it doesn't work, you get a compile-time not run-time error */ SELECT * FROM x AS x;
/* with "strict", this function can't be inlined in FROM */ EXPLAIN (verbose, costs off)   select * from array_to_set(array['one', 'two']) as t(f1 numeric(4,2),f2 text);
/* but without, it can be: */ create or replace function array_to_set(anyarray) returns setof record as $$   select i AS "index", $1[i] AS "value" from generate_subscripts($1, 1) i $$ language sql immutable;
SELECT ARRAY_TO_SET(ARRAY('one', 'two'));
SELECT * FROM x AS x;
SELECT * FROM x AS x;
SELECT * FROM x AS x;
EXPLAIN (verbose, costs off)   select * from array_to_set(array['one', 'two']) as t(f1 numeric(4,2),f2 text);
CREATE TEMPORARY TABLE x (x BIGINT, x BIGINT);
SELECT TESTRNGFUNC();
SELECT * FROM x AS x;
SELECT * FROM x;
/* fail */ DROP FUNCTION x;
SELECT TESTRNGFUNC();
SELECT * FROM x AS x;
SELECT * FROM x;
/* fail */ DROP FUNCTION x;
/* Check that typmod imposed by a composite type is honored */ create type rngfunc_type as (f1 numeric(35,6), f2 numeric(35,2));
EXPLAIN (verbose, costs off) select testrngfunc();
SELECT TESTRNGFUNC();
EXPLAIN (verbose, costs off) select * from testrngfunc();
SELECT * FROM x;
EXPLAIN (verbose, costs off) select testrngfunc();
SELECT TESTRNGFUNC();
EXPLAIN (verbose, costs off) select * from testrngfunc();
SELECT * FROM x;
DROP FUNCTION x;
EXPLAIN (verbose, costs off) select testrngfunc();
SELECT TESTRNGFUNC();
EXPLAIN (verbose, costs off) select * from testrngfunc();
SELECT * FROM x;
EXPLAIN (verbose, costs off) select testrngfunc();
SELECT TESTRNGFUNC();
EXPLAIN (verbose, costs off) select * from testrngfunc();
SELECT * FROM x;
EXPLAIN (verbose, costs off) select testrngfunc();
SELECT TESTRNGFUNC();
EXPLAIN (verbose, costs off) select * from testrngfunc();
SELECT * FROM x;
/* Check a couple of error cases while we're here */ SELECT * FROM x AS x;
/* fail, composite result */ SELECT * FROM x AS x;
/* fail, OUT params */ SELECT * FROM x AS x;
/* fail, scalar result type */ drop type rngfunc_type cascade;
/* Check some cases involving added/dropped columns in a rowtype result */ CREATE TEMPORARY TABLE x (x TEXT, x INT, x TEXT, x BOOLEAN, x INT, x BOOLEAN);
INSERT INTO x VALUES ('id', 1, 'email', TRUE, 11, TRUE);
INSERT INTO x VALUES ('id2', 2, 'email2', TRUE, 12, TRUE);
ALTER TABLE x DROP COLUMN x;
SELECT GET_FIRST_USER();
SELECT * FROM x;
SELECT GET_USERS();
SELECT * FROM x;
SELECT * FROM x WITH ORDINALITY;
/* make sure ordinality copes */ /* multiple functions vs. dropped columns */ SELECT * FROM ROWS FROM (x, x) WITH ORDINALITY;
SELECT * FROM ROWS FROM (x, x) WITH ORDINALITY;
/* check that we can cope with post-parsing changes in rowtypes */ CREATE TEMPORARY VIEW x AS SELECT * FROM ROWS FROM (x, x) WITH ORDINALITY;
SELECT * FROM x;
ALTER TABLE x ADD COLUMN x TEXT;
SELECT * FROM x;
ALTER TABLE x DROP COLUMN x;
/* fail, view has reference */ /* We used to have a bug that would allow the above to succeed, posing */ /* hazards for later execution of the view.  Check that the internal */ /* defenses for those hazards haven't bit-rotted, in case some other */ /* bug with similar symptoms emerges. */ BEGIN;
/* destroy the dependency entry that prevents the DROP: */ DELETE FROM x WHERE x = (SELECT x FROM x WHERE x = CAST('usersview' AS REGCLASS) AND x = '_RETURN') AND x = 5 RETURNING PG_DESCRIBE_OBJECT(x, x, x) AS x, PG_DESCRIBE_OBJECT(x, x, x) AS x, x;
ALTER TABLE x DROP COLUMN x;
SELECT * FROM x;
ROLLBACK /* expect clean failure */ /* expect clean failure */;
ALTER TABLE x ALTER COLUMN x SET DATA TYPE DECIMAL;
/* fail, view has reference */ /* likewise, check we don't crash if the dependency goes wrong */ BEGIN;
/* destroy the dependency entry that prevents the ALTER: */ DELETE FROM x WHERE x = (SELECT x FROM x WHERE x = CAST('usersview' AS REGCLASS) AND x = '_RETURN') AND x = 2 RETURNING PG_DESCRIBE_OBJECT(x, x, x) AS x, PG_DESCRIBE_OBJECT(x, x, x) AS x, x;
ALTER TABLE x ALTER COLUMN x SET DATA TYPE DECIMAL;
SELECT * FROM x;
ROLLBACK /* expect clean failure */ /* expect clean failure */;
DROP VIEW x;
DROP FUNCTION x;
DROP FUNCTION x;
DROP TABLE x;
SELECT RNGFUNCBAR();
SELECT * FROM x;
/* this function is now inlinable, too: */ EXPLAIN (verbose, costs off) select * from rngfuncbar();
DROP FUNCTION x;
/* check handling of a SQL function with multiple OUT params (bug #5777) */ CREATE OR REPLACE FUNCTION x(x INT, x DECIMAL) LANGUAGE sql AS $$ select (1, 2.1) $$;
SELECT * FROM x;
CREATE OR REPLACE FUNCTION x(x INT, x DECIMAL) LANGUAGE sql AS $$ select (1, 2) $$;
SELECT * FROM x;
/* fail */ CREATE OR REPLACE FUNCTION x(x INT, x DECIMAL) LANGUAGE sql AS $$ select (1, 2.1, 3) $$;
SELECT * FROM x;
/* fail */ DROP FUNCTION x;
/* check whole-row-Var handling in nested lateral functions (bug #11703) */ CREATE FUNCTION x(x int8_tbl) RETURNS BIGINT LANGUAGE sql IMMUTABLE AS $$   select t.q2 $$;
EXPLAIN (verbose, costs off) select x from int8_tbl, extractq2(int8_tbl) f(x);
SELECT x FROM x, x AS x;
CREATE FUNCTION x(x int8_tbl) RETURNS TABLE (x BIGINT) LANGUAGE sql IMMUTABLE AS $$   select extractq2(t) offset 0 $$;
EXPLAIN (verbose, costs off) select x from int8_tbl, extractq2_2(int8_tbl) f(x);
SELECT x FROM x, x AS x;
/* without the "offset 0", this function gets optimized quite differently */ CREATE FUNCTION x(x int8_tbl) RETURNS TABLE (x BIGINT) LANGUAGE sql IMMUTABLE AS $$   select extractq2(t) $$;
EXPLAIN (verbose, costs off) select x from int8_tbl, extractq2_2_opt(int8_tbl) f(x);
SELECT x FROM x, x AS x;
/* check handling of nulls in SRF results (bug #7808) */ create type rngfunc2 as (a integer, b text);
SELECT *, ROW_TO_JSON(x) FROM UNNEST(ARRAY(CAST((1, 'foo') AS rngfunc2), CAST(NULL AS rngfunc2))) AS x;
SELECT *, ROW_TO_JSON(x) FROM UNNEST(ARRAY(CAST(NULL AS rngfunc2), CAST(NULL AS rngfunc2))) AS x;
SELECT *, ROW_TO_JSON(x) FROM UNNEST(ARRAY(CAST(NULL AS rngfunc2), CAST((1, 'foo') AS rngfunc2), CAST(NULL AS rngfunc2))) AS x;
SELECT *, ROW_TO_JSON(x) FROM UNNEST(CAST(ARRAY() AS ARRAY<rngfunc2>)) AS x;
drop type rngfunc2;
/* check handling of functions pulled up into function RTEs (bug #17227) */ EXPLAIN (verbose, costs off) select * from   (select jsonb_path_query_array(module->'lectures', '$[*]') as lecture    from unnest(array['{"lectures": [{"id": "1"}]}'::jsonb])         as unnested_modules(module)) as ss,   jsonb_to_recordset(ss.lecture) as j (id text);
SELECT * FROM (SELECT JSONB_PATH_QUERY_ARRAY(x -> 'lectures', '$[*]') AS x FROM UNNEST(ARRAY(CAST('{"lectures": [{"id": "1"}]}' AS JSONB))) AS x) AS x, x AS x;
/* check detection of mismatching record types with a const-folded expression */ WITH x AS (SELECT * FROM (VALUES (ROW(1, 2, 3))) AS x) SELECT * FROM x, x AS x;
/* fail */ WITH x AS (SELECT * FROM (VALUES (ROW(1, 2, 3))) AS x) SELECT * FROM x, x AS x;
/* fail */ WITH x AS (SELECT * FROM (VALUES (ROW(1, 2, 3))) AS x) SELECT * FROM x, x AS x;
/* fail */ SELECT * FROM x, x AS _t0;
SELECT CAST('-[a,z)' AS textrange);
SELECT CAST('[a,z) - ' AS textrange);
SELECT CAST('(",a)' AS textrange);
SELECT CAST('(,,a)' AS textrange);
SELECT CAST('(),a)' AS textrange);
SELECT CAST('(a,))' AS textrange);
SELECT CAST('(],a)' AS textrange);
SELECT CAST('(a,])' AS textrange);
SELECT CAST('[z,a]' AS textrange);
/* should succeed */ SELECT CAST('  empty  ' AS textrange);
SELECT CAST(' ( empty, empty )  ' AS textrange);
SELECT CAST(' ( " a " " a ", " z " " z " )  ' AS textrange);
SELECT CAST('(a,)' AS textrange);
SELECT CAST('[,z]' AS textrange);
SELECT CAST('[a,]' AS textrange);
SELECT CAST('(,)' AS textrange);
SELECT CAST('[ , ]' AS textrange);
SELECT CAST('["",""]' AS textrange);
SELECT CAST('[",",","]' AS textrange);
SELECT CAST('["\\","\\"]' AS textrange);
SELECT CAST('(\\,a)' AS textrange);
SELECT CAST('((,z)' AS textrange);
SELECT CAST('([,z)' AS textrange);
SELECT CAST('(!,()' AS textrange);
SELECT CAST('(!,[)' AS textrange);
SELECT CAST('[a,a]' AS textrange);
/* these are allowed but normalize to empty: */ SELECT CAST('[a,a)' AS textrange);
SELECT CAST('(a,a]' AS textrange);
SELECT CAST('(a,a)' AS textrange);
/* Also try it with non-error-throwing API */ SELECT PG_INPUT_IS_VALID('(1,4)', 'int4range');
SELECT PG_INPUT_IS_VALID('(1,4', 'int4range');
SELECT * FROM x;
SELECT PG_INPUT_IS_VALID('(4,1)', 'int4range');
SELECT * FROM x;
SELECT PG_INPUT_IS_VALID('(4,zed)', 'int4range');
SELECT * FROM x;
SELECT PG_INPUT_IS_VALID('[1,2147483647]', 'int4range');
SELECT * FROM x;
SELECT PG_INPUT_IS_VALID('[2000-01-01,5874897-12-31]', 'daterange');
SELECT * FROM x;
/* create some test data and test the operators */ CREATE TABLE x (x NUMRANGE);
CREATE INDEX x ON x(x NULLS LAST);
INSERT INTO x VALUES ('[,)');
INSERT INTO x VALUES ('[3,]');
INSERT INTO x VALUES ('[, 5)');
INSERT INTO x VALUES (NUMRANGE(1.1, 2.2));
INSERT INTO x VALUES ('empty');
INSERT INTO x VALUES (NUMRANGE(1.7, 1.7, '[]'));
SELECT x, ISEMPTY(x), LOWER(x), UPPER(x) FROM x;
SELECT x, LOWER_INC(x), LOWER_INF(x), UPPER_INC(x), UPPER_INF(x) FROM x;
SELECT * FROM x WHERE RANGE_CONTAINS(x, NUMRANGE(1.9, 1.91));
SELECT * FROM x WHERE x @> NUMRANGE(1.0, 10000.1);
SELECT * FROM x WHERE RANGE_CONTAINED_BY(NUMRANGE(-1e7, -10000.1), x);
SELECT * FROM x WHERE x @> 1.9;
SELECT * FROM x WHERE x = 'empty';
SELECT * FROM x WHERE x = '(1.1, 2.2)';
SELECT * FROM x WHERE x = '[1.1, 2.2)';
SELECT * FROM x WHERE x < 'empty';
SELECT * FROM x WHERE x < NUMRANGE(-1000.0, -1000.0, '[]');
SELECT * FROM x WHERE x < NUMRANGE(0.0, 1.0, '[]');
SELECT * FROM x WHERE x < NUMRANGE(1000.0, 1001.0, '[]');
SELECT * FROM x WHERE x <= 'empty';
SELECT * FROM x WHERE x >= 'empty';
SELECT * FROM x WHERE x > 'empty';
SELECT * FROM x WHERE x > NUMRANGE(-1001.0, -1000.0, '[]');
SELECT * FROM x WHERE x > NUMRANGE(0.0, 1.0, '[]');
SELECT * FROM x WHERE x > NUMRANGE(1000.0, 1000.0, '[]');
SELECT NUMRANGE(2.0, 1.0);
SELECT RANGE_ADJACENT(NUMRANGE(2.0, 3.0), NUMRANGE(3.1, 4.0));
SELECT RANGE_ADJACENT(NUMRANGE(2.0, 3.0), NUMRANGE(3.1, NULL));
SELECT RANGE_ADJACENT(NUMRANGE(2.0, 3.0, '(]'), NUMRANGE(1.0, 2.0, '(]'));
SELECT NUMRANGE(0.1, 10.1) @> NUMRANGE(1.1, 3.3);
SELECT NUMRANGE(1.1, 3.3) @> NUMRANGE(0.1, 10.1);
SELECT NUMRANGE(1.1, 2.2) - NUMRANGE(2.0, 3.0);
SELECT NUMRANGE(1.1, 2.2) - NUMRANGE(2.2, 3.0);
SELECT NUMRANGE(1.1, 2.2, '[]') - NUMRANGE(2.0, 3.0);
SELECT RANGE_MINUS(NUMRANGE(10.1, 12.2, '[]'), NUMRANGE(110.0, 120.2, '(]'));
SELECT RANGE_MINUS(NUMRANGE(10.1, 12.2, '[]'), NUMRANGE(0.0, 120.2, '(]'));
SELECT NUMRANGE(4.5, 5.5, '[]') && NUMRANGE(5.5, 6.5);
SELECT NUMRANGE(1.0, 2.0) << NUMRANGE(3.0, 4.0);
SELECT NUMRANGE(1.0, 3.0, '[]') << NUMRANGE(3.0, 4.0, '[]');
SELECT NUMRANGE(1.0, 3.0, '()') << NUMRANGE(3.0, 4.0, '()');
SELECT NUMRANGE(1.0, 2.0) >> NUMRANGE(3.0, 4.0);
SELECT NUMRANGE(1.1, 2.2) < NUMRANGE(1.0, 200.2);
SELECT NUMRANGE(1.1, 2.2) < NUMRANGE(1.1, 1.2);
SELECT NUMRANGE(1.0, 2.0) + NUMRANGE(2.0, 3.0);
SELECT NUMRANGE(1.0, 2.0) + NUMRANGE(1.5, 3.0);
SELECT NUMRANGE(1.0, 2.0) + NUMRANGE(2.5, 3.0);
/* should fail */ SELECT RANGE_MERGE(NUMRANGE(1.0, 2.0), NUMRANGE(2.0, 3.0));
SELECT RANGE_MERGE(NUMRANGE(1.0, 2.0), NUMRANGE(1.5, 3.0));
SELECT RANGE_MERGE(NUMRANGE(1.0, 2.0), NUMRANGE(2.5, 3.0));
/* shouldn't fail */ SELECT NUMRANGE(1.0, 2.0) * NUMRANGE(2.0, 3.0);
SELECT NUMRANGE(1.0, 2.0) * NUMRANGE(1.5, 3.0);
SELECT NUMRANGE(1.0, 2.0) * NUMRANGE(2.5, 3.0);
SELECT RANGE_INTERSECT_AGG(x) FROM x;
SELECT RANGE_INTERSECT_AGG(x) FROM x WHERE FALSE;
SELECT RANGE_INTERSECT_AGG(x) FROM x WHERE x @> 4.0;
ANALYZE x;
CREATE TABLE x (x NUMRANGE);
CREATE INDEX x ON x USING hash(x NULLS LAST);
INSERT INTO x VALUES ('[, 5)');
INSERT INTO x VALUES (NUMRANGE(1.1, 2.2));
INSERT INTO x VALUES (NUMRANGE(1.1, 2.2));
INSERT INTO x VALUES (NUMRANGE(1.1, 2.2, '()'));
INSERT INTO x VALUES ('empty');
SELECT * FROM x WHERE x = CAST('empty' AS NUMRANGE);
SELECT * FROM x WHERE x = NUMRANGE(1.1, 2.2);
SELECT * FROM x WHERE x = NUMRANGE(1.1, 2.3);
SET x = t;
SET x = f;
SET x = f;
SELECT * FROM x NATURAL JOIN x ORDER BY x NULLS LAST;
SET x = f;
SET x = t;
SET x = f;
SELECT * FROM x NATURAL JOIN x ORDER BY x NULLS LAST;
SET x = f;
SET x = f;
SET x = t;
SELECT * FROM x NATURAL JOIN x ORDER BY x NULLS LAST;
SET x = default;
SET x = default;
SET x = default;
/* keep numrange_test around to help exercise dump/reload */ DROP TABLE x;
/* Apply a subset of the above tests on a collatable type, too */ CREATE TABLE x (x textrange);
CREATE INDEX x ON x(x NULLS LAST);
INSERT INTO x VALUES ('[,)');
INSERT INTO x VALUES ('["a",]');
INSERT INTO x VALUES ('[,"q")');
INSERT INTO x VALUES (TEXTRANGE('b', 'g'));
INSERT INTO x VALUES ('empty');
INSERT INTO x VALUES (TEXTRANGE('d', 'd', '[]'));
SELECT x, ISEMPTY(x), LOWER(x), UPPER(x) FROM x;
SELECT x, LOWER_INC(x), LOWER_INF(x), UPPER_INC(x), UPPER_INF(x) FROM x;
SELECT * FROM x WHERE RANGE_CONTAINS(x, TEXTRANGE('f', 'fx'));
SELECT * FROM x WHERE x @> TEXTRANGE('a', 'z');
SELECT * FROM x WHERE RANGE_CONTAINED_BY(TEXTRANGE('0', '9'), x);
SELECT * FROM x WHERE x @> CAST('e' AS TEXT);
SELECT * FROM x WHERE x = 'empty';
SELECT * FROM x WHERE x = '("b","g")';
SELECT * FROM x WHERE x = '["b","g")';
SELECT * FROM x WHERE x < 'empty';
/* test canonical form for int4range */ SELECT INT4RANGE(1, 10, '[]');
SELECT INT4RANGE(1, 10, '[)');
SELECT INT4RANGE(1, 10, '(]');
SELECT INT4RANGE(1, 10, '()');
SELECT INT4RANGE(1, 2, '()');
/* test canonical form for daterange */ SELECT DATERANGE(CAST('2000-01-10' AS DATE), CAST('2000-01-20' AS DATE), '[]');
SELECT DATERANGE(CAST('2000-01-10' AS DATE), CAST('2000-01-20' AS DATE), '[)');
SELECT DATERANGE(CAST('2000-01-10' AS DATE), CAST('2000-01-20' AS DATE), '(]');
SELECT DATERANGE(CAST('2000-01-10' AS DATE), CAST('2000-01-20' AS DATE), '()');
SELECT DATERANGE(CAST('2000-01-10' AS DATE), CAST('2000-01-11' AS DATE), '()');
SELECT DATERANGE(CAST('2000-01-10' AS DATE), CAST('2000-01-11' AS DATE), '(]');
SELECT DATERANGE(CAST('-infinity' AS DATE), CAST('2000-01-01' AS DATE), '()');
SELECT DATERANGE(CAST('-infinity' AS DATE), CAST('2000-01-01' AS DATE), '[)');
SELECT DATERANGE(CAST('2000-01-01' AS DATE), CAST('infinity' AS DATE), '[)');
SELECT DATERANGE(CAST('2000-01-01' AS DATE), CAST('infinity' AS DATE), '[]');
/* test GiST index that's been built incrementally */ CREATE TABLE x (x INT4RANGE);
CREATE INDEX x ON x USING gist(x NULLS LAST);
INSERT INTO x SELECT INT4RANGE(x, x + 10) FROM x AS x;
INSERT INTO x SELECT CAST('empty' AS INT4RANGE) FROM x AS x;
INSERT INTO x SELECT INT4RANGE(x, x + 10000) FROM x AS x;
INSERT INTO x SELECT CAST('empty' AS INT4RANGE) FROM x AS x;
INSERT INTO x SELECT INT4RANGE(NULL, x * 10, '(]') FROM x AS x;
INSERT INTO x SELECT INT4RANGE(x * 10, NULL, '(]') FROM x AS x;
INSERT INTO x SELECT INT4RANGE(x, x + 10) FROM x AS x;
ANALYZE x /* test statistics and selectivity estimation as well */ /* We don't check the accuracy of selectivity estimation, but at least check */ /* it doesn't fall. */;
SET x = t /* first, verify non-indexed results */;
SET x = f;
SET x = f;
SELECT COUNT(*) FROM x WHERE x @> CAST('empty' AS INT4RANGE);
SELECT COUNT(*) FROM x WHERE x = INT4RANGE(10, 20);
SELECT COUNT(*) FROM x WHERE x @> 10;
SELECT COUNT(*) FROM x WHERE x @> INT4RANGE(10, 20);
SELECT COUNT(*) FROM x WHERE x && INT4RANGE(10, 20);
SELECT COUNT(*) FROM x WHERE INT4RANGE(10, 50) @> x;
SELECT COUNT(*) FROM x WHERE x << INT4RANGE(100, 500);
SELECT COUNT(*) FROM x WHERE x >> INT4RANGE(100, 500);
SELECT COUNT(*) FROM x WHERE x @> CAST('{}' AS INT4MULTIRANGE);
SELECT COUNT(*) FROM x WHERE x @> INT4MULTIRANGE(INT4RANGE(10, 20), INT4RANGE(30, 40));
SELECT COUNT(*) FROM x WHERE x && CAST('{(10,20),(30,40),(50,60)}' AS INT4MULTIRANGE);
SELECT COUNT(*) FROM x WHERE CAST('{(10,30),(40,60),(70,90)}' AS INT4MULTIRANGE) @> x;
SELECT COUNT(*) FROM x WHERE x << INT4MULTIRANGE(INT4RANGE(100, 200), INT4RANGE(400, 500));
SELECT COUNT(*) FROM x WHERE x >> INT4MULTIRANGE(INT4RANGE(100, 200), INT4RANGE(400, 500));
SET x = f /* now check same queries using index */;
SET x = t;
SET x = f;
SELECT COUNT(*) FROM x WHERE x @> CAST('empty' AS INT4RANGE);
SELECT COUNT(*) FROM x WHERE x = INT4RANGE(10, 20);
SELECT COUNT(*) FROM x WHERE x @> 10;
SELECT COUNT(*) FROM x WHERE x @> INT4RANGE(10, 20);
SELECT COUNT(*) FROM x WHERE x && INT4RANGE(10, 20);
SELECT COUNT(*) FROM x WHERE INT4RANGE(10, 50) @> x;
SELECT COUNT(*) FROM x WHERE x << INT4RANGE(100, 500);
SELECT COUNT(*) FROM x WHERE x >> INT4RANGE(100, 500);
SELECT COUNT(*) FROM x WHERE x @> CAST('{}' AS INT4MULTIRANGE);
SELECT COUNT(*) FROM x WHERE x @> INT4MULTIRANGE(INT4RANGE(10, 20), INT4RANGE(30, 40));
SELECT COUNT(*) FROM x WHERE x && CAST('{(10,20),(30,40),(50,60)}' AS INT4MULTIRANGE);
SELECT COUNT(*) FROM x WHERE CAST('{(10,30),(40,60),(70,90)}' AS INT4MULTIRANGE) @> x;
SELECT COUNT(*) FROM x WHERE x << INT4MULTIRANGE(INT4RANGE(100, 200), INT4RANGE(400, 500));
SELECT COUNT(*) FROM x WHERE x >> INT4MULTIRANGE(INT4RANGE(100, 200), INT4RANGE(400, 500));
/* now check same queries using a bulk-loaded index */ DROP INDEX x;
CREATE INDEX x ON x USING gist(x NULLS LAST);
SELECT COUNT(*) FROM x WHERE x @> CAST('empty' AS INT4RANGE);
SELECT COUNT(*) FROM x WHERE x = INT4RANGE(10, 20);
SELECT COUNT(*) FROM x WHERE x @> 10;
SELECT COUNT(*) FROM x WHERE x @> INT4RANGE(10, 20);
SELECT COUNT(*) FROM x WHERE x && INT4RANGE(10, 20);
SELECT COUNT(*) FROM x WHERE INT4RANGE(10, 50) @> x;
SELECT COUNT(*) FROM x WHERE x << INT4RANGE(100, 500);
SELECT COUNT(*) FROM x WHERE x >> INT4RANGE(100, 500);
SELECT COUNT(*) FROM x WHERE x @> CAST('{}' AS INT4MULTIRANGE);
SELECT COUNT(*) FROM x WHERE x @> INT4MULTIRANGE(INT4RANGE(10, 20), INT4RANGE(30, 40));
SELECT COUNT(*) FROM x WHERE x && CAST('{(10,20),(30,40),(50,60)}' AS INT4MULTIRANGE);
SELECT COUNT(*) FROM x WHERE CAST('{(10,30),(40,60),(70,90)}' AS INT4MULTIRANGE) @> x;
SELECT COUNT(*) FROM x WHERE x << INT4MULTIRANGE(INT4RANGE(100, 200), INT4RANGE(400, 500));
SELECT COUNT(*) FROM x WHERE x >> INT4MULTIRANGE(INT4RANGE(100, 200), INT4RANGE(400, 500));
/* test SP-GiST index that's been built incrementally */ CREATE TABLE x (x INT4RANGE);
CREATE INDEX x ON x USING spgist(x NULLS LAST);
INSERT INTO x SELECT INT4RANGE(x, x + 10) FROM x AS x;
INSERT INTO x SELECT CAST('empty' AS INT4RANGE) FROM x AS x;
INSERT INTO x SELECT INT4RANGE(x, x + 10000) FROM x AS x;
INSERT INTO x SELECT CAST('empty' AS INT4RANGE) FROM x AS x;
INSERT INTO x SELECT INT4RANGE(NULL, x * 10, '(]') FROM x AS x;
INSERT INTO x SELECT INT4RANGE(x * 10, NULL, '(]') FROM x AS x;
INSERT INTO x SELECT INT4RANGE(x, x + 10) FROM x AS x;
SET x = t /* first, verify non-indexed results */;
SET x = f;
SET x = f;
SELECT COUNT(*) FROM x WHERE x @> CAST('empty' AS INT4RANGE);
SELECT COUNT(*) FROM x WHERE x = INT4RANGE(10, 20);
SELECT COUNT(*) FROM x WHERE x @> 10;
SELECT COUNT(*) FROM x WHERE x @> INT4RANGE(10, 20);
SELECT COUNT(*) FROM x WHERE x && INT4RANGE(10, 20);
SELECT COUNT(*) FROM x WHERE INT4RANGE(10, 50) @> x;
SELECT COUNT(*) FROM x WHERE x << INT4RANGE(100, 500);
SELECT COUNT(*) FROM x WHERE x >> INT4RANGE(100, 500);
SET x = f /* now check same queries using index */;
SET x = t;
SET x = f;
SELECT COUNT(*) FROM x WHERE x @> CAST('empty' AS INT4RANGE);
SELECT COUNT(*) FROM x WHERE x = INT4RANGE(10, 20);
SELECT COUNT(*) FROM x WHERE x @> 10;
SELECT COUNT(*) FROM x WHERE x @> INT4RANGE(10, 20);
SELECT COUNT(*) FROM x WHERE x && INT4RANGE(10, 20);
SELECT COUNT(*) FROM x WHERE INT4RANGE(10, 50) @> x;
SELECT COUNT(*) FROM x WHERE x << INT4RANGE(100, 500);
SELECT COUNT(*) FROM x WHERE x >> INT4RANGE(100, 500);
/* now check same queries using a bulk-loaded index */ DROP INDEX x;
CREATE INDEX x ON x USING spgist(x NULLS LAST);
SELECT COUNT(*) FROM x WHERE x @> CAST('empty' AS INT4RANGE);
SELECT COUNT(*) FROM x WHERE x = INT4RANGE(10, 20);
SELECT COUNT(*) FROM x WHERE x @> 10;
SELECT COUNT(*) FROM x WHERE x @> INT4RANGE(10, 20);
SELECT COUNT(*) FROM x WHERE x && INT4RANGE(10, 20);
SELECT COUNT(*) FROM x WHERE INT4RANGE(10, 50) @> x;
SELECT COUNT(*) FROM x WHERE x << INT4RANGE(100, 500);
SELECT COUNT(*) FROM x WHERE x >> INT4RANGE(100, 500);
/* test index-only scans */ EXPLAIN (costs off) select ir from test_range_spgist where ir -|- int4range(10,20) order by ir;
RESET enable_seqscan;
RESET enable_indexscan;
RESET enable_bitmapscan;
/* test elem <@ range operator */ CREATE TABLE x (x INT);
CREATE INDEX x ON x(x NULLS LAST);
INSERT INTO x SELECT x FROM x AS x;
SET x = f;
SELECT COUNT(*) FROM x WHERE INT4RANGE(10, 50) @> x;
/* also test spgist index on anyrange expression */ CREATE INDEX ON x USING spgist(INT4RANGE(x, x + 10) NULLS LAST);
EXPLAIN (costs off) select count(*) from test_range_elem where int4range(i,i+10) <@ int4range(10,30);
SELECT COUNT(*) FROM x WHERE INT4RANGE(10, 30) @> INT4RANGE(x, x + 10);
RESET enable_seqscan;
DROP TABLE x;
INSERT INTO x VALUES (INT4RANGE(123, 123, '[]'), INT4RANGE(1, 1, '[]'), '[2010-01-02 10:00, 2010-01-02 11:00)');
INSERT INTO x VALUES (INT4RANGE(123, 123, '[]'), INT4RANGE(2, 2, '[]'), '[2010-01-02 11:00, 2010-01-02 12:00)');
INSERT INTO x VALUES (INT4RANGE(123, 123, '[]'), INT4RANGE(3, 3, '[]'), '[2010-01-02 10:10, 2010-01-02 11:00)');
INSERT INTO x VALUES (INT4RANGE(124, 124, '[]'), INT4RANGE(3, 3, '[]'), '[2010-01-02 10:10, 2010-01-02 11:10)');
INSERT INTO x VALUES (INT4RANGE(125, 125, '[]'), INT4RANGE(1, 1, '[]'), '[2010-01-02 10:10, 2010-01-02 11:00)');
/* test bigint ranges */ SELECT INT8RANGE(CAST(10000000000 AS BIGINT), CAST(20000000000 AS BIGINT), '(]');
SET x = '-08' /* test tstz ranges */;
SELECT CAST('[2010-01-01 01:00:00 -05, 2010-01-01 02:00:00 -08)' AS TSTZRANGE);
/* should fail */ SELECT CAST('[2010-01-01 01:00:00 -08, 2010-01-01 02:00:00 -05)' AS TSTZRANGE);
SET x = default;
/* Test user-defined range of floats */ /* (type float8range was already made in test_setup.sql) */ /* should fail */ create type bogus_float8range as range (subtype=float8, subtype_diff=float4mi);
SELECT CAST('[123.001, 5.e9)' AS float8range) @> CAST(888.882 AS DOUBLE);
CREATE TABLE x (x float8range, x INT);
INSERT INTO x VALUES (FLOAT8RANGE(-100.00007, '1.111113e9'), 42);
SELECT * FROM x;
DROP TABLE x;
/* Test range types over domains */ create domain mydomain as int4;
create type mydomainrange as range(subtype=mydomain);
SELECT CAST('[4,50)' AS mydomainrange) @> CAST(7 AS mydomain);
drop domain mydomain;
/* fail */ drop domain mydomain cascade;
/* Test domains over range types */ create domain restrictedrange as int4range check (upper(value) < 10);
SELECT CAST('[4,5)' AS restrictedrange) @> 7;
SELECT CAST('[4,50)' AS restrictedrange) @> 7;
/* should fail */ drop domain restrictedrange;
/* Test multiple range types over the same subtype */ create type textrange1 as range(subtype=text, collation="C");
create type textrange2 as range(subtype=text, collation="C");
SELECT TEXTRANGE1('a', 'Z') @> CAST('b' AS TEXT);
SELECT TEXTRANGE2('a', 'z') @> CAST('b' AS TEXT);
drop type textrange1;
drop type textrange2;
SELECT ANYARRAY_ANYRANGE_FUNC(ARRAY(1, 2), INT4RANGE(10, 20));
/* should fail */ SELECT ANYARRAY_ANYRANGE_FUNC(ARRAY(1, 2), NUMRANGE(10, 20));
DROP FUNCTION x (anyarray, anyrange);
/* should fail */ CREATE FUNCTION x(x) RETURNS anyrange LANGUAGE sql AS 'select int4range(1,10)';
/* should fail */ CREATE FUNCTION x(x) RETURNS anyrange LANGUAGE sql AS 'select int4range(1,10)';
CREATE FUNCTION x(x) RETURNS anyelement LANGUAGE sql AS 'select lower($1) + upper($1)';
SELECT RANGE_ADD_BOUNDS(INT4RANGE(1, 17));
SELECT RANGE_ADD_BOUNDS(NUMRANGE(1.0001, 123.123));
SELECT RANGETYPES_SQL(INT4RANGE(1, 10), ARRAY(2, 20));
SELECT RANGETYPES_SQL(NUMRANGE(1, 10), ARRAY(2, 20));
SELECT ANYCOMPATIBLEARRAY_ANYCOMPATIBLERANGE_FUNC(ARRAY(1, 2), INT4RANGE(10, 20));
SELECT ANYCOMPATIBLEARRAY_ANYCOMPATIBLERANGE_FUNC(ARRAY(1, 2), NUMRANGE(10, 20));
/* should fail */ SELECT ANYCOMPATIBLEARRAY_ANYCOMPATIBLERANGE_FUNC(ARRAY(1.1, 2), INT4RANGE(10, 20));
DROP FUNCTION x (anycompatiblearray, anycompatiblerange);
/* should fail */ CREATE FUNCTION x(x) RETURNS anycompatiblerange LANGUAGE sql AS 'select int4range(1,10)';
/* Arrays of ranges */ SELECT ARRAY(NUMRANGE(1.1, 1.2), NUMRANGE(12.3, 155.5));
CREATE TABLE x (x INT, x ARRAY<INT8RANGE>);
INSERT INTO x VALUES (42, ARRAY(INT8RANGE(1, 10), INT8RANGE(2, 20)));
SELECT * FROM x;
DROP TABLE x;
/* Ranges of arrays */ create type arrayrange as range (subtype=int4[]);
SELECT ARRAYRANGE(ARRAY(1, 2), ARRAY(2, 1));
SELECT ARRAYRANGE(ARRAY(2, 1), ARRAY(1, 2));
/* fail */ SELECT ARRAYRANGE(ARRAY(1, 2), ARRAY(2, 1)) @> ARRAY(1, 1);
SELECT ARRAYRANGE(ARRAY(1, 2), ARRAY(2, 1)) @> ARRAY(1, 3);
/* Ranges of composites */ create type two_ints as (a int, b int);
create type two_ints_range as range (subtype = two_ints);
/* with debug_parallel_query on, this exercises tqueue.c's range remapping */ SELECT *, ROW_TO_JSON(UPPER(x)) AS x FROM (VALUES (TWO_INTS_RANGE(ROW(1, 2), ROW(3, 4))), (TWO_INTS_RANGE(ROW(5, 6), ROW(7, 8)))) AS x;
/* this must be rejected to avoid self-inclusion issues: */ alter type two_ints add attribute c two_ints_range;
drop type two_ints cascade;
/* Check behavior when subtype lacks a hash function */ create type varbitrange as range (subtype = varbit);
SET x = off;
/* try to make it pick a hash setop implementation */ SELECT CAST('(01,10)' AS varbitrange) EXCEPT SELECT CAST('(10,11)' AS varbitrange);
RESET enable_sort;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
CREATE FUNCTION x(x anyrange) RETURNS TABLE (x anyelement, x anyelement) LANGUAGE sql AS $$ select lower($1), upper($1) $$;
SELECT * FROM x;
/* should fail */ CREATE FUNCTION x(x anyelement) RETURNS TABLE (x anyelement, x anyrange) LANGUAGE sql AS $$ select $1, '[1,10]' $$;
/* Test support functions */ /* empty range */ EXPLAIN (verbose, costs off) select current_date <@ daterange 'empty';
/* unbounded range */ EXPLAIN (verbose, costs off) select current_date <@ daterange(NULL, NULL);
/* only lower bound present */ EXPLAIN (verbose, costs off) select current_date <@ daterange('2000-01-01', NULL, '[)');
/* only upper bound present */ EXPLAIN (verbose, costs off) select current_date <@ daterange(NULL, '2000-01-01', '(]');
/* lower range "-Infinity" excluded */ EXPLAIN (verbose, costs off) select current_date <@ daterange('-Infinity', '1997-04-10'::date, '()');
/* lower range "-Infinity" included */ EXPLAIN (verbose, costs off) select current_date <@ daterange('-Infinity', '1997-04-10'::date, '[)');
/* upper range "Infinity" excluded */ EXPLAIN (verbose, costs off) select current_date <@ daterange('2002-09-25'::date, 'Infinity', '[)');
/* upper range "Infinity" included */ EXPLAIN (verbose, costs off) select current_date <@ daterange('2002-09-25'::date, 'Infinity', '[]');
/* should also work if we use "@>" */ EXPLAIN (verbose, costs off) select daterange('-Infinity', '1997-04-10'::date, '()') @> current_date;
EXPLAIN (verbose, costs off) select daterange('2002-09-25'::date, 'Infinity', '[]') @> current_date;
/* Check that volatile cases are not optimized */ EXPLAIN (verbose, costs off) select now() <@ tstzrange('2024-01-20 00:00', '2024-01-21 00:00');
EXPLAIN (verbose, costs off)  -- unsafe! select clock_timestamp() <@ tstzrange('2024-01-20 00:00', '2024-01-21 00:00');
EXPLAIN (verbose, costs off) select clock_timestamp() <@ tstzrange('2024-01-20 00:00', NULL);
/* test a custom range type with a non-default operator class */ create type textrange_supp as range (    subtype = text,    subtype_opclass = text_pattern_ops );
CREATE TEMPORARY TABLE x (x TEXT COLLATE "x");
INSERT INTO x VALUES ('a'), ('c'), ('d'), ('ch');
EXPLAIN (costs off) select * from text_support_test where t <@ textrange_supp('a', 'd');
SELECT * FROM x WHERE TEXTRANGE_SUPP('a', 'd') @> x;
DROP TABLE x;
drop type textrange_supp;
SET x = on /* Regular expression tests */ /* Don't want to have to double backslashes in regexes */;
/* Test simple quantified backrefs */ SELECT REGEXP_LIKE('bbbbb', '^([bc])\1*$') AS x;
SELECT REGEXP_LIKE('ccc', '^([bc])\1*$') AS x;
SELECT REGEXP_LIKE('xxx', '^([bc])\1*$') AS x;
SELECT REGEXP_LIKE('bbc', '^([bc])\1*$') AS x;
SELECT REGEXP_LIKE('b', '^([bc])\1*$') AS x;
/* Test quantified backref within a larger expression */ SELECT REGEXP_LIKE('abc abc abc', '^(\w+)( \1)+$') AS x;
SELECT REGEXP_LIKE('abc abd abc', '^(\w+)( \1)+$') AS x;
SELECT REGEXP_LIKE('abc abc abd', '^(\w+)( \1)+$') AS x;
SELECT REGEXP_LIKE('abc abc abc', '^(.+)( \1)+$') AS x;
SELECT REGEXP_LIKE('abc abd abc', '^(.+)( \1)+$') AS x;
SELECT REGEXP_LIKE('abc abc abd', '^(.+)( \1)+$') AS x;
/* Test some cases that crashed in 9.2beta1 due to pmatch[] array overrun */ SELECT SUBSTRING('asd TO foo', ' TO (([a-z0-9._]+|"([^"]+|"")+")+)');
SELECT SUBSTRING('a', '((a))+');
SELECT SUBSTRING('a', '((a)+)');
/* Test regexp_match() */ SELECT REGEXP_MATCH('abc', '');
SELECT REGEXP_MATCH('abc', 'bc');
SELECT REGEXP_MATCH('abc', 'd') IS NULL;
SELECT REGEXP_MATCH('abc', '(B)(c)', 'i');
SELECT REGEXP_MATCH('abc', 'Bd', 'ig');
/* error */ /* Test lookahead constraints */ SELECT REGEXP_MATCHES('ab', 'a(?=b)b*');
SELECT REGEXP_MATCHES('a', 'a(?=b)b*');
SELECT REGEXP_MATCHES('abc', 'a(?=b)b*(?=c)c*');
SELECT REGEXP_MATCHES('ab', 'a(?=b)b*(?=c)c*');
SELECT REGEXP_MATCHES('ab', 'a(?!b)b*');
SELECT REGEXP_MATCHES('a', 'a(?!b)b*');
SELECT REGEXP_MATCHES('b', '(?=b)b');
SELECT REGEXP_MATCHES('a', '(?=b)b');
/* Test lookbehind constraints */ SELECT REGEXP_MATCHES('abb', '(?<=a)b*');
SELECT REGEXP_MATCHES('a', 'a(?<=a)b*');
SELECT REGEXP_MATCHES('abc', 'a(?<=a)b*(?<=b)c*');
SELECT REGEXP_MATCHES('ab', 'a(?<=a)b*(?<=b)c*');
SELECT REGEXP_MATCHES('ab', 'a*(?<!a)b*');
SELECT REGEXP_MATCHES('ab', 'a*(?<!a)b+');
SELECT REGEXP_MATCHES('b', 'a*(?<!a)b+');
SELECT REGEXP_MATCHES('a', 'a(?<!a)b*');
SELECT REGEXP_MATCHES('b', '(?<=b)b');
SELECT REGEXP_MATCHES('foobar', '(?<=f)b+');
SELECT REGEXP_MATCHES('foobar', '(?<=foo)b+');
SELECT REGEXP_MATCHES('foobar', '(?<=oo)b+');
/* Test optimization of single-chr-or-bracket-expression lookaround constraints */ SELECT REGEXP_LIKE('xz', 'x(?=[xy])');
SELECT REGEXP_LIKE('xy', 'x(?=[xy])');
SELECT REGEXP_LIKE('xz', 'x(?![xy])');
SELECT REGEXP_LIKE('xy', 'x(?![xy])');
SELECT REGEXP_LIKE('x', 'x(?![xy])');
SELECT REGEXP_LIKE('xyy', '(?<=[xy])yy+');
SELECT REGEXP_LIKE('zyy', '(?<=[xy])yy+');
SELECT REGEXP_LIKE('xyy', '(?<![xy])yy+');
SELECT REGEXP_LIKE('zyy', '(?<![xy])yy+');
/* Test conversion of regex patterns to indexable conditions */ EXPLAIN (costs off) select * from pg_proc where proname ~ 'abc';
EXPLAIN (costs off) select * from pg_proc where proname ~ '^abc';
EXPLAIN (costs off) select * from pg_proc where proname ~ '^abc$';
EXPLAIN (costs off) select * from pg_proc where proname ~ '^abcd*e';
EXPLAIN (costs off) select * from pg_proc where proname ~ '^abc+d';
EXPLAIN (costs off) select * from pg_proc where proname ~ '^(abc)(def)';
EXPLAIN (costs off) select * from pg_proc where proname ~ '^(abc)$';
EXPLAIN (costs off) select * from pg_proc where proname ~ '^(abc)?d';
EXPLAIN (costs off) select * from pg_proc where proname ~ '^abcd(x|(?=\w\w)q)';
/* Test for infinite loop in pullback() (CVE-2007-4772) */ SELECT REGEXP_LIKE('a', '($|^)*');
/* These cases expose a bug in the original fix for CVE-2007-4772 */ SELECT REGEXP_LIKE('a', '(^)+^');
SELECT REGEXP_LIKE('a', '$($$)+');
/* More cases of infinite loop in pullback(), not fixed by CVE-2007-4772 fix */ SELECT REGEXP_LIKE('a', '($^)+');
SELECT REGEXP_LIKE('a', '(^$)*');
SELECT REGEXP_LIKE('aa bb cc', '(^(?!aa))+');
SELECT REGEXP_LIKE('aa x', '(^(?!aa)(?!bb)(?!cc))+');
SELECT REGEXP_LIKE('bb x', '(^(?!aa)(?!bb)(?!cc))+');
SELECT REGEXP_LIKE('cc x', '(^(?!aa)(?!bb)(?!cc))+');
SELECT REGEXP_LIKE('dd x', '(^(?!aa)(?!bb)(?!cc))+');
/* Test for infinite loop in fixempties() (Tcl bugs 3604074, 3606683) */ SELECT REGEXP_LIKE('a', '((((((a)*)*)*)*)*)*');
SELECT REGEXP_LIKE('a', '((((((a+|)+|)+|)+|)+|)+|)');
/* These cases used to give too-many-states failures */ SELECT REGEXP_LIKE('x', 'abcd(\m)+xyz');
SELECT REGEXP_LIKE('a', '^abcd*(((((^(a c(e?d)a+|)+|)+|)+|)+|a)+|)');
SELECT REGEXP_LIKE('x', 'a^(^)bcd*xy(((((($a+|)+|)+|)+$|)+|)+|)^$');
SELECT REGEXP_LIKE('x', 'xyz(\Y\Y)+');
SELECT REGEXP_LIKE('x', 'x|(?:\M)+');
/* This generates O(N) states but O(N^2) arcs, so it causes problems */ /* if arc count is not constrained */ SELECT REGEXP_LIKE('x', REPEAT('x*y*z*', 1000));
/* Test backref in combination with non-greedy quantifier */ /* https://core.tcl.tk/tcl/tktview/6585b21ca8fa6f3678d442b97241fdd43dba2ec0 */ SELECT REGEXP_LIKE('Programmer', '(\w).*?\1') AS x;
SELECT REGEXP_MATCHES('Programmer', '(\w)(.*?\1)', 'g');
/* Test for proper matching of non-greedy iteration (bug #11478) */ SELECT REGEXP_MATCHES('foo/bar/baz', '^([^/]+?)(?:/([^/]+?))(?:/([^/]+?))?$', '');
/* Test that greediness can be overridden by outer quantifier */ SELECT REGEXP_MATCHES('llmmmfff', '^(l*)(.*)(f*)$');
SELECT REGEXP_MATCHES('llmmmfff', '^(l*){1,1}(.*)(f*)$');
SELECT REGEXP_MATCHES('llmmmfff', '^(l*){1,1}?(.*)(f*)$');
SELECT REGEXP_MATCHES('llmmmfff', '^(l*){1,1}?(.*){1,1}?(f*)$');
SELECT REGEXP_MATCHES('llmmmfff', '^(l*?)(.*)(f*)$');
SELECT REGEXP_MATCHES('llmmmfff', '^(l*?){1,1}(.*)(f*)$');
SELECT REGEXP_MATCHES('llmmmfff', '^(l*?){1,1}?(.*)(f*)$');
SELECT REGEXP_MATCHES('llmmmfff', '^(l*?){1,1}?(.*){1,1}?(f*)$');
/* Test for infinite loop in cfindloop with zero-length possible match */ /* but no actual match (can only happen in the presence of backrefs) */ SELECT REGEXP_LIKE('a', '$()|^\1');
SELECT REGEXP_LIKE('a', '.. ()|\1');
SELECT REGEXP_LIKE('a', '()*\1');
SELECT REGEXP_LIKE('a', '()+\1');
/* Test incorrect removal of capture groups within {0} */ SELECT REGEXP_LIKE('xxx', '(.){0}(\1)') AS x;
SELECT REGEXP_LIKE('xxx', '((.)){0}(\2)') AS x;
SELECT REGEXP_LIKE('xyz', '((.)){0}(\2){0}') AS x;
/* Test ancient oversight in when to apply zaptreesubs */ SELECT REGEXP_LIKE('abcdef', '^(.)\1|\1.') AS x;
SELECT REGEXP_LIKE('abadef', '^((.)\2|..)\2') AS x;
/* Add coverage for some cases in checkmatchall */ SELECT REGEXP_MATCH('xy', '.|...');
SELECT REGEXP_MATCH('xyz', '.|...');
SELECT REGEXP_MATCH('xy', '.*');
SELECT REGEXP_MATCH('fooba', '(?:..)*');
SELECT REGEXP_MATCH('xyz', REPEAT('.', 260));
SELECT REGEXP_MATCH('foo', '(?:.|){99}');
/* Error conditions */ SELECT REGEXP_LIKE('xyz', 'x(\w)(?=\1)');
/* no backrefs in LACONs */ SELECT REGEXP_LIKE('xyz', 'x(\w)(?=(\1))');
SELECT REGEXP_LIKE('a', '\x7fffffff');
/* regproc */ /* If objects exist, return oids */ CREATE ROLE regress_regrole_test;
/* without schemaname */ SELECT REGOPER('||/');
SELECT REGOPERATOR('+(int4,int4)');
SELECT REGPROC('now');
SELECT REGPROCEDURE('abs(numeric)');
SELECT REGCLASS('pg_class');
SELECT REGTYPE('int4');
SELECT REGCOLLATION('"POSIX"');
SELECT TO_REGOPER('||/');
SELECT TO_REGOPERATOR('+(int4,int4)');
SELECT TO_REGPROC('now');
SELECT TO_REGPROCEDURE('abs(numeric)');
SELECT TO_REGCLASS('pg_class');
SELECT TO_REGTYPE('int4');
SELECT TO_REGCOLLATION('"POSIX"');
/* with schemaname */ SELECT REGOPER('pg_catalog.||/');
SELECT REGOPERATOR('pg_catalog.+(int4,int4)');
SELECT REGPROC('pg_catalog.now');
SELECT REGPROCEDURE('pg_catalog.abs(numeric)');
SELECT REGCLASS('pg_catalog.pg_class');
SELECT REGTYPE('pg_catalog.int4');
SELECT REGCOLLATION('pg_catalog."POSIX"');
SELECT TO_REGOPER('pg_catalog.||/');
SELECT TO_REGPROC('pg_catalog.now');
SELECT TO_REGPROCEDURE('pg_catalog.abs(numeric)');
SELECT TO_REGCLASS('pg_catalog.pg_class');
SELECT TO_REGTYPE('pg_catalog.int4');
SELECT TO_REGCOLLATION('pg_catalog."POSIX"');
/* schemaname not applicable */ SELECT REGROLE('regress_regrole_test');
SELECT REGROLE('"regress_regrole_test"');
SELECT REGNAMESPACE('pg_catalog');
SELECT REGNAMESPACE('"pg_catalog"');
SELECT TO_REGROLE('regress_regrole_test');
SELECT TO_REGROLE('"regress_regrole_test"');
SELECT TO_REGNAMESPACE('pg_catalog');
SELECT TO_REGNAMESPACE('"pg_catalog"');
/* If objects don't exist, raise errors. */ DROP ROLE regress_regrole_test;
/* without schemaname */ SELECT REGOPER('||//');
SELECT REGOPERATOR('++(int4,int4)');
SELECT REGPROC('know');
SELECT REGPROCEDURE('absinthe(numeric)');
SELECT REGCLASS('pg_classes');
SELECT REGTYPE('int3');
/* with schemaname */ SELECT REGOPER('ng_catalog.||/');
SELECT REGOPERATOR('ng_catalog.+(int4,int4)');
SELECT REGPROC('ng_catalog.now');
SELECT REGPROCEDURE('ng_catalog.abs(numeric)');
SELECT REGCLASS('ng_catalog.pg_class');
SELECT REGTYPE('ng_catalog.int4');
SELECT REGROLE('"regress_regrole_test"');
SELECT REGROLE('Nonexistent');
SELECT REGROLE('"Nonexistent"');
SELECT REGROLE('foo.bar');
SELECT REGNAMESPACE('Nonexistent');
SELECT REGNAMESPACE('"Nonexistent"');
SELECT REGNAMESPACE('foo.bar');
/* If objects don't exist, return NULL with no error. */ /* without schemaname */ SELECT TO_REGOPER('||//');
SELECT TO_REGOPERATOR('++(int4,int4)');
SELECT TO_REGPROC('know');
SELECT TO_REGPROCEDURE('absinthe(numeric)');
SELECT TO_REGCLASS('pg_classes');
SELECT TO_REGTYPE('int3');
SELECT TO_REGCOLLATION('notacollation');
/* with schemaname */ SELECT TO_REGOPER('ng_catalog.||/');
SELECT TO_REGOPERATOR('ng_catalog.+(int4,int4)');
SELECT TO_REGPROC('ng_catalog.now');
SELECT TO_REGPROCEDURE('ng_catalog.abs(numeric)');
SELECT TO_REGCLASS('ng_catalog.pg_class');
SELECT TO_REGTYPE('ng_catalog.int4');
SELECT TO_REGCOLLATION('ng_catalog."POSIX"');
/* schemaname not applicable */ SELECT TO_REGROLE('regress_regrole_test');
SELECT TO_REGROLE('"regress_regrole_test"');
SELECT TO_REGROLE('foo.bar');
SELECT TO_REGROLE('Nonexistent');
SELECT TO_REGROLE('"Nonexistent"');
SELECT TO_REGROLE('foo.bar');
SELECT TO_REGNAMESPACE('Nonexistent');
SELECT TO_REGNAMESPACE('"Nonexistent"');
SELECT TO_REGNAMESPACE('foo.bar');
/* Test to_regtypemod */ SELECT TO_REGTYPEMOD('text');
SELECT TO_REGTYPEMOD('timestamp(4)');
SELECT TO_REGTYPEMOD('no_such_type(4)');
SELECT FORMAT_TYPE(TO_REGTYPE('varchar(32)'), TO_REGTYPEMOD('varchar(32)'));
SELECT FORMAT_TYPE(TO_REGTYPE('bit'), TO_REGTYPEMOD('bit'));
SELECT FORMAT_TYPE(TO_REGTYPE('"bit"'), TO_REGTYPEMOD('"bit"'));
/* Test soft-error API */ SELECT * FROM x;
SELECT PG_INPUT_IS_VALID('ng_catalog."POSIX"', 'regcollation');
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
/* Some cases that should be soft errors, but are not yet */ SELECT * FROM x;
SELECT * FROM x;
/* bogus typmod */ SELECT * FROM x;
SELECT * FROM x;
/* Check that system tables can be reindexed. */ /* Note that this test currently is not included in the default */ /* schedules, as currently reindexing catalog tables can cause */ /* deadlocks: */ /* * The lock upgrade between the ShareLock acquired for the reindex */ /*   and RowExclusiveLock needed for pg_class/pg_index locks can */ /*   trigger deadlocks. */ /* * The uniqueness checks performed when reindexing a unique/primary */ /*   key index possibly need to wait for the transaction of a */ /*   about-to-deleted row in pg_class to commit. That can cause */ /*   deadlocks because, in contrast to user tables, locks on catalog */ /*   tables are routinely released before commit - therefore the lock */ /*   held for reindexing doesn't guarantee that no running transaction */ /*   performed modifications in the table underlying the index. */ /*   This is particularly problematic as such conflicts can be */ /*   triggered even when run in isolation, as a previous session's */ /*   temporary table cleanup might still be running (even when the */ /*   session ended from a client perspective). */ /* Check reindexing of whole tables */ REINDEX TABLE pg_class;
/* mapped, non-shared, critical */ REINDEX TABLE pg_index;
/* non-mapped, non-shared, critical */ REINDEX TABLE pg_operator;
/* non-mapped, non-shared, critical */ REINDEX TABLE pg_database;
/* mapped, shared, critical */ REINDEX TABLE pg_shdescription;
/* mapped, shared non-critical */ /* Check that individual system indexes can be reindexed. That's a bit */ /* different from the entire-table case because reindex_relation */ /* treats e.g. pg_class special. */ REINDEX INDEX pg_class_oid_index;
/* mapped, non-shared, critical */ REINDEX INDEX pg_class_relname_nsp_index;
/* mapped, non-shared, non-critical */ REINDEX INDEX pg_index_indexrelid_index;
/* non-mapped, non-shared, critical */ REINDEX INDEX pg_index_indrelid_index;
/* non-mapped, non-shared, non-critical */ REINDEX INDEX pg_database_oid_index;
/* mapped, shared, critical */ REINDEX INDEX pg_shdescription_o_c_index;
/* mapped, shared, non-critical */ /* Check the same REINDEX INDEX statements under parallelism. */ BEGIN;
SET x = 0;
REINDEX INDEX pg_class_oid_index;
/* mapped, non-shared, critical */ REINDEX INDEX pg_class_relname_nsp_index;
/* mapped, non-shared, non-critical */ REINDEX INDEX pg_index_indexrelid_index;
/* non-mapped, non-shared, critical */ REINDEX INDEX pg_index_indrelid_index;
/* non-mapped, non-shared, non-critical */ REINDEX INDEX pg_database_oid_index;
/* mapped, shared, critical */ REINDEX INDEX pg_shdescription_o_c_index;
ROLLBACK /* mapped, shared, non-critical */ /* mapped, shared, non-critical */;
/* Simple create */ CREATE TABLE x (x INT) WITH (FiLLFaCToR=30, autovacuum_enabled=FALSE, autovacuum_analyze_scale_factor=0.2);
SELECT x FROM x WHERE x = CAST('reloptions_test' AS REGCLASS);
/* Fail min/max values check */ CREATE TABLE x (x INT) WITH (fillfactor=2);
CREATE TABLE x (x INT) WITH (fillfactor=110);
CREATE TABLE x (x INT) WITH (autovacuum_analyze_scale_factor=-10.0);
CREATE TABLE x (x INT) WITH (autovacuum_analyze_scale_factor=110.0);
/* Fail when option and namespace do not exist */ CREATE TABLE x (x INT) WITH (not_existing_option=2);
CREATE TABLE x (x INT) WITH (x.x=2);
/* Fail while setting improper values */ CREATE TABLE x (x INT) WITH (fillfactor=-30.1);
CREATE TABLE x (x INT) WITH (fillfactor='string');
CREATE TABLE x (x INT) WITH (fillfactor=TRUE);
CREATE TABLE x (x INT) WITH (autovacuum_enabled=12);
CREATE TABLE x (x INT) WITH (autovacuum_enabled=30.5);
CREATE TABLE x (x INT) WITH (autovacuum_enabled='string');
CREATE TABLE x (x INT) WITH (autovacuum_analyze_scale_factor='string');
CREATE TABLE x (x INT) WITH (autovacuum_analyze_scale_factor=TRUE);
/* Fail if option is specified twice */ CREATE TABLE x (x INT) WITH (fillfactor=30, fillfactor=40);
ALTER TABLE x SET x = 31, x = 0.3 /* Simple ALTER TABLE */;
SELECT x FROM x WHERE x = CAST('reloptions_test' AS REGCLASS);
ALTER TABLE x SET x, x = 32 /* Set boolean option to true without specifying value */;
SELECT x FROM x WHERE x = CAST('reloptions_test' AS REGCLASS);
/* Check that RESET works well */ ALTER TABLE reloptions_test RESET (fillfactor);
SELECT x FROM x WHERE x = CAST('reloptions_test' AS REGCLASS);
/* Resetting all values causes the column to become null */ ALTER TABLE reloptions_test RESET (autovacuum_enabled, 	autovacuum_analyze_scale_factor);
SELECT x FROM x WHERE x = CAST('reloptions_test' AS REGCLASS) AND x IS NULL;
/* RESET fails if a value is specified */ ALTER TABLE reloptions_test RESET (fillfactor=12);
/* We can RESET an invalid option which for some reason is already set */ UPDATE x SET x = '{fillfactor=13,autovacuum_enabled=false,illegal_option=4}' WHERE x = CAST('reloptions_test' AS REGCLASS);
ALTER TABLE reloptions_test RESET (illegal_option);
SELECT x FROM x WHERE x = CAST('reloptions_test' AS REGCLASS);
/* Test vacuum_truncate option */ DROP TABLE x;
CREATE TEMPORARY TABLE x (x INT NOT NULL, x TEXT) WITH (vacuum_truncate=FALSE, x.x=FALSE, autovacuum_enabled=FALSE);
SELECT x FROM x WHERE x = CAST('reloptions_test' AS REGCLASS);
INSERT INTO x VALUES (1, NULL), (NULL, NULL);
/* Do an aggressive vacuum to prevent page-skipping. */ VACUUM (FREEZE, DISABLE_PAGE_SKIPPING) reloptions_test;
SELECT PG_RELATION_SIZE('reloptions_test') > 0;
SELECT x FROM x WHERE x = (SELECT x FROM x WHERE x = CAST('reloptions_test' AS REGCLASS));
ALTER TABLE reloptions_test RESET (vacuum_truncate);
SELECT x FROM x WHERE x = CAST('reloptions_test' AS REGCLASS);
INSERT INTO x VALUES (1, NULL), (NULL, NULL);
/* Do an aggressive vacuum to prevent page-skipping. */ VACUUM (FREEZE, DISABLE_PAGE_SKIPPING) reloptions_test;
SELECT PG_RELATION_SIZE('reloptions_test') = 0;
/* Test toast.* options */ DROP TABLE x;
CREATE TABLE x (x VARCHAR) WITH (x.x=23);
ALTER TABLE x SET x.x = 24;
SELECT x FROM x WHERE x = :toast_oid;
ALTER TABLE reloptions_test RESET (toast.autovacuum_vacuum_cost_delay);
SELECT x FROM x WHERE x = :toast_oid;
/* Fail on non-existent options in toast namespace */ CREATE TABLE x (x INT) WITH (x.x=42);
/* Mix TOAST & heap */ DROP TABLE x;
CREATE TABLE x (x VARCHAR) WITH (x.x=23, autovacuum_vacuum_cost_delay=24, fillfactor=40);
SELECT x FROM x WHERE x = CAST('reloptions_test' AS REGCLASS);
SELECT x FROM x WHERE x = (SELECT x FROM x WHERE x = CAST('reloptions_test' AS REGCLASS));
/* CREATE INDEX, ALTER INDEX for btrees */ CREATE INDEX x ON x(x NULLS LAST) WITH (fillfactor=30);
SELECT x FROM x WHERE x = CAST('reloptions_test_idx' AS REGCLASS);
/* Fail when option and namespace do not exist */ CREATE INDEX x ON x(x NULLS LAST) WITH (not_existing_option=2);
CREATE INDEX x ON x(x NULLS LAST) WITH (x.x=2);
/* Check allowed ranges */ CREATE INDEX x ON x(x NULLS LAST) WITH (fillfactor=1);
CREATE INDEX x ON x(x NULLS LAST) WITH (fillfactor=130);
ALTER INDEX x SET x = 40 /* Check ALTER */;
SELECT x FROM x WHERE x = CAST('reloptions_test_idx' AS REGCLASS);
/* Check ALTER on empty reloption list */ CREATE INDEX x ON x(x NULLS LAST);
ALTER INDEX x SET x = 40;
SELECT x FROM x WHERE x = CAST('reloptions_test_idx3' AS REGCLASS);
CREATE TABLE x (x SERIAL PRIMARY KEY);
CREATE INDEX x ON x(x NULLS LAST, x NULLS LAST);
CREATE UNIQUE INDEX x ON x(x NULLS LAST, x NULLS LAST);
CREATE UNIQUE INDEX x ON x(x NULLS LAST, x NULLS LAST);
CREATE INDEX x ON x USING hash(x NULLS LAST);
CREATE UNIQUE INDEX x ON x(x NULLS LAST, x NULLS LAST, (3) NULLS LAST);
CREATE UNIQUE INDEX x ON x(x NULLS LAST, x NULLS LAST) WHERE x <> '3';
/* default is 'd'/DEFAULT for user created tables */ SELECT x FROM x WHERE x = CAST('test_replica_identity' AS REGCLASS);
/* but 'none' for system tables */ SELECT x FROM x WHERE x = CAST('pg_class' AS REGCLASS);
SELECT x FROM x WHERE x = CAST('pg_constraint' AS REGCLASS);
/* -- */ /* Make sure we detect ineligible indexes */ /* -- */ /* fail, not unique */ ALTER TABLE test_replica_identity REPLICA IDENTITY USING INDEX test_replica_identity_keyab;
/* fail, not a candidate key, nullable column */ ALTER TABLE test_replica_identity REPLICA IDENTITY USING INDEX test_replica_identity_nonkey;
/* fail, hash indexes cannot do uniqueness */ ALTER TABLE test_replica_identity REPLICA IDENTITY USING INDEX test_replica_identity_hash;
/* fail, expression index */ ALTER TABLE test_replica_identity REPLICA IDENTITY USING INDEX test_replica_identity_expr;
/* fail, partial index */ ALTER TABLE test_replica_identity REPLICA IDENTITY USING INDEX test_replica_identity_partial;
/* fail, not our index */ ALTER TABLE test_replica_identity REPLICA IDENTITY USING INDEX test_replica_identity_othertable_pkey;
/* fail, deferrable */ ALTER TABLE test_replica_identity REPLICA IDENTITY USING INDEX test_replica_identity_unique_defer;
/* fail, deferrable */ ALTER TABLE test_replica_identity_t3 REPLICA IDENTITY USING INDEX pk;
SELECT x FROM x WHERE x = CAST('test_replica_identity' AS REGCLASS);
/* -- */ /* Make sure index cases succeed */ /* -- */ /* succeed, primary key */ ALTER TABLE test_replica_identity REPLICA IDENTITY USING INDEX test_replica_identity_pkey;
SELECT x FROM x WHERE x = CAST('test_replica_identity' AS REGCLASS);
/* succeed unique index over nonnullable cols */ ALTER TABLE test_replica_identity REPLICA IDENTITY USING INDEX test_replica_identity_keyab_key;
ALTER TABLE test_replica_identity REPLICA IDENTITY USING INDEX test_replica_identity_keyab_key;
SELECT x FROM x WHERE x = CAST('test_replica_identity' AS REGCLASS);
/* -- */ /* Make sure non index cases work */ /* -- */ ALTER TABLE test_replica_identity REPLICA IDENTITY DEFAULT;
SELECT x FROM x WHERE x = CAST('test_replica_identity' AS REGCLASS);
SELECT COUNT(*) FROM x WHERE x = CAST('test_replica_identity' AS REGCLASS) AND x;
ALTER TABLE test_replica_identity REPLICA IDENTITY FULL;
SELECT x FROM x WHERE x = CAST('test_replica_identity' AS REGCLASS);
SELECT x FROM x WHERE x = CAST('test_replica_identity' AS REGCLASS);
/* - */ /* Test that ALTER TABLE rewrite preserves nondefault replica identity */ /* - */ /* constraint variant */ CREATE TABLE x (x INT UNIQUE NOT NULL);
ALTER TABLE test_replica_identity2 REPLICA IDENTITY USING INDEX test_replica_identity2_id_key;
CREATE UNIQUE INDEX x ON x(x NULLS LAST);
ALTER TABLE test_replica_identity3 REPLICA IDENTITY USING INDEX test_replica_identity3_id_key;
/* but it's OK when the identity is FULL */ ALTER TABLE test_replica_identity3 REPLICA IDENTITY FULL;
ALTER TABLE x ALTER COLUMN x DROP NOT NULL;
/* Test that replica identity can be set on an index that's not yet valid. */ /* (This matches the way pg_dump will try to dump a partitioned table.) */ CREATE TABLE x (x INT NOT NULL) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x (x INT NOT NULL);
ALTER TABLE ONLY test_replica_identity4   ATTACH PARTITION test_replica_identity4_1 FOR VALUES IN (1);
ALTER TABLE ONLY x ADD CONSTRAINT x PRIMARY KEY (x NULLS LAST);
ALTER TABLE ONLY test_replica_identity4   REPLICA IDENTITY USING INDEX test_replica_identity4_pkey;
ALTER TABLE ONLY x ADD CONSTRAINT x PRIMARY KEY (x NULLS LAST);
CREATE UNIQUE INDEX x ON x(x NULLS LAST, x NULLS LAST);
ALTER TABLE test_replica_identity5 REPLICA IDENTITY USING INDEX test_replica_identity5_a_b_key;
ALTER TABLE x DROP CONSTRAINT x;
ALTER TABLE x ALTER COLUMN x SET NOT NULL;
ALTER TABLE x DROP CONSTRAINT x;
ALTER TABLE x ALTER COLUMN x DROP NOT NULL;
DROP TABLE x;
DROP TABLE x;
DROP TABLE x;
DROP TABLE x;
DROP TABLE x;
DROP TABLE x;
DROP TABLE x;
/* Test INSERT/UPDATE/DELETE RETURNING */ /* Simple cases */ CREATE TEMPORARY TABLE x (x SERIAL, x TEXT, x INT DEFAULT 42);
INSERT INTO x (x, x) VALUES ('test', DEFAULT), ('More', 11), (UPPER('more'), 7 + 9) RETURNING *, x + x AS x;
SELECT * FROM x;
UPDATE x SET x = LOWER(x), x = x RETURNING x.*, x + x AS x;
SELECT * FROM x;
DELETE FROM x WHERE x > 2 RETURNING x, x, x, LEAST(x, x);
SELECT * FROM x;
/* Subplans and initplans in the RETURNING list */ INSERT INTO x SELECT x + 10, x, x + 99 FROM x RETURNING *, x + 112 IN (SELECT x FROM x) AS x, EXISTS(SELECT * FROM x) AS x;
UPDATE x SET x = x * 2 WHERE x > 10 RETURNING *, x + 112 IN (SELECT x FROM x) AS x, EXISTS(SELECT * FROM x) AS x;
DELETE FROM x WHERE x > 10 RETURNING *, x + 112 IN (SELECT x FROM x) AS x, EXISTS(SELECT * FROM x) AS x;
/* Joins */ UPDATE x SET x = x * 2 FROM x AS x WHERE x.x + 123455 = x.x RETURNING x.*, x.x AS "x";
SELECT * FROM x;
DELETE FROM x USING x AS x WHERE x.x + 123455 = x.x RETURNING x.*, x.x AS "x";
SELECT * FROM x;
/* Check inheritance cases */ CREATE TEMPORARY TABLE x (x INT) INHERITS (x);
INSERT INTO x VALUES (123, 'child', 999, -123);
ALTER TABLE x ADD COLUMN x BIGINT DEFAULT 99;
SELECT * FROM x;
SELECT * FROM x;
UPDATE x SET x = x + x WHERE x = 99 RETURNING *;
SELECT * FROM x;
SELECT * FROM x;
UPDATE x SET x = x * 2 FROM x AS x WHERE x.x = x.x RETURNING *;
SELECT * FROM x;
SELECT * FROM x;
DELETE FROM x USING x AS x WHERE x.x = x.x RETURNING *;
SELECT * FROM x;
SELECT * FROM x;
DROP TABLE x;
/* Rules and views */ CREATE TEMPORARY VIEW x AS SELECT x, x FROM x;
CREATE RULE voo_i AS ON INSERT TO voo DO INSTEAD   INSERT INTO foo VALUES(new.*, 57);
INSERT INTO x VALUES (11, 'zit');
/* fails: */ INSERT INTO x VALUES (12, 'zoo') RETURNING *, x * 2;
/* fails, incompatible list: */ CREATE OR REPLACE RULE voo_i AS ON INSERT TO voo DO INSTEAD   INSERT INTO foo VALUES(new.*, 57) RETURNING *;
CREATE OR REPLACE RULE voo_i AS ON INSERT TO voo DO INSTEAD   INSERT INTO foo VALUES(new.*, 57) RETURNING f1, f2;
/* should still work */ INSERT INTO x VALUES (13, 'zit2');
/* works now */ INSERT INTO x VALUES (14, 'zoo2') RETURNING *;
SELECT * FROM x;
SELECT * FROM x;
CREATE OR REPLACE RULE voo_u AS ON UPDATE TO voo DO INSTEAD   UPDATE foo SET f1 = new.f1, f2 = new.f2 WHERE f1 = old.f1   RETURNING f1, f2;
UPDATE x SET x = x + 1 WHERE x = 'zoo2';
UPDATE x SET x = x + 1 WHERE x = 'zoo2' RETURNING *, x * 2;
SELECT * FROM x;
SELECT * FROM x;
CREATE OR REPLACE RULE voo_d AS ON DELETE TO voo DO INSTEAD   DELETE FROM foo WHERE f1 = old.f1   RETURNING f1, f2;
DELETE FROM x WHERE x = 13;
DELETE FROM x WHERE x = 'zit' RETURNING *;
SELECT * FROM x;
SELECT * FROM x;
/* Check use of a whole-row variable for an un-flattenable view */ CREATE TEMPORARY VIEW x AS SELECT * FROM x OFFSET 0;
UPDATE x SET x = x.x FROM x WHERE x.x = x.x RETURNING x;
SELECT * FROM x;
/* Check use of a whole-row variable for an inlined set-returning function */ CREATE FUNCTION foo_f() RETURNS SETOF foo AS   $$ SELECT * FROM foo OFFSET 0 $$ LANGUAGE sql STABLE;
UPDATE x SET x = x.x FROM x WHERE x.x = x.x RETURNING x;
SELECT * FROM x;
DROP FUNCTION x;
/* As above, but SRF is defined to return a composite type */ CREATE TYPE foo_t AS (f1 int, f2 text, f3 int, f4 int8);
CREATE FUNCTION foo_f() RETURNS SETOF foo_t AS   $$ SELECT * FROM foo OFFSET 0 $$ LANGUAGE sql STABLE;
UPDATE x SET x = x.x FROM x WHERE x.x = x.x RETURNING x;
SELECT * FROM x;
DROP FUNCTION x;
DROP TYPE foo_t;
/* Try a join case */ CREATE TEMPORARY TABLE x (x TEXT, x INT);
INSERT INTO x VALUES ('more', 12345);
INSERT INTO x VALUES ('zoo2', 54321);
INSERT INTO x VALUES ('other', 0);
CREATE TEMPORARY VIEW x AS SELECT x.*, x FROM x JOIN x ON (x = x);
SELECT * FROM x;
CREATE RULE joinview_u AS ON UPDATE TO joinview DO INSTEAD   UPDATE foo SET f1 = new.f1, f3 = new.f3     FROM joinme WHERE f2 = f2j AND f2 = old.f2     RETURNING foo.*, other;
UPDATE x SET x = x + 1 WHERE x = 57 RETURNING *, x + 1;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
TRUNCATE TABLE x /* ok */ /* Test RETURNING OLD/NEW. */ /* Start with new data, to ensure predictable TIDs. */;
INSERT INTO x VALUES (1, 'xxx', 10, 20), (2, 'more', 42, 141), (3, 'zoo2', 57, 99);
/* INSERT has NEW, but not OLD */ EXPLAIN (verbose, costs off) INSERT INTO foo VALUES (4)   RETURNING old.tableoid::regclass, old.ctid, old.*,             new.tableoid::regclass, new.ctid, new.*, *;
INSERT INTO x VALUES (4) RETURNING CAST(x.x AS REGCLASS), x.x, x.*, CAST(x.x AS REGCLASS), x.x, x.*, *;
/* INSERT ... ON CONFLICT ... UPDATE has OLD and NEW */ CREATE UNIQUE INDEX x ON x(x NULLS LAST);
EXPLAIN (verbose, costs off) INSERT INTO foo VALUES (4, 'conflict'), (5, 'ok')   ON CONFLICT (f1) DO UPDATE SET f2 = excluded.f2||'ed', f3 = -1   RETURNING WITH (OLD AS o, NEW AS n)             o.tableoid::regclass, o.ctid, o.*,             n.tableoid::regclass, n.ctid, n.*, *;
/* UPDATE has OLD and NEW */ EXPLAIN (verbose, costs off) UPDATE foo SET f4 = 100 WHERE f1 = 5   RETURNING old.tableoid::regclass, old.ctid, old.*, old,             new.tableoid::regclass, new.ctid, new.*, new,             old.f4::text||'->'||new.f4::text AS change;
UPDATE x SET x = 100 WHERE x = 5 RETURNING CAST(x.x AS REGCLASS), x.x, x.*, x, CAST(x.x AS REGCLASS), x.x, x.*, x, CAST(x.x AS TEXT) || '->' || CAST(x.x AS TEXT) AS x;
/* DELETE has OLD, but not NEW */ EXPLAIN (verbose, costs off) DELETE FROM foo WHERE f1 = 5   RETURNING old.tableoid::regclass, old.ctid, old.*,             new.tableoid::regclass, new.ctid, new.*, *;
DELETE FROM x WHERE x = 5 RETURNING CAST(x.x AS REGCLASS), x.x, x.*, CAST(x.x AS REGCLASS), x.x, x.*, *;
/* RETURNING OLD and NEW from subquery */ EXPLAIN (verbose, costs off) INSERT INTO foo VALUES (5, 'subquery test')   RETURNING (SELECT max(old.f4 + x) FROM generate_series(1, 10) x) old_max,             (SELECT max(new.f4 + x) FROM generate_series(1, 10) x) new_max;
INSERT INTO x VALUES (5, 'subquery test') RETURNING (SELECT MAX(x.x + x) FROM x AS x) AS x, (SELECT MAX(x.x + x) FROM x AS x) AS x;
EXPLAIN (verbose, costs off) UPDATE foo SET f4 = 100 WHERE f1 = 5   RETURNING (SELECT old.f4 = new.f4),             (SELECT max(old.f4 + x) FROM generate_series(1, 10) x) old_max,             (SELECT max(new.f4 + x) FROM generate_series(1, 10) x) new_max;
UPDATE x SET x = 100 WHERE x = 5 RETURNING (SELECT x.x = x.x), (SELECT MAX(x.x + x) FROM x AS x) AS x, (SELECT MAX(x.x + x) FROM x AS x) AS x;
EXPLAIN (verbose, costs off) DELETE FROM foo WHERE f1 = 5   RETURNING (SELECT max(old.f4 + x) FROM generate_series(1, 10) x) old_max,             (SELECT max(new.f4 + x) FROM generate_series(1, 10) x) new_max;
DELETE FROM x WHERE x = 5 RETURNING (SELECT MAX(x.x + x) FROM x AS x) AS x, (SELECT MAX(x.x + x) FROM x AS x) AS x;
/* DELETE turned into UPDATE by a rule has OLD and NEW */ CREATE RULE foo_del_rule AS ON DELETE TO foo DO INSTEAD   UPDATE foo SET f2 = f2||' (deleted)', f3 = -1, f4 = -1 WHERE f1 = OLD.f1   RETURNING *;
EXPLAIN (verbose, costs off) DELETE FROM foo WHERE f1 = 4 RETURNING old.*,new.*, *;
DELETE FROM x WHERE x = 4 RETURNING x.*, x.*, *;
/* UPDATE on view with rule */ EXPLAIN (verbose, costs off) UPDATE joinview SET f3 = f3 + 1 WHERE f3 = 57   RETURNING old.*, new.*, *, new.f3 - old.f3 AS delta_f3;
UPDATE x SET x = x + 1 WHERE x = 57 RETURNING x.*, x.*, *, x.x - x.x AS x;
x AS x /* should fail */;
COMMIT;
CREATE TRIGGER joinview_upd_trig INSTEAD OF UPDATE ON joinview   FOR EACH ROW EXECUTE FUNCTION joinview_upd_trig_fn();
DROP RULE joinview_u ON joinview;
UPDATE x SET x = x + 1, x = 7 WHERE x = 58 RETURNING x.*, x.*, *, x.x - x.x AS x;
x AS x /* now ok */;
COMMIT;
EXPLAIN (verbose, costs off) UPDATE joinview SET f3 = f3 + 1, f4 = 7 WHERE f3 = 58   RETURNING old.*, new.*, *, new.f3 - old.f3 AS delta_f3;
UPDATE x SET x = x + 1, x = 7 WHERE x = 58 RETURNING x.*, x.*, *, x.x - x.x AS x;
ALTER TABLE x DROP COLUMN x CASCADE /* should succeed */ /* Test wholerow & dropped column handling */;
UPDATE x SET x = x + 1 RETURNING x.x;
/* should fail */ UPDATE x SET x = x + 1 RETURNING x, x;
/* INSERT/DELETE on zero column table */ CREATE TABLE x;
INSERT INTO x SELECT RETURNING x.*, x.*, *;
INSERT INTO x SELECT RETURNING CAST(x.x AS REGCLASS), x.x, CAST(x.x AS REGCLASS), x.x, x, *;
DELETE FROM x RETURNING CAST(x.x AS REGCLASS), x.x, CAST(x.x AS REGCLASS), x.x, x, *;
DROP TABLE x;
/* Test schema-qualified table name in RETURNING list */ CREATE TABLE x.x (x INT, x INT);
INSERT INTO x.x VALUES (1, 10);
UPDATE x.x SET x = x * 2 RETURNING x, x, x.x, x.x, x.x, x.x.x;
DROP TABLE x.x;
/* Test cross-partition updates and attribute mapping */ CREATE TABLE x (x INT, x DOUBLE, x TEXT) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN (1);
CREATE TABLE x PARTITION OF x FOR VALUES IN (2);
CREATE TABLE x (x TEXT, x INT, x DOUBLE);
ALTER TABLE foo_parted ATTACH PARTITION foo_part_d1 FOR VALUES IN (3);
CREATE TABLE x (x DOUBLE, x TEXT, x INT);
ALTER TABLE foo_parted ATTACH PARTITION foo_part_d2 FOR VALUES IN (4);
INSERT INTO x VALUES (1, 17.1, 'P1'), (2, 17.2, 'P2'), (3, 17.3, 'P3'), (4, 17.4, 'P4') RETURNING CAST(x.x AS REGCLASS), x.x, x.*, CAST(x.x AS REGCLASS), x.x, x.*, *;
UPDATE x SET x = 2, x = x + 1, x = x || '->P2' WHERE x = 1 RETURNING CAST(x.x AS REGCLASS), x.x, x.*, CAST(x.x AS REGCLASS), x.x, x.*, *;
UPDATE x SET x = 1, x = x + 1, x = x || '->P1' WHERE x = 3 RETURNING CAST(x.x AS REGCLASS), x.x, x.*, CAST(x.x AS REGCLASS), x.x, x.*, *;
UPDATE x SET x = 3, x = x + 1, x = x || '->P3' WHERE x = 1 RETURNING CAST(x.x AS REGCLASS), x.x, x.*, CAST(x.x AS REGCLASS), x.x, x.*, *;
UPDATE x SET x = 4, x = x + 1, x = x || '->P4' WHERE x = 3 RETURNING CAST(x.x AS REGCLASS), x.x, x.*, CAST(x.x AS REGCLASS), x.x, x.*, *;
/* cross-partition update that uses ReturningExpr nodes, without returning */ /* old/new table values */ CREATE VIEW x AS SELECT *, 'xxx' AS x FROM x;
UPDATE x SET x = 1, x = x || '->P1' WHERE x = 2 AND x = 'P2' RETURNING 'P2:' || x.x, 'P1:' || x.x;
DELETE FROM x RETURNING CAST(x.x AS REGCLASS), x.x, x.*, CAST(x.x AS REGCLASS), x.x, x.*, *;
DROP TABLE x CASCADE;
/* Test deparsing */ CREATE FUNCTION x() RETURNS void LANGUAGE sql AS BEGIN ATOMIC   WITH u1 AS (     UPDATE foo SET f1 = f1 + 1 RETURNING old.*, new.*   ), u2 AS (     UPDATE foo SET f1 = f1 + 1 RETURNING WITH (OLD AS "old foo") "old foo".*, new.*   ), u3 AS (     UPDATE foo SET f1 = f1 + 1 RETURNING WITH (NEW AS "new foo") old.*, "new foo".*   )   UPDATE foo SET f1 = f1 + 1     RETURNING WITH (OLD AS o, NEW AS n)               o.*, n.*, o, n, o.f1 = n.f1, o = n,               (SELECT o.f2 = n.f2),               (SELECT count(*) FROM foo WHERE foo.f1 = o.f4),               (SELECT count(*) FROM foo WHERE foo.f4 = n.f4),               (SELECT count(*) FROM foo WHERE foo = o),               (SELECT count(*) FROM foo WHERE foo = n);
COMMIT;
/* default for superuser is false */ CREATE ROLE regress_test_def_superuser;
SELECT x, x, x, x, x, x, x, x, x, x, x FROM x WHERE x = 'regress_test_def_superuser';
CREATE ROLE regress_test_superuser WITH SUPERUSER;
SELECT x, x, x, x, x, x, x, x, x, x, x FROM x WHERE x = 'regress_test_superuser';
ALTER ROLE regress_test_superuser WITH NOSUPERUSER;
SELECT x, x, x, x, x, x, x, x, x, x, x FROM x WHERE x = 'regress_test_superuser';
ALTER ROLE regress_test_superuser WITH SUPERUSER;
SELECT x, x, x, x, x, x, x, x, x, x, x FROM x WHERE x = 'regress_test_superuser';
/* default for inherit is true */ CREATE ROLE regress_test_def_inherit;
SELECT x, x, x, x, x, x, x, x, x, x, x FROM x WHERE x = 'regress_test_def_inherit';
CREATE ROLE regress_test_inherit WITH NOINHERIT;
SELECT x, x, x, x, x, x, x, x, x, x, x FROM x WHERE x = 'regress_test_inherit';
ALTER ROLE regress_test_inherit WITH INHERIT;
SELECT x, x, x, x, x, x, x, x, x, x, x FROM x WHERE x = 'regress_test_inherit';
ALTER ROLE regress_test_inherit WITH NOINHERIT;
SELECT x, x, x, x, x, x, x, x, x, x, x FROM x WHERE x = 'regress_test_inherit';
/* default for create role is false */ CREATE ROLE regress_test_def_createrole;
SELECT x, x, x, x, x, x, x, x, x, x, x FROM x WHERE x = 'regress_test_def_createrole';
CREATE ROLE regress_test_createrole WITH CREATEROLE;
SELECT x, x, x, x, x, x, x, x, x, x, x FROM x WHERE x = 'regress_test_createrole';
ALTER ROLE regress_test_createrole WITH NOCREATEROLE;
SELECT x, x, x, x, x, x, x, x, x, x, x FROM x WHERE x = 'regress_test_createrole';
ALTER ROLE regress_test_createrole WITH CREATEROLE;
SELECT x, x, x, x, x, x, x, x, x, x, x FROM x WHERE x = 'regress_test_createrole';
/* default for create database is false */ CREATE ROLE regress_test_def_createdb;
SELECT x, x, x, x, x, x, x, x, x, x, x FROM x WHERE x = 'regress_test_def_createdb';
CREATE ROLE regress_test_createdb WITH CREATEDB;
SELECT x, x, x, x, x, x, x, x, x, x, x FROM x WHERE x = 'regress_test_createdb';
ALTER ROLE regress_test_createdb WITH NOCREATEDB;
SELECT x, x, x, x, x, x, x, x, x, x, x FROM x WHERE x = 'regress_test_createdb';
ALTER ROLE regress_test_createdb WITH CREATEDB;
SELECT x, x, x, x, x, x, x, x, x, x, x FROM x WHERE x = 'regress_test_createdb';
/* default for can login is false for role */ CREATE ROLE regress_test_def_role_canlogin;
SELECT x, x, x, x, x, x, x, x, x, x, x FROM x WHERE x = 'regress_test_def_role_canlogin';
CREATE ROLE regress_test_role_canlogin WITH LOGIN;
SELECT x, x, x, x, x, x, x, x, x, x, x FROM x WHERE x = 'regress_test_role_canlogin';
ALTER ROLE regress_test_role_canlogin WITH NOLOGIN;
SELECT x, x, x, x, x, x, x, x, x, x, x FROM x WHERE x = 'regress_test_role_canlogin';
ALTER ROLE regress_test_role_canlogin WITH LOGIN;
SELECT x, x, x, x, x, x, x, x, x, x, x FROM x WHERE x = 'regress_test_role_canlogin';
/* default for can login is true for user */ CREATE USER regress_test_def_user_canlogin;
SELECT x, x, x, x, x, x, x, x, x, x, x FROM x WHERE x = 'regress_test_def_user_canlogin';
CREATE USER regress_test_user_canlogin WITH NOLOGIN;
SELECT x, x, x, x, x, x, x, x, x, x, x FROM x WHERE x = 'regress_test_user_canlogin';
ALTER USER regress_test_user_canlogin WITH LOGIN;
SELECT x, x, x, x, x, x, x, x, x, x, x FROM x WHERE x = 'regress_test_user_canlogin';
ALTER USER regress_test_user_canlogin WITH NOLOGIN;
SELECT x, x, x, x, x, x, x, x, x, x, x FROM x WHERE x = 'regress_test_user_canlogin';
/* default for replication is false */ CREATE ROLE regress_test_def_replication;
SELECT x, x, x, x, x, x, x, x, x, x, x FROM x WHERE x = 'regress_test_def_replication';
CREATE ROLE regress_test_replication WITH REPLICATION;
SELECT x, x, x, x, x, x, x, x, x, x, x FROM x WHERE x = 'regress_test_replication';
ALTER ROLE regress_test_replication WITH NOREPLICATION;
SELECT x, x, x, x, x, x, x, x, x, x, x FROM x WHERE x = 'regress_test_replication';
ALTER ROLE regress_test_replication WITH REPLICATION;
SELECT x, x, x, x, x, x, x, x, x, x, x FROM x WHERE x = 'regress_test_replication';
/* default for bypassrls is false */ CREATE ROLE regress_test_def_bypassrls;
SELECT x, x, x, x, x, x, x, x, x, x, x FROM x WHERE x = 'regress_test_def_bypassrls';
CREATE ROLE regress_test_bypassrls WITH BYPASSRLS;
SELECT x, x, x, x, x, x, x, x, x, x, x FROM x WHERE x = 'regress_test_bypassrls';
ALTER ROLE regress_test_bypassrls WITH NOBYPASSRLS;
SELECT x, x, x, x, x, x, x, x, x, x, x FROM x WHERE x = 'regress_test_bypassrls';
ALTER ROLE regress_test_bypassrls WITH BYPASSRLS;
SELECT x, x, x, x, x, x, x, x, x, x, x FROM x WHERE x = 'regress_test_bypassrls';
/* clean up roles */ DROP ROLE regress_test_def_superuser;
DROP ROLE regress_test_superuser;
DROP ROLE regress_test_def_inherit;
DROP ROLE regress_test_inherit;
DROP ROLE regress_test_def_createrole;
DROP ROLE regress_test_createrole;
DROP ROLE regress_test_def_createdb;
DROP ROLE regress_test_createdb;
DROP ROLE regress_test_def_role_canlogin;
DROP ROLE regress_test_role_canlogin;
DROP USER regress_test_def_user_canlogin;
DROP USER regress_test_user_canlogin;
DROP ROLE regress_test_def_replication;
DROP ROLE regress_test_replication;
DROP ROLE regress_test_def_bypassrls;
DROP ROLE regress_test_bypassrls;
SET x = 'warning' /* Test of Row-level security feature */ /* Clean up in case a prior regression run failed */ /* Suppress NOTICE messages when users/groups don't exist */;
DROP USER IF EXISTS regress_rls_alice;
DROP USER IF EXISTS regress_rls_bob;
DROP USER IF EXISTS regress_rls_carol;
DROP USER IF EXISTS regress_rls_dave;
DROP USER IF EXISTS regress_rls_exempt_user;
DROP ROLE IF EXISTS regress_rls_group1;
DROP ROLE IF EXISTS regress_rls_group2;
DROP SCHEMA IF EXISTS x CASCADE;
RESET client_min_messages;
/* initial setup */ CREATE USER regress_rls_alice NOLOGIN;
CREATE USER regress_rls_bob NOLOGIN;
CREATE USER regress_rls_carol NOLOGIN;
CREATE USER regress_rls_dave NOLOGIN;
CREATE USER regress_rls_exempt_user BYPASSRLS NOLOGIN;
CREATE ROLE regress_rls_group1 NOLOGIN;
CREATE ROLE regress_rls_group2 NOLOGIN;
GRANT regress_rls_group1 TO regress_rls_bob;
GRANT regress_rls_group2 TO regress_rls_carol;
CREATE SCHEMA x.x;
GRANT ALL ON SCHEMA x TO x;
SET x = regress_rls_schema;
x AS x;
GRANT EXECUTE ON FUNCTION x TO x;
/* BASIC Row-Level Security Scenario */ SET SESSION AUTHORIZATION regress_rls_alice;
CREATE TABLE x (x NAME PRIMARY KEY, x INT);
GRANT SELECT ON x TO x;
INSERT INTO x VALUES ('regress_rls_alice', 99), ('regress_rls_bob', 1), ('regress_rls_carol', 2), ('regress_rls_dave', 3);
CREATE TABLE x (x INT PRIMARY KEY, x TEXT);
GRANT ALL ON x TO x;
INSERT INTO x VALUES (11, 'novel'), (22, 'science fiction'), (33, 'technology'), (44, 'manga');
CREATE TABLE x (x INT PRIMARY KEY, x INT REFERENCES x (x), x INT NOT NULL, x NAME, x TEXT);
GRANT ALL ON x TO x;
INSERT INTO x VALUES (1, 11, 1, 'regress_rls_bob', 'my first novel'), (2, 11, 2, 'regress_rls_bob', 'my second novel'), (3, 22, 2, 'regress_rls_bob', 'my science fiction'), (4, 44, 1, 'regress_rls_bob', 'my first manga'), (5, 44, 2, 'regress_rls_bob', 'my second manga'), (6, 22, 1, 'regress_rls_carol', 'great science fiction'), (7, 33, 2, 'regress_rls_carol', 'great technology book'), (8, 44, 1, 'regress_rls_carol', 'great manga'), (9, 22, 1, 'regress_rls_dave', 'awesome science fiction'), (10, 33, 2, 'regress_rls_dave', 'awesome technology book');
ALTER TABLE document ENABLE ROW LEVEL SECURITY;
/* user's security level must be higher than or equal to document's */ CREATE POLICY p1 ON document AS PERMISSIVE     USING (dlevel <= (SELECT seclv FROM uaccount WHERE pguser = current_user));
/* try to create a policy of bogus type */ CREATE POLICY p1 ON document AS UGLY     USING (dlevel <= (SELECT seclv FROM uaccount WHERE pguser = current_user));
/* but Dave isn't allowed to anything at cid 50 or above */ /* this is to make sure that we sort the policies by name first */ /* when applying WITH CHECK, a later INSERT by Dave should fail due */ /* to p1r first */ CREATE POLICY p2r ON document AS RESTRICTIVE TO regress_rls_dave     USING (cid <> 44 AND cid < 50);
/* and Dave isn't allowed to see manga documents */ CREATE POLICY p1r ON document AS RESTRICTIVE TO regress_rls_dave     USING (cid <> 44);
/* viewpoint from regress_rls_bob */ SET SESSION AUTHORIZATION regress_rls_bob;
SET x = ON;
SELECT * FROM x WHERE F_LEAK(x) ORDER BY x NULLS LAST;
SELECT * FROM x NATURAL JOIN x WHERE F_LEAK(x) ORDER BY x NULLS LAST;
/* try a sampled version */ SELECT * FROM x TABLESAMPLE BERNOULLI (50 PERCENT) SEED (0) WHERE F_LEAK(x) ORDER BY x NULLS LAST;
/* viewpoint from regress_rls_carol */ SET SESSION AUTHORIZATION regress_rls_carol;
SELECT * FROM x WHERE F_LEAK(x) ORDER BY x NULLS LAST;
SELECT * FROM x NATURAL JOIN x WHERE F_LEAK(x) ORDER BY x NULLS LAST;
/* try a sampled version */ SELECT * FROM x TABLESAMPLE BERNOULLI (50 PERCENT) SEED (0) WHERE F_LEAK(x) ORDER BY x NULLS LAST;
EXPLAIN (COSTS OFF) SELECT * FROM document WHERE f_leak(dtitle);
EXPLAIN (COSTS OFF) SELECT * FROM document NATURAL JOIN category WHERE f_leak(dtitle);
/* viewpoint from regress_rls_dave */ SET SESSION AUTHORIZATION regress_rls_dave;
SELECT * FROM x WHERE F_LEAK(x) ORDER BY x NULLS LAST;
SELECT * FROM x NATURAL JOIN x WHERE F_LEAK(x) ORDER BY x NULLS LAST;
EXPLAIN (COSTS OFF) SELECT * FROM document WHERE f_leak(dtitle);
EXPLAIN (COSTS OFF) SELECT * FROM document NATURAL JOIN category WHERE f_leak(dtitle);
/* 44 would technically fail for both p2r and p1r, but we should get an error */ /* back from p1r for this because it sorts first */ INSERT INTO x VALUES (100, 44, 1, 'regress_rls_dave', 'testing sorting of policies');
/* fail */ /* Just to see a p2r error */ INSERT INTO x VALUES (100, 55, 1, 'regress_rls_dave', 'testing sorting of policies');
/* fail */ /* only owner can change policies */ ALTER POLICY p1 ON document USING (true);
/* fail */ DROP POLICY p1 ON document;
/* fail */ SET SESSION AUTHORIZATION regress_rls_alice;
ALTER POLICY p1 ON document USING (dauthor = current_user);
/* viewpoint from regress_rls_bob again */ SET SESSION AUTHORIZATION regress_rls_bob;
SELECT * FROM x WHERE F_LEAK(x) ORDER BY x NULLS LAST;
SELECT * FROM x NATURAL JOIN x WHERE F_LEAK(x) ORDER BY x NULLS LAST;
/* viewpoint from rls_regres_carol again */ SET SESSION AUTHORIZATION regress_rls_carol;
SELECT * FROM x WHERE F_LEAK(x) ORDER BY x NULLS LAST;
SELECT * FROM x NATURAL JOIN x WHERE F_LEAK(x) ORDER BY x NULLS LAST;
EXPLAIN (COSTS OFF) SELECT * FROM document WHERE f_leak(dtitle);
EXPLAIN (COSTS OFF) SELECT * FROM document NATURAL JOIN category WHERE f_leak(dtitle);
/* interaction of FK/PK constraints */ SET SESSION AUTHORIZATION regress_rls_alice;
CREATE POLICY p2 ON category     USING (CASE WHEN current_user = 'regress_rls_bob' THEN cid IN (11, 33)            WHEN current_user = 'regress_rls_carol' THEN cid IN (22, 44)            ELSE false END);
ALTER TABLE category ENABLE ROW LEVEL SECURITY;
/* cannot delete PK referenced by invisible FK */ SET SESSION AUTHORIZATION regress_rls_bob;
SELECT * FROM x AS x FULL OUTER JOIN x AS x ON x.x = x.x ORDER BY x.x NULLS LAST, x.x NULLS LAST;
DELETE FROM x WHERE x = 33;
/* fails with FK violation */ /* can insert FK referencing invisible PK */ SET SESSION AUTHORIZATION regress_rls_carol;
SELECT * FROM x AS x FULL OUTER JOIN x AS x ON x.x = x.x ORDER BY x.x NULLS LAST, x.x NULLS LAST;
INSERT INTO x VALUES (11, 33, 1, CURRENT_USER(), 'hoge');
/* UNIQUE or PRIMARY KEY constraint violation DOES reveal presence of row */ SET SESSION AUTHORIZATION regress_rls_bob;
INSERT INTO x VALUES (8, 44, 1, 'regress_rls_bob', 'my third manga');
/* Must fail with unique violation, revealing presence of did we can't see */ SELECT * FROM x WHERE x = 8;
/* and confirm we can't see it */ /* RLS policies are checked before constraints */ INSERT INTO x VALUES (8, 44, 1, 'regress_rls_carol', 'my third manga');
/* Should fail with RLS check violation, not duplicate key violation */ UPDATE x SET x = 8, x = 'regress_rls_carol' WHERE x = 5;
/* Should fail with RLS check violation, not duplicate key violation */ /* database superuser does bypass RLS policy when enabled */ RESET SESSION AUTHORIZATION;
SET x = ON;
SELECT * FROM x;
SELECT * FROM x;
/* database superuser does bypass RLS policy when disabled */ RESET SESSION AUTHORIZATION;
SET x = OFF;
SELECT * FROM x;
SELECT * FROM x;
/* database non-superuser with bypass privilege can bypass RLS policy when disabled */ SET SESSION AUTHORIZATION regress_rls_exempt_user;
SET x = OFF;
SELECT * FROM x;
SELECT * FROM x;
/* RLS policy does not apply to table owner when RLS enabled. */ SET SESSION AUTHORIZATION regress_rls_alice;
SET x = ON;
SELECT * FROM x;
SELECT * FROM x;
/* RLS policy does not apply to table owner when RLS disabled. */ SET SESSION AUTHORIZATION regress_rls_alice;
SET x = OFF;
SELECT * FROM x;
SELECT * FROM x;
/* Table inheritance and RLS policy */ SET SESSION AUTHORIZATION regress_rls_alice;
SET x = ON;
CREATE TABLE x (x INT NOT NULL PRIMARY KEY, x INT, x TEXT, x TEXT);
ALTER TABLE x DROP COLUMN x;
GRANT ALL ON x TO x /* just a disturbing factor */;
COPY INTO x FROM x;
GRANT ALL ON x TO x;
COPY INTO x FROM x;
ALTER TABLE t3 INHERIT t1;
GRANT ALL ON x TO x;
COPY INTO x (x, x, x, x) FROM x;
/* be even number */ CREATE POLICY p2 ON t2 FOR ALL TO PUBLIC USING (a % 2 = 1);
/* be odd number */ ALTER TABLE t1 ENABLE ROW LEVEL SECURITY;
ALTER TABLE t2 ENABLE ROW LEVEL SECURITY;
SET SESSION AUTHORIZATION regress_rls_bob;
SELECT * FROM x;
EXPLAIN (COSTS OFF) SELECT * FROM t1;
SELECT * FROM x WHERE F_LEAK(x);
EXPLAIN (COSTS OFF) SELECT * FROM t1 WHERE f_leak(b);
/* reference to system column */ SELECT CAST(x AS REGCLASS), * FROM x;
EXPLAIN (COSTS OFF) SELECT *, t1 FROM t1;
/* reference to whole-row reference */ SELECT *, x FROM x;
EXPLAIN (COSTS OFF) SELECT *, t1 FROM t1;
/* for share/update lock */ SELECT * FROM x;
EXPLAIN (COSTS OFF) SELECT * FROM t1 FOR SHARE;
SELECT * FROM x WHERE F_LEAK(x);
EXPLAIN (COSTS OFF) SELECT * FROM t1 WHERE f_leak(b) FOR SHARE;
/* union all query */ SELECT x, x, CAST(x AS REGCLASS) FROM x UNION ALL SELECT x, x, CAST(x AS REGCLASS) FROM x;
EXPLAIN (COSTS OFF) SELECT a, b, tableoid::regclass FROM t2 UNION ALL SELECT a, b, tableoid::regclass FROM t3;
/* superuser is allowed to bypass RLS checks */ RESET SESSION AUTHORIZATION;
SET x = OFF;
SELECT * FROM x WHERE F_LEAK(x);
EXPLAIN (COSTS OFF) SELECT * FROM t1 WHERE f_leak(b);
/* non-superuser with bypass privilege can bypass RLS policy when disabled */ SET SESSION AUTHORIZATION regress_rls_exempt_user;
SET x = OFF;
SELECT * FROM x WHERE F_LEAK(x);
EXPLAIN (COSTS OFF) SELECT * FROM t1 WHERE f_leak(b);
/* Partitioned Tables */ SET SESSION AUTHORIZATION regress_rls_alice;
CREATE TABLE x (x INT, x INT, x INT NOT NULL, x NAME, x TEXT) WITH (PARTITIONED_BY=RANGE(x));
GRANT ALL ON x TO x;
/* Create partitions for document categories */ CREATE TABLE x PARTITION OF x FOR VALUES FROM (11) TO (12);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (55) TO (56);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (99) TO (100);
GRANT ALL ON x TO x;
GRANT ALL ON x TO x;
GRANT ALL ON x TO x;
INSERT INTO x VALUES (1, 11, 1, 'regress_rls_bob', 'my first novel'), (2, 11, 2, 'regress_rls_bob', 'my second novel'), (3, 99, 2, 'regress_rls_bob', 'my science textbook'), (4, 55, 1, 'regress_rls_bob', 'my first satire'), (5, 99, 2, 'regress_rls_bob', 'my history book'), (6, 11, 1, 'regress_rls_carol', 'great science fiction'), (7, 99, 2, 'regress_rls_carol', 'great technology book'), (8, 55, 2, 'regress_rls_carol', 'great satire'), (9, 11, 1, 'regress_rls_dave', 'awesome science fiction'), (10, 99, 2, 'regress_rls_dave', 'awesome technology book');
ALTER TABLE part_document ENABLE ROW LEVEL SECURITY;
/* Create policy on parent */ /* user's security level must be higher than or equal to document's */ CREATE POLICY pp1 ON part_document AS PERMISSIVE     USING (dlevel <= (SELECT seclv FROM uaccount WHERE pguser = current_user));
/* Dave is only allowed to see cid < 55 */ CREATE POLICY pp1r ON part_document AS RESTRICTIVE TO regress_rls_dave     USING (cid < 55);
/* viewpoint from regress_rls_bob */ SET SESSION AUTHORIZATION regress_rls_bob;
SET x = ON;
SELECT * FROM x WHERE F_LEAK(x) ORDER BY x NULLS LAST;
EXPLAIN (COSTS OFF) SELECT * FROM part_document WHERE f_leak(dtitle);
/* viewpoint from regress_rls_carol */ SET SESSION AUTHORIZATION regress_rls_carol;
SELECT * FROM x WHERE F_LEAK(x) ORDER BY x NULLS LAST;
EXPLAIN (COSTS OFF) SELECT * FROM part_document WHERE f_leak(dtitle);
/* viewpoint from regress_rls_dave */ SET SESSION AUTHORIZATION regress_rls_dave;
SELECT * FROM x WHERE F_LEAK(x) ORDER BY x NULLS LAST;
EXPLAIN (COSTS OFF) SELECT * FROM part_document WHERE f_leak(dtitle);
/* pp1 ERROR */ INSERT INTO x VALUES (100, 11, 5, 'regress_rls_dave', 'testing pp1');
/* fail */ /* pp1r ERROR */ INSERT INTO x VALUES (100, 99, 1, 'regress_rls_dave', 'testing pp1r');
/* fail */ /* Show that RLS policy does not apply for direct inserts to children */ /* This should fail with RLS POLICY pp1r violation. */ INSERT INTO x VALUES (100, 55, 1, 'regress_rls_dave', 'testing RLS with partitions');
/* fail */ /* But this should succeed. */ INSERT INTO x VALUES (100, 55, 1, 'regress_rls_dave', 'testing RLS with partitions');
/* success */ /* We still cannot see the row using the parent */ SELECT * FROM x WHERE F_LEAK(x) ORDER BY x NULLS LAST;
/* But we can if we look directly */ SELECT * FROM x WHERE F_LEAK(x) ORDER BY x NULLS LAST;
/* Turn on RLS and create policy on child to show RLS is checked before constraints */ SET SESSION AUTHORIZATION regress_rls_alice;
ALTER TABLE part_document_satire ENABLE ROW LEVEL SECURITY;
CREATE POLICY pp3 ON part_document_satire AS RESTRICTIVE     USING (cid < 55);
/* This should fail with RLS violation now. */ SET SESSION AUTHORIZATION regress_rls_dave;
INSERT INTO x VALUES (101, 55, 1, 'regress_rls_dave', 'testing RLS with partitions');
/* fail */ /* And now we cannot see directly into the partition either, due to RLS */ SELECT * FROM x WHERE F_LEAK(x) ORDER BY x NULLS LAST;
/* The parent looks same as before */ /* viewpoint from regress_rls_dave */ SELECT * FROM x WHERE F_LEAK(x) ORDER BY x NULLS LAST;
EXPLAIN (COSTS OFF) SELECT * FROM part_document WHERE f_leak(dtitle);
/* viewpoint from regress_rls_carol */ SET SESSION AUTHORIZATION regress_rls_carol;
SELECT * FROM x WHERE F_LEAK(x) ORDER BY x NULLS LAST;
EXPLAIN (COSTS OFF) SELECT * FROM part_document WHERE f_leak(dtitle);
/* only owner can change policies */ ALTER POLICY pp1 ON part_document USING (true);
/* fail */ DROP POLICY pp1 ON part_document;
/* fail */ SET SESSION AUTHORIZATION regress_rls_alice;
ALTER POLICY pp1 ON part_document USING (dauthor = current_user);
/* viewpoint from regress_rls_bob again */ SET SESSION AUTHORIZATION regress_rls_bob;
SELECT * FROM x WHERE F_LEAK(x) ORDER BY x NULLS LAST;
/* viewpoint from rls_regres_carol again */ SET SESSION AUTHORIZATION regress_rls_carol;
SELECT * FROM x WHERE F_LEAK(x) ORDER BY x NULLS LAST;
EXPLAIN (COSTS OFF) SELECT * FROM part_document WHERE f_leak(dtitle);
/* database superuser does bypass RLS policy when enabled */ RESET SESSION AUTHORIZATION;
SET x = ON;
SELECT * FROM x ORDER BY x NULLS LAST;
SELECT * FROM x ORDER BY x NULLS LAST;
/* database non-superuser with bypass privilege can bypass RLS policy when disabled */ SET SESSION AUTHORIZATION regress_rls_exempt_user;
SET x = OFF;
SELECT * FROM x ORDER BY x NULLS LAST;
SELECT * FROM x ORDER BY x NULLS LAST;
/* RLS policy does not apply to table owner when RLS enabled. */ SET SESSION AUTHORIZATION regress_rls_alice;
SET x = ON;
SELECT * FROM x ORDER BY x NULLS LAST;
SELECT * FROM x ORDER BY x NULLS LAST;
/* When RLS disabled, other users get ERROR. */ SET SESSION AUTHORIZATION regress_rls_dave;
SET x = OFF;
SELECT * FROM x ORDER BY x NULLS LAST;
SELECT * FROM x ORDER BY x NULLS LAST;
/* Check behavior with a policy that uses a SubPlan not an InitPlan. */ SET SESSION AUTHORIZATION regress_rls_alice;
SET x = ON;
CREATE POLICY pp3 ON part_document AS RESTRICTIVE     USING ((SELECT dlevel <= seclv FROM uaccount WHERE pguser = current_user));
SET SESSION AUTHORIZATION regress_rls_carol;
INSERT INTO x VALUES (100, 11, 5, 'regress_rls_carol', 'testing pp3');
/* fail */ /* --- Dependencies ----- */ SET SESSION AUTHORIZATION regress_rls_alice;
SET x = ON;
CREATE TABLE x (x INT, x INT);
CREATE TABLE x (x INT, x INT);
CREATE POLICY d1 ON dependent FOR ALL     TO PUBLIC     USING (x = (SELECT d.x FROM dependee d WHERE d.y = y));
DROP TABLE x;
/* Should fail without CASCADE due to dependency on row security qual? */ DROP TABLE x CASCADE;
EXPLAIN (COSTS OFF) SELECT * FROM dependent;
/* After drop, should be unqualified */ /* ---   RECURSION    ---- */ /* Simple recursion */ SET SESSION AUTHORIZATION regress_rls_alice;
CREATE TABLE x (x INT, x INT);
CREATE POLICY r1 ON rec1 USING (x = (SELECT r.x FROM rec1 r WHERE y = r.y));
ALTER TABLE rec1 ENABLE ROW LEVEL SECURITY;
SET SESSION AUTHORIZATION regress_rls_bob;
SELECT * FROM x;
/* fail, direct recursion */ /* Mutual recursion */ SET SESSION AUTHORIZATION regress_rls_alice;
CREATE TABLE x (x INT, x INT);
ALTER POLICY r1 ON rec1 USING (x = (SELECT a FROM rec2 WHERE b = y));
CREATE POLICY r2 ON rec2 USING (a = (SELECT x FROM rec1 WHERE y = b));
ALTER TABLE rec2 ENABLE ROW LEVEL SECURITY;
SET SESSION AUTHORIZATION regress_rls_bob;
SELECT * FROM x;
/* fail, mutual recursion */ /* Mutual recursion via views */ SET SESSION AUTHORIZATION regress_rls_bob;
CREATE VIEW x AS SELECT * FROM x;
CREATE VIEW x AS SELECT * FROM x;
SET SESSION AUTHORIZATION regress_rls_alice;
ALTER POLICY r1 ON rec1 USING (x = (SELECT a FROM rec2v WHERE b = y));
ALTER POLICY r2 ON rec2 USING (a = (SELECT x FROM rec1v WHERE y = b));
SET SESSION AUTHORIZATION regress_rls_bob;
SELECT * FROM x;
/* fail, mutual recursion via views */ /* Mutual recursion via .s.b views */ SET SESSION AUTHORIZATION regress_rls_bob;
SET SESSION AUTHORIZATION regress_rls_alice;
CREATE POLICY r1 ON rec1 USING (x = (SELECT a FROM rec2v WHERE b = y));
CREATE POLICY r2 ON rec2 USING (a = (SELECT x FROM rec1v WHERE y = b));
SET SESSION AUTHORIZATION regress_rls_bob;
SELECT * FROM x;
/* fail, mutual recursion via s.b. views */ /* recursive RLS and VIEWs in policy */ SET SESSION AUTHORIZATION regress_rls_alice;
CREATE TABLE x (x INT, x TEXT);
INSERT INTO x (SELECT x, x.fipshash(CAST(x AS TEXT)) FROM x AS x);
CREATE TABLE x (x INT, x TEXT);
INSERT INTO x (SELECT x, x.fipshash(CAST(x AS TEXT)) FROM x AS x);
GRANT SELECT ON s1, s2 TO regress_rls_bob;
CREATE POLICY p1 ON s1 USING (a in (select x from s2 where y like '%2f%'));
CREATE POLICY p2 ON s2 USING (x in (select a from s1 where b like '%22%'));
CREATE POLICY p3 ON s1 FOR INSERT WITH CHECK (a = (SELECT a FROM s1));
ALTER TABLE s1 ENABLE ROW LEVEL SECURITY;
ALTER TABLE s2 ENABLE ROW LEVEL SECURITY;
SET SESSION AUTHORIZATION regress_rls_bob;
CREATE VIEW x AS SELECT * FROM x WHERE x LIKE '%af%';
SELECT * FROM x WHERE F_LEAK(x);
/* fail (infinite recursion) */ INSERT INTO x VALUES (1, 'foo');
/* fail (infinite recursion) */ SET SESSION AUTHORIZATION regress_rls_alice;
DROP POLICY p3 on s1;
ALTER POLICY p2 ON s2 USING (x % 2 = 0);
SET SESSION AUTHORIZATION regress_rls_bob;
SELECT * FROM x WHERE F_LEAK(x);
/* OK */ EXPLAIN (COSTS OFF) SELECT * FROM only s1 WHERE f_leak(b);
SET SESSION AUTHORIZATION regress_rls_alice;
ALTER POLICY p1 ON s1 USING (a in (select x from v2));
/* using VIEW in RLS policy */ SET SESSION AUTHORIZATION regress_rls_bob;
SELECT * FROM x WHERE F_LEAK(x);
/* OK */ EXPLAIN (COSTS OFF) SELECT * FROM s1 WHERE f_leak(b);
SELECT (SELECT x FROM x LIMIT 1) AS x, * FROM x WHERE x LIKE '%28%';
EXPLAIN (COSTS OFF) SELECT (SELECT x FROM s1 LIMIT 1) xx, * FROM s2 WHERE y like '%28%';
SET SESSION AUTHORIZATION regress_rls_alice;
ALTER POLICY p2 ON s2 USING (x in (select a from s1 where b like '%d2%'));
SET SESSION AUTHORIZATION regress_rls_bob;
SELECT * FROM x WHERE F_LEAK(x);
/* fail (infinite recursion via view) */ /* prepared statement with regress_rls_alice privilege */ PREPARE p1(int) AS SELECT * FROM t1 WHERE a <= $1;
EXECUTE p1(2);
EXPLAIN (COSTS OFF) EXECUTE p1(2);
/* superuser is allowed to bypass RLS checks */ RESET SESSION AUTHORIZATION;
SET x = OFF;
SELECT * FROM x WHERE F_LEAK(x);
EXPLAIN (COSTS OFF) SELECT * FROM t1 WHERE f_leak(b);
/* plan cache should be invalidated */ EXECUTE p1(2);
EXPLAIN (COSTS OFF) EXECUTE p1(2);
PREPARE p2(int) AS SELECT * FROM t1 WHERE a = $1;
EXECUTE p2(2);
EXPLAIN (COSTS OFF) EXECUTE p2(2);
/* also, case when privilege switch from superuser */ SET SESSION AUTHORIZATION regress_rls_bob;
SET x = ON;
EXECUTE p2(2);
EXPLAIN (COSTS OFF) EXECUTE p2(2);
/* UPDATE / DELETE and Row-level security */ SET SESSION AUTHORIZATION regress_rls_bob;
EXPLAIN (COSTS OFF) UPDATE t1 SET b = b || b WHERE f_leak(b);
UPDATE x SET x = x || x WHERE F_LEAK(x);
EXPLAIN (COSTS OFF) UPDATE only t1 SET b = b || '_updt' WHERE f_leak(b);
UPDATE ONLY x SET x = x || '_updt' WHERE F_LEAK(x);
/* returning clause with system column */ UPDATE ONLY x SET x = x WHERE F_LEAK(x) RETURNING CAST(x AS REGCLASS), *, x;
UPDATE x SET x = x WHERE F_LEAK(x) RETURNING *;
UPDATE x SET x = x WHERE F_LEAK(x) RETURNING CAST(x AS REGCLASS), *, x;
/* updates with from clause */ EXPLAIN (COSTS OFF) UPDATE t2 SET b=t2.b FROM t3 WHERE t2.a = 3 and t3.a = 2 AND f_leak(t2.b) AND f_leak(t3.b);
UPDATE x SET x = x.x FROM x WHERE x.x = 3 AND x.x = 2 AND F_LEAK(x.x) AND F_LEAK(x.x);
EXPLAIN (COSTS OFF) UPDATE t1 SET b=t1.b FROM t2 WHERE t1.a = 3 and t2.a = 3 AND f_leak(t1.b) AND f_leak(t2.b);
UPDATE x SET x = x.x FROM x WHERE x.x = 3 AND x.x = 3 AND F_LEAK(x.x) AND F_LEAK(x.x);
EXPLAIN (COSTS OFF) UPDATE t2 SET b=t2.b FROM t1 WHERE t1.a = 3 and t2.a = 3 AND f_leak(t1.b) AND f_leak(t2.b);
UPDATE x SET x = x.x FROM x WHERE x.x = 3 AND x.x = 3 AND F_LEAK(x.x) AND F_LEAK(x.x);
/* updates with from clause self join */ EXPLAIN (COSTS OFF) UPDATE t2 t2_1 SET b = t2_2.b FROM t2 t2_2 WHERE t2_1.a = 3 AND t2_2.a = t2_1.a AND t2_2.b = t2_1.b AND f_leak(t2_1.b) AND f_leak(t2_2.b) RETURNING *, t2_1, t2_2;
UPDATE x AS x SET x = x.x FROM x AS x WHERE x.x = 3 AND x.x = x.x AND x.x = x.x AND F_LEAK(x.x) AND F_LEAK(x.x) RETURNING *, x, x;
EXPLAIN (COSTS OFF) UPDATE t1 t1_1 SET b = t1_2.b FROM t1 t1_2 WHERE t1_1.a = 4 AND t1_2.a = t1_1.a AND t1_2.b = t1_1.b AND f_leak(t1_1.b) AND f_leak(t1_2.b) RETURNING *, t1_1, t1_2;
UPDATE x AS x SET x = x.x FROM x AS x WHERE x.x = 4 AND x.x = x.x AND x.x = x.x AND F_LEAK(x.x) AND F_LEAK(x.x) RETURNING *, x, x;
RESET SESSION AUTHORIZATION;
SET x = OFF;
SELECT * FROM x ORDER BY x NULLS LAST, x NULLS LAST;
SET SESSION AUTHORIZATION regress_rls_bob;
SET x = ON;
EXPLAIN (COSTS OFF) DELETE FROM only t1 WHERE f_leak(b);
EXPLAIN (COSTS OFF) DELETE FROM t1 WHERE f_leak(b);
DELETE FROM ONLY x WHERE F_LEAK(x) RETURNING CAST(x AS REGCLASS), *, x;
DELETE FROM x WHERE F_LEAK(x) RETURNING CAST(x AS REGCLASS), *, x;
/* S.b. view on top of Row-level security */ SET SESSION AUTHORIZATION regress_rls_alice;
CREATE TABLE x (x INT, x TEXT);
INSERT INTO x (SELECT x, x.fipshash(CAST(x AS TEXT)) FROM x AS x);
CREATE POLICY p1 ON b1 USING (a % 2 = 0);
ALTER TABLE b1 ENABLE ROW LEVEL SECURITY;
GRANT ALL ON x TO x;
SET SESSION AUTHORIZATION regress_rls_bob;
GRANT ALL ON x TO x;
SET SESSION AUTHORIZATION regress_rls_carol;
EXPLAIN (COSTS OFF) SELECT * FROM bv1 WHERE f_leak(b);
SELECT * FROM x WHERE F_LEAK(x);
INSERT INTO x VALUES (-1, 'xxx');
/* should fail view WCO */ INSERT INTO x VALUES (11, 'xxx');
/* should fail RLS check */ INSERT INTO x VALUES (12, 'xxx');
/* ok */ EXPLAIN (COSTS OFF) UPDATE bv1 SET b = 'yyy' WHERE a = 4 AND f_leak(b);
UPDATE x SET x = 'yyy' WHERE x = 4 AND F_LEAK(x);
EXPLAIN (COSTS OFF) DELETE FROM bv1 WHERE a = 6 AND f_leak(b);
DELETE FROM x WHERE x = 6 AND F_LEAK(x);
SET SESSION AUTHORIZATION regress_rls_alice;
SELECT * FROM x;
/* INSERT ... ON CONFLICT DO UPDATE and Row-level security */ SET SESSION AUTHORIZATION regress_rls_alice;
DROP POLICY p1 ON document;
DROP POLICY p1r ON document;
CREATE POLICY p1 ON document FOR SELECT USING (true);
CREATE POLICY p2 ON document FOR INSERT WITH CHECK (dauthor = current_user);
CREATE POLICY p3 ON document FOR UPDATE   USING (cid = (SELECT cid from category WHERE cname = 'novel'))   WITH CHECK (dauthor = current_user);
SET SESSION AUTHORIZATION regress_rls_bob;
/* Exists... */ SELECT * FROM x WHERE x = 2;
/* ...so violates actual WITH CHECK OPTION within UPDATE (not INSERT, since */ /* alternative UPDATE path happens to be taken): */ INSERT INTO x VALUES (2, (SELECT x FROM x WHERE x = 'novel'), 1, 'regress_rls_carol', 'my first novel') ON CONFLICT(x) DO UPDATE SET x = x.x, x = x.x;
/* Violates USING qual for UPDATE policy p3. */ /* UPDATE path is taken, but UPDATE fails purely because *existing* row to be */ /* updated is not a "novel"/cid 11 (row is not leaked, even though we have */ /* SELECT privileges sufficient to see the row in this instance): */ INSERT INTO x VALUES (33, 22, 1, 'regress_rls_bob', 'okay science fiction');
/* preparation for next statement */ INSERT INTO x VALUES (33, (SELECT x FROM x WHERE x = 'novel'), 1, 'regress_rls_bob', 'Some novel, replaces sci-fi') /* takes UPDATE path */ ON CONFLICT(x) DO UPDATE SET x = x.x;
/* Fine (we UPDATE, since INSERT WCOs and UPDATE security barrier quals + WCOs */ /* not violated): */ INSERT INTO x VALUES (2, (SELECT x FROM x WHERE x = 'novel'), 1, 'regress_rls_bob', 'my first novel') ON CONFLICT(x) DO UPDATE SET x = x.x RETURNING *;
/* Fine (we INSERT, so "cid = 33" ("technology") isn't evaluated): */ INSERT INTO x VALUES (78, (SELECT x FROM x WHERE x = 'novel'), 1, 'regress_rls_bob', 'some technology novel') ON CONFLICT(x) DO UPDATE SET x = x.x, x = 33 RETURNING *;
/* Fine (same query, but we UPDATE, so "cid = 33", ("technology") is not the */ /* case in respect of *existing* tuple): */ INSERT INTO x VALUES (78, (SELECT x FROM x WHERE x = 'novel'), 1, 'regress_rls_bob', 'some technology novel') ON CONFLICT(x) DO UPDATE SET x = x.x, x = 33 RETURNING *;
/* Same query a third time, but now fails due to existing tuple finally not */ /* passing quals: */ INSERT INTO x VALUES (78, (SELECT x FROM x WHERE x = 'novel'), 1, 'regress_rls_bob', 'some technology novel') ON CONFLICT(x) DO UPDATE SET x = x.x, x = 33 RETURNING *;
/* Don't fail just because INSERT doesn't satisfy WITH CHECK option that */ /* originated as a barrier/USING() qual from the UPDATE.  Note that the UPDATE */ /* path *isn't* taken, and so UPDATE-related policy does not apply: */ INSERT INTO x VALUES (79, (SELECT x FROM x WHERE x = 'technology'), 1, 'regress_rls_bob', 'technology book, can only insert') ON CONFLICT(x) DO UPDATE SET x = x.x RETURNING *;
/* But this time, the same statement fails, because the UPDATE path is taken, */ /* and updating the row just inserted falls afoul of security barrier qual */ /* (enforced as WCO) -- what we might have updated target tuple to is */ /* irrelevant, in fact. */ INSERT INTO x VALUES (79, (SELECT x FROM x WHERE x = 'technology'), 1, 'regress_rls_bob', 'technology book, can only insert') ON CONFLICT(x) DO UPDATE SET x = x.x RETURNING *;
/* Test default USING qual enforced as WCO */ SET SESSION AUTHORIZATION regress_rls_alice;
DROP POLICY p1 ON document;
DROP POLICY p2 ON document;
DROP POLICY p3 ON document;
CREATE POLICY p3_with_default ON document FOR UPDATE   USING (cid = (SELECT cid from category WHERE cname = 'novel'));
SET SESSION AUTHORIZATION regress_rls_bob;
/* Just because WCO-style enforcement of USING quals occurs with */ /* existing/target tuple does not mean that the implementation can be allowed */ /* to fail to also enforce this qual against the final tuple appended to */ /* relation (since in the absence of an explicit WCO, this is also interpreted */ /* as an UPDATE/ALL WCO in general). */ /* UPDATE path is taken here (fails due to existing tuple).  Note that this is */ /* not reported as a "USING expression", because it's an RLS UPDATE check that originated as */ /* a USING qual for the purposes of RLS in general, as opposed to an explicit */ /* USING qual that is ordinarily a security barrier.  We leave it up to the */ /* UPDATE to make this fail: */ INSERT INTO x VALUES (79, (SELECT x FROM x WHERE x = 'technology'), 1, 'regress_rls_bob', 'technology book, can only insert') ON CONFLICT(x) DO UPDATE SET x = x.x RETURNING *;
/* UPDATE path is taken here.  Existing tuple passes, since its cid */ /* corresponds to "novel", but default USING qual is enforced against */ /* post-UPDATE tuple too (as always when updating with a policy that lacks an */ /* explicit WCO), and so this fails: */ INSERT INTO x VALUES (2, (SELECT x FROM x WHERE x = 'technology'), 1, 'regress_rls_bob', 'my first novel') ON CONFLICT(x) DO UPDATE SET x = x.x, x = x.x RETURNING *;
SET SESSION AUTHORIZATION regress_rls_alice;
DROP POLICY p3_with_default ON document;
/* Test ALL policies with ON CONFLICT DO UPDATE (much the same as existing UPDATE */ /* tests) */ CREATE POLICY p3_with_all ON document FOR ALL   USING (cid = (SELECT cid from category WHERE cname = 'novel'))   WITH CHECK (dauthor = current_user);
SET SESSION AUTHORIZATION regress_rls_bob;
/* Fails, since ALL WCO is enforced in insert path: */ INSERT INTO x VALUES (80, (SELECT x FROM x WHERE x = 'novel'), 1, 'regress_rls_carol', 'my first novel') ON CONFLICT(x) DO UPDATE SET x = x.x, x = 33;
/* Fails, since ALL policy USING qual is enforced (existing, target tuple is in */ /* violation, since it has the "manga" cid): */ INSERT INTO x VALUES (4, (SELECT x FROM x WHERE x = 'novel'), 1, 'regress_rls_bob', 'my first novel') ON CONFLICT(x) DO UPDATE SET x = x.x;
/* Fails, since ALL WCO are enforced: */ INSERT INTO x VALUES (1, (SELECT x FROM x WHERE x = 'novel'), 1, 'regress_rls_bob', 'my first novel') ON CONFLICT(x) DO UPDATE SET x = 'regress_rls_carol';
/* MERGE */ RESET SESSION AUTHORIZATION;
DROP POLICY p3_with_all ON document;
ALTER TABLE x ADD COLUMN x TEXT DEFAULT '';
/* all documents are readable */ CREATE POLICY p1 ON document FOR SELECT USING (true);
/* one may insert documents only authored by them */ CREATE POLICY p2 ON document FOR INSERT WITH CHECK (dauthor = current_user);
/* one may only update documents in 'novel' category and new dlevel must be > 0 */ CREATE POLICY p3 ON document FOR UPDATE   USING (cid = (SELECT cid from category WHERE cname = 'novel'))   WITH CHECK (dlevel > 0);
/* one may only delete documents in 'manga' category */ CREATE POLICY p4 ON document FOR DELETE   USING (cid = (SELECT cid from category WHERE cname = 'manga'));
SELECT * FROM x;
SET SESSION AUTHORIZATION regress_rls_bob;
MERGE INTO x AS x USING (SELECT 1 AS x) AS x ON x = x.x WHEN MATCHED THEN UPDATE SET x = x || ' notes added by merge1 ', x = 0 /* Fails, since update violates WITH CHECK qual on dlevel */;
MERGE INTO x AS x USING (SELECT 1 AS x) AS x ON x = x.x WHEN MATCHED THEN UPDATE SET x = x || ' notes added by merge2 ' /* Should be OK since USING and WITH CHECK quals pass */;
MERGE INTO x AS x USING (SELECT 1 AS x) AS x ON x = x.x WHEN MATCHED THEN UPDATE SET x = x || ' notes added by merge3 ', x = 1 /* Even when dlevel is updated explicitly, but to the existing value */;
MERGE INTO x AS x USING (SELECT 3 AS x) AS x ON x = x.x WHEN MATCHED THEN UPDATE SET x = x || ' notes added by merge ' /* There is a MATCH for did = 3, but UPDATE's USING qual does not allow */ /* updating an item in category 'science fiction' */;
MERGE INTO x AS x USING (SELECT 3 AS x) AS x ON x = x.x WHEN MATCHED THEN DELETE /* The same thing with DELETE action, but fails again because no permissions */ /* to delete items in 'science fiction' category that did 3 belongs to. */;
MERGE INTO x AS x USING (SELECT 4 AS x) AS x ON x = x.x WHEN MATCHED AND x = '' THEN UPDATE SET x = x || ' notes added by merge ' WHEN MATCHED THEN DELETE /* Document with did 4 belongs to 'manga' category which is allowed for */ /* deletion. But this fails because the UPDATE action is matched first and */ /* UPDATE policy does not allow updation in the category. */;
MERGE INTO x AS x USING (SELECT 4 AS x) AS x ON x = x.x WHEN MATCHED AND x <> '' THEN UPDATE SET x = x || ' notes added by merge ' WHEN MATCHED THEN DELETE /* UPDATE action is not matched this time because of the WHEN qual. */ /* DELETE still fails because role regress_rls_bob does not have SELECT */ /* privileges on 'manga' category row in the category table. */;
MERGE INTO x AS x USING (SELECT 4 AS x) AS x ON x = x.x WHEN MATCHED AND x <> '' THEN UPDATE SET x = x || ' notes added by merge ' WHEN MATCHED THEN DO NOTHING /* OK if DELETE is replaced with DO NOTHING */;
SELECT * FROM x WHERE x = 4;
/* Switch to regress_rls_carol role and try the DELETE again. It should succeed */ /* this time */ RESET SESSION AUTHORIZATION;
SET SESSION AUTHORIZATION regress_rls_carol;
MERGE INTO x AS x USING (SELECT 4 AS x) AS x ON x = x.x WHEN MATCHED AND x <> '' THEN UPDATE SET x = x || ' notes added by merge ' WHEN MATCHED THEN DELETE;
/* Switch back to regress_rls_bob role */ RESET SESSION AUTHORIZATION;
SET SESSION AUTHORIZATION regress_rls_bob;
MERGE INTO x AS x USING (SELECT 12 AS x) AS x ON x = x.x WHEN MATCHED THEN DELETE WHEN NOT MATCHED THEN INSERT VALUES (12, 11, 1, 'regress_rls_dave', 'another novel') /* Try INSERT action. This fails because we are trying to insert */ /* dauthor = regress_rls_dave and INSERT's WITH CHECK does not allow */ /* that */;
MERGE INTO x AS x USING (SELECT 12 AS x) AS x ON x = x.x WHEN MATCHED THEN DELETE WHEN NOT MATCHED THEN INSERT VALUES (12, 11, 1, 'regress_rls_bob', 'another novel') /* This should be fine */;
MERGE INTO x AS x USING (SELECT 1 AS x) AS x ON x = x.x WHEN MATCHED THEN UPDATE SET x = x || ' notes added by merge4 ' WHEN NOT MATCHED THEN INSERT VALUES (12, 11, 1, 'regress_rls_bob', 'another novel') /* ok */;
/* drop and create a new SELECT policy which prevents us from reading */ /* any document except with category 'novel' */ RESET SESSION AUTHORIZATION;
DROP POLICY p1 ON document;
CREATE POLICY p1 ON document FOR SELECT   USING (cid = (SELECT cid from category WHERE cname = 'novel'));
SET SESSION AUTHORIZATION regress_rls_bob;
MERGE INTO x AS x USING (SELECT 7 AS x) AS x ON x = x.x WHEN MATCHED THEN UPDATE SET x = x || ' notes added by merge5 ' WHEN NOT MATCHED THEN INSERT VALUES (12, 11, 1, 'regress_rls_bob', 'another novel') /* MERGE can no longer see the matching row and hence attempts the */ /* NOT MATCHED action, which results in unique key violation */;
MERGE INTO x AS x USING (SELECT 1 AS x) AS x ON x = x.x WHEN MATCHED THEN UPDATE SET x = x || ' notes added by merge6 ', x = (SELECT x FROM x WHERE x = 'technology') /* UPDATE action fails if new row is not visible */;
MERGE INTO x AS x USING (SELECT 1 AS x) AS x ON x = x.x WHEN MATCHED THEN UPDATE SET x = x || ' notes added by merge7 ', x = (SELECT x FROM x WHERE x = 'novel') /* but OK if new row is visible */;
MERGE INTO x AS x USING (SELECT 13 AS x) AS x ON x = x.x WHEN MATCHED THEN UPDATE SET x = x || ' notes added by merge8 ' WHEN NOT MATCHED THEN INSERT VALUES (13, 44, 1, 'regress_rls_bob', 'new manga') /* OK to insert a new row that is not visible */;
SELECT * FROM x WHERE x = 13;
MERGE INTO x AS x USING (SELECT 14 AS x) AS x ON x = x.x WHEN MATCHED THEN UPDATE SET x = x || ' notes added by merge9 ' WHEN NOT MATCHED THEN INSERT VALUES (14, 44, 1, 'regress_rls_bob', 'new manga') RETURNING * /* but not OK if RETURNING is used */;
MERGE INTO x AS x USING (SELECT 14 AS x) AS x ON x = x.x WHEN MATCHED THEN UPDATE SET x = x || ' notes added by merge10 ' WHEN NOT MATCHED THEN INSERT VALUES (14, 11, 1, 'regress_rls_bob', 'new novel') RETURNING * /* but OK if new row is visible */;
RESET SESSION AUTHORIZATION;
/* drop the restrictive SELECT policy so that we can look at the */ /* final state of the table */ DROP POLICY p1 ON document;
/* Just check everything went per plan */ SELECT * FROM x;
/* ROLE/GROUP */ SET SESSION AUTHORIZATION regress_rls_alice;
CREATE TABLE x (x INT, x TEXT);
CREATE TABLE x (x INT, x TEXT);
GRANT SELECT ON z1,z2 TO regress_rls_group1, regress_rls_group2,     regress_rls_bob, regress_rls_carol;
INSERT INTO x VALUES (1, 'aba'), (2, 'bbb'), (3, 'ccc'), (4, 'dad');
CREATE POLICY p1 ON z1 TO regress_rls_group1 USING (a % 2 = 0);
CREATE POLICY p2 ON z1 TO regress_rls_group2 USING (a % 2 = 1);
ALTER TABLE z1 ENABLE ROW LEVEL SECURITY;
SET SESSION AUTHORIZATION regress_rls_bob;
SELECT * FROM x WHERE F_LEAK(x);
EXPLAIN (COSTS OFF) SELECT * FROM z1 WHERE f_leak(b);
PREPARE plancache_test AS SELECT * FROM z1 WHERE f_leak(b);
EXPLAIN (COSTS OFF) EXECUTE plancache_test;
PREPARE plancache_test2 AS WITH q AS MATERIALIZED (SELECT * FROM z1 WHERE f_leak(b)) SELECT * FROM q,z2;
EXPLAIN (COSTS OFF) EXECUTE plancache_test2;
PREPARE plancache_test3 AS WITH q AS MATERIALIZED (SELECT * FROM z2) SELECT * FROM q,z1 WHERE f_leak(z1.b);
EXPLAIN (COSTS OFF) EXECUTE plancache_test3;
SET ROLE regress_rls_group1;
SELECT * FROM x WHERE F_LEAK(x);
EXPLAIN (COSTS OFF) SELECT * FROM z1 WHERE f_leak(b);
EXPLAIN (COSTS OFF) EXECUTE plancache_test;
EXPLAIN (COSTS OFF) EXECUTE plancache_test2;
EXPLAIN (COSTS OFF) EXECUTE plancache_test3;
SET SESSION AUTHORIZATION regress_rls_carol;
SELECT * FROM x WHERE F_LEAK(x);
EXPLAIN (COSTS OFF) SELECT * FROM z1 WHERE f_leak(b);
EXPLAIN (COSTS OFF) EXECUTE plancache_test;
EXPLAIN (COSTS OFF) EXECUTE plancache_test2;
EXPLAIN (COSTS OFF) EXECUTE plancache_test3;
SET ROLE regress_rls_group2;
SELECT * FROM x WHERE F_LEAK(x);
EXPLAIN (COSTS OFF) SELECT * FROM z1 WHERE f_leak(b);
EXPLAIN (COSTS OFF) EXECUTE plancache_test;
EXPLAIN (COSTS OFF) EXECUTE plancache_test2;
EXPLAIN (COSTS OFF) EXECUTE plancache_test3;
/* Views should follow policy for view owner. */ /* View and Table owner are the same. */ SET SESSION AUTHORIZATION regress_rls_alice;
CREATE VIEW x AS SELECT * FROM x WHERE F_LEAK(x);
GRANT SELECT ON x TO x;
/* Query as role that is not owner of view or table.  Should return all records. */ SET SESSION AUTHORIZATION regress_rls_bob;
SELECT * FROM x;
EXPLAIN (COSTS OFF) SELECT * FROM rls_view;
/* Query as view/table owner.  Should return all records. */ SET SESSION AUTHORIZATION regress_rls_alice;
SELECT * FROM x;
EXPLAIN (COSTS OFF) SELECT * FROM rls_view;
DROP VIEW x;
/* View and Table owners are different. */ SET SESSION AUTHORIZATION regress_rls_bob;
CREATE VIEW x AS SELECT * FROM x WHERE F_LEAK(x);
GRANT SELECT ON x TO x;
/* Query as role that is not owner of view but is owner of table. */ /* Should return records based on view owner policies. */ SET SESSION AUTHORIZATION regress_rls_alice;
SELECT * FROM x;
EXPLAIN (COSTS OFF) SELECT * FROM rls_view;
/* Query as role that is not owner of table but is owner of view. */ /* Should return records based on view owner policies. */ SET SESSION AUTHORIZATION regress_rls_bob;
SELECT * FROM x;
EXPLAIN (COSTS OFF) SELECT * FROM rls_view;
/* Query as role that is not the owner of the table or view without permissions. */ SET SESSION AUTHORIZATION regress_rls_carol;
SELECT * FROM x;
/* fail - permission denied. */ EXPLAIN (COSTS OFF) SELECT * FROM rls_view;
/* fail - permission denied. */ /* Query as role that is not the owner of the table or view with permissions. */ SET SESSION AUTHORIZATION regress_rls_bob;
GRANT SELECT ON x TO x;
SET SESSION AUTHORIZATION regress_rls_carol;
SELECT * FROM x;
EXPLAIN (COSTS OFF) SELECT * FROM rls_view;
/* Policy requiring access to another table. */ SET SESSION AUTHORIZATION regress_rls_alice;
CREATE TABLE x (x INT);
INSERT INTO x VALUES (3), (4);
CREATE POLICY p3 ON z1 AS RESTRICTIVE USING (a NOT IN (SELECT a FROM z1_blacklist));
/* Query as role that is not owner of table but is owner of view without permissions. */ SET SESSION AUTHORIZATION regress_rls_bob;
SELECT * FROM x;
/* fail - permission denied. */ EXPLAIN (COSTS OFF) SELECT * FROM rls_view;
/* fail - permission denied. */ /* Query as role that is not the owner of the table or view without permissions. */ SET SESSION AUTHORIZATION regress_rls_carol;
SELECT * FROM x;
/* fail - permission denied. */ EXPLAIN (COSTS OFF) SELECT * FROM rls_view;
/* fail - permission denied. */ /* Query as role that is not owner of table but is owner of view with permissions. */ SET SESSION AUTHORIZATION regress_rls_alice;
GRANT SELECT ON x TO x;
SET SESSION AUTHORIZATION regress_rls_bob;
SELECT * FROM x;
EXPLAIN (COSTS OFF) SELECT * FROM rls_view;
/* Query as role that is not the owner of the table or view with permissions. */ SET SESSION AUTHORIZATION regress_rls_carol;
SELECT * FROM x;
EXPLAIN (COSTS OFF) SELECT * FROM rls_view;
SET SESSION AUTHORIZATION regress_rls_alice;
REVOKE SELECT ON z1_blacklist FROM regress_rls_bob;
DROP POLICY p3 ON z1;
SET SESSION AUTHORIZATION regress_rls_bob;
DROP VIEW x;
/* Security invoker views should follow policy for current user. */ /* View and table owner are the same. */ SET SESSION AUTHORIZATION regress_rls_alice;
GRANT SELECT ON x TO x;
GRANT SELECT ON x TO x;
/* Query as table owner.  Should return all records. */ SELECT * FROM x;
EXPLAIN (COSTS OFF) SELECT * FROM rls_view;
/* Queries as other users. */ /* Should return records based on current user's policies. */ SET SESSION AUTHORIZATION regress_rls_bob;
SELECT * FROM x;
EXPLAIN (COSTS OFF) SELECT * FROM rls_view;
SET SESSION AUTHORIZATION regress_rls_carol;
SELECT * FROM x;
EXPLAIN (COSTS OFF) SELECT * FROM rls_view;
/* View and table owners are different. */ SET SESSION AUTHORIZATION regress_rls_alice;
DROP VIEW x;
SET SESSION AUTHORIZATION regress_rls_bob;
GRANT SELECT ON x TO x;
GRANT SELECT ON x TO x;
/* Query as table owner.  Should return all records. */ SET SESSION AUTHORIZATION regress_rls_alice;
SELECT * FROM x;
EXPLAIN (COSTS OFF) SELECT * FROM rls_view;
/* Queries as other users. */ /* Should return records based on current user's policies. */ SET SESSION AUTHORIZATION regress_rls_bob;
SELECT * FROM x;
EXPLAIN (COSTS OFF) SELECT * FROM rls_view;
SET SESSION AUTHORIZATION regress_rls_carol;
SELECT * FROM x;
EXPLAIN (COSTS OFF) SELECT * FROM rls_view;
/* Policy requiring access to another table. */ SET SESSION AUTHORIZATION regress_rls_alice;
CREATE POLICY p3 ON z1 AS RESTRICTIVE USING (a NOT IN (SELECT a FROM z1_blacklist));
/* Query as role that is not owner of table but is owner of view without permissions. */ SET SESSION AUTHORIZATION regress_rls_bob;
SELECT * FROM x;
/* fail - permission denied. */ EXPLAIN (COSTS OFF) SELECT * FROM rls_view;
/* fail - permission denied. */ /* Query as role that is not the owner of the table or view without permissions. */ SET SESSION AUTHORIZATION regress_rls_carol;
SELECT * FROM x;
/* fail - permission denied. */ EXPLAIN (COSTS OFF) SELECT * FROM rls_view;
/* fail - permission denied. */ /* Query as role that is not owner of table but is owner of view with permissions. */ SET SESSION AUTHORIZATION regress_rls_alice;
GRANT SELECT ON x TO x;
SET SESSION AUTHORIZATION regress_rls_bob;
SELECT * FROM x;
EXPLAIN (COSTS OFF) SELECT * FROM rls_view;
/* Query as role that is not the owner of the table or view without permissions. */ SET SESSION AUTHORIZATION regress_rls_carol;
SELECT * FROM x;
/* fail - permission denied. */ EXPLAIN (COSTS OFF) SELECT * FROM rls_view;
/* fail - permission denied. */ /* Query as role that is not the owner of the table or view with permissions. */ SET SESSION AUTHORIZATION regress_rls_alice;
GRANT SELECT ON x TO x;
SET SESSION AUTHORIZATION regress_rls_carol;
SELECT * FROM x;
EXPLAIN (COSTS OFF) SELECT * FROM rls_view;
SET SESSION AUTHORIZATION regress_rls_bob;
DROP VIEW x;
/* Command specific */ SET SESSION AUTHORIZATION regress_rls_alice;
CREATE TABLE x (x INT, x TEXT, x TEXT);
GRANT ALL ON x TO x;
INSERT INTO x VALUES (1, 'abc', 'regress_rls_bob'), (2, 'bcd', 'regress_rls_bob'), (3, 'cde', 'regress_rls_carol'), (4, 'def', 'regress_rls_carol'), (5, 'efg', 'regress_rls_bob'), (6, 'fgh', 'regress_rls_bob'), (7, 'fgh', 'regress_rls_carol'), (8, 'fgh', 'regress_rls_carol');
CREATE POLICY p0 ON x1 FOR ALL USING (c = current_user);
CREATE POLICY p1 ON x1 FOR SELECT USING (a % 2 = 0);
CREATE POLICY p2 ON x1 FOR INSERT WITH CHECK (a % 2 = 1);
CREATE POLICY p3 ON x1 FOR UPDATE USING (a % 2 = 0);
CREATE POLICY p4 ON x1 FOR DELETE USING (a < 8);
ALTER TABLE x1 ENABLE ROW LEVEL SECURITY;
SET SESSION AUTHORIZATION regress_rls_bob;
SELECT * FROM x WHERE F_LEAK(x) ORDER BY x ASC NULLS LAST;
UPDATE x SET x = x || '_updt' WHERE F_LEAK(x) RETURNING *;
SET SESSION AUTHORIZATION regress_rls_carol;
SELECT * FROM x WHERE F_LEAK(x) ORDER BY x ASC NULLS LAST;
UPDATE x SET x = x || '_updt' WHERE F_LEAK(x) RETURNING *;
DELETE FROM x WHERE F_LEAK(x) RETURNING *;
/* Duplicate Policy Names */ SET SESSION AUTHORIZATION regress_rls_alice;
CREATE TABLE x (x INT, x TEXT);
CREATE TABLE x (x INT, x TEXT);
GRANT ALL ON y1, y2 TO regress_rls_bob;
CREATE POLICY p1 ON y1 FOR ALL USING (a % 2 = 0);
CREATE POLICY p2 ON y1 FOR SELECT USING (a > 2);
CREATE POLICY p1 ON y1 FOR SELECT USING (a % 2 = 1);
/* fail */ CREATE POLICY p1 ON y2 FOR ALL USING (a % 2 = 0);
/* OK */ ALTER TABLE y1 ENABLE ROW LEVEL SECURITY;
ALTER TABLE y2 ENABLE ROW LEVEL SECURITY;
/* Expression structure with SBV */ /* Create view as table owner.  RLS should NOT be applied. */ SET SESSION AUTHORIZATION regress_rls_alice;
EXPLAIN (COSTS OFF) SELECT * FROM rls_sbv WHERE (a = 1);
DROP VIEW x;
/* Create view as role that does not own table.  RLS should be applied. */ SET SESSION AUTHORIZATION regress_rls_bob;
EXPLAIN (COSTS OFF) SELECT * FROM rls_sbv WHERE (a = 1);
DROP VIEW x;
/* Expression structure */ SET SESSION AUTHORIZATION regress_rls_alice;
INSERT INTO x (SELECT x, x.fipshash(CAST(x AS TEXT)) FROM x AS x);
CREATE POLICY p2 ON y2 USING (a % 3 = 0);
CREATE POLICY p3 ON y2 USING (a % 4 = 0);
SET SESSION AUTHORIZATION regress_rls_bob;
SELECT * FROM x WHERE F_LEAK(x);
EXPLAIN (COSTS OFF) SELECT * FROM y2 WHERE f_leak(b);
/* Qual push-down of leaky functions, when not referring to table */ SELECT * FROM x WHERE F_LEAK('abc');
EXPLAIN (COSTS OFF) SELECT * FROM y2 WHERE f_leak('abc');
CREATE TABLE x (x TEXT);
INSERT INTO x VALUES ('abc'), ('def');
SELECT * FROM x JOIN x ON (x = x) WHERE F_LEAK(x);
EXPLAIN (COSTS OFF) SELECT * FROM y2 JOIN test_qual_pushdown ON (b = abc) WHERE f_leak(abc);
SELECT * FROM x JOIN x ON (x = x) WHERE F_LEAK(x);
EXPLAIN (COSTS OFF) SELECT * FROM y2 JOIN test_qual_pushdown ON (b = abc) WHERE f_leak(b);
DROP TABLE x;
/* Plancache invalidate on user change. */ RESET SESSION AUTHORIZATION;
DROP TABLE x CASCADE;
CREATE TABLE x (x INT);
GRANT SELECT ON x TO x, x;
CREATE POLICY p1 ON t1 TO regress_rls_bob USING ((a % 2) = 0);
CREATE POLICY p2 ON t1 TO regress_rls_carol USING ((a % 4) = 0);
ALTER TABLE t1 ENABLE ROW LEVEL SECURITY;
/* Prepare as regress_rls_bob */ SET ROLE regress_rls_bob;
PREPARE role_inval AS SELECT * FROM t1;
/* Check plan */ EXPLAIN (COSTS OFF) EXECUTE role_inval;
/* Change to regress_rls_carol */ SET ROLE regress_rls_carol;
/* Check plan- should be different */ EXPLAIN (COSTS OFF) EXECUTE role_inval;
/* Change back to regress_rls_bob */ SET ROLE regress_rls_bob;
/* Check plan- should be back to original */ EXPLAIN (COSTS OFF) EXECUTE role_inval;
/* CTE and RLS */ RESET SESSION AUTHORIZATION;
DROP TABLE x CASCADE;
CREATE TABLE x (x INT, x TEXT);
CREATE POLICY p1 ON t1 USING (a % 2 = 0);
ALTER TABLE t1 ENABLE ROW LEVEL SECURITY;
GRANT ALL ON x TO x;
INSERT INTO x (SELECT x, x.fipshash(CAST(x AS TEXT)) FROM x AS x);
SET SESSION AUTHORIZATION regress_rls_bob;
WITH x AS MATERIALIZED (SELECT * FROM x WHERE F_LEAK(x)) SELECT * FROM x;
EXPLAIN (COSTS OFF) WITH cte1 AS MATERIALIZED (SELECT * FROM t1 WHERE f_leak(b)) SELECT * FROM cte1;
WITH x AS (UPDATE x SET x = x + 1 RETURNING *) SELECT * FROM x;
/* fail */ WITH x AS (UPDATE x SET x = x RETURNING *) SELECT * FROM x;
/* ok */ WITH x AS (INSERT INTO x VALUES (21, 'Fail') RETURNING *) SELECT * FROM x;
/* fail */ WITH x AS (INSERT INTO x VALUES (20, 'Success') RETURNING *) SELECT * FROM x;
/* ok */ /* Rename Policy */ RESET SESSION AUTHORIZATION;
ALTER POLICY p1 ON t1 RENAME TO p1;
/* fail */ SELECT x, x FROM x AS x JOIN x AS x ON (x.x = x.x) WHERE x = 't1';
ALTER POLICY p1 ON t1 RENAME TO p2;
/* ok */ SELECT x, x FROM x AS x JOIN x AS x ON (x.x = x.x) WHERE x = 't1';
/* Check INSERT SELECT */ SET SESSION AUTHORIZATION regress_rls_bob;
CREATE TABLE x (x INT, x TEXT);
INSERT INTO x (SELECT * FROM x);
EXPLAIN (COSTS OFF) INSERT INTO t2 (SELECT * FROM t1);
SELECT * FROM x;
EXPLAIN (COSTS OFF) SELECT * FROM t2;
CREATE TABLE x AS SELECT * FROM x;
SELECT * FROM x;
CREATE TABLE x AS SELECT * FROM x;
SELECT * FROM x;
/* RLS with JOIN */ SET SESSION AUTHORIZATION regress_rls_alice;
CREATE TABLE x (x INT, x TEXT, x TEXT);
CREATE TABLE x (x INT, x TEXT);
GRANT ALL ON blog, comment TO regress_rls_bob;
CREATE POLICY blog_1 ON blog USING (id % 2 = 0);
ALTER TABLE blog ENABLE ROW LEVEL SECURITY;
INSERT INTO x VALUES (1, 'alice', 'blog #1'), (2, 'bob', 'blog #1'), (3, 'alice', 'blog #2'), (4, 'alice', 'blog #3'), (5, 'john', 'blog #1');
INSERT INTO x VALUES (1, 'cool blog'), (1, 'fun blog'), (3, 'crazy blog'), (5, 'what?'), (4, 'insane!'), (2, 'who did it?');
SET SESSION AUTHORIZATION regress_rls_bob;
/* Check RLS JOIN with Non-RLS. */ SELECT x, x, x FROM x JOIN x ON x = x;
/* Check Non-RLS JOIN with RLS. */ SELECT x, x, x FROM x JOIN x ON x = x;
SET SESSION AUTHORIZATION regress_rls_alice;
CREATE POLICY comment_1 ON comment USING (blog_id < 4);
ALTER TABLE comment ENABLE ROW LEVEL SECURITY;
SET SESSION AUTHORIZATION regress_rls_bob;
/* Check RLS JOIN RLS */ SELECT x, x, x FROM x JOIN x ON x = x;
SELECT x, x, x FROM x JOIN x ON x = x;
SET SESSION AUTHORIZATION regress_rls_alice;
/* Default Deny Policy */ RESET SESSION AUTHORIZATION;
DROP POLICY p2 ON t1;
ALTER TABLE t1 OWNER TO regress_rls_alice;
/* Check that default deny does not apply to superuser. */ RESET SESSION AUTHORIZATION;
SELECT * FROM x;
EXPLAIN (COSTS OFF) SELECT * FROM t1;
/* Check that default deny does not apply to table owner. */ SET SESSION AUTHORIZATION regress_rls_alice;
SELECT * FROM x;
EXPLAIN (COSTS OFF) SELECT * FROM t1;
/* Check that default deny applies to non-owner/non-superuser when RLS on. */ SET SESSION AUTHORIZATION regress_rls_bob;
SET x = ON;
SELECT * FROM x;
EXPLAIN (COSTS OFF) SELECT * FROM t1;
SET SESSION AUTHORIZATION regress_rls_bob;
SELECT * FROM x;
EXPLAIN (COSTS OFF) SELECT * FROM t1;
/* COPY TO/FROM */ RESET SESSION AUTHORIZATION;
DROP TABLE x CASCADE;
CREATE TABLE x (x INT, x TEXT);
CREATE POLICY p1 ON copy_t USING (a % 2 = 0);
ALTER TABLE copy_t ENABLE ROW LEVEL SECURITY;
GRANT ALL ON x TO x, x;
INSERT INTO x (SELECT x, x.fipshash(CAST(x AS TEXT)) FROM x AS x);
/* Check COPY TO as Superuser/owner. */ RESET SESSION AUTHORIZATION;
SET x = OFF;
COPY INTO (SELECT * FROM x ORDER BY x ASC NULLS LAST) TO x WITH (DELIMITER ',');
SET x = ON;
COPY INTO (SELECT * FROM x ORDER BY x ASC NULLS LAST) TO x WITH (DELIMITER ',');
/* Check COPY TO as user with permissions. */ SET SESSION AUTHORIZATION regress_rls_bob;
SET x = OFF;
COPY INTO (SELECT * FROM x ORDER BY x ASC NULLS LAST) TO x WITH (DELIMITER ',');
SET x = ON /* fail - would be affected by RLS */;
COPY INTO (SELECT * FROM x ORDER BY x ASC NULLS LAST) TO x WITH (DELIMITER ',');
/* ok */ /* Check COPY TO as user with permissions and BYPASSRLS */ SET SESSION AUTHORIZATION regress_rls_exempt_user;
SET x = OFF;
COPY INTO (SELECT * FROM x ORDER BY x ASC NULLS LAST) TO x WITH (DELIMITER ',');
SET x = ON /* ok */;
COPY INTO (SELECT * FROM x ORDER BY x ASC NULLS LAST) TO x WITH (DELIMITER ',');
SET SESSION AUTHORIZATION regress_rls_carol;
SET x = OFF;
COPY INTO (SELECT * FROM x ORDER BY x ASC NULLS LAST) TO x WITH (DELIMITER ',');
SET x = ON /* fail - would be affected by RLS */;
COPY INTO (SELECT * FROM x ORDER BY x ASC NULLS LAST) TO x WITH (DELIMITER ',');
SET x = ON;
CREATE TABLE x (x INT, x TEXT);
CREATE POLICY p1 ON copy_rel_to USING (a % 2 = 0);
ALTER TABLE copy_rel_to ENABLE ROW LEVEL SECURITY;
GRANT ALL ON x TO x, x;
INSERT INTO x VALUES (1, x.fipshash('1'));
/* Check COPY TO as Superuser/owner. */ RESET SESSION AUTHORIZATION;
SET x = OFF;
COPY INTO x TO x WITH (DELIMITER ',');
SET x = ON;
COPY INTO x TO x WITH (DELIMITER ',');
/* Check COPY TO as user with permissions. */ SET SESSION AUTHORIZATION regress_rls_bob;
SET x = OFF;
COPY INTO x TO x WITH (DELIMITER ',');
SET x = ON /* fail - would be affected by RLS */;
COPY INTO x TO x WITH (DELIMITER ',');
/* ok */ /* Check COPY TO as user with permissions and BYPASSRLS */ SET SESSION AUTHORIZATION regress_rls_exempt_user;
SET x = OFF;
COPY INTO x TO x WITH (DELIMITER ',');
SET x = ON /* ok */;
COPY INTO x TO x WITH (DELIMITER ',');
SET SESSION AUTHORIZATION regress_rls_carol;
SET x = OFF;
COPY INTO x TO x WITH (DELIMITER ',');
SET x = ON /* fail - permission denied */;
COPY INTO x TO x WITH (DELIMITER ',');
/* fail - permission denied */ /* Check behavior with a child table. */ RESET SESSION AUTHORIZATION;
SET x = ON;
CREATE TABLE x INHERITS (x);
INSERT INTO x VALUES (1, 'one'), (2, 'two');
/* Check COPY TO as Superuser/owner. */ RESET SESSION AUTHORIZATION;
SET x = OFF;
COPY INTO x TO x WITH (DELIMITER ',');
SET x = ON;
COPY INTO x TO x WITH (DELIMITER ',');
/* Check COPY TO as user with permissions. */ SET SESSION AUTHORIZATION regress_rls_bob;
SET x = OFF;
COPY INTO x TO x WITH (DELIMITER ',');
SET x = ON /* fail - would be affected by RLS */;
COPY INTO x TO x WITH (DELIMITER ',');
/* ok */ /* Check COPY TO as user with permissions and BYPASSRLS */ SET SESSION AUTHORIZATION regress_rls_exempt_user;
SET x = OFF;
COPY INTO x TO x WITH (DELIMITER ',');
SET x = ON /* ok */;
COPY INTO x TO x WITH (DELIMITER ',');
SET SESSION AUTHORIZATION regress_rls_carol;
SET x = OFF;
COPY INTO x TO x WITH (DELIMITER ',');
SET x = ON /* fail - permission denied */;
COPY INTO x TO x WITH (DELIMITER ',');
/* fail - permission denied */ /* Check COPY FROM as Superuser/owner. */ RESET SESSION AUTHORIZATION;
SET x = OFF;
COPY INTO x FROM x;
COPY INTO x FROM x;
SET x = OFF;
COPY INTO x FROM x;
SET x = ON /* fail - would be affected by RLS. */;
COPY INTO x FROM x;
/* fail - COPY FROM not supported by RLS. */ /* Check COPY FROM as user with permissions and BYPASSRLS */ SET SESSION AUTHORIZATION regress_rls_exempt_user;
SET x = ON;
COPY INTO x FROM x;
SET x = OFF;
COPY INTO x FROM x;
SET x = ON /* fail - permission denied. */;
COPY INTO x FROM x;
/* fail - permission denied. */ RESET SESSION AUTHORIZATION;
DROP TABLE x;
DROP TABLE x CASCADE;
/* Check WHERE CURRENT OF */ SET SESSION AUTHORIZATION regress_rls_alice;
CREATE TABLE x (x INT, x TEXT, x TEXT);
GRANT ALL ON x TO x;
INSERT INTO x VALUES (1, 'abc', 'regress_rls_bob'), (2, 'bcd', 'regress_rls_bob'), (3, 'cde', 'regress_rls_bob'), (4, 'def', 'regress_rls_bob');
CREATE POLICY p1 ON current_check FOR SELECT USING (currentid % 2 = 0);
CREATE POLICY p2 ON current_check FOR DELETE USING (currentid = 4 AND rlsuser = current_user);
CREATE POLICY p3 ON current_check FOR UPDATE USING (currentid = 4) WITH CHECK (rlsuser = current_user);
ALTER TABLE current_check ENABLE ROW LEVEL SECURITY;
SET SESSION AUTHORIZATION regress_rls_bob;
/* Can SELECT even rows */ SELECT * FROM x;
/* Cannot UPDATE row 2 */ UPDATE x SET x = x || '_new' WHERE x = 2 RETURNING *;
BEGIN;
DECLARE current_check_cursor SCROLL CURSOR FOR SELECT * FROM current_check;
/* Returns rows that can be seen according to SELECT policy, like plain SELECT */ /* above (even rows) */ FETCH ABSOLUTE 1 FROM current_check_cursor;
/* Can update row 4 through cursor, which is the next visible row */ FETCH RELATIVE 1 FROM current_check_cursor;
SELECT * FROM x;
/* Plan should be a subquery TID scan */ EXPLAIN (COSTS OFF) UPDATE current_check SET payload = payload WHERE CURRENT OF current_check_cursor;
/* Similarly can only delete row 4 */ FETCH ABSOLUTE 1 FROM current_check_cursor;
FETCH RELATIVE 1 FROM current_check_cursor;
SELECT * FROM x;
COMMIT;
/* Check that RLS filters that are tidquals don't override WHERE CURRENT OF */ BEGIN;
CREATE TABLE x (x INT, x TEXT);
INSERT INTO x VALUES (1, 'Apple');
ALTER TABLE current_check_2 ENABLE ROW LEVEL SECURITY;
ALTER TABLE current_check_2 FORCE ROW LEVEL SECURITY;
/* policy must accept ctid = (InvalidBlockNumber,0) since updates check it */ /* before assigning a ctid to the new row */ CREATE POLICY p1 ON current_check_2 AS PERMISSIVE   USING (ctid IN ('(0,1)', '(0,2)', '(4294967295,0)'));
SELECT x, * FROM x;
DECLARE current_check_cursor CURSOR FOR SELECT * FROM current_check_2;
FETCH FROM current_check_cursor;
EXPLAIN (COSTS OFF) UPDATE current_check_2 SET b = 'Manzana' WHERE CURRENT OF current_check_cursor;
SELECT x, * FROM x;
ROLLBACK;
SET x = ON /* check pg_stats view filtering */;
SET SESSION AUTHORIZATION regress_rls_alice;
ANALYZE x;
/* Stats visible */ SELECT ROW_SECURITY_ACTIVE('current_check');
SELECT x, x FROM x WHERE x = 'current_check' ORDER BY 1 NULLS LAST;
SET SESSION AUTHORIZATION regress_rls_bob;
/* Stats not visible */ SELECT ROW_SECURITY_ACTIVE('current_check');
SELECT x, x FROM x WHERE x = 'current_check' ORDER BY 1 NULLS LAST;
/* Collation support */ BEGIN;
CREATE TABLE x (x) AS VALUES (CAST('bar' AS TEXT));
CREATE POLICY coll_p ON coll_t USING (c < ('foo'::text COLLATE "C"));
ALTER TABLE coll_t ENABLE ROW LEVEL SECURITY;
GRANT SELECT ON x TO x;
SELECT (STRING_TO_ARRAY(x, ':'))[6] AS x FROM x WHERE x = CAST('coll_t' AS REGCLASS);
SET SESSION AUTHORIZATION regress_rls_alice;
SELECT * FROM x;
ROLLBACK;
/* Shared Object Dependencies */ RESET SESSION AUTHORIZATION;
BEGIN;
CREATE ROLE regress_rls_eve;
CREATE ROLE regress_rls_frank;
CREATE TABLE x (x) AS VALUES (CAST('bar' AS TEXT));
GRANT SELECT ON TABLE x TO x;
CREATE POLICY P ON tbl1 TO regress_rls_eve, regress_rls_frank USING (true);
SELECT CAST(x AS REGCLASS), x FROM x WHERE x = CAST('pg_policy' AS REGCLASS) AND x = CAST('tbl1' AS REGCLASS);
SELECT CAST(x AS REGCLASS), x FROM x WHERE x = CAST('pg_policy' AS REGCLASS) AND x IN (CAST('regress_rls_eve' AS REGROLE), CAST('regress_rls_frank' AS REGROLE));
x AS x;
DROP ROLE regress_rls_eve;
ROLLBACK TO x /* fails due to dependency on POLICY p */;
ALTER POLICY p ON tbl1 TO regress_rls_frank USING (true);
x AS x;
DROP ROLE regress_rls_eve;
ROLLBACK TO x /* fails due to dependency on GRANT SELECT */;
REVOKE ALL ON TABLE tbl1 FROM regress_rls_eve;
x AS x;
DROP ROLE regress_rls_eve;
ROLLBACK TO x /* succeeds */;
x AS x;
DROP ROLE regress_rls_frank;
ROLLBACK TO x /* fails due to dependency on POLICY p */;
DROP POLICY p ON tbl1;
x AS x;
DROP ROLE regress_rls_frank;
ROLLBACK TO x /* succeeds */;
ROLLBACK;
/* cleanup */ /* Policy expression handling */ BEGIN;
CREATE TABLE x (x) AS VALUES (CAST('bar' AS TEXT));
CREATE POLICY p ON t USING (max(c));
ROLLBACK /* fails: aggregate functions are not allowed in policy expressions */ /* fails: aggregate functions are not allowed in policy expressions */;
/* Non-target relations are only subject to SELECT policies */ SET SESSION AUTHORIZATION regress_rls_alice;
CREATE TABLE x (x INT);
CREATE TABLE x (x INT);
INSERT INTO x VALUES (10), (20);
INSERT INTO x VALUES (10), (20);
GRANT ALL ON r1, r2 TO regress_rls_bob;
CREATE POLICY p1 ON r1 USING (true);
ALTER TABLE r1 ENABLE ROW LEVEL SECURITY;
CREATE POLICY p1 ON r2 FOR SELECT USING (true);
CREATE POLICY p2 ON r2 FOR INSERT WITH CHECK (false);
CREATE POLICY p3 ON r2 FOR UPDATE USING (false);
CREATE POLICY p4 ON r2 FOR DELETE USING (false);
ALTER TABLE r2 ENABLE ROW LEVEL SECURITY;
SET SESSION AUTHORIZATION regress_rls_bob;
SELECT * FROM x;
SELECT * FROM x;
/* r2 is read-only */ INSERT INTO x VALUES (2);
/* Not allowed */ UPDATE x SET x = 2 RETURNING *;
/* Updates nothing */ DELETE FROM x RETURNING *;
/* Deletes nothing */ /* r2 can be used as a non-target relation in DML */ INSERT INTO x SELECT x + 1 FROM x RETURNING *;
/* OK */ UPDATE x SET x = x.x + 2 FROM x WHERE x.x = x.x RETURNING *;
/* OK */ DELETE FROM x USING x WHERE x.x = x.x + 2 RETURNING *;
/* OK */ SELECT * FROM x;
SELECT * FROM x;
SET SESSION AUTHORIZATION regress_rls_alice;
DROP TABLE x;
DROP TABLE x;
/* FORCE ROW LEVEL SECURITY applies RLS to owners too */ SET SESSION AUTHORIZATION regress_rls_alice;
SET x = on;
CREATE TABLE x (x INT);
INSERT INTO x VALUES (10), (20);
CREATE POLICY p1 ON r1 USING (false);
ALTER TABLE r1 ENABLE ROW LEVEL SECURITY;
ALTER TABLE r1 FORCE ROW LEVEL SECURITY;
x AS x /* No error, but no rows */;
/* RLS error */ INSERT INTO x VALUES (1);
/* No error (unable to see any rows to update) */ UPDATE x SET x = 1;
x AS x;
/* No error (unable to see any rows to delete) */ DELETE FROM x;
x AS x;
SET x = off;
x AS x /* these all fail, would be affected by RLS */;
UPDATE x SET x = 1;
DELETE FROM x;
DROP TABLE x;
/* FORCE ROW LEVEL SECURITY does not break RI */ SET SESSION AUTHORIZATION regress_rls_alice;
SET x = on;
CREATE TABLE x (x INT PRIMARY KEY);
CREATE TABLE x (x INT REFERENCES x);
INSERT INTO x VALUES (10), (20);
INSERT INTO x VALUES (10), (20);
/* Create policies on r2 which prevent the */ /* owner from seeing any rows, but RI should */ /* still see them. */ CREATE POLICY p1 ON r2 USING (false);
ALTER TABLE r2 ENABLE ROW LEVEL SECURITY;
ALTER TABLE r2 FORCE ROW LEVEL SECURITY;
/* Errors due to rows in r2 */ DELETE FROM x;
/* Reset r2 to no-RLS */ DROP POLICY p1 ON r2;
ALTER TABLE r2 NO FORCE ROW LEVEL SECURITY;
ALTER TABLE r2 DISABLE ROW LEVEL SECURITY;
/* clean out r2 for INSERT test below */ DELETE FROM x;
/* Change r1 to not allow rows to be seen */ CREATE POLICY p1 ON r1 USING (false);
ALTER TABLE r1 ENABLE ROW LEVEL SECURITY;
ALTER TABLE r1 FORCE ROW LEVEL SECURITY;
x AS x /* No rows seen */;
/* No error, RI still sees that row exists in r1 */ INSERT INTO x VALUES (10);
DROP TABLE x;
DROP TABLE x;
/* Ensure cascaded DELETE works */ CREATE TABLE x (x INT PRIMARY KEY);
CREATE TABLE x (x INT REFERENCES x ON DELETE CASCADE);
INSERT INTO x VALUES (10), (20);
INSERT INTO x VALUES (10), (20);
/* Create policies on r2 which prevent the */ /* owner from seeing any rows, but RI should */ /* still see them. */ CREATE POLICY p1 ON r2 USING (false);
ALTER TABLE r2 ENABLE ROW LEVEL SECURITY;
ALTER TABLE r2 FORCE ROW LEVEL SECURITY;
/* Deletes all records from both */ DELETE FROM x;
/* Remove FORCE from r2 */ ALTER TABLE r2 NO FORCE ROW LEVEL SECURITY;
x AS x /* As owner, we now bypass RLS */ /* verify no rows in r2 now */;
DROP TABLE x;
DROP TABLE x;
/* Ensure cascaded UPDATE works */ CREATE TABLE x (x INT PRIMARY KEY);
CREATE TABLE x (x INT REFERENCES x ON UPDATE CASCADE);
INSERT INTO x VALUES (10), (20);
INSERT INTO x VALUES (10), (20);
/* Create policies on r2 which prevent the */ /* owner from seeing any rows, but RI should */ /* still see them. */ CREATE POLICY p1 ON r2 USING (false);
ALTER TABLE r2 ENABLE ROW LEVEL SECURITY;
ALTER TABLE r2 FORCE ROW LEVEL SECURITY;
/* Updates records in both */ UPDATE x SET x = x + 5;
/* Remove FORCE from r2 */ ALTER TABLE r2 NO FORCE ROW LEVEL SECURITY;
x AS x /* As owner, we now bypass RLS */ /* verify records in r2 updated */;
DROP TABLE x;
DROP TABLE x;
/* Test INSERT+RETURNING applies SELECT policies as */ /* WithCheckOptions (meaning an error is thrown) */ SET SESSION AUTHORIZATION regress_rls_alice;
SET x = on;
CREATE TABLE x (x INT);
CREATE POLICY p1 ON r1 FOR SELECT USING (false);
CREATE POLICY p2 ON r1 FOR INSERT WITH CHECK (true);
ALTER TABLE r1 ENABLE ROW LEVEL SECURITY;
ALTER TABLE r1 FORCE ROW LEVEL SECURITY;
/* Works fine */ INSERT INTO x VALUES (10), (20);
x AS x /* No error, but no rows */;
SET x = off;
x AS x /* fail, would be affected by RLS */;
SET x = on;
/* Error */ INSERT INTO x VALUES (10), (20) RETURNING *;
DROP TABLE x;
/* Test UPDATE+RETURNING applies SELECT policies as */ /* WithCheckOptions (meaning an error is thrown) */ SET SESSION AUTHORIZATION regress_rls_alice;
SET x = on;
CREATE TABLE x (x INT PRIMARY KEY);
CREATE POLICY p1 ON r1 FOR SELECT USING (a < 20);
CREATE POLICY p2 ON r1 FOR UPDATE USING (a < 20) WITH CHECK (true);
CREATE POLICY p3 ON r1 FOR INSERT WITH CHECK (true);
INSERT INTO x VALUES (10);
ALTER TABLE r1 ENABLE ROW LEVEL SECURITY;
ALTER TABLE r1 FORCE ROW LEVEL SECURITY;
/* Works fine */ UPDATE x SET x = 30;
/* Show updated rows */ ALTER TABLE r1 NO FORCE ROW LEVEL SECURITY;
x AS x;
/* reset value in r1 for test with RETURNING */ UPDATE x SET x = 10;
x AS x /* Verify row reset */;
ALTER TABLE r1 FORCE ROW LEVEL SECURITY;
/* Error */ UPDATE x SET x = 30 RETURNING *;
/* UPDATE path of INSERT ... ON CONFLICT DO UPDATE should also error out */ INSERT INTO x VALUES (10) ON CONFLICT(x) DO UPDATE SET x = 30 RETURNING *;
/* Should still error out without RETURNING (use of arbiter always requires */ /* SELECT permissions) */ INSERT INTO x VALUES (10) ON CONFLICT(x) DO UPDATE SET x = 30;
INSERT INTO x VALUES (10) ON CONFLICT ON CONSTRAINT x DO UPDATE SET x = 30;
DROP TABLE x;
/* Test policies using virtual generated columns */ SET SESSION AUTHORIZATION regress_rls_alice;
SET x = on;
ALTER TABLE r1 ADD c int GENERATED ALWAYS AS (a * 100) VIRTUAL;
INSERT INTO x VALUES (1), (2), (4);
CREATE POLICY p0 ON r1 USING (b * 10 = c);
CREATE POLICY p1 ON r1 AS RESTRICTIVE USING (b > 10);
CREATE POLICY p2 ON r1 AS RESTRICTIVE USING ((SELECT c) < 400);
ALTER TABLE r1 ENABLE ROW LEVEL SECURITY;
ALTER TABLE r1 FORCE ROW LEVEL SECURITY;
/* Should fail p1 */ INSERT INTO x VALUES (0);
/* Should fail p2 */ INSERT INTO x VALUES (4);
/* OK */ INSERT INTO x VALUES (3);
SELECT * FROM x;
DROP TABLE x;
/* Check dependency handling */ RESET SESSION AUTHORIZATION;
CREATE TABLE x (x INT);
CREATE TABLE x (x INT);
CREATE POLICY dep_p1 ON dep1 TO regress_rls_bob USING (c1 > (select max(dep2.c1) from dep2));
ALTER POLICY dep_p1 ON dep1 TO regress_rls_bob,regress_rls_carol;
/* Should return one */ SELECT COUNT(*) = 1 FROM x WHERE x = (SELECT x FROM x WHERE x = 'dep_p1') AND x = (SELECT x FROM x WHERE x = 'dep2');
ALTER POLICY dep_p1 ON dep1 USING (true);
/* Should return one */ SELECT COUNT(*) = 1 FROM x WHERE x = (SELECT x FROM x WHERE x = 'dep_p1') AND x = (SELECT x FROM x WHERE x = 'regress_rls_bob');
/* Should return one */ SELECT COUNT(*) = 1 FROM x WHERE x = (SELECT x FROM x WHERE x = 'dep_p1') AND x = (SELECT x FROM x WHERE x = 'regress_rls_carol');
/* Should return zero */ SELECT COUNT(*) = 0 FROM x WHERE x = (SELECT x FROM x WHERE x = 'dep_p1') AND x = (SELECT x FROM x WHERE x = 'dep2');
/* DROP OWNED BY testing */ RESET SESSION AUTHORIZATION;
CREATE ROLE regress_rls_dob_role1;
CREATE ROLE regress_rls_dob_role2;
CREATE TABLE x (x INT);
CREATE TABLE x (x INT) WITH (PARTITIONED_BY=RANGE(x));
CREATE POLICY p1 ON dob_t1 TO regress_rls_dob_role1 USING (true);
DROP OWNED BY regress_rls_dob_role1;
DROP POLICY p1 ON dob_t1;
/* should fail, already gone */ CREATE POLICY p1 ON dob_t1 TO regress_rls_dob_role1,regress_rls_dob_role2 USING (true);
DROP OWNED BY regress_rls_dob_role1;
DROP POLICY p1 ON dob_t1;
/* should succeed */ /* same cases with duplicate polroles entries */ CREATE POLICY p1 ON dob_t1 TO regress_rls_dob_role1,regress_rls_dob_role1 USING (true);
DROP OWNED BY regress_rls_dob_role1;
DROP POLICY p1 ON dob_t1;
/* should fail, already gone */ CREATE POLICY p1 ON dob_t1 TO regress_rls_dob_role1,regress_rls_dob_role1,regress_rls_dob_role2 USING (true);
DROP OWNED BY regress_rls_dob_role1;
DROP POLICY p1 ON dob_t1;
/* should succeed */ /* partitioned target */ CREATE POLICY p1 ON dob_t2 TO regress_rls_dob_role1,regress_rls_dob_role2 USING (true);
DROP OWNED BY regress_rls_dob_role1;
DROP POLICY p1 ON dob_t2;
/* should succeed */ DROP USER regress_rls_dob_role1;
DROP USER regress_rls_dob_role2;
/* Bug #15708: view + table with RLS should check policies as view owner */ CREATE TABLE x (x INT);
INSERT INTO x VALUES (1);
CREATE TABLE x (x INT);
INSERT INTO x VALUES (10);
ALTER TABLE rls_tbl ENABLE ROW LEVEL SECURITY;
CREATE POLICY p1 ON rls_tbl USING (EXISTS (SELECT 1 FROM ref_tbl));
GRANT SELECT ON x TO x;
GRANT SELECT ON x TO x;
CREATE VIEW x AS SELECT * FROM x;
ALTER VIEW rls_view OWNER TO regress_rls_bob;
GRANT SELECT ON x TO x;
SET SESSION AUTHORIZATION regress_rls_alice;
SELECT * FROM x;
/* Permission denied */ SELECT * FROM x;
/* Permission denied */ SELECT * FROM x;
/* OK */ RESET SESSION AUTHORIZATION;
DROP VIEW x;
DROP TABLE x;
DROP TABLE x;
/* Leaky operator test */ CREATE TABLE x (x INT);
INSERT INTO x SELECT x / 10 FROM x AS x;
ANALYZE x;
ALTER TABLE rls_tbl ENABLE ROW LEVEL SECURITY;
GRANT SELECT ON x TO x;
SET SESSION AUTHORIZATION regress_rls_alice;
CREATE OPERATOR <<< (procedure = op_leak, leftarg = int, rightarg = int,                      restrict = scalarltsel);
EXPLAIN (COSTS OFF) SELECT * FROM rls_tbl WHERE a <<< 1000 or a <<< 900;
DROP OPERATOR <<< (int, int);
DROP FUNCTION x (INT, INT);
RESET SESSION AUTHORIZATION;
DROP TABLE x;
/* Bug #16006: whole-row Vars in a policy don't play nice with sub-selects */ SET SESSION AUTHORIZATION regress_rls_alice;
CREATE TABLE x (x INT, x INT, x INT);
CREATE POLICY p1 ON rls_tbl USING (rls_tbl >= ROW(1,1,1));
ALTER TABLE rls_tbl ENABLE ROW LEVEL SECURITY;
ALTER TABLE rls_tbl FORCE ROW LEVEL SECURITY;
INSERT INTO x SELECT 10, 20, 30;
EXPLAIN (VERBOSE, COSTS OFF) INSERT INTO rls_tbl   SELECT * FROM (SELECT b, c FROM rls_tbl ORDER BY a) ss;
INSERT INTO x SELECT * FROM (SELECT x, x FROM x ORDER BY x NULLS LAST) AS x;
SELECT * FROM x;
DROP TABLE x;
RESET SESSION AUTHORIZATION;
/* CVE-2023-2455: inlining an SRF may introduce an RLS dependency */ CREATE TABLE x (x TEXT);
INSERT INTO x VALUES ('invisible to bob');
alter table rls_t enable row level security;
GRANT SELECT ON x TO x, x;
create policy p1 on rls_t for select to regress_rls_alice using (true);
create policy p2 on rls_t for select to regress_rls_bob using (false);
create function rls_f () returns setof rls_t   stable language sql   as $$ select * from rls_t $$;
PREPARE q as select current_user, * from rls_f();
set role regress_rls_alice;
EXECUTE q;
set role regress_rls_bob;
EXECUTE q;
/* make sure RLS dependencies in CTEs are handled */ RESET role;
create or replace function rls_f() returns setof rls_t   stable language sql   as $$ with cte as (select * from rls_t) select * from cte $$;
PREPARE r as select current_user, * from rls_f();
set role regress_rls_alice;
EXECUTE r;
set role regress_rls_bob;
EXECUTE r;
/* make sure RLS dependencies in subqueries are handled */ RESET role;
create or replace function rls_f() returns setof rls_t   stable language sql   as $$ select * from (select * from rls_t) _ $$;
PREPARE s as select current_user, * from rls_f();
set role regress_rls_alice;
EXECUTE s;
set role regress_rls_bob;
EXECUTE s;
/* make sure RLS dependencies in sublinks are handled */ RESET role;
create or replace function rls_f() returns setof rls_t   stable language sql   as $$ select exists(select * from rls_t)::text $$;
PREPARE t as select current_user, * from rls_f();
set role regress_rls_alice;
EXECUTE t;
set role regress_rls_bob;
EXECUTE t;
/* make sure RLS dependencies are handled when coercion projections are inserted */ RESET role;
create or replace function rls_f() returns setof rls_t   stable language sql   as $$ select * from (select array_agg(c) as cs from rls_t) _ group by cs $$;
PREPARE u as select current_user, * from rls_f();
set role regress_rls_alice;
EXECUTE u;
set role regress_rls_bob;
EXECUTE u;
/* make sure RLS dependencies in security invoker views are handled */ RESET role;
GRANT SELECT ON x TO x, x;
create or replace function rls_f() returns setof rls_t   stable language sql   as $$ select * from rls_v $$;
PREPARE v as select current_user, * from rls_f();
set role regress_rls_alice;
EXECUTE v;
set role regress_rls_bob;
EXECUTE v;
RESET ROLE;
DROP FUNCTION x;
DROP VIEW x;
DROP TABLE x;
/* Clean up objects */ RESET SESSION AUTHORIZATION;
DROP SCHEMA x.x CASCADE;
DROP USER regress_rls_alice;
DROP USER regress_rls_bob;
DROP USER regress_rls_carol;
DROP USER regress_rls_dave;
DROP USER regress_rls_exempt_user;
DROP ROLE regress_rls_group1;
DROP ROLE regress_rls_group2;
/* Arrange to have a few policies left over, for testing */ /* pg_dump/pg_restore */ CREATE SCHEMA x.x;
CREATE TABLE x (x INT);
ALTER TABLE rls_tbl ENABLE ROW LEVEL SECURITY;
CREATE POLICY p1 ON rls_tbl USING (c1 > 5);
CREATE POLICY p2 ON rls_tbl FOR SELECT USING (c1 <= 3);
CREATE POLICY p3 ON rls_tbl FOR UPDATE USING (c1 <= 3) WITH CHECK (c1 > 5);
CREATE POLICY p4 ON rls_tbl FOR DELETE USING (c1 <= 3);
CREATE TABLE x (x INT);
ALTER TABLE rls_tbl_force ENABLE ROW LEVEL SECURITY;
ALTER TABLE rls_tbl_force FORCE ROW LEVEL SECURITY;
CREATE POLICY p1 ON rls_tbl_force USING (c1 = 5) WITH CHECK (c1 < 5);
CREATE POLICY p2 ON rls_tbl_force FOR SELECT USING (c1 = 8);
CREATE POLICY p3 ON rls_tbl_force FOR UPDATE USING (c1 = 8) WITH CHECK (c1 >= 5);
CREATE POLICY p4 ON rls_tbl_force FOR DELETE USING (c1 = 8);
/* ROWTYPES */ /* Make both a standalone composite type and a table rowtype */ create type complex as (r float8, i float8);
CREATE TEMPORARY TABLE x (x TEXT, x TEXT);
/* Nested composite */ create type quad as (c1 complex, c2 complex);
/* Some simple tests of I/O conversions and row construction */ SELECT CAST((1.1, 2.2) AS complex), CAST(ROW((3.3, 4.4), (5.5, NULL)) AS quad);
SELECT CAST(ROW('Joe', 'Blow') AS fullname), CAST('(Joe,Blow)' AS fullname);
SELECT CAST('(Joe,von Blow)' AS fullname), CAST('(Joe,d''Blow)' AS fullname);
SELECT CAST('(Joe,"von""Blow")' AS fullname), CAST((Joe,d\\\\Blow) AS fullname);
SELECT CAST('(Joe,"Blow,Jr")' AS fullname);
SELECT CAST('(Joe,)' AS fullname);
/* ok, null 2nd column */ SELECT CAST('(Joe)' AS fullname);
/* bad */ SELECT CAST('(Joe,,)' AS fullname);
/* bad */ SELECT CAST('[]' AS fullname);
/* bad */ SELECT CAST(' (Joe,Blow)  ' AS fullname);
/* ok, extra whitespace */ SELECT CAST('(Joe,Blow) /' AS fullname);
/* bad */ /* test non-error-throwing API */ SELECT PG_INPUT_IS_VALID('(1,2)', 'complex');
SELECT PG_INPUT_IS_VALID('(1,2', 'complex');
SELECT PG_INPUT_IS_VALID('(1,zed)', 'complex');
SELECT * FROM x;
SELECT * FROM x;
CREATE TEMPORARY TABLE x (x INT, x quad);
INSERT INTO x VALUES (1, ((3.3, 4.4), (5.5, 6.6)));
INSERT INTO x VALUES (2, ((NULL, 4.4), (5.5, 6.6)));
SELECT * FROM x;
SELECT x, x.x FROM x;
/* fails, q is a table reference */ SELECT x, (x).x, (x.x).x.x FROM x AS x;
CREATE TEMPORARY TABLE x (x fullname, x DATE);
INSERT INTO x VALUES ('(Joe,Blow)', '1984-01-10');
SELECT * FROM x;
ALTER TABLE x ADD COLUMN x TEXT DEFAULT '' /* at the moment this will not work due to ALTER TABLE inadequacy: */;
ALTER TABLE x ADD COLUMN x TEXT DEFAULT NULL /* but this should work: */;
SELECT * FROM x;
/* test insertion/updating of subfields */ UPDATE x SET x.x = 'Jr';
SELECT * FROM x;
UPDATE x SET x.x.x = 12 WHERE x = 2;
UPDATE x SET x.x = 12;
/* error, type mismatch */ SELECT * FROM x;
/* The object here is to ensure that toasted references inside */ /* composite values don't cause problems.  The large f1 value will */ /* be toasted inside pp, it must still work after being copied to people. */ CREATE TEMPORARY TABLE x (x TEXT);
INSERT INTO x VALUES (REPEAT('abcdefghijkl', 100000));
INSERT INTO x SELECT CAST(('Jim', x, NULL) AS fullname), CURRENT_DATE FROM x;
SELECT (x).x, SUBSTRING((x).x, 1, 20), LENGTH((x).x) FROM x;
/* try an update on a toasted composite value, too */ UPDATE x SET x.x = 'Jack';
SELECT (x).x, SUBSTRING((x).x, 1, 20), LENGTH((x).x) FROM x;
/* Test row comparison semantics.  Prior to PG 8.2 we did this in a totally */ /* non-spec-compliant way. */ SELECT ROW(1, 2) < ROW(1, 3) AS x;
SELECT ROW(1, 2) < ROW(1, 1) AS x;
SELECT ROW(1, 2) < ROW(1, NULL) AS x;
SELECT ROW(1, 2, 3) < ROW(1, 3, NULL) AS x;
/* the NULL is not examined */ SELECT ROW(11, 'ABC') < ROW(11, 'DEF') AS x;
SELECT ROW(11, 'ABC') > ROW(11, 'DEF') AS x;
SELECT ROW(12, 'ABC') > ROW(11, 'DEF') AS x;
/* = and <> have different NULL-behavior than < etc */ SELECT ROW(1, 2, 3) < ROW(1, NULL, 4) AS x;
SELECT ROW(1, 2, 3) = ROW(1, NULL, 4) AS x;
SELECT ROW(1, 2, 3) <> ROW(1, NULL, 4) AS x;
SELECT ROW('ABC', 'DEF') LIKE ROW('DEF', 'ABC') AS x;
/* Comparisons of ROW() expressions can cope with some type mismatches */ SELECT ROW(1, 2) = ROW(1, CAST(2 AS BIGINT));
SELECT ROW(1, 2) IN (ROW(3, 4), ROW(1, 2));
SELECT ROW(1, 2) IN (ROW(3, 4), ROW(1, CAST(2 AS BIGINT)));
/* Check row comparison with a subselect */ SELECT x, x FROM x WHERE (x, x) < ANY (SELECT x, x FROM x WHERE x < 3) AND x <= 20 ORDER BY 1 NULLS LAST;
/* Also check row comparison with an indexable condition */ EXPLAIN (costs off) select thousand, tenthous from tenk1 where (thousand, tenthous) >= (997, 5000) order by thousand, tenthous;
SELECT x, x FROM x WHERE (x, x) >= (997, 5000) ORDER BY x NULLS LAST, x NULLS LAST;
EXPLAIN (costs off) select thousand, tenthous, four from tenk1 where (thousand, tenthous, four) > (998, 5000, 3) order by thousand, tenthous;
SELECT x, x, x FROM x WHERE (x, x, x) > (998, 5000, 3) ORDER BY x NULLS LAST, x NULLS LAST;
EXPLAIN (costs off) select thousand, tenthous from tenk1 where (998, 5000) < (thousand, tenthous) order by thousand, tenthous;
SELECT x, x FROM x WHERE (998, 5000) < (x, x) ORDER BY x NULLS LAST, x NULLS LAST;
EXPLAIN (costs off) select thousand, hundred from tenk1 where (998, 5000) < (thousand, hundred) order by thousand, hundred;
SELECT x, x FROM x WHERE (998, 5000) < (x, x) ORDER BY x NULLS LAST, x NULLS LAST;
/* Test case for bug #14010: indexed row comparisons fail with nulls */ CREATE TEMPORARY TABLE x (x TEXT, x TEXT);
INSERT INTO x VALUES ('a', 'b');
INSERT INTO x SELECT 'a', NULL FROM x;
INSERT INTO x VALUES ('b', 'a');
CREATE INDEX ON x(x NULLS LAST, x NULLS LAST);
SET x = off;
EXPLAIN (costs off) select a,b from test_table where (a,b) > ('a','a') order by a,b;
SELECT x, x FROM x WHERE (x, x) > ('a', 'a') ORDER BY x NULLS LAST, x NULLS LAST;
RESET enable_sort;
/* Check row comparisons with IN */ SELECT * FROM x AS x WHERE x IN (ROW(123, 456));
/* fail, type mismatch */ EXPLAIN (costs off) select * from int8_tbl i8 where i8 in (row(123,456)::int8_tbl, '(4567890123456789,123)');
SELECT * FROM x AS x WHERE x IN (CAST(ROW(123, 456) AS int8_tbl), '(4567890123456789,123)');
/* Check ability to select columns from an anonymous rowtype */ SELECT (ROW(1, 2.0)).x;
SELECT (ROW(1, 2.0)).x;
SELECT (ROW(1, 2.0)).x;
/* fail */ SELECT (ROW(1, 2.0)).*;
SELECT (x).x FROM (SELECT ROW(1, 2.0) AS x) AS x;
SELECT (x).x FROM (SELECT ROW(1, 2.0) AS x) AS x;
/* fail */ SELECT (x).* FROM (SELECT ROW(1, 2.0) AS x) AS x;
/* Check some corner cases involving empty rowtypes */ SELECT ROW();
SELECT ROW() IS NULL;
SELECT ROW() = ROW();
/* Check ability to create arrays of anonymous rowtypes */ SELECT ARRAY(ROW(1, 2), ROW(3, 4), ROW(5, 6));
/* Check ability to compare an anonymous row to elements of an array */ SELECT ROW(1, 1.1) = ANY(ARRAY(ROW(7, 7.7), ROW(1, 1.1), ROW(0, 0.0)));
SELECT ROW(1, 1.1) = ANY(ARRAY(ROW(7, 7.7), ROW(1, 1.0), ROW(0, 0.0)));
/* Check behavior with a non-comparable rowtype */ create type cantcompare as (p point, r float8);
CREATE TEMPORARY TABLE x (x cantcompare);
INSERT INTO x VALUES ('("(1,2)",3)');
INSERT INTO x VALUES ('("(4,5)",6)');
SELECT * FROM x ORDER BY x NULLS LAST;
/* fail, but should complain about cantcompare */ /* Tests for record_{eq,cmp} */ create type testtype1 as (a int, b int);
/* all true */ SELECT CAST(ROW(1, 2) AS testtype1) < CAST(ROW(1, 3) AS testtype1);
SELECT CAST(ROW(1, 2) AS testtype1) <= CAST(ROW(1, 3) AS testtype1);
SELECT CAST(ROW(1, 2) AS testtype1) = CAST(ROW(1, 2) AS testtype1);
SELECT CAST(ROW(1, 2) AS testtype1) <> CAST(ROW(1, 3) AS testtype1);
SELECT CAST(ROW(1, 3) AS testtype1) >= CAST(ROW(1, 2) AS testtype1);
SELECT CAST(ROW(1, 3) AS testtype1) > CAST(ROW(1, 2) AS testtype1);
/* all false */ SELECT CAST(ROW(1, -2) AS testtype1) < CAST(ROW(1, -3) AS testtype1);
SELECT CAST(ROW(1, -2) AS testtype1) <= CAST(ROW(1, -3) AS testtype1);
SELECT CAST(ROW(1, -2) AS testtype1) = CAST(ROW(1, -3) AS testtype1);
SELECT CAST(ROW(1, -2) AS testtype1) <> CAST(ROW(1, -2) AS testtype1);
SELECT CAST(ROW(1, -3) AS testtype1) >= CAST(ROW(1, -2) AS testtype1);
SELECT CAST(ROW(1, -3) AS testtype1) > CAST(ROW(1, -2) AS testtype1);
/* true, but see *< below */ SELECT CAST(ROW(1, -2) AS testtype1) < CAST(ROW(1, 3) AS testtype1);
/* mismatches */ create type testtype3 as (a int, b text);
SELECT CAST(ROW(1, 2) AS testtype1) < CAST(ROW(1, 'abc') AS testtype3);
SELECT CAST(ROW(1, 2) AS testtype1) <> CAST(ROW(1, 'abc') AS testtype3);
create type testtype5 as (a int);
SELECT CAST(ROW(1, 2) AS testtype1) < CAST(ROW(1) AS testtype5);
SELECT CAST(ROW(1, 2) AS testtype1) <> CAST(ROW(1) AS testtype5);
/* non-comparable types */ create type testtype6 as (a int, b point);
SELECT CAST(ROW(1, '(1,2)') AS testtype6) < CAST(ROW(1, '(1,3)') AS testtype6);
SELECT CAST(ROW(1, '(1,2)') AS testtype6) <> CAST(ROW(1, '(1,3)') AS testtype6);
drop type testtype1, testtype3, testtype5, testtype6;
/* Tests for record_image_{eq,cmp} */ create type testtype1 as (a int, b int);
/* other types */ create type testtype2 as (a smallint, b bool);
create type testtype3 as (a int, b text);
create type testtype4 as (a int, b point);
create type testtype5 as (a int);
/* non-comparable types */ create type testtype6 as (a int, b point);
/* anonymous rowtypes in coldeflists */ SELECT x.x, x.x = ROW(2), x.x = ARRAY(ROW(3)), x.x = ROW(ROW(4)) FROM UNNEST(ARRAY(ROW(1, ROW(2), ARRAY(ROW(3)), ROW(ROW(4))), ROW(2, ROW(3), ARRAY(ROW(4)), ROW(ROW(5))))) AS x;
drop type testtype1, testtype2, testtype3, testtype4, testtype5, testtype6;
/* Test case derived from bug #5716: check multiple uses of a rowtype result */ BEGIN;
CREATE TABLE x (x SERIAL PRIMARY KEY, x BOOLEAN NOT NULL, x DECIMAL);
CREATE TYPE price_input AS (     id INTEGER,     price NUMERIC );
CREATE TYPE price_key AS (     id INTEGER );
CREATE FUNCTION x(x) RETURNS price_key LANGUAGE SQL AS $$     SELECT $1.id $$;
CREATE FUNCTION x(x) RETURNS price_key LANGUAGE SQL AS $$     SELECT $1.id $$;
INSERT INTO x VALUES (1, FALSE, 42), (10, FALSE, 100), (11, TRUE, 17.99);
UPDATE x SET x = TRUE, x = x.x FROM UNNEST(CAST(ARRAY((10, 123.00), (11, 99.99)) AS ARRAY<price_input>)) AS x WHERE PRICE_KEY_FROM_TABLE(x.*) = PRICE_KEY_FROM_INPUT(x.*);
SELECT * FROM x;
ROLLBACK;
/* Test case derived from bug #9085: check * qualification of composite */ /* parameters for SQL functions */ CREATE TEMPORARY TABLE x (x INT, x TEXT);
SELECT FCOMPOS1(ROW(1, 'one'));
SELECT FCOMPOS2(ROW(2, 'two'));
SELECT FCOMPOS3(ROW(3, 'three'));
SELECT * FROM x;
/* We allow I/O conversion casts from composite types to strings to be */ /* invoked via cast syntax, but not functional syntax.  This is because */ /* the latter is too prone to be invoked unintentionally. */ SELECT CAST(x AS TEXT) FROM x;
SELECT CAST(x AS TEXT) FROM x;
SELECT TEXT(x) FROM x;
/* error */ SELECT x.x FROM x;
/* error */ /* same, but RECORD instead of named composite type: */ SELECT CAST(ROW('Jim', 'Beam') AS TEXT);
SELECT CAST((ROW('Jim', 'Beam')) AS TEXT);
SELECT TEXT(ROW('Jim', 'Beam'));
/* error */ SELECT (ROW('Jim', 'Beam')).x;
/* error */ /* Check the equivalence of functional and column notation */ INSERT INTO x VALUES ('Joe', 'Blow');
SELECT x.x FROM x AS x;
SELECT LAST(x) FROM x AS x;
CREATE FUNCTION x(x) RETURNS TEXT LANGUAGE sql AS $$select $1.first || ' ' || $1.last$$;
SELECT x.x FROM x AS x;
SELECT LONGNAME(x) FROM x AS x;
ALTER TABLE x ADD COLUMN x TEXT /* Starting in v11, the notational form does matter if there's ambiguity */;
SELECT x.x FROM x AS x;
SELECT LONGNAME(x) FROM x AS x;
/* Test that composite values are seen to have the correct column names */ /* (bug #11210 and other reports) */ SELECT ROW_TO_JSON(x) FROM x AS x;
/* since "i" is of type "int8_tbl", attaching aliases doesn't change anything: */ SELECT ROW_TO_JSON(x) FROM x AS x;
/* in these examples, we'll report the exposed column names of the subselect: */ SELECT ROW_TO_JSON(x) FROM (SELECT x, x FROM x) AS x;
SELECT ROW_TO_JSON(x) FROM (SELECT x, x FROM x OFFSET 0) AS x;
SELECT ROW_TO_JSON(x) FROM (SELECT x AS x, x AS x FROM x) AS x;
SELECT ROW_TO_JSON(x) FROM (SELECT x AS x, x AS x FROM x OFFSET 0) AS x;
SELECT ROW_TO_JSON(x) FROM (SELECT x AS x, x AS x FROM x) AS x;
SELECT ROW_TO_JSON(x) FROM (SELECT x AS x, x AS x FROM x OFFSET 0) AS x;
EXPLAIN (costs off) select row_to_json(q) from   (select thousand, tenthous from tenk1    where thousand = 42 and tenthous < 2000 offset 0) q;
SELECT ROW_TO_JSON(x) FROM (SELECT x, x FROM x WHERE x = 42 AND x < 2000 OFFSET 0) AS x;
SELECT ROW_TO_JSON(x) FROM (SELECT x AS x, x AS x FROM x WHERE x = 42 AND x < 2000 OFFSET 0) AS x;
SELECT ROW_TO_JSON(x) FROM (SELECT x AS x, x AS x FROM x WHERE x = 42 AND x < 2000 OFFSET 0) AS x;
CREATE TEMPORARY TABLE x AS SELECT * FROM x LIMIT 2;
CREATE TEMPORARY TABLE x INHERITS (x);
INSERT INTO x VALUES (0, 0);
SELECT ROW_TO_JSON(x) FROM (SELECT x, x FROM x OFFSET 0) AS x;
/* check no-op rowtype conversions */ CREATE TEMPORARY TABLE x INHERITS (x);
INSERT INTO x VALUES (33, 44);
SELECT ROW_TO_JSON(CAST(CAST(x AS tt2) AS tt1)) FROM x;
/* IS [NOT] NULL should not recurse into nested composites (bug #14235) */ EXPLAIN (verbose, costs off) select r, r is null as isnull, r is not null as isnotnull from (values (1,row(1,2)), (1,row(null,null)), (1,null),              (null,row(1,2)), (null,row(null,null)), (null,null) ) r(a,b);
SELECT x, x IS NULL AS x, NOT x IS NULL AS x FROM (VALUES (1, ROW(1, 2)), (1, ROW(NULL, NULL)), (1, NULL), (NULL, ROW(1, 2)), (NULL, ROW(NULL, NULL)), (NULL, NULL)) AS x;
EXPLAIN (verbose, costs off) with r(a,b) as materialized   (values (1,row(1,2)), (1,row(null,null)), (1,null),           (null,row(1,2)), (null,row(null,null)), (null,null) ) select r, r is null as isnull, r is not null as isnotnull from r;
WITH x AS MATERIALIZED (SELECT * FROM (VALUES (1, ROW(1, 2)), (1, ROW(NULL, NULL)), (1, NULL), (NULL, ROW(1, 2)), (NULL, ROW(NULL, NULL)), (NULL, NULL)) AS x) SELECT x, x IS NULL AS x, NOT x IS NULL AS x FROM x;
/* Check parsing of indirect references to composite values (bug #18077) */ EXPLAIN (verbose, costs off) with cte(c) as materialized (select row(1, 2)),      cte2(c) as (select * from cte) select * from cte2 as t where (select * from (select c as c1) s        where (select (c1).f1 > 0)) is not null;
WITH x AS MATERIALIZED (SELECT ROW(1, 2)), x AS (SELECT * FROM x) SELECT * FROM x AS x WHERE NOT (SELECT * FROM (SELECT x AS x) AS x WHERE (SELECT (x).x > 0)) IS NULL;
/* Also check deparsing of such cases */ CREATE VIEW x AS WITH x AS MATERIALIZED (SELECT ROW(1, 2)), x AS (SELECT * FROM x) SELECT 1 AS x FROM x AS x WHERE NOT (SELECT * FROM (SELECT x AS x) AS x WHERE (SELECT (x).x > 0)) IS NULL;
SELECT PG_GET_VIEWDEF('composite_v', TRUE);
DROP VIEW x;
/* Check cases where the composite comes from a proven-dummy rel (bug #18576) */ EXPLAIN (verbose, costs off) select (ss.a).x, (ss.a).n from   (select information_schema._pg_expandarray(array[1,2]) AS a) ss;
EXPLAIN (verbose, costs off) select (ss.a).x, (ss.a).n from   (select information_schema._pg_expandarray(array[1,2]) AS a) ss where false;
EXPLAIN (verbose, costs off) with cte(c) as materialized (select row(1, 2)),      cte2(c) as (select * from cte) select (c).f1 from cte2 as t;
EXPLAIN (verbose, costs off) with cte(c) as materialized (select row(1, 2)),      cte2(c) as (select * from cte) select (c).f1 from cte2 as t where false;
/* Tests for component access / FieldSelect */ CREATE TABLE x (x TEXT, x TEXT);
INSERT INTO x (x, x) VALUES ('fa', 'fb');
/* composite type columns can't directly be accessed (error) */ SELECT x.x FROM (SELECT x AS x FROM x) AS x;
/* but can be accessed with proper parens */ SELECT (x).x, (x).x FROM (SELECT x AS x FROM x) AS x;
/* system columns can't be accessed in composite types (error) */ SELECT (x).x FROM (SELECT x AS x FROM x) AS x;
/* accessing non-existing column in NULL datum errors out */ SELECT (CAST(NULL AS compositetable)).x;
/* existing column in a NULL composite yield NULL */ SELECT (CAST(NULL AS compositetable)).x;
/* oids can't be accessed in composite types (error) */ SELECT (CAST(NULL AS compositetable)).x;
DROP TABLE x;
/* RULES */ /* From Jan's original setup_ruletest.sql and run_ruletest.sql */ /* - thomas 1998-09-13 */ /* Tables and rules for the view test */ CREATE TABLE x (x INT, x INT);
CREATE TABLE x (x INT, x INT);
CREATE TABLE x (x INT, x INT);
CREATE VIEW x AS SELECT * FROM x;
create rule rtest_v1_ins as on insert to rtest_v1 do instead 	insert into rtest_t1 values (new.a, new.b);
create rule rtest_v1_upd as on update to rtest_v1 do instead 	update rtest_t1 set a = new.a, b = new.b 	where a = old.a;
create rule rtest_v1_del as on delete to rtest_v1 do instead 	delete from rtest_t1 where a = old.a;
/* Test comments */ COMMENT ON RULE rtest_v1_bad ON rtest_v1 IS 'bad rule';
COMMENT ON RULE rtest_v1_del ON rtest_v1 IS 'delete rule';
COMMENT ON RULE rtest_v1_del ON rtest_v1 IS NULL;
/* Tables and rules for the constraint update/delete test */ /* Note: */ /* 	Now that we have multiple action rule support, we check */ /* 	both possible syntaxes to define them (The last action */ /*  can but must not have a semicolon at the end). */ CREATE TABLE x (x TEXT, x TEXT);
CREATE TABLE x (x TEXT, x TEXT);
CREATE TABLE x (x TEXT, x TEXT);
CREATE TABLE x (x TEXT, x TEXT);
create rule rtest_sys_upd as on update to rtest_system do also ( 	update rtest_interface set sysname = new.sysname 		where sysname = old.sysname;
create rule rtest_sys_del as on delete to rtest_system do also ( 	delete from rtest_interface where sysname = old.sysname;
DELETE FROM x WHERE x = x.x;
create rule rtest_pers_upd as on update to rtest_person do also 	update rtest_admin set pname = new.pname where pname = old.pname;
create rule rtest_pers_del as on delete to rtest_person do also 	delete from rtest_admin where pname = old.pname;
/* Tables and rules for the logging test */ CREATE TABLE x (x CHAR(20), x DECIMAL);
CREATE TABLE x (x CHAR(20), x NAME, x CHAR(10), x DECIMAL, x DECIMAL);
CREATE TABLE x (x CHAR(20), x DECIMAL);
create rule rtest_emp_ins as on insert to rtest_emp do 	insert into rtest_emplog values (new.ename, current_user, 			'hired', new.salary, '0.00');
create rule rtest_emp_upd as on update to rtest_emp where new.salary != old.salary do 	insert into rtest_emplog values (new.ename, current_user, 			'honored', new.salary, old.salary);
create rule rtest_emp_del as on delete to rtest_emp do 	insert into rtest_emplog values (old.ename, current_user, 			'fired', '0.00', old.salary);
/* Tables and rules for the multiple cascaded qualified instead */ /* rule test */ CREATE TABLE x (x INT, x TEXT);
CREATE TABLE x (x INT, x TEXT);
CREATE TABLE x (x INT, x TEXT);
CREATE TABLE x (x INT, x TEXT);
CREATE TABLE x (x INT, x TEXT);
CREATE TABLE x (x INT, x TEXT);
create rule rtest_t4_ins1 as on insert to rtest_t4 		where new.a >= 10 and new.a < 20 do instead 	insert into rtest_t5 values (new.a, new.b);
create rule rtest_t4_ins2 as on insert to rtest_t4 		where new.a >= 20 and new.a < 30 do 	insert into rtest_t6 values (new.a, new.b);
create rule rtest_t5_ins as on insert to rtest_t5 		where new.a > 15 do 	insert into rtest_t7 values (new.a, new.b);
create rule rtest_t6_ins as on insert to rtest_t6 		where new.a > 25 do instead 	insert into rtest_t8 values (new.a, new.b);
/* Tables and rules for the rule fire order test */ /* As of PG 7.3, the rules should fire in order by name, regardless */ /* of INSTEAD attributes or creation order. */ CREATE TABLE x (x INT);
CREATE TABLE x (x INT, x INT, x TEXT);
CREATE SEQUENCE x;
create rule rtest_order_r3 as on insert to rtest_order1 do instead 	insert into rtest_order2 values (new.a, nextval('rtest_seq'), 		'rule 3 - this should run 3rd');
create rule rtest_order_r4 as on insert to rtest_order1 		where a < 100 do instead 	insert into rtest_order2 values (new.a, nextval('rtest_seq'), 		'rule 4 - this should run 4th');
create rule rtest_order_r2 as on insert to rtest_order1 do 	insert into rtest_order2 values (new.a, nextval('rtest_seq'), 		'rule 2 - this should run 2nd');
create rule rtest_order_r1 as on insert to rtest_order1 do instead 	insert into rtest_order2 values (new.a, nextval('rtest_seq'), 		'rule 1 - this should run 1st');
/* Tables and rules for the instead nothing test */ CREATE TABLE x (x INT, x TEXT);
CREATE TABLE x (x INT, x TEXT);
CREATE TABLE x (x INT, x TEXT);
CREATE TABLE x (x INT, x TEXT);
create rule rtest_nothn_r1 as on insert to rtest_nothn1 	where new.a >= 10 and new.a < 20 do instead nothing;
create rule rtest_nothn_r2 as on insert to rtest_nothn1 	where new.a >= 30 and new.a < 40 do instead nothing;
create rule rtest_nothn_r3 as on insert to rtest_nothn2 	where new.a >= 100 do instead 	insert into rtest_nothn3 values (new.a, new.b);
create rule rtest_nothn_r4 as on insert to rtest_nothn2 	do instead nothing;
/* Tests on a view that is select * of a table */ /* and has insert/update/delete instead rules to */ /* behave close like the real table. */ /* We need test date later */ INSERT INTO x VALUES (1, 21);
INSERT INTO x VALUES (2, 22);
INSERT INTO x VALUES (3, 23);
INSERT INTO x VALUES (1, 31);
INSERT INTO x VALUES (2, 32);
INSERT INTO x VALUES (3, 33);
INSERT INTO x VALUES (4, 34);
INSERT INTO x VALUES (5, 35);
/* insert values */ INSERT INTO x VALUES (1, 11);
INSERT INTO x VALUES (2, 12);
SELECT * FROM x;
/* delete with constant expression */ DELETE FROM x WHERE x = 1;
SELECT * FROM x;
INSERT INTO x VALUES (1, 11);
DELETE FROM x WHERE x = 12;
SELECT * FROM x;
INSERT INTO x VALUES (2, 12);
INSERT INTO x VALUES (2, 13);
SELECT * FROM x;
SELECT * FROM x;
DELETE FROM x;
/* insert select */ INSERT INTO x SELECT * FROM x;
SELECT * FROM x;
DELETE FROM x;
/* same with swapped targetlist */ INSERT INTO x (x, x) SELECT x, x FROM x;
SELECT * FROM x;
/* now with only one target attribute */ INSERT INTO x (x) SELECT x FROM x;
SELECT * FROM x;
SELECT * FROM x WHERE x IS NULL;
/* let attribute a differ (must be done on rtest_t1 - see above) */ UPDATE x SET x = x + 10 WHERE x IS NULL;
DELETE FROM x WHERE x IS NULL;
SELECT * FROM x;
/* now updates with constant expression */ UPDATE x SET x = 42 WHERE x = 2;
SELECT * FROM x;
UPDATE x SET x = 99 WHERE x = 42;
SELECT * FROM x;
UPDATE x SET x = 88 WHERE x < 50;
SELECT * FROM x;
DELETE FROM x;
INSERT INTO x SELECT x.x, x.x FROM x, x WHERE x.x = x.x;
SELECT * FROM x;
/* updates in a mergejoin */ UPDATE x SET x = x.x FROM x WHERE x.x = x.x;
SELECT * FROM x;
INSERT INTO x SELECT * FROM x;
SELECT * FROM x;
UPDATE x SET x = x + 10 WHERE x > 30;
SELECT * FROM x;
UPDATE x SET x = x.x + 20 FROM x WHERE x.x = x.x;
SELECT * FROM x;
/* Test for constraint updates/deletes */ INSERT INTO x VALUES ('orion', 'Linux Jan Wieck');
INSERT INTO x VALUES ('notjw', 'WinNT Jan Wieck (notebook)');
INSERT INTO x VALUES ('neptun', 'Fileserver');
INSERT INTO x VALUES ('orion', 'eth0');
INSERT INTO x VALUES ('orion', 'eth1');
INSERT INTO x VALUES ('notjw', 'eth0');
INSERT INTO x VALUES ('neptun', 'eth0');
INSERT INTO x VALUES ('jw', 'Jan Wieck');
INSERT INTO x VALUES ('bm', 'Bruce Momjian');
INSERT INTO x VALUES ('jw', 'orion');
INSERT INTO x VALUES ('jw', 'notjw');
INSERT INTO x VALUES ('bm', 'neptun');
UPDATE x SET x = 'pluto' WHERE x = 'neptun';
SELECT * FROM x;
SELECT * FROM x;
UPDATE x SET x = 'jwieck' WHERE x = 'Jan Wieck';
/* Note: use ORDER BY here to ensure consistent output across all systems. */ /* The above UPDATE affects two rows with equal keys, so they could be */ /* updated in either order depending on the whim of the local qsort(). */ SELECT * FROM x ORDER BY x NULLS LAST, x NULLS LAST;
DELETE FROM x WHERE x = 'orion';
SELECT * FROM x;
SELECT * FROM x;
/* Rule qualification test */ INSERT INTO x VALUES ('wiecc', '5000.00');
INSERT INTO x VALUES ('gates', '80000.00');
UPDATE x SET x = 'wiecx' WHERE x = 'wiecc';
UPDATE x SET x = 'wieck', x = '6000.00' WHERE x = 'wiecx';
UPDATE x SET x = '7000.00' WHERE x = 'wieck';
DELETE FROM x WHERE x = 'gates';
SELECT x, x = CURRENT_USER() AS "x", x, x, x FROM x ORDER BY x NULLS LAST, x NULLS LAST, x NULLS LAST;
INSERT INTO x VALUES ('meyer', '4000.00');
INSERT INTO x VALUES ('maier', '5000.00');
INSERT INTO x VALUES ('mayr', '6000.00');
INSERT INTO x SELECT * FROM x;
SELECT x, x = CURRENT_USER() AS "x", x, x, x FROM x ORDER BY x NULLS LAST, x NULLS LAST, x NULLS LAST;
UPDATE x SET x = x + '1000.00';
UPDATE x SET x = x.x FROM x WHERE x.x = x.x;
SELECT x, x = CURRENT_USER() AS "x", x, x, x FROM x ORDER BY x NULLS LAST, x NULLS LAST, x NULLS LAST;
DELETE FROM x USING x WHERE x.x = x.x;
SELECT x, x = CURRENT_USER() AS "x", x, x, x FROM x ORDER BY x NULLS LAST, x NULLS LAST, x NULLS LAST;
/* Multiple cascaded qualified instead rule test */ INSERT INTO x VALUES (1, 'Record should go to rtest_t4');
INSERT INTO x VALUES (2, 'Record should go to rtest_t4');
INSERT INTO x VALUES (10, 'Record should go to rtest_t5');
INSERT INTO x VALUES (15, 'Record should go to rtest_t5');
INSERT INTO x VALUES (19, 'Record should go to rtest_t5 and t7');
INSERT INTO x VALUES (20, 'Record should go to rtest_t4 and t6');
INSERT INTO x VALUES (26, 'Record should go to rtest_t4 and t8');
INSERT INTO x VALUES (28, 'Record should go to rtest_t4 and t8');
INSERT INTO x VALUES (30, 'Record should go to rtest_t4');
INSERT INTO x VALUES (40, 'Record should go to rtest_t4');
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
DELETE FROM x;
DELETE FROM x;
DELETE FROM x;
DELETE FROM x;
DELETE FROM x;
INSERT INTO x VALUES (1, 'Record should go to rtest_t4');
INSERT INTO x VALUES (2, 'Record should go to rtest_t4');
INSERT INTO x VALUES (10, 'Record should go to rtest_t5');
INSERT INTO x VALUES (15, 'Record should go to rtest_t5');
INSERT INTO x VALUES (19, 'Record should go to rtest_t5 and t7');
INSERT INTO x VALUES (20, 'Record should go to rtest_t4 and t6');
INSERT INTO x VALUES (26, 'Record should go to rtest_t4 and t8');
INSERT INTO x VALUES (28, 'Record should go to rtest_t4 and t8');
INSERT INTO x VALUES (30, 'Record should go to rtest_t4');
INSERT INTO x VALUES (40, 'Record should go to rtest_t4');
INSERT INTO x SELECT * FROM x WHERE x < 20;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
INSERT INTO x SELECT * FROM x WHERE REGEXP_LIKE(x, 'and t8');
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
INSERT INTO x SELECT x + 1, x FROM x WHERE x IN (20, 30, 40);
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
/* Check that the ordering of rules fired is correct */ INSERT INTO x VALUES (1);
SELECT * FROM x;
/* Check if instead nothing w/without qualification works */ INSERT INTO x VALUES (1, 'want this');
INSERT INTO x VALUES (2, 'want this');
INSERT INTO x VALUES (10, 'don''t want this');
INSERT INTO x VALUES (19, 'don''t want this');
INSERT INTO x VALUES (20, 'want this');
INSERT INTO x VALUES (29, 'want this');
INSERT INTO x VALUES (30, 'don''t want this');
INSERT INTO x VALUES (39, 'don''t want this');
INSERT INTO x VALUES (40, 'want this');
INSERT INTO x VALUES (50, 'want this');
INSERT INTO x VALUES (60, 'want this');
SELECT * FROM x;
INSERT INTO x VALUES (10, 'too small');
INSERT INTO x VALUES (50, 'too small');
INSERT INTO x VALUES (100, 'OK');
INSERT INTO x VALUES (200, 'OK');
SELECT * FROM x;
SELECT * FROM x;
DELETE FROM x;
DELETE FROM x;
DELETE FROM x;
INSERT INTO x VALUES (1, 'want this');
INSERT INTO x VALUES (2, 'want this');
INSERT INTO x VALUES (10, 'don''t want this');
INSERT INTO x VALUES (19, 'don''t want this');
INSERT INTO x VALUES (20, 'want this');
INSERT INTO x VALUES (29, 'want this');
INSERT INTO x VALUES (30, 'don''t want this');
INSERT INTO x VALUES (39, 'don''t want this');
INSERT INTO x VALUES (40, 'want this');
INSERT INTO x VALUES (50, 'want this');
INSERT INTO x VALUES (60, 'want this');
INSERT INTO x SELECT * FROM x;
SELECT * FROM x;
DELETE FROM x;
INSERT INTO x VALUES (10, 'too small');
INSERT INTO x VALUES (50, 'too small');
INSERT INTO x VALUES (100, 'OK');
INSERT INTO x VALUES (200, 'OK');
INSERT INTO x SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
CREATE TABLE x (x INT, x TEXT, x BOOLEAN);
CREATE TABLE x (x INT);
CREATE TABLE x (x INT, x TEXT);
CREATE TABLE x (x INT, x TEXT, x INT);
CREATE VIEW x AS SELECT x, x FROM x AS x WHERE 0 < (SELECT COUNT(*) FROM x AS x WHERE x.x = x.x);
CREATE VIEW x AS SELECT x, x FROM x WHERE x;
CREATE VIEW x AS SELECT x, x FROM x AS x WHERE 0 < (SELECT COUNT(*) FROM x AS x WHERE x.x = x.x);
CREATE VIEW x AS SELECT x.x, x.x, COUNT(x.x) AS x FROM x AS x, x AS x WHERE x.x = x.x GROUP BY x.x, x.x;
CREATE FUNCTION x(x) RETURNS INT LANGUAGE sql AS 'select count(*)::int4 from rtest_view2 where a = $1';
CREATE VIEW x AS SELECT x, x, RTEST_VIEWFUNC1(x) AS x FROM x;
INSERT INTO x VALUES (1, 'item 1', 't');
INSERT INTO x VALUES (2, 'item 2', 't');
INSERT INTO x VALUES (3, 'item 3', 't');
INSERT INTO x VALUES (4, 'item 4', 'f');
INSERT INTO x VALUES (5, 'item 5', 't');
INSERT INTO x VALUES (6, 'item 6', 'f');
INSERT INTO x VALUES (7, 'item 7', 't');
INSERT INTO x VALUES (8, 'item 8', 't');
INSERT INTO x VALUES (2);
INSERT INTO x VALUES (2);
INSERT INTO x VALUES (4);
INSERT INTO x VALUES (5);
INSERT INTO x VALUES (7);
INSERT INTO x VALUES (7);
INSERT INTO x VALUES (7);
INSERT INTO x VALUES (7);
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x ORDER BY x NULLS LAST, x NULLS LAST;
SELECT * FROM x;
INSERT INTO x SELECT * FROM x WHERE x < 7;
SELECT * FROM x;
DELETE FROM x;
INSERT INTO x SELECT * FROM x WHERE x <> 5 AND NOT REGEXP_LIKE(x, '2');
SELECT * FROM x;
DELETE FROM x;
INSERT INTO x SELECT * FROM x;
SELECT * FROM x;
DELETE FROM x;
INSERT INTO x SELECT * FROM x WHERE 3 > x;
SELECT * FROM x ORDER BY x NULLS LAST, x NULLS LAST;
DELETE FROM x;
INSERT INTO x SELECT * FROM x WHERE x > 2 AND x = 0;
SELECT * FROM x;
DELETE FROM x;
/* Test for computations in views */ CREATE TABLE x (x TEXT, x CHAR(4), x DOUBLE);
CREATE TABLE x (x CHAR(4), x DOUBLE);
CREATE VIEW x AS SELECT x.x, (x.x * x.x) AS x FROM x AS x, x AS x WHERE x.x = x.x;
INSERT INTO x VALUES ('m', 100.0);
INSERT INTO x VALUES ('cm', 1.0);
INSERT INTO x VALUES ('inch', 2.54);
INSERT INTO x VALUES ('p1', 'm', 5.0);
INSERT INTO x VALUES ('p2', 'm', 3.0);
INSERT INTO x VALUES ('p3', 'cm', 5.0);
INSERT INTO x VALUES ('p4', 'cm', 15.0);
INSERT INTO x VALUES ('p5', 'inch', 7.0);
INSERT INTO x VALUES ('p6', 'inch', 4.4);
SELECT * FROM x ORDER BY x NULLS LAST;
/* In addition run the (slightly modified) queries from the */ /* programmers manual section on the rule system. */ CREATE TABLE x (x CHAR(10) /* primary key */, x INT /* available # of pairs */, x CHAR(10) /* preferred shoelace color */, x DOUBLE /* minimum shoelace length */, x DOUBLE /* maximum shoelace length */, x CHAR(8) /* length unit */);
CREATE TABLE x (x CHAR(10) /* primary key */, x INT /* available # of pairs */, x CHAR(10) /* shoelace color */, x DOUBLE /* shoelace length */, x CHAR(8) /* length unit */);
CREATE TABLE x (x CHAR(8) /* the primary key */, x DOUBLE /* factor to transform to cm */);
CREATE VIEW x AS SELECT x.x, x.x, x.x, x.x, x.x * x.x AS x, x.x, x.x * x.x AS x, x.x FROM x AS x, x AS x WHERE x.x = x.x;
CREATE VIEW x AS SELECT x.x, x.x, x.x, x.x, x.x, x.x * x.x AS x FROM x AS x, x AS x WHERE x.x = x.x;
CREATE VIEW x AS SELECT x.x, x.x, x.x, x.x, INT4SMALLER(x.x, x.x) AS x FROM x AS x, x AS x WHERE x.x = x.x AND x.x >= x.x AND x.x <= x.x;
INSERT INTO x VALUES ('cm', 1.0);
INSERT INTO x VALUES ('m', 100.0);
INSERT INTO x VALUES ('inch', 2.54);
INSERT INTO x VALUES ('sh1', 2, 'black', 70.0, 90.0, 'cm');
INSERT INTO x VALUES ('sh2', 0, 'black', 30.0, 40.0, 'inch');
INSERT INTO x VALUES ('sh3', 4, 'brown', 50.0, 65.0, 'cm');
INSERT INTO x VALUES ('sh4', 3, 'brown', 40.0, 50.0, 'inch');
INSERT INTO x VALUES ('sl1', 5, 'black', 80.0, 'cm');
INSERT INTO x VALUES ('sl2', 6, 'black', 100.0, 'cm');
INSERT INTO x VALUES ('sl3', 0, 'black', 35.0, 'inch');
INSERT INTO x VALUES ('sl4', 8, 'black', 40.0, 'inch');
INSERT INTO x VALUES ('sl5', 4, 'brown', 1.0, 'm');
INSERT INTO x VALUES ('sl6', 0, 'brown', 0.9, 'm');
INSERT INTO x VALUES ('sl7', 7, 'brown', 60, 'cm');
INSERT INTO x VALUES ('sl8', 1, 'brown', 40, 'inch');
/* SELECTs in doc */ SELECT * FROM x ORDER BY x NULLS LAST;
SELECT * FROM x WHERE x >= 2 ORDER BY 1 NULLS LAST;
CREATE TABLE x (x CHAR(10) /* shoelace changed */, x INT /* new available value */, x NAME /* who did it */, x TIMESTAMP /* when */);
/* Want "log_who" to be CURRENT_USER, */ /* but that is non-portable for the regression test */ /* - thomas 1999-02-21 */ CREATE RULE log_shoelace AS ON UPDATE TO shoelace_data         WHERE NEW.sl_avail != OLD.sl_avail         DO INSERT INTO shoelace_log VALUES (                                         NEW.sl_name,                                         NEW.sl_avail,                                         'Al Bundy',                                         'epoch'                                     );
UPDATE x SET x = 6 WHERE x = 'sl7';
SELECT * FROM x;
CREATE RULE shoelace_ins AS ON INSERT TO shoelace         DO INSTEAD         INSERT INTO shoelace_data VALUES (                NEW.sl_name,                NEW.sl_avail,                NEW.sl_color,                NEW.sl_len,                NEW.sl_unit);
CREATE RULE shoelace_upd AS ON UPDATE TO shoelace         DO INSTEAD         UPDATE shoelace_data SET                sl_name = NEW.sl_name,                sl_avail = NEW.sl_avail,                sl_color = NEW.sl_color,                sl_len = NEW.sl_len,                sl_unit = NEW.sl_unit          WHERE sl_name = OLD.sl_name;
CREATE RULE shoelace_del AS ON DELETE TO shoelace         DO INSTEAD         DELETE FROM shoelace_data          WHERE sl_name = OLD.sl_name;
CREATE TABLE x (x CHAR(10), x INT);
CREATE TABLE x (x CHAR(10), x INT);
CREATE RULE shoelace_ok_ins AS ON INSERT TO shoelace_ok         DO INSTEAD         UPDATE shoelace SET                sl_avail = sl_avail + NEW.ok_quant          WHERE sl_name = NEW.ok_name;
INSERT INTO x VALUES ('sl3', 10);
INSERT INTO x VALUES ('sl6', 20);
INSERT INTO x VALUES ('sl8', 20);
SELECT * FROM x ORDER BY x NULLS LAST;
INSERT INTO x SELECT * FROM x;
SELECT * FROM x ORDER BY x NULLS LAST;
SELECT * FROM x ORDER BY x NULLS LAST;
CREATE VIEW x AS SELECT * FROM x WHERE NOT EXISTS(SELECT x FROM x WHERE x = x);
CREATE VIEW x AS SELECT * FROM x WHERE x = 0;
INSERT INTO x VALUES ('sl9', 0, 'pink', 35.0, 'inch', 0.0);
INSERT INTO x VALUES ('sl10', 1000, 'magenta', 40.0, 'inch', 0.0);
/* Unsupported (even though a similar updatable view construct is) */ INSERT INTO x VALUES ('sl10', 1000, 'magenta', 40.0, 'inch', 0.0) ON CONFLICT DO NOTHING;
SELECT * FROM x ORDER BY x NULLS LAST;
SELECT * FROM x;
DELETE FROM x WHERE EXISTS(SELECT * FROM x WHERE x = x.x);
SELECT * FROM x ORDER BY x NULLS LAST;
SELECT * FROM x ORDER BY x NULLS LAST;
SELECT COUNT(*) FROM x;
/* Simple test of qualified ON INSERT ... this did not work in 7.0 ... */ CREATE TABLE x (x INT);
CREATE TABLE x (x INT);
create rule rules_foorule as on insert to rules_foo where f1 < 100 do instead nothing;
INSERT INTO x VALUES (1);
INSERT INTO x VALUES (1001);
SELECT * FROM x;
drop rule rules_foorule on rules_foo;
/* this should fail because f1 is not exposed for unqualified reference: */ create rule rules_foorule as on insert to rules_foo where f1 < 100 do instead insert into rules_foo2 values (f1);
/* this is the correct way: */ create rule rules_foorule as on insert to rules_foo where f1 < 100 do instead insert into rules_foo2 values (new.f1);
INSERT INTO x VALUES (2);
INSERT INTO x VALUES (100);
SELECT * FROM x;
SELECT * FROM x;
drop rule rules_foorule on rules_foo;
DROP TABLE x;
DROP TABLE x;
/* Test rules containing INSERT ... SELECT, which is a very ugly special */ /* case as of 7.1.  Example is based on bug report from Joel Burton. */ CREATE TABLE x (x INT, x TEXT);
INSERT INTO x VALUES (1, 'parent1');
INSERT INTO x VALUES (2, 'parent2');
CREATE TABLE x (x INT, x TEXT);
INSERT INTO x VALUES (1, 'descrip1');
CREATE VIEW x AS SELECT x.x, x, x FROM x LEFT JOIN x USING (x);
create rule rrule as   on update to vview do instead (   insert into cchild (pid, descrip)     select old.pid, new.descrip where old.descrip isnull;
UPDATE x SET x = x.x WHERE x.x = x.x;
SELECT * FROM x;
UPDATE x SET x = 'test1' WHERE x = 1;
SELECT * FROM x;
UPDATE x SET x = 'test2' WHERE x = 2;
SELECT * FROM x;
UPDATE x SET x = 'test3' WHERE x = 3;
SELECT * FROM x;
SELECT * FROM x;
drop rule rrule on vview;
DROP VIEW x;
DROP TABLE x;
DROP TABLE x;
SELECT x, x, x FROM x WHERE x = 'pg_catalog' ORDER BY x NULLS LAST, x NULLS LAST;
CREATE TABLE x (x INT, x INT);
CREATE OR REPLACE RULE myrule AS ON INSERT TO ruletest_tbl 	DO INSTEAD INSERT INTO ruletest_tbl2 VALUES (10, 10);
INSERT INTO x VALUES (99, 99);
CREATE OR REPLACE RULE myrule AS ON INSERT TO ruletest_tbl 	DO INSTEAD INSERT INTO ruletest_tbl2 VALUES (1000, 1000);
INSERT INTO x VALUES (99, 99);
SELECT * FROM x;
/* Check that rewrite rules splitting one INSERT into multiple */ /* conditional statements does not disable FK checking. */ CREATE TABLE x (x INT, x INT, PRIMARY KEY (x NULLS LAST, x NULLS LAST));
CREATE TABLE x (x INT, x INT, PRIMARY KEY (x NULLS LAST, x NULLS LAST));
CREATE TABLE x (x INT, x INT, x INT, x TEXT, PRIMARY KEY (x NULLS LAST, x NULLS LAST, x NULLS LAST), FOREIGN KEY (x, x) REFERENCES x (x, x), FOREIGN KEY (x, x) REFERENCES x (x, x));
INSERT INTO x VALUES (1, 11);
INSERT INTO x VALUES (1, 12);
INSERT INTO x VALUES (2, 21);
INSERT INTO x VALUES (2, 22);
INSERT INTO x VALUES (1, 11);
INSERT INTO x VALUES (1, 12);
INSERT INTO x VALUES (2, 21);
INSERT INTO x VALUES (2, 22);
INSERT INTO x VALUES (1, 11, 11, 'row1');
INSERT INTO x VALUES (1, 11, 12, 'row2');
INSERT INTO x VALUES (1, 12, 11, 'row3');
INSERT INTO x VALUES (1, 12, 12, 'row4');
INSERT INTO x VALUES (1, 11, 13, 'row5');
INSERT INTO x VALUES (1, 13, 11, 'row6');
/* Ordinary table */ INSERT INTO x VALUES (1, 13, 11, 'row6') ON CONFLICT DO NOTHING;
/* rule not fired, so fk violation */ INSERT INTO x VALUES (1, 13, 11, 'row6') ON CONFLICT(x, x, x) DO UPDATE SET x = x.x;
/* rule fired, so unsupported */ INSERT INTO x VALUES ('sl9', 0, 'pink', 35.0, 'inch', 0.0) ON CONFLICT(x) DO UPDATE SET x = x.x;
create rule rule_and_refint_t3_ins as on insert to rule_and_refint_t3 	where (exists (select 1 from rule_and_refint_t3 			where (((rule_and_refint_t3.id3a = new.id3a) 			and (rule_and_refint_t3.id3b = new.id3b)) 			and (rule_and_refint_t3.id3c = new.id3c)))) 	do instead update rule_and_refint_t3 set data = new.data 	where (((rule_and_refint_t3.id3a = new.id3a) 	and (rule_and_refint_t3.id3b = new.id3b)) 	and (rule_and_refint_t3.id3c = new.id3c));
INSERT INTO x VALUES (1, 11, 13, 'row7');
INSERT INTO x VALUES (1, 13, 11, 'row8');
/* disallow dropping a view's rule (bug #5072) */ CREATE VIEW x AS SELECT CAST('rules_foo' AS TEXT);
drop rule "_RETURN" on rules_fooview;
DROP VIEW x;
/* We used to allow converting a table to a view by creating a "_RETURN" */ /* rule for it, but no more. */ CREATE TABLE x (x INT, x TEXT);
create rule "_RETURN" as on select to rules_fooview do instead   select 1 as x, 'aaa'::text as y;
DROP TABLE x;
/* likewise, converting a partitioned table or partition to view is not allowed */ CREATE TABLE x (x INT, x TEXT) WITH (PARTITIONED_BY=LIST(x));
create rule "_RETURN" as on select to rules_fooview do instead   select 1 as x, 'aaa'::text as y;
CREATE TABLE x PARTITION OF x FOR VALUES IN (1);
create rule "_RETURN" as on select to rules_fooview_part do instead   select 1 as x, 'aaa'::text as y;
DROP TABLE x;
/* check for planner problems with complex inherited UPDATES */ CREATE TABLE x (x SERIAL PRIMARY KEY, x TEXT);
/* currently, must respecify PKEY for each inherited subtable */ CREATE TABLE x (x INT PRIMARY KEY) INHERITS (x);
CREATE TABLE x (x INT PRIMARY KEY) INHERITS (x);
CREATE TABLE x (x INT PRIMARY KEY) INHERITS (x);
INSERT INTO x (x) VALUES ('Test 1');
INSERT INTO x (x) VALUES ('Test 2');
INSERT INTO x (x) VALUES ('Test 3');
INSERT INTO x (x) VALUES ('Test 4');
INSERT INTO x (x) VALUES ('Test 5');
INSERT INTO x (x) VALUES ('Test 6');
CREATE VIEW x AS SELECT * FROM x ORDER BY x NULLS LAST;
create rule update_id_ordered as on update to id_ordered 	do instead update id set name = new.name where id = old.id;
SELECT * FROM x;
UPDATE x SET x = 'update 2' WHERE x = 2;
UPDATE x SET x = 'update 4' WHERE x = 4;
UPDATE x SET x = 'update 5' WHERE x = 5;
SELECT * FROM x;
DROP TABLE x CASCADE;
/* check corner case where an entirely-dummy subplan is created by */ /* constraint exclusion */ CREATE TEMPORARY TABLE x (x INT PRIMARY KEY);
CREATE TEMPORARY TABLE x (CHECK (x >= 0 AND x < 10)) INHERITS (x);
CREATE TEMPORARY TABLE x (CHECK (x >= 10 AND x < 20)) INHERITS (x);
create rule t1_ins_1 as on insert to t1 	where new.a >= 0 and new.a < 10 	do instead 	insert into t1_1 values (new.a);
create rule t1_ins_2 as on insert to t1 	where new.a >= 10 and new.a < 20 	do instead 	insert into t1_2 values (new.a);
create rule t1_upd_1 as on update to t1 	where old.a >= 0 and old.a < 10 	do instead 	update t1_1 set a = new.a where a = old.a;
create rule t1_upd_2 as on update to t1 	where old.a >= 10 and old.a < 20 	do instead 	update t1_2 set a = new.a where a = old.a;
SET x = on;
INSERT INTO x SELECT * FROM x AS x;
UPDATE x SET x = 4 WHERE x = 5;
SELECT * FROM ONLY x;
SELECT * FROM ONLY x;
SELECT * FROM ONLY x;
RESET constraint_exclusion;
/* test FOR UPDATE in rules */ CREATE TABLE x (x INT, x INT);
INSERT INTO x VALUES (1, 2), (11, 12);
create rule r1 as on update to rules_base do instead   select * from rules_base where f1 = 1 for update;
UPDATE x SET x = x + 1;
create or replace rule r1 as on update to rules_base do instead   select * from rules_base where f1 = 11 for update of rules_base;
UPDATE x SET x = x + 1;
create or replace rule r1 as on update to rules_base do instead   select * from rules_base where f1 = 11 for update of old;
/* error */ DROP TABLE x;
/* test various flavors of pg_get_viewdef() */ SELECT PG_GET_VIEWDEF(CAST('shoe' AS REGCLASS)) AS x;
SELECT PG_GET_VIEWDEF(CAST('shoe' AS REGCLASS), TRUE) AS x;
SELECT PG_GET_VIEWDEF(CAST('shoe' AS REGCLASS), 0) AS x;
/* check multi-row VALUES in rules */ CREATE TABLE x (x INT, x INT DEFAULT 0);
CREATE TABLE x (x INT, x INT, x TEXT, x SERIAL);
INSERT INTO x VALUES (1, 2), (11, 12);
create rule r1 as on update to rules_src do also   insert into rules_log values(old.*, 'old', default), (new.*, 'new', default);
UPDATE x SET x = x + 1;
UPDATE x SET x = x * 10;
SELECT * FROM x;
SELECT * FROM x;
create rule r2 as on update to rules_src do also   values(old.*, 'old'), (new.*, 'new');
UPDATE x SET x = x / 10;
create rule r3 as on insert to rules_src do also   insert into rules_log values(null, null, '-', default), (new.*, 'new', default);
INSERT INTO x VALUES (22, 23), (33, DEFAULT);
SELECT * FROM x;
SELECT * FROM x;
create rule r4 as on delete to rules_src do notify rules_src_deletion;
/* Ensure an aliased target relation for insert is correctly deparsed. */ create rule r5 as on insert to rules_src do instead insert into rules_log AS trgt SELECT NEW.* RETURNING trgt.f1, trgt.f2;
create rule r6 as on update to rules_src do instead UPDATE rules_log AS trgt SET tag = 'updated' WHERE trgt.f1 = new.f1;
/* Check deparse disambiguation of INSERT/UPDATE/DELETE targets. */ create rule r7 as on delete to rules_src do instead   with wins as (insert into int4_tbl as trgt values (0) returning *),        wupd as (update int4_tbl trgt set f1 = f1+1 returning *),        wdel as (delete from int4_tbl trgt where f1 = 0 returning *)   insert into rules_log AS trgt select old.* from wins, wupd, wdel   returning trgt.f1, trgt.f2;
CREATE TABLE x (x INT, x ARRAY<INT>, x TEXT);
create rule rr as on update to rule_t1 do instead UPDATE rule_dest trgt   SET (f2[1], f1, tag) = (SELECT new.f2, new.f1, 'updated'::varchar)   WHERE trgt.f1 = new.f1 RETURNING new.*;
/* Test implicit LATERAL references to old/new in rules */ CREATE TABLE x (x INT, x TEXT DEFAULT 'xxx', x INT);
CREATE VIEW x AS SELECT * FROM x;
CREATE RULE v1_ins AS ON INSERT TO rule_v1   DO ALSO INSERT INTO rule_t1   SELECT * FROM (SELECT a + 10 FROM rule_t1 WHERE a = NEW.a) tt;
CREATE RULE v1_upd AS ON UPDATE TO rule_v1   DO ALSO UPDATE rule_t1 t   SET c = tt.a * 10   FROM (SELECT a FROM rule_t1 WHERE a = OLD.a) tt WHERE t.a = tt.a;
INSERT INTO x VALUES (1, 'a'), (2, 'b');
UPDATE x SET x = UPPER(x);
SELECT * FROM x;
DROP TABLE x CASCADE;
/* check alter rename rule */ CREATE TABLE x (x INT);
CREATE VIEW x AS SELECT * FROM x;
CREATE RULE InsertRule AS     ON INSERT TO rule_v1     DO INSTEAD         INSERT INTO rule_t1 VALUES(new.a);
ALTER RULE InsertRule ON rule_v1 RENAME to NewInsertRule;
INSERT INTO x VALUES (1);
SELECT * FROM x;
/* doesn't exist */ ALTER RULE NewInsertRule ON rule_v1 RENAME TO "_RETURN";
/* already exists */ ALTER RULE "_RETURN" ON rule_v1 RENAME TO abc;
/* ON SELECT rule cannot be renamed */ DROP VIEW x;
DROP TABLE x;
/* check display of VALUES in view definitions */ CREATE VIEW x AS VALUES (1, 2);
CREATE VIEW x (x) AS VALUES (1, 2);
CREATE VIEW x (x) AS SELECT * FROM (VALUES (1, 2)) AS x;
CREATE VIEW x (x) AS SELECT * FROM (VALUES (1, 2)) AS x;
/* Check DO INSTEAD rules with ON CONFLICT */ CREATE TABLE x (x CHAR(10) PRIMARY KEY, x CHAR(10) /* hat color */);
CREATE TABLE x (x CHAR(10), x CHAR(10) /* hat color */);
CREATE UNIQUE INDEX x ON x(x COLLATE "x" x NULLS LAST);
/* DO NOTHING with ON CONFLICT */ CREATE RULE hat_nosert AS ON INSERT TO hats     DO INSTEAD     INSERT INTO hat_data VALUES (            NEW.hat_name,            NEW.hat_color)         ON CONFLICT (hat_name COLLATE "C" bpchar_pattern_ops) WHERE hat_color = 'green'         DO NOTHING         RETURNING *;
SELECT x FROM x WHERE x = 'hats' ORDER BY x NULLS LAST;
/* Works (projects row) */ INSERT INTO x VALUES ('h7', 'black') RETURNING *;
/* Works (does nothing) */ INSERT INTO x VALUES ('h7', 'black') RETURNING *;
SELECT x, x, x FROM x WHERE x = 'hats';
DROP RULE hat_nosert ON hats;
/* DO NOTHING without ON CONFLICT */ CREATE RULE hat_nosert_all AS ON INSERT TO hats     DO INSTEAD     INSERT INTO hat_data VALUES (            NEW.hat_name,            NEW.hat_color)         ON CONFLICT         DO NOTHING         RETURNING *;
SELECT x FROM x WHERE x = 'hats' ORDER BY x NULLS LAST;
DROP RULE hat_nosert_all ON hats;
/* Works (does nothing) */ INSERT INTO x VALUES ('h7', 'black') RETURNING *;
/* DO UPDATE with a WHERE clause */ CREATE RULE hat_upsert AS ON INSERT TO hats     DO INSTEAD     INSERT INTO hat_data VALUES (            NEW.hat_name,            NEW.hat_color)         ON CONFLICT (hat_name)         DO UPDATE            SET hat_name = hat_data.hat_name, hat_color = excluded.hat_color            WHERE excluded.hat_color <>  'forbidden' AND hat_data.* != excluded.*         RETURNING *;
SELECT x FROM x WHERE x = 'hats' ORDER BY x NULLS LAST;
/* Works (does upsert) */ INSERT INTO x VALUES ('h8', 'black') RETURNING *;
SELECT * FROM x WHERE x = 'h8';
INSERT INTO x VALUES ('h8', 'white') RETURNING *;
SELECT * FROM x WHERE x = 'h8';
INSERT INTO x VALUES ('h8', 'forbidden') RETURNING *;
SELECT * FROM x WHERE x = 'h8';
SELECT x, x, x FROM x WHERE x = 'hats';
/* ensure explain works for on insert conflict rules */ EXPLAIN (costs off) INSERT INTO hats VALUES ('h8', 'forbidden') RETURNING *;
/* ensure upserting into a rule, with a CTE (different offsets!) works */ WITH x AS MATERIALIZED (SELECT * FROM (VALUES ('h8', 'green'), ('h9', 'blue'), ('h7', 'forbidden')) AS x) INSERT INTO x SELECT * FROM x RETURNING *;
EXPLAIN (costs off) WITH data(hat_name, hat_color) AS MATERIALIZED (     VALUES ('h8', 'green'),         ('h9', 'blue'),         ('h7', 'forbidden') ) INSERT INTO hats     SELECT * FROM data RETURNING *;
SELECT * FROM x WHERE x IN ('h8', 'h9', 'h7') ORDER BY x NULLS LAST;
DROP RULE hat_upsert ON hats;
DROP TABLE x;
DROP TABLE x;
SELECT PG_GET_FUNCTIONDEF(CAST('func_with_set_params()' AS REGPROCEDURE));
/* tests for pg_get_*def with invalid objects */ SELECT PG_GET_CONSTRAINTDEF(0);
SELECT PG_GET_FUNCTIONDEF(0);
SELECT PG_GET_INDEXDEF(0);
SELECT PG_GET_RULEDEF(0);
SELECT PG_GET_STATISTICSOBJDEF(0);
SELECT PG_GET_TRIGGERDEF(0);
SELECT PG_GET_VIEWDEF(0);
SELECT PG_GET_FUNCTION_ARGUMENTS(0);
SELECT PG_GET_FUNCTION_IDENTITY_ARGUMENTS(0);
SELECT PG_GET_FUNCTION_RESULT(0);
SELECT PG_GET_FUNCTION_ARG_DEFAULT(0, 0);
SELECT PG_GET_FUNCTION_ARG_DEFAULT(CAST('pg_class' AS REGCLASS), 0);
SELECT PG_GET_PARTKEYDEF(0);
/* test rename for a rule defined on a partitioned table */ CREATE TABLE x (x INT) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN (1);
CREATE RULE rules_parted_table_insert AS ON INSERT to rules_parted_table     DO INSTEAD INSERT INTO rules_parted_table_1 VALUES (NEW.*);
ALTER RULE rules_parted_table_insert ON rules_parted_table RENAME TO rules_parted_table_insert_redirect;
DROP TABLE x;
/* test MERGE */ CREATE TABLE x (x INT, x TEXT);
CREATE TABLE x (x INT, x TEXT);
CREATE RULE rule1 AS ON INSERT TO rule_merge1 	DO INSTEAD INSERT INTO rule_merge2 VALUES (NEW.*);
CREATE RULE rule2 AS ON UPDATE TO rule_merge1 	DO INSTEAD UPDATE rule_merge2 SET a = NEW.a, b = NEW.b 	WHERE a = OLD.a;
CREATE RULE rule3 AS ON DELETE TO rule_merge1 	DO INSTEAD DELETE FROM rule_merge2 WHERE a = OLD.a;
MERGE INTO x AS x USING (SELECT 1 AS x) AS x ON x.x = x.x WHEN MATCHED AND x.x < 2 THEN UPDATE SET x = x || ' updated by merge' WHEN MATCHED AND x.x > 2 THEN DELETE WHEN NOT MATCHED THEN INSERT VALUES (x.x, '') /* MERGE not supported for table with rules */;
MERGE INTO x AS x USING (SELECT 1 AS x) AS x ON x.x = x.x WHEN MATCHED AND x.x < 2 THEN UPDATE SET x = x || ' updated by merge' WHEN MATCHED AND x.x > 2 THEN DELETE WHEN NOT MATCHED THEN INSERT VALUES (x.x, '') /* should be ok with the other table though */;
/* also ok if the rules are disabled */ ALTER TABLE rule_merge1 DISABLE RULE rule1;
ALTER TABLE rule_merge1 DISABLE RULE rule2;
ALTER TABLE rule_merge1 DISABLE RULE rule3;
MERGE INTO x AS x USING (SELECT 1 AS x) AS x ON x.x = x.x WHEN MATCHED AND x.x < 2 THEN UPDATE SET x = x || ' updated by merge' WHEN MATCHED AND x.x > 2 THEN DELETE WHEN NOT MATCHED THEN INSERT VALUES (x.x, '');
/* test deparsing */ CREATE TABLE x (x INT, x TEXT, x ARRAY<INT>);
CREATE FUNCTION x() RETURNS TABLE (x TEXT, x INT, x TEXT, x INT, x TEXT, x ARRAY<INT>, x INT, x TEXT, x ARRAY<INT>, x INT, x TEXT, x ARRAY<INT>) LANGUAGE sql AS BEGIN ATOMIC  MERGE INTO sf_target t    USING rule_merge1 s    ON (s.a = t.id) WHEN MATCHED    AND (s.a + t.id) = 42    THEN UPDATE SET data = repeat(t.data, s.a) || s.b, id = length(s.b) WHEN NOT MATCHED    AND (s.b IS NOT NULL)    THEN INSERT (data, id)    VALUES (s.b, s.a) WHEN MATCHED    AND length(s.b || t.data) > 10    THEN UPDATE SET data = s.b WHEN MATCHED    AND s.a > 200    THEN UPDATE SET filling[s.a] = t.id WHEN MATCHED    AND s.a > 100    THEN DELETE WHEN MATCHED    THEN DO NOTHING WHEN NOT MATCHED    AND s.a > 200    THEN INSERT DEFAULT VALUES WHEN NOT MATCHED    AND s.a > 100    THEN INSERT (id, data) OVERRIDING USER VALUE    VALUES (s.a, DEFAULT) WHEN NOT MATCHED    AND s.a > 0    THEN INSERT    VALUES (s.a, s.b, DEFAULT) WHEN NOT MATCHED    THEN INSERT (filling[1], id)    VALUES (s.a, s.a) RETURNING    WITH (OLD AS o, NEW AS n)    merge_action() AS action, *, o.*, n.*;
COMMIT;
COMMIT;
DROP FUNCTION x;
DROP TABLE x;
/* Test enabling/disabling */ CREATE TABLE x (x INT);
CREATE TABLE x (x INT);
CREATE RULE rule1 AS ON INSERT TO ruletest1     DO INSTEAD INSERT INTO ruletest2 VALUES (NEW.*);
INSERT INTO x VALUES (1);
ALTER TABLE ruletest1 DISABLE RULE rule1;
INSERT INTO x VALUES (2);
ALTER TABLE ruletest1 ENABLE RULE rule1;
SET x = replica;
INSERT INTO x VALUES (3);
ALTER TABLE ruletest1 ENABLE REPLICA RULE rule1;
INSERT INTO x VALUES (4);
RESET session_replication_role;
INSERT INTO x VALUES (5);
SELECT * FROM x;
SELECT * FROM x;
DROP TABLE x;
DROP TABLE x;
/* Test non-SELECT rule on security invoker view. */ /* Should use view owner's permissions. */ CREATE USER regress_rule_user1;
CREATE TABLE x (x INT);
CREATE TABLE x (x INT);
CREATE VIEW x WITH (security_invoker=TRUE) AS SELECT * FROM x;
GRANT INSERT ON x TO x;
CREATE RULE rule1 AS ON INSERT TO ruletest_v1     DO INSTEAD INSERT INTO ruletest_t2 VALUES (NEW.*);
SET SESSION AUTHORIZATION regress_rule_user1;
INSERT INTO x VALUES (1);
RESET SESSION AUTHORIZATION;
/* Test that main query's relation's permissions are checked before */ /* the rule action's relation's. */ CREATE TABLE x (x INT);
CREATE RULE rule2 AS ON UPDATE TO ruletest_t1     DO INSTEAD INSERT INTO ruletest_t2 VALUES (OLD.*);
REVOKE ALL ON ruletest_t2 FROM regress_rule_user1;
REVOKE ALL ON ruletest_t3 FROM regress_rule_user1;
ALTER TABLE ruletest_t1 OWNER TO regress_rule_user1;
SET SESSION AUTHORIZATION regress_rule_user1;
UPDATE x AS x SET x = 0 FROM x AS x WHERE x.x = x.x;
RESET SESSION AUTHORIZATION;
SELECT * FROM x;
SELECT * FROM x;
DROP VIEW x;
DROP RULE rule2 ON ruletest_t1;
DROP TABLE x;
DROP TABLE x;
DROP TABLE x;
DROP USER regress_rule_user1;
VACUUM;
/* Sanity check: every system catalog that has OIDs should have */ /* a unique index on OID.  This ensures that the OIDs will be unique, */ /* even after the OID counter wraps around. */ /* We exclude non-system tables from the check by looking at nspname. */ SELECT x, x FROM x AS x LEFT JOIN x AS x ON x.x = x JOIN x AS x ON (x = x.x AND x = 'oid') WHERE x = 'r' AND x.x < 16384 AND (NOT (REGEXP_LIKE(x, '^pg_')) IS FALSE) AND NOT EXISTS(SELECT 1 FROM x AS x WHERE x = x.x AND x[-1] = x.x AND x = 1 AND x AND x);
/* check that relations without storage don't have relfilenode */ SELECT x, x FROM x WHERE x IN ('v', 'c', 'f', 'p', 'I') AND x <> 0;
SET x = 'warning' /* Test for facilities of security label */ /* initial setups */;
DROP ROLE IF EXISTS regress_seclabel_user1;
DROP ROLE IF EXISTS regress_seclabel_user2;
RESET client_min_messages;
CREATE USER regress_seclabel_user1 WITH CREATEROLE;
CREATE USER regress_seclabel_user2;
CREATE TABLE x (x INT, x TEXT);
CREATE TABLE x (x INT, x TEXT);
CREATE VIEW x AS SELECT * FROM x;
CREATE FUNCTION x() RETURNS INT LANGUAGE sql AS $$SELECT 4$$;
CREATE DOMAIN seclabel_domain AS text;
ALTER TABLE seclabel_tbl1 OWNER TO regress_seclabel_user1;
ALTER TABLE seclabel_tbl2 OWNER TO regress_seclabel_user2;
/* fail */ /* clean up objects */ DROP FUNCTION x;
DROP DOMAIN seclabel_domain;
DROP VIEW x;
DROP TABLE x;
DROP TABLE x;
DROP USER regress_seclabel_user1;
DROP USER regress_seclabel_user2;
ANALYZE x /* test partial btree indexes */ /* As of 7.2, planner probably won't pick an indexscan without stats, */ /* so ANALYZE first.  Also, we want to prevent it from picking a bitmapscan */ /* followed by sort, because that could hide index ordering problems. */;
SET x = off;
SET x = off;
SET x = off;
RESET enable_seqscan;
RESET enable_bitmapscan;
RESET enable_sort;
/* Test some cases involving whole-row Var referencing a subquery */ SELECT x FROM (SELECT 1 OFFSET 0) AS x;
SELECT x FROM (SELECT NULL OFFSET 0) AS x;
SELECT x FROM (SELECT 'xyzzy', 1, NULL OFFSET 0) AS x;
/* Test VALUES lists */ SELECT * FROM x, (VALUES (147, 'RFAAAA'), (931, 'VJAAAA')) AS x WHERE x.x = x.x AND x.x = x.x;
/* a more complex case */ /* looks like we're coding lisp :-) */ SELECT * FROM x, (VALUES ((SELECT x FROM (VALUES (10000), (2), (389), (1000), (2000), ((SELECT 10029))) AS x ORDER BY x ASC NULLS LAST LIMIT 1))) AS x WHERE x.x = x.x;
/* try VALUES in a subquery */ SELECT * FROM x WHERE (x, x) IN (VALUES (1, 1), (20, 0), (99, 9), (17, 99)) ORDER BY x NULLS LAST;
VALUES (1, 2), (3, 4 + 4), (7, 77.7);
/* corner case: VALUES with no columns */ CREATE TEMPORARY TABLE x;
SELECT * FROM x AS x, LATERAL (VALUES (x.*)) AS x;
/* Test ORDER BY options */ CREATE TEMPORARY TABLE x (x INT);
INSERT INTO x VALUES (42), (3), (10), (7), (NULL), (NULL), (1);
SELECT * FROM x ORDER BY x NULLS LAST;
SELECT * FROM x ORDER BY x ASC NULLS LAST;
/* same thing */ SELECT * FROM x ORDER BY x;
SELECT * FROM x ORDER BY x DESC NULLS FIRST;
SELECT * FROM x ORDER BY x DESC;
/* check if indexscans do the right things */ CREATE INDEX x ON x(x NULLS LAST);
SET x = FALSE;
SELECT * FROM x ORDER BY x NULLS LAST;
SELECT * FROM x ORDER BY x;
SELECT * FROM x ORDER BY x DESC NULLS FIRST;
SELECT * FROM x ORDER BY x DESC;
DROP INDEX x;
CREATE INDEX x ON x(x DESC NULLS FIRST);
SELECT * FROM x ORDER BY x NULLS LAST;
SELECT * FROM x ORDER BY x;
SELECT * FROM x ORDER BY x DESC NULLS FIRST;
SELECT * FROM x ORDER BY x DESC;
DROP INDEX x;
CREATE INDEX x ON x(x DESC);
SELECT * FROM x ORDER BY x NULLS LAST;
SELECT * FROM x ORDER BY x;
SELECT * FROM x ORDER BY x DESC NULLS FIRST;
SELECT * FROM x ORDER BY x DESC;
/* Test planning of some cases with partial indexes */ /* partial index is usable */ EXPLAIN (costs off) select * from onek2 where unique2 = 11 and stringu1 = 'ATAAAA';
SELECT * FROM x WHERE x = 11 AND x = 'ATAAAA';
/* actually run the query with an analyze to use the partial index */ EXPLAIN (costs off, analyze on, timing off, summary off, buffers off) select * from onek2 where unique2 = 11 and stringu1 = 'ATAAAA';
EXPLAIN (costs off) select unique2 from onek2 where unique2 = 11 and stringu1 = 'ATAAAA';
SELECT x FROM x WHERE x = 11 AND x = 'ATAAAA';
/* partial index predicate implies clause, so no need for retest */ EXPLAIN (costs off) select * from onek2 where unique2 = 11 and stringu1 < 'B';
SELECT * FROM x WHERE x = 11 AND x < 'B';
EXPLAIN (costs off) select unique2 from onek2 where unique2 = 11 and stringu1 < 'B';
SELECT x FROM x WHERE x = 11 AND x < 'B';
/* but if it's an update target, must retest anyway */ EXPLAIN (costs off) select unique2 from onek2 where unique2 = 11 and stringu1 < 'B' for update;
SELECT x FROM x WHERE x = 11 AND x < 'B';
/* partial index is not applicable */ EXPLAIN (costs off) select unique2 from onek2 where unique2 = 11 and stringu1 < 'C';
SELECT x FROM x WHERE x = 11 AND x < 'C';
SET x = off /* partial index implies clause, but bitmap scan must recheck predicate anyway */;
EXPLAIN (costs off) select unique2 from onek2 where unique2 = 11 and stringu1 < 'B';
SELECT x FROM x WHERE x = 11 AND x < 'B';
RESET enable_indexscan;
/* check multi-index cases too */ EXPLAIN (costs off) select unique1, unique2 from onek2   where (unique2 = 11 or unique1 = 0) and stringu1 < 'B';
SELECT x, x FROM x WHERE (x = 11 OR x = 0) AND x < 'B';
EXPLAIN (costs off) select unique1, unique2 from onek2   where (unique2 = 11 and stringu1 < 'B') or unique1 = 0;
SELECT x, x FROM x WHERE (x = 11 AND x < 'B') OR x = 0;
/* Test some corner cases that have been known to confuse the planner */ /* ORDER BY on a constant doesn't really need any sorting */ SELECT 1 AS x ORDER BY x NULLS LAST;
/* But ORDER BY on a set-valued expression does */ create function sillysrf(int) returns setof int as   'values (1),(10),(2),($1)' language sql immutable;
SELECT SILLYSRF(42);
SELECT SILLYSRF(-1) ORDER BY 1 NULLS LAST;
DROP FUNCTION x (INT);
/* X = X isn't a no-op, it's effectively X IS NOT NULL assuming = is strict */ /* (see bug #5084) */ SELECT * FROM (VALUES (2), (NULL), (1)) AS x WHERE x = x ORDER BY x NULLS LAST;
SELECT * FROM (VALUES (2), (NULL), (1)) AS x WHERE x = x;
/* Test partitioned tables with no partitions, which should be handled the */ /* same as the non-inheritance case when expanding its RTE. */ CREATE TABLE x (x INT, x INT) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN (1) WITH (PARTITIONED_BY=LIST(x));
EXPLAIN (costs off) select * from list_parted_tbl;
DROP TABLE x;
/* Check mentioning same column more than once */ EXPLAIN (VERBOSE, COSTS OFF) SELECT count(*) FROM   (SELECT DISTINCT two, four, two FROM tenk1) ss;
SELECT COUNT(*) FROM (SELECT DISTINCT x, x, x FROM x) AS x;
SET x = '64kB' /* Compare results between plans using sorting and plans using hash */ /* aggregation. Force spilling in both cases by setting work_mem low. */;
SET x = FALSE /* Produce results with sorting. */;
SET x = 0;
EXPLAIN (costs off) SELECT DISTINCT g%1000 FROM generate_series(0,9999) g;
CREATE TABLE x AS SELECT DISTINCT x % 1000 FROM x AS x;
SET x = DEFAULT;
CREATE TABLE x AS SELECT DISTINCT CAST((x % 1000) AS TEXT) FROM x AS x;
SET x = 0;
/* Check to see we get an incremental sort plan */ EXPLAIN (costs off) SELECT DISTINCT hundred, two FROM tenk1;
RESET enable_seqscan;
SET x = TRUE;
SET x = FALSE /* Produce results with hash aggregation. */;
SET x = 0;
EXPLAIN (costs off) SELECT DISTINCT g%1000 FROM generate_series(0,9999) g;
CREATE TABLE x AS SELECT DISTINCT x % 1000 FROM x AS x;
SET x = DEFAULT;
CREATE TABLE x AS SELECT DISTINCT CAST((x % 1000) AS TEXT) FROM x AS x;
SET x = TRUE;
SET x = DEFAULT;
(SELECT * FROM x EXCEPT SELECT * FROM x) /* Compare results */ UNION ALL (SELECT * FROM x EXCEPT SELECT * FROM x);
(SELECT * FROM x EXCEPT SELECT * FROM x) UNION ALL (SELECT * FROM x EXCEPT SELECT * FROM x);
DROP TABLE x;
DROP TABLE x;
DROP TABLE x;
DROP TABLE x;
SET x = 0 /* Test parallel DISTINCT */;
SET x = 0;
SET x = 0;
SET x = 2;
/* Ensure we get a parallel plan */ EXPLAIN (costs off) SELECT DISTINCT four FROM tenk1;
/* Ensure the parallel plan produces the correct results */ SELECT DISTINCT x FROM x;
COMMIT;
/* Ensure we don't do parallel distinct with a parallel unsafe function */ EXPLAIN (COSTS OFF) SELECT DISTINCT distinct_func(1) FROM tenk1;
COMMIT;
/* Ensure we do parallel distinct now that the function is parallel safe */ EXPLAIN (COSTS OFF) SELECT DISTINCT distinct_func(1) FROM tenk1;
RESET max_parallel_workers_per_gather;
RESET min_parallel_table_scan_size;
RESET parallel_setup_cost;
RESET parallel_tuple_cost;
/* Test the planner's ability to use a LIMIT 1 instead of a Unique node when */ /* all of the distinct_pathkeys have been marked as redundant */ /* Ensure we get a plan with a Limit 1 */ EXPLAIN (COSTS OFF) SELECT DISTINCT four FROM tenk1 WHERE four = 0;
/* Ensure the above gives us the correct result */ SELECT DISTINCT x FROM x WHERE x = 0;
/* Ensure we get a plan with a Limit 1 */ EXPLAIN (COSTS OFF) SELECT DISTINCT four FROM tenk1 WHERE four = 0 AND two <> 0;
/* Ensure no rows are returned */ SELECT DISTINCT x FROM x WHERE x = 0 AND x <> 0;
/* Ensure we get a plan with a Limit 1 when the SELECT list contains constants */ EXPLAIN (COSTS OFF) SELECT DISTINCT four,1,2,3 FROM tenk1 WHERE four = 0;
/* Ensure we only get 1 row */ SELECT DISTINCT x, 1, 2, 3 FROM x WHERE x = 0;
SET x = 0;
SET x = 0;
SET x = 2;
/* Ensure we get a plan with a Limit 1 in both partial distinct and final */ /* distinct */ EXPLAIN (COSTS OFF) SELECT DISTINCT four FROM tenk1 WHERE four = 10;
RESET max_parallel_workers_per_gather;
RESET min_parallel_table_scan_size;
RESET parallel_setup_cost;
/* Also, some tests of IS DISTINCT FROM, which doesn't quite deserve its */ /* very own regression file. */ CREATE TEMPORARY TABLE x (x INT);
INSERT INTO x VALUES (1);
INSERT INTO x VALUES (2);
INSERT INTO x VALUES (3);
INSERT INTO x VALUES (NULL);
/* basic cases */ SELECT x, x IS DISTINCT FROM 2 AS "x" FROM x;
SELECT x, x IS DISTINCT FROM NULL AS "x" FROM x;
SELECT x, x IS DISTINCT FROM x AS "x" FROM x;
SELECT x, x IS DISTINCT FROM x + 1 AS "x" FROM x;
/* check that optimizer constant-folds it properly */ SELECT 1 IS DISTINCT FROM 2 AS "x";
SELECT 2 IS DISTINCT FROM 2 AS "x";
SELECT 2 IS DISTINCT FROM NULL AS "x";
SELECT NULL IS DISTINCT FROM NULL AS "x";
/* negated form */ SELECT 1 IS NOT DISTINCT FROM 2 AS "x";
SELECT 2 IS NOT DISTINCT FROM 2 AS "x";
SELECT 2 IS NOT DISTINCT FROM NULL AS "x";
SELECT NULL IS NOT DISTINCT FROM NULL AS "x";
/* Test the planner's ability to reorder the distinctClause Pathkeys to match */ /* the input path's ordering */ CREATE TABLE x (x INT, x INT);
INSERT INTO x SELECT x % 10, x % 10 FROM x AS x;
CREATE INDEX x ON x(x NULLS LAST, x NULLS LAST);
ANALYZE x;
SET x = OFF /* Produce results with sorting. */;
/* Ensure we avoid the need to re-sort by reordering the distinctClause */ /* Pathkeys to match the ordering of the input path */ EXPLAIN (COSTS OFF) SELECT DISTINCT y, x FROM distinct_tbl;
SELECT DISTINCT x, x FROM x;
/* Ensure we leverage incremental-sort by reordering the distinctClause */ /* Pathkeys to partially match the ordering of the input path */ EXPLAIN (COSTS OFF) SELECT DISTINCT y, x FROM (SELECT * FROM distinct_tbl ORDER BY x) s;
SELECT DISTINCT x, x FROM (SELECT * FROM x ORDER BY x NULLS LAST) AS x;
SET x = 0 /* Ensure we avoid the need to re-sort in partial distinct by reordering the */ /* distinctClause Pathkeys to match the ordering of the input path */;
SET x = 0;
SET x = 0;
SET x = 0;
SET x = 2;
EXPLAIN (COSTS OFF) SELECT DISTINCT y, x FROM distinct_tbl limit 10;
SELECT DISTINCT x, x FROM x LIMIT 10;
RESET max_parallel_workers_per_gather;
RESET min_parallel_index_scan_size;
RESET min_parallel_table_scan_size;
RESET parallel_setup_cost;
RESET parallel_tuple_cost;
/* Ensure we reorder the distinctClause Pathkeys to match the ordering of the */ /* input path even if there is ORDER BY clause */ EXPLAIN (COSTS OFF) SELECT DISTINCT y, x FROM distinct_tbl ORDER BY y;
SELECT DISTINCT x, x FROM x ORDER BY x NULLS LAST;
RESET enable_hashagg;
DROP TABLE x;
/* bug #5049: early 8.4.x chokes on volatile DISTINCT ON clauses */ SELECT DISTINCT ON (1) FLOOR(RAND()) AS x, x FROM x ORDER BY 1 NULLS LAST, 2 NULLS LAST;
/* Test the planner's ability to use a LIMIT 1 instead of a Unique node when */ /* all of the distinct_pathkeys have been marked as redundant */ /* Ensure we also get a LIMIT plan with DISTINCT ON */ EXPLAIN (COSTS OFF) SELECT DISTINCT ON (four) four,two    FROM tenk1 WHERE four = 0 ORDER BY 1;
/* and check the result of the above query is correct */ SELECT DISTINCT ON (x) x, x FROM x WHERE x = 0 ORDER BY 1 NULLS LAST;
/* Ensure a Sort -> Limit is used when the ORDER BY contains additional cols */ EXPLAIN (COSTS OFF) SELECT DISTINCT ON (four) four,two    FROM tenk1 WHERE four = 0 ORDER BY 1,2;
/* Same again but use a column that is indexed so that we get an index scan */ /* then a limit */ EXPLAIN (COSTS OFF) SELECT DISTINCT ON (four) four,hundred    FROM tenk1 WHERE four = 0 ORDER BY 1,2;
/* Test the planner's ability to reorder the distinctClause Pathkeys to match */ /* the input path's ordering */ CREATE TABLE x (x INT, x INT, x INT);
INSERT INTO x SELECT x % 10, x % 10, x % 10 FROM x AS x;
CREATE INDEX x ON x(x NULLS LAST, x NULLS LAST);
ANALYZE x;
SET x = OFF /* Produce results with sorting. */;
/* Ensure we avoid the need to re-sort by reordering the distinctClause */ /* Pathkeys to match the ordering of the input path */ EXPLAIN (COSTS OFF) SELECT DISTINCT ON (y, x) x, y FROM distinct_on_tbl;
SELECT DISTINCT ON (x, x) x, x FROM x;
/* Ensure we leverage incremental-sort by reordering the distinctClause */ /* Pathkeys to partially match the ordering of the input path */ EXPLAIN (COSTS OFF) SELECT DISTINCT ON (y, x) x, y FROM (SELECT * FROM distinct_on_tbl ORDER BY x) s;
SELECT DISTINCT ON (x, x) x, x FROM (SELECT * FROM x ORDER BY x NULLS LAST) AS x;
/* Ensure we reorder the distinctClause Pathkeys to match the ordering of the */ /* input path even if there is ORDER BY clause */ EXPLAIN (COSTS OFF) SELECT DISTINCT ON (y, x) x, y FROM distinct_on_tbl ORDER BY y;
SELECT DISTINCT ON (x, x) x, x FROM x ORDER BY x NULLS LAST;
/* Ensure the resulting pathkey list matches the initial distinctClause Pathkeys */ EXPLAIN (COSTS OFF) SELECT DISTINCT ON (y, x) x, y FROM (select * from distinct_on_tbl order by x, z, y) s ORDER BY y, x, z;
SELECT DISTINCT ON (x, x) x, x FROM (SELECT * FROM x ORDER BY x NULLS LAST, x NULLS LAST, x NULLS LAST) AS x ORDER BY x NULLS LAST, x NULLS LAST, x NULLS LAST;
RESET enable_hashagg;
DROP TABLE x;
/* SELECT_HAVING */ /* load test data */ CREATE TABLE x (x INT, x INT, x CHAR(8), x CHAR);
INSERT INTO x VALUES (0, 1, 'XXXX', 'A');
INSERT INTO x VALUES (1, 2, 'AAAA', 'b');
INSERT INTO x VALUES (2, 2, 'AAAA', 'c');
INSERT INTO x VALUES (3, 3, 'BBBB', 'D');
INSERT INTO x VALUES (4, 3, 'BBBB', 'e');
INSERT INTO x VALUES (5, 3, 'bbbb', 'F');
INSERT INTO x VALUES (6, 4, 'cccc', 'g');
INSERT INTO x VALUES (7, 4, 'cccc', 'h');
INSERT INTO x VALUES (8, 4, 'CCCC', 'I');
INSERT INTO x VALUES (9, 4, 'CCCC', 'j');
SELECT x, x FROM x GROUP BY x, x HAVING COUNT(*) = 1 ORDER BY x NULLS LAST, x NULLS LAST;
/* HAVING is effectively equivalent to WHERE in this case */ SELECT x, x FROM x GROUP BY x, x HAVING x = 3 ORDER BY x NULLS LAST, x NULLS LAST;
SELECT LOWER(x), COUNT(x) FROM x GROUP BY LOWER(x) HAVING COUNT(*) > 2 OR MIN(x) = MAX(x) ORDER BY LOWER(x) NULLS LAST;
SELECT x, MAX(x) FROM x GROUP BY x HAVING COUNT(*) > 2 OR MIN(x) = MAX(x) ORDER BY x NULLS LAST;
/* test degenerate cases involving HAVING without GROUP BY */ /* Per SQL spec, these should generate 0 or 1 row, even without aggregates */ SELECT MIN(x), MAX(x) FROM x HAVING MIN(x) = MAX(x);
SELECT MIN(x), MAX(x) FROM x HAVING MIN(x) < MAX(x);
/* errors: ungrouped column references */ SELECT x FROM x HAVING MIN(x) < MAX(x);
SELECT 1 AS x FROM x HAVING x > 1;
/* the really degenerate case: need not scan table at all */ SELECT 1 AS x FROM x HAVING 1 > 2;
SELECT 1 AS x FROM x HAVING 1 < 2;
/* and just to prove that we aren't scanning the table: */ SELECT 1 AS x FROM x WHERE 1 / x = 1 HAVING 1 < 2;
DROP TABLE x;
/* SELECT_IMPLICIT */ /* Test cases for queries with ordering terms missing from the target list. */ /* This used to be called "junkfilter.sql". */ /* The parser uses the term "resjunk" to handle these cases. */ /* - thomas 1998-07-09 */ /* load test data */ CREATE TABLE x (x INT, x INT, x CHAR(8), x CHAR);
INSERT INTO x VALUES (0, 1, 'XXXX', 'A');
INSERT INTO x VALUES (1, 2, 'ABAB', 'b');
INSERT INTO x VALUES (2, 2, 'ABAB', 'c');
INSERT INTO x VALUES (3, 3, 'BBBB', 'D');
INSERT INTO x VALUES (4, 3, 'BBBB', 'e');
INSERT INTO x VALUES (5, 3, 'bbbb', 'F');
INSERT INTO x VALUES (6, 4, 'cccc', 'g');
INSERT INTO x VALUES (7, 4, 'cccc', 'h');
INSERT INTO x VALUES (8, 4, 'CCCC', 'I');
INSERT INTO x VALUES (9, 4, 'CCCC', 'j');
/*   w/ existing GROUP BY target */ SELECT x, COUNT(*) FROM x GROUP BY x.x ORDER BY x NULLS LAST;
/*   w/o existing GROUP BY target using a relation name in GROUP BY clause */ SELECT COUNT(*) FROM x GROUP BY x.x ORDER BY x NULLS LAST;
/*   w/o existing GROUP BY target and w/o existing a different ORDER BY target */ /*   failure expected */ SELECT COUNT(*) FROM x GROUP BY x ORDER BY x NULLS LAST;
/*   w/o existing GROUP BY target and w/o existing same ORDER BY target */ SELECT COUNT(*) FROM x GROUP BY x ORDER BY x NULLS LAST;
/*   w/ existing GROUP BY target using a relation name in target */ SELECT x.x, COUNT(*) FROM x GROUP BY x ORDER BY x NULLS LAST;
/*   w/o existing GROUP BY target */ SELECT x FROM x ORDER BY x NULLS LAST;
/*   w/o existing ORDER BY target */ SELECT COUNT(*) FROM x GROUP BY x ORDER BY x DESC NULLS FIRST;
/*   group using reference number */ SELECT COUNT(*) FROM x ORDER BY 1 DESC NULLS FIRST;
/*   order using reference number */ SELECT x, COUNT(*) FROM x GROUP BY 1 ORDER BY 1 NULLS LAST;
/*   group using reference number out of range */ /*   failure expected */ SELECT x, COUNT(*) FROM x GROUP BY 3;
/*   group w/o existing GROUP BY and ORDER BY target under ambiguous condition */ /*   failure expected */ SELECT COUNT(*) FROM x AS x, x AS x WHERE x.x = x.x GROUP BY x ORDER BY x NULLS LAST;
/*   order w/ target under ambiguous condition */ /*   failure NOT expected */ SELECT x, x FROM x ORDER BY x NULLS LAST;
/*   order expression w/ target under ambiguous condition */ /*   failure NOT expected */ SELECT x / 2, x / 2 FROM x ORDER BY x / 2 NULLS LAST;
/*   group expression w/ target under ambiguous condition */ /*   failure NOT expected */ SELECT x / 2, x / 2 FROM x GROUP BY x / 2 ORDER BY x / 2 NULLS LAST;
/*   group w/ existing GROUP BY target under ambiguous condition */ SELECT x.x, COUNT(*) FROM x AS x, x AS x WHERE x.x = x.x GROUP BY x.x ORDER BY x.x NULLS LAST;
/*   group w/o existing GROUP BY target under ambiguous condition */ SELECT COUNT(*) FROM x AS x, x AS x WHERE x.x = x.x GROUP BY x.x ORDER BY x.x NULLS LAST;
/*   group w/o existing GROUP BY target under ambiguous condition */ /*   into a table */ CREATE TABLE x AS SELECT COUNT(*) FROM x AS x, x AS x WHERE x.x = x.x GROUP BY x.x ORDER BY x.x NULLS LAST;
SELECT * FROM x;
/*  Functions and expressions */ /*   w/ existing GROUP BY target */ SELECT x % 2, COUNT(x) FROM x GROUP BY x.x % 2 ORDER BY x.x % 2 NULLS LAST;
/*   w/o existing GROUP BY target using a relation name in GROUP BY clause */ SELECT COUNT(x) FROM x GROUP BY LOWER(x.x) ORDER BY LOWER(x.x) NULLS LAST;
/*   w/o existing GROUP BY target and w/o existing a different ORDER BY target */ /*   failure expected */ SELECT COUNT(x) FROM x GROUP BY x ORDER BY x NULLS LAST;
/*   w/o existing GROUP BY target and w/o existing same ORDER BY target */ SELECT COUNT(x) FROM x GROUP BY x / 2 ORDER BY x / 2 NULLS LAST;
/*   w/ existing GROUP BY target using a relation name in target */ SELECT LOWER(x.x), COUNT(x) FROM x GROUP BY LOWER(x) ORDER BY LOWER(x) NULLS LAST;
/*   w/o existing GROUP BY target */ SELECT x FROM x ORDER BY UPPER(x) NULLS LAST;
/*   w/o existing ORDER BY target */ SELECT COUNT(x) FROM x GROUP BY (x + 1) / 2 ORDER BY (x + 1) / 2 DESC NULLS FIRST;
/*   group w/o existing GROUP BY and ORDER BY target under ambiguous condition */ /*   failure expected */ SELECT COUNT(x.x) FROM x AS x, x AS x WHERE x.x = x.x GROUP BY x / 2 ORDER BY x / 2 NULLS LAST;
/*   group w/ existing GROUP BY target under ambiguous condition */ SELECT x.x / 2, COUNT(x.x) FROM x AS x, x AS x WHERE x.x = x.x GROUP BY x.x / 2 ORDER BY x.x / 2 NULLS LAST;
/*   group w/o existing GROUP BY target under ambiguous condition */ /*   failure expected due to ambiguous b in count(b) */ SELECT COUNT(x) FROM x AS x, x AS x WHERE x.x = x.x GROUP BY x.x / 2;
/*   group w/o existing GROUP BY target under ambiguous condition */ /*   into a table */ CREATE TABLE x AS SELECT COUNT(x.x) FROM x AS x, x AS x WHERE x.x = x.x GROUP BY x.x / 2 ORDER BY x.x / 2 NULLS LAST;
SELECT * FROM x;
/*   Cleanup */ DROP TABLE x;
DROP TABLE x;
DROP TABLE x;
/* SELECT_INTO */ CREATE TABLE x AS SELECT * FROM x WHERE x.x < 2;
DROP TABLE x;
CREATE TABLE x AS SELECT * FROM x WHERE x.x < 2;
DROP TABLE x;
/* SELECT INTO and INSERT permission, if owner is not allowed to insert. */ CREATE SCHEMA x.x;
CREATE USER regress_selinto_user;
ALTER DEFAULT PRIVILEGES FOR ROLE regress_selinto_user 	  REVOKE INSERT ON TABLES FROM regress_selinto_user;
GRANT ALL ON SCHEMA x TO x;
SET SESSION AUTHORIZATION regress_selinto_user;
/* WITH DATA, passes. */ CREATE TABLE x.x (x) AS SELECT UNNEST(GENERATE_SERIES(1, 3)) WITH DATA;
INSERT INTO x.x VALUES (4);
EXPLAIN (ANALYZE, COSTS OFF, SUMMARY OFF, TIMING OFF, BUFFERS OFF)   CREATE TABLE selinto_schema.tbl_withdata2 (a) AS   SELECT generate_series(1,3) WITH DATA;
/* WITH NO DATA, passes. */ CREATE TABLE x.x (x) AS SELECT UNNEST(GENERATE_SERIES(1, 3)) WITH NO DATA;
EXPLAIN (ANALYZE, COSTS OFF, SUMMARY OFF, TIMING OFF, BUFFERS OFF)   CREATE TABLE selinto_schema.tbl_nodata2 (a) AS   SELECT generate_series(1,3) WITH NO DATA;
/* EXECUTE and WITH DATA, passes. */ PREPARE data_sel AS SELECT generate_series(1,3);
CREATE TABLE x.x (x) EXECUTE AS data_sel WITH DATA;
EXPLAIN (ANALYZE, COSTS OFF, SUMMARY OFF, TIMING OFF, BUFFERS OFF)   CREATE TABLE selinto_schema.tbl_withdata4 (a) AS   EXECUTE data_sel WITH DATA;
/* EXECUTE and WITH NO DATA, passes. */ CREATE TABLE x.x (x) EXECUTE AS data_sel WITH NO DATA;
EXPLAIN (ANALYZE, COSTS OFF, SUMMARY OFF, TIMING OFF, BUFFERS OFF)   CREATE TABLE selinto_schema.tbl_nodata4 (a) AS   EXECUTE data_sel WITH NO DATA;
RESET SESSION AUTHORIZATION;
ALTER DEFAULT PRIVILEGES FOR ROLE regress_selinto_user 	  GRANT INSERT ON TABLES TO regress_selinto_user;
SET SESSION AUTHORIZATION regress_selinto_user;
RESET SESSION AUTHORIZATION;
x AS x;
DROP SCHEMA x.x CASCADE;
DROP USER regress_selinto_user;
/* Tests for WITH NO DATA and column name consistency */ CREATE TABLE x (x INT, x INT);
INSERT INTO x VALUES (1, 2);
CREATE TABLE x (x, x, x) AS SELECT x, x FROM x;
/* Error */ CREATE TABLE x (x, x, x) AS SELECT x, x FROM x WITH NO DATA;
/* Error */ CREATE TABLE x (x, x) AS SELECT x, x FROM x;
/* OK */ CREATE TABLE x (x, x) AS SELECT x, x FROM x WITH NO DATA;
/* OK */ CREATE TABLE x (x) AS SELECT x, x FROM x;
/* OK */ CREATE TABLE x (x) AS SELECT x, x FROM x WITH NO DATA;
/* OK */ SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
DROP TABLE x;
DROP TABLE x;
DROP TABLE x;
DROP TABLE x;
DROP TABLE x;
SELECT MAKE_TABLE();
SELECT * FROM x;
EXECUTE 'EXPLAIN ANALYZE CREATE TABLE easi2 AS SELECT * FROM int8_tbl WITH NO DATA';
x;
DROP TABLE x;
/* Disallowed uses of SELECT ... INTO.  All should fail */ DECLARE foo CURSOR FOR SELECT 1 INTO int4_tbl;
COPY INTO (CREATE TABLE x AS SELECT 1 UNION SELECT 2) TO 'blob';
SELECT * FROM (CREATE TABLE x AS SELECT 1) AS x;
CREATE VIEW x AS CREATE TABLE x AS SELECT 1;
INSERT INTO x CREATE TABLE x AS SELECT 1;
/* Test CREATE TABLE AS ... IF NOT EXISTS */ CREATE TABLE x AS SELECT 1;
CREATE TABLE x AS SELECT 1 / 0;
/* error */ CREATE TABLE IF NOT EXISTS x AS SELECT 1 / 0;
/* ok */ CREATE TABLE x AS SELECT 1 / 0 WITH NO DATA;
/* error */ CREATE TABLE IF NOT EXISTS x AS SELECT 1 / 0 WITH NO DATA;
/* ok */ EXPLAIN (ANALYZE, COSTS OFF, SUMMARY OFF, TIMING OFF)   CREATE TABLE ctas_ine_tbl AS SELECT 1 / 0;
/* error */ EXPLAIN (ANALYZE, COSTS OFF, SUMMARY OFF, TIMING OFF)   CREATE TABLE IF NOT EXISTS ctas_ine_tbl AS SELECT 1 / 0;
/* ok */ EXPLAIN (ANALYZE, COSTS OFF, SUMMARY OFF, TIMING OFF)   CREATE TABLE ctas_ine_tbl AS SELECT 1 / 0 WITH NO DATA;
/* error */ EXPLAIN (ANALYZE, COSTS OFF, SUMMARY OFF, TIMING OFF)   CREATE TABLE IF NOT EXISTS ctas_ine_tbl AS SELECT 1 / 0 WITH NO DATA;
/* ok */ PREPARE ctas_ine_query AS SELECT 1 / 0;
EXPLAIN (ANALYZE, COSTS OFF, SUMMARY OFF, TIMING OFF)   CREATE TABLE ctas_ine_tbl AS EXECUTE ctas_ine_query;
/* error */ EXPLAIN (ANALYZE, COSTS OFF, SUMMARY OFF, TIMING OFF)   CREATE TABLE IF NOT EXISTS ctas_ine_tbl AS EXECUTE ctas_ine_query;
/* ok */ DROP TABLE x;
/* PARALLEL */ /* Save parallel worker stats, used for comparison at the end */ SELECT PG_STAT_FORCE_NEXT_FLUSH();
BEGIN;
SET x = 0 /* encourage use of parallel plans */;
SET x = 0;
SET x = 0;
SET x = 4;
/* Parallel Append with partial-subplans */ EXPLAIN (costs off)   select round(avg(aa)), sum(aa) from a_star;
SELECT ROUND(AVG(x)), SUM(x) FROM x AS x;
ALTER TABLE x SET x = 0 /* Parallel Append with both partial and non-partial subplans */;
ALTER TABLE x SET x = 0;
EXPLAIN (costs off)   select round(avg(aa)), sum(aa) from a_star;
SELECT ROUND(AVG(x)), SUM(x) FROM x AS x;
ALTER TABLE x SET x = 0 /* Parallel Append with only non-partial subplans */;
ALTER TABLE x SET x = 0;
ALTER TABLE x SET x = 0;
ALTER TABLE x SET x = 0;
EXPLAIN (costs off)   select round(avg(aa)), sum(aa) from a_star;
SELECT ROUND(AVG(x)), SUM(x) FROM x AS x;
/* Disable Parallel Append */ alter table a_star reset (parallel_workers);
alter table b_star reset (parallel_workers);
alter table c_star reset (parallel_workers);
alter table d_star reset (parallel_workers);
alter table e_star reset (parallel_workers);
alter table f_star reset (parallel_workers);
SET x = off;
EXPLAIN (costs off)   select round(avg(aa)), sum(aa) from a_star;
SELECT ROUND(AVG(x)), SUM(x) FROM x AS x;
RESET enable_parallel_append;
/* Parallel Append that runs serially */ create function sp_test_func() returns setof text as $$ select 'foo'::varchar union all select 'bar'::varchar $$ language sql stable;
SELECT SP_TEST_FUNC() ORDER BY 1 NULLS LAST;
/* Parallel Append is not to be used when the subpath depends on the outer param */ CREATE TABLE x (x INT, x INT) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (MINVALUE) TO (0);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (0) TO (MAXVALUE);
EXPLAIN (costs off) 	select (select max((select pa1.b from part_pa_test pa1 where pa1.a = pa2.a))) 	from part_pa_test pa2;
DROP TABLE x;
SET x = off /* test with leader participation disabled */;
EXPLAIN (costs off)   select count(*) from tenk1 where stringu1 = 'GRAAAA';
SELECT COUNT(*) FROM x WHERE x = 'GRAAAA';
SET x = 0 /* test with leader participation disabled, but no workers available (so */ /* the leader will have to run the plan despite the setting) */;
EXPLAIN (costs off)   select count(*) from tenk1 where stringu1 = 'GRAAAA';
SELECT COUNT(*) FROM x WHERE x = 'GRAAAA';
RESET max_parallel_workers;
RESET parallel_leader_participation;
ALTER TABLE x SET x = 4 /* test that parallel_restricted function doesn't run in worker */;
EXPLAIN (verbose, costs off) select sp_parallel_restricted(unique1) from tenk1   where stringu1 = 'GRAAAA' order by 1;
/* test parallel plan when group by expression is in target list. */ EXPLAIN (costs off) 	select length(stringu1) from tenk1 group by length(stringu1);
SELECT LENGTH(x) FROM x GROUP BY LENGTH(x);
EXPLAIN (costs off) 	select stringu1, count(*) from tenk1 group by stringu1 order by stringu1;
/* test that parallel plan for aggregates is not selected when */ /* target list contains parallel restricted clause. */ EXPLAIN (costs off) 	select  sum(sp_parallel_restricted(unique1)) from tenk1 	group by(sp_parallel_restricted(unique1));
/* test prepared statement */ PREPARE tenk1_count(integer) As select  count((unique1)) from tenk1 where hundred > $1;
EXPLAIN (costs off) execute tenk1_count(1);
EXECUTE tenk1_count(1);
x AS x;
ALTER TABLE x SET x = 0 /* test parallel plans for queries containing un-correlated subplans. */;
EXPLAIN (costs off) 	select count(*) from tenk1 where (two, four) not in 	(select hundred, thousand from tenk2 where thousand > 100);
SELECT COUNT(*) FROM x WHERE NOT (x, x) IN (SELECT x, x FROM x WHERE x > 100);
/* this is not parallel-safe due to use of random() within SubLink's testexpr: */ EXPLAIN (costs off) 	select * from tenk1 where (unique1 + random())::integer not in 	(select ten from tenk2);
alter table tenk2 reset (parallel_workers);
SET x = off /* test parallel plan for a query containing initplan. */;
SET x = off;
SET x = off;
ALTER TABLE x SET x = 2;
EXPLAIN (costs off) 	select count(*) from tenk1         where tenk1.unique1 = (Select max(tenk2.unique1) from tenk2);
SELECT COUNT(*) FROM x WHERE x.x = (SELECT MAX(x.x) FROM x);
RESET enable_indexscan;
RESET enable_indexonlyscan;
RESET enable_bitmapscan;
alter table tenk2 reset (parallel_workers);
SET x = off /* test parallel index scans. */;
SET x = off;
SET x = 2;
EXPLAIN (costs off) 	select  count((unique1)) from tenk1 where hundred > 1;
SELECT COUNT((x)) FROM x WHERE x > 1;
/* Parallel ScalarArrayOp index scan */ EXPLAIN (costs off)   select count((unique1)) from tenk1   where hundred = any ((select array_agg(i) from generate_series(1, 100, 15) i)::int[]);
SELECT COUNT((x)) FROM x WHERE x = ANY(CAST((SELECT ARRAY_AGG(x) FROM x AS x) AS ARRAY<INT>));
/* test parallel index-only scans. */ EXPLAIN (costs off) 	select  count(*) from tenk1 where thousand > 95;
SELECT COUNT(*) FROM x WHERE x > 95;
SET x = FALSE /* test rescan cases too */;
EXPLAIN (costs off) select * from   (select count(unique1) from tenk1 where hundred > 10) ss   right join (values (1),(2),(3)) v(x) on true;
SELECT * FROM (SELECT COUNT(x) FROM x WHERE x > 10) AS x RIGHT JOIN (VALUES (1), (2), (3)) AS x ON TRUE;
EXPLAIN (costs off) select * from   (select count(*) from tenk1 where thousand > 99) ss   right join (values (1),(2),(3)) v(x) on true;
SELECT * FROM (SELECT COUNT(*) FROM x WHERE x > 99) AS x RIGHT JOIN (VALUES (1), (2), (3)) AS x ON TRUE;
/* test rescans for a Limit node with a parallel node beneath it. */ RESET enable_seqscan;
SET x = off;
SET x = off;
ALTER TABLE x SET x = 0;
ALTER TABLE x SET x = 1;
EXPLAIN (costs off) select count(*) from tenk1   left join (select tenk2.unique1 from tenk2 order by 1 limit 1000) ss   on tenk1.unique1 < ss.unique1 + 1   where tenk1.unique1 < 2;
SELECT COUNT(*) FROM x LEFT JOIN (SELECT x.x FROM x ORDER BY 1 NULLS LAST LIMIT 1000) AS x ON x.x < x.x + 1 WHERE x.x < 2;
ALTER TABLE x SET x = 4 /* reset the value of workers for each table as it was before this test. */;
alter table tenk2 reset (parallel_workers);
RESET enable_material;
RESET enable_bitmapscan;
RESET enable_indexonlyscan;
RESET enable_indexscan;
SET x = off /* test parallel bitmap heap scan. */;
SET x = off;
SET x = off;
SET x = off;
SET x = off;
SET x = '64kB';
/* set small work mem to force lossy pages */ EXPLAIN (costs off) 	select count(*) from tenk1, tenk2 where tenk1.hundred > 1 and tenk2.thousand=0;
SELECT COUNT(*) FROM x, x WHERE x.x > 1 AND x.x = 0;
CREATE TABLE x (x INT, x TEXT);
INSERT INTO x SELECT x, 'fooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo' FROM x AS x;
CREATE INDEX x ON x(x NULLS LAST);
SELECT COUNT(*) FROM x WHERE x > 1;
/* test accumulation of stats for parallel nodes */ RESET enable_seqscan;
ALTER TABLE x SET x = 0;
EXPLAIN (analyze, timing off, summary off, costs off, buffers off)    select count(*) from tenk1, tenk2 where tenk1.hundred > 1         and tenk2.thousand=0;
alter table tenk2 reset (parallel_workers);
RESET work_mem;
BEGIN for ln in         explain (analyze, timing off, summary off, costs off, buffers off)           select * from           (select ten from tenk1 where ten < 100 order by ten) ss           right join (values (1),(2),(3)) v(x) on true     loop         ln := regexp_replace(ln, 'Memory: \S*',  'Memory: xxx');
COMMIT;
SELECT * FROM x;
RESET enable_indexscan;
RESET enable_hashjoin;
RESET enable_mergejoin;
RESET enable_material;
RESET effective_io_concurrency;
DROP TABLE x;
DROP FUNCTION x;
SET x = off /* test parallel merge join path. */;
SET x = off;
EXPLAIN (costs off) 	select  count(*) from tenk1, tenk2 where tenk1.unique1 = tenk2.unique1;
SELECT COUNT(*) FROM x, x WHERE x.x = x.x;
RESET enable_hashjoin;
RESET enable_nestloop;
ALTER TABLE x SET x = 0 /* test parallel nestloop join path with materialization of the inner path */;
EXPLAIN (costs off) select * from tenk1 t1, tenk2 t2 where t1.two > t2.two;
/* test that parallel nestloop join is not generated if the inner path is */ /* not parallel-safe */ EXPLAIN (costs off) select * from tenk1 t1     left join lateral       (select t1.unique1 as x, * from tenk2 t2 order by 1) t2     on true where t1.two > t2.two;
alter table tenk2 reset (parallel_workers);
SET x = FALSE /* test gather merge */;
EXPLAIN (costs off)    select count(*) from tenk1 group by twenty;
SELECT COUNT(*) FROM x GROUP BY x;
COMMIT;
EXPLAIN (costs off, verbose)     select ten, sp_simple_func(ten) from tenk1 where ten < 100 order by ten;
DROP FUNCTION x (INT);
/* test handling of SRFs in targetlist (bug in 10.0) */ EXPLAIN (costs off)    select count(*), generate_series(1,2) from tenk1 group by twenty;
SELECT COUNT(*), UNNEST(GENERATE_SERIES(1, 2)) FROM x GROUP BY x;
SET x = off /* test gather merge with parallel leader participation disabled */;
EXPLAIN (costs off)    select count(*) from tenk1 group by twenty;
SELECT COUNT(*) FROM x GROUP BY x;
RESET parallel_leader_participation;
SET x = FALSE /* test rescan behavior of gather merge */;
EXPLAIN (costs off) select * from   (select string4, count(unique2)    from tenk1 group by string4 order by string4) ss   right join (values (1),(2),(3)) v(x) on true;
SELECT * FROM (SELECT x, COUNT(x) FROM x GROUP BY x ORDER BY x NULLS LAST) AS x RIGHT JOIN (VALUES (1), (2), (3)) AS x ON TRUE;
RESET enable_material;
RESET enable_hashagg;
/* check parallelized int8 aggregate (bug #14897) */ EXPLAIN (costs off) select avg(unique1::int8) from tenk1;
SELECT AVG(CAST(x AS BIGINT)) FROM x;
/* gather merge test with a LIMIT */ EXPLAIN (costs off)   select fivethous from tenk1 order by fivethous limit 4;
SELECT x FROM x ORDER BY x NULLS LAST LIMIT 4;
SET x = 0 /* gather merge test with 0 worker */;
EXPLAIN (costs off)    select string4 from tenk1 order by string4 limit 5;
SELECT x FROM x ORDER BY x NULLS LAST LIMIT 5;
SET x = off /* gather merge test with 0 workers, with parallel leader */ /* participation disabled (the leader will have to run the plan */ /* despite the setting) */;
EXPLAIN (costs off)    select string4 from tenk1 order by string4 limit 5;
SELECT x FROM x ORDER BY x NULLS LAST LIMIT 5;
RESET parallel_leader_participation;
RESET max_parallel_workers;
COMMIT;
/* Test gather merge atop of a sort of a partial path */ EXPLAIN (costs off) select * from tenk1 where four = 2 order by four, hundred, parallel_safe_volatile(thousand);
SET x = 0 /* Test gather merge atop of an incremental sort a of partial path */;
SET x = off;
EXPLAIN (costs off) select * from tenk1 where four = 2 order by four, hundred, parallel_safe_volatile(thousand);
RESET min_parallel_index_scan_size;
RESET enable_seqscan;
/* Test GROUP BY with a gather merge path atop of a sort of a partial path */ EXPLAIN (costs off) select count(*) from tenk1 group by twenty, parallel_safe_volatile(two);
DROP FUNCTION x (INT);
x AS x;
SET LOCAL x = 1;
EXPLAIN (costs off)   select stringu1::int2 from tenk1 where unique1 = 1;
ROLLBACK TO x;
COMMIT;
x AS x;
SET LOCAL x = 1;
SELECT MAKE_RECORD(x) FROM (SELECT UNNEST(GENERATE_SERIES(1, 5)) AS x) AS x ORDER BY x NULLS LAST;
ROLLBACK TO x;
/* test the sanity of parallel query after the active role is dropped. */ drop role if exists regress_parallel_worker;
create role regress_parallel_worker;
set role regress_parallel_worker;
RESET session authorization;
drop role regress_parallel_worker;
SET x = 1;
SELECT COUNT(*) FROM x;
RESET debug_parallel_query;
RESET role;
/* Window function calculation can't be pushed to workers. */ EXPLAIN (costs off, verbose)   select count(*) from tenk1 a where (unique1, two) in     (select unique1, row_number() over() from tenk1 b);
/* LIMIT/OFFSET within sub-selects can't be pushed to workers. */ EXPLAIN (costs off)   select * from tenk1 a where two in     (select two from tenk1 b where stringu1 like '%AAAA' limit 3);
x AS x /* to increase the parallel query test coverage */;
SET LOCAL x = 1;
EXPLAIN (analyze, timing off, summary off, costs off, buffers off) SELECT * FROM tenk1;
ROLLBACK TO x;
x AS x /* provoke error in worker */ /* (make the error message long enough to require multiple bufferloads) */;
SET LOCAL x = 1;
SELECT CAST((x || REPEAT('abcd', 5000)) AS SMALLINT) FROM x WHERE x = 1;
ROLLBACK TO x;
x AS x /* test interaction with set-returning functions */;
SET LOCAL x = 10 /* multiple subqueries under a single Gather node */ /* must set parallel_setup_cost > 0 to discourage multiple Gather nodes */;
EXPLAIN (COSTS OFF) SELECT unique1 FROM tenk1 WHERE fivethous = tenthous + 1 UNION ALL SELECT unique1 FROM tenk1 WHERE fivethous = tenthous + 1;
ROLLBACK TO x;
/* can't use multiple subqueries under a single Gather node due to initPlans */ EXPLAIN (COSTS OFF) SELECT unique1 FROM tenk1 WHERE fivethous = 	(SELECT unique1 FROM tenk1 WHERE fivethous = 1 LIMIT 1) UNION ALL SELECT unique1 FROM tenk1 WHERE fivethous = 	(SELECT unique2 FROM tenk1 WHERE fivethous = 1 LIMIT 1) ORDER BY 1;
/* test interaction with SRFs */ SELECT * FROM x.x ORDER BY 1 NULLS LAST, 2 NULLS LAST, 3 NULLS LAST;
EXPLAIN (VERBOSE, COSTS OFF) SELECT generate_series(1, two), array(select generate_series(1, two))   FROM tenk1 ORDER BY tenthous;
/* must disallow pushing sort below gather when pathkey contains an SRF */ EXPLAIN (VERBOSE, COSTS OFF) SELECT unnest(ARRAY[]::integer[]) + 1 AS pathkey   FROM tenk1 t1 JOIN tenk1 t2 ON TRUE   ORDER BY pathkey;
BEGIN x[1] := $1;
x[1] := @2;
x AS x;
CREATE TABLE x (x TEXT, x ARRAY<INT>, x TEXT);
INSERT INTO x VALUES ('1', ARRAY(1, 2), 'one');
PREPARE pstmt(text, int[]) AS SELECT * FROM fooarr WHERE f1 = $1 AND f2 = $2;
EXPLAIN (COSTS OFF) EXECUTE pstmt('1', make_some_array(1,2));
EXECUTE pstmt('1', make_some_array(1,2));
x AS x;
EXPLAIN (COSTS OFF) SELECT 1 FROM tenk1_vw_sec   WHERE (SELECT sum(f1) FROM int4_tbl WHERE f1 < unique1) < 100;
ROLLBACK;
/* test that a newly-created session role propagates to workers. */ BEGIN;
create role regress_parallel_worker;
set session authorization regress_parallel_worker;
SELECT CURRENT_SETTING('session_authorization');
SET x = 1;
SELECT CURRENT_SETTING('session_authorization');
ROLLBACK;
/* test that function option SET ROLE works in parallel workers. */ create role regress_parallel_worker;
create function set_and_report_role() returns text as   $$ select current_setting('role') $$ language sql parallel safe   set role = regress_parallel_worker;
create function set_role_and_error(int) returns int as   $$ select 1 / $1 $$ language sql parallel safe   set role = regress_parallel_worker;
SET x = 0;
SELECT SET_AND_REPORT_ROLE();
SELECT SET_ROLE_AND_ERROR(0);
SET x = 1;
SELECT SET_AND_REPORT_ROLE();
SELECT SET_ROLE_AND_ERROR(0);
RESET debug_parallel_query;
DROP FUNCTION x;
DROP FUNCTION x (INT);
drop role regress_parallel_worker;
/* don't freeze in ParallelFinish while holding an LWLock */ BEGIN;
CREATE TABLE x (x INT);
INSERT INTO x (SELECT * FROM x AS x);
CREATE OPERATOR CLASS int4_custom_ops FOR TYPE int4 USING btree AS 	OPERATOR 1 < (int4, int4), OPERATOR 2 <= (int4, int4), 	OPERATOR 3 = (int4, int4), OPERATOR 4 >= (int4, int4), 	OPERATOR 5 > (int4, int4), FUNCTION 1 my_cmp(int4, int4);
CREATE UNIQUE INDEX x ON x USING btree(x x NULLS LAST);
SET x = on;
DELETE FROM x WHERE 380 <= x AND x <= 420;
ROLLBACK;
/* Check parallel worker stats */ SELECT PG_STAT_FORCE_NEXT_FLUSH();
/* SELECT_VIEWS */ /* test the views defined in CREATE_VIEWS */ SELECT * FROM x;
SELECT * FROM x WHERE x = 'sharon';
/* Test for Leaky view scenario */ CREATE ROLE regress_alice;
x AS x;
CREATE TABLE x (x INT PRIMARY KEY, x TEXT NOT NULL, x TEXT, x TEXT);
CREATE TABLE x (x INT REFERENCES x (x), x TEXT, x INT);
CREATE TABLE x (x INT REFERENCES x (x), x DATE, x INT);
INSERT INTO x VALUES (101, 'regress_alice', '+81-12-3456-7890', 'passwd123'), (102, 'regress_bob', '+01-234-567-8901', 'beafsteak'), (103, 'regress_eve', '+49-8765-43210', 'hamburger');
INSERT INTO x VALUES (101, '1111-2222-3333-4444', 4000), (102, '5555-6666-7777-8888', 3000), (103, '9801-2345-6789-0123', 2000);
INSERT INTO x VALUES (101, '2011-09-15', 120), (101, '2011-10-05', 90), (101, '2011-10-18', 110), (101, '2011-10-21', 200), (101, '2011-11-10', 80), (102, '2011-09-22', 300), (102, '2011-10-12', 120), (102, '2011-10-28', 200), (103, '2011-10-15', 480);
CREATE VIEW x AS SELECT * FROM x WHERE x = CURRENT_USER();
CREATE VIEW x AS SELECT * FROM x AS x NATURAL JOIN x AS x WHERE x.x = CURRENT_USER();
CREATE VIEW x AS SELECT * FROM x AS x NATURAL JOIN x AS x;
GRANT SELECT ON x TO x;
GRANT SELECT ON x TO x;
GRANT SELECT ON x TO x;
GRANT SELECT ON x TO x;
GRANT SELECT ON x TO x;
GRANT SELECT ON x TO x;
/* Run leaky view scenarios */ SET SESSION AUTHORIZATION regress_alice;
/* scenario: if a qualifier with tiny-cost is given, it shall be launched */ /*           prior to the security policy of the view. */ SELECT * FROM x WHERE F_LEAK(x);
EXPLAIN (COSTS OFF) SELECT * FROM my_property_normal WHERE f_leak(passwd);
SELECT * FROM x WHERE F_LEAK(x);
EXPLAIN (COSTS OFF) SELECT * FROM my_property_secure WHERE f_leak(passwd);
/* scenario: qualifiers can be pushed down if they contain leaky functions, */ /*           provided they aren't passed data from inside the view. */ SELECT * FROM x AS x WHERE F_LEAK('passwd') AND F_LEAK(x);
EXPLAIN (COSTS OFF) SELECT * FROM my_property_normal v 		WHERE f_leak('passwd') AND f_leak(passwd);
SELECT * FROM x AS x WHERE F_LEAK('passwd') AND F_LEAK(x);
EXPLAIN (COSTS OFF) SELECT * FROM my_property_secure v 		WHERE f_leak('passwd') AND f_leak(passwd);
/* scenario: if a qualifier references only one-side of a particular join- */ /*           tree, it shall be distributed to the most deep scan plan as */ /*           possible as we can. */ SELECT * FROM x WHERE F_LEAK(x);
EXPLAIN (COSTS OFF) SELECT * FROM my_credit_card_normal WHERE f_leak(cnum);
SELECT * FROM x WHERE F_LEAK(x);
EXPLAIN (COSTS OFF) SELECT * FROM my_credit_card_secure WHERE f_leak(cnum);
/* scenario: an external qualifier can be pushed-down by in-front-of the */ /*           views with "security_barrier" attribute, except for operators */ /*           implemented with leakproof functions. */ SELECT * FROM x WHERE F_LEAK(x) AND x >= '2011-10-01' AND x < '2011-11-01';
EXPLAIN (COSTS OFF) SELECT * FROM my_credit_card_usage_normal        WHERE f_leak(cnum) AND ymd >= '2011-10-01' AND ymd < '2011-11-01';
SELECT * FROM x WHERE F_LEAK(x) AND x >= '2011-10-01' AND x < '2011-11-01';
EXPLAIN (COSTS OFF) SELECT * FROM my_credit_card_usage_secure        WHERE f_leak(cnum) AND ymd >= '2011-10-01' AND ymd < '2011-11-01';
/* Test for the case when security_barrier gets changed between rewriter */ /* and planner stage. */ PREPARE p1 AS SELECT * FROM my_property_normal WHERE f_leak(passwd);
PREPARE p2 AS SELECT * FROM my_property_secure WHERE f_leak(passwd);
EXECUTE p1;
EXECUTE p2;
RESET SESSION AUTHORIZATION;
ALTER VIEW x SET x = TRUE;
ALTER VIEW x SET x = FALSE;
SET SESSION AUTHORIZATION regress_alice;
EXECUTE p1;
/* To be perform as a view with security-barrier */ EXECUTE p2;
/* To be perform as a view without security-barrier */ /* Cleanup. */ RESET SESSION AUTHORIZATION;
DROP ROLE regress_alice;
/* CREATE SEQUENCE */ /* various error cases */ CREATE SEQUENCE x INCREMENT BY 0;
CREATE SEQUENCE x INCREMENT BY -1 MINVALUE 20;
CREATE SEQUENCE x INCREMENT BY 1 MAXVALUE -20;
CREATE SEQUENCE x START WITH 10 INCREMENT BY -1;
CREATE SEQUENCE x START WITH -10 INCREMENT BY 1;
CREATE SEQUENCE x CACHE 0;
/* OWNED BY errors */ CREATE SEQUENCE x OWNED BY x;
/* nonsense word */ CREATE SEQUENCE x OWNED BY x.x;
/* not a table */ CREATE SEQUENCE x OWNED BY x.x;
/* not same schema */ CREATE TABLE x (x INT);
CREATE SEQUENCE x OWNED BY x.x;
/* wrong column */ DROP TABLE x;
/* sequence data types */ CREATE SEQUENCE x AS INT;
CREATE SEQUENCE x AS SMALLINT;
CREATE SEQUENCE x AS BIGINT;
CREATE SEQUENCE x AS INT MAXVALUE 100000;
CREATE SEQUENCE x AS INT INCREMENT BY -1;
CREATE SEQUENCE x AS INT START WITH 1 MINVALUE -100000;
CREATE SEQUENCE x AS SMALLINT;
CREATE SEQUENCE x AS SMALLINT INCREMENT BY -1;
CREATE SEQUENCE x AS SMALLINT MINVALUE -32768;
CREATE SEQUENCE x AS SMALLINT INCREMENT BY -1 MAXVALUE 32767;
CREATE SEQUENCE x AS TEXT;
CREATE SEQUENCE x AS nosuchtype;
CREATE SEQUENCE x AS SMALLINT MAXVALUE 100000;
CREATE SEQUENCE x AS SMALLINT MINVALUE -100000;
ALTER SEQUENCE sequence_test5 AS smallint;
/* success, max will be adjusted */ ALTER SEQUENCE sequence_test8 AS smallint;
/* fail, max has to be adjusted */ ALTER SEQUENCE sequence_test8 AS smallint MAXVALUE 20000;
/* ok now */ ALTER SEQUENCE sequence_test9 AS smallint;
/* success, min will be adjusted */ ALTER SEQUENCE sequence_test10 AS smallint;
/* fail, min has to be adjusted */ ALTER SEQUENCE sequence_test10 AS smallint MINVALUE -20000;
/* ok now */ ALTER SEQUENCE sequence_test11 AS int;
/* max will be adjusted */ ALTER SEQUENCE sequence_test12 AS int;
/* min will be adjusted */ ALTER SEQUENCE sequence_test13 AS int;
/* min and max will be adjusted */ ALTER SEQUENCE sequence_test14 AS int;
/* min and max will be adjusted */ /* - */ /* - test creation of SERIAL column */ /* - */ CREATE TABLE x (x TEXT, x SERIAL);
INSERT INTO x VALUES ('foo');
INSERT INTO x VALUES ('bar');
INSERT INTO x VALUES ('force', 100);
INSERT INTO x VALUES ('wrong', NULL);
SELECT * FROM x;
SELECT PG_GET_SERIAL_SEQUENCE('serialTest1', 'f2');
/* test smallserial / bigserial */ CREATE TABLE x (x TEXT, x SERIAL, x SMALLSERIAL, x serial2, x BIGSERIAL, x serial8);
INSERT INTO x (x) VALUES ('test_defaults');
INSERT INTO x (x, x, x, x, x, x) VALUES ('test_max_vals', 2147483647, 32767, 32767, 9223372036854775807, 9223372036854775807), ('test_min_vals', -2147483648, -32768, -32768, -9223372036854775808, -9223372036854775808);
/* All these INSERTs should fail: */ INSERT INTO x (x, x) VALUES ('bogus', -32769);
INSERT INTO x (x, x) VALUES ('bogus', -32769);
INSERT INTO x (x, x) VALUES ('bogus', 32768);
INSERT INTO x (x, x) VALUES ('bogus', 32768);
INSERT INTO x (x, x) VALUES ('bogus', -9223372036854775809);
INSERT INTO x (x, x) VALUES ('bogus', -9223372036854775809);
INSERT INTO x (x, x) VALUES ('bogus', 9223372036854775808);
INSERT INTO x (x, x) VALUES ('bogus', 9223372036854775808);
SELECT * FROM x ORDER BY x ASC NULLS LAST;
SELECT NEXTVAL('serialTest2_f2_seq');
SELECT NEXTVAL('serialTest2_f3_seq');
SELECT NEXTVAL('serialTest2_f4_seq');
SELECT NEXTVAL('serialTest2_f5_seq');
SELECT NEXTVAL('serialTest2_f6_seq');
/* basic sequence operations using both text and oid references */ CREATE SEQUENCE x;
CREATE SEQUENCE IF NOT EXISTS x;
SELECT NEXTVAL(CAST('sequence_test' AS TEXT));
SELECT NEXTVAL(CAST('sequence_test' AS REGCLASS));
SELECT CURRVAL(CAST('sequence_test' AS TEXT));
SELECT CURRVAL(CAST('sequence_test' AS REGCLASS));
SELECT SETVAL(CAST('sequence_test' AS TEXT), 32);
SELECT NEXTVAL(CAST('sequence_test' AS REGCLASS));
SELECT SETVAL(CAST('sequence_test' AS TEXT), 99, FALSE);
SELECT NEXTVAL(CAST('sequence_test' AS REGCLASS));
SELECT SETVAL(CAST('sequence_test' AS REGCLASS), 32);
SELECT NEXTVAL(CAST('sequence_test' AS TEXT));
SELECT SETVAL(CAST('sequence_test' AS REGCLASS), 99, FALSE);
SELECT NEXTVAL(CAST('sequence_test' AS TEXT));
x AS x;
SELECT CURRVAL(CAST('sequence_test' AS REGCLASS));
DROP SEQUENCE x;
/* renaming sequences */ CREATE SEQUENCE x;
ALTER TABLE x RENAME TO x;
SELECT * FROM x;
SELECT NEXTVAL('foo_seq_new');
SELECT NEXTVAL('foo_seq_new');
/* log_cnt can be higher if there is a checkpoint just at the right */ /* time, so just test for the expected range */ SELECT x, x IN (31, 32) AS x, x FROM x;
DROP SEQUENCE x;
ALTER TABLE x RENAME TO x /* renaming serial sequences */;
INSERT INTO x VALUES ('more');
SELECT * FROM x;
/* Check dependencies of serial and ordinary sequences */ CREATE TEMPORARY SEQUENCE x;
CREATE TEMPORARY SEQUENCE x;
CREATE TEMPORARY TABLE x (x SERIAL, x INT DEFAULT NEXTVAL('myseq2'), x INT DEFAULT NEXTVAL(CAST('myseq3' AS TEXT)));
/* Both drops should fail, but with different error messages: */ DROP SEQUENCE x;
DROP SEQUENCE x;
/* This however will work: */ DROP SEQUENCE x;
DROP TABLE x;
/* Fails because no longer existent: */ DROP SEQUENCE x;
/* Now OK: */ DROP SEQUENCE x;
/* Alter sequence */ ALTER SEQUENCE IF EXISTS sequence_test2 RESTART WITH 24   INCREMENT BY 4 MAXVALUE 36 MINVALUE 5 CYCLE;
ALTER SEQUENCE serialTest1 CYCLE;
/* error, not a sequence */ CREATE SEQUENCE x START WITH 32;
CREATE SEQUENCE x INCREMENT BY -1;
SELECT NEXTVAL('sequence_test2');
SELECT NEXTVAL('sequence_test4');
ALTER SEQUENCE sequence_test2 RESTART;
SELECT NEXTVAL('sequence_test2');
ALTER SEQUENCE sequence_test2 RESTART WITH 0;
/* error */ ALTER SEQUENCE sequence_test4 RESTART WITH 40;
/* error */ /* test CYCLE and NO CYCLE */ ALTER SEQUENCE sequence_test2 RESTART WITH 24   INCREMENT BY 4 MAXVALUE 36 MINVALUE 5 CYCLE;
SELECT NEXTVAL('sequence_test2');
SELECT NEXTVAL('sequence_test2');
SELECT NEXTVAL('sequence_test2');
SELECT NEXTVAL('sequence_test2');
SELECT NEXTVAL('sequence_test2');
/* cycled */ ALTER SEQUENCE sequence_test2 RESTART WITH 24   NO CYCLE;
SELECT NEXTVAL('sequence_test2');
SELECT NEXTVAL('sequence_test2');
SELECT NEXTVAL('sequence_test2');
SELECT NEXTVAL('sequence_test2');
SELECT NEXTVAL('sequence_test2');
/* error */ ALTER SEQUENCE sequence_test2 RESTART WITH -24 START WITH -24   INCREMENT BY -4 MINVALUE -36 MAXVALUE -5 CYCLE;
SELECT NEXTVAL('sequence_test2');
SELECT NEXTVAL('sequence_test2');
SELECT NEXTVAL('sequence_test2');
SELECT NEXTVAL('sequence_test2');
SELECT NEXTVAL('sequence_test2');
/* cycled */ ALTER SEQUENCE sequence_test2 RESTART WITH -24   NO CYCLE;
SELECT NEXTVAL('sequence_test2');
SELECT NEXTVAL('sequence_test2');
SELECT NEXTVAL('sequence_test2');
SELECT NEXTVAL('sequence_test2');
SELECT NEXTVAL('sequence_test2');
/* error */ /* reset */ ALTER SEQUENCE IF EXISTS sequence_test2 RESTART WITH 32 START WITH 32   INCREMENT BY 4 MAXVALUE 36 MINVALUE 5 CYCLE;
SELECT SETVAL('sequence_test2', -100);
/* error */ SELECT SETVAL('sequence_test2', 100);
/* error */ SELECT SETVAL('sequence_test2', 5);
CREATE SEQUENCE x;
/* not read from, to test is_called */ /* Information schema */ SELECT * FROM x.x WHERE REGEXP_LIKE(x, ANY(ARRAY('sequence_test', 'serialtest'))) ORDER BY x ASC NULLS LAST;
SELECT x, x, x, x, x, x, x, x, x FROM x WHERE REGEXP_LIKE(x, ANY(ARRAY('sequence_test', 'serialtest'))) ORDER BY x ASC NULLS LAST;
SELECT * FROM x;
COMMENT ON SEQUENCE x IS 'will work';
/* Test lastval() */ CREATE SEQUENCE x;
SELECT NEXTVAL('seq');
SELECT LASTVAL();
SELECT SETVAL('seq', 99);
SELECT LASTVAL();
x AS x;
SELECT LASTVAL();
CREATE SEQUENCE x;
SELECT NEXTVAL('seq2');
SELECT LASTVAL();
DROP SEQUENCE x;
/* should fail */ SELECT LASTVAL();
/* unlogged sequences */ /* (more tests in src/test/recovery/) */ CREATE UNLOGGED SEQUENCE x;
ALTER SEQUENCE sequence_test_unlogged SET LOGGED;
/* Test sequences in read-only transactions */ CREATE TEMPORARY SEQUENCE x;
SELECT NEXTVAL('sequence_test_temp1');
/* ok */ SELECT NEXTVAL('sequence_test2');
ROLLBACK /* error */ /* error */;
SELECT SETVAL('sequence_test_temp1', 1);
/* ok */ SELECT SETVAL('sequence_test2', 1);
ROLLBACK /* error */ /* error */;
/* privileges tests */ CREATE USER regress_seq_user;
/* nextval */ BEGIN;
SET LOCAL SESSION AUTHORIZATION regress_seq_user;
CREATE SEQUENCE x;
REVOKE ALL ON seq3 FROM regress_seq_user;
GRANT SELECT ON x TO x;
SELECT NEXTVAL('seq3');
ROLLBACK;
BEGIN;
SET LOCAL SESSION AUTHORIZATION regress_seq_user;
CREATE SEQUENCE x;
REVOKE ALL ON seq3 FROM regress_seq_user;
GRANT UPDATE ON x TO x;
SELECT NEXTVAL('seq3');
ROLLBACK;
BEGIN;
SET LOCAL SESSION AUTHORIZATION regress_seq_user;
CREATE SEQUENCE x;
REVOKE ALL ON seq3 FROM regress_seq_user;
GRANT USAGE ON x TO x;
SELECT NEXTVAL('seq3');
ROLLBACK;
/* currval */ BEGIN;
SET LOCAL SESSION AUTHORIZATION regress_seq_user;
CREATE SEQUENCE x;
SELECT NEXTVAL('seq3');
REVOKE ALL ON seq3 FROM regress_seq_user;
GRANT SELECT ON x TO x;
SELECT CURRVAL('seq3');
ROLLBACK;
BEGIN;
SET LOCAL SESSION AUTHORIZATION regress_seq_user;
CREATE SEQUENCE x;
SELECT NEXTVAL('seq3');
REVOKE ALL ON seq3 FROM regress_seq_user;
GRANT UPDATE ON x TO x;
SELECT CURRVAL('seq3');
ROLLBACK;
BEGIN;
SET LOCAL SESSION AUTHORIZATION regress_seq_user;
CREATE SEQUENCE x;
SELECT NEXTVAL('seq3');
REVOKE ALL ON seq3 FROM regress_seq_user;
GRANT USAGE ON x TO x;
SELECT CURRVAL('seq3');
ROLLBACK;
/* lastval */ BEGIN;
SET LOCAL SESSION AUTHORIZATION regress_seq_user;
CREATE SEQUENCE x;
SELECT NEXTVAL('seq3');
REVOKE ALL ON seq3 FROM regress_seq_user;
GRANT SELECT ON x TO x;
SELECT LASTVAL();
ROLLBACK;
BEGIN;
SET LOCAL SESSION AUTHORIZATION regress_seq_user;
CREATE SEQUENCE x;
SELECT NEXTVAL('seq3');
REVOKE ALL ON seq3 FROM regress_seq_user;
GRANT UPDATE ON x TO x;
SELECT LASTVAL();
ROLLBACK;
BEGIN;
SET LOCAL SESSION AUTHORIZATION regress_seq_user;
CREATE SEQUENCE x;
SELECT NEXTVAL('seq3');
REVOKE ALL ON seq3 FROM regress_seq_user;
GRANT USAGE ON x TO x;
SELECT LASTVAL();
ROLLBACK;
/* setval */ BEGIN;
SET LOCAL SESSION AUTHORIZATION regress_seq_user;
CREATE SEQUENCE x;
REVOKE ALL ON seq3 FROM regress_seq_user;
x AS x;
SELECT SETVAL('seq3', 5);
ROLLBACK TO x;
GRANT UPDATE ON x TO x;
SELECT SETVAL('seq3', 5);
SELECT NEXTVAL('seq3');
ROLLBACK;
/* ALTER SEQUENCE */ BEGIN;
SET LOCAL SESSION AUTHORIZATION regress_seq_user;
ALTER SEQUENCE sequence_test2 START WITH 1;
ROLLBACK;
/* Make sure sequences are gone: */ SELECT * FROM x.x WHERE x IN ('sequence_test2', 'serialtest2_f2_seq', 'serialtest2_f3_seq', 'serialtest2_f4_seq', 'serialtest2_f5_seq', 'serialtest2_f6_seq') ORDER BY x ASC NULLS LAST;
DROP USER regress_seq_user;
DROP SEQUENCE x;
/* cache tests */ CREATE SEQUENCE x CACHE 10;
SELECT NEXTVAL('test_seq1');
SELECT NEXTVAL('test_seq1');
SELECT NEXTVAL('test_seq1');
/* pg_get_sequence_data */ SELECT * FROM x;
DROP SEQUENCE x;
/* Test SP-GiST indexes. */ /* There are other tests to test different SP-GiST opclasses. This is for */ /* testing SP-GiST code itself. */ CREATE TABLE x (x INT, x point);
CREATE INDEX x ON x USING spgist(x NULLS LAST) WITH (fillfactor=75);
/* Test vacuum-root operation. It gets invoked when the root is also a leaf, */ /* i.e. the index is very small. */ INSERT INTO x (x, x) SELECT x, POINT(x * 10, x * 10) FROM x AS x;
DELETE FROM x WHERE x < 5;
VACUUM spgist_point_tbl;
/* Insert more data, to make the index a few levels deep. */ INSERT INTO x (x, x) SELECT x, POINT(x * 10, x * 10) FROM x AS x;
INSERT INTO x (x, x) SELECT x + 100000, POINT(x * 10 + 1, x * 10 + 1) FROM x AS x;
/* To test vacuum, delete some entries from all over the index. */ DELETE FROM x WHERE x % 2 = 1;
/* And also delete some concentration of values. (SP-GiST doesn't currently */ /* attempt to delete pages even when they become empty, but if it did, this */ /* would exercise it) */ DELETE FROM x WHERE x < 10000;
VACUUM spgist_point_tbl;
/* Test rescan paths (cf. bug #15378) */ /* use box and && rather than point, so that rescan happens when the */ /* traverse stack is non-empty */ CREATE TABLE x (x SERIAL, x box);
INSERT INTO x (x) SELECT BOX(POINT(x, x), POINT(x + x, x + x)) FROM x AS x, x AS x, x AS x;
CREATE INDEX x ON x USING spgist(x NULLS LAST);
SELECT COUNT(*) FROM (VALUES (POINT(5, 5)), (POINT(8, 8)), (POINT(12, 12))) AS x WHERE EXISTS(SELECT * FROM x AS x WHERE x.x && BOX(x.x, x.x));
/* The point opclass's choose method only uses the spgMatchNode action, */ /* so the other actions are not tested by the above. Create an index using */ /* text opclass, which uses the others actions. */ CREATE TABLE x (x INT, x TEXT);
CREATE INDEX x ON x USING spgist(x NULLS LAST);
INSERT INTO x (x, x) SELECT x, 'f' || REPEAT('o', 100) || x FROM x AS x UNION ALL SELECT x, 'baaaaaaaaaaaaaar' || x FROM x AS x;
/* Do a lot of insertions that have to split an existing node. Hopefully */ /* one of these will cause the page to run out of space, causing the inner */ /* tuple to be moved to another page. */ INSERT INTO x (x, x) SELECT -x, 'f' || REPEAT('o', 100 - x) || 'surprise' FROM x AS x;
/* Test out-of-range fillfactor values */ CREATE INDEX x ON x USING spgist(x NULLS LAST) WITH (fillfactor=9);
CREATE INDEX x ON x USING spgist(x NULLS LAST) WITH (fillfactor=101);
ALTER INDEX x SET x = 90 /* Modify fillfactor in existing index */;
REINDEX index spgist_point_idx;
/* Test index over a domain */ create domain spgist_text as varchar;
CREATE TABLE x (x spgist_text);
CREATE INDEX x ON x USING spgist(x NULLS LAST);
INSERT INTO x VALUES ('fee'), ('fi'), ('fo'), ('fum');
EXPLAIN (costs off) select * from spgist_domain_tbl where f1 = 'fo';
SELECT * FROM x WHERE x = 'fo';
/* test an unlogged table, mostly to get coverage of spgistbuildempty */ CREATE UNLOGGED TABLE x (x SERIAL, x box);
CREATE INDEX x ON x USING spgist(x NULLS LAST);
INSERT INTO x (x) SELECT BOX(POINT(x, x)) FROM x AS x, x AS x;
/* JSON() */ SELECT JSON();
SELECT JSON(NULL);
SELECT JSON('{ "a" : 1 } ');
SELECT PG_TYPEOF(JSON('{ "a" : 1 } '));
SELECT JSON(CAST('   1   ' AS JSON));
SELECT JSON(CAST('   1   ' AS JSONB));
SELECT JSON(123);
SELECT JSON('{"a": 1, "a": 2}');
EXPLAIN (VERBOSE, COSTS OFF) SELECT JSON('123');
EXPLAIN (VERBOSE, COSTS OFF) SELECT JSON('123' FORMAT JSON);
EXPLAIN (VERBOSE, COSTS OFF) SELECT JSON('123'::bytea FORMAT JSON);
EXPLAIN (VERBOSE, COSTS OFF) SELECT JSON('123'::bytea FORMAT JSON ENCODING UTF8);
EXPLAIN (VERBOSE, COSTS OFF) SELECT JSON('123' WITH UNIQUE KEYS);
EXPLAIN (VERBOSE, COSTS OFF) SELECT JSON('123' WITHOUT UNIQUE KEYS);
EXPLAIN (VERBOSE, COSTS OFF) SELECT JSON('123');
SELECT PG_TYPEOF(JSON('123'));
/* JSON_SCALAR() */ SELECT JSON_SCALAR();
SELECT JSON_SCALAR(NULL);
SELECT JSON_SCALAR(CAST(NULL AS INT));
SELECT JSON_SCALAR(123);
SELECT JSON_SCALAR(123.45);
SELECT JSON_SCALAR(CAST(123.45 AS DECIMAL));
SELECT JSON_SCALAR(TRUE);
SELECT JSON_SCALAR(FALSE);
SELECT JSON_SCALAR(' 123.45');
SELECT JSON_SCALAR(CAST('2020-06-07' AS DATE));
SELECT JSON_SCALAR(CAST('2020-06-07 01:02:03' AS TIMESTAMP));
SELECT JSON_SCALAR(CAST('{}' AS JSON));
SELECT JSON_SCALAR(CAST('{}' AS JSONB));
EXPLAIN (VERBOSE, COSTS OFF) SELECT JSON_SCALAR(123);
EXPLAIN (VERBOSE, COSTS OFF) SELECT JSON_SCALAR('123');
/* JSON_SERIALIZE() */ SELECT JSON_SERIALIZE();
SELECT JSON_SERIALIZE(NULL);
SELECT JSON_SERIALIZE(JSON('{ "a" : 1 } '));
SELECT JSON_SERIALIZE('{ "a" : 1 } ');
SELECT JSON_SERIALIZE('1');
SELECT PG_TYPEOF(JSON_SERIALIZE(NULL));
EXPLAIN (VERBOSE, COSTS OFF) SELECT JSON_SERIALIZE('{}');
EXPLAIN (VERBOSE, COSTS OFF) SELECT JSON_SERIALIZE('{}' RETURNING bytea);
/* JSON_OBJECT() */ SELECT JSON_OBJECT();
SELECT JSON_OBJECT( RETURNING x);
SELECT JSON_OBJECT( RETURNING x FORMAT JSON);
SELECT JSON_OBJECT( RETURNING x);
SELECT JSON_OBJECT( RETURNING x FORMAT JSON);
SELECT JSON_OBJECT( RETURNING x);
SELECT JSON_OBJECT( RETURNING x FORMAT JSON);
SELECT JSON_OBJECT( RETURNING x FORMAT JSON ENCODING UTF8);
SELECT JSON_OBJECT( RETURNING x FORMAT JSON ENCODING INVALID_ENCODING);
SELECT JSON_OBJECT( RETURNING x);
SELECT JSON_OBJECT( RETURNING x FORMAT JSON);
SELECT JSON_OBJECT( RETURNING x FORMAT JSON ENCODING UTF8);
SELECT JSON_OBJECT( RETURNING x FORMAT JSON ENCODING UTF16);
SELECT JSON_OBJECT( RETURNING x FORMAT JSON ENCODING UTF32);
SELECT JSON_OBJECT('foo': CAST(NULL AS INT) FORMAT JSON);
SELECT JSON_OBJECT('foo': CAST(NULL AS INT) FORMAT JSON ENCODING UTF8);
SELECT JSON_OBJECT('foo': CAST(NULL AS JSON) FORMAT JSON);
SELECT JSON_OBJECT('foo': CAST(NULL AS JSON) FORMAT JSON ENCODING UTF8);
SELECT JSON_OBJECT('foo': CAST(NULL AS JSONB) FORMAT JSON);
SELECT JSON_OBJECT('foo': CAST(NULL AS JSONB) FORMAT JSON ENCODING UTF8);
SELECT JSON_OBJECT(NULL: 1);
SELECT JSON_OBJECT('a': 2 + 3);
SELECT JSON_OBJECT('a': 2 + 3);
SELECT JSON_OBJECT(('a' || 2): 1);
SELECT JSON_OBJECT('a': CAST(2 AS TEXT));
SELECT JSON_OBJECT('a': CAST(2 AS TEXT));
SELECT JSON_OBJECT(CAST(1 AS TEXT): 2);
SELECT JSON_OBJECT((CAST(1 AS TEXT)): 2);
SELECT JSON_OBJECT(ARRAY(1, 2, 3): 'aaa');
SELECT JSON_OBJECT('a': '123', 1.23: 123, 'c': PARSE_JSON('[ 1,true,{ } ]'), 'd': CAST('{ "x" : 123.45 }' AS JSONB));
SELECT JSON_OBJECT('a': '123', 1.23: 123, 'c': PARSE_JSON('[ 1,true,{ } ]'), 'd': CAST('{ "x" : 123.45 }' AS JSONB) RETURNING x);
SELECT JSON_OBJECT('a': '123', 'b': JSON_OBJECT('a': 111, 'b': 'aaa' RETURNING x));
SELECT JSON_OBJECT('a': JSON_OBJECT('b': 1 RETURNING x));
SELECT JSON_OBJECT('a': JSON_OBJECT('b': 1 RETURNING x) FORMAT JSON);
SELECT JSON_OBJECT('a': JSON_OBJECT('b': 1 RETURNING x));
SELECT JSON_OBJECT('a': JSON_OBJECT('b': 1 RETURNING x) FORMAT JSON);
SELECT JSON_OBJECT('a': '1', 'b': NULL, 'c': 2);
SELECT JSON_OBJECT('a': '1', 'b': NULL, 'c': 2 NULL ON NULL);
SELECT JSON_OBJECT('a': '1', 'b': NULL, 'c': 2 ABSENT ON NULL);
SELECT JSON_OBJECT(1: 1, '2': NULL, '3': 1, REPEAT('x', 1000): 1, 2: REPEAT('a', 100) WITH UNIQUE KEYS);
SELECT JSON_OBJECT(1: 1, '1': NULL WITH UNIQUE KEYS);
SELECT JSON_OBJECT(1: 1, '1': NULL ABSENT ON NULL WITH UNIQUE KEYS);
SELECT JSON_OBJECT(1: 1, '1': NULL NULL ON NULL WITH UNIQUE KEYS RETURNING x);
SELECT JSON_OBJECT(1: 1, '1': NULL ABSENT ON NULL WITH UNIQUE KEYS RETURNING x);
SELECT JSON_OBJECT(1: 1, '2': NULL, '1': 1 NULL ON NULL WITH UNIQUE KEYS);
SELECT JSON_OBJECT(1: 1, '2': NULL, '1': 1 ABSENT ON NULL WITH UNIQUE KEYS);
SELECT JSON_OBJECT(1: 1, '2': NULL, '1': 1 ABSENT ON NULL WITHOUT UNIQUE KEYS);
SELECT JSON_OBJECT(1: 1, '2': NULL, '1': 1 ABSENT ON NULL WITH UNIQUE KEYS RETURNING x);
SELECT JSON_OBJECT(1: 1, '2': NULL, '1': 1 ABSENT ON NULL WITHOUT UNIQUE KEYS RETURNING x);
SELECT JSON_OBJECT(1: 1, '2': NULL, '3': 1, 4: NULL, '5': 'a' ABSENT ON NULL WITH UNIQUE KEYS RETURNING x);
/* BUG: https://postgr.es/m/CADXhmgTJtJZK9A3Na_ry%2BXrq-ghjcejBRhcRMzWZvbd__QdgJA%40mail.gmail.com */ /* datum_to_jsonb_internal() didn't catch keys that are casts instead of a simple scalar */ CREATE TYPE mood AS ENUM ('happy', 'sad', 'neutral');
CREATE CAST (mood AS json) WITH FUNCTION mood_to_json(mood) AS IMPLICIT;
SELECT JSON_OBJECT(CAST('happy' AS mood): CAST('123' AS JSONB));
DROP CAST (mood AS json);
DROP FUNCTION x;
DROP TYPE mood;
/* JSON_ARRAY() */ SELECT JSON_ARRAY();
SELECT JSON_ARRAY('aaa', 111, TRUE, ARRAY(1, 2, 3), NULL, PARSE_JSON('{"a": [1]}'), CAST('["a",3]' AS JSONB));
SELECT JSON_ARRAY(SELECT x FROM (VALUES (1), (2), (NULL), (4)) AS x);
SELECT JSON_ARRAY(SELECT x FROM (VALUES (CAST(NULL AS ARRAY<INT>)), ('{1,2}'), (NULL), (NULL), ('{3,4}'), (NULL)) AS x);
SELECT JSON_ARRAY(SELECT x FROM (VALUES (3), (1), (NULL), (2)) AS x ORDER BY x NULLS LAST);
/* Should fail */ SELECT JSON_ARRAY(SELECT FROM (VALUES (1)) AS x);
SELECT JSON_ARRAY(SELECT x, x FROM (VALUES (1)) AS x);
SELECT JSON_ARRAY(SELECT * FROM (VALUES (1, 2)) AS x);
SELECT JSON_ARRAYAGG(x ORDER BY x DESC NULLS FIRST) FROM x AS x;
SELECT JSON_ARRAYAGG(CAST(CAST(x AS TEXT) AS JSON)) FROM x AS x;
/* JSON_OBJECTAGG() */ SELECT JSON_OBJECTAGG('key': 1) IS NULL, JSON_OBJECTAGG('key': 1 RETURNING x) IS NULL WHERE FALSE;
SELECT JSON_OBJECTAGG(NULL: 1);
SELECT JSON_OBJECTAGG(NULL: 1 RETURNING x);
SELECT JSON_OBJECTAGG(x: x), JSON_OBJECTAGG(x: x RETURNING x) /*	JSON_OBJECTAGG(i VALUE i), */ /*	JSON_OBJECTAGG(KEY i VALUE i), */ FROM x AS x;
SELECT JSON_OBJECTAGG(x: x), JSON_OBJECTAGG(x: x NULL ON NULL), JSON_OBJECTAGG(x: x ABSENT ON NULL), JSON_OBJECTAGG(x: x RETURNING x), JSON_OBJECTAGG(x: x NULL ON NULL RETURNING x), JSON_OBJECTAGG(x: x ABSENT ON NULL RETURNING x) FROM (VALUES (1, 1), (1, NULL), (2, NULL), (3, 3)) AS x;
SELECT JSON_OBJECTAGG(x: x WITH UNIQUE KEYS) FROM (VALUES (1, 1), (1, NULL), (2, 2)) AS x;
SELECT JSON_OBJECTAGG(x: x ABSENT ON NULL WITH UNIQUE KEYS) FROM (VALUES (1, 1), (1, NULL), (2, 2)) AS x;
SELECT JSON_OBJECTAGG(x: x ABSENT ON NULL WITH UNIQUE KEYS) FROM (VALUES (1, 1), (0, NULL), (3, NULL), (2, 2), (4, NULL)) AS x;
SELECT JSON_OBJECTAGG(x: x WITH UNIQUE KEYS RETURNING x) FROM (VALUES (1, 1), (1, NULL), (2, 2)) AS x;
SELECT JSON_OBJECTAGG(x: x ABSENT ON NULL WITH UNIQUE KEYS RETURNING x) FROM (VALUES (1, 1), (1, NULL), (2, 2)) AS x;
SELECT JSON_OBJECTAGG(x: x ABSENT ON NULL WITH UNIQUE KEYS RETURNING x) FROM (VALUES (1, 1), (0, NULL), (4, NULL), (5, NULL), (6, NULL), (2, 2)) AS x;
SELECT JSON_OBJECTAGG(x % 100: CAST((x) AS TEXT) FORMAT JSON WITH UNIQUE KEYS) FROM x AS x;
/* Test JSON_OBJECT deparsing */ EXPLAIN (VERBOSE, COSTS OFF) SELECT JSON_OBJECT('foo' : '1' FORMAT JSON, 'bar' : 'baz' RETURNING json);
CREATE VIEW x AS SELECT JSON_OBJECT('foo': '1' FORMAT JSON, 'bar': 'baz' RETURNING x);
SELECT TO_JSON(x) AS x, JSON_OBJECTAGG(x: x WITH UNIQUE KEYS) OVER (ORDER BY x NULLS LAST) FROM (VALUES (1, 1), (2, 2)) AS x;
SELECT TO_JSON(x) AS x, JSON_OBJECTAGG(x: x WITH UNIQUE KEYS) OVER (ORDER BY x NULLS LAST) FROM (VALUES (1, 1), (1, 2), (2, 2)) AS x;
SELECT TO_JSON(x) AS x, JSON_OBJECTAGG(x: x ABSENT ON NULL WITH UNIQUE KEYS) OVER (ORDER BY x NULLS LAST) FROM (VALUES (1, 1), (1, NULL), (2, 2)) AS x;
SELECT TO_JSON(x) AS x, JSON_OBJECTAGG(x: x ABSENT ON NULL) OVER (ORDER BY x NULLS LAST) FROM (VALUES (1, 1), (1, NULL), (2, 2)) AS x;
SELECT TO_JSON(x) AS x, JSON_OBJECTAGG(x: x ABSENT ON NULL) OVER (ORDER BY x NULLS LAST RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) FROM (VALUES (1, 1), (1, NULL), (2, 2)) AS x;
/* Test JSON_ARRAY deparsing */ EXPLAIN (VERBOSE, COSTS OFF) SELECT JSON_ARRAY('1' FORMAT JSON, 2 RETURNING json);
/* Test JSON_OBJECTAGG deparsing */ EXPLAIN (VERBOSE, COSTS OFF) SELECT JSON_OBJECTAGG(i: ('111' || i)::bytea FORMAT JSON WITH UNIQUE RETURNING text) FILTER (WHERE i > 3) FROM generate_series(1,5) i;
EXPLAIN (VERBOSE, COSTS OFF) SELECT JSON_OBJECTAGG(i: ('111' || i)::bytea FORMAT JSON WITH UNIQUE RETURNING text) OVER (PARTITION BY i % 2) FROM generate_series(1,5) i;
CREATE VIEW x AS SELECT JSON_OBJECTAGG(x: CAST(('111' || x) AS VARBINARY) FORMAT JSON WITH UNIQUE KEYS RETURNING x) FILTER(WHERE x > 3) FROM x AS x;
/* Test JSON_ARRAYAGG deparsing */ EXPLAIN (VERBOSE, COSTS OFF) SELECT JSON_ARRAYAGG(('111' || i)::bytea FORMAT JSON NULL ON NULL RETURNING text) FILTER (WHERE i > 3) FROM generate_series(1,5) i;
EXPLAIN (VERBOSE, COSTS OFF) SELECT JSON_ARRAYAGG(('111' || i)::bytea FORMAT JSON NULL ON NULL RETURNING text) OVER (PARTITION BY i % 2) FROM generate_series(1,5) i;
/* Test JSON_ARRAY(subquery) deparsing */ EXPLAIN (VERBOSE, COSTS OFF) SELECT JSON_ARRAY(SELECT i FROM (VALUES (1), (2), (NULL), (4)) foo(i) RETURNING jsonb);
/* IS JSON predicate */ SELECT NULL IS JSON;
SELECT NOT NULL IS JSON;
SELECT CAST(NULL AS JSON) IS JSON;
SELECT CAST(NULL AS JSONB) IS JSON;
SELECT CAST(NULL AS TEXT) IS JSON;
SELECT CAST(NULL AS VARBINARY) IS JSON;
SELECT CAST(NULL AS INT) IS JSON;
SELECT '' IS JSON;
SELECT CAST('\x00' AS VARBINARY) IS JSON;
CREATE TABLE x (x TEXT);
INSERT INTO x VALUES (NULL), (''), ('123'), ('"aaa "'), ('true'), ('null'), ('[]'), ('[1, "2", {}]'), ('{}'), ('{ "a": 1, "b": null }'), ('{ "a": 1, "a": null }'), ('{ "a": 1, "b": [{ "a": 1 }, { "a": 2 }] }'), ('{ "a": 1, "b": [{ "a": 1, "b": 0, "a": 2 }] }'), ('aaa'), ('{a:1}'), ('["a",]');
SELECT x, x IS JSON AS "x", NOT x IS JSON AS "x", x IS JSON VALUE AS "x", x IS JSON OBJECT AS "x", x IS JSON ARRAY AS "x", x IS JSON SCALAR AS "x", x IS JSON WITHOUT UNIQUE KEYS AS "x", x IS JSON WITH UNIQUE KEYS AS "x" FROM x;
SELECT x, x IS JSON AS "x", NOT x IS JSON AS "x", x IS JSON VALUE AS "x", x IS JSON OBJECT AS "x", x IS JSON ARRAY AS "x", x IS JSON SCALAR AS "x", x IS JSON WITHOUT UNIQUE KEYS AS "x", x IS JSON WITH UNIQUE KEYS AS "x" FROM (SELECT CAST(x AS JSON) FROM x WHERE x IS JSON) AS x;
SELECT x, x IS JSON AS "x", NOT x IS JSON AS "x", x IS JSON VALUE AS "x", x IS JSON OBJECT AS "x", x IS JSON ARRAY AS "x", x IS JSON SCALAR AS "x", x IS JSON WITHOUT UNIQUE KEYS AS "x", x IS JSON WITH UNIQUE KEYS AS "x" FROM (SELECT x, CAST(x AS VARBINARY) FROM x WHERE x IS JSON) AS x;
SELECT x, x IS JSON AS "x", NOT x IS JSON AS "x", x IS JSON VALUE AS "x", x IS JSON OBJECT AS "x", x IS JSON ARRAY AS "x", x IS JSON SCALAR AS "x", x IS JSON WITHOUT UNIQUE KEYS AS "x", x IS JSON WITH UNIQUE KEYS AS "x" FROM (SELECT CAST(x AS JSONB) FROM x WHERE x IS JSON) AS x;
/* Test IS JSON deparsing */ EXPLAIN (VERBOSE, COSTS OFF) SELECT '1' IS JSON AS "any", ('1' || i) IS JSON SCALAR AS "scalar", '[]' IS NOT JSON ARRAY AS "array", '{}' IS JSON OBJECT WITH UNIQUE AS "object" FROM generate_series(1, 3) i;
CREATE VIEW x AS SELECT '1' IS JSON AS "x", ('1' || x) IS JSON SCALAR AS "x", NOT '[]' IS JSON ARRAY AS "x", '{}' IS JSON OBJECT WITH UNIQUE KEYS AS "x" FROM x AS x;
SELECT JSON_OBJECT('a': JSON_OBJECT('b': 1 RETURNING VARCHAR(2)));
SELECT JSON_OBJECTAGG(x: CAST(('111' || x) AS VARBINARY) FORMAT JSON WITH UNIQUE KEYS RETURNING VARCHAR(2)) FROM x AS x;
/* Now try domain over fixed-length type */ CREATE DOMAIN sqljson_char2 AS char(2) CHECK (VALUE NOT IN ('12'));
COMMIT;
COMMIT;
EXPLAIN (VERBOSE, COSTS OFF) SELECT JSON_OBJECT('a': JSON_OBJECTAGG('b': volatile_one() RETURNING text) FORMAT JSON);
SELECT JSON_OBJECT('a': JSON_OBJECTAGG('b': VOLATILE_ONE() RETURNING x) FORMAT JSON);
EXPLAIN (VERBOSE, COSTS OFF) SELECT JSON_OBJECT('a': JSON_OBJECTAGG('b': stable_one() RETURNING text) FORMAT JSON);
SELECT JSON_OBJECT('a': JSON_OBJECTAGG('b': STABLE_ONE() RETURNING x) FORMAT JSON);
EXPLAIN (VERBOSE, COSTS OFF) SELECT JSON_OBJECT('a': JSON_OBJECTAGG('b': 1 RETURNING text) FORMAT JSON);
SELECT JSON_OBJECT('a': JSON_OBJECTAGG('b': 1 RETURNING x) FORMAT JSON);
/* JSON_TABLE */ /* Should fail (JSON_TABLE can be used only in FROM clause) */ SELECT JSON_TABLE('[]', '$' COLUMNS());
/* Should fail (no columns) */ SELECT * FROM x;
SELECT * FROM x AS x;
/* duplicated column name */ SELECT * FROM x;
/* return composite data type. */ create type comp as (a int, b int);
drop type comp;
/* NULL => empty table */ SELECT * FROM x AS x;
SELECT * FROM x;
SELECT * FROM x AS x;
/* JSON_TABLE: basic functionality */ CREATE DOMAIN jsonb_test_domain AS text CHECK (value <> 'foo');
CREATE TEMPORARY TABLE x (x) AS (VALUES ('1'), ('[]'), ('{}'), ('[1, 1.23, "2", "aaaaaaa", "foo", null, false, true, {"aaa": 123}, "[1,2]", "\"str\""]'));
EXPLAIN (COSTS OFF, VERBOSE) SELECT * FROM jsonb_table_view3;
EXPLAIN (COSTS OFF, VERBOSE) SELECT * FROM jsonb_table_view4;
EXPLAIN (COSTS OFF, VERBOSE) SELECT * FROM jsonb_table_view5;
EXPLAIN (COSTS OFF, VERBOSE) SELECT * FROM jsonb_table_view6;
/* JSON_TABLE() with alias */ EXPLAIN (COSTS OFF, VERBOSE) SELECT * FROM 	JSON_TABLE( 		jsonb 'null', 'lax $[*]' PASSING 1 + 2 AS a, json '"foo"' AS "b c" 		COLUMNS ( 			id FOR ORDINALITY, 			"int" int PATH '$', 			"text" text PATH '$' 	)) json_table_func;
EXPLAIN (COSTS OFF, FORMAT JSON, VERBOSE) SELECT * FROM 	JSON_TABLE( 		jsonb 'null', 'lax $[*]' PASSING 1 + 2 AS a, json '"foo"' AS "b c" 		COLUMNS ( 			id FOR ORDINALITY, 			"int" int PATH '$', 			"text" text PATH '$' 	)) json_table_func;
DROP VIEW x;
DROP VIEW x;
DROP VIEW x;
DROP VIEW x;
DROP VIEW x;
DROP DOMAIN jsonb_test_domain;
/* JSON_TABLE: ON EMPTY/ON ERROR behavior */ SELECT * FROM (VALUES ('1'), ('"err"')) AS x, x AS x;
/* EXISTS PATH domain over int */ CREATE DOMAIN dint4 AS int;
CREATE DOMAIN dint4_0 AS int CHECK (VALUE <> 0 );
DROP DOMAIN dint4, dint4_0;
/* JSON_TABLE: plan execution */ CREATE TEMPORARY TABLE x (x JSONB);
INSERT INTO x VALUES ('[ 		{"a":  1,  "b": [], "c": []}, 		{"a":  2,  "b": [1, 2, 3], "c": [10, null, 20]}, 		{"a":  3,  "b": [1, 2], "c": []}, 		{"x": "4", "b": [1, 2], "c": 123} 	 ]');
CREATE TABLE x (x JSONB);
INSERT INTO x VALUES ('{"a":{"za":[{"z1": [11,2222]},{"z21": [22, 234,2345]},{"z22": [32, 204,145]}]},"c": 3}'), ('{"a":{"za":[{"z1": [21,4222]},{"z21": [32, 134,1345]}]},"c": 10}');
DROP TABLE x;
/* Test JSON_TABLE() column deparsing -- don't emit default ON ERROR / EMPTY */ /* behavior */ CREATE VIEW x AS SELECT * FROM x;
/* JSON_EXISTS */ SELECT JSON_EXISTS(CAST(NULL AS JSONB), '$');
SELECT JSON_EXISTS(CAST('[]' AS JSONB), '$');
SELECT JSON_EXISTS(JSON_OBJECT( RETURNING x), '$');
SELECT JSON_EXISTS(CAST('1' AS JSONB), '$');
SELECT JSON_EXISTS(CAST('null' AS JSONB), '$');
SELECT JSON_EXISTS(CAST('[]' AS JSONB), '$');
SELECT JSON_EXISTS(CAST('1' AS JSONB), '$.a');
SELECT JSON_EXISTS(CAST('1' AS JSONB), 'strict $.a');
SELECT JSON_EXISTS(CAST('null' AS JSONB), '$.a');
SELECT JSON_EXISTS(CAST('[]' AS JSONB), '$.a');
SELECT JSON_EXISTS(CAST('[1, "aaa", {"a": 1}]' AS JSONB), 'strict $.a');
/* FALSE on error */ SELECT JSON_EXISTS(CAST('[1, "aaa", {"a": 1}]' AS JSONB), 'lax $.a');
SELECT JSON_EXISTS(CAST('{}' AS JSONB), '$.a');
SELECT JSON_EXISTS(CAST('{"b": 1, "a": 2}' AS JSONB), '$.a');
SELECT JSON_EXISTS(CAST('1' AS JSONB), '$.a.b');
SELECT JSON_EXISTS(CAST('{"a": {"b": 1}}' AS JSONB), '$.a.b');
SELECT JSON_EXISTS(CAST('{"a": 1, "b": 2}' AS JSONB), '$.a.b');
/* extension: boolean expressions */ SELECT JSON_EXISTS(CAST('1' AS JSONB), '$ > 2');
/* JSON_VALUE */ SELECT JSON_VALUE(CAST(NULL AS JSONB), '$');
SELECT JSON_VALUE(CAST('null' AS JSONB), '$');
SELECT JSON_VALUE(CAST('true' AS JSONB), '$');
SELECT JSON_VALUE(CAST('123' AS JSONB), '$');
SELECT JSON_VALUE(CAST('1.23' AS JSONB), '$');
SELECT JSON_VALUE(CAST('"aaa"' AS JSONB), '$');
/* Test NULL checks execution in domain types */ CREATE DOMAIN sqljsonb_int_not_null AS int NOT NULL;
CREATE TYPE rainbow AS ENUM ('red', 'orange', 'yellow', 'green', 'blue', 'purple');
CREATE DOMAIN rgb AS rainbow CHECK (VALUE IN ('red', 'green', 'blue'));
SELECT JSON_VALUE(CAST('[]' AS JSONB), '$');
SELECT JSON_VALUE(CAST('{}' AS JSONB), '$');
SELECT JSON_VALUE(CAST('1' AS JSONB), '$.a');
/* JSON_QUERY */ SELECT JSON_VALUE(CAST(NULL AS JSONB), '$');
CREATE DOMAIN qf_char_domain AS char(1);
CREATE DOMAIN qf_jsonb_domain AS jsonb;
DROP DOMAIN qf_char_domain, qf_jsonb_domain;
SELECT JSON_QUERY(CAST('[]' AS JSONB), '$[*]');
/* record type returning with quotes behavior. */ CREATE TYPE comp_abc AS (a text, b int, c timestamp);
DROP TYPE comp_abc;
/* Extension: record types returning */ CREATE TYPE sqljsonb_rec AS (a int, t text, js json, jb jsonb, jsa json[]);
CREATE TYPE sqljsonb_reca AS (reca sqljsonb_rec[]);
SELECT PG_GET_EXPR(x, x) FROM x WHERE x = CAST('test_jsonb_constraints' AS REGCLASS) ORDER BY 1 NULLS LAST;
INSERT INTO x VALUES ('', 1);
INSERT INTO x VALUES ('1', 1);
INSERT INTO x VALUES ('[]');
INSERT INTO x VALUES ('{"b": 1}', 1);
INSERT INTO x VALUES ('{"a": 1}', 1);
INSERT INTO x VALUES ('{"a": 10}', 1);
DROP TABLE x;
/* Test mutabilily of query functions */ CREATE TABLE x (x JSONB, x INT);
CREATE INDEX ON x(JSON_QUERY(x, '$') NULLS LAST);
CREATE INDEX ON x(JSON_QUERY(x, '$.a[0]') NULLS LAST);
CREATE INDEX ON x(JSON_QUERY(x, '$.time()') NULLS LAST);
CREATE INDEX ON x(JSON_QUERY(x, '$.date()') NULLS LAST);
CREATE INDEX ON x(JSON_QUERY(x, '$.time_tz()') NULLS LAST);
CREATE INDEX ON x(JSON_QUERY(x, '$.timestamp()') NULLS LAST);
CREATE INDEX ON x(JSON_QUERY(x, '$.timestamp_tz()') NULLS LAST);
CREATE INDEX ON x(JSON_QUERY(x, '$.a ? (@.date() < $.time_tz())') NULLS LAST);
CREATE INDEX ON x(JSON_QUERY(x, '$.a ? (@.date() < $.time())') NULLS LAST);
CREATE INDEX ON x(JSON_QUERY(x, '$.a ? (@.time() < $.time())') NULLS LAST);
CREATE INDEX ON x(JSON_QUERY(x, '$.a ? (@.time() < $.time_tz())') NULLS LAST);
CREATE INDEX ON x(JSON_QUERY(x, '$.a ? (@.timestamp() < $.timestamp_tz())') NULLS LAST);
CREATE INDEX ON x(JSON_QUERY(x, '$.a ? (@.timestamp_tz() < $.timestamp_tz())') NULLS LAST);
CREATE INDEX ON x(JSON_QUERY(x, '$.a ? (@.time() < $.datetime("HH:MI TZH"))') NULLS LAST);
CREATE INDEX ON x(JSON_QUERY(x, '$.a ? (@.date() < $.datetime("HH:MI TZH"))') NULLS LAST);
CREATE INDEX ON x(JSON_QUERY(x, '$.a ? (@.timestamp() < $.datetime("HH:MI TZH"))') NULLS LAST);
CREATE INDEX ON x(JSON_QUERY(x, '$.a ? (@.timestamp() < $.datetime("HH:MI"))') NULLS LAST);
CREATE INDEX ON x(JSON_QUERY(x, '$.a ? (@.timestamp_tz() < $.datetime("HH:MI TZH"))') NULLS LAST);
CREATE INDEX ON x(JSON_QUERY(x, '$.a ? (@.timestamp_tz() < $.datetime("HH:MI"))') NULLS LAST);
CREATE INDEX ON x(JSON_QUERY(x, '$.a ? (@.timestamp(2) < $.timestamp(3))') NULLS LAST);
CREATE INDEX ON x(JSON_QUERY(x, '$.datetime()') NULLS LAST);
CREATE INDEX ON x(JSON_QUERY(x, '$.a ? (@ < $.datetime())') NULLS LAST);
CREATE INDEX ON x(JSON_QUERY(x, '$.a ? (@.datetime() < $.datetime())') NULLS LAST);
CREATE INDEX ON x(JSON_QUERY(x, '$.a ? (@.datetime() < $.datetime("HH:MI TZH"))') NULLS LAST);
CREATE INDEX ON x(JSON_QUERY(x, '$.a ? (@.datetime("HH:MI TZH") < $.datetime("HH:MI TZH"))') NULLS LAST);
CREATE INDEX ON x(JSON_QUERY(x, '$.a ? (@.datetime("HH:MI") < $.datetime("YY-MM-DD HH:MI"))') NULLS LAST);
CREATE INDEX ON x(JSON_QUERY(x, '$.a ? (@.datetime("HH:MI TZH") < $.datetime("YY-MM-DD HH:MI"))') NULLS LAST);
COMMIT;
DROP TABLE x;
DROP FUNCTION x;
CREATE DOMAIN queryfuncs_test_domain AS text CHECK (value <> 'foo');
/* ConvertRowtypeExpr */ CREATE TABLE x (x INT);
CREATE TABLE x INHERITS (x);
DROP DOMAIN queryfuncs_test_domain;
/* Extension: non-constant JSON path */ SELECT JSON_EXISTS(CAST('{"a": 123}' AS JSONB), '$' || '.' || 'a');
SELECT JSON_VALUE(CAST('{"a": 123}' AS JSONB), '$' || '.' || 'a');
SELECT JSON_QUERY(CAST('{"a": 123}' AS JSONB), '$' || '.' || 'a');
/* Should fail (invalid path) */ SELECT JSON_QUERY(CAST('{"a": 123}' AS JSONB), 'error' || ' ' || 'error');
/* Non-jsonb inputs automatically coerced to jsonb */ SELECT JSON_EXISTS(PARSE_JSON('{"a": 123}'), '$' || '.' || 'a');
/* Test non-const jsonpath */ CREATE TEMPORARY TABLE x (x) AS SELECT '$';
/* Test implicit coercion to a domain over fixed-length type specified in */ /* RETURNING */ CREATE DOMAIN queryfuncs_char2 AS char(2);
CREATE DOMAIN queryfuncs_char2_chk AS char(2) CHECK (VALUE NOT IN ('12'));
DROP DOMAIN queryfuncs_char2, queryfuncs_char2_chk;
/* Test coercion to domain over another fixed-length type of the ON ERROR / */ /* EMPTY expressions.  Ask user to cast the DEFAULT expression explicitly if */ /* automatic casting cannot be done, for example, from int to bit(2). */ CREATE DOMAIN queryfuncs_d_varbit3 AS varbit(3) CHECK (VALUE <> '01');
DROP DOMAIN queryfuncs_d_varbit3;
/* Test cumulative stats system */ /* Must be run after tenk2 has been created (by create_table), */ /* populated (by create_misc) and indexed (by create_index). */ /* conditio sine qua non */ SHOW track_counts;
SET x = on;
SET x = off /* for the moment, we don't want index-only scans here */;
SET x = 'all' /* not enabled by default, but we want to test it... */;
SET LOCAL x = snapshot;
CREATE TABLE x AS SELECT x.x, x.x, x.x, x.x, (x.x + x.x) AS x, (x.x + x.x) AS x, PG_STAT_GET_SNAPSHOT_TIMESTAMP() AS x FROM x.x AS x, x.x AS x WHERE x.x = 'tenk2' AND x.x = 'tenk2';
COMMIT;
/* test effects of TRUNCATE on n_live_tup/n_dead_tup counters */ CREATE TABLE x (x SERIAL);
CREATE TABLE x (x SERIAL, x TEXT);
CREATE TABLE x (x SERIAL);
CREATE TABLE x (x SERIAL, x TEXT);
CREATE TABLE x (x SERIAL);
TRUNCATE TABLE x;
UPDATE x SET x = x + 10 WHERE x IN (1, 2);
DELETE FROM x WHERE x = 3;
BEGIN;
UPDATE x SET x = x + 100;
TRUNCATE TABLE x;
COMMIT;
/* use a savepoint: 1 insert, 1 live */ BEGIN;
x AS x;
TRUNCATE TABLE x;
COMMIT;
/* rollback a savepoint: this should count 4 inserts and have 2 */ /* live tuples after commit (and 2 dead ones due to aborted subxact) */ BEGIN;
x AS x;
TRUNCATE TABLE x;
ROLLBACK TO x;
COMMIT;
/* rollback a truncate: this should count 2 inserts and produce 2 dead tuples */ BEGIN;
TRUNCATE TABLE x;
ROLLBACK;
/* do a seqscan */ SELECT COUNT(*) FROM x;
SET x = off /* do an indexscan */ /* make sure it is not a bitmap scan, which might skip fetching heap tuples */;
SELECT COUNT(*) FROM x WHERE x = 1;
RESET enable_bitmapscan;
/* ensure pending stats are flushed */ SELECT PG_STAT_FORCE_NEXT_FLUSH();
/* check effects */ BEGIN;
SET LOCAL x = snapshot;
SELECT x, x, x, x, x, x FROM x WHERE x LIKE 'trunc_stats_test%' ORDER BY x NULLS LAST;
SELECT x.x >= x.x + 1, x.x >= x.x + x.x, x.x >= x.x + 1, x.x >= x.x + 1 FROM x AS x, x AS x, x AS x WHERE x.x = 'tenk2' AND x.x = 'tenk2';
SELECT x.x + x.x >= x.x + x.x, x.x + x.x >= x.x + 1 FROM x AS x, x AS x, x AS x WHERE x.x = 'tenk2' AND x.x = 'tenk2';
SELECT x.x < PG_STAT_GET_SNAPSHOT_TIMESTAMP() AS x FROM x AS x;
COMMIT;
SET LOCAL x = none;
SELECT PG_STAT_GET_FUNCTION_CALLS(:stats_test_func1_oid);
SELECT PG_STAT_GET_XACT_FUNCTION_CALLS(:stats_test_func1_oid);
SELECT STATS_TEST_FUNC1();
SELECT PG_STAT_GET_XACT_FUNCTION_CALLS(:stats_test_func1_oid);
SELECT STATS_TEST_FUNC1();
SELECT PG_STAT_GET_XACT_FUNCTION_CALLS(:stats_test_func1_oid);
SELECT PG_STAT_GET_FUNCTION_CALLS(:stats_test_func1_oid);
COMMIT;
/* Verify that function stats are not transactional */ /* rolled back savepoint in committing transaction */ BEGIN;
SELECT STATS_TEST_FUNC2();
x AS x;
SELECT STATS_TEST_FUNC2();
ROLLBACK TO x;
SELECT PG_STAT_GET_XACT_FUNCTION_CALLS(:stats_test_func2_oid);
SELECT STATS_TEST_FUNC2();
COMMIT;
/* rolled back transaction */ BEGIN;
SELECT STATS_TEST_FUNC2();
ROLLBACK;
SELECT PG_STAT_FORCE_NEXT_FLUSH();
/* check collected stats */ SELECT x, x FROM x WHERE x = :stats_test_func1_oid;
SELECT x, x FROM x WHERE x = :stats_test_func2_oid;
/* check that a rolled back drop function stats leaves stats alive */ BEGIN;
SELECT x, x FROM x WHERE x = :stats_test_func1_oid;
DROP FUNCTION x;
/* shouldn't be visible via view */ SELECT x, x FROM x WHERE x = :stats_test_func1_oid;
/* but still via oid access */ SELECT PG_STAT_GET_FUNCTION_CALLS(:stats_test_func1_oid);
ROLLBACK;
SELECT x, x FROM x WHERE x = :stats_test_func1_oid;
SELECT PG_STAT_GET_FUNCTION_CALLS(:stats_test_func1_oid);
/* check that function dropped in main transaction leaves no stats behind */ BEGIN;
DROP FUNCTION x;
COMMIT;
SELECT x, x FROM x WHERE x = :stats_test_func1_oid;
SELECT PG_STAT_GET_FUNCTION_CALLS(:stats_test_func1_oid);
/* check that function dropped in a subtransaction leaves no stats behind */ BEGIN;
SELECT STATS_TEST_FUNC2();
x AS x;
SELECT STATS_TEST_FUNC2();
x AS x;
DROP FUNCTION x;
COMMIT;
SELECT x, x FROM x WHERE x = :stats_test_func2_oid;
SELECT PG_STAT_GET_FUNCTION_CALLS(:stats_test_func2_oid);
/* Check that stats for relations are dropped. For that we need to access stats */ /* by oid after the DROP TABLE. Save oids. */ CREATE TABLE x;
SELECT PG_STAT_GET_LIVE_TUPLES(:drop_stats_test_oid);
DROP TABLE x;
SELECT PG_STAT_GET_LIVE_TUPLES(:drop_stats_test_oid);
SELECT PG_STAT_GET_XACT_TUPLES_INSERTED(:drop_stats_test_oid);
/* check that rollback protects against having stats dropped and that local */ /* modifications don't pose a problem */ SELECT PG_STAT_GET_LIVE_TUPLES(:drop_stats_test_xact_oid);
SELECT PG_STAT_GET_TUPLES_INSERTED(:drop_stats_test_xact_oid);
SELECT PG_STAT_GET_XACT_TUPLES_INSERTED(:drop_stats_test_xact_oid);
BEGIN;
SELECT PG_STAT_GET_XACT_TUPLES_INSERTED(:drop_stats_test_xact_oid);
DROP TABLE x;
SELECT PG_STAT_GET_XACT_TUPLES_INSERTED(:drop_stats_test_xact_oid);
ROLLBACK;
SELECT PG_STAT_FORCE_NEXT_FLUSH();
SELECT PG_STAT_GET_LIVE_TUPLES(:drop_stats_test_xact_oid);
SELECT PG_STAT_GET_TUPLES_INSERTED(:drop_stats_test_xact_oid);
/* transactional drop */ SELECT PG_STAT_GET_LIVE_TUPLES(:drop_stats_test_xact_oid);
SELECT PG_STAT_GET_TUPLES_INSERTED(:drop_stats_test_xact_oid);
BEGIN;
SELECT PG_STAT_GET_XACT_TUPLES_INSERTED(:drop_stats_test_xact_oid);
DROP TABLE x;
SELECT PG_STAT_GET_XACT_TUPLES_INSERTED(:drop_stats_test_xact_oid);
COMMIT;
SELECT PG_STAT_FORCE_NEXT_FLUSH();
SELECT PG_STAT_GET_LIVE_TUPLES(:drop_stats_test_xact_oid);
SELECT PG_STAT_GET_TUPLES_INSERTED(:drop_stats_test_xact_oid);
/* savepoint rollback (2 levels) */ SELECT PG_STAT_GET_LIVE_TUPLES(:drop_stats_test_subxact_oid);
BEGIN;
x AS x;
SELECT PG_STAT_GET_XACT_TUPLES_INSERTED(:drop_stats_test_subxact_oid);
x AS x;
DROP TABLE x;
ROLLBACK TO x;
SELECT PG_STAT_GET_XACT_TUPLES_INSERTED(:drop_stats_test_subxact_oid);
COMMIT;
SELECT PG_STAT_FORCE_NEXT_FLUSH();
SELECT PG_STAT_GET_LIVE_TUPLES(:drop_stats_test_subxact_oid);
/* savepoint rolback (1 level) */ SELECT PG_STAT_GET_LIVE_TUPLES(:drop_stats_test_subxact_oid);
BEGIN;
x AS x;
DROP TABLE x;
x AS x;
ROLLBACK TO x;
COMMIT;
SELECT PG_STAT_GET_LIVE_TUPLES(:drop_stats_test_subxact_oid);
/* and now actually drop */ SELECT PG_STAT_GET_LIVE_TUPLES(:drop_stats_test_subxact_oid);
BEGIN;
x AS x;
DROP TABLE x;
x AS x;
COMMIT;
SELECT PG_STAT_GET_LIVE_TUPLES(:drop_stats_test_subxact_oid);
DROP TABLE x;
/* --- */ /* Test that last_seq_scan, last_idx_scan are correctly maintained */ /* Perform test using a temporary table. That way autovacuum etc won't */ /* interfere. To be able to check that timestamps increase, we sleep for 100ms */ /* between tests, assuming that there aren't systems with a coarser timestamp */ /* granularity. */ /* --- */ BEGIN;
CREATE TEMPORARY TABLE x (x INT PRIMARY KEY, x INT);
INSERT INTO x (x, x) VALUES (1, 1);
SELECT PG_STAT_FORCE_NEXT_FLUSH();
SELECT x, x FROM x WHERE x = CAST('test_last_scan' AS REGCLASS);
COMMIT;
SELECT PG_STAT_RESET_SINGLE_TABLE_COUNTERS(CAST('test_last_scan' AS REGCLASS));
SELECT x, x FROM x WHERE x = CAST('test_last_scan' AS REGCLASS);
/* ensure we start out with exactly one index and sequential scan */ BEGIN;
SET LOCAL x = on;
SET LOCAL x = on;
SET LOCAL x = off;
EXPLAIN (COSTS off) SELECT count(*) FROM test_last_scan WHERE noidx_col = 1;
SELECT COUNT(*) FROM x WHERE x = 1;
SET LOCAL x = off;
EXPLAIN (COSTS off) SELECT count(*) FROM test_last_scan WHERE idx_col = 1;
SELECT COUNT(*) FROM x WHERE x = 1;
SELECT PG_STAT_FORCE_NEXT_FLUSH();
COMMIT;
/* assume a minimum timestamp granularity of 100ms */ /* cause one sequential scan */ BEGIN;
SET LOCAL x = on;
SET LOCAL x = off;
SET LOCAL x = off;
EXPLAIN (COSTS off) SELECT count(*) FROM test_last_scan WHERE noidx_col = 1;
SELECT COUNT(*) FROM x WHERE x = 1;
SELECT PG_STAT_FORCE_NEXT_FLUSH();
COMMIT;
/* cause one index scan */ BEGIN;
SET LOCAL x = off;
SET LOCAL x = on;
SET LOCAL x = off;
EXPLAIN (COSTS off) SELECT count(*) FROM test_last_scan WHERE idx_col = 1;
SELECT COUNT(*) FROM x WHERE x = 1;
SELECT PG_STAT_FORCE_NEXT_FLUSH();
COMMIT;
/* cause one bitmap index scan */ BEGIN;
SET LOCAL x = off;
SET LOCAL x = off;
SET LOCAL x = on;
EXPLAIN (COSTS off) SELECT count(*) FROM test_last_scan WHERE idx_col = 1;
SELECT COUNT(*) FROM x WHERE x = 1;
SELECT PG_STAT_FORCE_NEXT_FLUSH();
COMMIT;
SELECT PG_STAT_FORCE_NEXT_FLUSH();
COMMIT;
/* check that the stats are reset. */ SELECT (x + x) > 0 AS x FROM x WHERE x = CAST('pg_shdescription' AS REGCLASS);
SELECT PG_STAT_RESET_SINGLE_TABLE_COUNTERS(CAST('pg_shdescription' AS REGCLASS));
SELECT (x + x) > 0 AS x FROM x WHERE x = CAST('pg_shdescription' AS REGCLASS);
SELECT x > :db_stat_sessions FROM x WHERE x = (SELECT CURRENT_DATABASE());
DROP TABLE x;
x /* Checkpoint twice: The checkpointer reports stats after reporting completion */ /* of the checkpoint. But after a second checkpoint we'll see at least the */ /* results of the first. */;
x;
SELECT x > :rqst_ckpts_before FROM x;
SELECT x > :wal_bytes_before FROM x;
SELECT PG_STAT_FORCE_NEXT_FLUSH();
SELECT x > :backend_wal_bytes_before FROM x;
/* Test pg_stat_get_backend_idset() and some allied functions. */ /* In particular, verify that their notion of backend ID matches */ /* our temp schema index. */ SELECT (CURRENT_SCHEMAS(TRUE))[0] = ('pg_temp_' || CAST(x AS TEXT)) AS x FROM x AS x WHERE PG_STAT_GET_BACKEND_PID(x) = PG_BACKEND_PID();
/* Test error case for reset_shared with unknown stats type */ SELECT PG_STAT_RESET_SHARED('unknown');
/* Test that reset works for pg_stat_database */ /* Since pg_stat_database stats_reset starts out as NULL, reset it once first so we have something to compare it to */ SELECT PG_STAT_RESET();
/* -- */ /* pg_stat_get_snapshot_timestamp behavior */ /* -- */ BEGIN;
SET LOCAL x = snapshot;
/* no snapshot yet, return NULL */ SELECT PG_STAT_GET_SNAPSHOT_TIMESTAMP();
/* any attempt at accessing stats will build snapshot */ SELECT PG_STAT_GET_FUNCTION_CALLS(0);
SELECT PG_STAT_GET_SNAPSHOT_TIMESTAMP() >= CURRENT_TIMESTAMP();
/* shows NULL again after clearing */ SELECT PG_STAT_CLEAR_SNAPSHOT();
SELECT PG_STAT_GET_SNAPSHOT_TIMESTAMP();
COMMIT;
/* -- */ /* Changing stats_fetch_consistency in a transaction. */ /* -- */ BEGIN;
SELECT PG_STAT_GET_FUNCTION_CALLS(0);
SELECT NOT PG_STAT_GET_SNAPSHOT_TIMESTAMP() IS NULL AS x;
SET LOCAL x = snapshot /* Success in accessing pre-existing snapshot data. */;
SELECT NOT PG_STAT_GET_SNAPSHOT_TIMESTAMP() IS NULL AS x;
SELECT PG_STAT_GET_FUNCTION_CALLS(0);
SELECT NOT PG_STAT_GET_SNAPSHOT_TIMESTAMP() IS NULL AS x;
SET LOCAL x = none /* Snapshot cleared. */;
SELECT NOT PG_STAT_GET_SNAPSHOT_TIMESTAMP() IS NULL AS x;
SELECT PG_STAT_GET_FUNCTION_CALLS(0);
SELECT NOT PG_STAT_GET_SNAPSHOT_TIMESTAMP() IS NULL AS x;
ROLLBACK;
/* -- */ /* pg_stat_have_stats behavior */ /* -- */ /* fixed-numbered stats exist */ SELECT PG_STAT_HAVE_STATS('bgwriter', 0, 0);
/* unknown stats kinds error out */ SELECT PG_STAT_HAVE_STATS('zaphod', 0, 0);
/* db stats have objid 0 */ SELECT PG_STAT_HAVE_STATS('database', :dboid, 1);
SELECT PG_STAT_HAVE_STATS('database', :dboid, 0);
/* pg_stat_have_stats returns true for committed index creation */ CREATE TABLE x AS SELECT UNNEST(GENERATE_SERIES(1, 10)) AS x;
CREATE INDEX x ON x(x NULLS LAST);
SELECT x FROM x WHERE x = 3;
SELECT PG_STAT_HAVE_STATS('relation', :dboid, :stats_test_idx1_oid);
/* pg_stat_have_stats returns false for dropped index with stats */ SELECT PG_STAT_HAVE_STATS('relation', :dboid, :stats_test_idx1_oid);
DROP INDEX x;
SELECT PG_STAT_HAVE_STATS('relation', :dboid, :stats_test_idx1_oid);
/* pg_stat_have_stats returns false for rolled back index creation */ BEGIN;
CREATE INDEX x ON x(x NULLS LAST);
SELECT PG_STAT_HAVE_STATS('relation', :dboid, :stats_test_idx1_oid);
ROLLBACK;
SELECT PG_STAT_HAVE_STATS('relation', :dboid, :stats_test_idx1_oid);
/* pg_stat_have_stats returns true for reindex CONCURRENTLY */ CREATE INDEX x ON x(x NULLS LAST);
SELECT PG_STAT_HAVE_STATS('relation', :dboid, :stats_test_idx1_oid);
REINDEX index CONCURRENTLY stats_test_idx1;
/* false for previous oid */ SELECT PG_STAT_HAVE_STATS('relation', :dboid, :stats_test_idx1_oid);
/* pg_stat_have_stats returns true for a rolled back drop index with stats */ BEGIN;
SELECT PG_STAT_HAVE_STATS('relation', :dboid, :stats_test_idx1_oid);
DROP INDEX x;
ROLLBACK;
SELECT PG_STAT_HAVE_STATS('relation', :dboid, :stats_test_idx1_oid);
SET x = on /* put enable_seqscan back to on */;
/* ensure that stats accessors handle NULL input correctly */ SELECT PG_STAT_GET_REPLICATION_SLOT(NULL);
SELECT PG_STAT_GET_SUBSCRIPTION_STATS(NULL);
INSERT INTO x SELECT x FROM x AS x;
SELECT PG_STAT_FORCE_NEXT_FLUSH();
x /* After a checkpoint, there should be some additional IOCONTEXT_NORMAL writes */ /* and fsyncs in the global stats (usually not for the backend). */ /* See comment above for rationale for two explicit CHECKPOINTs. */;
x;
SELECT CURRENT_SETTING('fsync') = 'off' OR :io_sum_shared_after_fsyncs > :io_sum_shared_before_fsyncs;
SELECT CURRENT_SETTING('fsync') = 'off' OR :my_io_sum_shared_after_fsyncs >= :my_io_sum_shared_before_fsyncs;
SELECT :io_sum_wal_normal_after_writes > :io_sum_wal_normal_before_writes;
SELECT CURRENT_SETTING('fsync') = 'off' OR :io_sum_wal_normal_after_fsyncs > :io_sum_wal_normal_before_fsyncs;
ALTER TABLE x SET;
/* SELECT from the table so that the data is read into shared buffers and */ /* context 'normal', object 'relation' reads are counted. */ SELECT COUNT(*) FROM x;
COMMIT;
SELECT PG_STAT_FORCE_NEXT_FLUSH();
SET LOCAL x = on;
SET LOCAL x = off;
SET LOCAL x = off;
SET LOCAL x = off;
/* ensure plan stays as we expect it to */ EXPLAIN (COSTS OFF) SELECT COUNT(*) FROM test_io_shared t1 INNER JOIN test_io_shared t2 USING (a);
SELECT COUNT(*) FROM x AS x INNER JOIN x AS x USING (x);
COMMIT;
SELECT PG_STAT_FORCE_NEXT_FLUSH();
DROP TABLE x;
CREATE TEMPORARY TABLE x (x INT, x TEXT);
/* Ensure the table is large enough to exceed our temp_buffers setting. */ SELECT PG_RELATION_SIZE('test_io_local') / CAST(CURRENT_SETTING('block_size') AS BIGINT) > 100;
SELECT PG_STAT_FORCE_NEXT_FLUSH();
ALTER TABLE x SET  /* Change the tablespaces so that the temporary table is rewritten to other */ /* local buffers, exercising a different codepath than standard local buffer */ /* writes. */;
SELECT PG_STAT_FORCE_NEXT_FLUSH();
RESET temp_buffers;
SET x = '1 kB' /* Test that reuse of strategy buffers and reads of blocks into these reused */ /* buffers while VACUUMing are tracked in pg_stat_io. If there is sufficient */ /* demand for shared buffers from concurrent queries, some buffers may be */ /* pinned by other backends before they can be reused. In such cases, the */ /* backend will evict a buffer from outside the ring and add it to the */ /* ring. This is considered an eviction and not a reuse. */ /* Set wal_skip_threshold smaller than the expected size of */ /* test_io_vac_strategy so that, even if wal_level is minimal, VACUUM FULL will */ /* fsync the newly rewritten test_io_vac_strategy instead of writing it to WAL. */ /* Writing it to WAL will result in the newly written relation pages being in */ /* shared buffers -- preventing us from testing BAS_VACUUM BufferAccessStrategy */ /* reads. */;
INSERT INTO x SELECT x, x FROM x AS x;
/* Ensure that the next VACUUM will need to perform IO by rewriting the table */ /* first with VACUUM (FULL). */ VACUUM (FULL) test_io_vac_strategy;
/* Use the minimum BUFFER_USAGE_LIMIT to cause reuses or evictions with the */ /* smallest table possible. */ VACUUM (PARALLEL 0, BUFFER_USAGE_LIMIT 128) test_io_vac_strategy;
SELECT PG_STAT_FORCE_NEXT_FLUSH();
SELECT (:io_sum_vac_strategy_after_reuses + :io_sum_vac_strategy_after_evictions) > (:io_sum_vac_strategy_before_reuses + :io_sum_vac_strategy_before_evictions);
RESET wal_skip_threshold;
SELECT PG_STAT_FORCE_NEXT_FLUSH();
/* Test IO stats reset */ SELECT PG_STAT_HAVE_STATS('io', 0, 0);
/* but pg_stat_reset_backend_stats() does */ SELECT PG_STAT_RESET_BACKEND_STATS(PG_BACKEND_PID());
/* Check invalid input for pg_stat_get_backend_io() */ SELECT PG_STAT_GET_BACKEND_IO(NULL);
SELECT PG_STAT_GET_BACKEND_IO(0);
/* Auxiliary processes return no data. */ SELECT PG_STAT_GET_BACKEND_IO(:checkpointer_pid);
/* test BRIN index doesn't block HOT update */ CREATE TABLE x (x INT PRIMARY KEY, x INT NOT NULL) WITH (autovacuum_enabled=off, fillfactor=70);
INSERT INTO x SELECT *, 0 FROM x;
CREATE INDEX x ON x USING brin(x NULLS LAST);
x AS x;
/* we don't want to wait forever */ BEGIN -- we don't want to wait forever;
UPDATE x SET x = -3 WHERE x = 42;
SELECT PG_STAT_GET_TUPLES_HOT_UPDATED(CAST(CAST('brin_hot' AS REGCLASS) AS OID));
DROP TABLE x;
DROP FUNCTION x;
/* Test handling of index predicates - updating attributes in precicates */ /* should not block HOT when summarizing indexes are involved. We update */ /* a row that was not indexed due to the index predicate, and becomes */ /* indexable - the HOT-updated tuple is forwarded to the BRIN index. */ CREATE TABLE x (x INT, x INT);
INSERT INTO x VALUES (1, 100);
CREATE INDEX ON x USING brin(x NULLS LAST) WHERE x = 2;
UPDATE x SET x = 2;
EXPLAIN (COSTS OFF) SELECT * FROM brin_hot_2 WHERE a = 2 AND b = 100;
SELECT COUNT(*) FROM x WHERE x = 2 AND x = 100;
SET x = off;
EXPLAIN (COSTS OFF) SELECT * FROM brin_hot_2 WHERE a = 2 AND b = 100;
SELECT COUNT(*) FROM x WHERE x = 2 AND x = 100;
DROP TABLE x;
/* Test that updates to indexed columns are still propagated to the */ /* BRIN column. */ /* https://postgr.es/m/05ebcb44-f383-86e3-4f31-0a97a55634cf@enterprisedb.com */ CREATE TABLE x (x INT, x TEXT) WITH (fillfactor=10);
INSERT INTO x SELECT 1, REPEAT(' ', 500) FROM x;
CREATE INDEX ON x USING brin(x NULLS LAST) WITH (pages_per_range=1);
UPDATE x SET x = 2;
EXPLAIN (COSTS OFF) SELECT * FROM brin_hot_3 WHERE a = 2;
SELECT COUNT(*) FROM x WHERE x = 2;
DROP TABLE x;
SET x = on;
/* Test that estimation of relation size works with tuples wider than the */ /* relation fillfactor. We create a table with wide inline attributes and */ /* low fillfactor, insert rows and then see how many rows EXPLAIN shows */ /* before running analyze. We disable autovacuum so that it does not */ /* interfere with the test. */ CREATE TABLE x (x CHAR(1000)) WITH (fillfactor=10, autovacuum_enabled=off);
INSERT INTO x SELECT 'x' FROM x;
SELECT * FROM x;
DROP TABLE x;
BEGIN for ln in         execute format('explain analyze %s', $1)     loop         if first_row then             first_row := false;
x := REGEXP_MATCH(x, 'rows=(\d*) .* rows=(\d*)');
COMMIT;
/* Verify failures */ CREATE TABLE x (x TEXT, x INT, x INT);
CREATE STATISTICS tst;
CREATE STATISTICS tst ON a, b;
CREATE STATISTICS tst FROM sometab;
CREATE STATISTICS tst ON a, b FROM nonexistent;
CREATE STATISTICS tst ON a, b FROM ext_stats_test;
CREATE STATISTICS tst ON x, x, y FROM ext_stats_test;
CREATE STATISTICS tst ON x, x, y, x, x, y, x, x, y FROM ext_stats_test;
CREATE STATISTICS tst ON x, x, y, x, x, (x || 'x'), (y + 1), (x || 'x'), (x || 'x'), (y + 1) FROM ext_stats_test;
CREATE STATISTICS tst ON (x || 'x'), (x || 'x'), (y + 1), (x || 'x'), (x || 'x'), (y + 1), (x || 'x'), (x || 'x'), (y + 1) FROM ext_stats_test;
CREATE STATISTICS tst ON (x || 'x'), (x || 'x'), y FROM ext_stats_test;
CREATE STATISTICS tst (unrecognized) ON x, y FROM ext_stats_test;
/* incorrect expressions */ CREATE STATISTICS tst ON (y) FROM ext_stats_test;
/* single column reference */ CREATE STATISTICS tst ON y + z FROM ext_stats_test;
/* missing parentheses */ CREATE STATISTICS tst ON (x, y) FROM ext_stats_test;
/* tuple expression */ DROP TABLE x;
CREATE STATISTICS tst on z from ext_stats_test1;
CREATE STATISTICS tst on (z) from ext_stats_test1;
CREATE STATISTICS tst on (z+1) from ext_stats_test1;
CREATE STATISTICS tst (ndistinct) ON z from ext_stats_test1;
/* statistics on system column not allowed */ CREATE STATISTICS tst on tableoid from ext_stats_test1;
CREATE STATISTICS tst on (tableoid) from ext_stats_test1;
CREATE STATISTICS tst on (tableoid::int+1) from ext_stats_test1;
CREATE STATISTICS tst (ndistinct) ON xmin from ext_stats_test1;
/* statistics without a less-than operator not supported */ CREATE STATISTICS tst (ndistinct) ON w from ext_stats_test1;
DROP TABLE x;
/* Ensure stats are dropped sanely, and test IF NOT EXISTS while at it */ CREATE TABLE x (x INT, x INT, x INT);
CREATE STATISTICS IF NOT EXISTS ab1_a_b_stats ON a, b FROM ab1;
COMMENT ON STATISTICS ab1_a_b_stats IS 'new comment';
CREATE ROLE regress_stats_ext;
SET SESSION AUTHORIZATION regress_stats_ext;
COMMENT ON STATISTICS ab1_a_b_stats IS 'changed comment';
DROP STATISTICS ab1_a_b_stats;
ALTER STATISTICS ab1_a_b_stats RENAME TO ab1_a_b_stats_new;
RESET SESSION AUTHORIZATION;
DROP ROLE regress_stats_ext;
CREATE STATISTICS IF NOT EXISTS ab1_a_b_stats ON a, b FROM ab1;
DROP STATISTICS ab1_a_b_stats;
CREATE SCHEMA x.x;
CREATE STATISTICS regress_schema_2.ab1_a_b_stats ON a, b FROM ab1;
/* Let's also verify the pg_get_statisticsobjdef output looks sane. */ SELECT PG_GET_STATISTICSOBJDEF(x) FROM x WHERE x = 'ab1_a_b_stats';
DROP STATISTICS regress_schema_2.ab1_a_b_stats;
/* Ensure statistics are dropped when columns are */ CREATE STATISTICS ab1_b_c_stats ON b, c FROM ab1;
CREATE STATISTICS ab1_a_b_c_stats ON a, b, c FROM ab1;
CREATE STATISTICS ab1_b_a_stats ON b, a FROM ab1;
ALTER TABLE x DROP COLUMN x;
DROP TABLE x;
SELECT x FROM x WHERE x LIKE 'ab1%';
/* Ensure things work sanely with SET STATISTICS 0 */ CREATE TABLE x (x INT, x INT);
ALTER TABLE x ALTER COLUMN x DROP DEFAULT, SET STATISTICS 0;
INSERT INTO x SELECT x, x % 23 FROM x AS x;
CREATE STATISTICS ab1_a_b_stats ON a, b FROM ab1;
ANALYZE x;
ALTER TABLE x ALTER COLUMN x DROP DEFAULT, SET STATISTICS -1;
/* setting statistics target 0 skips the statistics, without printing any message, so check catalog */ ALTER STATISTICS ab1_a_b_stats SET STATISTICS 0;
SELECT x, x, x, x, x FROM x AS x LEFT JOIN x AS x ON (x.x = x.x) WHERE x.x = 'ab1_a_b_stats';
ALTER STATISTICS ab1_a_b_stats SET STATISTICS -1;
ANALYZE x;
DROP TABLE x;
ALTER STATISTICS ab1_a_b_stats SET STATISTICS 0;
ALTER STATISTICS IF EXISTS ab1_a_b_stats SET STATISTICS 0;
/* Ensure we can build statistics for tables with inheritance. */ CREATE TABLE x (x INT, x INT);
CREATE TABLE x INHERITS (x);
INSERT INTO x VALUES (1, 1);
CREATE STATISTICS ab1_a_b_stats ON a, b FROM ab1;
ANALYZE x;
DROP TABLE x CASCADE;
/* Tests for stats with inheritance */ CREATE TABLE x (x INT, x INT);
CREATE TABLE x INHERITS (x);
CREATE TABLE x INHERITS (x);
INSERT INTO x SELECT x % 50, x % 100 FROM x AS x;
INSERT INTO x SELECT x % 100, x % 100 FROM x AS x;
INSERT INTO x SELECT x % 100, x % 100 FROM x AS x;
VACUUM ANALYZE stxdinh, stxdinh1, stxdinh2;
/* Ensure non-inherited stats are not applied to inherited query */ /* Without stats object, it looks like this */ SELECT * FROM x;
SELECT * FROM x;
CREATE STATISTICS stxdinh ON a, b FROM stxdinh;
VACUUM ANALYZE stxdinh, stxdinh1, stxdinh2;
/* See if the extended stats affect the estimates */ SELECT * FROM x;
/* Dependencies are applied at individual relations (within append), so */ /* this estimate changes a bit because we improve estimates for the parent */ SELECT * FROM x;
/* Ensure correct (non-inherited) stats are applied to inherited query */ SELECT * FROM x;
SELECT * FROM x;
/* Ensure inherited stats ARE applied to inherited query in partitioned table */ CREATE TABLE x (x INT, x INT, x INT) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (1) TO (100);
INSERT INTO x SELECT 1, x / 100, x / 100 FROM x AS x;
CREATE STATISTICS stxdinp ON (a + 1), a, b FROM stxdinp;
VACUUM ANALYZE stxdinp;
/* partitions are processed recursively */ SELECT 1 FROM x WHERE x = CAST('stxdinp' AS REGCLASS);
SELECT * FROM x;
SELECT * FROM x;
DROP TABLE x;
/* basic test for statistics on expressions */ CREATE TABLE x (x INT, x INT, x TIMESTAMP, x TIMESTAMPTZ);
/* expression stats may be built on a single expression column */ CREATE STATISTICS ab1_exprstat_1 ON (a+b) FROM ab1;
/* with a single expression, we only enable expression statistics */ CREATE STATISTICS ab1_exprstat_2 ON (a+b) FROM ab1;
SELECT x FROM x WHERE x = 'ab1_exprstat_2';
/* adding anything to the expression builds all statistics kinds */ CREATE STATISTICS ab1_exprstat_3 ON (a+b), a FROM ab1;
SELECT x FROM x WHERE x = 'ab1_exprstat_3';
/* date_trunc on timestamptz is not immutable, but that should not matter */ CREATE STATISTICS ab1_exprstat_4 ON date_trunc('day', d) FROM ab1;
/* date_trunc on timestamp is immutable */ CREATE STATISTICS ab1_exprstat_5 ON date_trunc('day', c) FROM ab1;
/* check use of a boolean-returning expression */ CREATE STATISTICS ab1_exprstat_6 ON   (case a when 1 then true else false end), b FROM ab1;
/* insert some data and run analyze, to test that these cases build properly */ INSERT INTO x SELECT x / 10, x / 3, CAST('2020-10-01' AS TIMESTAMP) + x * INTERVAL '1' DAY, CAST('2020-10-01' AS TIMESTAMPTZ) + x * INTERVAL '1' DAY FROM x AS x;
ANALYZE x;
/* apply some stats */ SELECT * FROM x;
DROP TABLE x;
/* Verify supported object types for extended statistics */ CREATE SCHEMA x.x;
CREATE TABLE x.x (x INT, x INT, x TEXT);
CREATE INDEX x ON x.x(x NULLS LAST, x NULLS LAST);
CREATE SEQUENCE x.x;
CREATE VIEW x.x AS SELECT * FROM x.x;
CREATE MATERIALIZED VIEW x.x AS SELECT * FROM x.x;
CREATE TYPE tststats.ty AS (a int, b int, c text);
CREATE FOREIGN DATA WRAPPER extstats_dummy_fdw;
CREATE SERVER extstats_dummy_srv FOREIGN DATA WRAPPER extstats_dummy_fdw;
CREATE FOREIGN TABLE tststats.f (a int, b int, c text) SERVER extstats_dummy_srv;
CREATE TABLE x.x (x INT, x INT, x TEXT) WITH (PARTITIONED_BY=RANGE(x, x));
CREATE TABLE x.x PARTITION OF x.x FOR VALUES FROM (-10, -10) TO (10, 10);
CREATE STATISTICS tststats.s1 ON a, b FROM tststats.t;
CREATE STATISTICS tststats.s2 ON a, b FROM tststats.ti;
CREATE STATISTICS tststats.s3 ON a, b FROM tststats.s;
CREATE STATISTICS tststats.s4 ON a, b FROM tststats.v;
CREATE STATISTICS tststats.s5 ON a, b FROM tststats.mv;
CREATE STATISTICS tststats.s6 ON a, b FROM tststats.ty;
CREATE STATISTICS tststats.s7 ON a, b FROM tststats.f;
CREATE STATISTICS tststats.s8 ON a, b FROM tststats.pt;
CREATE STATISTICS tststats.s9 ON a, b FROM tststats.pt1;
BEGIN EXECUTE 'CREATE STATISTICS tststats.s10 ON a, b FROM ' || relname;
COMMIT;
DROP SCHEMA x.x CASCADE;
DROP FOREIGN DATA WRAPPER extstats_dummy_fdw CASCADE;
/* n-distinct tests */ CREATE TABLE x (x TEXT, x DECIMAL, x INT, x INT, x DATE, x INT, x INT) WITH (autovacuum_enabled=off);
/* over-estimates when using only per-column statistics */ INSERT INTO x (x, x, x, x) SELECT x / 100, x / 100, x / 100, (x / 100) || ' dollars and zero cents' FROM x AS x;
ANALYZE x;
/* Group Aggregate, due to over-estimate of the number of groups */ SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
/* correct command */ CREATE STATISTICS s10 ON a, b, c FROM ndistinct;
ANALYZE x;
SELECT x.x, x.x FROM x AS x, x AS x WHERE x.x = CAST('ndistinct' AS REGCLASS) AND x.x = x.x;
/* minor improvement, make sure the ctid does not break the matching */ SELECT * FROM x;
/* Hash Aggregate, thanks to estimates improved by the statistic */ SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
/* partial improvement (match on attributes) */ SELECT * FROM x;
/* expressions - no improvement */ SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
/* last two plans keep using Group Aggregate, because 'd' is not covered */ /* by the statistic and while it's NULL-only we assume 200 values for it */ SELECT * FROM x;
SELECT * FROM x;
TRUNCATE TABLE x;
/* under-estimates when using only per-column statistics */ INSERT INTO x (x, x, x, x) SELECT x % 13, x % 17, x % 19, x % 23 || ' dollars and zero cents' FROM x AS x;
ANALYZE x;
SELECT x.x, x.x FROM x AS x, x AS x WHERE x.x = CAST('ndistinct' AS REGCLASS) AND x.x = x.x;
/* correct estimates */ SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
DROP STATISTICS s10;
SELECT x.x, x.x FROM x AS x, x AS x WHERE x.x = CAST('ndistinct' AS REGCLASS) AND x.x = x.x;
/* dropping the statistics results in under-estimates */ SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
/* ndistinct estimates with statistics on expressions */ SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
CREATE STATISTICS s10 (ndistinct) ON (a+1), (b+100), (2*c) FROM ndistinct;
ANALYZE x;
SELECT x.x, x.x FROM x AS x, x AS x WHERE x.x = CAST('ndistinct' AS REGCLASS) AND x.x = x.x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
DROP STATISTICS s10;
/* a mix of attributes and expressions */ SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
CREATE STATISTICS s10 (ndistinct) ON a, b, (2*c) FROM ndistinct;
ANALYZE x;
SELECT x.x, x.x FROM x AS x, x AS x WHERE x.x = CAST('ndistinct' AS REGCLASS) AND x.x = x.x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
DROP STATISTICS s10;
TRUNCATE TABLE x /* combination of multiple ndistinct statistics, with/without expressions */;
/* two mostly independent groups of columns */ INSERT INTO x (x, x, x, x) SELECT x % 3, x % 9, x % 5, x % 20 FROM x AS x;
ANALYZE x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
/* basic statistics on both attributes (no expressions) */ CREATE STATISTICS s11 (ndistinct) ON a, b FROM ndistinct;
CREATE STATISTICS s12 (ndistinct) ON c, d FROM ndistinct;
ANALYZE x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
/* replace the second statistics by statistics on expressions */ DROP STATISTICS s12;
CREATE STATISTICS s12 (ndistinct) ON (c * 10), (d - 1) FROM ndistinct;
ANALYZE x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
/* replace the second statistics by statistics on both attributes and expressions */ DROP STATISTICS s12;
CREATE STATISTICS s12 (ndistinct) ON c, d, (c * 10), (d - 1) FROM ndistinct;
ANALYZE x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
/* replace the other statistics by statistics on both attributes and expressions */ DROP STATISTICS s11;
CREATE STATISTICS s11 (ndistinct) ON a, b, (a*5), (b+1) FROM ndistinct;
ANALYZE x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
/* replace statistics by somewhat overlapping ones (this expected to get worse estimate */ /* because the first statistics shall be applied to 3 columns, and the second one can't */ /* be really applied) */ DROP STATISTICS s11;
DROP STATISTICS s12;
CREATE STATISTICS s11 (ndistinct) ON a, b, (a*5), (b+1) FROM ndistinct;
CREATE STATISTICS s12 (ndistinct) ON a, (b+1), (c * 10) FROM ndistinct;
ANALYZE x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
DROP STATISTICS s11;
DROP STATISTICS s12;
/* functional dependencies tests */ CREATE TABLE x (x TEXT, x DECIMAL, x INT, x TEXT, x DATE, x INT, x TEXT) WITH (autovacuum_enabled=off);
CREATE INDEX x ON x(x NULLS LAST, x NULLS LAST);
CREATE INDEX x ON x(x NULLS LAST, x NULLS LAST, x NULLS LAST);
/* random data (no functional dependencies) */ INSERT INTO x (x, x, x, x) SELECT x % 5, x % 7, x % 11, x FROM x AS x;
ANALYZE x;
SELECT * FROM x;
SELECT * FROM x;
/* create statistics */ CREATE STATISTICS func_deps_stat (dependencies) ON a, b, c FROM functional_dependencies;
ANALYZE x;
SELECT * FROM x;
SELECT * FROM x;
TRUNCATE TABLE x /* a => b, a => c, b => c */;
DROP STATISTICS func_deps_stat;
/* now do the same thing, but with expressions */ INSERT INTO x (x, x, x, x) SELECT x, x, x, x FROM x AS x;
ANALYZE x;
SELECT * FROM x;
SELECT * FROM x;
/* create statistics */ CREATE STATISTICS func_deps_stat (dependencies) ON (mod(a,11)), (mod(b::int, 13)), (mod(c, 7)) FROM functional_dependencies;
ANALYZE x;
SELECT * FROM x;
SELECT * FROM x;
TRUNCATE TABLE x /* a => b, a => c, b => c */;
DROP STATISTICS func_deps_stat;
INSERT INTO x (x, x, x, x) SELECT x % 100, x % 50, x % 25, x FROM x AS x;
ANALYZE x;
SELECT * FROM x;
SELECT * FROM x;
/* IN */ SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
/* OR clauses referencing the same attribute */ SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
/* OR clauses referencing different attributes */ SELECT * FROM x;
/* ANY */ SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
/* ANY with inequalities should not benefit from functional dependencies */ SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
/* ALL (should not benefit from functional dependencies) */ SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
/* create statistics */ CREATE STATISTICS func_deps_stat (dependencies) ON a, b, c FROM functional_dependencies;
ANALYZE x;
/* print the detected dependencies */ SELECT x FROM x WHERE x = 'func_deps_stat';
SELECT * FROM x;
SELECT * FROM x;
/* IN */ SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
/* OR clauses referencing the same attribute */ SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
/* OR clauses referencing different attributes are incompatible */ SELECT * FROM x;
/* ANY */ SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
/* ANY with inequalities should not benefit from functional dependencies */ SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
/* ALL (should not benefit from functional dependencies) */ SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
ALTER TABLE x ALTER COLUMN x SET DATA TYPE DECIMAL /* changing the type of column c causes all its stats to be dropped, reverting */ /* to default estimates without any statistics, i.e. 0.5% selectivity for each */ /* condition */;
SELECT * FROM x;
ANALYZE x;
SELECT * FROM x;
DROP STATISTICS func_deps_stat;
/* now try functional dependencies with expressions */ SELECT * FROM x;
SELECT * FROM x;
/* IN */ SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
/* OR clauses referencing the same attribute */ SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
/* OR clauses referencing different attributes */ SELECT * FROM x;
/* ANY */ SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
/* ANY with inequalities should not benefit from functional dependencies */ /* the estimates however improve thanks to having expression statistics */ SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
/* ALL (should not benefit from functional dependencies) */ SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
/* create statistics on expressions */ CREATE STATISTICS func_deps_stat (dependencies) ON (a * 2), upper(b), (c + 1) FROM functional_dependencies;
ANALYZE x;
/* print the detected dependencies */ SELECT x FROM x WHERE x = 'func_deps_stat';
SELECT * FROM x;
SELECT * FROM x;
/* IN */ SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
/* OR clauses referencing the same attribute */ SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
/* OR clauses referencing different attributes */ SELECT * FROM x;
/* ANY */ SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
/* ANY with inequalities should not benefit from functional dependencies */ /* the estimates however improve thanks to having expression statistics */ SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
/* ALL (should not benefit from functional dependencies) */ SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
/* check the ability to use multiple functional dependencies */ CREATE TABLE x (x INT, x INT, x INT, x INT) WITH (autovacuum_enabled=off);
INSERT INTO x (x, x, x, x) SELECT x % 7, x % 7, x % 11, x % 11 FROM x AS x;
ANALYZE x;
/* estimates without any functional dependencies */ SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
/* create separate functional dependencies */ CREATE STATISTICS functional_dependencies_multi_1 (dependencies) ON a, b FROM functional_dependencies_multi;
CREATE STATISTICS functional_dependencies_multi_2 (dependencies) ON c, d FROM functional_dependencies_multi;
ANALYZE x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
DROP TABLE x;
/* MCV lists */ CREATE TABLE x (x TEXT, x DECIMAL, x INT, x VARCHAR, x DATE, x INT, x TEXT, x ARRAY<INT>) WITH (autovacuum_enabled=off);
/* random data (no MCV list) */ INSERT INTO x (x, x, x, x) SELECT x % 37, x % 41, x % 43, x % 47 FROM x AS x;
ANALYZE x;
SELECT * FROM x;
SELECT * FROM x;
/* create statistics */ CREATE STATISTICS mcv_lists_stats (mcv) ON a, b, c FROM mcv_lists;
ANALYZE x;
SELECT * FROM x;
SELECT * FROM x;
TRUNCATE TABLE x;
DROP STATISTICS mcv_lists_stats;
/* random data (no MCV list), but with expression */ INSERT INTO x (x, x, x, x) SELECT x, x, x, x FROM x AS x;
ANALYZE x;
SELECT * FROM x;
SELECT * FROM x;
/* create statistics */ CREATE STATISTICS mcv_lists_stats (mcv) ON (mod(a,7)), (mod(b::int,11)), (mod(c,13)) FROM mcv_lists;
ANALYZE x;
SELECT * FROM x;
SELECT * FROM x;
TRUNCATE TABLE x /* 100 distinct combinations, all in the MCV list */;
DROP STATISTICS mcv_lists_stats;
INSERT INTO x (x, x, x, x, x) SELECT x % 100, x % 50, x % 25, ARRAY(x % 25), x FROM x AS x;
ANALYZE x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
/* create statistics */ CREATE STATISTICS mcv_lists_stats (mcv) ON a, b, c, ia FROM mcv_lists;
ANALYZE x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
ALTER TABLE x ALTER COLUMN x SET DATA TYPE VARCHAR(64) /* check change of unrelated column type does not reset the MCV statistics */;
SELECT NOT x.x IS NULL FROM x AS x, x AS x WHERE x.x = 'mcv_lists_stats' AND x.x = x.x;
ALTER TABLE x ALTER COLUMN x SET DATA TYPE DECIMAL /* check change of column type resets the MCV statistics */;
SELECT * FROM x;
ANALYZE x;
SELECT * FROM x;
TRUNCATE TABLE x /* 100 distinct combinations, all in the MCV list, but with expressions */;
DROP STATISTICS mcv_lists_stats;
INSERT INTO x (x, x, x, x) SELECT x, x, x, x FROM x AS x;
ANALYZE x;
/* without any stats on the expressions, we have to use default selectivities, which */ /* is why the estimates here are different from the pre-computed case above */ SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
/* create statistics with expressions only (we create three separate stats, in order not to build more complex extended stats) */ CREATE STATISTICS mcv_lists_stats_1 ON (mod(a,20)) FROM mcv_lists;
CREATE STATISTICS mcv_lists_stats_2 ON (mod(b::int,10)) FROM mcv_lists;
CREATE STATISTICS mcv_lists_stats_3 ON (mod(c,5)) FROM mcv_lists;
ANALYZE x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
DROP STATISTICS mcv_lists_stats_1;
DROP STATISTICS mcv_lists_stats_2;
DROP STATISTICS mcv_lists_stats_3;
/* create statistics with both MCV and expressions */ CREATE STATISTICS mcv_lists_stats (mcv) ON (mod(a,20)), (mod(b::int,10)), (mod(c,5)) FROM mcv_lists;
ANALYZE x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
/* we can't use the statistic for OR clauses that are not fully covered (missing 'd' attribute) */ SELECT * FROM x;
TRUNCATE TABLE x /* 100 distinct combinations with NULL values, all in the MCV list */;
DROP STATISTICS mcv_lists_stats;
INSERT INTO x (x, x, x, x) SELECT (CASE WHEN x % 100 = 1 THEN NULL ELSE x % 100 END), (CASE WHEN x % 50 = 1 THEN NULL ELSE x % 50 END), (CASE WHEN x % 25 = 1 THEN NULL ELSE x % 25 END), x FROM x AS x;
ANALYZE x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
/* create statistics */ CREATE STATISTICS mcv_lists_stats (mcv) ON a, b, c FROM mcv_lists;
ANALYZE x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
TRUNCATE TABLE x /* test pg_mcv_list_items with a very simple (single item) MCV list */;
INSERT INTO x (x, x, x) SELECT 1, 2, 3 FROM x AS x;
ANALYZE x;
SELECT x.* FROM x AS x, x AS x, x AS x WHERE x.x = 'mcv_lists_stats' AND x.x = x.x;
TRUNCATE TABLE x /* 2 distinct combinations with NULL values, all in the MCV list */;
DROP STATISTICS mcv_lists_stats;
INSERT INTO x (x, x, x, x) SELECT NULL /* always NULL */, (CASE WHEN x % 2 = 0 THEN NULL ELSE 'x' END), (CASE WHEN x % 2 = 0 THEN NULL ELSE 0 END), (CASE WHEN x % 2 = 0 THEN NULL ELSE 'x' END) FROM x AS x;
ANALYZE x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
/* create statistics */ CREATE STATISTICS mcv_lists_stats (mcv) ON a, b, d FROM mcv_lists;
ANALYZE x;
/* test pg_mcv_list_items with MCV list containing variable-length data and NULLs */ SELECT x.* FROM x AS x, x AS x, x AS x WHERE x.x = 'mcv_lists_stats' AND x.x = x.x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
/* mcv with pass-by-ref fixlen types, e.g. uuid */ CREATE TABLE x (x UUID, x UUID, x UUID) WITH (autovacuum_enabled=off);
INSERT INTO x (x, x, x) SELECT CAST(FIPSHASH(CAST(x % 100 AS TEXT)) AS UUID), CAST(FIPSHASH(CAST(x % 50 AS TEXT)) AS UUID), CAST(FIPSHASH(CAST(x % 25 AS TEXT)) AS UUID) FROM x AS x;
ANALYZE x;
SELECT * FROM x;
SELECT * FROM x;
CREATE STATISTICS mcv_lists_uuid_stats (mcv) ON a, b, c   FROM mcv_lists_uuid;
ANALYZE x;
SELECT * FROM x;
SELECT * FROM x;
DROP TABLE x;
/* mcv with arrays */ CREATE TABLE x (x ARRAY<TEXT>, x ARRAY<DECIMAL>, x ARRAY<INT>) WITH (autovacuum_enabled=off);
INSERT INTO x (x, x, x) SELECT ARRAY(FIPSHASH(CAST((x / 100) AS TEXT)), FIPSHASH(CAST((x / 100 - 1) AS TEXT)), FIPSHASH(CAST((x / 100 + 1) AS TEXT))), ARRAY(CAST((x / 100 - 1) AS DECIMAL) / 1000, CAST((x / 100) AS DECIMAL) / 1000, CAST((x / 100 + 1) AS DECIMAL) / 1000), ARRAY((x / 100 - 1), x / 100, (x / 100 + 1)) FROM x AS x;
CREATE STATISTICS mcv_lists_arrays_stats (mcv) ON a, b, c   FROM mcv_lists_arrays;
ANALYZE x;
/* mcv with bool */ CREATE TABLE x (x BOOLEAN, x BOOLEAN, x BOOLEAN) WITH (autovacuum_enabled=off);
INSERT INTO x (x, x, x) SELECT (x % 2 = 0), (x % 4 = 0), (x % 8 = 0) FROM x AS x;
ANALYZE x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
CREATE STATISTICS mcv_lists_bool_stats (mcv) ON a, b, c   FROM mcv_lists_bool;
ANALYZE x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
/* mcv covering just a small fraction of data */ CREATE TABLE x (x INT, x INT, x INT);
/* 10 frequent groups, each with 100 elements */ INSERT INTO x (x, x, x) SELECT x % 10, x % 10, x % 10 FROM x AS x;
/* 100 groups that will make it to the MCV list (includes the 10 frequent ones) */ INSERT INTO x (x, x, x) SELECT x, x, x FROM x AS x;
/* 4000 groups in total, most of which won't make it (just a single item) */ INSERT INTO x (x, x, x) SELECT x, x, x FROM x AS x;
ANALYZE x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
CREATE STATISTICS mcv_lists_partial_stats (mcv) ON a, b, c   FROM mcv_lists_partial;
ANALYZE x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
DROP TABLE x;
/* check the ability to use multiple MCV lists */ CREATE TABLE x (x INT, x INT, x INT, x INT) WITH (autovacuum_enabled=off);
INSERT INTO x (x, x, x, x) SELECT x % 5, x % 5, x % 7, x % 7 FROM x AS x;
ANALYZE x;
/* estimates without any mcv statistics */ SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
/* create separate MCV statistics */ CREATE STATISTICS mcv_lists_multi_1 (mcv) ON a, b FROM mcv_lists_multi;
CREATE STATISTICS mcv_lists_multi_2 (mcv) ON c, d FROM mcv_lists_multi;
ANALYZE x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
DROP TABLE x;
/* statistics on integer expressions */ CREATE TABLE x (x INT, x INT, x INT);
INSERT INTO x SELECT x % 10, x % 10, x % 10 FROM x AS x;
ANALYZE x;
SELECT * FROM x;
SELECT * FROM x;
CREATE STATISTICS expr_stats_1 (mcv) ON (a+b), (a-b), (2*a), (3*b) FROM expr_stats;
ANALYZE x;
SELECT * FROM x;
SELECT * FROM x;
DROP STATISTICS expr_stats_1;
DROP TABLE x;
/* statistics on a mix columns and expressions */ CREATE TABLE x (x INT, x INT, x INT);
INSERT INTO x SELECT x % 10, x % 10, x % 10 FROM x AS x;
ANALYZE x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
CREATE STATISTICS expr_stats_1 (mcv) ON a, b, (2*a), (3*b), (a+b), (a-b) FROM expr_stats;
ANALYZE x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
DROP TABLE x;
/* statistics on expressions with different data types */ CREATE TABLE x (x INT, x NAME, x TEXT);
INSERT INTO x SELECT x % 10, FIPSHASH(CAST(x % 10 AS TEXT)), FIPSHASH(CAST(x % 10 AS TEXT)) FROM x AS x;
ANALYZE x;
SELECT * FROM x;
CREATE STATISTICS expr_stats_1 (mcv) ON a, b, (b || c), (c || b) FROM expr_stats;
ANALYZE x;
SELECT * FROM x;
DROP TABLE x;
/* test handling of a mix of compatible and incompatible expressions */ CREATE TABLE x (x DOUBLE, x BOOLEAN NOT NULL);
CREATE STATISTICS expr_stat_comp_1 ON c0, c1 FROM expr_stats_incompatible_test;
INSERT INTO x VALUES (1234, FALSE), (5678, TRUE);
ANALYZE x;
SELECT x FROM ONLY x WHERE (UPPER('x') LIKE ('x' || (CAST('[0,1]' AS INT4RANGE))) AND (x IN (0, 1) OR x));
DROP TABLE x;
/* Permission tests. Users should not be able to see specific data values in */ /* the extended statistics, if they lack permission to see those values in */ /* the underlying table. */ /* Currently this is only relevant for MCV stats. */ CREATE SCHEMA x.x;
CREATE TABLE x.x (x INT, x INT);
INSERT INTO x.x SELECT x % 5, x % 10 FROM x AS x;
CREATE STATISTICS tststats.priv_test_stats (mcv) ON a, b   FROM tststats.priv_test_tbl;
ANALYZE x.x;
/* Check printing info about extended statistics by \dX */ CREATE TABLE x (x INT, x INT);
create statistics (ndistinct) on a, b from stts_t1;
create statistics (ndistinct, dependencies) on a, b from stts_t1;
create statistics (ndistinct, dependencies, mcv) on a, b from stts_t1;
CREATE TABLE x (x INT, x INT, x INT);
create statistics on b, c from stts_t2;
CREATE TABLE x (x INT, x INT, x INT);
create statistics stts_hoge on col1, col2, col3 from stts_t3;
CREATE SCHEMA x.x;
CREATE SCHEMA x.x;
create statistics stts_s1.stts_foo on col1, col2 from stts_t3;
create statistics stts_s2.stts_yama (dependencies, mcv) on col1, col3 from stts_t3;
INSERT INTO x SELECT x, x FROM x AS x;
ANALYZE x;
set search_path to public, stts_s1, stts_s2, tststats;
create statistics (mcv) ON a, b, (a+b), (a-b) FROM stts_t1;
create statistics (mcv) ON (a+b), (a-b) FROM stts_t1;
drop statistics stts_t1_a_b_expr_expr_stat1;
drop statistics stts_t1_expr_expr_stat;
set search_path to public, stts_s1;
set role regress_stats_ext;
drop user regress_stats_ext;
RESET search_path;
/* User with no access */ CREATE USER regress_stats_user1;
GRANT USAGE ON SCHEMA x TO x;
SET SESSION AUTHORIZATION regress_stats_user1;
SELECT * FROM x.x;
/* Permission denied */ /* Check individual columns if we don't have table privilege */ SELECT * FROM x.x WHERE x = 1 AND x.x.* > NOT (1, 1) IS NULL;
CREATE OPERATOR <<< (procedure = op_leak, leftarg = int, rightarg = int,                      restrict = scalarltsel);
/* Permission denied */ /* Grant access via a security barrier view, but hide all data */ RESET SESSION AUTHORIZATION;
CREATE VIEW x.x WITH (security_barrier=TRUE) AS SELECT * FROM x.x WHERE FALSE;
GRANT SELECT, DELETE ON x.x TO x;
/* Should now have access via the view, but see nothing and leak nothing */ SET SESSION AUTHORIZATION regress_stats_user1;
/* Should not leak */ /* Grant table access, but hide all data with RLS */ RESET SESSION AUTHORIZATION;
ALTER TABLE tststats.priv_test_tbl ENABLE ROW LEVEL SECURITY;
GRANT SELECT, DELETE ON x.x TO x;
/* Should now have direct table access, but see nothing and leak nothing */ SET SESSION AUTHORIZATION regress_stats_user1;
/* Should not leak */ /* privilege checks for pg_stats_ext and pg_stats_ext_exprs */ RESET SESSION AUTHORIZATION;
CREATE TABLE x (x INT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY, x TEXT);
INSERT INTO x (x) VALUES ('secret'), ('secret'), ('very secret');
CREATE STATISTICS s_col ON id, col FROM stats_ext_tbl;
CREATE STATISTICS s_expr ON mod(id, 2), lower(col) FROM stats_ext_tbl;
ANALYZE x;
/* unprivileged role should not have access */ SET SESSION AUTHORIZATION regress_stats_user1;
SELECT x, x FROM x AS x WHERE x = 'stats_ext_tbl' ORDER BY ROW(x.*) NULLS LAST;
SELECT x, x FROM x AS x WHERE x = 'stats_ext_tbl' ORDER BY ROW(x.*) NULLS LAST;
/* give unprivileged role ownership of table */ RESET SESSION AUTHORIZATION;
ALTER TABLE stats_ext_tbl OWNER TO regress_stats_user1;
/* unprivileged role should now have access */ SET SESSION AUTHORIZATION regress_stats_user1;
SELECT x, x FROM x AS x WHERE x = 'stats_ext_tbl' ORDER BY ROW(x.*) NULLS LAST;
SELECT x, x FROM x AS x WHERE x = 'stats_ext_tbl' ORDER BY ROW(x.*) NULLS LAST;
/* Tidy up */ DROP OPERATOR <<< (int, int);
DROP FUNCTION x (INT, INT);
RESET SESSION AUTHORIZATION;
DROP TABLE x;
DROP SCHEMA x.x CASCADE;
DROP USER regress_stats_user1;
CREATE TABLE x (x INT);
INSERT INTO x (x) SELECT x FROM x AS x;
ANALYZE x;
DROP TABLE x;
/* Extended statistics on sb_2 (x, y, z) improve a bucket size estimation, */ /* and the optimizer may choose hash join. */ CREATE TABLE x AS SELECT x % 10 AS x, x % 10 AS x, x % 10 AS x FROM x AS x;
CREATE TABLE x AS SELECT x % 49 AS x, x % 51 AS x, x % 73 AS x, 'abc' || x AS x FROM x AS x;
/* During hash join estimation, the number of distinct values on each column */ /* is calculated. The optimizer selects the smallest number of distinct values */ /* and the largest hash bucket size. The optimizer decides that the hash */ /* bucket size is quite big because there are possibly many correlations. */ EXPLAIN (COSTS OFF) -- Choose merge join SELECT * FROM sb_1 a, sb_2 b WHERE a.x = b.x AND a.y = b.y AND a.z = b.z;
/* The ndistinct extended statistics on (x, y, z) provides more reliable value */ /* of bucket size. */ CREATE STATISTICS extstat_sb_2 (ndistinct) ON x, y, z FROM sb_2;
ANALYZE x;
EXPLAIN (COSTS OFF) -- Choose hash join SELECT * FROM sb_1 a, sb_2 b WHERE a.x = b.x AND a.y = b.y AND a.z = b.z;
CREATE SCHEMA x.x;
CREATE TYPE stats_import.complex_type AS (     a integer,     b real,     c text,     d date,     e jsonb);
CREATE TABLE x.x (x INT PRIMARY KEY, x TEXT, x stats_import.complex_type, x INT4RANGE, x ARRAY<TEXT>) WITH (autovacuum_enabled=FALSE);
SELECT x.pg_restore_relation_stats('relation', CAST('stats_import.test' AS REGCLASS), 'relpages', CAST(18 AS INT), 'reltuples', CAST(21 AS FLOAT), 'relallvisible', CAST(24 AS INT), 'relallfrozen', CAST(27 AS INT));
/* CREATE INDEX on a table with autovac disabled should not overwrite */ /* stats */ CREATE INDEX x ON x.x(x NULLS LAST);
SELECT x, x, x, x, x FROM x WHERE x = CAST('stats_import.test' AS REGCLASS) ORDER BY x NULLS LAST;
SELECT PG_CLEAR_RELATION_STATS(CAST('stats_import.test' AS REGCLASS));
/* relstats tests */ /* - error: relation is wrong type */ SELECT x.pg_restore_relation_stats('relation', CAST(0 AS OID), 'relpages', CAST(17 AS INT));
/* error: relation not found */ SELECT x.pg_restore_relation_stats('relation', CAST(CAST(0 AS OID) AS REGCLASS), 'relpages', CAST(17 AS INT));
/* error: odd number of variadic arguments cannot be pairs */ SELECT PG_RESTORE_RELATION_STATS('relation', CAST('stats_import.test' AS REGCLASS), 'relallvisible');
/* error: argument name is NULL */ SELECT PG_RESTORE_RELATION_STATS('relation', CAST('stats_import.test' AS REGCLASS), NULL, CAST('17' AS INT));
/* error: argument name is not a text type */ SELECT PG_RESTORE_RELATION_STATS('relation', CAST(CAST('0' AS OID) AS REGCLASS), 17, CAST('17' AS INT));
/* starting stats */ SELECT x, x, x, x FROM x WHERE x = CAST('stats_import.test_i' AS REGCLASS);
/* regular indexes have special case locking rules */ BEGIN;
SELECT x.pg_restore_relation_stats('relation', CAST('stats_import.test_i' AS REGCLASS), 'relpages', CAST(18 AS INT));
SELECT x FROM x WHERE x = CAST('stats_import.test' AS REGCLASS) AND x = PG_BACKEND_PID() AND x;
SELECT x FROM x WHERE x = CAST('stats_import.test_i' AS REGCLASS) AND x = PG_BACKEND_PID() AND x;
COMMIT;
/*  relpages may be -1 for partitioned tables */ CREATE TABLE x.x (x INT) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x.x PARTITION OF x.x FOR VALUES FROM (0) TO (10) WITH (autovacuum_enabled=FALSE);
CREATE INDEX x ON x.x(x NULLS LAST);
ANALYZE x.x;
SELECT x FROM x WHERE x = CAST('stats_import.part_parent' AS REGCLASS);
/* Partitioned indexes aren't analyzed but it is possible to set */ /* stats. The locking rules are different from normal indexes due to */ /* the rules for in-place updates: both the partitioned table and the */ /* partitioned index are locked in ShareUpdateExclusive mode. */ BEGIN;
SELECT x.pg_restore_relation_stats('relation', CAST('stats_import.part_parent_i' AS REGCLASS), 'relpages', CAST(2 AS INT));
SELECT x FROM x WHERE x = CAST('stats_import.part_parent' AS REGCLASS) AND x = PG_BACKEND_PID() AND x;
SELECT x FROM x WHERE x = CAST('stats_import.part_parent_i' AS REGCLASS) AND x = PG_BACKEND_PID() AND x;
COMMIT;
SELECT x FROM x WHERE x = CAST('stats_import.part_parent_i' AS REGCLASS);
/* ok: set all relstats, with version, no bounds checking */ SELECT PG_RESTORE_RELATION_STATS('relation', CAST('stats_import.test' AS REGCLASS), 'version', CAST(150000 AS INT), 'relpages', CAST('-17' AS INT), 'reltuples', CAST(400 AS FLOAT), 'relallvisible', CAST(4 AS INT), 'relallfrozen', CAST(2 AS INT));
SELECT x, x, x, x FROM x WHERE x = CAST('stats_import.test' AS REGCLASS);
/* ok: set just relpages, rest stay same */ SELECT PG_RESTORE_RELATION_STATS('relation', CAST('stats_import.test' AS REGCLASS), 'relpages', CAST('16' AS INT));
SELECT x, x, x, x FROM x WHERE x = CAST('stats_import.test' AS REGCLASS);
/* ok: set just reltuples, rest stay same */ SELECT PG_RESTORE_RELATION_STATS('relation', CAST('stats_import.test' AS REGCLASS), 'reltuples', CAST('500' AS FLOAT));
SELECT x, x, x, x FROM x WHERE x = CAST('stats_import.test' AS REGCLASS);
/* ok: set just relallvisible, rest stay same */ SELECT PG_RESTORE_RELATION_STATS('relation', CAST('stats_import.test' AS REGCLASS), 'relallvisible', CAST(5 AS INT));
SELECT x, x, x, x FROM x WHERE x = CAST('stats_import.test' AS REGCLASS);
/* ok: just relallfrozen */ SELECT PG_RESTORE_RELATION_STATS('relation', CAST('stats_import.test' AS REGCLASS), 'version', CAST(150000 AS INT), 'relallfrozen', CAST(3 AS INT));
SELECT x, x, x, x FROM x WHERE x = CAST('stats_import.test' AS REGCLASS);
/* warn: bad relpages type, rest updated */ SELECT PG_RESTORE_RELATION_STATS('relation', CAST('stats_import.test' AS REGCLASS), 'relpages', CAST('nope' AS TEXT), 'reltuples', CAST(400.0 AS FLOAT), 'relallvisible', CAST(4 AS INT), 'relallfrozen', CAST(3 AS INT));
SELECT x, x, x, x FROM x WHERE x = CAST('stats_import.test' AS REGCLASS);
/* unrecognized argument name, rest ok */ SELECT PG_RESTORE_RELATION_STATS('relation', CAST('stats_import.test' AS REGCLASS), 'relpages', CAST('171' AS INT), 'nope', CAST(10 AS INT));
SELECT x, x, x FROM x WHERE x = CAST('stats_import.test' AS REGCLASS);
/* ok: clear stats */ SELECT x.pg_clear_relation_stats(relation => CAST('stats_import.test' AS REGCLASS));
SELECT x, x, x FROM x WHERE x = CAST('stats_import.test' AS REGCLASS);
/* invalid relkinds for statistics */ CREATE SEQUENCE x.x;
SELECT x.pg_restore_relation_stats('relation', CAST('stats_import.testseq' AS REGCLASS));
SELECT x.pg_clear_relation_stats(CAST('stats_import.testseq' AS REGCLASS));
CREATE VIEW x.x AS SELECT * FROM x.x;
SELECT x.pg_restore_relation_stats('relation', CAST('stats_import.testview' AS REGCLASS));
SELECT x.pg_clear_relation_stats(CAST('stats_import.testview' AS REGCLASS));
/* attribute stats */ /* error: object does not exist */ SELECT x.pg_restore_attribute_stats('relation', CAST(CAST('0' AS OID) AS REGCLASS), 'attname', CAST('id' AS NAME), 'inherited', CAST(FALSE AS BOOLEAN), 'null_frac', CAST(0.1 AS FLOAT));
/* error: relation null */ SELECT x.pg_restore_attribute_stats('relation', CAST(CAST(NULL AS OID) AS REGCLASS), 'attname', CAST('id' AS NAME), 'inherited', CAST(FALSE AS BOOLEAN), 'null_frac', CAST(0.1 AS FLOAT));
/* error: NULL attname */ SELECT x.pg_restore_attribute_stats('relation', CAST('stats_import.test' AS REGCLASS), 'attname', CAST(NULL AS NAME), 'inherited', CAST(FALSE AS BOOLEAN), 'null_frac', CAST(0.1 AS FLOAT));
/* error: attname doesn't exist */ SELECT x.pg_restore_attribute_stats('relation', CAST('stats_import.test' AS REGCLASS), 'attname', CAST('nope' AS NAME), 'inherited', CAST(FALSE AS BOOLEAN), 'null_frac', CAST(0.1 AS FLOAT), 'avg_width', CAST(2 AS INT), 'n_distinct', CAST(0.3 AS FLOAT));
/* error: both attname and attnum */ SELECT x.pg_restore_attribute_stats('relation', CAST('stats_import.test' AS REGCLASS), 'attname', CAST('id' AS NAME), 'attnum', CAST(1 AS SMALLINT), 'inherited', CAST(FALSE AS BOOLEAN), 'null_frac', CAST(0.1 AS FLOAT));
/* error: neither attname nor attnum */ SELECT x.pg_restore_attribute_stats('relation', CAST('stats_import.test' AS REGCLASS), 'inherited', CAST(FALSE AS BOOLEAN), 'null_frac', CAST(0.1 AS FLOAT));
/* error: attribute is system column */ SELECT x.pg_restore_attribute_stats('relation', CAST('stats_import.test' AS REGCLASS), 'attname', CAST('xmin' AS NAME), 'inherited', CAST(FALSE AS BOOLEAN), 'null_frac', CAST(0.1 AS FLOAT));
/* error: inherited null */ SELECT x.pg_restore_attribute_stats('relation', CAST('stats_import.test' AS REGCLASS), 'attname', CAST('id' AS NAME), 'inherited', CAST(NULL AS BOOLEAN), 'null_frac', CAST(0.1 AS FLOAT));
/* ok: just the fixed values, with version, no stakinds */ SELECT x.pg_restore_attribute_stats('relation', CAST('stats_import.test' AS REGCLASS), 'attname', CAST('id' AS NAME), 'inherited', CAST(FALSE AS BOOLEAN), 'version', CAST(150000 AS INT), 'null_frac', CAST(0.2 AS FLOAT), 'avg_width', CAST(5 AS INT), 'n_distinct', CAST(0.6 AS FLOAT));
SELECT * FROM x WHERE x = 'stats_import' AND x = 'test' AND x = FALSE AND x = 'id';
/* ok: restore by attnum, we normally reserve this for */ /* indexes, but there is no reason it shouldn't work */ /* for any stat-having relation. */ SELECT x.pg_restore_attribute_stats('relation', CAST('stats_import.test' AS REGCLASS), 'attnum', CAST(1 AS SMALLINT), 'inherited', CAST(FALSE AS BOOLEAN), 'null_frac', CAST(0.4 AS FLOAT));
SELECT * FROM x WHERE x = 'stats_import' AND x = 'test' AND x = FALSE AND x = 'id';
/* warn: unrecognized argument name, rest get set */ SELECT x.pg_restore_attribute_stats('relation', CAST('stats_import.test' AS REGCLASS), 'attname', CAST('id' AS NAME), 'inherited', CAST(FALSE AS BOOLEAN), 'null_frac', CAST(0.2 AS FLOAT), 'nope', CAST(0.5 AS FLOAT));
SELECT * FROM x WHERE x = 'stats_import' AND x = 'test' AND x = FALSE AND x = 'id';
/* warn: mcv / mcf null mismatch part 1, rest get set */ SELECT x.pg_restore_attribute_stats('relation', CAST('stats_import.test' AS REGCLASS), 'attname', CAST('id' AS NAME), 'inherited', CAST(FALSE AS BOOLEAN), 'null_frac', CAST(0.21 AS FLOAT), 'most_common_freqs', CAST('{0.1,0.2,0.3}' AS ARRAY<FLOAT>));
SELECT * FROM x WHERE x = 'stats_import' AND x = 'test' AND x = FALSE AND x = 'id';
/* warn: mcv / mcf null mismatch part 2, rest get set */ SELECT x.pg_restore_attribute_stats('relation', CAST('stats_import.test' AS REGCLASS), 'attname', CAST('id' AS NAME), 'inherited', CAST(FALSE AS BOOLEAN), 'null_frac', CAST(0.21 AS FLOAT), 'most_common_vals', CAST('{1,2,3}' AS TEXT));
SELECT * FROM x WHERE x = 'stats_import' AND x = 'test' AND x = FALSE AND x = 'id';
/* warn: mcf type mismatch, mcv-pair fails, rest get set */ SELECT x.pg_restore_attribute_stats('relation', CAST('stats_import.test' AS REGCLASS), 'attname', CAST('id' AS NAME), 'inherited', CAST(FALSE AS BOOLEAN), 'null_frac', CAST(0.22 AS FLOAT), 'most_common_vals', CAST('{2,1,3}' AS TEXT), 'most_common_freqs', CAST('{0.2,0.1}' AS ARRAY<DOUBLE>));
SELECT * FROM x WHERE x = 'stats_import' AND x = 'test' AND x = FALSE AND x = 'id';
/* warn: mcv cast failure, mcv-pair fails, rest get set */ SELECT x.pg_restore_attribute_stats('relation', CAST('stats_import.test' AS REGCLASS), 'attname', CAST('id' AS NAME), 'inherited', CAST(FALSE AS BOOLEAN), 'null_frac', CAST(0.23 AS FLOAT), 'most_common_vals', CAST('{2,four,3}' AS TEXT), 'most_common_freqs', CAST('{0.3,0.25,0.05}' AS ARRAY<FLOAT>));
SELECT * FROM x WHERE x = 'stats_import' AND x = 'test' AND x = FALSE AND x = 'id';
/* ok: mcv+mcf */ SELECT x.pg_restore_attribute_stats('relation', CAST('stats_import.test' AS REGCLASS), 'attname', CAST('id' AS NAME), 'inherited', CAST(FALSE AS BOOLEAN), 'most_common_vals', CAST('{2,1,3}' AS TEXT), 'most_common_freqs', CAST('{0.3,0.25,0.05}' AS ARRAY<FLOAT>));
SELECT * FROM x WHERE x = 'stats_import' AND x = 'test' AND x = FALSE AND x = 'id';
/* warn: NULL in histogram array, rest get set */ SELECT x.pg_restore_attribute_stats('relation', CAST('stats_import.test' AS REGCLASS), 'attname', CAST('id' AS NAME), 'inherited', CAST(FALSE AS BOOLEAN), 'null_frac', CAST(0.24 AS FLOAT), 'histogram_bounds', CAST('{1,NULL,3,4}' AS TEXT));
SELECT * FROM x WHERE x = 'stats_import' AND x = 'test' AND x = FALSE AND x = 'id';
/* ok: histogram_bounds */ SELECT x.pg_restore_attribute_stats('relation', CAST('stats_import.test' AS REGCLASS), 'attname', CAST('id' AS NAME), 'inherited', CAST(FALSE AS BOOLEAN), 'histogram_bounds', CAST('{1,2,3,4}' AS TEXT));
SELECT * FROM x WHERE x = 'stats_import' AND x = 'test' AND x = FALSE AND x = 'id';
/* warn: elem_count_histogram null element, rest get set */ SELECT x.pg_restore_attribute_stats('relation', CAST('stats_import.test' AS REGCLASS), 'attname', CAST('tags' AS NAME), 'inherited', CAST(FALSE AS BOOLEAN), 'null_frac', CAST(0.25 AS FLOAT), 'elem_count_histogram', CAST('{1,1,NULL,1,1,1,1,1}' AS ARRAY<FLOAT>));
SELECT * FROM x WHERE x = 'stats_import' AND x = 'test' AND x = FALSE AND x = 'tags';
/* ok: elem_count_histogram */ SELECT x.pg_restore_attribute_stats('relation', CAST('stats_import.test' AS REGCLASS), 'attname', CAST('tags' AS NAME), 'inherited', CAST(FALSE AS BOOLEAN), 'null_frac', CAST(0.26 AS FLOAT), 'elem_count_histogram', CAST('{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1}' AS ARRAY<FLOAT>));
SELECT * FROM x WHERE x = 'stats_import' AND x = 'test' AND x = FALSE AND x = 'tags';
/* warn: range stats on a scalar type, rest ok */ SELECT x.pg_restore_attribute_stats('relation', CAST('stats_import.test' AS REGCLASS), 'attname', CAST('id' AS NAME), 'inherited', CAST(FALSE AS BOOLEAN), 'null_frac', CAST(0.27 AS FLOAT), 'range_empty_frac', CAST(0.5 AS FLOAT), 'range_length_histogram', CAST('{399,499,Infinity}' AS TEXT));
SELECT * FROM x WHERE x = 'stats_import' AND x = 'test' AND x = FALSE AND x = 'id';
/* warn: range_empty_frac range_length_hist null mismatch, rest ok */ SELECT x.pg_restore_attribute_stats('relation', CAST('stats_import.test' AS REGCLASS), 'attname', CAST('arange' AS NAME), 'inherited', CAST(FALSE AS BOOLEAN), 'null_frac', CAST(0.28 AS FLOAT), 'range_length_histogram', CAST('{399,499,Infinity}' AS TEXT));
SELECT * FROM x WHERE x = 'stats_import' AND x = 'test' AND x = FALSE AND x = 'arange';
/* warn: range_empty_frac range_length_hist null mismatch part 2, rest ok */ SELECT x.pg_restore_attribute_stats('relation', CAST('stats_import.test' AS REGCLASS), 'attname', CAST('arange' AS NAME), 'inherited', CAST(FALSE AS BOOLEAN), 'null_frac', CAST(0.29 AS FLOAT), 'range_empty_frac', CAST(0.5 AS FLOAT));
SELECT * FROM x WHERE x = 'stats_import' AND x = 'test' AND x = FALSE AND x = 'arange';
/* ok: range_empty_frac + range_length_hist */ SELECT x.pg_restore_attribute_stats('relation', CAST('stats_import.test' AS REGCLASS), 'attname', CAST('arange' AS NAME), 'inherited', CAST(FALSE AS BOOLEAN), 'range_empty_frac', CAST(0.5 AS FLOAT), 'range_length_histogram', CAST('{399,499,Infinity}' AS TEXT));
SELECT * FROM x WHERE x = 'stats_import' AND x = 'test' AND x = FALSE AND x = 'arange';
/* warn: range bounds histogram on scalar, rest ok */ SELECT x.pg_restore_attribute_stats('relation', CAST('stats_import.test' AS REGCLASS), 'attname', CAST('id' AS NAME), 'inherited', CAST(FALSE AS BOOLEAN), 'null_frac', CAST(0.31 AS FLOAT), 'range_bounds_histogram', CAST('{"[-1,1)","[0,4)","[1,4)","[1,100)"}' AS TEXT));
SELECT * FROM x WHERE x = 'stats_import' AND x = 'test' AND x = FALSE AND x = 'id';
/* ok: range_bounds_histogram */ SELECT x.pg_restore_attribute_stats('relation', CAST('stats_import.test' AS REGCLASS), 'attname', CAST('arange' AS NAME), 'inherited', CAST(FALSE AS BOOLEAN), 'range_bounds_histogram', CAST('{"[-1,1)","[0,4)","[1,4)","[1,100)"}' AS TEXT));
SELECT * FROM x WHERE x = 'stats_import' AND x = 'test' AND x = FALSE AND x = 'arange';
/* warn: cannot set most_common_elems for range type, rest ok */ SELECT x.pg_restore_attribute_stats('relation', CAST('stats_import.test' AS REGCLASS), 'attname', CAST('arange' AS NAME), 'inherited', CAST(FALSE AS BOOLEAN), 'null_frac', CAST(0.32 AS FLOAT), 'most_common_elems', CAST('{3,1}' AS TEXT), 'most_common_elem_freqs', CAST('{0.3,0.2,0.2,0.3,0.0}' AS ARRAY<FLOAT>));
SELECT * FROM x WHERE x = 'stats_import' AND x = 'test' AND x = FALSE AND x = 'arange';
/* warn: scalars can't have mcelem, rest ok */ SELECT x.pg_restore_attribute_stats('relation', CAST('stats_import.test' AS REGCLASS), 'attname', CAST('id' AS NAME), 'inherited', CAST(FALSE AS BOOLEAN), 'null_frac', CAST(0.33 AS FLOAT), 'most_common_elems', CAST('{1,3}' AS TEXT), 'most_common_elem_freqs', CAST('{0.3,0.2,0.2,0.3,0.0}' AS ARRAY<FLOAT>));
SELECT * FROM x WHERE x = 'stats_import' AND x = 'test' AND x = FALSE AND x = 'id';
/* warn: mcelem / mcelem mismatch, rest ok */ SELECT x.pg_restore_attribute_stats('relation', CAST('stats_import.test' AS REGCLASS), 'attname', CAST('tags' AS NAME), 'inherited', CAST(FALSE AS BOOLEAN), 'null_frac', CAST(0.34 AS FLOAT), 'most_common_elems', CAST('{one,two}' AS TEXT));
SELECT * FROM x WHERE x = 'stats_import' AND x = 'test' AND x = FALSE AND x = 'tags';
/* warn: mcelem / mcelem null mismatch part 2, rest ok */ SELECT x.pg_restore_attribute_stats('relation', CAST('stats_import.test' AS REGCLASS), 'attname', CAST('tags' AS NAME), 'inherited', CAST(FALSE AS BOOLEAN), 'null_frac', CAST(0.35 AS FLOAT), 'most_common_elem_freqs', CAST('{0.3,0.2,0.2,0.3}' AS ARRAY<FLOAT>));
SELECT * FROM x WHERE x = 'stats_import' AND x = 'test' AND x = FALSE AND x = 'tags';
/* ok: mcelem */ SELECT x.pg_restore_attribute_stats('relation', CAST('stats_import.test' AS REGCLASS), 'attname', CAST('tags' AS NAME), 'inherited', CAST(FALSE AS BOOLEAN), 'most_common_elems', CAST('{one,three}' AS TEXT), 'most_common_elem_freqs', CAST('{0.3,0.2,0.2,0.3,0.0}' AS ARRAY<FLOAT>));
SELECT * FROM x WHERE x = 'stats_import' AND x = 'test' AND x = FALSE AND x = 'tags';
/* warn: scalars can't have elem_count_histogram, rest ok */ SELECT x.pg_restore_attribute_stats('relation', CAST('stats_import.test' AS REGCLASS), 'attname', CAST('id' AS NAME), 'inherited', CAST(FALSE AS BOOLEAN), 'null_frac', CAST(0.36 AS FLOAT), 'elem_count_histogram', CAST('{1,1,1,1,1,1,1,1,1,1}' AS ARRAY<FLOAT>));
SELECT * FROM x WHERE x = 'stats_import' AND x = 'test' AND x = FALSE AND x = 'id';
/* Test the ability to exactly copy data from one table to an identical table, */ /* correctly reconstructing the stakind order as well as the staopN and */ /* stacollN values. Because oids are not stable across databases, we can only */ /* test this when the source and destination are on the same database */ /* instance. For that reason, we borrow and adapt a query found in fe_utils */ /* and used by pg_dump/pg_upgrade. */ INSERT INTO x.x SELECT 1, 'one', CAST((1, 1.1, 'ONE', '2001-01-01', '{ "xkey": "xval" }') AS stats_import.complex_type), INT4RANGE(1, 4), ARRAY('red', 'green') UNION ALL SELECT 2, 'two', CAST((2, 2.2, 'TWO', '2002-02-02', '[true, 4, "six"]') AS stats_import.complex_type), INT4RANGE(1, 4), ARRAY('blue', 'yellow') UNION ALL SELECT 3, 'tre', CAST((3, 3.3, 'TRE', '2003-03-03', NULL) AS stats_import.complex_type), INT4RANGE(-1, 1), ARRAY('"orange"', 'purple', 'cyan') UNION ALL SELECT 4, 'four', NULL, INT4RANGE(0, 100), NULL;
CREATE INDEX x ON x.x(((x).x % 2 = 1) NULLS LAST);
ANALYZE x.x /* Generate statistics on table with data */;
CREATE TABLE x.x (LIKE x.x) WITH (autovacuum_enabled=FALSE);
CREATE INDEX x ON x.x(((x).x % 2 = 1) NULLS LAST);
/* Copy stats from test to test_clone, and is_odd to is_odd_clone */ SELECT x.x, x.x, x.x, x.x, x.* FROM x.x AS x CROSS JOIN LATERAL x.pg_restore_attribute_stats('relation', CAST(('stats_import.' || x.x || '_clone') AS REGCLASS), 'attname', x.x, 'inherited', x.x, 'version', 150000, 'null_frac', x.x, 'avg_width', x.x, 'n_distinct', x.x, 'most_common_vals', CAST(x.x AS TEXT), 'most_common_freqs', x.x, 'histogram_bounds', CAST(x.x AS TEXT), 'correlation', x.x, 'most_common_elems', CAST(x.x AS TEXT), 'most_common_elem_freqs', x.x, 'elem_count_histogram', x.x, 'range_bounds_histogram', CAST(x.x AS TEXT), 'range_empty_frac', x.x, 'range_length_histogram', CAST(x.x AS TEXT)) AS x WHERE x.x = 'stats_import' AND x.x IN ('test', 'is_odd') ORDER BY x.x NULLS LAST, x.x NULLS LAST, x.x NULLS LAST;
SELECT x.x, COUNT(*) AS x FROM x AS x JOIN x AS x ON x.x = x.x WHERE x.x = CAST('stats_import' AS REGNAMESPACE) AND x.x IN ('test', 'test_clone', 'is_odd', 'is_odd_clone') GROUP BY x.x ORDER BY x.x NULLS LAST;
/* check test minus test_clone */ SELECT x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, CAST(x.x AS TEXT) AS x, CAST(x.x AS TEXT) AS x, CAST(x.x AS TEXT) AS x, CAST(x.x AS TEXT) AS x, CAST(x.x AS TEXT) AS x, 'test' AS x FROM x AS x JOIN x AS x ON x.x = x.x AND x.x = x.x WHERE x.x = CAST('stats_import.test' AS REGCLASS) EXCEPT SELECT x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, CAST(x.x AS TEXT) AS x, CAST(x.x AS TEXT) AS x, CAST(x.x AS TEXT) AS x, CAST(x.x AS TEXT) AS x, CAST(x.x AS TEXT) AS x, 'test' AS x FROM x AS x JOIN x AS x ON x.x = x.x AND x.x = x.x WHERE x.x = CAST('stats_import.test_clone' AS REGCLASS);
/* check test_clone minus test */ SELECT x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, CAST(x.x AS TEXT) AS x, CAST(x.x AS TEXT) AS x, CAST(x.x AS TEXT) AS x, CAST(x.x AS TEXT) AS x, CAST(x.x AS TEXT) AS x, 'test_clone' AS x FROM x AS x JOIN x AS x ON x.x = x.x AND x.x = x.x WHERE x.x = CAST('stats_import.test_clone' AS REGCLASS) EXCEPT SELECT x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, CAST(x.x AS TEXT) AS x, CAST(x.x AS TEXT) AS x, CAST(x.x AS TEXT) AS x, CAST(x.x AS TEXT) AS x, CAST(x.x AS TEXT) AS x, 'test_clone' AS x FROM x AS x JOIN x AS x ON x.x = x.x AND x.x = x.x WHERE x.x = CAST('stats_import.test' AS REGCLASS);
/* check is_odd minus is_odd_clone */ SELECT x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, CAST(x.x AS TEXT) AS x, CAST(x.x AS TEXT) AS x, CAST(x.x AS TEXT) AS x, CAST(x.x AS TEXT) AS x, CAST(x.x AS TEXT) AS x, 'is_odd' AS x FROM x AS x JOIN x AS x ON x.x = x.x AND x.x = x.x WHERE x.x = CAST('stats_import.is_odd' AS REGCLASS) EXCEPT SELECT x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, CAST(x.x AS TEXT) AS x, CAST(x.x AS TEXT) AS x, CAST(x.x AS TEXT) AS x, CAST(x.x AS TEXT) AS x, CAST(x.x AS TEXT) AS x, 'is_odd' AS x FROM x AS x JOIN x AS x ON x.x = x.x AND x.x = x.x WHERE x.x = CAST('stats_import.is_odd_clone' AS REGCLASS);
/* check is_odd_clone minus is_odd */ SELECT x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, CAST(x.x AS TEXT) AS x, CAST(x.x AS TEXT) AS x, CAST(x.x AS TEXT) AS x, CAST(x.x AS TEXT) AS x, CAST(x.x AS TEXT) AS x, 'is_odd_clone' AS x FROM x AS x JOIN x AS x ON x.x = x.x AND x.x = x.x WHERE x.x = CAST('stats_import.is_odd_clone' AS REGCLASS) EXCEPT SELECT x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, x.x, CAST(x.x AS TEXT) AS x, CAST(x.x AS TEXT) AS x, CAST(x.x AS TEXT) AS x, CAST(x.x AS TEXT) AS x, CAST(x.x AS TEXT) AS x, 'is_odd_clone' AS x FROM x AS x JOIN x AS x ON x.x = x.x AND x.x = x.x WHERE x.x = CAST('stats_import.is_odd' AS REGCLASS);
/* attribute stats exist before a clear, but not after */ SELECT COUNT(*) FROM x WHERE x = 'stats_import' AND x = 'test' AND x = FALSE AND x = 'arange';
SELECT x.pg_clear_attribute_stats(relation => CAST('stats_import.test' AS REGCLASS), attname => CAST('arange' AS NAME), inherited => CAST(FALSE AS BOOLEAN));
SELECT COUNT(*) FROM x WHERE x = 'stats_import' AND x = 'test' AND x = FALSE AND x = 'arange';
DROP SCHEMA x.x CASCADE;
/* STRINGS */ /* Test various data entry syntaxes. */ /* SQL string continuation syntax */ /* E021-03 character string literals */ SELECT CONCAT('first line', ' - next line', ' - third line') AS "x";
/* illegal string continuation syntax */ SELECT CONCAT('first line', ' - next line', ' - third line') AS "x";
SET x = on /* Unicode escapes */;
SELECT x & 'a\\b' AS "x";
SELECT x & 'wrong: \061';
SELECT x & 'wrong: \+0061';
SELECT x & 'wrong: \db99';
SELECT x & 'wrong: \db99xy';
SELECT x & 'wrong: \db99\\';
SELECT x & 'wrong: \db99\0061';
SELECT x & 'wrong: \+00db99\+000061';
SELECT x & 'wrong: \+2FFFFF';
/* while we're here, check the same cases in E-style literals */ SELECT d\u0061t\U00000061 AS "x";
SELECT a\\b AS "x";
SELECT wrong: \u061;
SELECT wrong: \U0061;
SELECT wrong: \udb99;
SELECT wrong: \udb99xy;
SELECT wrong: \udb99\\;
SELECT wrong: \udb99\u0061;
SELECT wrong: \U0000db99\U00000061;
SELECT wrong: \U002FFFFF;
SET x = off;
SELECT x & 'wrong: \061';
SELECT x & 'wrong: \+0061';
RESET standard_conforming_strings;
SET x = hex /* bytea */;
SELECT CAST(\\xDeAdBeEf AS VARBINARY);
SELECT CAST(\\x De Ad Be Ef  AS VARBINARY);
SELECT CAST(\\xDeAdBeE AS VARBINARY);
SELECT CAST(\\xDeAdBeEx AS VARBINARY);
SELECT CAST(\\xDe00BeEf AS VARBINARY);
SELECT CAST(DeAdBeEf AS VARBINARY);
SELECT CAST(De\\000dBeEf AS VARBINARY);
SELECT CAST(De\123dBeEf AS VARBINARY);
SELECT CAST(De\\123dBeEf AS VARBINARY);
SELECT CAST(De\\678dBeEf AS VARBINARY);
SELECT REVERSE(CAST('' AS VARBINARY));
SELECT REVERSE(CAST('\xaa' AS VARBINARY));
SELECT REVERSE(CAST('\xabcd' AS VARBINARY));
SET x = escape;
SELECT CAST(\\xDeAdBeEf AS VARBINARY);
SELECT CAST(\\x De Ad Be Ef  AS VARBINARY);
SELECT CAST(\\xDe00BeEf AS VARBINARY);
SELECT CAST(DeAdBeEf AS VARBINARY);
SELECT CAST(De\\000dBeEf AS VARBINARY);
SELECT CAST(De\\123dBeEf AS VARBINARY);
/* Test non-error-throwing API too */ SELECT PG_INPUT_IS_VALID(\\xDeAdBeE, 'bytea');
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
/* test conversions between various string types */ /* E021-10 implicit casting among the character data types */ SELECT CAST(x AS TEXT) AS "x" FROM x;
SELECT CAST(x AS TEXT) AS "x" FROM x;
SELECT CAST(CAST('namefield' AS NAME) AS TEXT) AS "x";
/* since this is an explicit cast, it should truncate w/o error: */ SELECT CAST(x AS CHAR(10)) AS "x" FROM x;
/* note: implicit-cast case is tested in char.sql */ SELECT CAST(x AS CHAR(20)) AS "x" FROM x;
SELECT CAST(x AS CHAR(10)) AS "x" FROM x;
SELECT CAST(CAST('namefield' AS NAME) AS CHAR(10)) AS "x";
SELECT CAST(x AS VARCHAR) AS "x" FROM x;
SELECT CAST(x AS VARCHAR) AS "x" FROM x;
SELECT CAST(CAST('namefield' AS NAME) AS VARCHAR) AS "x";
/* test SQL string functions */ /* E### and T### are feature reference numbers from SQL99 */ /* E021-09 trim function */ SELECT TRIM('  bunch o blanks  ') = 'bunch o blanks' AS "x";
SELECT LTRIM('  bunch o blanks  ') = 'bunch o blanks  ' AS "x";
SELECT RTRIM('  bunch o blanks  ') = '  bunch o blanks' AS "x";
SELECT TRIM('xxxxxsome Xsxxxxx', 'x') = 'some Xs' AS "x";
/* E021-06 substring expression */ SELECT SUBSTRING('1234567890', 3) = '34567890' AS "x";
SELECT SUBSTRING('1234567890', 4, 3) = '456' AS "x";
/* test overflow cases */ SELECT SUBSTRING('string', 2, 2147483646) AS "x";
SELECT SUBSTRING('string', -10, 2147483646) AS "x";
SELECT SUBSTRING('string', -10, -2147483646) AS "x";
/* obsolete SQL99 syntax */ SELECT SUBSTRING('abcdefg', 'a#"(b_d)#"%', '#') AS "x";
/* we accept it, but we interpret the pattern as a POSIX regexp not SQL */ SELECT SUBSTRING('abcdefg', 'c.e') AS "x";
/* With a parenthesized subexpression, return only what matches the subexpr */ SELECT SUBSTRING('abcdefg', 'b(.*)f') AS "x";
/* Check case where we have a match, but not a subexpression match */ SELECT SUBSTRING('foo', 'foo(bar)?') IS NULL AS x;
/* Check behavior of SIMILAR TO, which uses largely the same regexp variant */ SELECT 'abcdefg' SIMILAR TO '_bcd%' AS x;
SELECT 'abcdefg' SIMILAR TO 'bcd%' AS x;
SELECT 'abcdefg' SIMILAR TO '_bcd#%' ESCAPE '#' AS x;
SELECT 'abcd%' SIMILAR TO '_bcd#%' ESCAPE '#' AS x;
/* Postgres uses '\' as the default escape character, which is not per spec */ SELECT 'abcdefg' SIMILAR TO '_bcd\%' AS x;
/* and an empty string to mean "no escape", which is also not per spec */ SELECT 'abcd\efg' SIMILAR TO '_bcd\%' ESCAPE '' AS x;
SELECT 'abcdefg' SIMILAR TO '_bcd#%' ESCAPE '##' AS x;
/* Test backslash escapes in regexp_replace's replacement string */ SELECT REGEXP_REPLACE('1112223333', (\\d{3})(\\d{3})(\\d{4}), (\\1) \\2-\\3);
SELECT REGEXP_REPLACE('foobarrbazz', (.)\\1, X\\&Y, 'g');
SELECT REGEXP_REPLACE('foobarrbazz', (.)\\1, X\\\\Y, 'g');
/* not an error, though perhaps it should be: */ SELECT REGEXP_REPLACE('foobarrbazz', (.)\\1, X\\Y\\1Z\\);
SELECT REGEXP_REPLACE('AAA   BBB   CCC   ', \\s+, ' ', 'g');
SELECT REGEXP_REPLACE('AAA', '^|$', 'Z', 'g');
SELECT REGEXP_REPLACE('AAA aaa', 'A+', 'Z', 'gi');
/* invalid regexp option */ SELECT REGEXP_REPLACE('AAA aaa', 'A+', 'Z', 'z');
/* extended regexp_replace tests */ SELECT REGEXP_REPLACE('A PostgreSQL function', 'A|e|i|o|u', 'X', 1);
SELECT REGEXP_REPLACE('A PostgreSQL function', 'A|e|i|o|u', 'X', 1, 2);
SELECT REGEXP_REPLACE('A PostgreSQL function', 'a|e|i|o|u', 'X', 1, 0, 'i');
SELECT REGEXP_REPLACE('A PostgreSQL function', 'a|e|i|o|u', 'X', 1, 1, 'i');
SELECT REGEXP_REPLACE('A PostgreSQL function', 'a|e|i|o|u', 'X', 1, 2, 'i');
SELECT REGEXP_REPLACE('A PostgreSQL function', 'a|e|i|o|u', 'X', 1, 3, 'i');
SELECT REGEXP_REPLACE('A PostgreSQL function', 'a|e|i|o|u', 'X', 1, 9, 'i');
SELECT REGEXP_REPLACE('A PostgreSQL function', 'A|e|i|o|u', 'X', 7, 0, 'i');
/* 'g' flag should be ignored when N is specified */ SELECT REGEXP_REPLACE('A PostgreSQL function', 'a|e|i|o|u', 'X', 1, 1, 'g');
/* errors */ SELECT REGEXP_REPLACE('A PostgreSQL function', 'a|e|i|o|u', 'X', -1, 0, 'i');
SELECT REGEXP_REPLACE('A PostgreSQL function', 'a|e|i|o|u', 'X', 1, -1, 'i');
/* erroneous invocation of non-extended form */ SELECT REGEXP_REPLACE('A PostgreSQL function', 'a|e|i|o|u', 'X', '1');
/*  regexp_count tests */ SELECT REGEXP_COUNT('123123123123123', '(12)3');
SELECT REGEXP_COUNT('123123123123', '123', 1);
SELECT REGEXP_COUNT('123123123123', '123', 3);
SELECT REGEXP_COUNT('123123123123', '123', 33);
SELECT REGEXP_COUNT('ABCABCABCABC', 'Abc', 1, '');
SELECT REGEXP_COUNT('ABCABCABCABC', 'Abc', 1, 'i');
/* errors */ SELECT REGEXP_COUNT('123123123123', '123', 0);
SELECT REGEXP_COUNT('123123123123', '123', -3);
/* regexp_like tests */ SELECT REGEXP_LIKE('Steven', '^Ste(v|ph)en$');
SELECT REGEXP_LIKE('a' || CHR(10) || 'd', 'a.d', 'n');
SELECT REGEXP_LIKE('a' || CHR(10) || 'd', 'a.d', 's');
SELECT REGEXP_LIKE('abc', ' a . c ', 'x');
SELECT REGEXP_LIKE('abc', 'a.c', 'g');
/* error */ /* regexp_instr tests */ SELECT REGEXP_INSTR('abcdefghi', 'd.f');
SELECT REGEXP_INSTR('abcdefghi', 'd.q');
SELECT REGEXP_INSTR('abcabcabc', 'a.c');
SELECT REGEXP_INSTR('abcabcabc', 'a.c', 2);
SELECT REGEXP_INSTR('abcabcabc', 'a.c', 1, 3);
SELECT REGEXP_INSTR('abcabcabc', 'a.c', 1, 4);
SELECT REGEXP_INSTR('abcabcabc', 'A.C', 1, 2, 0, 'i');
SELECT REGEXP_INSTR('1234567890', '(123)(4(56)(78))', 1, 1, 0, 'i', 0);
SELECT REGEXP_INSTR('1234567890', '(123)(4(56)(78))', 1, 1, 0, 'i', 1);
SELECT REGEXP_INSTR('1234567890', '(123)(4(56)(78))', 1, 1, 0, 'i', 2);
SELECT REGEXP_INSTR('1234567890', '(123)(4(56)(78))', 1, 1, 0, 'i', 3);
SELECT REGEXP_INSTR('1234567890', '(123)(4(56)(78))', 1, 1, 0, 'i', 4);
SELECT REGEXP_INSTR('1234567890', '(123)(4(56)(78))', 1, 1, 0, 'i', 5);
SELECT REGEXP_INSTR('1234567890', '(123)(4(56)(78))', 1, 1, 1, 'i', 0);
SELECT REGEXP_INSTR('1234567890', '(123)(4(56)(78))', 1, 1, 1, 'i', 1);
SELECT REGEXP_INSTR('1234567890', '(123)(4(56)(78))', 1, 1, 1, 'i', 2);
SELECT REGEXP_INSTR('1234567890', '(123)(4(56)(78))', 1, 1, 1, 'i', 3);
SELECT REGEXP_INSTR('1234567890', '(123)(4(56)(78))', 1, 1, 1, 'i', 4);
SELECT REGEXP_INSTR('1234567890', '(123)(4(56)(78))', 1, 1, 1, 'i', 5);
/* Check case where we have a match, but not a subexpression match */ SELECT REGEXP_INSTR('foo', 'foo(bar)?', 1, 1, 0, '', 1);
/* errors */ SELECT REGEXP_INSTR('abcabcabc', 'a.c', 0, 1);
SELECT REGEXP_INSTR('abcabcabc', 'a.c', 1, 0);
SELECT REGEXP_INSTR('abcabcabc', 'a.c', 1, 1, -1);
SELECT REGEXP_INSTR('abcabcabc', 'a.c', 1, 1, 2);
SELECT REGEXP_INSTR('abcabcabc', 'a.c', 1, 1, 0, 'g');
SELECT REGEXP_INSTR('abcabcabc', 'a.c', 1, 1, 0, '', -1);
/* regexp_substr tests */ SELECT REGEXP_SUBSTR('abcdefghi', 'd.f');
SELECT REGEXP_SUBSTR('abcdefghi', 'd.q') IS NULL AS x;
SELECT REGEXP_SUBSTR('abcabcabc', 'a.c');
SELECT REGEXP_SUBSTR('abcabcabc', 'a.c', 2);
SELECT REGEXP_SUBSTR('abcabcabc', 'a.c', 1, 3);
SELECT REGEXP_SUBSTR('abcabcabc', 'a.c', 1, 4) IS NULL AS x;
SELECT REGEXP_SUBSTR('abcabcabc', 'A.C', 1, 2, 'i');
SELECT REGEXP_SUBSTR('1234567890', '(123)(4(56)(78))', 1, 1, 'i', 0);
SELECT REGEXP_SUBSTR('1234567890', '(123)(4(56)(78))', 1, 1, 'i', 1);
SELECT REGEXP_SUBSTR('1234567890', '(123)(4(56)(78))', 1, 1, 'i', 2);
SELECT REGEXP_SUBSTR('1234567890', '(123)(4(56)(78))', 1, 1, 'i', 3);
SELECT REGEXP_SUBSTR('1234567890', '(123)(4(56)(78))', 1, 1, 'i', 4);
SELECT REGEXP_SUBSTR('1234567890', '(123)(4(56)(78))', 1, 1, 'i', 5) IS NULL AS x;
/* Check case where we have a match, but not a subexpression match */ SELECT REGEXP_SUBSTR('foo', 'foo(bar)?', 1, 1, '', 1) IS NULL AS x;
/* errors */ SELECT REGEXP_SUBSTR('abcabcabc', 'a.c', 0, 1);
SELECT REGEXP_SUBSTR('abcabcabc', 'a.c', 1, 0);
SELECT REGEXP_SUBSTR('abcabcabc', 'a.c', 1, 1, 'g');
SELECT REGEXP_SUBSTR('abcabcabc', 'a.c', 1, 1, '', -1);
/* test case insensitive */ SELECT REGEXP_MATCHES('foObARbEqUEbAz', '(bar)(beque)', 'i');
/* global option - more than one match */ SELECT REGEXP_MATCHES('foobarbequebazilbarfbonk', '(b[^b]+)(b[^b]+)', 'g');
/* empty capture group (matched empty string) */ SELECT REGEXP_MATCHES('foobarbequebaz', '(bar)(.*)(beque)');
/* no match */ SELECT REGEXP_MATCHES('foobarbequebaz', '(bar)(.+)(beque)');
/* optional capture group did not match, null entry in array */ SELECT REGEXP_MATCHES('foobarbequebaz', '(bar)(.+)?(beque)');
/* no capture groups */ SELECT REGEXP_MATCHES('foobarbequebaz', 'barbeque');
/* start/end-of-line matches are of zero length */ SELECT REGEXP_MATCHES('foo' || CHR(10) || 'bar' || CHR(10) || 'bequq' || CHR(10) || 'baz', '^', 'mg');
SELECT REGEXP_MATCHES('foo' || CHR(10) || 'bar' || CHR(10) || 'bequq' || CHR(10) || 'baz', '$', 'mg');
SELECT REGEXP_MATCHES('1' || CHR(10) || '2' || CHR(10) || '3' || CHR(10) || '4' || CHR(10), '^.?', 'mg');
SELECT REGEXP_MATCHES(CHR(10) || '1' || CHR(10) || '2' || CHR(10) || '3' || CHR(10) || '4' || CHR(10), '.?$', 'mg');
SELECT REGEXP_MATCHES(CHR(10) || '1' || CHR(10) || '2' || CHR(10) || '3' || CHR(10) || '4', '.?$', 'mg');
/* give me errors */ SELECT REGEXP_MATCHES('foobarbequebaz', '(bar)(beque)', 'gz');
SELECT REGEXP_MATCHES('foobarbequebaz', '(barbeque');
SELECT REGEXP_MATCHES('foobarbequebaz', '(bar)(beque){2,1}');
/* split string on regexp */ SELECT x, LENGTH(x) FROM x AS x;
SELECT REGEXP_SPLIT_TO_ARRAY('the quick brown fox jumps over the lazy dog', '\\s+');
SELECT x, LENGTH(x) FROM x AS x;
SELECT REGEXP_SPLIT_TO_ARRAY('the quick brown fox jumps over the lazy dog', '\\s*');
SELECT x, LENGTH(x) FROM x AS x;
SELECT REGEXP_SPLIT_TO_ARRAY('the quick brown fox jumps over the lazy dog', '');
/* case insensitive */ SELECT x, LENGTH(x) FROM x AS x;
SELECT REGEXP_SPLIT_TO_ARRAY('thE QUick bROWn FOx jUMPs ovEr The lazy dOG', 'e', 'i');
/* no match of pattern */ SELECT x, LENGTH(x) FROM x AS x;
SELECT REGEXP_SPLIT_TO_ARRAY('the quick brown fox jumps over the lazy dog', 'nomatch');
/* some corner cases */ SELECT REGEXP_SPLIT_TO_ARRAY('123456', '1');
SELECT REGEXP_SPLIT_TO_ARRAY('123456', '6');
SELECT REGEXP_SPLIT_TO_ARRAY('123456', '.');
SELECT REGEXP_SPLIT_TO_ARRAY('123456', '');
SELECT REGEXP_SPLIT_TO_ARRAY('123456', '(?:)');
SELECT REGEXP_SPLIT_TO_ARRAY('1', '');
/* errors */ SELECT x, LENGTH(x) FROM x AS x;
SELECT REGEXP_SPLIT_TO_ARRAY('thE QUick bROWn FOx jUMPs ovEr The lazy dOG', 'e', 'iz');
/* global option meaningless for regexp_split */ SELECT x, LENGTH(x) FROM x AS x;
SELECT REGEXP_SPLIT_TO_ARRAY('thE QUick bROWn FOx jUMPs ovEr The lazy dOG', 'e', 'g');
SELECT STR_POSITION('1234567890', '5') = '5' AS "x";
/* T312 character overlay function */ SELECT OVERLAY('abcdef' PLACING '45' FROM 4) AS "x";
SELECT OVERLAY('yabadoo' PLACING 'daba' FROM 5) AS "x";
SELECT OVERLAY('yabadoo' PLACING 'daba' FROM 5 FOR 0) AS "x";
SELECT OVERLAY('babosa' PLACING 'ubb' FROM 2 FOR 4) AS "x";
/* test LIKE */ /* Be sure to form every test as a LIKE/NOT LIKE pair. */ /* simplest examples */ /* E061-04 like predicate */ SELECT 'hawkeye' LIKE 'h%' AS "x";
SELECT NOT 'hawkeye' LIKE 'h%' AS "x";
SELECT 'hawkeye' LIKE 'H%' AS "x";
SELECT NOT 'hawkeye' LIKE 'H%' AS "x";
SELECT 'hawkeye' LIKE 'indio%' AS "x";
SELECT NOT 'hawkeye' LIKE 'indio%' AS "x";
SELECT 'hawkeye' LIKE 'h%eye' AS "x";
SELECT NOT 'hawkeye' LIKE 'h%eye' AS "x";
SELECT 'indio' LIKE '_ndio' AS "x";
SELECT NOT 'indio' LIKE '_ndio' AS "x";
SELECT 'indio' LIKE 'in__o' AS "x";
SELECT NOT 'indio' LIKE 'in__o' AS "x";
SELECT 'indio' LIKE 'in_o' AS "x";
SELECT NOT 'indio' LIKE 'in_o' AS "x";
SELECT CAST('abc' AS NAME) LIKE '_b_' AS "x";
SELECT NOT CAST('abc' AS NAME) LIKE '_b_' AS "x";
SELECT CAST('abc' AS VARBINARY) LIKE CAST('_b_' AS VARBINARY) AS "x";
SELECT NOT CAST('abc' AS VARBINARY) LIKE CAST('_b_' AS VARBINARY) AS "x";
/* unused escape character */ SELECT 'hawkeye' LIKE 'h%' ESCAPE '#' AS "x";
SELECT NOT 'hawkeye' LIKE 'h%' ESCAPE '#' AS "x";
SELECT 'indio' LIKE 'ind_o' ESCAPE '$' AS "x";
SELECT NOT 'indio' LIKE 'ind_o' ESCAPE '$' AS "x";
/* escape character */ /* E061-05 like predicate with escape clause */ SELECT 'h%' LIKE 'h#%' ESCAPE '#' AS "x";
SELECT NOT 'h%' LIKE 'h#%' ESCAPE '#' AS "x";
SELECT 'h%wkeye' LIKE 'h#%' ESCAPE '#' AS "x";
SELECT NOT 'h%wkeye' LIKE 'h#%' ESCAPE '#' AS "x";
SELECT 'h%wkeye' LIKE 'h#%%' ESCAPE '#' AS "x";
SELECT NOT 'h%wkeye' LIKE 'h#%%' ESCAPE '#' AS "x";
SELECT 'h%awkeye' LIKE 'h#%a%k%e' ESCAPE '#' AS "x";
SELECT NOT 'h%awkeye' LIKE 'h#%a%k%e' ESCAPE '#' AS "x";
SELECT 'indio' LIKE '_ndio' ESCAPE '$' AS "x";
SELECT NOT 'indio' LIKE '_ndio' ESCAPE '$' AS "x";
SELECT 'i_dio' LIKE 'i$_d_o' ESCAPE '$' AS "x";
SELECT NOT 'i_dio' LIKE 'i$_d_o' ESCAPE '$' AS "x";
SELECT 'i_dio' LIKE 'i$_nd_o' ESCAPE '$' AS "x";
SELECT NOT 'i_dio' LIKE 'i$_nd_o' ESCAPE '$' AS "x";
SELECT 'i_dio' LIKE 'i$_d%o' ESCAPE '$' AS "x";
SELECT NOT 'i_dio' LIKE 'i$_d%o' ESCAPE '$' AS "x";
/* escape character same as pattern character */ SELECT 'maca' LIKE 'm%aca' ESCAPE '%' AS "x";
SELECT NOT 'maca' LIKE 'm%aca' ESCAPE '%' AS "x";
SELECT 'ma%a' LIKE 'm%a%%a' ESCAPE '%' AS "x";
SELECT NOT 'ma%a' LIKE 'm%a%%a' ESCAPE '%' AS "x";
SELECT 'bear' LIKE 'b_ear' ESCAPE '_' AS "x";
SELECT NOT 'bear' LIKE 'b_ear' ESCAPE '_' AS "x";
SELECT 'be_r' LIKE 'b_e__r' ESCAPE '_' AS "x";
SELECT NOT 'be_r' LIKE 'b_e__r' ESCAPE '_' AS "x";
SELECT 'be_r' LIKE '__e__r' ESCAPE '_' AS "x";
SELECT NOT 'be_r' LIKE '__e__r' ESCAPE '_' AS "x";
/* test ILIKE (case-insensitive LIKE) */ /* Be sure to form every test as an ILIKE/NOT ILIKE pair. */ SELECT 'hawkeye' ILIKE 'h%' AS "x";
SELECT NOT 'hawkeye' ILIKE 'h%' AS "x";
SELECT 'hawkeye' ILIKE 'H%' AS "x";
SELECT NOT 'hawkeye' ILIKE 'H%' AS "x";
SELECT 'hawkeye' ILIKE 'H%Eye' AS "x";
SELECT NOT 'hawkeye' ILIKE 'H%Eye' AS "x";
SELECT 'Hawkeye' ILIKE 'h%' AS "x";
SELECT NOT 'Hawkeye' ILIKE 'h%' AS "x";
SELECT CAST('ABC' AS NAME) ILIKE '_b_' AS "x";
SELECT NOT CAST('ABC' AS NAME) ILIKE '_b_' AS "x";
/* test %/_ combination cases, cf bugs #4821 and #5478 */ SELECT 'foo' LIKE '_%' AS x, 'f' LIKE '_%' AS x, '' LIKE '_%' AS x;
SELECT 'foo' LIKE '%_' AS x, 'f' LIKE '%_' AS x, '' LIKE '%_' AS x;
SELECT 'foo' LIKE '__%' AS x, 'foo' LIKE '___%' AS x, 'foo' LIKE '____%' AS x;
SELECT 'foo' LIKE '%__' AS x, 'foo' LIKE '%___' AS x, 'foo' LIKE '%____' AS x;
SELECT 'jack' LIKE '%____%' AS x;
/* basic tests of LIKE with indexes */ CREATE TABLE x (x TEXT PRIMARY KEY, x INT);
SELECT * FROM x WHERE x LIKE '%1%';
CREATE TABLE x (x VARBINARY PRIMARY KEY, x INT);
SELECT * FROM x WHERE x LIKE '%1%';
/* test implicit type conversion */ /* E021-07 character concatenation */ SELECT 'unknown' || ' and unknown' AS "x";
SELECT CAST('text' AS TEXT) || ' and unknown' AS "x";
SELECT CAST('characters' AS CHAR(20)) || ' and text' AS "x";
SELECT CAST('text' AS TEXT) || CAST(' and characters' AS CHAR(20)) AS "x";
SELECT CAST('text' AS TEXT) || CAST(' and varchar' AS VARCHAR) AS "x";
/* test substr with toasted text values */ CREATE TABLE x (x TEXT);
INSERT INTO x VALUES (REPEAT('1234567890', 10000));
INSERT INTO x VALUES (REPEAT('1234567890', 10000));
ALTER TABLE x ALTER COLUMN x DROP DEFAULT, set storage external /* Ensure that some values are uncompressed, to test the faster substring */ /* operation used in that case */;
INSERT INTO x VALUES (REPEAT('1234567890', 10000));
INSERT INTO x VALUES (REPEAT('1234567890', 10000));
/* If the starting position is zero or less, then return from the start of the string */ /* adjusting the length to be consistent with the "negative start" per SQL. */ SELECT SUBSTRING(x, -1, 5) FROM x;
/* If the length is less than zero, an ERROR is thrown. */ SELECT SUBSTRING(x, 5, -1) FROM x;
/* If no third argument (length) is provided, the length to the end of the */ /* string is assumed. */ SELECT SUBSTRING(x, 99995) FROM x;
/* If start plus length is > string length, the result is truncated to */ /* string length */ SELECT SUBSTRING(x, 99995, 10) FROM x;
TRUNCATE TABLE x;
INSERT INTO x VALUES (REPEAT('1234567890', 300));
INSERT INTO x VALUES (REPEAT('1234567890', 300));
INSERT INTO x VALUES (REPEAT('1234567890', 300));
INSERT INTO x VALUES (REPEAT('1234567890', 300));
/* expect >0 blocks */ SELECT PG_RELATION_SIZE(x) = 0 AS x FROM x WHERE x = 'toasttest';
TRUNCATE TABLE x;
ALTER TABLE x SET x = 4080;
INSERT INTO x VALUES (REPEAT('1234567890', 300));
INSERT INTO x VALUES (REPEAT('1234567890', 300));
INSERT INTO x VALUES (REPEAT('1234567890', 300));
INSERT INTO x VALUES (REPEAT('1234567890', 300));
/* expect 0 blocks */ SELECT PG_RELATION_SIZE(x) = 0 AS x FROM x WHERE x = 'toasttest';
DROP TABLE x;
/* test substr with toasted bytea values */ CREATE TABLE x (x VARBINARY);
INSERT INTO x VALUES (DECODE(REPEAT('1234567890', 10000), 'escape'));
INSERT INTO x VALUES (DECODE(REPEAT('1234567890', 10000), 'escape'));
ALTER TABLE x ALTER COLUMN x DROP DEFAULT, set storage external /* Ensure that some values are uncompressed, to test the faster substring */ /* operation used in that case */;
INSERT INTO x VALUES (DECODE(REPEAT('1234567890', 10000), 'escape'));
INSERT INTO x VALUES (DECODE(REPEAT('1234567890', 10000), 'escape'));
/* If the starting position is zero or less, then return from the start of the string */ /* adjusting the length to be consistent with the "negative start" per SQL. */ SELECT SUBSTRING(x, -1, 5) FROM x;
/* If the length is less than zero, an ERROR is thrown. */ SELECT SUBSTRING(x, 5, -1) FROM x;
/* If no third argument (length) is provided, the length to the end of the */ /* string is assumed. */ SELECT SUBSTRING(x, 99995) FROM x;
/* If start plus length is > string length, the result is truncated to */ /* string length */ SELECT SUBSTRING(x, 99995, 10) FROM x;
DROP TABLE x;
/* test internally compressing datums */ /* this tests compressing a datum to a very small size which exercises a */ /* corner case in packed-varlena handling: even though small, the compressed */ /* datum must be given a 4-byte header because there are no bits to indicate */ /* compression in a 1-byte header */ CREATE TABLE x (x CHAR(4096));
INSERT INTO x VALUES ('x');
SELECT LENGTH(x), CAST(x AS TEXT) FROM x;
SELECT x FROM x;
DROP TABLE x;
/* test length */ SELECT LENGTH('abcdef') AS "x";
/* test strpos */ SELECT STR_POSITION('abcdef', 'cd') AS "x";
SELECT STR_POSITION('abcdef', 'xy') AS "x";
SELECT STR_POSITION('abcdef', '') AS "x";
SELECT STR_POSITION('', 'xy') AS "x";
SELECT STR_POSITION('', '') AS "x";
/* test replace */ SELECT REPLACE('abcdef', 'de', '45') AS "x";
SELECT REPLACE('yabadabadoo', 'ba', '123') AS "x";
SELECT REPLACE('yabadoo', 'bad', '') AS "x";
/* test split_part */ SELECT SPLIT_PART('', '@', 1) AS "x";
SELECT SPLIT_PART('', '@', -1) AS "x";
SELECT SPLIT_PART('joeuser@mydatabase', '', 1) AS "x";
SELECT SPLIT_PART('joeuser@mydatabase', '', 2) AS "x";
SELECT SPLIT_PART('joeuser@mydatabase', '', -1) AS "x";
SELECT SPLIT_PART('joeuser@mydatabase', '', -2) AS "x";
SELECT SPLIT_PART('joeuser@mydatabase', '@', 0) AS "x";
SELECT SPLIT_PART('joeuser@mydatabase', '@@', 1) AS "x";
SELECT SPLIT_PART('joeuser@mydatabase', '@@', 2) AS "x";
SELECT SPLIT_PART('joeuser@mydatabase', '@', 1) AS "x";
SELECT SPLIT_PART('joeuser@mydatabase', '@', 2) AS "x";
SELECT SPLIT_PART('joeuser@mydatabase', '@', 3) AS "x";
SELECT SPLIT_PART('@joeuser@mydatabase@', '@', 2) AS "x";
SELECT SPLIT_PART('joeuser@mydatabase', '@', -1) AS "x";
SELECT SPLIT_PART('joeuser@mydatabase', '@', -2) AS "x";
SELECT SPLIT_PART('joeuser@mydatabase', '@', -3) AS "x";
SELECT SPLIT_PART('@joeuser@mydatabase@', '@', -2) AS "x";
/* test to_bin, to_oct, and to_hex */ SELECT TO_BIN(-1234) AS "x";
SELECT TO_BIN(-CAST(1234 AS BIGINT));
SELECT TO_BIN(256 * 256 * 256 - 1) AS "x";
SELECT TO_BIN(CAST(256 AS BIGINT) * CAST(256 AS BIGINT) * CAST(256 AS BIGINT) * CAST(256 AS BIGINT) - 1) AS "x";
SELECT TO_OCT(-1234) AS "x";
SELECT TO_OCT(-CAST(1234 AS BIGINT)) AS "x";
SELECT TO_OCT(256 * 256 * 256 - 1) AS "x";
SELECT TO_OCT(CAST(256 AS BIGINT) * CAST(256 AS BIGINT) * CAST(256 AS BIGINT) * CAST(256 AS BIGINT) - 1) AS "x";
SELECT HEX(-1234) AS "x";
SELECT HEX(-CAST(1234 AS BIGINT)) AS "x";
SELECT HEX(256 * 256 * 256 - 1) AS "x";
SELECT HEX(CAST(256 AS BIGINT) * CAST(256 AS BIGINT) * CAST(256 AS BIGINT) * CAST(256 AS BIGINT) - 1) AS "x";
SET x = hex /* SHA-2 */;
SELECT SHA224('');
SELECT SHA224('The quick brown fox jumps over the lazy dog.');
SELECT SHA2('', 256);
SELECT SHA2('The quick brown fox jumps over the lazy dog.', 256);
SELECT SHA2('', 384);
SELECT SHA2('The quick brown fox jumps over the lazy dog.', 384);
SELECT SHA2('', 512);
SELECT SHA2('The quick brown fox jumps over the lazy dog.', 512);
/* CRC */ SELECT CRC32('');
SELECT CRC32('The quick brown fox jumps over the lazy dog.');
SELECT CRC32C('');
SELECT CRC32C('The quick brown fox jumps over the lazy dog.');
/* encode/decode */ SELECT ENCODE('\x1234567890abcdef00', 'hex');
SELECT DECODE('1234567890abcdef00', 'hex');
SELECT ENCODE(CAST(('\x' || REPEAT('1234567890abcdef0001', 7)) AS VARBINARY), 'base64');
SELECT DECODE(ENCODE(CAST(('\x' || REPEAT('1234567890abcdef0001', 7)) AS VARBINARY), 'base64'), 'base64');
SELECT ENCODE('\x1234567890abcdef00', 'escape');
SELECT DECODE(ENCODE('\x1234567890abcdef00', 'escape'), 'escape');
/* get_bit/set_bit etc */ SELECT GET_BIT(CAST('\x1234567890abcdef00' AS VARBINARY), 43);
SELECT GET_BIT(CAST('\x1234567890abcdef00' AS VARBINARY), 99);
/* error */ SELECT SET_BIT(CAST('\x1234567890abcdef00' AS VARBINARY), 43, 0);
SELECT SET_BIT(CAST('\x1234567890abcdef00' AS VARBINARY), 99, 0);
/* error */ SELECT GET_BYTE(CAST('\x1234567890abcdef00' AS VARBINARY), 3);
SELECT GET_BYTE(CAST('\x1234567890abcdef00' AS VARBINARY), 99);
/* error */ SELECT SET_BYTE(CAST('\x1234567890abcdef00' AS VARBINARY), 7, 11);
SELECT SET_BYTE(CAST('\x1234567890abcdef00' AS VARBINARY), 99, 11);
/* error */ /* conversions between bytea and integer types */ SELECT CAST(CAST(4660 AS SMALLINT) AS VARBINARY) AS "x", CAST(CAST((-4660) AS SMALLINT) AS VARBINARY) AS "x";
SELECT CAST(CAST(305419896 AS INT) AS VARBINARY) AS "x", CAST(CAST((-305419896) AS INT) AS VARBINARY) AS "x";
SELECT CAST(CAST(1234605616436508552 AS BIGINT) AS VARBINARY) AS "x", CAST(CAST((-1234605616436508552) AS BIGINT) AS VARBINARY) AS "x";
SELECT CAST(CAST('' AS VARBINARY) AS SMALLINT) AS "x";
SELECT CAST(CAST('\x12' AS VARBINARY) AS SMALLINT) AS "x";
SELECT CAST(CAST('\x1234' AS VARBINARY) AS SMALLINT) AS "x";
SELECT CAST(CAST('\x123456' AS VARBINARY) AS SMALLINT);
/* error */ SELECT CAST(CAST('' AS VARBINARY) AS INT) AS "x";
SELECT CAST(CAST('\x12' AS VARBINARY) AS INT) AS "x";
SELECT CAST(CAST('\x12345678' AS VARBINARY) AS INT) AS "x";
SELECT CAST(CAST('\x123456789A' AS VARBINARY) AS INT);
/* error */ SELECT CAST(CAST('' AS VARBINARY) AS BIGINT) AS "x";
SELECT CAST(CAST('\x12' AS VARBINARY) AS BIGINT) AS "x";
SELECT CAST(CAST('\x1122334455667788' AS VARBINARY) AS BIGINT) AS "x";
SELECT CAST(CAST('\x112233445566778899' AS VARBINARY) AS BIGINT);
/* error */ /* min/max integer values */ SELECT CAST(CAST('\x8000' AS VARBINARY) AS SMALLINT) AS "x", CAST(CAST('\x7FFF' AS VARBINARY) AS SMALLINT) AS "x";
SELECT CAST(CAST('\x80000000' AS VARBINARY) AS INT) AS "x", CAST(CAST('\x7FFFFFFF' AS VARBINARY) AS INT) AS "x";
SELECT CAST(CAST('\x8000000000000000' AS VARBINARY) AS BIGINT) AS "x", CAST(CAST('\x7FFFFFFFFFFFFFFF' AS VARBINARY) AS BIGINT) AS "x";
SET x = off /* test behavior of escape_string_warning and standard_conforming_strings options */;
SET x = off;
SHOW escape_string_warning;
SHOW standard_conforming_strings;
SET x = on;
SET x = on;
SHOW escape_string_warning;
SHOW standard_conforming_strings;
SELECT 'a\bcd' AS x, 'a\b''cd' AS x, 'a\b''''cd' AS x, 'abcd\' AS x, 'ab\''cd' AS x, '\\' AS x;
SET x = off;
SET x = off;
SET x = on;
SELECT 'a\bcd' AS x, 'a\b''cd' AS x, 'a\b''''cd' AS x, 'abcd\' AS x, 'ab\''cd' AS x, '\\' AS x;
SET x = off;
RESET standard_conforming_strings;
SET x = escape /* Additional string functions */;
SELECT INITCAP('hi THOMAS');
SELECT LPAD('hi', 5, 'xy');
SELECT LPAD('hi', 5);
SELECT LPAD('hi', -5, 'xy');
SELECT LPAD('hello', 2);
SELECT LPAD('hi', 5, '');
SELECT RPAD('hi', 5, 'xy');
SELECT RPAD('hi', 5);
SELECT RPAD('hi', -5, 'xy');
SELECT RPAD('hello', 2);
SELECT RPAD('hi', 5, '');
SELECT LTRIM('zzzytrim', 'xyz');
SELECT TRANSLATE('', '14', 'ax');
SELECT TRANSLATE('12345', '14', 'ax');
SELECT TRANSLATE('12345', '134', 'a');
SELECT UNICODE('x');
SELECT UNICODE('');
SELECT CHR(65);
SELECT CHR(0);
SELECT REPEAT('Pg', 4);
SELECT REPEAT('Pg', -4);
SELECT SUBSTRING(CAST('1234567890' AS VARBINARY), 3) AS "x";
SELECT SUBSTRING(CAST('1234567890' AS VARBINARY), 4, 3) AS "x";
SELECT SUBSTRING(CAST('string' AS VARBINARY), 2, 2147483646) AS "x";
SELECT SUBSTRING(CAST('string' AS VARBINARY), -10, 2147483646) AS "x";
SELECT SUBSTRING(CAST('string' AS VARBINARY), -10, -2147483646) AS "x";
SELECT TRIM(CAST(\\000Tom\\000 AS VARBINARY), CAST(\\000 AS VARBINARY));
SELECT LTRIM(CAST(\\000Tom\\000 AS VARBINARY), CAST(\\000 AS VARBINARY));
SELECT RTRIM(CAST(\\000Tom\\000 AS VARBINARY), CAST(\\000 AS VARBINARY));
SELECT BTRIM(CAST(\\000trim\\000 AS VARBINARY), CAST(\\000 AS VARBINARY));
SELECT BTRIM(CAST('' AS VARBINARY), CAST(\\000 AS VARBINARY));
SELECT BTRIM(CAST(\\000trim\\000 AS VARBINARY), CAST('' AS VARBINARY));
SELECT ENCODE(OVERLAY(CAST(Th\\000omas AS VARBINARY) PLACING CAST(Th\\001omas AS VARBINARY) FROM 2), 'escape');
SELECT ENCODE(OVERLAY(CAST(Th\\000omas AS VARBINARY) PLACING CAST(\\002\\003 AS VARBINARY) FROM 8), 'escape');
SELECT ENCODE(OVERLAY(CAST(Th\\000omas AS VARBINARY) PLACING CAST(\\002\\003 AS VARBINARY) FROM 5 FOR 3), 'escape');
SELECT BIT_COUNT(CAST('\x1234567890' AS VARBINARY));
SELECT UNISTR('\0064at\+0000610');
SELECT UNISTR('d\u0061t\U000000610');
SELECT UNISTR('a\\b');
/* errors: */ SELECT UNISTR('wrong: \db99');
SELECT UNISTR('wrong: \db99\0061');
SELECT UNISTR('wrong: \+00db99\+000061');
SELECT UNISTR('wrong: \+2FFFFF');
SELECT UNISTR('wrong: \udb99\u0061');
SELECT UNISTR('wrong: \U0000db99\U00000061');
SELECT UNISTR('wrong: \U002FFFFF');
SELECT UNISTR('wrong: \xyz');
/* SUBSCRIPTION */ CREATE ROLE regress_subscription_user LOGIN SUPERUSER;
CREATE ROLE regress_subscription_user2;
CREATE ROLE regress_subscription_user3 IN ROLE pg_create_subscription;
CREATE ROLE regress_subscription_user_dummy LOGIN NOSUPERUSER;
SET SESSION AUTHORIZATION 'regress_subscription_user';
/* fail - no publications */ CREATE SUBSCRIPTION regress_testsub CONNECTION 'foo';
/* fail - no connection */ CREATE SUBSCRIPTION regress_testsub PUBLICATION foo;
/* fail - cannot do CREATE SUBSCRIPTION CREATE SLOT inside transaction block */ BEGIN;
CREATE SUBSCRIPTION regress_testsub CONNECTION 'testconn' PUBLICATION testpub WITH (create_slot);
COMMIT;
/* fail - invalid connection string */ CREATE SUBSCRIPTION regress_testsub CONNECTION 'testconn' PUBLICATION testpub;
/* fail - duplicate publications */ CREATE SUBSCRIPTION regress_testsub CONNECTION 'dbname=regress_doesnotexist' PUBLICATION foo, testpub, foo WITH (connect = false);
/* ok */ CREATE SUBSCRIPTION regress_testsub CONNECTION 'dbname=regress_doesnotexist' PUBLICATION testpub WITH (connect = false);
COMMENT ON SUBSCRIPTION regress_testsub IS 'test subscription';
SELECT OBJ_DESCRIPTION(x.x, 'pg_subscription') FROM x AS x;
/* Check if the subscription stats are created and stats_reset is updated */ /* by pg_stat_reset_subscription_stats(). */ SELECT x, x IS NULL AS x FROM x WHERE x = 'regress_testsub';
SELECT PG_STAT_RESET_SUBSCRIPTION_STATS(x) FROM x WHERE x = 'regress_testsub';
SELECT x, x IS NULL AS x FROM x WHERE x = 'regress_testsub';
/* fail - name already exists */ CREATE SUBSCRIPTION regress_testsub CONNECTION 'dbname=regress_doesnotexist' PUBLICATION testpub WITH (connect = false);
/* fail - must be superuser */ SET SESSION AUTHORIZATION 'regress_subscription_user2';
CREATE SUBSCRIPTION regress_testsub2 CONNECTION 'dbname=regress_doesnotexist' PUBLICATION foo WITH (connect = false);
SET SESSION AUTHORIZATION 'regress_subscription_user';
/* fail - invalid option combinations */ CREATE SUBSCRIPTION regress_testsub2 CONNECTION 'dbname=regress_doesnotexist' PUBLICATION testpub WITH (connect = false, copy_data = true);
CREATE SUBSCRIPTION regress_testsub2 CONNECTION 'dbname=regress_doesnotexist' PUBLICATION testpub WITH (connect = false, enabled = true);
CREATE SUBSCRIPTION regress_testsub2 CONNECTION 'dbname=regress_doesnotexist' PUBLICATION testpub WITH (connect = false, create_slot = true);
CREATE SUBSCRIPTION regress_testsub2 CONNECTION 'dbname=regress_doesnotexist' PUBLICATION testpub WITH (slot_name = NONE, enabled = true);
CREATE SUBSCRIPTION regress_testsub2 CONNECTION 'dbname=regress_doesnotexist' PUBLICATION testpub WITH (slot_name = NONE, enabled = false, create_slot = true);
CREATE SUBSCRIPTION regress_testsub2 CONNECTION 'dbname=regress_doesnotexist' PUBLICATION testpub WITH (slot_name = NONE);
CREATE SUBSCRIPTION regress_testsub2 CONNECTION 'dbname=regress_doesnotexist' PUBLICATION testpub WITH (slot_name = NONE, enabled = false);
CREATE SUBSCRIPTION regress_testsub2 CONNECTION 'dbname=regress_doesnotexist' PUBLICATION testpub WITH (slot_name = NONE, create_slot = false);
/* ok - with slot_name = NONE */ CREATE SUBSCRIPTION regress_testsub3 CONNECTION 'dbname=regress_doesnotexist' PUBLICATION testpub WITH (slot_name = NONE, connect = false);
/* fail */ ALTER SUBSCRIPTION regress_testsub3 ENABLE;
ALTER SUBSCRIPTION regress_testsub3 REFRESH PUBLICATION;
/* fail - origin must be either none or any */ CREATE SUBSCRIPTION regress_testsub4 CONNECTION 'dbname=regress_doesnotexist' PUBLICATION testpub WITH (slot_name = NONE, connect = false, origin = foo);
/* now it works */ CREATE SUBSCRIPTION regress_testsub4 CONNECTION 'dbname=regress_doesnotexist' PUBLICATION testpub WITH (slot_name = NONE, connect = false, origin = none);
DROP SUBSCRIPTION regress_testsub4;
/* fail, connection string does not parse */ CREATE SUBSCRIPTION regress_testsub5 CONNECTION 'i_dont_exist=param' PUBLICATION testpub;
/* fail, connection string parses, but doesn't work (and does so without */ /* connecting, so this is reliable and safe) */ CREATE SUBSCRIPTION regress_testsub5 CONNECTION 'port=-1' PUBLICATION testpub;
/* fail - invalid connection string during ALTER */ ALTER SUBSCRIPTION regress_testsub CONNECTION 'foobar';
ALTER SUBSCRIPTION regress_testsub CONNECTION 'dbname=regress_doesnotexist2';
ALTER SUBSCRIPTION regress_testsub SET (slot_name = 'newname');
ALTER SUBSCRIPTION regress_testsub SET (password_required = false);
ALTER SUBSCRIPTION regress_testsub SET (run_as_owner = true);
ALTER SUBSCRIPTION regress_testsub SET (run_as_owner = false);
/* fail */ ALTER SUBSCRIPTION regress_testsub SET (slot_name = '');
/* fail */ ALTER SUBSCRIPTION regress_doesnotexist CONNECTION 'dbname=regress_doesnotexist2';
ALTER SUBSCRIPTION regress_testsub SET (create_slot = false);
/* ok */ ALTER SUBSCRIPTION regress_testsub SKIP (lsn = '0/12345');
/* fail */ ALTER SUBSCRIPTION regress_testsub SKIP (lsn = '0/0');
ALTER SUBSCRIPTION regress_testsub ENABLE;
/* fail - must be owner of subscription */ SET ROLE regress_subscription_user_dummy;
ALTER SUBSCRIPTION regress_testsub RENAME TO regress_testsub_dummy;
RESET ROLE;
ALTER SUBSCRIPTION regress_testsub RENAME TO regress_testsub_foo;
ALTER SUBSCRIPTION regress_testsub_foo SET (synchronous_commit = local);
ALTER SUBSCRIPTION regress_testsub_foo SET (synchronous_commit = foobar);
/* ok, we're a superuser */ ALTER SUBSCRIPTION regress_testsub OWNER TO regress_subscription_user2;
/* fail - cannot do DROP SUBSCRIPTION inside transaction block with slot name */ BEGIN;
DROP SUBSCRIPTION regress_testsub;
COMMIT;
ALTER SUBSCRIPTION regress_testsub SET (slot_name = NONE);
/* now it works */ BEGIN;
DROP SUBSCRIPTION regress_testsub;
COMMIT;
DROP SUBSCRIPTION IF EXISTS regress_testsub;
DROP SUBSCRIPTION regress_testsub;
/* fail */ /* fail - binary must be boolean */ CREATE SUBSCRIPTION regress_testsub CONNECTION 'dbname=regress_doesnotexist' PUBLICATION testpub WITH (connect = false, binary = foo);
/* now it works */ CREATE SUBSCRIPTION regress_testsub CONNECTION 'dbname=regress_doesnotexist' PUBLICATION testpub WITH (connect = false, binary = true);
ALTER SUBSCRIPTION regress_testsub SET (slot_name = NONE);
/* fail - streaming must be boolean or 'parallel' */ CREATE SUBSCRIPTION regress_testsub CONNECTION 'dbname=regress_doesnotexist' PUBLICATION testpub WITH (connect = false, streaming = foo);
/* now it works */ CREATE SUBSCRIPTION regress_testsub CONNECTION 'dbname=regress_doesnotexist' PUBLICATION testpub WITH (connect = false, streaming = true);
ALTER SUBSCRIPTION regress_testsub SET (slot_name = NONE);
/* fail - publication used more than once */ ALTER SUBSCRIPTION regress_testsub ADD PUBLICATION testpub1, testpub1 WITH (refresh = false);
/* ok - add two publications into subscription */ ALTER SUBSCRIPTION regress_testsub ADD PUBLICATION testpub1, testpub2 WITH (refresh = false);
/* fail - publications already exist */ ALTER SUBSCRIPTION regress_testsub ADD PUBLICATION testpub1, testpub2 WITH (refresh = false);
/* fail - all publications are deleted */ ALTER SUBSCRIPTION regress_testsub DROP PUBLICATION testpub, testpub1, testpub2 WITH (refresh = false);
/* fail - publication does not exist in subscription */ ALTER SUBSCRIPTION regress_testsub DROP PUBLICATION testpub3 WITH (refresh = false);
/* ok - delete publications */ ALTER SUBSCRIPTION regress_testsub DROP PUBLICATION testpub1, testpub2 WITH (refresh = false);
CREATE SUBSCRIPTION regress_testsub CONNECTION 'dbname=regress_doesnotexist' PUBLICATION mypub        WITH (connect = false, create_slot = false, copy_data = false);
ALTER SUBSCRIPTION regress_testsub ENABLE;
/* fail - ALTER SUBSCRIPTION with refresh is not allowed in a transaction */ /* block or function */ BEGIN;
ALTER SUBSCRIPTION regress_testsub SET PUBLICATION mypub WITH (refresh = true);
COMMIT;
BEGIN;
ALTER SUBSCRIPTION regress_testsub REFRESH PUBLICATION;
COMMIT;
CREATE FUNCTION x() RETURNS VOID LANGUAGE SQL AS $$ ALTER SUBSCRIPTION regress_testsub SET PUBLICATION mypub WITH (refresh = true) $$;
SELECT FUNC();
ALTER SUBSCRIPTION regress_testsub DISABLE;
ALTER SUBSCRIPTION regress_testsub SET (slot_name = NONE);
DROP SUBSCRIPTION regress_testsub;
DROP FUNCTION x;
/* fail - two_phase must be boolean */ CREATE SUBSCRIPTION regress_testsub CONNECTION 'dbname=regress_doesnotexist' PUBLICATION testpub WITH (connect = false, two_phase = foo);
/* now it works */ CREATE SUBSCRIPTION regress_testsub CONNECTION 'dbname=regress_doesnotexist' PUBLICATION testpub WITH (connect = false, two_phase = true);
DROP SUBSCRIPTION regress_testsub;
/* two_phase and streaming are compatible. */ CREATE SUBSCRIPTION regress_testsub CONNECTION 'dbname=regress_doesnotexist' PUBLICATION testpub WITH (connect = false, streaming = true, two_phase = true);
DROP SUBSCRIPTION regress_testsub;
/* fail - disable_on_error must be boolean */ CREATE SUBSCRIPTION regress_testsub CONNECTION 'dbname=regress_doesnotexist' PUBLICATION testpub WITH (connect = false, disable_on_error = foo);
/* now it works */ CREATE SUBSCRIPTION regress_testsub CONNECTION 'dbname=regress_doesnotexist' PUBLICATION testpub WITH (connect = false, disable_on_error = false);
DROP SUBSCRIPTION regress_testsub;
/* let's do some tests with pg_create_subscription rather than superuser */ SET SESSION AUTHORIZATION regress_subscription_user3;
/* fail, not enough privileges */ CREATE SUBSCRIPTION regress_testsub CONNECTION 'dbname=regress_doesnotexist' PUBLICATION testpub WITH (connect = false);
/* fail, must specify password */ RESET SESSION AUTHORIZATION;
GRANT CREATE ON DATABASE x TO x;
SET SESSION AUTHORIZATION regress_subscription_user3;
CREATE SUBSCRIPTION regress_testsub CONNECTION 'dbname=regress_doesnotexist' PUBLICATION testpub WITH (connect = false);
/* fail, can't set password_required=false */ RESET SESSION AUTHORIZATION;
GRANT CREATE ON DATABASE x TO x;
SET SESSION AUTHORIZATION regress_subscription_user3;
CREATE SUBSCRIPTION regress_testsub CONNECTION 'dbname=regress_doesnotexist' PUBLICATION testpub WITH (connect = false, password_required = false);
/* ok */ RESET SESSION AUTHORIZATION;
GRANT CREATE ON DATABASE x TO x;
SET SESSION AUTHORIZATION regress_subscription_user3;
CREATE SUBSCRIPTION regress_testsub CONNECTION 'dbname=regress_doesnotexist password=regress_fakepassword' PUBLICATION testpub WITH (connect = false);
/* we cannot give the subscription away to some random user */ ALTER SUBSCRIPTION regress_testsub OWNER TO regress_subscription_user;
/* but we can rename the subscription we just created */ ALTER SUBSCRIPTION regress_testsub RENAME TO regress_testsub2;
/* ok, even after losing pg_create_subscription we can still rename it */ RESET SESSION AUTHORIZATION;
REVOKE pg_create_subscription FROM regress_subscription_user3;
SET SESSION AUTHORIZATION regress_subscription_user3;
ALTER SUBSCRIPTION regress_testsub2 RENAME TO regress_testsub;
/* fail, after losing CREATE on the database we can't rename it any more */ RESET SESSION AUTHORIZATION;
REVOKE CREATE ON DATABASE REGRESSION FROM regress_subscription_user3;
SET SESSION AUTHORIZATION regress_subscription_user3;
ALTER SUBSCRIPTION regress_testsub RENAME TO regress_testsub2;
/* fail - cannot do ALTER SUBSCRIPTION SET (failover) inside transaction block */ BEGIN;
ALTER SUBSCRIPTION regress_testsub SET (failover);
COMMIT;
/* ok, owning it is enough for this stuff */ ALTER SUBSCRIPTION regress_testsub SET (slot_name = NONE);
DROP SUBSCRIPTION regress_testsub;
RESET SESSION AUTHORIZATION;
DROP ROLE regress_subscription_user;
DROP ROLE regress_subscription_user2;
DROP ROLE regress_subscription_user3;
DROP ROLE regress_subscription_user_dummy;
/* SUBSELECT */ SELECT 1 AS x WHERE 1 IN (SELECT 1);
SELECT 1 AS x WHERE NOT 1 IN (SELECT 1);
SELECT 1 AS x WHERE 1 IN (SELECT 2);
/* Check grammar's handling of extra parens in assorted contexts */ SELECT * FROM (SELECT 1 AS x) AS x;
SELECT * FROM ((SELECT 1 AS x)) AS x;
SELECT * FROM ((SELECT 1 AS x)), ((SELECT * FROM ((SELECT 2 AS x))));
(SELECT 2) UNION SELECT 2;
((SELECT 2)) UNION SELECT 2;
SELECT ((SELECT 2) UNION SELECT 2);
SELECT (((SELECT 2)) UNION SELECT 2);
SELECT (SELECT ARRAY(1, 2, 3))[0];
SELECT ((SELECT ARRAY(1, 2, 3)))[1];
SELECT (((SELECT ARRAY(1, 2, 3))))[2];
/* Set up some simple test tables */ CREATE TABLE x (x INT, x INT, x DOUBLE);
INSERT INTO x VALUES (1, 2, 3);
INSERT INTO x VALUES (2, 3, 4);
INSERT INTO x VALUES (3, 4, 5);
INSERT INTO x VALUES (1, 1, 1);
INSERT INTO x VALUES (2, 2, 2);
INSERT INTO x VALUES (3, 3, 3);
INSERT INTO x VALUES (6, 7, 8);
INSERT INTO x VALUES (8, 9, NULL);
SELECT * FROM x;
/* Uncorrelated subselects */ SELECT x AS "x" FROM x WHERE x IN (SELECT 1);
SELECT x AS "x" FROM x WHERE x IN (SELECT x FROM x);
SELECT x AS "x" FROM x WHERE x IN (SELECT x FROM x WHERE x IN (SELECT x FROM x));
SELECT x, x FROM x WHERE NOT (x, x) IN (SELECT x, CAST(x AS INT) FROM x WHERE NOT x IS NULL);
/* Correlated subselects */ SELECT x AS "x", x AS "x" FROM x AS x WHERE x IN (SELECT x FROM x WHERE x = x.x);
SELECT x AS "x", x AS "x" FROM x AS x WHERE x IN (SELECT x FROM x WHERE CAST(x.x AS DOUBLE) = x);
SELECT x AS "x", x AS "x" FROM x AS x WHERE x IN (SELECT x.x + x FROM x WHERE x = CAST(x AS INT));
SELECT x AS "x" FROM x WHERE (x, x) IN (SELECT x, CAST(x AS INT) FROM x WHERE NOT x IS NULL);
/* Check ROWCOMPARE cases, both correlated and not */ EXPLAIN (VERBOSE, COSTS OFF) SELECT ROW(1, 2) = (SELECT f1, f2) AS eq FROM SUBSELECT_TBL;
SELECT ROW(1, 2) = (SELECT x, x) AS x FROM x;
EXPLAIN (VERBOSE, COSTS OFF) SELECT ROW(1, 2) = (SELECT 3, 4) AS eq FROM SUBSELECT_TBL;
SELECT ROW(1, 2) = (SELECT 3, 4) AS x FROM x;
SELECT ROW(1, 2) = (SELECT x, x FROM x);
/* error */ /* Subselects without aliases */ SELECT x FROM (SELECT COUNT(DISTINCT x) FROM x);
SELECT COUNT(*) FROM (SELECT DISTINCT x FROM x);
SELECT * FROM (SELECT * FROM x), VALUES (123456) WHERE x = x;
CREATE VIEW x AS SELECT * FROM (SELECT * FROM (SELECT ABS(x) AS x FROM x)), (SELECT * FROM x) WHERE x < 10 AND x > x ORDER BY x NULLS LAST, x NULLS LAST;
SELECT * FROM x;
/* Test matching of locking clause to correct alias */ CREATE VIEW x AS SELECT * FROM (SELECT * FROM x), x AS x WHERE x = x;
/* Use some existing tables in the regression test */ SELECT x.x AS "x", x.x AS "x" FROM x AS x WHERE NOT x IN (SELECT x + 1 FROM x WHERE x <> x.x AND x < 2147483647);
SELECT x, FLOAT8(COUNT(*)) / (SELECT COUNT(*) FROM x) FROM x GROUP BY x ORDER BY x NULLS LAST;
/* Unspecified-type literals in output columns should resolve as text */ SELECT *, PG_TYPEOF(x) FROM (SELECT 'foo' AS x FROM x) AS x ORDER BY 1 NULLS LAST;
/* ... unless there's context to suggest differently */ EXPLAIN (verbose, costs off) select '42' union all select '43';
EXPLAIN (verbose, costs off) select '42' union all select 43;
/* check materialization of an initplan reference (bug #14524) */ EXPLAIN (verbose, costs off) select 1 = all (select (select 1));
SELECT 1 = ALL (SELECT (SELECT 1));
/* Check EXISTS simplification with LIMIT */ EXPLAIN (costs off) select * from int4_tbl o where exists   (select 1 from int4_tbl i where i.f1=o.f1 limit null);
EXPLAIN (costs off) select * from int4_tbl o where not exists   (select 1 from int4_tbl i where i.f1=o.f1 limit 1);
EXPLAIN (costs off) select * from int4_tbl o where exists   (select 1 from int4_tbl i where i.f1=o.f1 limit 0);
/* Test cases to catch unpleasant interactions between IN-join processing */ /* and subquery pullup. */ SELECT COUNT(*) FROM (SELECT 1 FROM x AS x WHERE x IN (SELECT x FROM x AS x)) AS x;
SELECT COUNT(DISTINCT x.x) FROM (SELECT x FROM x AS x WHERE x IN (SELECT x FROM x AS x)) AS x;
SELECT COUNT(*) FROM (SELECT 1 FROM x AS x WHERE x IN (SELECT DISTINCT x FROM x AS x)) AS x;
SELECT COUNT(DISTINCT x.x) FROM (SELECT x FROM x AS x WHERE x IN (SELECT DISTINCT x FROM x AS x)) AS x;
/* Test cases to check for overenthusiastic optimization of */ /* "IN (SELECT DISTINCT ...)" and related cases.  Per example from */ /* Luca Pireddu and Michael Fuhr. */ CREATE TEMPORARY TABLE x (x INT);
CREATE TEMPORARY TABLE x (x INT, x INT);
INSERT INTO x VALUES (1);
INSERT INTO x VALUES (1, 1);
INSERT INTO x VALUES (2, 2);
INSERT INTO x VALUES (3, 1);
/* These cases require an extra level of distinct-ing above subquery s */ SELECT * FROM x WHERE x IN (SELECT x FROM (SELECT DISTINCT x, x FROM x) AS x);
SELECT * FROM x WHERE x IN (SELECT x FROM (SELECT x, x FROM x GROUP BY x, x) AS x);
SELECT * FROM x WHERE x IN (SELECT x FROM (SELECT x, x FROM x UNION SELECT x, x FROM x) AS x);
/* These cases do not */ SELECT * FROM x WHERE x IN (SELECT x FROM (SELECT DISTINCT ON (x) x, x FROM x) AS x);
SELECT * FROM x WHERE x IN (SELECT x FROM (SELECT x FROM x GROUP BY x) AS x);
SELECT * FROM x WHERE x IN (SELECT x FROM (SELECT x FROM x UNION SELECT x FROM x) AS x);
/* Test case to catch problems with multiply nested sub-SELECTs not getting */ /* recalculated properly.  Per bug report from Didier Moens. */ CREATE TABLE x (x INT, x INT, x BOOLEAN);
INSERT INTO x VALUES (1, 1, FALSE);
INSERT INTO x VALUES (66, 5, FALSE);
INSERT INTO x VALUES (66, 6, FALSE);
INSERT INTO x VALUES (66, 7, FALSE);
INSERT INTO x VALUES (66, 1, TRUE);
INSERT INTO x VALUES (66, 8, FALSE);
INSERT INTO x VALUES (66, 1, FALSE);
INSERT INTO x VALUES (77, 1, FALSE);
INSERT INTO x VALUES (1, 1, FALSE);
INSERT INTO x VALUES (66, 1, FALSE);
INSERT INTO x VALUES (1, 1, FALSE);
CREATE VIEW x AS SELECT *, (SELECT CASE WHEN x.x = 1 THEN '---' ELSE 'Approved' END) AS "x", (SELECT CASE WHEN x.x THEN 'Canceled' ELSE (SELECT CASE WHEN x.x = 1 THEN (SELECT CASE WHEN x.x = 1 THEN '---' ELSE 'Approved' END) ELSE 'PO' END) END) AS "x", (CASE WHEN x.x THEN 'Canceled' ELSE (CASE WHEN x.x = 1 THEN (CASE WHEN x.x = 1 THEN '---' ELSE 'Approved' END) ELSE 'PO' END) END) AS "x" FROM x AS x;
SELECT * FROM x;
DROP TABLE x CASCADE;
/* Test cases to catch situations where rule rewriter fails to propagate */ /* hasSubLinks flag correctly.  Per example from Kyle Bateman. */ CREATE TEMPORARY TABLE x (x TEXT, x DOUBLE);
CREATE TEMPORARY TABLE x (x CHAR(2), x INT, x TEXT, x DOUBLE);
CREATE TEMPORARY VIEW x AS SELECT * FROM x WHERE x = 'wt';
create rule shipped_view_insert as on insert to shipped_view do instead     insert into shipped values('wt', new.ordnum, new.partnum, new.value);
INSERT INTO x (x, x) VALUES (1, 1234.56);
INSERT INTO x (x, x, x) VALUES (0, 1, (SELECT x FROM x WHERE x = '1'));
SELECT * FROM x;
create rule shipped_view_update as on update to shipped_view do instead     update shipped set partnum = new.partnum, value = new.value         where ttype = new.ttype and ordnum = new.ordnum;
UPDATE x SET x = 11 FROM x AS x JOIN x AS x ON (x.x = (SELECT x FROM x AS x WHERE x.x = x.x)) WHERE x = x.x;
SELECT * FROM x;
SELECT x, x AS x FROM (SELECT *, (SELECT SUM(x) FROM x AS x WHERE x >= x.x) AS x FROM x AS x) AS x;
/* Test cases involving PARAM_EXEC parameters and min/max index optimizations. */ /* Per bug report from David Sanchez i Gregori. */ SELECT * FROM (SELECT MAX(x) FROM x AS x WHERE EXISTS(SELECT 1 FROM x AS x WHERE x.x = x.x)) AS x;
SELECT * FROM (SELECT MIN(x) FROM x AS x WHERE NOT EXISTS(SELECT 1 FROM x AS x WHERE x.x = 10000)) AS x;
/* Test that an IN implemented using a UniquePath does unique-ification */ /* with the right semantics, as per bug #4113.  (Unfortunately we have */ /* no simple way to ensure that this test case actually chooses that type */ /* of plan, but it does in releases 7.4-8.3.  Note that an ordering difference */ /* here might mean that some other plan type is being used, rendering the test */ /* pointless.) */ CREATE TEMPORARY TABLE x (x DECIMAL);
INSERT INTO x VALUES (1), (1.000000000000000000001), (2), (3);
CREATE TEMPORARY TABLE x (x DOUBLE);
INSERT INTO x VALUES (1), (2), (3);
SELECT * FROM x WHERE x IN (SELECT x FROM x);
SELECT * FROM x WHERE x IN (SELECT x FROM x);
/* Test case for bug #4290: bogus calculation of subplan param sets */ CREATE TEMPORARY TABLE x (x INT PRIMARY KEY, x INT);
INSERT INTO x VALUES (1, 1);
INSERT INTO x VALUES (2, 2);
CREATE TEMPORARY TABLE x (x INT PRIMARY KEY, x INT);
INSERT INTO x VALUES (1, 1);
INSERT INTO x VALUES (2, 1);
INSERT INTO x VALUES (3, 2);
INSERT INTO x VALUES (4, 2);
CREATE TEMPORARY TABLE x (x INT PRIMARY KEY, x INT);
INSERT INTO x VALUES (1, 1);
INSERT INTO x VALUES (2, 2);
SELECT (SELECT MIN(x.x) FROM x WHERE x.x = (SELECT x.x FROM x WHERE x.x = x.x)) AS x FROM x;
/* Test case for 8.3 "failed to locate grouping columns" bug */ CREATE TEMPORARY TABLE x (x DECIMAL(14, 0), x VARCHAR(30));
SELECT * FROM (SELECT DISTINCT x, x, (SELECT x FROM x AS x WHERE x.x = x.x) AS x FROM x AS x) AS x GROUP BY x, x, x;
/* Test case for bug #5514 (mishandling of whole-row Vars in subselects) */ CREATE TEMPORARY TABLE x (x INT);
INSERT INTO x VALUES (42);
CREATE TEMPORARY VIEW x AS SELECT * FROM x;
SELECT x FROM x;
SELECT (SELECT x) FROM x;
SELECT (SELECT (SELECT x)) FROM x;
SELECT (SELECT CAST((x.*) AS TEXT)) FROM x AS x;
/* Check that whole-row Vars reading the result of a subselect don't include */ /* any junk columns therein */ SELECT x FROM (SELECT MAX(x) FROM x GROUP BY x ORDER BY x NULLS LAST) AS x;
WITH x AS (SELECT MAX(x) FROM x GROUP BY x ORDER BY x NULLS LAST) SELECT x FROM x;
/* Test case for sublinks pulled up into joinaliasvars lists in an */ /* inherited update/delete query */ BEGIN;
/*  this shouldn't delete anything, but be safe */ DELETE FROM x WHERE EXISTS(SELECT 1 FROM x CROSS JOIN (SELECT x, ARRAY(SELECT x FROM x) AS x FROM x) AS x WHERE x.x = x.x);
ROLLBACK;
/* Test case for sublinks pushed down into subselects via join alias expansion */ SELECT (SELECT x) AS x FROM (SELECT EXISTS(SELECT 1 FROM x WHERE x = x) AS x, 42 AS x FROM x) AS x JOIN x AS x ON x = x.x;
/* Test case for subselect within UPDATE of INSERT...ON CONFLICT DO UPDATE */ CREATE TEMPORARY TABLE x (x INT PRIMARY KEY, x TEXT);
INSERT INTO x VALUES (1, 'val') ON CONFLICT(x) DO UPDATE SET x = 'not seen';
INSERT INTO x VALUES (1, 'val') ON CONFLICT(x) DO UPDATE SET x = 'seen with subselect ' || CAST((SELECT x FROM x WHERE x <> 0 LIMIT 1) AS TEXT);
SELECT * FROM x;
WITH x AS (SELECT 'int4_tbl' AS x FROM x LIMIT 1) INSERT INTO x VALUES (1, 'x'), (999, 'y') ON CONFLICT(x) DO UPDATE SET x = (SELECT x FROM x) RETURNING *;
/* Test case for cross-type partial matching in hashed subplan (bug #7597) */ CREATE TEMPORARY TABLE x (x INT, x INT);
INSERT INTO x VALUES (0, 0);
INSERT INTO x VALUES (1, 0);
INSERT INTO x VALUES (0, NULL);
INSERT INTO x VALUES (1, NULL);
CREATE TEMPORARY TABLE x (x BIGINT, x BIGINT);
INSERT INTO x VALUES (0, NULL);
SELECT * FROM x WHERE NOT (x, x) IN (SELECT * FROM x);
/* Similar test case using text that verifies that collation */ /* information is passed through by execTuplesEqual() in nodeSubplan.c */ /* (otherwise it would error in texteq()) */ CREATE TEMPORARY TABLE x (x TEXT, x TEXT);
INSERT INTO x VALUES ('a', 'a');
INSERT INTO x VALUES ('b', 'a');
INSERT INTO x VALUES ('a', NULL);
INSERT INTO x VALUES ('b', NULL);
CREATE TEMPORARY TABLE x (x TEXT, x TEXT);
INSERT INTO x VALUES ('a', NULL);
INSERT INTO x VALUES ('123', '456');
SELECT * FROM x WHERE NOT (x, x) IN (SELECT * FROM x);
/* Another test case for cross-type hashed subplans: comparison of */ /* inner-side values must be done with appropriate operator */ EXPLAIN (verbose, costs off) select 'foo'::text in (select 'bar'::name union all select 'bar'::name);
SELECT CAST('foo' AS TEXT) IN (SELECT CAST('bar' AS NAME) UNION ALL SELECT CAST('bar' AS NAME));
/* Test that we don't try to hash nested records (bug #17363) */ /* (Hashing could be supported, but for now we don't) */ EXPLAIN (verbose, costs off) select row(row(row(1))) = any (select row(row(1)));
SELECT ROW(ROW(ROW(1))) = ANY (SELECT ROW(ROW(1)));
/* Test case for premature memory release during hashing of subplan output */ SELECT CAST('1' AS TEXT) IN (SELECT CAST('1' AS NAME) UNION ALL SELECT CAST('1' AS NAME));
/* Test that we don't try to use a hashed subplan if the simplified */ /* testexpr isn't of the right shape */ /* this fails by default, of course */ SELECT * FROM x WHERE x IN (SELECT x FROM x);
BEGIN;
/* make an operator to allow it to succeed */ CREATE FUNCTION x(x, x) RETURNS BOOLEAN LANGUAGE sql AS 'select $1::text = $2';
create operator = (procedure=bogus_int8_text_eq, leftarg=int8, rightarg=text);
EXPLAIN (costs off) select * from int8_tbl where q1 in (select c1 from inner_text);
SELECT * FROM x WHERE x IN (SELECT x FROM x);
/* inlining of this function results in unusual number of hash clauses, */ /* which we can still cope with */ CREATE OR REPLACE FUNCTION x(x, x) RETURNS BOOLEAN LANGUAGE sql AS 'select $1::text = $2 and $1::text = $2';
EXPLAIN (costs off) select * from int8_tbl where q1 in (select c1 from inner_text);
SELECT * FROM x WHERE x IN (SELECT x FROM x);
/* inlining of this function causes LHS and RHS to be switched, */ /* which we can't cope with, so hashing should be abandoned */ CREATE OR REPLACE FUNCTION x(x, x) RETURNS BOOLEAN LANGUAGE sql AS 'select $2 = $1::text';
EXPLAIN (costs off) select * from int8_tbl where q1 in (select c1 from inner_text);
SELECT * FROM x WHERE x IN (SELECT x FROM x);
ROLLBACK;
/* to get rid of the bogus operator */ /* Test resolution of hashed vs non-hashed implementation of EXISTS subplan */ EXPLAIN (costs off) select count(*) from tenk1 t where (exists(select 1 from tenk1 k where k.unique1 = t.unique2) or ten < 0);
SELECT COUNT(*) FROM x AS x WHERE (EXISTS(SELECT 1 FROM x AS x WHERE x.x = x.x) OR x < 0);
EXPLAIN (costs off) select count(*) from tenk1 t where (exists(select 1 from tenk1 k where k.unique1 = t.unique2) or ten < 0)   and thousand = 1;
SELECT COUNT(*) FROM x AS x WHERE (EXISTS(SELECT 1 FROM x AS x WHERE x.x = x.x) OR x < 0) AND x = 1;
/* It's possible for the same EXISTS to get resolved both ways */ CREATE TEMPORARY TABLE x (x INT, x INT, x INT) WITH (PARTITIONED_BY=LIST(x));
CREATE TEMPORARY TABLE x PARTITION OF x FOR VALUES IN (NULL);
CREATE TEMPORARY TABLE x PARTITION OF x DEFAULT;
INSERT INTO x SELECT x, x / 2, x + 1 FROM x AS x;
ANALYZE x;
EXPLAIN (costs off) select * from exists_tbl t1   where (exists(select 1 from exists_tbl t2 where t1.c1 = t2.c2) or c3 < 0);
SELECT * FROM x AS x WHERE (EXISTS(SELECT 1 FROM x AS x WHERE x.x = x.x) OR x < 0);
/* Test case for planner bug with nested EXISTS handling */ SELECT x.x FROM x AS x, x AS x WHERE x.x = x.x AND EXISTS(SELECT 1 FROM x AS x WHERE x.x = x.x AND NOT EXISTS(SELECT 1 FROM x AS x WHERE x.x = x.x));
/* Check that nested sub-selects are not pulled up if they contain volatiles */ EXPLAIN (verbose, costs off)   select x, x from     (select (select now()) as x from (values(1),(2)) v(y)) ss;
EXPLAIN (verbose, costs off)   select x, x from     (select (select random()) as x from (values(1),(2)) v(y)) ss;
EXPLAIN (verbose, costs off)   select x, x from     (select (select now() where y=y) as x from (values(1),(2)) v(y)) ss;
EXPLAIN (verbose, costs off)   select x, x from     (select (select random() where y=y) as x from (values(1),(2)) v(y)) ss;
/* Test rescan of a hashed subplan (the use of random() is to prevent the */ /* sub-select from being pulled up, which would result in not hashing) */ EXPLAIN (verbose, costs off) select sum(ss.tst::int) from   onek o cross join lateral (   select i.ten in (select f1 from int4_tbl where f1 <= o.hundred) as tst,          random() as r   from onek i where i.unique1 = o.unique1 ) ss where o.ten = 0;
SELECT SUM(CAST(x.x AS INT)) FROM x AS x CROSS JOIN LATERAL (SELECT x.x IN (SELECT x FROM x WHERE x <= x.x) AS x, RAND() AS x FROM x AS x WHERE x.x = x.x) AS x WHERE x.x = 0;
/* Test rescan of a hashed SetOp node */ BEGIN;
SET LOCAL x = off;
EXPLAIN (costs off) select count(*) from   onek o cross join lateral (     select * from onek i1 where i1.unique1 = o.unique1     except     select * from onek i2 where i2.unique1 = o.unique2   ) ss where o.ten = 1;
SELECT COUNT(*) FROM x AS x CROSS JOIN LATERAL (SELECT * FROM x AS x WHERE x.x = x.x EXCEPT SELECT * FROM x AS x WHERE x.x = x.x) AS x WHERE x.x = 1;
ROLLBACK;
/* Test rescan of a sorted SetOp node */ BEGIN;
SET LOCAL x = off;
EXPLAIN (costs off) select count(*) from   onek o cross join lateral (     select * from onek i1 where i1.unique1 = o.unique1     except     select * from onek i2 where i2.unique1 = o.unique2   ) ss where o.ten = 1;
SELECT COUNT(*) FROM x AS x CROSS JOIN LATERAL (SELECT * FROM x AS x WHERE x.x = x.x EXCEPT SELECT * FROM x AS x WHERE x.x = x.x) AS x WHERE x.x = 1;
ROLLBACK;
/* Test rescan of a RecursiveUnion node */ EXPLAIN (costs off) select sum(o.four), sum(ss.a) from   onek o cross join lateral (     with recursive x(a) as       (select o.four as a        union        select a + 1 from x        where a < 10)     select * from x   ) ss where o.ten = 1;
SELECT SUM(x.x), SUM(x.x) FROM x AS x CROSS JOIN LATERAL (WITH RECURSIVE x AS (SELECT x.x AS x UNION SELECT x + 1 FROM x WHERE x < 10) SELECT * FROM x) AS x WHERE x.x = 1;
/* Check we don't misoptimize a NOT IN where the subquery returns no rows. */ CREATE TEMPORARY TABLE x (x INT);
CREATE TEMPORARY TABLE x (x INT NOT NULL);
INSERT INTO x VALUES (NULL), (1);
SELECT * FROM x WHERE NOT x IN (SELECT x FROM x);
/* Check we behave sanely in corner case of empty SELECT list (bug #8648) */ CREATE TEMPORARY TABLE x;
SELECT EXISTS(SELECT * FROM x);
/* Check behavior with a SubPlan in VALUES (bug #14924) */ SELECT x.x FROM x AS x, LATERAL (VALUES ((SELECT x.x + 1)), (x.x + 101)) AS x WHERE x.x < 10 AND (SELECT x.x) < 110;
/* another variant of that (bug #16213) */ EXPLAIN (verbose, costs off) select * from (values   (3 not in (select * from (values (1), (2)) ss1)),   (false) ) ss;
SELECT * FROM (VALUES (NOT 3 IN (SELECT * FROM (VALUES (1), (2)) AS x)), (FALSE)) AS x;
/* Check sane behavior with nested IN SubLinks */ EXPLAIN (verbose, costs off) select * from int4_tbl where   (case when f1 in (select unique1 from tenk1 a) then f1 else null end) in   (select ten from tenk1 b);
SELECT * FROM x WHERE (CASE WHEN x IN (SELECT x FROM x AS x) THEN x ELSE NULL END) IN (SELECT x FROM x AS x);
/* Check for incorrect optimization when IN subquery contains a SRF */ EXPLAIN (verbose, costs off) select * from int4_tbl o where (f1, f1) in   (select f1, generate_series(1,50) / 10 g from int4_tbl i group by f1);
SELECT * FROM x AS x WHERE (x, x) IN (SELECT x, UNNEST(GENERATE_SERIES(1, 50)) / 10 AS x FROM x AS x GROUP BY x);
/* check for over-optimization of whole-row Var referencing an Append plan */ SELECT (SELECT x FROM (SELECT 1, 2, 3 WHERE x > 0 UNION ALL SELECT 4, 5, 6.0 WHERE x <= 0) AS x) FROM x;
/* Check for sane handling of a lateral reference in a subquery's quals */ /* (most of the complication here is to prevent the test case from being */ /* flattened too much) */ EXPLAIN (verbose, costs off) select * from     int4_tbl i4,     lateral (         select i4.f1 > 1 as b, 1 as id         from (select random() order by 1) as t1       union all         select true as b, 2 as id     ) as t2 where b and f1 >= 0;
SELECT * FROM x AS x, LATERAL (SELECT x.x > 1 AS x, 1 AS x FROM (SELECT RAND() ORDER BY 1 NULLS LAST) AS x UNION ALL SELECT TRUE AS x, 2 AS x) AS x WHERE x AND x >= 0;
/* Check that volatile quals aren't pushed down past a DISTINCT: */ /* nextval() should not be called more than the nominal number of times */ CREATE TEMPORARY SEQUENCE x;
SELECT * FROM (SELECT DISTINCT x FROM x) AS x WHERE x < 10 + NEXTVAL('ts1') ORDER BY 1 NULLS LAST;
SELECT NEXTVAL('ts1');
x;
EXPLAIN (verbose, costs off) select * from   (select 9 as x, unnest(array[1,2,3,11,12,13]) as u) ss   where tattle(x, 8);
SELECT * FROM (SELECT 9 AS x, EXPLODE(ARRAY(1, 2, 3, 11, 12, 13)) AS x) AS x WHERE TATTLE(x, 8);
/* if we pretend it's stable, we get different results: */ alter function tattle(x int, y int) stable;
EXPLAIN (verbose, costs off) select * from   (select 9 as x, unnest(array[1,2,3,11,12,13]) as u) ss   where tattle(x, 8);
SELECT * FROM (SELECT 9 AS x, EXPLODE(ARRAY(1, 2, 3, 11, 12, 13)) AS x) AS x WHERE TATTLE(x, 8);
/* although even a stable qual should not be pushed down if it references SRF */ EXPLAIN (verbose, costs off) select * from   (select 9 as x, unnest(array[1,2,3,11,12,13]) as u) ss   where tattle(x, u);
SELECT * FROM (SELECT 9 AS x, EXPLODE(ARRAY(1, 2, 3, 11, 12, 13)) AS x) AS x WHERE TATTLE(x, x);
/* Test that LIMIT can be pushed to SORT through a subquery that just projects */ /* columns.  We check for that having happened by looking to see if EXPLAIN */ /* ANALYZE shows that a top-N sort was used.  We must suppress or filter away */ /* all the non-invariant parts of the EXPLAIN ANALYZE output. */ CREATE TABLE x (x INT PRIMARY KEY, x INT, x INT);
INSERT INTO x VALUES (1, 1, 1), (2, 2, 2), (3, 3, 3), (4, 4, 4), (5, 1, 1), (6, 2, 2), (7, 3, 3), (8, 4, 4);
BEGIN for ln in         explain (analyze, summary off, timing off, costs off, buffers off)         select * from (select pk,c2 from sq_limit order by c1,pk) as x limit 3     loop         ln := regexp_replace(ln, 'Memory: \S*',  'Memory: xxx');
COMMIT;
SELECT * FROM x;
SELECT * FROM (SELECT x, x FROM x ORDER BY x NULLS LAST, x NULLS LAST) AS x LIMIT 3;
DROP FUNCTION x;
DROP TABLE x;
/* Ensure that backward scan direction isn't propagated into */ /* expression subqueries (bug #15336) */ BEGIN;
DECLARE c1 scroll cursor for  select * from generate_series(1,4) i   where i <> all (values (2),(3));
FETCH backward all in c1;
COMMIT;
/* Verify that we correctly flatten cases involving a subquery output */ /* expression that doesn't need to be wrapped in a PlaceHolderVar */ EXPLAIN (costs off) select tname, attname from ( select relname::information_schema.sql_identifier as tname, * from   (select * from pg_class c) ss1) ss2   right join pg_attribute a on a.attrelid = ss2.oid where tname = 'tenk1' and attnum = 1;
SELECT x, x FROM (SELECT CAST(x AS information_schema.sql_identifier) AS x, * FROM (SELECT * FROM x AS x) AS x) AS x RIGHT JOIN x AS x ON x.x = x.x WHERE x = 'tenk1' AND x = 1;
/* Check behavior when there's a lateral reference in the output expression */ EXPLAIN (verbose, costs off) select t1.ten, sum(x) from   tenk1 t1 left join lateral (     select t1.ten + t2.ten as x, t2.fivethous from tenk1 t2   ) ss on t1.unique1 = ss.fivethous group by t1.ten order by t1.ten;
SELECT x.x, SUM(x) FROM x AS x LEFT JOIN LATERAL (SELECT x.x + x.x AS x, x.x FROM x AS x) AS x ON x.x = x.x GROUP BY x.x ORDER BY x.x NULLS LAST;
EXPLAIN (verbose, costs off) select t1.q1, x from   int8_tbl t1 left join   (int8_tbl t2 left join    lateral (select t2.q1+t3.q1 as x, * from int8_tbl t3) t3 on t2.q2 = t3.q2)   on t1.q2 = t2.q2 order by 1, 2;
SELECT x.x, x FROM x AS x LEFT JOIN (x AS x LEFT JOIN LATERAL (SELECT x.x + x.x AS x, * FROM x AS x) AS x ON x.x = x.x) ON x.x = x.x ORDER BY 1 NULLS LAST, 2 NULLS LAST;
/* strict expressions containing variables of rels under the same lowest */ /* nulling outer join can escape being wrapped */ EXPLAIN (verbose, costs off) select t1.q1, x from   int8_tbl t1 left join   (int8_tbl t2 inner join    lateral (select t2.q1+1 as x, * from int8_tbl t3) t3 on t2.q2 = t3.q2)   on t1.q2 = t2.q2 order by 1, 2;
SELECT x.x, x FROM x AS x LEFT JOIN (x AS x INNER JOIN LATERAL (SELECT x.x + 1 AS x, * FROM x AS x) AS x ON x.x = x.x) ON x.x = x.x ORDER BY 1 NULLS LAST, 2 NULLS LAST;
/* otherwise we need to wrap the strict expressions */ EXPLAIN (verbose, costs off) select t1.q1, x from   int8_tbl t1 left join   (int8_tbl t2 left join    lateral (select t2.q1+1 as x, * from int8_tbl t3) t3 on t2.q2 = t3.q2)   on t1.q2 = t2.q2 order by 1, 2;
SELECT x.x, x FROM x AS x LEFT JOIN (x AS x LEFT JOIN LATERAL (SELECT x.x + 1 AS x, * FROM x AS x) AS x ON x.x = x.x) ON x.x = x.x ORDER BY 1 NULLS LAST, 2 NULLS LAST;
/* lateral references for simple Vars can escape being wrapped if the */ /* referenced rel is under the same lowest nulling outer join */ EXPLAIN (verbose, costs off) select t1.q1, x from   int8_tbl t1 left join   (int8_tbl t2 inner join    lateral (select t2.q2 as x, * from int8_tbl t3) ss on t2.q2 = ss.q1)   on t1.q1 = t2.q1 order by 1, 2;
SELECT x.x, x FROM x AS x LEFT JOIN (x AS x INNER JOIN LATERAL (SELECT x.x AS x, * FROM x AS x) AS x ON x.x = x.x) ON x.x = x.x ORDER BY 1 NULLS LAST, 2 NULLS LAST;
/* otherwise we need to wrap the Vars */ EXPLAIN (verbose, costs off) select t1.q1, x from   int8_tbl t1 left join   (int8_tbl t2 left join    lateral (select t2.q2 as x, * from int8_tbl t3) ss on t2.q2 = ss.q1)   on t1.q1 = t2.q1 order by 1, 2;
SELECT x.x, x FROM x AS x LEFT JOIN (x AS x LEFT JOIN LATERAL (SELECT x.x AS x, * FROM x AS x) AS x ON x.x = x.x) ON x.x = x.x ORDER BY 1 NULLS LAST, 2 NULLS LAST;
/* lateral references for PHVs can also escape being wrapped if the */ /* referenced rel is under the same lowest nulling outer join */ EXPLAIN (verbose, costs off) select ss2.* from   int8_tbl t1 left join   (int8_tbl t2 left join    (select coalesce(q1) as x, * from int8_tbl t3) ss1 on t2.q1 = ss1.q2 inner join    lateral (select ss1.x as y, * from int8_tbl t4) ss2 on t2.q2 = ss2.q1)   on t1.q2 = ss2.q1 order by 1, 2, 3;
SELECT x.* FROM x AS x LEFT JOIN (x AS x LEFT JOIN (SELECT COALESCE(x) AS x, * FROM x AS x) AS x ON x.x = x.x INNER JOIN LATERAL (SELECT x.x AS x, * FROM x AS x) AS x ON x.x = x.x) ON x.x = x.x ORDER BY 1 NULLS LAST, 2 NULLS LAST, 3 NULLS LAST;
/* otherwise we need to wrap the PHVs */ EXPLAIN (verbose, costs off) select ss2.* from   int8_tbl t1 left join   (int8_tbl t2 left join    (select coalesce(q1) as x, * from int8_tbl t3) ss1 on t2.q1 = ss1.q2 left join    lateral (select ss1.x as y, * from int8_tbl t4) ss2 on t2.q2 = ss2.q1)   on t1.q2 = ss2.q1 order by 1, 2, 3;
SELECT x.* FROM x AS x LEFT JOIN (x AS x LEFT JOIN (SELECT COALESCE(x) AS x, * FROM x AS x) AS x ON x.x = x.x LEFT JOIN LATERAL (SELECT x.x AS x, * FROM x AS x) AS x ON x.x = x.x) ON x.x = x.x ORDER BY 1 NULLS LAST, 2 NULLS LAST, 3 NULLS LAST;
/* Tests for CTE inlining behavior */ /* Basic subquery that can be inlined */ EXPLAIN (verbose, costs off) with x as (select * from (select f1 from subselect_tbl) ss) select * from x where f1 = 1;
/* Explicitly request materialization */ EXPLAIN (verbose, costs off) with x as materialized (select * from (select f1 from subselect_tbl) ss) select * from x where f1 = 1;
/* Stable functions are safe to inline */ EXPLAIN (verbose, costs off) with x as (select * from (select f1, now() from subselect_tbl) ss) select * from x where f1 = 1;
/* Volatile functions prevent inlining */ EXPLAIN (verbose, costs off) with x as (select * from (select f1, random() from subselect_tbl) ss) select * from x where f1 = 1;
/* SELECT FOR UPDATE cannot be inlined */ EXPLAIN (verbose, costs off) with x as (select * from (select f1 from subselect_tbl for update) ss) select * from x where f1 = 1;
/* Multiply-referenced CTEs are inlined only when requested */ EXPLAIN (verbose, costs off) with x as (select * from (select f1, now() as n from subselect_tbl) ss) select * from x, x x2 where x.n = x2.n;
EXPLAIN (verbose, costs off) with x as not materialized (select * from (select f1, now() as n from subselect_tbl) ss) select * from x, x x2 where x.n = x2.n;
/* Multiply-referenced CTEs can't be inlined if they contain outer self-refs */ EXPLAIN (verbose, costs off) with recursive x(a) as   ((values ('a'), ('b'))    union all    (with z as not materialized (select * from x)     select z.a || z1.a as a from z cross join z as z1     where length(z.a || z1.a) < 5)) select * from x;
WITH RECURSIVE x AS ((VALUES ('a'), ('b')) UNION ALL (WITH x AS NOT MATERIALIZED (SELECT * FROM x) SELECT x.x || x.x AS x FROM x CROSS JOIN x AS x WHERE LENGTH(x.x || x.x) < 5)) SELECT * FROM x;
EXPLAIN (verbose, costs off) with recursive x(a) as   ((values ('a'), ('b'))    union all    (with z as not materialized (select * from x)     select z.a || z.a as a from z     where length(z.a || z.a) < 5)) select * from x;
WITH RECURSIVE x AS ((VALUES ('a'), ('b')) UNION ALL (WITH x AS NOT MATERIALIZED (SELECT * FROM x) SELECT x.x || x.x AS x FROM x WHERE LENGTH(x.x || x.x) < 5)) SELECT * FROM x;
/* Check handling of outer references */ EXPLAIN (verbose, costs off) with x as (select * from int4_tbl) select * from (with y as (select * from x) select * from y) ss;
EXPLAIN (verbose, costs off) with x as materialized (select * from int4_tbl) select * from (with y as (select * from x) select * from y) ss;
/* Ensure that we inline the correct CTE when there are */ /* multiple CTEs with the same name */ EXPLAIN (verbose, costs off) with x as (select 1 as y) select * from (with x as (select 2 as y) select * from x) ss;
/* Row marks are not pushed into CTEs */ EXPLAIN (verbose, costs off) with x as (select * from subselect_tbl) select * from x for update;
/* Pull up direct-correlated ANY_SUBLINKs */ EXPLAIN (costs off) select * from tenk1 A where hundred in (select hundred from tenk2 B where B.odd = A.odd);
EXPLAIN (costs off) select * from tenk1 A where exists (select 1 from tenk2 B where A.hundred in (select C.hundred FROM tenk2 C WHERE c.odd = b.odd));
/* we should only try to pull up the sublink into RHS of a left join */ /* but a.hundred is not available. */ EXPLAIN (costs off) SELECT * FROM tenk1 A LEFT JOIN tenk2 B ON A.hundred in (SELECT c.hundred FROM tenk2 C WHERE c.odd = b.odd);
/* we should only try to pull up the sublink into RHS of a left join */ /* but a.odd is not available for this. */ EXPLAIN (costs off) SELECT * FROM tenk1 A LEFT JOIN tenk2 B ON B.hundred in (SELECT c.hundred FROM tenk2 C WHERE c.odd = a.odd);
/* should be able to pull up since all the references are available. */ EXPLAIN (costs off) SELECT * FROM tenk1 A LEFT JOIN tenk2 B ON B.hundred in (SELECT c.hundred FROM tenk2 C WHERE c.odd = b.odd);
/* we can pull up the sublink into the inner JoinExpr. */ EXPLAIN (costs off) SELECT * FROM tenk1 A INNER JOIN tenk2 B ON A.hundred in (SELECT c.hundred FROM tenk2 C WHERE c.odd = b.odd) WHERE a.thousand < 750;
/* we can pull up the aggregate sublink into RHS of a left join. */ EXPLAIN (costs off) SELECT * FROM tenk1 A LEFT JOIN tenk2 B ON B.hundred in (SELECT min(c.hundred) FROM tenk2 C WHERE c.odd = b.odd);
/* but even a trivial check of count(*) will exercise the normal code path */ /* through the SRF. */ SELECT COUNT(*) >= 0 AS x FROM x;
SELECT COUNT(*) >= 0 AS x FROM x;
/* The entire output of pg_backend_memory_contexts is not stable, */ /* we test only the existence and basic condition of TopMemoryContext. */ SELECT x, x, x, x, x >= x FROM x WHERE x = 1;
/* We can exercise some MemoryContext type stats functions.  Most of the */ /* column values are too platform-dependant to display. */ /* Ensure stats from the bump allocator look sane.  Bump isn't a commonly */ /* used context, but it is used in tuplesort.c, so open a cursor to keep */ /* the tuplesort alive long enough for us to query the context stats. */ BEGIN;
DECLARE cur cursor for select left(a,10), b   from (values(repeat('a', 512 * 1024),1),(repeat('b', 512),2)) v(a,b)   order by v.a desc;
FETCH 1 from cur;
SELECT x, x, x > 0, x, x > 0, x FROM x WHERE x = 'Caller tuples';
ROLLBACK;
/* Further sanity checks on pg_backend_memory_contexts.  We expect */ /* CacheMemoryContext to have multiple children.  Ensure that's the case. */ WITH x AS (SELECT * FROM x) SELECT COUNT(*) > 1 FROM x AS x, x AS x WHERE x.x = 'CacheMemoryContext' AND x.x[x.x] = x.x[x.x];
SELECT COUNT(*) >= 0 AS x FROM x;
/* There will surely be at least one rule, with no errors. */ SELECT COUNT(*) > 0 AS x, COUNT(*) FILTER(WHERE NOT x IS NULL) = 0 AS x FROM x;
/* There may be no rules, and there should be no errors. */ SELECT COUNT(*) >= 0 AS x, COUNT(*) FILTER(WHERE NOT x IS NULL) = 0 AS x FROM x;
/* There will surely be at least one active lock */ SELECT COUNT(*) > 0 AS x FROM x;
/* See also prepared_xacts.sql */ SELECT COUNT(*) >= 0 AS x FROM x;
/* There will surely be at least one SLRU cache */ SELECT COUNT(*) > 0 AS x FROM x;
/* There must be only one record */ SELECT COUNT(*) = 1 AS x FROM x;
/* We expect no walreceiver running in this test */ SELECT COUNT(*) = 0 AS x FROM x;
/* This is to record the prevailing planner enable_foo settings during */ /* a regression test run. */ SELECT x, x FROM x WHERE x LIKE 'enable%';
/* There are always wait event descriptions for various types.  InjectionPoint */ /* may be present or absent, depending on history since last postmaster start. */ SELECT x, COUNT(*) > 0 AS x FROM x WHERE x <> 'InjectionPoint' GROUP BY x ORDER BY x COLLATE "x" NULLS LAST;
/* Test that the pg_timezone_names and pg_timezone_abbrevs views are */ /* more-or-less working.  We can't test their contents in any great detail */ /* without the outputs changing anytime IANA updates the underlying data, */ /* but it seems reasonable to expect at least one entry per major meridian. */ /* (At the time of writing, the actual counts are around 38 because of */ /* zones using fractional GMT offsets, so this is a pretty loose test.) */ SELECT COUNT(DISTINCT x) >= 24 AS x FROM x;
SELECT COUNT(DISTINCT x) >= 24 AS x FROM x;
SET x = 'Australia' /* Let's check the non-default timezone abbreviation sets, too */;
SELECT COUNT(DISTINCT x) >= 24 AS x FROM x;
SET x = 'India';
SELECT COUNT(DISTINCT x) >= 24 AS x FROM x;
/* One specific case we can check without much fear of breakage */ /* is the historical local-mean-time value used for America/Los_Angeles. */ SELECT * FROM x WHERE x = 'LMT';
CREATE TABLE x (x INT, x TEXT) WITH (fillfactor=10);
/* use fillfactor so we don't have to load too much data to get multiple pages */ INSERT INTO x SELECT x, REPEAT(CAST(x AS TEXT), 200) FROM x AS x;
SELECT x.x FROM x AS x TABLESAMPLE SYSTEM (50 PERCENT) SEED (0);
SELECT x FROM x TABLESAMPLE SYSTEM (100.0 / 11 PERCENT) SEED (0);
SELECT x FROM x TABLESAMPLE SYSTEM (50 PERCENT) SEED (0);
SELECT x FROM x TABLESAMPLE BERNOULLI (50 PERCENT) SEED (0);
SELECT x FROM x TABLESAMPLE BERNOULLI (5.5 PERCENT) SEED (0);
/* 100% should give repeatable count results (ie, all rows) in any case */ SELECT COUNT(*) FROM x TABLESAMPLE SYSTEM (100 PERCENT);
SELECT COUNT(*) FROM x TABLESAMPLE SYSTEM (100 PERCENT) SEED (0.4);
CREATE VIEW x AS SELECT x FROM x TABLESAMPLE SYSTEM (10 * 2 PERCENT) SEED (2);
CREATE VIEW x AS SELECT x FROM x TABLESAMPLE SYSTEM (99 PERCENT);
DECLARE tablesample_cur SCROLL CURSOR FOR   SELECT id FROM test_tablesample TABLESAMPLE SYSTEM (50) REPEATABLE (0);
FETCH FIRST FROM tablesample_cur;
FETCH NEXT FROM tablesample_cur;
FETCH NEXT FROM tablesample_cur;
SELECT x FROM x TABLESAMPLE SYSTEM (50 PERCENT) SEED (0);
FETCH NEXT FROM tablesample_cur;
FETCH NEXT FROM tablesample_cur;
FETCH NEXT FROM tablesample_cur;
FETCH FIRST FROM tablesample_cur;
FETCH NEXT FROM tablesample_cur;
FETCH NEXT FROM tablesample_cur;
FETCH NEXT FROM tablesample_cur;
FETCH NEXT FROM tablesample_cur;
FETCH NEXT FROM tablesample_cur;
x AS x;
COMMIT;
EXPLAIN (COSTS OFF)   SELECT id FROM test_tablesample TABLESAMPLE SYSTEM (50) REPEATABLE (2);
EXPLAIN (COSTS OFF)   SELECT * FROM test_tablesample_v1;
/* check inheritance behavior */ EXPLAIN (costs off)   select count(*) from person tablesample bernoulli (100);
SELECT COUNT(*) FROM x TABLESAMPLE BERNOULLI (100 PERCENT);
SELECT COUNT(*) FROM x;
EXPLAIN (costs off) select pct, count(unique1) from   (values (0),(100)) v(pct),   lateral (select * from tenk1 tablesample bernoulli (pct)) ss   group by pct;
/* errors */ SELECT x FROM x TABLESAMPLE FOOBAR (1 PERCENT);
SELECT x FROM x TABLESAMPLE SYSTEM (NULL PERCENT);
SELECT x FROM x TABLESAMPLE BERNOULLI (200 PERCENT);
SELECT x FROM x TABLESAMPLE SYSTEM (200 PERCENT);
SELECT x FROM x TABLESAMPLE BERNOULLI (1 PERCENT);
INSERT INTO x VALUES (1);
WITH x AS (SELECT * FROM x) SELECT * FROM x TABLESAMPLE BERNOULLI (5.5 PERCENT) SEED (1);
SELECT x.* FROM (SELECT * FROM x) AS x TABLESAMPLE BERNOULLI (5 PERCENT);
/* check partitioned tables support tablesample */ CREATE TABLE x (x INT) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN (1);
CREATE TABLE x PARTITION OF x FOR VALUES IN (2);
EXPLAIN (costs off)   select * from parted_sample tablesample bernoulli (100);
/* relative tablespace locations are not allowed */ CREATE TABLESPACE regress_tblspace LOCATION 'relative';
/* fail */ /* empty tablespace locations are not usually allowed */ CREATE TABLESPACE regress_tblspace LOCATION '';
SET x = TRUE /* fail */ /* as a special developer-only option to allow us to use tablespaces */ /* with streaming replication on the same server, an empty location */ /* can be allowed as a way to say that the tablespace should be created */ /* as a directory in pg_tblspc, rather than being a symlink */;
/* create a tablespace using WITH clause */ CREATE TABLESPACE regress_tblspacewith LOCATION '' WITH (some_nonexistent_parameter = true);
/* fail */ CREATE TABLESPACE regress_tblspacewith LOCATION '' WITH (random_page_cost = 3.0);
/* ok */ /* check to see the parameter was used */ SELECT x FROM x WHERE x = 'regress_tblspacewith';
/* drop the tablespace so we can re-use the location */ DROP TABLESPACE regress_tblspacewith;
/* This returns a relative path as of an effect of allow_in_place_tablespaces, */ /* masking the tablespace OID used in the path name. */ SELECT REGEXP_REPLACE(PG_TABLESPACE_LOCATION(x), '(pg_tblspc)/(\d+)', '\1/NNN') FROM x WHERE x = 'regress_tblspace';
/* try setting and resetting some properties for the new tablespace */ ALTER TABLESPACE regress_tblspace SET (random_page_cost = 1.0, seq_page_cost = 1.1);
ALTER TABLESPACE regress_tblspace SET (some_nonexistent_parameter = true);
/* fail */ ALTER TABLESPACE regress_tblspace RESET (random_page_cost = 2.0);
/* fail */ ALTER TABLESPACE regress_tblspace RESET (random_page_cost, effective_io_concurrency);
/* ok */ /* REINDEX (TABLESPACE) */ /* catalogs and system tablespaces */ /* system catalog, fail */ REINDEX (TABLESPACE regress_tblspace) TABLE pg_am;
REINDEX (TABLESPACE regress_tblspace) TABLE CONCURRENTLY pg_am;
/* shared catalog, fail */ REINDEX (TABLESPACE regress_tblspace) TABLE pg_authid;
REINDEX (TABLESPACE regress_tblspace) TABLE CONCURRENTLY pg_authid;
/* toast relations, fail */ REINDEX (TABLESPACE regress_tblspace) INDEX pg_toast.pg_toast_1262_index;
REINDEX (TABLESPACE regress_tblspace) INDEX CONCURRENTLY pg_toast.pg_toast_1262_index;
REINDEX (TABLESPACE regress_tblspace) TABLE pg_toast.pg_toast_1262;
REINDEX (TABLESPACE regress_tblspace) TABLE CONCURRENTLY pg_toast.pg_toast_1262;
/* system catalog, fail */ REINDEX (TABLESPACE pg_global) TABLE pg_authid;
REINDEX (TABLESPACE pg_global) TABLE CONCURRENTLY pg_authid;
/* table with toast relation */ CREATE TABLE x (x BIGINT, x DOUBLE, x TEXT);
INSERT INTO x (x, x, x) SELECT ROUND(RAND() * 100), RAND(), 'text' FROM x AS x;
CREATE INDEX x ON x(x NULLS LAST);
/* move to global tablespace, fail */ REINDEX (TABLESPACE pg_global) INDEX regress_tblspace_test_tbl_idx;
REINDEX (TABLESPACE pg_global) INDEX CONCURRENTLY regress_tblspace_test_tbl_idx;
/* check transactional behavior of REINDEX (TABLESPACE) */ BEGIN;
REINDEX (TABLESPACE regress_tblspace) INDEX regress_tblspace_test_tbl_idx;
REINDEX (TABLESPACE regress_tblspace) TABLE regress_tblspace_test_tbl;
ROLLBACK;
/* no relation moved to the new tablespace */ SELECT x.x FROM x AS x, x AS x WHERE x.x = x.x AND x.x = 'regress_tblspace';
SELECT x.x FROM x AS x, x AS x WHERE x.x = x.x AND x.x = 'regress_tblspace' ORDER BY x.x NULLS LAST;
ALTER TABLE x SET;
ALTER TABLE x SET;
SELECT x.x FROM x AS x, x AS x WHERE x.x = x.x AND x.x = 'regress_tblspace' ORDER BY x.x NULLS LAST;
ALTER INDEX x SET  /* Move back to the default tablespace. */;
SELECT x.x FROM x AS x, x AS x WHERE x.x = x.x AND x.x = 'regress_tblspace' ORDER BY x.x NULLS LAST;
REINDEX (TABLESPACE regress_tblspace, CONCURRENTLY) TABLE regress_tblspace_test_tbl;
SELECT x.x FROM x AS x, x AS x WHERE x.x = x.x AND x.x = 'regress_tblspace' ORDER BY x.x NULLS LAST;
SELECT x = :main_filenode AS x FROM x WHERE x = 'regress_tblspace_test_tbl_idx';
SELECT x = :toast_filenode AS x FROM x WHERE x = (SELECT x.x FROM x AS x, x AS x WHERE x.x = x.x AND x.x = 'regress_tblspace_test_tbl');
DROP TABLE x;
/* REINDEX (TABLESPACE) with partitions */ /* Create a partition tree and check the set of relations reindexed */ /* with their new tablespace. */ CREATE TABLE x (x INT, x INT) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (0) TO (10) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN (1);
CREATE TABLE x PARTITION OF x FOR VALUES IN (2);
/* This partitioned table will have no partitions. */ CREATE TABLE x PARTITION OF x FOR VALUES FROM (10) TO (20) WITH (PARTITIONED_BY=LIST(x));
ALTER INDEX tbspace_reindex_part_index ATTACH PARTITION tbspace_reindex_part_index_0;
ALTER INDEX tbspace_reindex_part_index ATTACH PARTITION tbspace_reindex_part_index_10;
ALTER INDEX tbspace_reindex_part_index_0 ATTACH PARTITION tbspace_reindex_part_index_0_1;
ALTER INDEX tbspace_reindex_part_index_0 ATTACH PARTITION tbspace_reindex_part_index_0_2;
SELECT x, x, x FROM x ORDER BY x NULLS LAST, x NULLS LAST;
/* Track the original tablespace, relfilenode and OID of each index */ /* in the tree. */ CREATE TEMPORARY TABLE x AS SELECT x, x, x, x FROM x WHERE REGEXP_LIKE(x, 'tbspace_reindex_part_index');
REINDEX (TABLESPACE regress_tblspace, CONCURRENTLY) TABLE tbspace_reindex_part;
/* REINDEX CONCURRENTLY changes the OID of the old relation, hence a check */ /* based on the relation name below. */ SELECT x.x, CASE WHEN x.x = x.x THEN 'relfilenode is unchanged' ELSE 'relfilenode has changed' END AS x, CASE WHEN x.x = x.x THEN 'reltablespace is unchanged' ELSE 'reltablespace has changed' END AS x FROM x AS x JOIN x AS x ON x.x = x.x ORDER BY 1 NULLS LAST;
DROP TABLE x;
/* create a schema we can use */ CREATE SCHEMA x.x;
/* try a table */ CREATE TABLE testschema.foo (i int) TABLESPACE regress_tblspace;
SELECT x, x FROM x.x AS x, x.x AS x WHERE x.x = x.x AND x.x = 'foo';
INSERT INTO x.x VALUES (1);
INSERT INTO x.x VALUES (2);
/* tables from dynamic sources */ CREATE TABLE testschema.asselect TABLESPACE regress_tblspace AS SELECT 1;
SELECT x, x FROM x.x AS x, x.x AS x WHERE x.x = x.x AND x.x = 'asselect';
PREPARE selectsource(int) AS SELECT $1;
CREATE TABLE testschema.asexecute TABLESPACE regress_tblspace     AS EXECUTE selectsource(2);
SELECT x, x FROM x.x AS x, x.x AS x WHERE x.x = x.x AND x.x = 'asexecute';
/* index */ CREATE INDEX foo_idx on testschema.foo(i) TABLESPACE regress_tblspace;
SELECT x, x FROM x.x AS x, x.x AS x WHERE x.x = x.x AND x.x = 'foo_idx';
SET x = pg_global;
CREATE TABLE x.x PARTITION OF x.x FOR VALUES IN (1);
RESET default_tablespace;
CREATE TABLE x.x PARTITION OF x.x FOR VALUES IN (1);
SET x = regress_tblspace;
CREATE TABLE x.x PARTITION OF x.x FOR VALUES IN (2);
SET x = pg_global;
CREATE TABLE x.x PARTITION OF x.x FOR VALUES IN (3);
ALTER TABLE x.x SET;
CREATE TABLE x.x PARTITION OF x.x FOR VALUES IN (3);
CREATE TABLE testschema.part_4 PARTITION OF testschema.part FOR VALUES IN (4)   TABLESPACE pg_default;
CREATE TABLE x.x PARTITION OF x.x FOR VALUES IN (5, 6) WITH (PARTITIONED_BY=LIST(x));
ALTER TABLE x.x SET;
CREATE TABLE x.x PARTITION OF x.x FOR VALUES IN (7, 8) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE testschema.part_910 PARTITION OF testschema.part FOR VALUES IN (9, 10)   PARTITION BY LIST (a) TABLESPACE regress_tblspace;
RESET default_tablespace;
CREATE TABLE x.x PARTITION OF x.x FOR VALUES IN (7, 8) WITH (PARTITIONED_BY=LIST(x));
SELECT x, x FROM x.x AS x JOIN x.x AS x ON (x.x = x.x) LEFT JOIN x.x AS x ON x.x = x.x WHERE x.x LIKE 'part%' AND x.x = 'testschema' ORDER BY x NULLS LAST;
RESET default_tablespace;
DROP TABLE x.x;
/* partitioned index */ CREATE TABLE x.x (x INT) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x.x PARTITION OF x.x FOR VALUES IN (1);
CREATE INDEX part_a_idx ON testschema.part (a) TABLESPACE regress_tblspace;
CREATE TABLE x.x PARTITION OF x.x FOR VALUES IN (2);
SELECT x, x FROM x.x AS x, x.x AS x WHERE x.x = x.x AND x.x LIKE 'part%_idx' ORDER BY x NULLS LAST;
SET x = 'pg_default';
CREATE TABLE testschema.dflt (a int PRIMARY KEY) PARTITION BY LIST (a) TABLESPACE regress_tblspace;
SET x = '';
CREATE TABLE x.x (x INT PRIMARY KEY) WITH (PARTITIONED_BY=LIST(x));
/* check that default_tablespace doesn't affect ALTER TABLE index rebuilds */ CREATE TABLE testschema.test_default_tab(id bigint) TABLESPACE regress_tblspace;
INSERT INTO x.x VALUES (1);
CREATE INDEX x ON x.x(x NULLS LAST);
CREATE INDEX test_index2 on testschema.test_default_tab (id) TABLESPACE regress_tblspace;
ALTER TABLE x.x ADD CONSTRAINT x PRIMARY KEY (x NULLS LAST);
ALTER TABLE testschema.test_default_tab ADD CONSTRAINT test_index4 UNIQUE (id) USING INDEX TABLESPACE regress_tblspace;
ALTER TABLE x.x ALTER COLUMN x SET DATA TYPE BIGINT /* tablespace should not change if no rewrite */;
ALTER TABLE x.x ALTER COLUMN x SET DATA TYPE INT /* tablespace should not change even if there is an index rewrite */;
SET x = '' /* now use the default tablespace for default_tablespace */;
ALTER TABLE x.x ALTER COLUMN x SET DATA TYPE INT /* tablespace should not change if no rewrite */;
/* check that default_tablespace doesn't affect ALTER TABLE index rebuilds */ /* (this time with a partitioned table) */ CREATE TABLE testschema.test_default_tab_p(id bigint, val bigint)     PARTITION BY LIST (id) TABLESPACE regress_tblspace;
CREATE TABLE x.x PARTITION OF x.x FOR VALUES IN (1);
INSERT INTO x.x VALUES (1);
CREATE INDEX x ON x.x(x NULLS LAST);
CREATE INDEX test_index2 on testschema.test_default_tab_p (val) TABLESPACE regress_tblspace;
ALTER TABLE x.x ADD CONSTRAINT x PRIMARY KEY (x NULLS LAST);
ALTER TABLE testschema.test_default_tab_p ADD CONSTRAINT test_index4 UNIQUE (id) USING INDEX TABLESPACE regress_tblspace;
ALTER TABLE x.x ALTER COLUMN x SET DATA TYPE BIGINT /* tablespace should not change if no rewrite */;
ALTER TABLE x.x ALTER COLUMN x SET DATA TYPE INT /* tablespace should not change even if there is an index rewrite */;
SET x = '' /* now use the default tablespace for default_tablespace */;
ALTER TABLE x.x ALTER COLUMN x SET DATA TYPE INT /* tablespace should not change if no rewrite */;
/* check that default_tablespace affects index additions in ALTER TABLE */ CREATE TABLE testschema.test_tab(id int) TABLESPACE regress_tblspace;
INSERT INTO x.x VALUES (1);
SET x = regress_tblspace;
ALTER TABLE x.x ADD CONSTRAINT x UNIQUE (x);
SET x = '';
ALTER TABLE x.x ADD CONSTRAINT x PRIMARY KEY (x NULLS LAST);
DROP TABLE x.x;
/* check that default_tablespace is handled correctly by multi-command */ /* ALTER TABLE that includes a tablespace-preserving rewrite */ CREATE TABLE x.x (x INT, x INT, x INT);
SET x = regress_tblspace;
ALTER TABLE x.x ADD CONSTRAINT x UNIQUE (x);
CREATE INDEX x ON x.x(x NULLS LAST);
SET x = '';
CREATE INDEX x ON x.x(x NULLS LAST);
/* let's try moving a table from one place to another */ CREATE TABLE x.x AS VALUES (1), (2);
CREATE UNIQUE INDEX x ON x.x(x NULLS LAST);
ALTER TABLE x.x SET;
ALTER INDEX x.x SET;
ALTER INDEX x.x SET;
ALTER INDEX x.x SET;
ALTER INDEX x.x SET;
INSERT INTO x.x VALUES (3);
/* ok */ INSERT INTO x.x VALUES (1);
/* fail (checks index) */ SELECT COUNT(*) FROM x.x;
/* checks heap */ /* let's try moving a materialized view from one place to another */ CREATE MATERIALIZED VIEW x.x AS SELECT * FROM x.x;
ALTER MATERIALIZED VIEW testschema.amv SET TABLESPACE regress_tblspace;
REFRESH MATERIALIZED VIEW testschema.amv;
SELECT COUNT(*) FROM x.x;
/* Will fail with bad path */ CREATE TABLESPACE regress_badspace LOCATION '/no/such/location';
/* No such tablespace */ CREATE TABLE bar (i int) TABLESPACE regress_nosuchspace;
/* Fail, in use for some partitioned object */ DROP TABLESPACE regress_tblspace;
ALTER INDEX x.x SET;
/* Fail, not empty */ DROP TABLESPACE regress_tblspace;
GRANT ALL ON TABLESPACE regress_tblspace TO PUBLIC;
ROLLBACK;
CREATE ROLE regress_tablespace_user1 login;
CREATE ROLE regress_tablespace_user2 login;
GRANT USAGE ON SCHEMA x TO x;
ALTER TABLESPACE regress_tblspace OWNER TO regress_tablespace_user1;
CREATE TABLE x.x (x INT);
/* new owner lacks permission to create this index from scratch */ CREATE INDEX k ON testschema.tablespace_acl (c) TABLESPACE regress_tblspace;
ALTER TABLE testschema.tablespace_acl OWNER TO regress_tablespace_user2;
SET SESSION ROLE regress_tablespace_user2;
CREATE TABLE tablespace_table (i int) TABLESPACE regress_tblspace;
ALTER TABLE x.x ALTER COLUMN x SET DATA TYPE BIGINT /* fail */;
REINDEX (TABLESPACE regress_tblspace) TABLE tablespace_table;
/* fail */ REINDEX (TABLESPACE regress_tblspace, CONCURRENTLY) TABLE tablespace_table;
/* fail */ RESET ROLE;
ALTER TABLESPACE regress_tblspace RENAME TO regress_tblspace_renamed;
ALTER TABLE ALL IN TABLESPACE regress_tblspace_renamed SET TABLESPACE pg_default;
ALTER INDEX ALL IN TABLESPACE regress_tblspace_renamed SET TABLESPACE pg_default;
ALTER MATERIALIZED VIEW ALL IN TABLESPACE regress_tblspace_renamed SET TABLESPACE pg_default;
/* Should show notice that nothing was done */ ALTER TABLE ALL IN TABLESPACE regress_tblspace_renamed SET TABLESPACE pg_default;
ALTER MATERIALIZED VIEW ALL IN TABLESPACE regress_tblspace_renamed SET TABLESPACE pg_default;
/* Should succeed */ DROP TABLESPACE regress_tblspace_renamed;
DROP SCHEMA x.x CASCADE;
DROP ROLE regress_tablespace_user1;
DROP ROLE regress_tablespace_user2;
/* TEMP */ /* Test temp relations and indexes */ /* test temp table/index masking */ CREATE TABLE x (x INT);
CREATE INDEX x ON x(x NULLS LAST);
CREATE TEMPORARY TABLE x (x INT);
CREATE INDEX x ON x(x NULLS LAST);
SELECT * FROM x;
DROP INDEX x;
DROP TABLE x;
SELECT * FROM x;
DROP INDEX x;
DROP TABLE x;
/* test temp table selects */ CREATE TABLE x (x INT);
INSERT INTO x VALUES (1);
CREATE TEMPORARY TABLE x (x DOUBLE);
INSERT INTO x VALUES (2.1);
SELECT * FROM x;
DROP TABLE x;
SELECT * FROM x;
DROP TABLE x;
/* test temp table deletion */ CREATE TEMPORARY TABLE x (x INT);
/* Test ON COMMIT DELETE ROWS */ CREATE TEMPORARY TABLE x (x INT) ON COMMIT DELETE ROWS;
/* while we're here, verify successful truncation of index with SQL function */ CREATE INDEX ON x(BIT_LENGTH('') NULLS LAST);
BEGIN;
INSERT INTO x VALUES (1);
INSERT INTO x VALUES (2);
SELECT * FROM x;
COMMIT;
SELECT * FROM x;
DROP TABLE x;
BEGIN;
CREATE TEMPORARY TABLE x (x) AS SELECT 1 ON COMMIT DELETE ROWS;
SELECT * FROM x;
COMMIT;
SELECT * FROM x;
DROP TABLE x;
/* Test ON COMMIT DROP */ BEGIN;
CREATE TEMP TABLE temptest(col int) ON COMMIT DROP;
INSERT INTO x VALUES (1);
INSERT INTO x VALUES (2);
SELECT * FROM x;
COMMIT;
SELECT * FROM x;
BEGIN;
CREATE TEMP TABLE temptest(col) ON COMMIT DROP AS SELECT 1;
SELECT * FROM x;
COMMIT;
SELECT * FROM x;
/* Test it with a CHECK condition that produces a toasted pg_constraint entry */ BEGIN;
x;
SELECT * FROM x;
COMMIT;
SELECT * FROM x;
/* ON COMMIT is only allowed for TEMP */ CREATE TABLE x (x INT) ON COMMIT DELETE ROWS;
CREATE TABLE x (x) AS SELECT 1 ON COMMIT DELETE ROWS;
/* Test foreign keys */ BEGIN;
CREATE TEMPORARY TABLE x (x INT PRIMARY KEY);
CREATE TEMPORARY TABLE x (x INT REFERENCES x) ON COMMIT DELETE ROWS;
INSERT INTO x VALUES (1);
INSERT INTO x VALUES (1);
COMMIT;
SELECT * FROM x;
SELECT * FROM x;
BEGIN;
CREATE TEMPORARY TABLE x (x INT PRIMARY KEY) ON COMMIT DELETE ROWS;
CREATE TEMPORARY TABLE x (x INT REFERENCES x);
COMMIT;
/* Test manipulation of temp schema's placement in search path */ CREATE TABLE x.x (x TEXT);
INSERT INTO x.x VALUES ('public');
CREATE TEMPORARY TABLE x (x TEXT);
INSERT INTO x VALUES ('temp');
CREATE FUNCTION x.x() RETURNS TEXT LANGUAGE sql AS $$select 'public'::text$$;
CREATE FUNCTION x.x() RETURNS TEXT LANGUAGE sql AS $$select 'temp'::text$$;
/* default should have pg_temp implicitly first, but only for tables */ SELECT * FROM x;
SELECT WHOAMI();
/* can list temp first explicitly, but it still doesn't affect functions */ set search_path = pg_temp, public;
SELECT * FROM x;
SELECT WHOAMI();
/* or put it last for security */ set search_path = public, pg_temp;
SELECT * FROM x;
SELECT WHOAMI();
/* you can invoke a temp function explicitly, though */ SELECT x.whoami();
DROP TABLE x.x;
/* types in temp schema */ set search_path = pg_temp, public;
create domain pg_temp.nonempty as text check (value <> '');
/* function-syntax invocation of types matches rules for functions */ SELECT NONEMPTY('');
SELECT x.nonempty('');
/* other syntax matches rules for tables */ SELECT CAST('' AS nonempty);
RESET search_path;
/* For partitioned temp tables, ON COMMIT actions ignore storage-less */ /* partitioned tables. */ BEGIN;
CREATE TEMPORARY TABLE x (x INT) WITH (PARTITIONED_BY=LIST(x)) ON COMMIT DELETE ROWS;
CREATE TEMPORARY TABLE x PARTITION OF x FOR VALUES IN (1) ON COMMIT DELETE ROWS;
INSERT INTO x VALUES (1);
COMMIT;
/* partitions are emptied by the previous commit */ SELECT * FROM x;
DROP TABLE x;
/* Check dependencies between ON COMMIT actions with a partitioned */ /* table and its partitions.  Using ON COMMIT DROP on a parent removes */ /* the whole set. */ BEGIN;
create temp table temp_parted_oncommit_test (a int)   partition by list (a) on commit drop;
CREATE TEMPORARY TABLE x PARTITION OF x FOR VALUES IN (1) ON COMMIT DELETE ROWS;
create temp table temp_parted_oncommit_test2   partition of temp_parted_oncommit_test   for values in (2) on commit drop;
INSERT INTO x VALUES (1), (2);
COMMIT;
/* no relations remain in this case. */ SELECT x FROM x WHERE REGEXP_LIKE(x, '^temp_parted_oncommit_test');
/* Using ON COMMIT DELETE on a partitioned table does not remove */ /* all rows if partitions preserve their data. */ BEGIN;
CREATE TEMPORARY TABLE x (x INT) WITH (PARTITIONED_BY=LIST(x)) ON COMMIT DELETE ROWS;
CREATE TEMPORARY TABLE x PARTITION OF x FOR VALUES IN (1) ON COMMIT PRESERVE ROWS;
create temp table temp_parted_oncommit_test2   partition of temp_parted_oncommit_test   for values in (2) on commit drop;
INSERT INTO x VALUES (1), (2);
COMMIT;
/* Data from the remaining partition is still here as its rows are */ /* preserved. */ SELECT * FROM x;
/* two relations remain in this case. */ SELECT x FROM x WHERE REGEXP_LIKE(x, '^temp_parted_oncommit_test') ORDER BY x NULLS LAST;
DROP TABLE x;
/* Check dependencies between ON COMMIT actions with inheritance trees. */ /* Using ON COMMIT DROP on a parent removes the whole set. */ BEGIN;
create temp table temp_inh_oncommit_test (a int) on commit drop;
CREATE TEMPORARY TABLE x INHERITS (x) ON COMMIT DELETE ROWS;
INSERT INTO x VALUES (1);
COMMIT;
/* no relations remain in this case */ SELECT x FROM x WHERE REGEXP_LIKE(x, '^temp_inh_oncommit_test');
/* Data on the parent is removed, and the child goes away. */ BEGIN;
CREATE TEMPORARY TABLE x (x INT) ON COMMIT DELETE ROWS;
create temp table temp_inh_oncommit_test1 ()   inherits(temp_inh_oncommit_test) on commit drop;
INSERT INTO x VALUES (1);
INSERT INTO x VALUES (1);
COMMIT;
SELECT * FROM x;
/* one relation remains */ SELECT x FROM x WHERE REGEXP_LIKE(x, '^temp_inh_oncommit_test');
DROP TABLE x;
/* Tests with two-phase commit */ /* Transactions creating objects in a temporary namespace cannot be used */ /* with two-phase commit. */ /* These cases generate errors about temporary namespace. */ /* Function creation */ BEGIN;
CREATE FUNCTION x.x() RETURNS void LANGUAGE sql AS $$ select '2pc_func'::text $$;
PREPARE transaction 'twophase_func';
/* Function drop */ CREATE FUNCTION x.x() RETURNS void LANGUAGE sql AS $$ select '2pc_func'::text $$;
BEGIN;
DROP FUNCTION x.x;
PREPARE transaction 'twophase_func';
/* Operator creation */ BEGIN;
create operator pg_temp.@@ (leftarg = int4, rightarg = int4, procedure = int4mi);
PREPARE transaction 'twophase_operator';
/* These generate errors about temporary tables. */ BEGIN;
create type pg_temp.twophase_type as (a int);
PREPARE transaction 'twophase_type';
BEGIN;
CREATE VIEW x.x AS SELECT 1;
PREPARE transaction 'twophase_view';
BEGIN;
CREATE SEQUENCE x.x;
PREPARE transaction 'twophase_sequence';
/* Temporary tables cannot be used with two-phase commit. */ CREATE TEMPORARY TABLE x (x INT);
BEGIN;
SELECT x FROM x;
PREPARE transaction 'twophase_tab';
BEGIN;
INSERT INTO x VALUES (1);
PREPARE transaction 'twophase_tab';
BEGIN;
PREPARE transaction 'twophase_tab';
BEGIN;
DROP TABLE x;
PREPARE transaction 'twophase_tab';
BEGIN;
SELECT REGEXP_LIKE(CURRENT_SCHEMA(), 'pg_temp') AS x;
PREPARE TRANSACTION 'twophase_search';
GRANT ALL ON SCHEMA x TO x /* Postgres formerly made the public schema read/write by default, */ /* and most of the core regression tests still expect that. */;
SET x = TRUE /* Create a tablespace we can use in tests. */;
CREATE TABLESPACE regress_tblspace LOCATION '';
/* These tables have traditionally been referenced by many tests, */ /* so create and populate them.  Insert only non-error values here. */ /* (Some subsequent tests try to insert erroneous values.  That's okay */ /* because the table won't actually change.  Do not change the contents */ /* of these tables in later tests, as it may affect other tests.) */ CREATE TABLE x (x CHAR(4));
INSERT INTO x (x) VALUES ('a'), ('ab'), ('abcd'), ('abcd    ');
VACUUM CHAR_TBL;
CREATE TABLE x (x DOUBLE);
INSERT INTO x (x) VALUES ('0.0'), ('-34.84'), ('-1004.30'), ('-1.2345678901234e+200'), ('-1.2345678901234e-200');
VACUUM FLOAT8_TBL;
CREATE TABLE x (x SMALLINT);
INSERT INTO x (x) VALUES ('0   '), ('  1234 '), ('    -1234'), ('32767') /* largest and smallest values */, ('-32767');
VACUUM INT2_TBL;
CREATE TABLE x (x INT);
INSERT INTO x (x) VALUES ('   0  '), ('123456     '), ('    -123456'), ('2147483647') /* largest and smallest values */, ('-2147483647');
VACUUM INT4_TBL;
CREATE TABLE x (x BIGINT, x BIGINT);
INSERT INTO x VALUES ('  123   ', '  456'), ('123   ', '4567890123456789'), ('4567890123456789', '123'), (4567890123456789, '4567890123456789'), ('+4567890123456789', '-4567890123456789');
VACUUM INT8_TBL;
CREATE TABLE x (x point);
INSERT INTO x (x) VALUES ('(0.0,0.0)'), ('(-10.0,0.0)'), ('(-3.0,4.0)'), ('(5.1, 34.5)'), ('(-5.0,-12.0)'), ('(1e-300,-1e-300)') /* To underflow */, ('(1e+300,Inf)') /* To overflow */, ('(Inf,1e+300)') /* Transposed */, (' ( Nan , NaN ) '), ('10.0,10.0');
INSERT INTO x VALUES ('doh!'), ('hi de ho neighbor');
VACUUM TEXT_TBL;
CREATE TABLE x (x VARCHAR(4));
INSERT INTO x (x) VALUES ('a'), ('ab'), ('abcd'), ('abcd    ');
VACUUM VARCHAR_TBL;
CREATE TABLE x (x INT, x INT, x INT, x INT, x INT, x INT, x INT, x INT, x INT, x INT, x INT, x INT, x INT, x NAME, x NAME, x NAME);
VACUUM ANALYZE onek;
CREATE TABLE x AS SELECT * FROM x;
VACUUM ANALYZE onek2;
CREATE TABLE x (x INT, x INT, x INT, x INT, x INT, x INT, x INT, x INT, x INT, x INT, x INT, x INT, x INT, x NAME, x NAME, x NAME);
VACUUM ANALYZE tenk1;
CREATE TABLE x AS SELECT * FROM x;
VACUUM ANALYZE tenk2;
CREATE TABLE x (x TEXT, x INT, x point);
VACUUM ANALYZE person;
CREATE TABLE x (x INT, x NAME) INHERITS (x);
VACUUM ANALYZE emp;
CREATE TABLE x (x DOUBLE) INHERITS (x);
VACUUM ANALYZE student;
CREATE TABLE x (x INT) INHERITS (x, x);
VACUUM ANALYZE stud_emp;
CREATE TABLE x (x TEXT, x path);
VACUUM ANALYZE road;
CREATE TABLE x INHERITS (x);
INSERT INTO x SELECT * FROM ONLY x WHERE REGEXP_LIKE(x, 'I- .*');
VACUUM ANALYZE ihighway;
CREATE TABLE x (x TEXT) INHERITS (x);
INSERT INTO x SELECT *, 'asphalt' FROM ONLY x WHERE REGEXP_LIKE(x, 'State Hwy.*');
VACUUM ANALYZE shighway;
/* We must have some enum type in the database for opr_sanity and type_sanity. */ create type stoplight as enum ('red', 'yellow', 'green');
/* Also create some non-built-in range types. */ create type float8range as range (subtype = float8, subtype_diff = float8mi);
create type textrange as range (subtype = text, collation = "C");
/* Create some C functions that will be used by various tests. */ CREATE FUNCTION binary_coercible(oid, oid)     RETURNS bool     AS :'regresslib', 'binary_coercible'     LANGUAGE C STRICT STABLE PARALLEL SAFE;
CREATE FUNCTION ttdummy ()     RETURNS trigger     AS :'regresslib'     LANGUAGE C;
create operator class part_test_int4_ops for type int4 using hash as     operator 1 =,     function 2 part_hashint4_noop(int4, int8);
create function part_hashtext_length(value text, seed int8)     returns int8 as $$     select length(coalesce(value, ''))::int8     $$ language sql strict immutable parallel safe;
create operator class part_test_text_ops for type text using hash as     operator 1 =,     function 2 part_hashtext_length(text, int8);
/* These functions are used in tests that used to use md5(), which we now */ /* mostly avoid so that the tests will pass in FIPS mode. */ create function fipshash(bytea)     returns text     strict immutable parallel safe leakproof     return substr(encode(sha256($1), 'hex'), 1, 32);
create function fipshash(text)     returns text     strict immutable parallel safe leakproof     return substr(encode(sha256($1::bytea), 'hex'), 1, 32);
/* TEXT */ SELECT CAST('this is a text string' AS TEXT) = CAST('this is a text string' AS TEXT) AS x;
SELECT CAST('this is a text string' AS TEXT) = CAST('this is a text strin' AS TEXT) AS x;
/* text_tbl was already created and filled in test_setup.sql. */ SELECT * FROM x;
/* As of 8.3 we have removed most implicit casts to text, so that for example */ /* this no longer works: */ SELECT LENGTH(42);
/* But as a special exception for usability's sake, we still allow implicit */ /* casting to text in concatenations, so long as the other input is text or */ /* an unknown literal.  So these work: */ SELECT CAST('four: ' AS TEXT) || 2 + 2;
SELECT 'four: ' || 2 + 2;
/* but not this: */ SELECT 3 || 4.0;
/*  * various string functions  */ SELECT CONCAT(COALESCE('one', ''));
SELECT CONCAT(COALESCE(1, ''), COALESCE(2, ''), COALESCE(3, ''), COALESCE('hello', ''), COALESCE(TRUE, ''), COALESCE(FALSE, ''), COALESCE(STR_TO_DATE('20100309', '%Y%m%d'), ''));
SELECT CONCAT_WS('#', COALESCE('one', ''));
SELECT CONCAT_WS('#', COALESCE(1, ''), COALESCE(2, ''), COALESCE(3, ''), COALESCE('hello', ''), COALESCE(TRUE, ''), COALESCE(FALSE, ''), COALESCE(STR_TO_DATE('20100309', '%Y%m%d'), ''));
SELECT CONCAT_WS(',', COALESCE(10, ''), COALESCE(20, ''), COALESCE(NULL, ''), COALESCE(30, ''));
SELECT CONCAT_WS('', COALESCE(10, ''), COALESCE(20, ''), COALESCE(NULL, ''), COALESCE(30, ''));
SELECT CONCAT_WS(NULL, COALESCE(10, ''), COALESCE(20, ''), COALESCE(NULL, ''), COALESCE(30, '')) IS NULL;
SELECT REVERSE('abcde');
SELECT x, LEFT('ahoj', x), RIGHT('ahoj', x) FROM x AS x ORDER BY x NULLS LAST;
SELECT QUOTE_LITERAL('');
SELECT QUOTE_LITERAL('abc''');
SELECT QUOTE_LITERAL(\\);
/*  * format  */ SELECT FORMAT(NULL);
SELECT FORMAT('Hello');
SELECT FORMAT('Hello %s', 'World');
SELECT FORMAT('Hello %%');
SELECT FORMAT('Hello %%%%');
/* should fail */ SELECT FORMAT('Hello %s %s', 'World');
SELECT FORMAT('Hello %s');
SELECT FORMAT('Hello %x', 20);
/* check literal and sql identifiers */ SELECT FORMAT('INSERT INTO %I VALUES(%L,%L)', 'mytab', 10, 'Hello');
SELECT FORMAT('%s%s%s', 'Hello', NULL, 'World');
SELECT FORMAT('INSERT INTO %I VALUES(%L,%L)', 'mytab', 10, NULL);
SELECT FORMAT('INSERT INTO %I VALUES(%L,%L)', 'mytab', NULL, 'Hello');
/* should fail, sql identifier cannot be NULL */ SELECT FORMAT('INSERT INTO %I VALUES(%L,%L)', NULL, 10, 'Hello');
/* check positional placeholders */ SELECT FORMAT('%1$s %3$s', 1, 2, 3);
SELECT FORMAT('%1$s %12$s', 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12);
/* should fail */ SELECT FORMAT('%1$s %4$s', 1, 2, 3);
SELECT FORMAT('%1$s %13$s', 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12);
SELECT FORMAT('%0$s', 'Hello');
SELECT FORMAT('%*0$s', 'Hello');
SELECT FORMAT('%1$', 1);
SELECT FORMAT('%1$1', 1);
/* check mix of positional and ordered placeholders */ SELECT FORMAT('Hello %s %1$s %s', 'World', 'Hello again');
SELECT FORMAT('Hello %s %s, %2$s %2$s', 'World', 'Hello again');
/* check field widths and left, right alignment */ SELECT FORMAT('>>%10s<<', 'Hello');
SELECT FORMAT('>>%10s<<', NULL);
SELECT FORMAT('>>%10s<<', '');
SELECT FORMAT('>>%-10s<<', '');
SELECT FORMAT('>>%-10s<<', 'Hello');
SELECT FORMAT('>>%-10s<<', NULL);
SELECT FORMAT('>>%1$10s<<', 'Hello');
SELECT FORMAT('>>%1$-10I<<', 'Hello');
SELECT FORMAT('>>%2$*1$L<<', 10, 'Hello');
SELECT FORMAT('>>%2$*1$L<<', 10, NULL);
SELECT FORMAT('>>%2$*1$L<<', -10, NULL);
SELECT FORMAT('>>%*s<<', 10, 'Hello');
SELECT FORMAT('>>%*1$s<<', 10, 'Hello');
SELECT FORMAT('>>%-s<<', 'Hello');
SELECT FORMAT('>>%10L<<', NULL);
SELECT FORMAT('>>%2$*1$L<<', NULL, 'Hello');
SELECT FORMAT('>>%2$*1$L<<', 0, 'Hello');
/* basic tests for the TID data type */ SELECT CAST('(0,0)' AS tid) AS x, CAST('(0,1)' AS tid) AS x, CAST('(-1,0)' AS tid) AS x, CAST('(4294967295,65535)' AS tid) AS x;
SELECT CAST('(4294967296,1)' AS tid);
/* error */ SELECT CAST('(1,65536)' AS tid);
/* error */ /* Also try it with non-error-throwing API */ SELECT PG_INPUT_IS_VALID('(0)', 'tid');
SELECT * FROM x;
SELECT PG_INPUT_IS_VALID('(0,-1)', 'tid');
SELECT * FROM x;
/* tests for functions related to TID handling */ CREATE TABLE x (x INT);
/* min() and max() for TIDs */ INSERT INTO x VALUES (1), (2);
SELECT MIN(x) FROM x;
SELECT MAX(x) FROM x;
TRUNCATE TABLE x;
/* Tests for currtid2() with various relation kinds */ /* Materialized view */ CREATE MATERIALIZED VIEW x AS SELECT x FROM x;
SELECT CURRTID2(CAST('tid_matview' AS TEXT), CAST('(0,1)' AS tid));
/* fails */ INSERT INTO x VALUES (1);
REFRESH MATERIALIZED VIEW tid_matview;
SELECT CURRTID2(CAST('tid_matview' AS TEXT), CAST('(0,1)' AS tid));
/* ok */ DROP MATERIALIZED VIEW x;
TRUNCATE TABLE x;
/* Sequence */ CREATE SEQUENCE x;
SELECT CURRTID2(CAST('tid_seq' AS TEXT), CAST('(0,1)' AS tid));
/* ok */ DROP SEQUENCE x;
/* Index, fails with incorrect relation type */ CREATE INDEX x ON x(x NULLS LAST);
SELECT CURRTID2(CAST('tid_ind' AS TEXT), CAST('(0,1)' AS tid));
/* fails */ DROP INDEX x;
/* Partitioned table, no storage */ CREATE TABLE x (x INT) WITH (PARTITIONED_BY=RANGE(x));
SELECT CURRTID2(CAST('tid_part' AS TEXT), CAST('(0,1)' AS tid));
/* fails */ DROP TABLE x;
/* Views */ /* ctid not defined in the view */ CREATE VIEW x AS SELECT x FROM x;
SELECT CURRTID2(CAST('tid_view_no_ctid' AS TEXT), CAST('(0,1)' AS tid));
/* fails */ DROP VIEW x;
/* ctid fetched directly from the source table. */ CREATE VIEW x AS SELECT x, x FROM x;
SELECT CURRTID2(CAST('tid_view_with_ctid' AS TEXT), CAST('(0,1)' AS tid));
/* fails */ INSERT INTO x VALUES (1);
SELECT CURRTID2(CAST('tid_view_with_ctid' AS TEXT), CAST('(0,1)' AS tid));
/* ok */ DROP VIEW x;
TRUNCATE TABLE x;
/* ctid attribute with incorrect data type */ CREATE VIEW x AS SELECT 1 AS x, 2 AS x;
SELECT CURRTID2(CAST('tid_view_fake_ctid' AS TEXT), CAST('(0,1)' AS tid));
/* fails */ DROP VIEW x;
DROP TABLE x CASCADE;
SET x = off /* tests for tidrangescans */;
CREATE TABLE x (x INT, x TEXT);
/* empty table */ EXPLAIN (COSTS OFF) SELECT ctid FROM tidrangescan WHERE ctid < '(1, 0)';
SELECT x FROM x WHERE x < '(1, 0)';
EXPLAIN (COSTS OFF) SELECT ctid FROM tidrangescan WHERE ctid > '(9, 0)';
SELECT x FROM x WHERE x > '(9, 0)';
/* insert enough tuples to fill at least two pages */ INSERT INTO x SELECT x, REPEAT('x', 100) FROM x AS x;
/* remove all tuples after the 10th tuple on each page.  Trying to ensure */ /* we get the same layout with all CPU architectures and smaller than standard */ /* page sizes. */ DELETE FROM x WHERE CAST(SUBSTRING(CAST(x AS TEXT), ',(\d+)\)') AS INT) > 10 OR CAST(SUBSTRING(CAST(x AS TEXT), '\((\d+),') AS INT) > 2;
VACUUM tidrangescan;
/* range scans with upper bound */ EXPLAIN (COSTS OFF) SELECT ctid FROM tidrangescan WHERE ctid < '(1,0)';
SELECT x FROM x WHERE x < '(1,0)';
EXPLAIN (COSTS OFF) SELECT ctid FROM tidrangescan WHERE ctid <= '(1,5)';
SELECT x FROM x WHERE x <= '(1,5)';
EXPLAIN (COSTS OFF) SELECT ctid FROM tidrangescan WHERE ctid < '(0,0)';
SELECT x FROM x WHERE x < '(0,0)';
/* range scans with lower bound */ EXPLAIN (COSTS OFF) SELECT ctid FROM tidrangescan WHERE ctid > '(2,8)';
SELECT x FROM x WHERE x > '(2,8)';
EXPLAIN (COSTS OFF) SELECT ctid FROM tidrangescan WHERE '(2,8)' < ctid;
SELECT x FROM x WHERE '(2,8)' < x;
EXPLAIN (COSTS OFF) SELECT ctid FROM tidrangescan WHERE ctid >= '(2,8)';
SELECT x FROM x WHERE x >= '(2,8)';
EXPLAIN (COSTS OFF) SELECT ctid FROM tidrangescan WHERE ctid >= '(100,0)';
SELECT x FROM x WHERE x >= '(100,0)';
/* range scans with both bounds */ EXPLAIN (COSTS OFF) SELECT ctid FROM tidrangescan WHERE ctid > '(1,4)' AND '(1,7)' >= ctid;
SELECT x FROM x WHERE x > '(1,4)' AND '(1,7)' >= x;
EXPLAIN (COSTS OFF) SELECT ctid FROM tidrangescan WHERE '(1,7)' >= ctid AND ctid > '(1,4)';
SELECT x FROM x WHERE '(1,7)' >= x AND x > '(1,4)';
/* extreme offsets */ SELECT x FROM x WHERE x > '(0,65535)' AND x < '(1,0)' LIMIT 1;
SELECT x FROM x WHERE x < '(0,0)' LIMIT 1;
SELECT x FROM x WHERE x > '(4294967295,65535)';
SELECT x FROM x WHERE x < '(0,0)';
/* NULLs in the range cannot return tuples */ SELECT x FROM x WHERE x >= (SELECT CAST(NULL AS tid));
/* rescans */ EXPLAIN (COSTS OFF) SELECT t.ctid,t2.c FROM tidrangescan t, LATERAL (SELECT count(*) c FROM tidrangescan t2 WHERE t2.ctid <= t.ctid) t2 WHERE t.ctid < '(1,0)';
SELECT x.x, x.x FROM x AS x, LATERAL (SELECT COUNT(*) AS x FROM x AS x WHERE x.x <= x.x) AS x WHERE x.x < '(1,0)';
/* cursors */ /* Ensure we get a TID Range scan without a Materialize node. */ EXPLAIN (COSTS OFF) DECLARE c SCROLL CURSOR FOR SELECT ctid FROM tidrangescan WHERE ctid < '(1,0)';
BEGIN;
DECLARE c SCROLL CURSOR FOR SELECT ctid FROM tidrangescan WHERE ctid < '(1,0)';
FETCH NEXT c;
FETCH NEXT c;
FETCH PRIOR c;
FETCH FIRST c;
FETCH LAST c;
COMMIT;
DROP TABLE x;
RESET enable_seqscan;
/* tests for tidscans */ CREATE TABLE x (x INT);
/* only insert a few rows, we don't want to spill onto a second table page */ INSERT INTO x VALUES (1), (2), (3);
/* show ctids */ SELECT x, * FROM x;
/* ctid equality - implemented as tidscan */ EXPLAIN (COSTS OFF) SELECT ctid, * FROM tidscan WHERE ctid = '(0,1)';
SELECT x, * FROM x WHERE x = '(0,1)';
EXPLAIN (COSTS OFF) SELECT ctid, * FROM tidscan WHERE '(0,1)' = ctid;
SELECT x, * FROM x WHERE '(0,1)' = x;
/* OR'd clauses */ EXPLAIN (COSTS OFF) SELECT ctid, * FROM tidscan WHERE ctid = '(0,2)' OR '(0,1)' = ctid;
SELECT x, * FROM x WHERE x = '(0,2)' OR '(0,1)' = x;
/* ctid = ScalarArrayOp - implemented as tidscan */ EXPLAIN (COSTS OFF) SELECT ctid, * FROM tidscan WHERE ctid = ANY(ARRAY['(0,1)', '(0,2)']::tid[]);
SELECT x, * FROM x WHERE x = ANY(CAST(ARRAY('(0,1)', '(0,2)') AS ARRAY<tid>));
/* ctid != ScalarArrayOp - can't be implemented as tidscan */ EXPLAIN (COSTS OFF) SELECT ctid, * FROM tidscan WHERE ctid != ANY(ARRAY['(0,1)', '(0,2)']::tid[]);
SELECT x, * FROM x WHERE x <> ANY(CAST(ARRAY('(0,1)', '(0,2)') AS ARRAY<tid>));
/* tid equality extracted from sub-AND clauses */ EXPLAIN (COSTS OFF) SELECT ctid, * FROM tidscan WHERE (id = 3 AND ctid IN ('(0,2)', '(0,3)')) OR (ctid = '(0,1)' AND id = 1);
SELECT x, * FROM x WHERE (x = 3 AND x IN ('(0,2)', '(0,3)')) OR (x = '(0,1)' AND x = 1);
SET x = off /* nestloop-with-inner-tidscan joins on tid */;
/* otherwise hash join might win */ EXPLAIN (COSTS OFF) SELECT t1.ctid, t1.*, t2.ctid, t2.* FROM tidscan t1 JOIN tidscan t2 ON t1.ctid = t2.ctid WHERE t1.id = 1;
SELECT x.x, x.*, x.x, x.* FROM x AS x JOIN x AS x ON x.x = x.x WHERE x.x = 1;
EXPLAIN (COSTS OFF) SELECT t1.ctid, t1.*, t2.ctid, t2.* FROM tidscan t1 LEFT JOIN tidscan t2 ON t1.ctid = t2.ctid WHERE t1.id = 1;
SELECT x.x, x.*, x.x, x.* FROM x AS x LEFT JOIN x AS x ON x.x = x.x WHERE x.x = 1;
RESET enable_hashjoin;
/* exercise backward scan and rewind */ BEGIN;
DECLARE c CURSOR FOR SELECT ctid, * FROM tidscan WHERE ctid = ANY(ARRAY['(0,1)', '(0,2)']::tid[]);
FETCH ALL FROM c;
FETCH BACKWARD 1 FROM c;
FETCH FIRST FROM c;
ROLLBACK;
/* tidscan via CURRENT OF */ BEGIN;
DECLARE c CURSOR FOR SELECT ctid, * FROM tidscan;
FETCH NEXT FROM c;
/* skip one row */ FETCH NEXT FROM c;
/* perform update */ EXPLAIN (ANALYZE, COSTS OFF, SUMMARY OFF, TIMING OFF, BUFFERS OFF) UPDATE tidscan SET id = -id WHERE CURRENT OF c RETURNING *;
FETCH NEXT FROM c;
/* perform update */ EXPLAIN (ANALYZE, COSTS OFF, SUMMARY OFF, TIMING OFF, BUFFERS OFF) UPDATE tidscan SET id = -id WHERE CURRENT OF c RETURNING *;
SELECT * FROM x;
/* position cursor past any rows */ FETCH NEXT FROM c;
/* should error out */ EXPLAIN (ANALYZE, COSTS OFF, SUMMARY OFF, TIMING OFF, BUFFERS OFF) UPDATE tidscan SET id = -id WHERE CURRENT OF c RETURNING *;
ROLLBACK;
/* bulk joins on CTID */ /* (these plans don't use TID scans, but this still seems like an */ /* appropriate place for these tests) */ EXPLAIN (COSTS OFF) SELECT count(*) FROM tenk1 t1 JOIN tenk1 t2 ON t1.ctid = t2.ctid;
SELECT COUNT(*) FROM x AS x JOIN x AS x ON x.x = x.x;
SET x = off;
EXPLAIN (COSTS OFF) SELECT count(*) FROM tenk1 t1 JOIN tenk1 t2 ON t1.ctid = t2.ctid;
SELECT COUNT(*) FROM x AS x JOIN x AS x ON x.x = x.x;
RESET enable_hashjoin;
/* check predicate lock on CTID */ BEGIN ISOLATION LEVEL SERIALIZABLE;
SELECT * FROM x WHERE x = '(0,1)';
/* locktype should be 'tuple' */ SELECT x, x FROM x WHERE x = PG_BACKEND_PID() AND x = 'SIReadLock';
ROLLBACK;
DROP TABLE x;
/* TIME */ CREATE TABLE x (x TIME(2));
INSERT INTO x VALUES ('00:00');
INSERT INTO x VALUES ('01:00');
/* as of 7.4, timezone spec should be accepted and ignored */ INSERT INTO x VALUES ('02:03 PST');
INSERT INTO x VALUES ('11:59 EDT');
INSERT INTO x VALUES ('12:00');
INSERT INTO x VALUES ('12:01');
INSERT INTO x VALUES ('23:59');
INSERT INTO x VALUES ('11:59:59.99 PM');
INSERT INTO x VALUES ('2003-03-07 15:36:39 America/New_York');
INSERT INTO x VALUES ('2003-07-07 15:36:39 America/New_York');
/* this should fail (the timezone offset is not known) */ INSERT INTO x VALUES ('15:36:39 America/New_York');
SELECT x AS "x" FROM x;
SELECT x AS "x" FROM x WHERE x < '05:06:07';
SELECT x AS "x" FROM x WHERE x > '05:06:07';
SELECT x AS "x" FROM x WHERE x < '00:00';
SELECT x AS "x" FROM x WHERE x >= '00:00';
/* Check edge cases */ SELECT CAST('23:59:59.999999' AS TIME);
SELECT CAST('23:59:59.9999999' AS TIME);
/* rounds up */ SELECT CAST('23:59:60' AS TIME);
/* rounds up */ SELECT CAST('24:00:00' AS TIME);
/* allowed */ SELECT CAST('24:00:00.01' AS TIME);
/* not allowed */ SELECT CAST('23:59:60.01' AS TIME);
/* not allowed */ SELECT CAST('24:01:00' AS TIME);
/* not allowed */ SELECT CAST('25:00:00' AS TIME);
/* not allowed */ /* Test non-error-throwing API */ SELECT PG_INPUT_IS_VALID('12:00:00', 'time');
SELECT PG_INPUT_IS_VALID('25:00:00', 'time');
SELECT PG_INPUT_IS_VALID('15:36:39 America/New_York', 'time');
SELECT * FROM x;
SELECT * FROM x;
/* TIME simple math */ /* We now make a distinction between time and intervals, */ /* and adding two times together makes no sense at all. */ /* Leave in one query to show that it is rejected, */ /* and do the rest of the testing in horology.sql */ /* where we do mixed-type arithmetic. - thomas 2000-12-02 */ SELECT x + CAST('00:01' AS TIME) AS "x" FROM x;
/* test EXTRACT */ SELECT EXTRACT(MICROSECOND FROM CAST('2020-05-26 13:30:25.575401' AS TIME));
SELECT EXTRACT(MILLISECOND FROM CAST('2020-05-26 13:30:25.575401' AS TIME));
SELECT EXTRACT(SECOND FROM CAST('2020-05-26 13:30:25.575401' AS TIME));
SELECT EXTRACT(MINUTE FROM CAST('2020-05-26 13:30:25.575401' AS TIME));
SELECT EXTRACT(HOUR FROM CAST('2020-05-26 13:30:25.575401' AS TIME));
SELECT EXTRACT(DAY FROM CAST('2020-05-26 13:30:25.575401' AS TIME));
/* error */ SELECT EXTRACT(FORTNIGHT FROM CAST('2020-05-26 13:30:25.575401' AS TIME));
/* error */ SELECT EXTRACT(TIMEZONE FROM CAST('2020-05-26 13:30:25.575401' AS TIME));
/* error */ SELECT EXTRACT(EPOCH FROM CAST('2020-05-26 13:30:25.575401' AS TIME));
/* date_part implementation is mostly the same as extract, so only */ /* test a few cases for additional coverage. */ SELECT EXTRACT(microsecond FROM CAST('2020-05-26 13:30:25.575401' AS TIME));
SELECT EXTRACT(millisecond FROM CAST('2020-05-26 13:30:25.575401' AS TIME));
SELECT EXTRACT(second FROM CAST('2020-05-26 13:30:25.575401' AS TIME));
SELECT EXTRACT(epoch FROM CAST('2020-05-26 13:30:25.575401' AS TIME));
/* TIMESTAMP */ CREATE TABLE x (x TIMESTAMP(2));
INSERT INTO x VALUES ('today');
INSERT INTO x VALUES ('yesterday');
INSERT INTO x VALUES ('tomorrow');
/* time zone should be ignored by this data type */ INSERT INTO x VALUES ('tomorrow EST');
INSERT INTO x VALUES ('tomorrow zulu');
SELECT COUNT(*) AS x FROM x WHERE x = CAST('today' AS TIMESTAMP);
SELECT COUNT(*) AS x FROM x WHERE x = CAST('tomorrow' AS TIMESTAMP);
SELECT COUNT(*) AS x FROM x WHERE x = CAST('yesterday' AS TIMESTAMP);
COMMIT;
DELETE FROM x;
/* Verify that 'now' *does* change over a reasonable interval such as 100 msec, */ /* and that it doesn't change over the same interval within a transaction block */ INSERT INTO x VALUES ('now');
SELECT PG_SLEEP(0.1);
BEGIN;
INSERT INTO x VALUES ('now');
SELECT PG_SLEEP(0.1);
INSERT INTO x VALUES ('now');
SELECT PG_SLEEP(0.1);
SELECT COUNT(*) AS x FROM x WHERE x = CAST('now' AS TIMESTAMP(2));
SELECT COUNT(x) AS x, COUNT(DISTINCT x) AS x FROM x;
COMMIT;
TRUNCATE TABLE x;
/* Special values */ INSERT INTO x VALUES ('-infinity');
INSERT INTO x VALUES ('infinity');
INSERT INTO x VALUES ('epoch');
SELECT CAST('infinity' AS TIMESTAMP) = CAST('+infinity' AS TIMESTAMP) AS x;
/* Postgres v6.0 standard output format */ INSERT INTO x VALUES ('Mon Feb 10 17:32:01 1997 PST');
/* Variations on Postgres v6.1 standard output format */ INSERT INTO x VALUES ('Mon Feb 10 17:32:01.000001 1997 PST');
INSERT INTO x VALUES ('Mon Feb 10 17:32:01.999999 1997 PST');
INSERT INTO x VALUES ('Mon Feb 10 17:32:01.4 1997 PST');
INSERT INTO x VALUES ('Mon Feb 10 17:32:01.5 1997 PST');
INSERT INTO x VALUES ('Mon Feb 10 17:32:01.6 1997 PST');
/* ISO 8601 format */ INSERT INTO x VALUES ('1997-01-02');
INSERT INTO x VALUES ('1997-01-02 03:04:05');
INSERT INTO x VALUES ('1997-02-10 17:32:01-08');
INSERT INTO x VALUES ('1997-02-10 17:32:01-0800');
INSERT INTO x VALUES ('1997-02-10 17:32:01 -08:00');
INSERT INTO x VALUES ('19970210 173201 -0800');
INSERT INTO x VALUES ('1997-06-10 17:32:01 -07:00');
INSERT INTO x VALUES ('2001-09-22T18:19:20');
/* POSIX format (note that the timezone abbrev is just decoration here) */ INSERT INTO x VALUES ('2000-03-15 08:14:01 GMT+8');
INSERT INTO x VALUES ('2000-03-15 13:14:02 GMT-1');
INSERT INTO x VALUES ('2000-03-15 12:14:03 GMT-2');
INSERT INTO x VALUES ('2000-03-15 03:14:04 PST+8');
INSERT INTO x VALUES ('2000-03-15 02:14:05 MST+7:00');
/* Variations for acceptable input formats */ INSERT INTO x VALUES ('Feb 10 17:32:01 1997 -0800');
INSERT INTO x VALUES ('Feb 10 17:32:01 1997');
INSERT INTO x VALUES ('Feb 10 5:32PM 1997');
INSERT INTO x VALUES ('1997/02/10 17:32:01-0800');
INSERT INTO x VALUES ('1997-02-10 17:32:01 PST');
INSERT INTO x VALUES ('Feb-10-1997 17:32:01 PST');
INSERT INTO x VALUES ('02-10-1997 17:32:01 PST');
INSERT INTO x VALUES ('19970210 173201 PST');
SET x = ymd;
INSERT INTO x VALUES ('97FEB10 5:32:01PM UTC');
INSERT INTO x VALUES ('97/02/10 17:32:01 UTC');
RESET datestyle;
INSERT INTO x VALUES ('1997.041 17:32:01 UTC');
INSERT INTO x VALUES ('19970210 173201 America/New_York');
/* this fails (even though TZ is a no-op, we still look it up) */ INSERT INTO x VALUES ('19970710 173201 America/Does_not_exist');
/* Test non-error-throwing API */ SELECT PG_INPUT_IS_VALID('now', 'timestamp');
SELECT PG_INPUT_IS_VALID('garbage', 'timestamp');
SELECT PG_INPUT_IS_VALID('2001-01-01 00:00 Nehwon/Lankhmar', 'timestamp');
SELECT * FROM x;
SELECT * FROM x;
/* Check date conversion and date arithmetic */ INSERT INTO x VALUES ('1997-06-10 18:32:01 PDT');
INSERT INTO x VALUES ('Feb 10 17:32:01 1997');
INSERT INTO x VALUES ('Feb 11 17:32:01 1997');
INSERT INTO x VALUES ('Feb 12 17:32:01 1997');
INSERT INTO x VALUES ('Feb 13 17:32:01 1997');
INSERT INTO x VALUES ('Feb 14 17:32:01 1997');
INSERT INTO x VALUES ('Feb 15 17:32:01 1997');
INSERT INTO x VALUES ('Feb 16 17:32:01 1997');
INSERT INTO x VALUES ('Feb 16 17:32:01 0097 BC');
INSERT INTO x VALUES ('Feb 16 17:32:01 0097');
INSERT INTO x VALUES ('Feb 16 17:32:01 0597');
INSERT INTO x VALUES ('Feb 16 17:32:01 1097');
INSERT INTO x VALUES ('Feb 16 17:32:01 1697');
INSERT INTO x VALUES ('Feb 16 17:32:01 1797');
INSERT INTO x VALUES ('Feb 16 17:32:01 1897');
INSERT INTO x VALUES ('Feb 16 17:32:01 1997');
INSERT INTO x VALUES ('Feb 16 17:32:01 2097');
INSERT INTO x VALUES ('Feb 28 17:32:01 1996');
INSERT INTO x VALUES ('Feb 29 17:32:01 1996');
INSERT INTO x VALUES ('Mar 01 17:32:01 1996');
INSERT INTO x VALUES ('Dec 30 17:32:01 1996');
INSERT INTO x VALUES ('Dec 31 17:32:01 1996');
INSERT INTO x VALUES ('Jan 01 17:32:01 1997');
INSERT INTO x VALUES ('Feb 28 17:32:01 1997');
INSERT INTO x VALUES ('Feb 29 17:32:01 1997');
INSERT INTO x VALUES ('Mar 01 17:32:01 1997');
INSERT INTO x VALUES ('Dec 30 17:32:01 1997');
INSERT INTO x VALUES ('Dec 31 17:32:01 1997');
INSERT INTO x VALUES ('Dec 31 17:32:01 1999');
INSERT INTO x VALUES ('Jan 01 17:32:01 2000');
INSERT INTO x VALUES ('Dec 31 17:32:01 2000');
INSERT INTO x VALUES ('Jan 01 17:32:01 2001');
/* Currently unsupported syntax and ranges */ INSERT INTO x VALUES ('Feb 16 17:32:01 -0097');
INSERT INTO x VALUES ('Feb 16 17:32:01 5097 BC');
SELECT x FROM x;
/* Check behavior at the boundaries of the timestamp range */ SELECT CAST('4714-11-24 00:00:00 BC' AS TIMESTAMP);
SELECT CAST('4714-11-23 23:59:59 BC' AS TIMESTAMP);
/* out of range */ SELECT CAST('294276-12-31 23:59:59' AS TIMESTAMP);
SELECT CAST('294277-01-01 00:00:00' AS TIMESTAMP);
/* out of range */ /* Demonstrate functions and operators */ SELECT x FROM x WHERE x > CAST('1997-01-02' AS TIMESTAMP);
SELECT x FROM x WHERE x < CAST('1997-01-02' AS TIMESTAMP);
SELECT x FROM x WHERE x = CAST('1997-01-02' AS TIMESTAMP);
SELECT x FROM x WHERE x <> CAST('1997-01-02' AS TIMESTAMP);
SELECT x FROM x WHERE x <= CAST('1997-01-02' AS TIMESTAMP);
SELECT x FROM x WHERE x >= CAST('1997-01-02' AS TIMESTAMP);
SELECT x - CAST('1997-01-02' AS TIMESTAMP) AS x FROM x WHERE x BETWEEN '1902-01-01' AND '2038-01-01';
SELECT TIMESTAMP_TRUNC(CAST('2004-02-29 15:44:17.71393' AS TIMESTAMP), WEEK) AS x;
SELECT TIMESTAMP_TRUNC(CAST('infinity' AS TIMESTAMP), AGO) AS x;
/* verify date_bin behaves the same as date_trunc for relevant intervals */ /* case 1: AD dates, origin < input */ SELECT x, x, TIMESTAMP_TRUNC(x, STR) = DATE_BIN(CAST(x AS INTERVAL), x, CAST('2001-01-01' AS TIMESTAMP)) AS x FROM (VALUES ('week', '7 d'), ('day', '1 d'), ('hour', '1 h'), ('minute', '1 m'), ('second', '1 s'), ('millisecond', '1 ms'), ('microsecond', '1 us')) AS x, (VALUES (CAST('2020-02-29 15:44:17.71393' AS TIMESTAMP))) AS x;
/* case 2: BC dates, origin < input */ SELECT x, x, TIMESTAMP_TRUNC(x, STR) = DATE_BIN(CAST(x AS INTERVAL), x, CAST('2000-01-01 BC' AS TIMESTAMP)) AS x FROM (VALUES ('week', '7 d'), ('day', '1 d'), ('hour', '1 h'), ('minute', '1 m'), ('second', '1 s'), ('millisecond', '1 ms'), ('microsecond', '1 us')) AS x, (VALUES (CAST('0055-6-10 15:44:17.71393 BC' AS TIMESTAMP))) AS x;
/* case 3: AD dates, origin > input */ SELECT x, x, TIMESTAMP_TRUNC(x, STR) = DATE_BIN(CAST(x AS INTERVAL), x, CAST('2020-03-02' AS TIMESTAMP)) AS x FROM (VALUES ('week', '7 d'), ('day', '1 d'), ('hour', '1 h'), ('minute', '1 m'), ('second', '1 s'), ('millisecond', '1 ms'), ('microsecond', '1 us')) AS x, (VALUES (CAST('2020-02-29 15:44:17.71393' AS TIMESTAMP))) AS x;
/* case 4: BC dates, origin > input */ SELECT x, x, TIMESTAMP_TRUNC(x, STR) = DATE_BIN(CAST(x AS INTERVAL), x, CAST('0055-06-17 BC' AS TIMESTAMP)) AS x FROM (VALUES ('week', '7 d'), ('day', '1 d'), ('hour', '1 h'), ('minute', '1 m'), ('second', '1 s'), ('millisecond', '1 ms'), ('microsecond', '1 us')) AS x, (VALUES (CAST('0055-6-10 15:44:17.71393 BC' AS TIMESTAMP))) AS x;
/* bin timestamps into arbitrary intervals */ SELECT x, x, x, DATE_BIN(CAST(x AS INTERVAL), x, ORIGIN) FROM (VALUES ('15 days'), ('2 hours'), ('1 hour 30 minutes'), ('15 minutes'), ('10 seconds'), ('100 milliseconds'), ('250 microseconds')) AS x, (VALUES (CAST('2020-02-11 15:44:17.71393' AS TIMESTAMP))) AS x, (VALUES (CAST('2001-01-01' AS TIMESTAMP))) AS x;
/* shift bins using the origin parameter: */ SELECT DATE_BIN(CAST('5 min' AS INTERVAL), CAST('2020-02-01 01:01:01' AS TIMESTAMP), CAST('2020-02-01 00:02:30' AS TIMESTAMP));
/* test roundoff edge case when source < origin */ SELECT DATE_BIN(CAST('30 minutes' AS INTERVAL), CAST('2024-02-01 15:00:00' AS TIMESTAMP), CAST('2024-02-01 17:00:00' AS TIMESTAMP));
/* disallow intervals with months or years */ SELECT DATE_BIN(CAST('5 months' AS INTERVAL), CAST('2020-02-01 01:01:01' AS TIMESTAMP), CAST('2001-01-01' AS TIMESTAMP));
SELECT DATE_BIN(CAST('5 years' AS INTERVAL), CAST('2020-02-01 01:01:01' AS TIMESTAMP), CAST('2001-01-01' AS TIMESTAMP));
/* disallow zero intervals */ SELECT DATE_BIN(CAST('0 days' AS INTERVAL), CAST('1970-01-01 01:00:00' AS TIMESTAMP), CAST('1970-01-01 00:00:00' AS TIMESTAMP));
/* disallow negative intervals */ SELECT DATE_BIN(CAST('-2 days' AS INTERVAL), CAST('1970-01-01 01:00:00' AS TIMESTAMP), CAST('1970-01-01 00:00:00' AS TIMESTAMP));
/* test overflow cases */ SELECT DATE_BIN(CAST('15 minutes' AS INTERVAL), CAST('294276-12-30' AS TIMESTAMP), CAST('4000-12-20 BC' AS TIMESTAMP));
SELECT DATE_BIN(CAST('200000000 days' AS INTERVAL), CAST('2024-02-01' AS TIMESTAMP), CAST('2024-01-01' AS TIMESTAMP));
SELECT DATE_BIN(CAST('365000 days' AS INTERVAL), CAST('4400-01-01 BC' AS TIMESTAMP), CAST('4000-01-01 BC' AS TIMESTAMP));
/* Test casting within a BETWEEN qualifier */ SELECT x - CAST('1997-01-02' AS TIMESTAMP) AS x FROM x WHERE x BETWEEN CAST('1902-01-01' AS TIMESTAMP) AND CAST('2038-01-01' AS TIMESTAMP);
/* DATE_PART (timestamp_part) */ SELECT x AS "x", EXTRACT(year FROM x) AS x, EXTRACT(month FROM x) AS x, EXTRACT(day FROM x) AS x, EXTRACT(hour FROM x) AS x, EXTRACT(minute FROM x) AS x, EXTRACT(second FROM x) AS x FROM x;
SELECT x AS "x", EXTRACT(quarter FROM x) AS x, EXTRACT(msec FROM x) AS x, EXTRACT(usec FROM x) AS x FROM x;
SELECT x AS "x", EXTRACT(isoyear FROM x) AS x, EXTRACT(week FROM x) AS x, EXTRACT(isodow FROM x) AS x, EXTRACT(dow FROM x) AS x, EXTRACT(doy FROM x) AS x FROM x;
SELECT x AS "x", EXTRACT(decade FROM x) AS x, EXTRACT(century FROM x) AS x, EXTRACT(millennium FROM x) AS x, ROUND(EXTRACT(julian FROM x)) AS x, EXTRACT(epoch FROM x) AS x FROM x;
/* extract implementation is mostly the same as date_part, so only */ /* test a few cases for additional coverage. */ SELECT x AS "x", EXTRACT(MICROSECONDS FROM x) AS x, EXTRACT(MILLISECONDS FROM x) AS x, EXTRACT(SECONDS FROM x) AS x, ROUND(EXTRACT(JULIAN FROM x)) AS x, EXTRACT(EPOCH FROM x) AS x FROM x;
/* value near upper bound uses special case in code */ SELECT EXTRACT(epoch FROM CAST('294270-01-01 00:00:00' AS TIMESTAMP));
SELECT EXTRACT(EPOCH FROM CAST('294270-01-01 00:00:00' AS TIMESTAMP));
/* another internal overflow test case */ SELECT EXTRACT(EPOCH FROM CAST('5000-01-01 00:00:00' AS TIMESTAMP));
/* test edge-case overflow in timestamp subtraction */ SELECT CAST('294276-12-31 23:59:59' AS TIMESTAMP) - CAST('1999-12-23 19:59:04.224193' AS TIMESTAMP) AS x;
SELECT CAST('294276-12-31 23:59:59' AS TIMESTAMP) - CAST('1999-12-23 19:59:04.224192' AS TIMESTAMP) AS x;
/* TO_CHAR() */ SELECT TIME_TO_STR(x, '%uAY %uay day %uY %uy dy MONTH Month month RM MON Mon mon') FROM x;
SELECT TIME_TO_STR(x, 'FM%uAY FM%uay FMday F%mONTH F%month FMmonth FMRM') FROM x;
SELECT TIME_TO_STR(x, 'Y,%yY %Y %yY %y Y CC Q %m %U %j %d %u J') FROM x;
SELECT TIME_TO_STR(x, 'FMY,%yY FM%Y FM%yY FM%y FMY FMCC FMQ %-m FM%U %-j %-d FM%u FMJ') FROM x;
SELECT TIME_TO_STR(x, 'HH %I %H %M %S %S%S') FROM x;
SELECT TIME_TO_STR(x, "HH:MI:SS is" HH:MI:SS "\\"text between quote marks\\"") FROM x;
SELECT TIME_TO_STR(x, '%H--text--%M--text--%S') FROM x;
SELECT TIME_TO_STR(x, '%YTH %Yth Jth') FROM x;
SELECT TIME_TO_STR(x, '%Y A.%u. %Y a.d. %Y bc HH:%M:%S P.M. HH:%M:%S p.m. HH:%M:%S pm') FROM x;
SELECT TIME_TO_STR(x, 'I%yY I%y IY I IW I%j I%u') FROM x;
SELECT TIME_TO_STR(x, 'F%M%yY F%M%y F%MY F%M F%MW F%M%j F%M%u') FROM x;
SELECT TIME_TO_STR(x, 'FF1 FF2 FF3 FF4 FF5 FF6  ff1 ff2 ff3 ff4 ff5 ff6  MS %f') FROM (VALUES (CAST('2018-11-02 12:34:56' AS TIMESTAMP)), ('2018-11-02 12:34:56.78'), ('2018-11-02 12:34:56.78901'), ('2018-11-02 12:34:56.78901234')) AS x;
/* Roman months, with upper and lower case. */ SELECT x, TIME_TO_STR(x * INTERVAL '1' MON, 'rm'), TIME_TO_STR(x * INTERVAL '1' MON, 'RM') FROM x AS x;
/* timestamp numeric fields constructor */ SELECT TIMESTAMP_FROM_PARTS(2014, 12, 28, 6, 30, 45.887);
SELECT TIMESTAMP_FROM_PARTS(-44, 3, 15, 12, 30, 15);
/* should fail */ SELECT TIMESTAMP_FROM_PARTS(0, 7, 15, 12, 30, 15);
/* generate_series for timestamp */ SELECT * FROM x;
/* the LIMIT should allow this to terminate in a reasonable amount of time */ /* (but that unfortunately doesn't work yet for SELECT * FROM ...) */ SELECT UNNEST(GENERATE_SERIES(CAST('2022-01-01 00:00' AS TIMESTAMP), CAST('infinity' AS TIMESTAMP), CAST('1 month' AS INTERVAL))) LIMIT 10;
/* errors */ SELECT * FROM x;
SELECT UNNEST(GENERATE_SERIES(CAST('1995-08-06 12:12:12' AS TIMESTAMP), CAST('1996-08-06 12:12:12' AS TIMESTAMP), INTERVAL x));
SELECT UNNEST(GENERATE_SERIES(CAST('1995-08-06 12:12:12' AS TIMESTAMP), CAST('1996-08-06 12:12:12' AS TIMESTAMP), INTERVAL -x));
/* test arithmetic with infinite timestamps */ SELECT CAST('infinity' AS TIMESTAMP) - CAST('infinity' AS TIMESTAMP);
SELECT CAST('infinity' AS TIMESTAMP) - CAST('-infinity' AS TIMESTAMP);
SELECT CAST('-infinity' AS TIMESTAMP) - CAST('infinity' AS TIMESTAMP);
SELECT CAST('-infinity' AS TIMESTAMP) - CAST('-infinity' AS TIMESTAMP);
SELECT CAST('infinity' AS TIMESTAMP) - CAST('1995-08-06 12:12:12' AS TIMESTAMP);
SELECT CAST('-infinity' AS TIMESTAMP) - CAST('1995-08-06 12:12:12' AS TIMESTAMP);
/* test age() with infinite timestamps */ SELECT AGE(CAST('infinity' AS TIMESTAMP));
SELECT AGE(CAST('-infinity' AS TIMESTAMP));
SELECT AGE(CAST('infinity' AS TIMESTAMP), CAST('infinity' AS TIMESTAMP));
SELECT AGE(CAST('infinity' AS TIMESTAMP), CAST('-infinity' AS TIMESTAMP));
SELECT AGE(CAST('-infinity' AS TIMESTAMP), CAST('infinity' AS TIMESTAMP));
SELECT AGE(CAST('-infinity' AS TIMESTAMP), CAST('-infinity' AS TIMESTAMP));
/* test timestamp near POSTGRES_EPOCH_JDATE */ SELECT CAST('1999-12-31 24:00:00' AS TIMESTAMP);
SELECT TIMESTAMP_FROM_PARTS(1999, 12, 31, 24, 0, 0);
/* TIMESTAMPTZ */ CREATE TABLE x (x TIMESTAMPTZ(2));
INSERT INTO x VALUES ('today');
INSERT INTO x VALUES ('yesterday');
INSERT INTO x VALUES ('tomorrow');
INSERT INTO x VALUES ('tomorrow EST');
INSERT INTO x VALUES ('tomorrow zulu');
SELECT COUNT(*) AS x FROM x WHERE x = CAST('today' AS TIMESTAMPTZ);
SELECT COUNT(*) AS x FROM x WHERE x = CAST('tomorrow' AS TIMESTAMPTZ);
SELECT COUNT(*) AS x FROM x WHERE x = CAST('yesterday' AS TIMESTAMPTZ);
SELECT COUNT(*) AS x FROM x WHERE x = CAST('tomorrow EST' AS TIMESTAMPTZ);
SELECT COUNT(*) AS x FROM x WHERE x = CAST('tomorrow zulu' AS TIMESTAMPTZ);
COMMIT;
DELETE FROM x;
/* Verify that 'now' *does* change over a reasonable interval such as 100 msec, */ /* and that it doesn't change over the same interval within a transaction block */ INSERT INTO x VALUES ('now');
SELECT PG_SLEEP(0.1);
BEGIN;
INSERT INTO x VALUES ('now');
SELECT PG_SLEEP(0.1);
INSERT INTO x VALUES ('now');
SELECT PG_SLEEP(0.1);
SELECT COUNT(*) AS x FROM x WHERE x = CAST('now' AS TIMESTAMPTZ(2));
SELECT COUNT(x) AS x, COUNT(DISTINCT x) AS x FROM x;
COMMIT;
TRUNCATE TABLE x;
/* Special values */ INSERT INTO x VALUES ('-infinity');
INSERT INTO x VALUES ('infinity');
INSERT INTO x VALUES ('epoch');
SELECT CAST('infinity' AS TIMESTAMPTZ) = CAST('+infinity' AS TIMESTAMPTZ) AS x;
/* Postgres v6.0 standard output format */ INSERT INTO x VALUES ('Mon Feb 10 17:32:01 1997 PST');
/* Variations on Postgres v6.1 standard output format */ INSERT INTO x VALUES ('Mon Feb 10 17:32:01.000001 1997 PST');
INSERT INTO x VALUES ('Mon Feb 10 17:32:01.999999 1997 PST');
INSERT INTO x VALUES ('Mon Feb 10 17:32:01.4 1997 PST');
INSERT INTO x VALUES ('Mon Feb 10 17:32:01.5 1997 PST');
INSERT INTO x VALUES ('Mon Feb 10 17:32:01.6 1997 PST');
/* ISO 8601 format */ INSERT INTO x VALUES ('1997-01-02');
INSERT INTO x VALUES ('1997-01-02 03:04:05');
INSERT INTO x VALUES ('1997-02-10 17:32:01-08');
INSERT INTO x VALUES ('1997-02-10 17:32:01-0800');
INSERT INTO x VALUES ('1997-02-10 17:32:01 -08:00');
INSERT INTO x VALUES ('19970210 173201 -0800');
INSERT INTO x VALUES ('1997-06-10 17:32:01 -07:00');
INSERT INTO x VALUES ('2001-09-22T18:19:20');
/* POSIX format (note that the timezone abbrev is just decoration here) */ INSERT INTO x VALUES ('2000-03-15 08:14:01 GMT+8');
INSERT INTO x VALUES ('2000-03-15 13:14:02 GMT-1');
INSERT INTO x VALUES ('2000-03-15 12:14:03 GMT-2');
INSERT INTO x VALUES ('2000-03-15 03:14:04 PST+8');
INSERT INTO x VALUES ('2000-03-15 02:14:05 MST+7:00');
/* Variations for acceptable input formats */ INSERT INTO x VALUES ('Feb 10 17:32:01 1997 -0800');
INSERT INTO x VALUES ('Feb 10 17:32:01 1997');
INSERT INTO x VALUES ('Feb 10 5:32PM 1997');
INSERT INTO x VALUES ('1997/02/10 17:32:01-0800');
INSERT INTO x VALUES ('1997-02-10 17:32:01 PST');
INSERT INTO x VALUES ('Feb-10-1997 17:32:01 PST');
INSERT INTO x VALUES ('02-10-1997 17:32:01 PST');
INSERT INTO x VALUES ('19970210 173201 PST');
SET x = ymd;
INSERT INTO x VALUES ('97FEB10 5:32:01PM UTC');
INSERT INTO x VALUES ('97/02/10 17:32:01 UTC');
RESET datestyle;
INSERT INTO x VALUES ('1997.041 17:32:01 UTC');
/* timestamps at different timezones */ INSERT INTO x VALUES ('19970210 173201 America/New_York');
SELECT '19970210 173201' AT TIME ZONE 'America/New_York';
INSERT INTO x VALUES ('19970710 173201 America/New_York');
SELECT '19970710 173201' AT TIME ZONE 'America/New_York';
INSERT INTO x VALUES ('19970710 173201 America/Does_not_exist');
SELECT '19970710 173201' AT TIME ZONE 'America/Does_not_exist';
/* Daylight saving time for timestamps beyond 32-bit time_t range. */ SELECT CAST('20500710 173201 Europe/Helsinki' AS TIMESTAMPTZ);
/* DST */ SELECT CAST('20500110 173201 Europe/Helsinki' AS TIMESTAMPTZ);
/* non-DST */ SELECT CAST('205000-07-10 17:32:01 Europe/Helsinki' AS TIMESTAMPTZ);
/* DST */ SELECT CAST('205000-01-10 17:32:01 Europe/Helsinki' AS TIMESTAMPTZ);
/* non-DST */ /* Recognize "LMT" as whatever it means in the current zone */ SELECT CAST('Jan 01 00:00:00 1000 LMT' AS TIMESTAMPTZ);
SELECT CAST('Jan 01 00:00:00 2024 LMT' AS TIMESTAMPTZ);
SET x = 'Europe/London';
SELECT CAST('Jan 01 00:00:00 1000 LMT' AS TIMESTAMPTZ);
SELECT CAST('Jan 01 00:00:00 2024 LMT' AS TIMESTAMPTZ);
SET x = 'UTC' /* which might be nothing */;
SELECT CAST('Jan 01 00:00:00 2024 LMT' AS TIMESTAMPTZ);
/* fail */ /* Another example of an abbrev that varies across zones */ SELECT CAST('1912-01-01 00:00 MMT' AS TIMESTAMPTZ);
SET x = 'America/Montevideo' /* from timezone_abbreviations */;
SELECT CAST('1912-01-01 00:00' AS TIMESTAMPTZ);
SELECT CAST('1912-01-01 00:00 MMT' AS TIMESTAMPTZ);
SELECT CAST('1912-01-01 00:00 MMT' AS TIMESTAMPTZ) AT TIME ZONE 'UTC';
RESET timezone;
/* Test non-error-throwing API */ SELECT PG_INPUT_IS_VALID('now', 'timestamptz');
SELECT PG_INPUT_IS_VALID('garbage', 'timestamptz');
SELECT PG_INPUT_IS_VALID('2001-01-01 00:00 Nehwon/Lankhmar', 'timestamptz');
SELECT * FROM x;
SELECT * FROM x;
/* Check date conversion and date arithmetic */ INSERT INTO x VALUES ('1997-06-10 18:32:01 PDT');
INSERT INTO x VALUES ('Feb 10 17:32:01 1997');
INSERT INTO x VALUES ('Feb 11 17:32:01 1997');
INSERT INTO x VALUES ('Feb 12 17:32:01 1997');
INSERT INTO x VALUES ('Feb 13 17:32:01 1997');
INSERT INTO x VALUES ('Feb 14 17:32:01 1997');
INSERT INTO x VALUES ('Feb 15 17:32:01 1997');
INSERT INTO x VALUES ('Feb 16 17:32:01 1997');
INSERT INTO x VALUES ('Feb 16 17:32:01 0097 BC');
INSERT INTO x VALUES ('Feb 16 17:32:01 0097');
INSERT INTO x VALUES ('Feb 16 17:32:01 0597');
INSERT INTO x VALUES ('Feb 16 17:32:01 1097');
INSERT INTO x VALUES ('Feb 16 17:32:01 1697');
INSERT INTO x VALUES ('Feb 16 17:32:01 1797');
INSERT INTO x VALUES ('Feb 16 17:32:01 1897');
INSERT INTO x VALUES ('Feb 16 17:32:01 1997');
INSERT INTO x VALUES ('Feb 16 17:32:01 2097');
INSERT INTO x VALUES ('Feb 28 17:32:01 1996');
INSERT INTO x VALUES ('Feb 29 17:32:01 1996');
INSERT INTO x VALUES ('Mar 01 17:32:01 1996');
INSERT INTO x VALUES ('Dec 30 17:32:01 1996');
INSERT INTO x VALUES ('Dec 31 17:32:01 1996');
INSERT INTO x VALUES ('Jan 01 17:32:01 1997');
INSERT INTO x VALUES ('Feb 28 17:32:01 1997');
INSERT INTO x VALUES ('Feb 29 17:32:01 1997');
INSERT INTO x VALUES ('Mar 01 17:32:01 1997');
INSERT INTO x VALUES ('Dec 30 17:32:01 1997');
INSERT INTO x VALUES ('Dec 31 17:32:01 1997');
INSERT INTO x VALUES ('Dec 31 17:32:01 1999');
INSERT INTO x VALUES ('Jan 01 17:32:01 2000');
INSERT INTO x VALUES ('Dec 31 17:32:01 2000');
INSERT INTO x VALUES ('Jan 01 17:32:01 2001');
/* Currently unsupported syntax and ranges */ INSERT INTO x VALUES ('Feb 16 17:32:01 -0097');
INSERT INTO x VALUES ('Feb 16 17:32:01 5097 BC');
/* Alternative field order that we've historically supported (sort of) */ /* with regular and POSIXy timezone specs */ SELECT CAST('Wed Jul 11 10:51:14 America/New_York 2001' AS TIMESTAMPTZ);
SELECT CAST('Wed Jul 11 10:51:14 GMT-4 2001' AS TIMESTAMPTZ);
SELECT CAST('Wed Jul 11 10:51:14 GMT+4 2001' AS TIMESTAMPTZ);
SELECT CAST('Wed Jul 11 10:51:14 PST-03:00 2001' AS TIMESTAMPTZ);
SELECT CAST('Wed Jul 11 10:51:14 PST+03:00 2001' AS TIMESTAMPTZ);
SELECT x FROM x;
/* Check behavior at the boundaries of the timestamp range */ SELECT CAST('4714-11-24 00:00:00+00 BC' AS TIMESTAMPTZ);
SELECT CAST('4714-11-23 16:00:00-08 BC' AS TIMESTAMPTZ);
SELECT CAST('Sun Nov 23 16:00:00 4714 PST BC' AS TIMESTAMPTZ);
SELECT CAST('4714-11-23 23:59:59+00 BC' AS TIMESTAMPTZ);
/* out of range */ SELECT CAST('294276-12-31 23:59:59+00' AS TIMESTAMPTZ);
SELECT CAST('294276-12-31 15:59:59-08' AS TIMESTAMPTZ);
SELECT CAST('294277-01-01 00:00:00+00' AS TIMESTAMPTZ);
/* out of range */ SELECT CAST('294277-12-31 16:00:00-08' AS TIMESTAMPTZ);
/* out of range */ /* Demonstrate functions and operators */ SELECT x FROM x WHERE x > CAST('1997-01-02' AS TIMESTAMPTZ);
SELECT x FROM x WHERE x < CAST('1997-01-02' AS TIMESTAMPTZ);
SELECT x FROM x WHERE x = CAST('1997-01-02' AS TIMESTAMPTZ);
SELECT x FROM x WHERE x <> CAST('1997-01-02' AS TIMESTAMPTZ);
SELECT x FROM x WHERE x <= CAST('1997-01-02' AS TIMESTAMPTZ);
SELECT x FROM x WHERE x >= CAST('1997-01-02' AS TIMESTAMPTZ);
SELECT x - CAST('1997-01-02' AS TIMESTAMPTZ) AS x FROM x WHERE x BETWEEN '1902-01-01' AND '2038-01-01';
SELECT TIMESTAMP_TRUNC(CAST('2004-02-29 15:44:17.71393' AS TIMESTAMPTZ), WEEK) AS x;
SELECT TIMESTAMP_TRUNC(CAST('infinity' AS TIMESTAMPTZ), AGO) AS x;
SELECT TIMESTAMP_TRUNC(CAST('2001-02-16 20:38:40+00' AS TIMESTAMPTZ), DAY) AS x;
/* zone name */ SELECT TIMESTAMP_TRUNC(CAST('2001-02-16 20:38:40+00' AS TIMESTAMPTZ), DAY) AS x;
/* fixed-offset abbreviation */ SELECT TIMESTAMP_TRUNC(CAST('2001-02-16 20:38:40+00' AS TIMESTAMPTZ), DAY) AS x;
/* variable-offset abbreviation */ SELECT TIMESTAMP_TRUNC(CAST('infinity' AS TIMESTAMPTZ), AGO) AS x;
/* verify date_bin behaves the same as date_trunc for relevant intervals */ SELECT x, x, TIMESTAMP_TRUNC(x, STR) = DATE_BIN(CAST(x AS INTERVAL), x, CAST('2001-01-01+11' AS TIMESTAMPTZ)) AS x FROM (VALUES ('day', '1 d'), ('hour', '1 h'), ('minute', '1 m'), ('second', '1 s'), ('millisecond', '1 ms'), ('microsecond', '1 us')) AS x, (VALUES (CAST('2020-02-29 15:44:17.71393+00' AS TIMESTAMPTZ))) AS x;
/* bin timestamps into arbitrary intervals */ SELECT x, x, x, DATE_BIN(CAST(x AS INTERVAL), x, ORIGIN) FROM (VALUES ('15 days'), ('2 hours'), ('1 hour 30 minutes'), ('15 minutes'), ('10 seconds'), ('100 milliseconds'), ('250 microseconds')) AS x, (VALUES (CAST('2020-02-11 15:44:17.71393' AS TIMESTAMPTZ))) AS x, (VALUES (CAST('2001-01-01' AS TIMESTAMPTZ))) AS x;
/* shift bins using the origin parameter: */ SELECT DATE_BIN(CAST('5 min' AS INTERVAL), CAST('2020-02-01 01:01:01+00' AS TIMESTAMPTZ), CAST('2020-02-01 00:02:30+00' AS TIMESTAMPTZ));
/* test roundoff edge case when source < origin */ SELECT DATE_BIN(CAST('30 minutes' AS INTERVAL), CAST('2024-02-01 15:00:00' AS TIMESTAMPTZ), CAST('2024-02-01 17:00:00' AS TIMESTAMPTZ));
/* disallow intervals with months or years */ SELECT DATE_BIN(CAST('5 months' AS INTERVAL), CAST('2020-02-01 01:01:01+00' AS TIMESTAMPTZ), CAST('2001-01-01+00' AS TIMESTAMPTZ));
SELECT DATE_BIN(CAST('5 years' AS INTERVAL), CAST('2020-02-01 01:01:01+00' AS TIMESTAMPTZ), CAST('2001-01-01+00' AS TIMESTAMPTZ));
/* disallow zero intervals */ SELECT DATE_BIN(CAST('0 days' AS INTERVAL), CAST('1970-01-01 01:00:00+00' AS TIMESTAMPTZ), CAST('1970-01-01 00:00:00+00' AS TIMESTAMPTZ));
/* disallow negative intervals */ SELECT DATE_BIN(CAST('-2 days' AS INTERVAL), CAST('1970-01-01 01:00:00+00' AS TIMESTAMPTZ), CAST('1970-01-01 00:00:00+00' AS TIMESTAMPTZ));
/* test overflow cases */ SELECT DATE_BIN(CAST('15 minutes' AS INTERVAL), CAST('294276-12-30' AS TIMESTAMPTZ), CAST('4000-12-20 BC' AS TIMESTAMPTZ));
SELECT DATE_BIN(CAST('200000000 days' AS INTERVAL), CAST('2024-02-01' AS TIMESTAMPTZ), CAST('2024-01-01' AS TIMESTAMPTZ));
SELECT DATE_BIN(CAST('365000 days' AS INTERVAL), CAST('4400-01-01 BC' AS TIMESTAMPTZ), CAST('4000-01-01 BC' AS TIMESTAMPTZ));
/* Test casting within a BETWEEN qualifier */ SELECT x - CAST('1997-01-02' AS TIMESTAMPTZ) AS x FROM x WHERE x BETWEEN CAST('1902-01-01' AS TIMESTAMPTZ) AND CAST('2038-01-01' AS TIMESTAMPTZ);
/* DATE_PART (timestamptz_part) */ SELECT x AS x, EXTRACT(year FROM x) AS x, EXTRACT(month FROM x) AS x, EXTRACT(day FROM x) AS x, EXTRACT(hour FROM x) AS x, EXTRACT(minute FROM x) AS x, EXTRACT(second FROM x) AS x FROM x;
SELECT x AS x, EXTRACT(quarter FROM x) AS x, EXTRACT(msec FROM x) AS x, EXTRACT(usec FROM x) AS x FROM x;
SELECT x AS x, EXTRACT(isoyear FROM x) AS x, EXTRACT(week FROM x) AS x, EXTRACT(isodow FROM x) AS x, EXTRACT(dow FROM x) AS x, EXTRACT(doy FROM x) AS x FROM x;
SELECT x AS x, EXTRACT(decade FROM x) AS x, EXTRACT(century FROM x) AS x, EXTRACT(millennium FROM x) AS x, ROUND(EXTRACT(julian FROM x)) AS x, EXTRACT(epoch FROM x) AS x FROM x;
SELECT x AS x, EXTRACT(timezone FROM x) AS x, EXTRACT(timezone_hour FROM x) AS x, EXTRACT(timezone_minute FROM x) AS x FROM x;
/* extract implementation is mostly the same as date_part, so only */ /* test a few cases for additional coverage. */ SELECT x AS "x", EXTRACT(MICROSECONDS FROM x) AS x, EXTRACT(MILLISECONDS FROM x) AS x, EXTRACT(SECONDS FROM x) AS x, ROUND(EXTRACT(JULIAN FROM x)) AS x, EXTRACT(EPOCH FROM x) AS x FROM x;
/* value near upper bound uses special case in code */ SELECT EXTRACT(epoch FROM CAST('294270-01-01 00:00:00+00' AS TIMESTAMPTZ));
SELECT EXTRACT(EPOCH FROM CAST('294270-01-01 00:00:00+00' AS TIMESTAMPTZ));
/* another internal overflow test case */ SELECT EXTRACT(EPOCH FROM CAST('5000-01-01 00:00:00+00' AS TIMESTAMPTZ));
/* test edge-case overflow in timestamp subtraction */ SELECT CAST('294276-12-31 23:59:59 UTC' AS TIMESTAMPTZ) - CAST('1999-12-23 19:59:04.224193 UTC' AS TIMESTAMPTZ) AS x;
SELECT CAST('294276-12-31 23:59:59 UTC' AS TIMESTAMPTZ) - CAST('1999-12-23 19:59:04.224192 UTC' AS TIMESTAMPTZ) AS x;
/* TO_CHAR() */ SELECT TIME_TO_STR(x, '%uAY %uay day %uY %uy dy MONTH Month month RM MON Mon mon') FROM x;
SELECT TIME_TO_STR(x, 'FM%uAY FM%uay FMday F%mONTH F%month FMmonth FMRM') FROM x;
SELECT TIME_TO_STR(x, 'Y,%yY %Y %yY %y Y CC Q %m %U %j %d %u J') FROM x;
SELECT TIME_TO_STR(x, 'FMY,%yY FM%Y FM%yY FM%y FMY FMCC FMQ %-m FM%U %-j %-d FM%u FMJ') FROM x;
SELECT TIME_TO_STR(x, 'HH %I %H %M %S %S%S') FROM x;
SELECT TIME_TO_STR(x, "HH:MI:SS is" HH:MI:SS "\\"text between quote marks\\"") FROM x;
SELECT TIME_TO_STR(x, '%H--text--%M--text--%S') FROM x;
SELECT TIME_TO_STR(x, '%YTH %Yth Jth') FROM x;
SELECT TIME_TO_STR(x, '%Y A.%u. %Y a.d. %Y bc HH:%M:%S P.M. HH:%M:%S p.m. HH:%M:%S pm') FROM x;
SELECT TIME_TO_STR(x, 'I%yY I%y IY I IW I%j I%u') FROM x;
SELECT TIME_TO_STR(x, 'F%M%yY F%M%y F%MY F%M F%MW F%M%j F%M%u') FROM x;
SELECT TIME_TO_STR(x, 'FF1 FF2 FF3 FF4 FF5 FF6  ff1 ff2 ff3 ff4 ff5 ff6  MS %f') FROM (VALUES (CAST('2018-11-02 12:34:56' AS TIMESTAMPTZ)), ('2018-11-02 12:34:56.78'), ('2018-11-02 12:34:56.78901'), ('2018-11-02 12:34:56.78901234')) AS x;
SET x = '00:00' /* Check OF, TZH, TZM with various zone offsets, particularly fractional hours */;
SELECT TIME_TO_STR(CURRENT_TIMESTAMP(), '%z') AS "x", TIME_TO_STR(CURRENT_TIMESTAMP(), '%ZH:%ZM') AS "x";
SET x = '+02:00';
SELECT TIME_TO_STR(CURRENT_TIMESTAMP(), '%z') AS "x", TIME_TO_STR(CURRENT_TIMESTAMP(), '%ZH:%ZM') AS "x";
SET x = '-13:00';
SELECT TIME_TO_STR(CURRENT_TIMESTAMP(), '%z') AS "x", TIME_TO_STR(CURRENT_TIMESTAMP(), '%ZH:%ZM') AS "x";
SET x = '-00:30';
SELECT TIME_TO_STR(CURRENT_TIMESTAMP(), '%z') AS "x", TIME_TO_STR(CURRENT_TIMESTAMP(), '%ZH:%ZM') AS "x";
SET x = '00:30';
SELECT TIME_TO_STR(CURRENT_TIMESTAMP(), '%z') AS "x", TIME_TO_STR(CURRENT_TIMESTAMP(), '%ZH:%ZM') AS "x";
SET x = '-04:30';
SELECT TIME_TO_STR(CURRENT_TIMESTAMP(), '%z') AS "x", TIME_TO_STR(CURRENT_TIMESTAMP(), '%ZH:%ZM') AS "x";
SET x = '04:30';
SELECT TIME_TO_STR(CURRENT_TIMESTAMP(), '%z') AS "x", TIME_TO_STR(CURRENT_TIMESTAMP(), '%ZH:%ZM') AS "x";
SET x = '-04:15';
SELECT TIME_TO_STR(CURRENT_TIMESTAMP(), '%z') AS "x", TIME_TO_STR(CURRENT_TIMESTAMP(), '%ZH:%ZM') AS "x";
SET x = '04:15';
SELECT TIME_TO_STR(CURRENT_TIMESTAMP(), '%z') AS "x", TIME_TO_STR(CURRENT_TIMESTAMP(), '%ZH:%ZM') AS "x";
RESET timezone;
SET x = '00:00' /* Check of, tzh, tzm with various zone offsets. */;
SELECT TIME_TO_STR(CURRENT_TIMESTAMP(), 'of') AS "x", TIME_TO_STR(CURRENT_TIMESTAMP(), 'tzh:tzm') AS "x";
SET x = '+02:00';
SELECT TIME_TO_STR(CURRENT_TIMESTAMP(), 'of') AS "x", TIME_TO_STR(CURRENT_TIMESTAMP(), 'tzh:tzm') AS "x";
SET x = '-13:00';
SELECT TIME_TO_STR(CURRENT_TIMESTAMP(), 'of') AS "x", TIME_TO_STR(CURRENT_TIMESTAMP(), 'tzh:tzm') AS "x";
SET x = '-00:30';
SELECT TIME_TO_STR(CURRENT_TIMESTAMP(), 'of') AS "x", TIME_TO_STR(CURRENT_TIMESTAMP(), 'tzh:tzm') AS "x";
SET x = '00:30';
SELECT TIME_TO_STR(CURRENT_TIMESTAMP(), 'of') AS "x", TIME_TO_STR(CURRENT_TIMESTAMP(), 'tzh:tzm') AS "x";
SET x = '-04:30';
SELECT TIME_TO_STR(CURRENT_TIMESTAMP(), 'of') AS "x", TIME_TO_STR(CURRENT_TIMESTAMP(), 'tzh:tzm') AS "x";
SET x = '04:30';
SELECT TIME_TO_STR(CURRENT_TIMESTAMP(), 'of') AS "x", TIME_TO_STR(CURRENT_TIMESTAMP(), 'tzh:tzm') AS "x";
SET x = '-04:15';
SELECT TIME_TO_STR(CURRENT_TIMESTAMP(), 'of') AS "x", TIME_TO_STR(CURRENT_TIMESTAMP(), 'tzh:tzm') AS "x";
SET x = '04:15';
SELECT TIME_TO_STR(CURRENT_TIMESTAMP(), 'of') AS "x", TIME_TO_STR(CURRENT_TIMESTAMP(), 'tzh:tzm') AS "x";
RESET timezone;
CREATE TABLE x (x INT, x TIMESTAMPTZ);
/* Test year field value with len > 4 */ INSERT INTO x VALUES (1, 'Sat Mar 12 23:58:48 1000 IST');
INSERT INTO x VALUES (2, 'Sat Mar 12 23:58:48 10000 IST');
INSERT INTO x VALUES (3, 'Sat Mar 12 23:58:48 100000 IST');
INSERT INTO x VALUES (3, '10000 Mar 12 23:58:48 IST');
INSERT INTO x VALUES (4, '100000312 23:58:48 IST');
INSERT INTO x VALUES (4, '1000000312 23:58:48 IST');
/* Verify data */ SELECT * FROM x ORDER BY x NULLS LAST;
/* Cleanup */ DROP TABLE x;
SET x = 'America/New_York' /* test timestamptz constructors */;
/* numeric timezone */ SELECT MAKE_TIMESTAMPTZ(1973, 07, 15, 08, 15, 55.33);
SELECT MAKE_TIMESTAMPTZ(1973, 07, 15, 08, 15, 55.33, '+2');
SELECT MAKE_TIMESTAMPTZ(1973, 07, 15, 08, 15, 55.33, '-2');
WITH x AS (SELECT * FROM (VALUES ('+1'), ('+1:'), ('+1:0'), ('+100'), ('+1:00'), ('+01:00'), ('+10'), ('+1000'), ('+10:'), ('+10:0'), ('+10:00'), ('+10:00:'), ('+10:00:1'), ('+10:00:01'), ('+10:00:10')) AS x) SELECT MAKE_TIMESTAMPTZ(2010, 2, 27, 3, 45, 00, x), x FROM x;
/* these should fail */ SELECT MAKE_TIMESTAMPTZ(1973, 07, 15, 08, 15, 55.33, '2');
SELECT MAKE_TIMESTAMPTZ(2014, 12, 10, 10, 10, 10, '+16');
SELECT MAKE_TIMESTAMPTZ(2014, 12, 10, 10, 10, 10, '-16');
/* should be true */ SELECT MAKE_TIMESTAMPTZ(1973, 07, 15, 08, 15, 55.33, '+2') = CAST('1973-07-15 08:15:55.33+02' AS TIMESTAMPTZ);
/* full timezone names */ SELECT MAKE_TIMESTAMPTZ(2014, 12, 10, 0, 0, 0, 'Europe/Prague') = CAST('2014-12-10 00:00:00 Europe/Prague' AS TIMESTAMPTZ);
SELECT MAKE_TIMESTAMPTZ(2014, 12, 10, 0, 0, 0, 'Europe/Prague') AT TIME ZONE 'UTC';
SELECT MAKE_TIMESTAMPTZ(1881, 12, 10, 0, 0, 0, 'Asia/Singapore') AT TIME ZONE 'UTC';
SELECT MAKE_TIMESTAMPTZ(1881, 12, 10, 0, 0, 0, 'Pacific/Honolulu') AT TIME ZONE 'UTC';
SELECT MAKE_TIMESTAMPTZ(1881, 12, 10, 0, 0, 0, 'Europe/Paris') AT TIME ZONE 'UTC';
SELECT MAKE_TIMESTAMPTZ(1910, 12, 24, 0, 0, 0, 'Nehwon/Lankhmar');
/* abbreviations */ SELECT MAKE_TIMESTAMPTZ(2008, 12, 10, 10, 10, 10, 'EST');
SELECT MAKE_TIMESTAMPTZ(2008, 12, 10, 10, 10, 10, 'EDT');
SELECT MAKE_TIMESTAMPTZ(2014, 12, 10, 10, 10, 10, 'FOO8BAR');
/* POSIX */ SELECT MAKE_TIMESTAMPTZ(2014, 12, 10, 10, 10, 10, 'PST8PDT,M3.2.0,M11.1.0');
RESET TimeZone;
/* generate_series for timestamptz */ SELECT * FROM x;
/* the LIMIT should allow this to terminate in a reasonable amount of time */ /* (but that unfortunately doesn't work yet for SELECT * FROM ...) */ SELECT UNNEST(GENERATE_SERIES(CAST('2022-01-01 00:00' AS TIMESTAMPTZ), CAST('infinity' AS TIMESTAMPTZ), CAST('1 month' AS INTERVAL))) LIMIT 10;
/* errors */ SELECT * FROM x;
SELECT UNNEST(GENERATE_SERIES(CAST('1995-08-06 12:12:12' AS TIMESTAMPTZ), CAST('1996-08-06 12:12:12' AS TIMESTAMPTZ), INTERVAL x));
SELECT UNNEST(GENERATE_SERIES(CAST('1995-08-06 12:12:12' AS TIMESTAMPTZ), CAST('1996-08-06 12:12:12' AS TIMESTAMPTZ), INTERVAL -x));
SET x = 'UTC' /* Interval crossing time shift for Europe/Warsaw timezone (with DST) */;
SELECT DATE_ADD(CAST('2022-10-30 00:00:00+01' AS TIMESTAMPTZ), CAST('1 day' AS INTERVAL), 'DAY');
SELECT DATE_ADD(CAST('2021-10-31 00:00:00+02' AS TIMESTAMPTZ), CAST('1 day' AS INTERVAL), 'EUROPE/WARSAW');
SELECT DATE_SUBTRACT(CAST('2022-10-30 00:00:00+01' AS TIMESTAMPTZ), CAST('1 day' AS INTERVAL));
SELECT DATE_SUBTRACT(CAST('2021-10-31 00:00:00+02' AS TIMESTAMPTZ), CAST('1 day' AS INTERVAL), 'Europe/Warsaw');
SELECT * FROM x;
RESET TimeZone;
SET x = 'UTC' /* Test behavior with a dynamic (time-varying) timezone abbreviation. */ /* These tests rely on the knowledge that MSK (Europe/Moscow standard time) */ /* moved forwards in Mar 2011 and backwards again in Oct 2014. */;
SELECT CAST('2011-03-27 00:00:00 Europe/Moscow' AS TIMESTAMPTZ);
SELECT CAST('2011-03-27 01:00:00 Europe/Moscow' AS TIMESTAMPTZ);
SELECT CAST('2011-03-27 01:59:59 Europe/Moscow' AS TIMESTAMPTZ);
SELECT CAST('2011-03-27 02:00:00 Europe/Moscow' AS TIMESTAMPTZ);
SELECT CAST('2011-03-27 02:00:01 Europe/Moscow' AS TIMESTAMPTZ);
SELECT CAST('2011-03-27 02:59:59 Europe/Moscow' AS TIMESTAMPTZ);
SELECT CAST('2011-03-27 03:00:00 Europe/Moscow' AS TIMESTAMPTZ);
SELECT CAST('2011-03-27 03:00:01 Europe/Moscow' AS TIMESTAMPTZ);
SELECT CAST('2011-03-27 04:00:00 Europe/Moscow' AS TIMESTAMPTZ);
SELECT CAST('2011-03-27 00:00:00 MSK' AS TIMESTAMPTZ);
SELECT CAST('2011-03-27 01:00:00 MSK' AS TIMESTAMPTZ);
SELECT CAST('2011-03-27 01:59:59 MSK' AS TIMESTAMPTZ);
SELECT CAST('2011-03-27 02:00:00 MSK' AS TIMESTAMPTZ);
SELECT CAST('2011-03-27 02:00:01 MSK' AS TIMESTAMPTZ);
SELECT CAST('2011-03-27 02:59:59 MSK' AS TIMESTAMPTZ);
SELECT CAST('2011-03-27 03:00:00 MSK' AS TIMESTAMPTZ);
SELECT CAST('2011-03-27 03:00:01 MSK' AS TIMESTAMPTZ);
SELECT CAST('2011-03-27 04:00:00 MSK' AS TIMESTAMPTZ);
SELECT CAST('2014-10-26 00:00:00 Europe/Moscow' AS TIMESTAMPTZ);
SELECT CAST('2014-10-26 00:59:59 Europe/Moscow' AS TIMESTAMPTZ);
SELECT CAST('2014-10-26 01:00:00 Europe/Moscow' AS TIMESTAMPTZ);
SELECT CAST('2014-10-26 01:00:01 Europe/Moscow' AS TIMESTAMPTZ);
SELECT CAST('2014-10-26 02:00:00 Europe/Moscow' AS TIMESTAMPTZ);
SELECT CAST('2014-10-26 00:00:00 MSK' AS TIMESTAMPTZ);
SELECT CAST('2014-10-26 00:59:59 MSK' AS TIMESTAMPTZ);
SELECT CAST('2014-10-26 01:00:00 MSK' AS TIMESTAMPTZ);
SELECT CAST('2014-10-26 01:00:01 MSK' AS TIMESTAMPTZ);
SELECT CAST('2014-10-26 02:00:00 MSK' AS TIMESTAMPTZ);
SELECT CAST('2011-03-27 00:00:00' AS TIMESTAMP) AT TIME ZONE 'Europe/Moscow';
SELECT CAST('2011-03-27 01:00:00' AS TIMESTAMP) AT TIME ZONE 'Europe/Moscow';
SELECT CAST('2011-03-27 01:59:59' AS TIMESTAMP) AT TIME ZONE 'Europe/Moscow';
SELECT CAST('2011-03-27 02:00:00' AS TIMESTAMP) AT TIME ZONE 'Europe/Moscow';
SELECT CAST('2011-03-27 02:00:01' AS TIMESTAMP) AT TIME ZONE 'Europe/Moscow';
SELECT CAST('2011-03-27 02:59:59' AS TIMESTAMP) AT TIME ZONE 'Europe/Moscow';
SELECT CAST('2011-03-27 03:00:00' AS TIMESTAMP) AT TIME ZONE 'Europe/Moscow';
SELECT CAST('2011-03-27 03:00:01' AS TIMESTAMP) AT TIME ZONE 'Europe/Moscow';
SELECT CAST('2011-03-27 04:00:00' AS TIMESTAMP) AT TIME ZONE 'Europe/Moscow';
SELECT CAST('2011-03-27 00:00:00' AS TIMESTAMP) AT TIME ZONE 'MSK';
SELECT CAST('2011-03-27 01:00:00' AS TIMESTAMP) AT TIME ZONE 'MSK';
SELECT CAST('2011-03-27 01:59:59' AS TIMESTAMP) AT TIME ZONE 'MSK';
SELECT CAST('2011-03-27 02:00:00' AS TIMESTAMP) AT TIME ZONE 'MSK';
SELECT CAST('2011-03-27 02:00:01' AS TIMESTAMP) AT TIME ZONE 'MSK';
SELECT CAST('2011-03-27 02:59:59' AS TIMESTAMP) AT TIME ZONE 'MSK';
SELECT CAST('2011-03-27 03:00:00' AS TIMESTAMP) AT TIME ZONE 'MSK';
SELECT CAST('2011-03-27 03:00:01' AS TIMESTAMP) AT TIME ZONE 'MSK';
SELECT CAST('2011-03-27 04:00:00' AS TIMESTAMP) AT TIME ZONE 'MSK';
SELECT CAST('2014-10-26 00:00:00' AS TIMESTAMP) AT TIME ZONE 'Europe/Moscow';
SELECT CAST('2014-10-26 00:59:59' AS TIMESTAMP) AT TIME ZONE 'Europe/Moscow';
SELECT CAST('2014-10-26 01:00:00' AS TIMESTAMP) AT TIME ZONE 'Europe/Moscow';
SELECT CAST('2014-10-26 01:00:01' AS TIMESTAMP) AT TIME ZONE 'Europe/Moscow';
SELECT CAST('2014-10-26 02:00:00' AS TIMESTAMP) AT TIME ZONE 'Europe/Moscow';
SELECT CAST('2014-10-26 00:00:00' AS TIMESTAMP) AT TIME ZONE 'MSK';
SELECT CAST('2014-10-26 00:59:59' AS TIMESTAMP) AT TIME ZONE 'MSK';
SELECT CAST('2014-10-26 01:00:00' AS TIMESTAMP) AT TIME ZONE 'MSK';
SELECT CAST('2014-10-26 01:00:01' AS TIMESTAMP) AT TIME ZONE 'MSK';
SELECT CAST('2014-10-26 02:00:00' AS TIMESTAMP) AT TIME ZONE 'MSK';
SELECT MAKE_TIMESTAMPTZ(2014, 10, 26, 0, 0, 0, 'MSK');
SELECT MAKE_TIMESTAMPTZ(2014, 10, 26, 1, 0, 0, 'MSK');
SELECT UNIX_TO_TIME(0);
/* 1970-01-01 00:00:00+00 */ SELECT UNIX_TO_TIME(946684800);
/* 2000-01-01 00:00:00+00 */ SELECT UNIX_TO_TIME(1262349296.7890123);
/* 2010-01-01 12:34:56.789012+00 */ /* edge cases */ SELECT UNIX_TO_TIME(-210866803200);
/*   4714-11-24 00:00:00+00 BC */ /* upper limit varies between integer and float timestamps, so hard to test */ /* nonfinite values */ SELECT UNIX_TO_TIME(CAST(' Infinity' AS DOUBLE));
SELECT UNIX_TO_TIME(CAST('-Infinity' AS DOUBLE));
SELECT UNIX_TO_TIME(CAST('NaN' AS DOUBLE));
SET x = 'Europe/Moscow';
SELECT CAST('2011-03-26 21:00:00 UTC' AS TIMESTAMPTZ);
SELECT CAST('2011-03-26 22:00:00 UTC' AS TIMESTAMPTZ);
SELECT CAST('2011-03-26 22:59:59 UTC' AS TIMESTAMPTZ);
SELECT CAST('2011-03-26 23:00:00 UTC' AS TIMESTAMPTZ);
SELECT CAST('2011-03-26 23:00:01 UTC' AS TIMESTAMPTZ);
SELECT CAST('2011-03-26 23:59:59 UTC' AS TIMESTAMPTZ);
SELECT CAST('2011-03-27 00:00:00 UTC' AS TIMESTAMPTZ);
SELECT CAST('2014-10-25 21:00:00 UTC' AS TIMESTAMPTZ);
SELECT CAST('2014-10-25 21:59:59 UTC' AS TIMESTAMPTZ);
SELECT CAST('2014-10-25 22:00:00 UTC' AS TIMESTAMPTZ);
SELECT CAST('2014-10-25 22:00:01 UTC' AS TIMESTAMPTZ);
SELECT CAST('2014-10-25 23:00:00 UTC' AS TIMESTAMPTZ);
RESET TimeZone;
SELECT CAST('2011-03-26 21:00:00 UTC' AS TIMESTAMPTZ) AT TIME ZONE 'Europe/Moscow';
SELECT CAST('2011-03-26 22:00:00 UTC' AS TIMESTAMPTZ) AT TIME ZONE 'Europe/Moscow';
SELECT CAST('2011-03-26 22:59:59 UTC' AS TIMESTAMPTZ) AT TIME ZONE 'Europe/Moscow';
SELECT CAST('2011-03-26 23:00:00 UTC' AS TIMESTAMPTZ) AT TIME ZONE 'Europe/Moscow';
SELECT CAST('2011-03-26 23:00:01 UTC' AS TIMESTAMPTZ) AT TIME ZONE 'Europe/Moscow';
SELECT CAST('2011-03-26 23:59:59 UTC' AS TIMESTAMPTZ) AT TIME ZONE 'Europe/Moscow';
SELECT CAST('2011-03-27 00:00:00 UTC' AS TIMESTAMPTZ) AT TIME ZONE 'Europe/Moscow';
SELECT CAST('2014-10-25 21:00:00 UTC' AS TIMESTAMPTZ) AT TIME ZONE 'Europe/Moscow';
SELECT CAST('2014-10-25 21:59:59 UTC' AS TIMESTAMPTZ) AT TIME ZONE 'Europe/Moscow';
SELECT CAST('2014-10-25 22:00:00 UTC' AS TIMESTAMPTZ) AT TIME ZONE 'Europe/Moscow';
SELECT CAST('2014-10-25 22:00:01 UTC' AS TIMESTAMPTZ) AT TIME ZONE 'Europe/Moscow';
SELECT CAST('2014-10-25 23:00:00 UTC' AS TIMESTAMPTZ) AT TIME ZONE 'Europe/Moscow';
SELECT CAST('2011-03-26 21:00:00 UTC' AS TIMESTAMPTZ) AT TIME ZONE 'MSK';
SELECT CAST('2011-03-26 22:00:00 UTC' AS TIMESTAMPTZ) AT TIME ZONE 'MSK';
SELECT CAST('2011-03-26 22:59:59 UTC' AS TIMESTAMPTZ) AT TIME ZONE 'MSK';
SELECT CAST('2011-03-26 23:00:00 UTC' AS TIMESTAMPTZ) AT TIME ZONE 'MSK';
SELECT CAST('2011-03-26 23:00:01 UTC' AS TIMESTAMPTZ) AT TIME ZONE 'MSK';
SELECT CAST('2011-03-26 23:59:59 UTC' AS TIMESTAMPTZ) AT TIME ZONE 'MSK';
SELECT CAST('2011-03-27 00:00:00 UTC' AS TIMESTAMPTZ) AT TIME ZONE 'MSK';
SELECT CAST('2014-10-25 21:00:00 UTC' AS TIMESTAMPTZ) AT TIME ZONE 'MSK';
SELECT CAST('2014-10-25 21:59:59 UTC' AS TIMESTAMPTZ) AT TIME ZONE 'MSK';
SELECT CAST('2014-10-25 22:00:00 UTC' AS TIMESTAMPTZ) AT TIME ZONE 'MSK';
SELECT CAST('2014-10-25 22:00:01 UTC' AS TIMESTAMPTZ) AT TIME ZONE 'MSK';
SELECT CAST('2014-10-25 23:00:00 UTC' AS TIMESTAMPTZ) AT TIME ZONE 'MSK';
/* Test LOCAL time zone */ BEGIN;
SET LOCAL TIME ZONE 'Europe/Paris';
SET LOCAL TIME ZONE 'Australia/Sydney';
SET LOCAL x = 'UTC';
CREATE VIEW timestamp_local_view AS   SELECT CAST('1978-07-07 19:38 America/New_York' AS TIMESTAMP WITH TIME ZONE) AT LOCAL AS ttz_at_local,          timezone(CAST('1978-07-07 19:38 America/New_York' AS TIMESTAMP WITH TIME ZONE)) AS ttz_func,          TIMESTAMP '1978-07-07 19:38' AT LOCAL AS t_at_local,          timezone(TIMESTAMP '1978-07-07 19:38') AS t_func;
SELECT PG_GET_VIEWDEF('timestamp_local_view', TRUE);
COMMIT;
/* Test that AT TIME ZONE isn't misoptimized when using an index (bug #14504) */ CREATE TEMPORARY TABLE x (x TIMESTAMPTZ PRIMARY KEY);
INSERT INTO x VALUES ('2017-01-18 00:00+00');
EXPLAIN (costs off) select * from tmptz where f1 at time zone 'utc' = '2017-01-18 00:00';
SELECT * FROM x WHERE x AT TIME ZONE 'utc' = '2017-01-18 00:00';
/* test arithmetic with infinite timestamps */ SELECT CAST('infinity' AS TIMESTAMPTZ) - CAST('infinity' AS TIMESTAMPTZ);
SELECT CAST('infinity' AS TIMESTAMPTZ) - CAST('-infinity' AS TIMESTAMPTZ);
SELECT CAST('-infinity' AS TIMESTAMPTZ) - CAST('infinity' AS TIMESTAMPTZ);
SELECT CAST('-infinity' AS TIMESTAMPTZ) - CAST('-infinity' AS TIMESTAMPTZ);
SELECT CAST('infinity' AS TIMESTAMPTZ) - CAST('1995-08-06 12:12:12' AS TIMESTAMPTZ);
SELECT CAST('-infinity' AS TIMESTAMPTZ) - CAST('1995-08-06 12:12:12' AS TIMESTAMPTZ);
/* test age() with infinite timestamps */ SELECT AGE(CAST('infinity' AS TIMESTAMPTZ));
SELECT AGE(CAST('-infinity' AS TIMESTAMPTZ));
SELECT AGE(CAST('infinity' AS TIMESTAMPTZ), CAST('infinity' AS TIMESTAMPTZ));
SELECT AGE(CAST('infinity' AS TIMESTAMPTZ), CAST('-infinity' AS TIMESTAMPTZ));
SELECT AGE(CAST('-infinity' AS TIMESTAMPTZ), CAST('infinity' AS TIMESTAMPTZ));
SELECT AGE(CAST('-infinity' AS TIMESTAMPTZ), CAST('-infinity' AS TIMESTAMPTZ));
/* test timestamp near POSTGRES_EPOCH_JDATE */ SELECT CAST('1999-12-31 24:00:00' AS TIMESTAMPTZ);
SELECT MAKE_TIMESTAMPTZ(1999, 12, 31, 24, 0, 0);
/* TIMETZ */ CREATE TABLE x (x TIMETZ(2));
INSERT INTO x VALUES ('00:01 PDT');
INSERT INTO x VALUES ('01:00 PDT');
INSERT INTO x VALUES ('02:03 PDT');
INSERT INTO x VALUES ('07:07 PST');
INSERT INTO x VALUES ('08:08 EDT');
INSERT INTO x VALUES ('11:59 PDT');
INSERT INTO x VALUES ('12:00 PDT');
INSERT INTO x VALUES ('12:01 PDT');
INSERT INTO x VALUES ('23:59 PDT');
INSERT INTO x VALUES ('11:59:59.99 PM PDT');
INSERT INTO x VALUES ('2003-03-07 15:36:39 America/New_York');
INSERT INTO x VALUES ('2003-07-07 15:36:39 America/New_York');
/* this should fail (the timezone offset is not known) */ INSERT INTO x VALUES ('15:36:39 America/New_York');
/* this should fail (timezone not specified without a date) */ INSERT INTO x VALUES ('15:36:39 m2');
/* this should fail (dynamic timezone abbreviation without a date) */ INSERT INTO x VALUES ('15:36:39 MSK m2');
SELECT x AS "x" FROM x;
SELECT x AS "x" FROM x WHERE x < '05:06:07-07';
SELECT x AS "x" FROM x WHERE x > '05:06:07-07';
SELECT x AS "x" FROM x WHERE x < '00:00-07';
SELECT x AS "x" FROM x WHERE x >= '00:00-07';
/* Check edge cases */ SELECT CAST('23:59:59.999999 PDT' AS TIMETZ);
SELECT CAST('23:59:59.9999999 PDT' AS TIMETZ);
/* rounds up */ SELECT CAST('23:59:60 PDT' AS TIMETZ);
/* rounds up */ SELECT CAST('24:00:00 PDT' AS TIMETZ);
/* allowed */ SELECT CAST('24:00:00.01 PDT' AS TIMETZ);
/* not allowed */ SELECT CAST('23:59:60.01 PDT' AS TIMETZ);
/* not allowed */ SELECT CAST('24:01:00 PDT' AS TIMETZ);
/* not allowed */ SELECT CAST('25:00:00 PDT' AS TIMETZ);
/* not allowed */ /* Test non-error-throwing API */ SELECT PG_INPUT_IS_VALID('12:00:00 PDT', 'timetz');
SELECT PG_INPUT_IS_VALID('25:00:00 PDT', 'timetz');
SELECT PG_INPUT_IS_VALID('15:36:39 America/New_York', 'timetz');
SELECT * FROM x;
SELECT * FROM x;
/* TIME simple math */ /* We now make a distinction between time and intervals, */ /* and adding two times together makes no sense at all. */ /* Leave in one query to show that it is rejected, */ /* and do the rest of the testing in horology.sql */ /* where we do mixed-type arithmetic. - thomas 2000-12-02 */ SELECT x + CAST('00:01' AS TIMETZ) AS "x" FROM x;
/* test EXTRACT */ SELECT EXTRACT(MICROSECOND FROM CAST('2020-05-26 13:30:25.575401-04' AS TIMETZ));
SELECT EXTRACT(MILLISECOND FROM CAST('2020-05-26 13:30:25.575401-04' AS TIMETZ));
SELECT EXTRACT(SECOND FROM CAST('2020-05-26 13:30:25.575401-04' AS TIMETZ));
SELECT EXTRACT(MINUTE FROM CAST('2020-05-26 13:30:25.575401-04' AS TIMETZ));
SELECT EXTRACT(HOUR FROM CAST('2020-05-26 13:30:25.575401-04' AS TIMETZ));
SELECT EXTRACT(DAY FROM CAST('2020-05-26 13:30:25.575401-04' AS TIMETZ));
/* error */ SELECT EXTRACT(FORTNIGHT FROM CAST('2020-05-26 13:30:25.575401-04' AS TIMETZ));
/* error */ SELECT EXTRACT(TIMEZONE FROM CAST('2020-05-26 13:30:25.575401-04:30' AS TIMETZ));
SELECT EXTRACT(TIMEZONE_HOUR FROM CAST('2020-05-26 13:30:25.575401-04:30' AS TIMETZ));
SELECT EXTRACT(TIMEZONE_MINUTE FROM CAST('2020-05-26 13:30:25.575401-04:30' AS TIMETZ));
SELECT EXTRACT(EPOCH FROM CAST('2020-05-26 13:30:25.575401-04' AS TIMETZ));
/* date_part implementation is mostly the same as extract, so only */ /* test a few cases for additional coverage. */ SELECT EXTRACT(microsecond FROM CAST('2020-05-26 13:30:25.575401-04' AS TIMETZ));
SELECT EXTRACT(millisecond FROM CAST('2020-05-26 13:30:25.575401-04' AS TIMETZ));
SELECT EXTRACT(second FROM CAST('2020-05-26 13:30:25.575401-04' AS TIMETZ));
SELECT EXTRACT(epoch FROM CAST('2020-05-26 13:30:25.575401-04' AS TIMETZ));
/* Test timetz_zone, timetz_izone, AT LOCAL */ BEGIN;
SET LOCAL x = 'UTC';
CREATE VIEW timetz_local_view AS   SELECT f1 AS dat,        timezone(f1) AS dat_func,        f1 AT LOCAL AS dat_at_local,        f1 AT TIME ZONE current_setting('TimeZone') AS dat_at_tz,        f1 AT TIME ZONE INTERVAL '00:00' AS dat_at_int   FROM TIMETZ_TBL   ORDER BY f1;
SELECT PG_GET_VIEWDEF('timetz_local_view', TRUE);
x AS x;
SELECT x AS x, x AT TIME ZONE 'UTC+10' AS x, x AT TIME ZONE INTERVAL '-10:00' AS x FROM x ORDER BY x NULLS LAST;
ROLLBACK;
/* TRANSACTIONS */ BEGIN;
CREATE TABLE x (x SMALLINT, x FLOAT);
INSERT INTO x VALUES (56, 7.8), (100, 99.097), (0, 0.09561), (42, 324.78);
INSERT INTO x (x, x) VALUES (777, 777.777);
COMMIT;
/* should retrieve one value-- */ SELECT x FROM x WHERE x > 100;
BEGIN;
CREATE TABLE x (x INT);
DELETE FROM x;
/* should be empty */ SELECT * FROM x;
x;
/* should not exist */ SELECT x FROM x WHERE x = 'disappear';
/* should have members again */ SELECT * FROM x;
BEGIN /* Test that transaction characteristics cannot be reset. */;
SELECT COUNT(*) FROM x;
RESET transaction_isolation;
COMMIT /* error */ /* error */;
SELECT COUNT(*) FROM x;
RESET transaction_read_only;
COMMIT /* error */ /* error */;
BEGIN;
SELECT COUNT(*) FROM x;
RESET transaction_deferrable;
COMMIT /* error */ /* error */;
CREATE FUNCTION x() RETURNS INT LANGUAGE SQL SET x = on AS 'SELECT 1';
/* error */ /* Read-only tests */ CREATE TABLE x (x INT);
CREATE TEMPORARY TABLE x (x INT);
BEGIN;
/* ok */ SELECT * FROM x;
SET TRANSACTION READ WRITE /* ok */;
COMMIT /* fail */ /* fail */;
BEGIN;
SET TRANSACTION READ ONLY;
SET TRANSACTION READ WRITE /* ok */;
SET TRANSACTION READ ONLY /* ok */;
/* ok */ SELECT * FROM x;
x AS x /* ok */;
SET TRANSACTION READ ONLY;
/* ok */ SELECT * FROM x;
SET TRANSACTION READ ONLY /* ok */;
SET TRANSACTION READ WRITE /* ok */;
COMMIT /* fail */ /* fail */;
BEGIN;
SET TRANSACTION READ WRITE;
x AS x /* ok */;
SET TRANSACTION READ WRITE;
SET TRANSACTION READ ONLY /* ok */;
/* ok */ SELECT * FROM x;
SET TRANSACTION READ ONLY /* ok */;
SET TRANSACTION READ WRITE /* ok */;
COMMIT /* fail */ /* fail */;
BEGIN;
SET TRANSACTION READ WRITE;
x AS x /* ok */;
SET TRANSACTION READ ONLY;
/* ok */ SELECT * FROM x;
ROLLBACK TO x /* ok */;
SHOW transaction_read_only;
x AS x /* off */;
SET TRANSACTION READ ONLY;
/* ok */ SELECT * FROM x;
SHOW transaction_read_only;
COMMIT /* off */ /* off */;
SET SESSION CHARACTERISTICS AS TRANSACTION READ ONLY;
DROP TABLE x;
/* fail */ INSERT INTO x VALUES (1);
/* fail */ SELECT * FROM x;
/* ok */ DELETE FROM x;
/* ok */ UPDATE x SET x = 0 FROM x WHERE x.x = 1 AND x.x = x.x;
/* ok */ PREPARE test AS UPDATE writetest SET a = 0;
/* ok */ EXECUTE test;
/* fail */ SELECT * FROM x, x;
/* ok */ CREATE TABLE x AS SELECT * FROM x;
DROP TABLE x;
COMMIT /* ok */ /* ok */;
/* Subtransactions, basic tests */ /* create & drop tables */ SET SESSION CHARACTERISTICS AS TRANSACTION READ WRITE;
CREATE TABLE x (x INT);
BEGIN;
CREATE TABLE x (x INT);
x AS x;
DROP TABLE x;
CREATE TABLE x (x INT);
ROLLBACK TO x;
x AS x;
CREATE TABLE x (x INT);
DROP TABLE x;
CREATE TABLE x (x INT);
COMMIT;
/* should exist: trans_barbaz, trans_baz, trans_foo */ SELECT * FROM x;
/* should be empty */ SELECT * FROM x;
/* shouldn't exist */ SELECT * FROM x;
/* should be empty */ SELECT * FROM x;
/* should be empty */ /* inserts */ BEGIN;
INSERT INTO x VALUES (1);
x AS x;
INSERT INTO x VALUES (1);
ROLLBACK TO x;
x AS x;
INSERT INTO x VALUES (1);
x AS x;
x AS x;
x AS x;
INSERT INTO x VALUES (2);
ROLLBACK TO x;
INSERT INTO x VALUES (3);
COMMIT;
SELECT * FROM x;
/* should have 1 and 3 */ SELECT * FROM x;
/* should have 1 */ /* test whole-tree commit */ BEGIN;
x AS x;
SELECT x;
ROLLBACK TO x;
x AS x;
CREATE TABLE x (x INT);
x AS x;
INSERT INTO x VALUES (1);
x AS x;
INSERT INTO x VALUES (2);
x AS x;
INSERT INTO x VALUES (3);
ROLLBACK TO x;
COMMIT;
COMMIT;
/* should not be in a transaction block */ SELECT * FROM x;
/* test whole-tree rollback */ BEGIN;
x AS x;
DELETE FROM x WHERE x = 1;
x AS x;
DELETE FROM x WHERE x = 1;
x AS x;
DELETE FROM x WHERE x = 2;
ROLLBACK;
COMMIT;
/* should not be in a transaction block */ SELECT * FROM x;
/* test whole-tree commit on an aborted subtransaction */ BEGIN;
INSERT INTO x VALUES (4);
x AS x;
INSERT INTO x VALUES (5);
SELECT x;
COMMIT;
SELECT * FROM x;
BEGIN;
INSERT INTO x VALUES (6);
x AS x;
INSERT INTO x VALUES (7);
INSERT INTO x VALUES (8);
COMMIT;
/* rows 6 and 8 should have been created by the same xact */ SELECT x.x = x.x FROM x AS x, x AS x WHERE x.x = 6 AND x.x = 8;
/* rows 6 and 7 should have been created by different xacts */ SELECT x.x = x.x FROM x AS x, x AS x WHERE x.x = 6 AND x.x = 7;
BEGIN;
INSERT INTO x VALUES (9);
x AS x;
INSERT INTO x VALUES (10);
ROLLBACK TO x;
INSERT INTO x VALUES (11);
COMMIT;
SELECT x FROM x WHERE x IN (9, 10, 11);
/* rows 9 and 11 should have been created by different xacts */ SELECT x.x = x.x FROM x AS x, x AS x WHERE x.x = 9 AND x.x = 11;
BEGIN;
INSERT INTO x VALUES (12);
x AS x;
INSERT INTO x VALUES (13);
x AS x;
INSERT INTO x VALUES (14);
ROLLBACK TO x;
INSERT INTO x VALUES (15);
x AS x;
INSERT INTO x VALUES (16);
x AS x;
INSERT INTO x VALUES (17);
COMMIT;
SELECT x FROM x WHERE x BETWEEN 12 AND 17;
BEGIN;
INSERT INTO x VALUES (18);
x AS x;
INSERT INTO x VALUES (19);
x AS x;
INSERT INTO x VALUES (20);
ROLLBACK TO x;
INSERT INTO x VALUES (21);
ROLLBACK TO x;
INSERT INTO x VALUES (22);
COMMIT;
SELECT x FROM x WHERE x BETWEEN 18 AND 22;
DROP TABLE x;
x AS x /* only in a transaction block: */;
ROLLBACK TO x;
/* Only "rollback to" allowed in aborted state */ BEGIN;
x AS x;
SELECT 0 / 0;
x AS x;
ROLLBACK TO x /* ignored till the end of ... */;
SELECT 1;
COMMIT;
SELECT 1;
/* this should work */ /* check non-transactional behavior of cursors */ BEGIN;
DECLARE c CURSOR FOR SELECT unique2 FROM tenk1 ORDER BY unique2;
x AS x;
FETCH 10 FROM c;
ROLLBACK TO x;
FETCH 10 FROM c;
FETCH 10 FROM c;
x AS x;
DECLARE c CURSOR FOR SELECT unique2/0 FROM tenk1 ORDER BY unique2;
x AS x;
FETCH 10 FROM c;
ROLLBACK TO x;
/* c is now dead to the world ... */ FETCH 10 FROM c;
ROLLBACK TO x;
FETCH 10 FROM c;
COMMIT;
/* Check that "stable" functions are really stable.  They should not be */ /* able to see the partial results of the calling query.  (Ideally we would */ /* also check that they don't see commits of concurrent transactions, but */ /* that's a mite hard to do within the limitations of pg_regress.) */ SELECT * FROM x;
CREATE OR REPLACE FUNCTION x() RETURNS SMALLINT LANGUAGE sql STABLE AS 'select max(a) from xacttest';
BEGIN;
UPDATE x SET x = MAX_XACTTEST() + 10 WHERE x > 0;
SELECT * FROM x;
ROLLBACK;
/* But a volatile function can see the partial results of the calling query */ CREATE OR REPLACE FUNCTION x() RETURNS SMALLINT LANGUAGE sql VOLATILE AS 'select max(a) from xacttest';
BEGIN;
UPDATE x SET x = MAX_XACTTEST() + 10 WHERE x > 0;
SELECT * FROM x;
ROLLBACK;
BEGIN;
UPDATE x SET x = MAX_XACTTEST() + 10 WHERE x > 0;
SELECT * FROM x;
ROLLBACK;
BEGIN;
UPDATE x SET x = MAX_XACTTEST() + 10 WHERE x > 0;
SELECT * FROM x;
ROLLBACK;
/* test case for problems with dropping an open relation during abort */ BEGIN;
x AS x;
CREATE TABLE x (x INT UNIQUE);
INSERT INTO x VALUES (1);
INSERT INTO x VALUES (1);
ROLLBACK TO x;
CREATE TABLE x (x INT UNIQUE);
INSERT INTO x VALUES (1);
INSERT INTO x VALUES (1);
ROLLBACK;
DROP TABLE x;
DROP TABLE x;
DROP TABLE x;
CREATE TABLE x (x DOUBLE UNIQUE);
INSERT INTO x VALUES (1);
INSERT INTO x VALUES (INVERSE(0));
DROP TABLE x;
DROP FUNCTION x (INT);
/* verify that cursors created during an aborted subtransaction are */ /* closed, but that we do not rollback the effect of any FETCHs */ /* performed in the aborted subtransaction */ BEGIN;
x AS x;
CREATE TABLE x (x INT);
INSERT INTO x VALUES (5);
INSERT INTO x VALUES (10);
DECLARE foo cursor for select * from trans_abc;
FETCH from foo;
ROLLBACK TO x;
/* should fail */ FETCH from foo;
COMMIT;
BEGIN;
CREATE TABLE x (x INT);
INSERT INTO x VALUES (5);
INSERT INTO x VALUES (10);
INSERT INTO x VALUES (15);
DECLARE foo cursor for select * from trans_abc;
FETCH from foo;
x AS x;
FETCH from foo;
ROLLBACK TO x;
FETCH from foo;
x;
/* case of interest is that we fail while holding an open */ /* relcache reference to new_table */ INSERT INTO x SELECT INVERT(0.0);
BEGIN;
DECLARE ok CURSOR FOR SELECT * FROM int8_tbl;
DECLARE ctt CURSOR FOR SELECT create_temp_tab();
FETCH ok;
x AS x;
FETCH ok;
/* should work */ FETCH ctt;
ROLLBACK TO x /* error occurs here */;
FETCH ok;
/* should work */ FETCH ctt;
COMMIT /* must be rejected */ /* must be rejected */;
DROP FUNCTION x;
/* Tests for AND CHAIN */ CREATE TABLE x (x INT);
SET x = on /* set nondefault value so we have something to override below */;
SHOW transaction_isolation;
SHOW transaction_read_only;
SHOW transaction_deferrable;
INSERT INTO x VALUES (1);
INSERT INTO x VALUES (2);
COMMIT AND CHAIN;
/* TBLOCK_END */ SHOW transaction_isolation;
SHOW transaction_read_only;
SHOW transaction_deferrable;
INSERT INTO x VALUES ('error');
INSERT INTO x VALUES (3);
COMMIT AND CHAIN /* check it's really aborted */;
/* TBLOCK_ABORT_END */ SHOW transaction_isolation;
SHOW transaction_read_only;
SHOW transaction_deferrable;
INSERT INTO x VALUES (4);
COMMIT;
SHOW transaction_isolation;
SHOW transaction_read_only;
SHOW transaction_deferrable;
x AS x;
INSERT INTO x VALUES ('error');
COMMIT AND CHAIN;
/* TBLOCK_ABORT_PENDING */ SHOW transaction_isolation;
SHOW transaction_read_only;
SHOW transaction_deferrable;
INSERT INTO x VALUES (5);
COMMIT;
SHOW transaction_isolation;
SHOW transaction_read_only;
SHOW transaction_deferrable;
x AS x;
COMMIT AND CHAIN;
/* TBLOCK_SUBCOMMIT */ SHOW transaction_isolation;
SHOW transaction_read_only;
SHOW transaction_deferrable;
COMMIT;
SHOW transaction_isolation;
SHOW transaction_read_only;
SHOW transaction_deferrable;
x AS x;
COMMIT AND CHAIN;
/* TBLOCK_SUBCOMMIT */ SHOW transaction_isolation;
SHOW transaction_read_only;
SHOW transaction_deferrable;
COMMIT;
SHOW transaction_isolation;
SHOW transaction_read_only;
SHOW transaction_deferrable;
INSERT INTO x VALUES (6);
ROLLBACK;
/* TBLOCK_ABORT_PENDING */ SHOW transaction_isolation;
SHOW transaction_read_only;
SHOW transaction_deferrable;
INSERT INTO x VALUES ('error');
ROLLBACK;
/* TBLOCK_ABORT_END */ SHOW transaction_isolation;
SHOW transaction_read_only;
SHOW transaction_deferrable;
ROLLBACK;
COMMIT AND CHAIN /* not allowed outside a transaction block */;
ROLLBACK /* error */;
/* error */ SELECT * FROM x ORDER BY 1 NULLS LAST;
RESET default_transaction_read_only;
DROP TABLE x;
/* Test assorted behaviors around the implicit transaction block created */ /* when multiple SQL commands are sent in a single Query message.  These */ /* tests rely on the fact that psql will not break SQL commands apart at a */ /* backslash-quoted semicolon, but will send them as one Query. */ CREATE TEMPORARY TABLE x (x INT);
SELECT 3;
SELECT * FROM x;
SELECT 1 / 0;
SELECT * FROM x;
ROLLBACK;
/* we are not in a transaction at this point */ /* can use regular begin/commit/rollback within a single Query */ BEGIN \;
COMMIT;
ROLLBACK;
/* we are not in a transaction at this point */ BEGIN \;
ROLLBACK;
ROLLBACK;
BEGIN \;
INSERT INTO x VALUES (5);
COMMIT;
BEGIN \;
INSERT INTO x VALUES (6);
ROLLBACK;
SELECT 1 / 0;
SELECT 2;
SELECT * FROM x;
ROLLBACK;
VACUUM;
VACUUM;
x AS x;
x AS x;
SELECT 2;
SELECT 3;
BEGIN \;
COMMIT;
/* Tests for AND CHAIN in implicit transaction blocks */ SET TRANSACTION READ ONLY\;
COMMIT AND CHAIN;
/* error */ SHOW transaction_read_only;
SET TRANSACTION READ ONLY\;
ROLLBACK;
/* error */ SHOW transaction_read_only;
CREATE TABLE x (x INT);
COMMIT AND CHAIN;
ROLLBACK;
COMMIT;
ROLLBACK;
COMMIT AND CHAIN;
/* 15 ok */ SHOW transaction_isolation;
COMMIT /* transaction is active at this point */ /* transaction is active at this point */;
ROLLBACK;
/* 16 ok */ SHOW transaction_isolation;
ROLLBACK /* transaction is active at this point */ /* transaction is active at this point */;
SET x = 'read committed';
COMMIT AND CHAIN;
/* 17 commit, 18 error */ SHOW transaction_isolation;
ROLLBACK;
/* 19 rollback, 20 error */ SHOW transaction_isolation;
/* out of transaction block */ RESET default_transaction_isolation;
SELECT * FROM x ORDER BY 1 NULLS LAST;
DROP TABLE x;
BEGIN /* TRANSACTION SNAPSHOT */ /* Incorrect identifier. */;
ROLLBACK;
BEGIN /* Correct identifier, missing file. */;
ROLLBACK;
/* Test for successful cleanup of an aborted transaction at session exit. */ /* THIS MUST BE THE LAST TEST IN THIS FILE. */ BEGIN;
SELECT 1 / 0;
ROLLBACK TO x;
CREATE FUNCTION check_primary_key () 	RETURNS trigger 	AS :'refintlib' 	LANGUAGE C;
CREATE FUNCTION check_foreign_key () 	RETURNS trigger 	AS :'refintlib' 	LANGUAGE C;
CREATE FUNCTION trigger_return_old ()         RETURNS trigger         AS :'regresslib'         LANGUAGE C;
CREATE FUNCTION set_ttdummy (int4)         RETURNS int4         AS :'regresslib'         LANGUAGE C STRICT;
CREATE TABLE x (x INT NOT NULL, x TEXT NOT NULL);
CREATE TABLE x (x INT, x TEXT, x INT);
CREATE TABLE x (x INT, x TEXT, x INT NOT NULL);
CREATE INDEX x ON x(x NULLS LAST, x NULLS LAST);
CREATE INDEX x ON x(x NULLS LAST, x NULLS LAST);
CREATE INDEX x ON x(x NULLS LAST);
INSERT INTO x VALUES (10, '1');
INSERT INTO x VALUES (20, '2');
INSERT INTO x VALUES (30, '3');
INSERT INTO x VALUES (40, '4');
INSERT INTO x VALUES (50, '5');
INSERT INTO x VALUES (60, '6');
CREATE UNIQUE INDEX x ON x(x NULLS LAST, x NULLS LAST);
/* For fkeys: */ /* 	(fkey1, fkey2)	--> pkeys (pkey1, pkey2) */ /* 	(fkey3)		--> fkeys2 (pkey23) */ create trigger check_fkeys_pkey_exist 	before insert or update on fkeys 	for each row 	execute function 	check_primary_key ('fkey1', 'fkey2', 'pkeys', 'pkey1', 'pkey2');
create trigger check_fkeys_pkey2_exist 	before insert or update on fkeys 	for each row 	execute function check_primary_key ('fkey3', 'fkeys2', 'pkey23');
/* For fkeys2: */ /* 	(fkey21, fkey22)	--> pkeys (pkey1, pkey2) */ create trigger check_fkeys2_pkey_exist 	before insert or update on fkeys2 	for each row 	execute procedure 	check_primary_key ('fkey21', 'fkey22', 'pkeys', 'pkey1', 'pkey2');
/* Test comments */ COMMENT ON TRIGGER check_fkeys2_pkey_bad ON fkeys2 IS 'wrong';
COMMENT ON TRIGGER check_fkeys2_pkey_exist ON fkeys2 IS 'right';
COMMENT ON TRIGGER check_fkeys2_pkey_exist ON fkeys2 IS NULL;
/* For pkeys: */ /* 	ON DELETE/UPDATE (pkey1, pkey2) CASCADE: */ /* 		fkeys (fkey1, fkey2) and fkeys2 (fkey21, fkey22) */ create trigger check_pkeys_fkey_cascade 	before delete or update on pkeys 	for each row 	execute procedure 	check_foreign_key (2, 'cascade', 'pkey1', 'pkey2', 	'fkeys', 'fkey1', 'fkey2', 'fkeys2', 'fkey21', 'fkey22');
/* For fkeys2: */ /* 	ON DELETE/UPDATE (pkey23) RESTRICT: */ /* 		fkeys (fkey3) */ create trigger check_fkeys2_fkey_restrict 	before delete or update on fkeys2 	for each row 	execute procedure check_foreign_key (1, 'restrict', 'pkey23', 'fkeys', 'fkey3');
INSERT INTO x VALUES (10, '1', 1);
INSERT INTO x VALUES (30, '3', 2);
INSERT INTO x VALUES (40, '4', 5);
INSERT INTO x VALUES (50, '5', 3);
/* no key in pkeys */ INSERT INTO x VALUES (70, '5', 3);
INSERT INTO x VALUES (10, '1', 2);
INSERT INTO x VALUES (30, '3', 3);
INSERT INTO x VALUES (40, '4', 2);
INSERT INTO x VALUES (50, '5', 2);
/* no key in pkeys */ INSERT INTO x VALUES (70, '5', 1);
/* no key in fkeys2 */ INSERT INTO x VALUES (60, '6', 4);
DELETE FROM x WHERE x = 30 AND x = '3';
DELETE FROM x WHERE x = 40 AND x = '4';
UPDATE x SET x = 7, x = '70' WHERE x = 50 AND x = '5';
UPDATE x SET x = 7, x = '70' WHERE x = 10 AND x = '1';
SELECT x, x, x, x, x, x, x, x, x, x FROM x.x WHERE x IN ('pkeys', 'fkeys', 'fkeys2') ORDER BY x COLLATE "x" NULLS LAST, 2 NULLS LAST;
DROP TABLE x;
DROP TABLE x;
DROP TABLE x;
/* Check behavior when trigger returns unmodified trigtuple */ CREATE TABLE x (x INT, x TEXT);
create trigger trigger_return_old 	before insert or delete or update on trigtest 	for each row execute procedure trigger_return_old();
INSERT INTO x VALUES (1, 'foo');
SELECT * FROM x;
UPDATE x SET x = x || 'bar';
SELECT * FROM x;
DELETE FROM x;
SELECT * FROM x;
x AS x;
create trigger trigger_alpha 	before insert or update on trigtest 	for each row execute procedure f1_times_10();
INSERT INTO x VALUES (1, 'foo');
SELECT * FROM x;
UPDATE x SET x = x || 'bar';
SELECT * FROM x;
DELETE FROM x;
SELECT * FROM x;
create trigger trigger_zed 	before insert or update on trigtest 	for each row execute procedure f1_times_10();
INSERT INTO x VALUES (1, 'foo');
SELECT * FROM x;
UPDATE x SET x = x || 'bar';
SELECT * FROM x;
DELETE FROM x;
SELECT * FROM x;
drop trigger trigger_alpha on trigtest;
INSERT INTO x VALUES (1, 'foo');
SELECT * FROM x;
UPDATE x SET x = x || 'bar';
SELECT * FROM x;
DELETE FROM x;
SELECT * FROM x;
DROP TABLE x;
/* Check behavior with an implicit column default, too (bug #16644) */ CREATE TABLE x (x INT, x BOOLEAN DEFAULT TRUE NOT NULL, x TEXT DEFAULT 'xyzzy' NOT NULL);
create trigger trigger_return_old 	before insert or delete or update on trigtest 	for each row execute procedure trigger_return_old();
INSERT INTO x VALUES (1);
SELECT * FROM x;
ALTER TABLE x ADD COLUMN x INT DEFAULT 42 NOT NULL;
SELECT * FROM x;
UPDATE x SET x = 2 WHERE x = 1 RETURNING *;
SELECT * FROM x;
ALTER TABLE x DROP COLUMN x;
SELECT * FROM x;
UPDATE x SET x = 2 WHERE x = 1 RETURNING *;
SELECT * FROM x;
DROP TABLE x;
CREATE SEQUENCE x START WITH 0 INCREMENT BY 10 MINVALUE 0;
CREATE TABLE x (x INT, x INT, x INT, x INT DEFAULT 999999);
create trigger ttdummy 	before delete or update on tttest 	for each row 	execute procedure 	ttdummy (price_on, price_off);
create trigger ttserial 	before insert or update on tttest 	for each row 	execute procedure 	autoinc (price_on, ttdummy_seq);
INSERT INTO x VALUES (1, 1, NULL);
INSERT INTO x VALUES (2, 2, NULL);
INSERT INTO x VALUES (3, 3, 0);
SELECT * FROM x;
DELETE FROM x WHERE x = 2;
SELECT * FROM x;
/* what do we see ? */ /* get current prices */ SELECT * FROM x WHERE x = 999999;
/* change price for price_id == 3 */ UPDATE x SET x = 30 WHERE x = 3;
SELECT * FROM x;
/* now we want to change pric_id in ALL tuples */ /* this gets us not what we need */ UPDATE x SET x = 5 WHERE x = 3;
SELECT * FROM x;
/* restore data as before last update: */ SELECT SET_TTDUMMY(0);
DELETE FROM x WHERE x = 5;
UPDATE x SET x = 999999 WHERE x = 30;
SELECT * FROM x;
/* and try change price_id now! */ UPDATE x SET x = 5 WHERE x = 3;
SELECT * FROM x;
/* isn't it what we need ? */ SELECT SET_TTDUMMY(1);
/* we want to correct some "date" */ UPDATE x SET x = -1 WHERE x = 1;
/* but this doesn't work */ /* try in this way */ SELECT SET_TTDUMMY(0);
UPDATE x SET x = -1 WHERE x = 1;
SELECT * FROM x;
/* isn't it what we need ? */ /* get price for price_id == 5 as it was @ "date" 35 */ SELECT * FROM x WHERE x <= 35 AND x > 35 AND x = 5;
DROP TABLE x;
DROP SEQUENCE x;
/* tests for per-statement triggers */ CREATE TABLE x (x TIMESTAMP DEFAULT CAST(TIMEOFDAY() AS TIMESTAMP));
CREATE TABLE x (x INT UNIQUE, x INT);
COPY INTO x (x, x) FROM x;
x AS x;
COMMIT;
CREATE TRIGGER before_ins_stmt_trig BEFORE INSERT ON main_table FOR EACH STATEMENT EXECUTE PROCEDURE trigger_func('before_ins_stmt');
CREATE TRIGGER after_ins_stmt_trig AFTER INSERT ON main_table FOR EACH STATEMENT EXECUTE PROCEDURE trigger_func('after_ins_stmt');
/* if neither 'FOR EACH ROW' nor 'FOR EACH STATEMENT' was specified, */ /* CREATE TRIGGER should default to 'FOR EACH STATEMENT' */ CREATE TRIGGER after_upd_stmt_trig AFTER UPDATE ON main_table EXECUTE PROCEDURE trigger_func('after_upd_stmt');
/* Both insert and update statement level triggers (before and after) should */ /* fire.  Doesn't fire UPDATE before trigger, but only because one isn't */ /* defined. */ INSERT INTO x (x, x) VALUES (5, 10) ON CONFLICT(x) DO UPDATE SET x = x.x;
CREATE TRIGGER after_upd_row_trig AFTER UPDATE ON main_table FOR EACH ROW EXECUTE PROCEDURE trigger_func('after_upd_row');
UPDATE x SET x = x + 1 WHERE x < 30;
/* UPDATE that effects zero rows should still call per-statement trigger */ UPDATE x SET x = x + 2 WHERE x > 100;
ALTER TABLE x DROP CONSTRAINT x /* constraint now unneeded */;
COPY INTO x (x, x) FROM x /* COPY should fire per-row and per-statement INSERT triggers */;
/* test triggers with WHEN clause */ CREATE TRIGGER modified_a BEFORE UPDATE OF a ON main_table FOR EACH ROW WHEN (OLD.a <> NEW.a) EXECUTE PROCEDURE trigger_func('modified_a');
CREATE TRIGGER modified_any BEFORE UPDATE OF a ON main_table FOR EACH ROW WHEN (OLD.* IS DISTINCT FROM NEW.*) EXECUTE PROCEDURE trigger_func('modified_any');
CREATE TRIGGER insert_a AFTER INSERT ON main_table FOR EACH ROW WHEN (NEW.a = 123) EXECUTE PROCEDURE trigger_func('insert_a');
CREATE TRIGGER delete_a AFTER DELETE ON main_table FOR EACH ROW WHEN (OLD.a = 123) EXECUTE PROCEDURE trigger_func('delete_a');
CREATE TRIGGER insert_when BEFORE INSERT ON main_table FOR EACH STATEMENT WHEN (true) EXECUTE PROCEDURE trigger_func('insert_when');
CREATE TRIGGER delete_when AFTER DELETE ON main_table FOR EACH STATEMENT WHEN (true) EXECUTE PROCEDURE trigger_func('delete_when');
SELECT x, x, x, x, x, x, x, x, x, x FROM x.x WHERE x IN ('main_table') ORDER BY x COLLATE "x" NULLS LAST, 2 NULLS LAST;
INSERT INTO x (x) VALUES (123), (456);
COPY INTO x FROM x;
UPDATE x SET x = 50, x = 60;
SELECT * FROM x ORDER BY x NULLS LAST, x NULLS LAST;
SELECT PG_GET_TRIGGERDEF(x, TRUE) FROM x WHERE x = CAST('main_table' AS REGCLASS) AND x = 'modified_a';
SELECT PG_GET_TRIGGERDEF(x, FALSE) FROM x WHERE x = CAST('main_table' AS REGCLASS) AND x = 'modified_a';
SELECT PG_GET_TRIGGERDEF(x, TRUE) FROM x WHERE x = CAST('main_table' AS REGCLASS) AND x = 'modified_any';
/* Test RENAME TRIGGER */ ALTER TRIGGER modified_a ON main_table RENAME TO modified_modified_a;
SELECT COUNT(*) FROM x WHERE x = CAST('main_table' AS REGCLASS) AND x = 'modified_a';
SELECT COUNT(*) FROM x WHERE x = CAST('main_table' AS REGCLASS) AND x = 'modified_modified_a';
DROP TRIGGER modified_modified_a ON main_table;
DROP TRIGGER modified_any ON main_table;
DROP TRIGGER insert_a ON main_table;
DROP TRIGGER delete_a ON main_table;
DROP TRIGGER insert_when ON main_table;
DROP TRIGGER delete_when ON main_table;
/* Test WHEN condition accessing system columns. */ CREATE TABLE x (x INT);
INSERT INTO x VALUES (1);
create trigger oid_unchanged_trig after update on table_with_oids 	for each row 	when (new.tableoid = old.tableoid AND new.tableoid <> 0) 	execute procedure trigger_func('after_upd_oid_unchanged');
UPDATE x SET x = x + 1;
DROP TABLE x;
/* Test column-level triggers */ DROP TRIGGER after_upd_row_trig ON main_table;
CREATE TRIGGER before_upd_a_row_trig BEFORE UPDATE OF a ON main_table FOR EACH ROW EXECUTE PROCEDURE trigger_func('before_upd_a_row');
CREATE TRIGGER after_upd_b_row_trig AFTER UPDATE OF b ON main_table FOR EACH ROW EXECUTE PROCEDURE trigger_func('after_upd_b_row');
CREATE TRIGGER after_upd_a_b_row_trig AFTER UPDATE OF a, b ON main_table FOR EACH ROW EXECUTE PROCEDURE trigger_func('after_upd_a_b_row');
CREATE TRIGGER before_upd_a_stmt_trig BEFORE UPDATE OF a ON main_table FOR EACH STATEMENT EXECUTE PROCEDURE trigger_func('before_upd_a_stmt');
CREATE TRIGGER after_upd_b_stmt_trig AFTER UPDATE OF b ON main_table FOR EACH STATEMENT EXECUTE PROCEDURE trigger_func('after_upd_b_stmt');
SELECT PG_GET_TRIGGERDEF(x) FROM x WHERE x = CAST('main_table' AS REGCLASS) AND x = 'after_upd_a_b_row_trig';
UPDATE x SET x = 50;
UPDATE x SET x = 10;
/* Test case for bug with BEFORE trigger followed by AFTER trigger with WHEN */ CREATE TABLE x (x BOOLEAN NOT NULL);
x AS x;
COMMIT;
CREATE TRIGGER some_trig_before BEFORE UPDATE ON some_t FOR EACH ROW   EXECUTE PROCEDURE dummy_update_func('before');
CREATE TRIGGER some_trig_aftera AFTER UPDATE ON some_t FOR EACH ROW   WHEN (NOT OLD.some_col AND NEW.some_col)   EXECUTE PROCEDURE dummy_update_func('aftera');
CREATE TRIGGER some_trig_afterb AFTER UPDATE ON some_t FOR EACH ROW   WHEN (NOT NEW.some_col)   EXECUTE PROCEDURE dummy_update_func('afterb');
INSERT INTO x VALUES (TRUE);
UPDATE x SET x = TRUE;
UPDATE x SET x = FALSE;
UPDATE x SET x = TRUE;
DROP TABLE x;
/* bogus cases */ CREATE TRIGGER error_upd_and_col BEFORE UPDATE OR UPDATE OF a ON main_table FOR EACH ROW EXECUTE PROCEDURE trigger_func('error_upd_and_col');
CREATE TRIGGER error_upd_a_a BEFORE UPDATE OF a, a ON main_table FOR EACH ROW EXECUTE PROCEDURE trigger_func('error_upd_a_a');
CREATE TRIGGER error_ins_a BEFORE INSERT OF a ON main_table FOR EACH ROW EXECUTE PROCEDURE trigger_func('error_ins_a');
CREATE TRIGGER error_ins_when BEFORE INSERT OR UPDATE ON main_table FOR EACH ROW WHEN (OLD.a <> NEW.a) EXECUTE PROCEDURE trigger_func('error_ins_old');
CREATE TRIGGER error_del_when BEFORE DELETE OR UPDATE ON main_table FOR EACH ROW WHEN (OLD.a <> NEW.a) EXECUTE PROCEDURE trigger_func('error_del_new');
CREATE TRIGGER error_del_when BEFORE INSERT OR UPDATE ON main_table FOR EACH ROW WHEN (NEW.tableoid <> 0) EXECUTE PROCEDURE trigger_func('error_when_sys_column');
CREATE TRIGGER error_stmt_when BEFORE UPDATE OF a ON main_table FOR EACH STATEMENT WHEN (OLD.* IS DISTINCT FROM NEW.*) EXECUTE PROCEDURE trigger_func('error_stmt_when');
ALTER TABLE x DROP COLUMN x /* check dependency restrictions */;
/* this should succeed, but we'll roll it back to keep the triggers around */ BEGIN;
DROP TRIGGER after_upd_a_b_row_trig ON main_table;
DROP TRIGGER after_upd_b_row_trig ON main_table;
DROP TRIGGER after_upd_b_stmt_trig ON main_table;
ALTER TABLE x DROP COLUMN x;
ROLLBACK;
/* Test enable/disable triggers */ CREATE TABLE x (x SERIAL PRIMARY KEY);
/* test that disabling RI triggers works */ CREATE TABLE x (x INT REFERENCES x (x) ON delete CASCADE);
x AS x;
COMMIT;
create trigger trigtest_b_row_tg before insert or update or delete on trigtest for each row execute procedure trigtest();
create trigger trigtest_a_row_tg after insert or update or delete on trigtest for each row execute procedure trigtest();
create trigger trigtest_b_stmt_tg before insert or update or delete on trigtest for each statement execute procedure trigtest();
create trigger trigtest_a_stmt_tg after insert or update or delete on trigtest for each statement execute procedure trigtest();
alter table trigtest disable trigger trigtest_b_row_tg;
alter table trigtest disable trigger user;
alter table trigtest enable trigger trigtest_a_stmt_tg;
SET x = replica;
/* does not trigger */ alter table trigtest enable always trigger trigtest_a_stmt_tg;
/* now it does */ RESET session_replication_role;
INSERT INTO x VALUES (1);
INSERT INTO x VALUES (2);
DELETE FROM x WHERE x = 2;
SELECT * FROM x;
alter table trigtest disable trigger all;
DELETE FROM x WHERE x = 1;
SELECT * FROM x;
SELECT * FROM x;
DROP TABLE x;
DROP TABLE x;
/* dump trigger data */ CREATE TABLE x (x INT, x VARCHAR);
x AS x;
BEGIN relid := TG_relid::regclass;
x := '[';
x := x || x[x];
x := x || ']';
if TG_OP != 'INSERT' then 		raise NOTICE 'OLD: %', OLD;
if TG_OP != 'DELETE' then 		raise NOTICE 'NEW: %', NEW;
if TG_OP = 'DELETE' then 		return OLD;
COMMIT;
CREATE TRIGGER show_trigger_data_trig BEFORE INSERT OR UPDATE OR DELETE ON trigger_test FOR EACH ROW EXECUTE PROCEDURE trigger_data(23,'skidoo');
INSERT INTO x VALUES (1, 'insert');
UPDATE x SET x = 'update' WHERE x = 1;
DELETE FROM x;
DROP TRIGGER show_trigger_data_trig on trigger_test;
DROP FUNCTION x;
DROP TABLE x;
/* Test use of row comparisons on OLD/NEW */ CREATE TABLE x (x INT, x TEXT, x TEXT);
x AS x;
x;
CREATE TRIGGER t BEFORE UPDATE ON trigger_test FOR EACH ROW EXECUTE PROCEDURE mytrigger();
INSERT INTO x VALUES (1, 'foo', 'bar');
INSERT INTO x VALUES (2, 'baz', 'quux');
UPDATE x SET x = 'bar';
UPDATE x SET x = NULL;
/* this demonstrates that the above isn't really working as desired: */ UPDATE x SET x = NULL;
x AS x;
x;
UPDATE x SET x = 'bar';
UPDATE x SET x = NULL;
UPDATE x SET x = NULL;
DROP TABLE x;
DROP FUNCTION x;
BEGIN new.description = 'updated in trigger';
x AS x;
COMMIT;
CREATE TABLE x (x INT, x TEXT, x TEXT);
CREATE TRIGGER serializable_update_trig BEFORE UPDATE ON serializable_update_tab 	FOR EACH ROW EXECUTE PROCEDURE serializable_update_trig();
INSERT INTO x SELECT x, REPEAT('xyzxz', 100), 'new' FROM x AS x;
BEGIN;
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
UPDATE x SET x = 'no no', x = 1 WHERE x = 1;
COMMIT;
SELECT x FROM x WHERE x = 1;
DROP TABLE x;
/* minimal update trigger */ CREATE TABLE x (x TEXT, x INT, x INT);
INSERT INTO x VALUES ('a', 1, 2), ('b', '2', NULL);
CREATE TRIGGER z_min_update BEFORE UPDATE ON min_updates_test FOR EACH ROW EXECUTE PROCEDURE suppress_redundant_updates_trigger();
UPDATE x SET x = x + 1;
UPDATE x SET x = 2 WHERE x IS NULL;
DROP TABLE x;
/* Test triggers on views */ CREATE VIEW x AS SELECT x, x FROM x;
BEGIN for i in 0 .. TG_nargs - 1 loop         if i > 0 then             argstr := argstr || ', ';
x := x || x[x];
if TG_LEVEL = 'ROW' then         if TG_OP = 'INSERT' then             raise NOTICE 'NEW: %', NEW;
INSERT INTO x VALUES (x.x, x.x);
x AS x;
if TG_OP = 'UPDATE' then             raise NOTICE 'OLD: %, NEW: %', OLD, NEW;
UPDATE x SET x = x.x, x = x.x WHERE x = x.x AND x = x.x;
if NOT FOUND then RETURN NULL;
x AS x;
if TG_OP = 'DELETE' then             raise NOTICE 'OLD: %', OLD;
DELETE FROM x WHERE x = x.x AND x = x.x;
if NOT FOUND then RETURN NULL;
x AS x;
x AS x;
COMMIT;
/* Before row triggers aren't allowed on views */ CREATE TRIGGER invalid_trig BEFORE INSERT ON main_view FOR EACH ROW EXECUTE PROCEDURE trigger_func('before_ins_row');
CREATE TRIGGER invalid_trig BEFORE UPDATE ON main_view FOR EACH ROW EXECUTE PROCEDURE trigger_func('before_upd_row');
CREATE TRIGGER invalid_trig BEFORE DELETE ON main_view FOR EACH ROW EXECUTE PROCEDURE trigger_func('before_del_row');
/* After row triggers aren't allowed on views */ CREATE TRIGGER invalid_trig AFTER INSERT ON main_view FOR EACH ROW EXECUTE PROCEDURE trigger_func('before_ins_row');
CREATE TRIGGER invalid_trig AFTER UPDATE ON main_view FOR EACH ROW EXECUTE PROCEDURE trigger_func('before_upd_row');
CREATE TRIGGER invalid_trig AFTER DELETE ON main_view FOR EACH ROW EXECUTE PROCEDURE trigger_func('before_del_row');
/* Truncate triggers aren't allowed on views */ CREATE TRIGGER invalid_trig BEFORE TRUNCATE ON main_view EXECUTE PROCEDURE trigger_func('before_tru_row');
CREATE TRIGGER invalid_trig AFTER TRUNCATE ON main_view EXECUTE PROCEDURE trigger_func('before_tru_row');
/* INSTEAD OF triggers aren't allowed on tables */ CREATE TRIGGER invalid_trig INSTEAD OF INSERT ON main_table FOR EACH ROW EXECUTE PROCEDURE view_trigger('instead_of_ins');
CREATE TRIGGER invalid_trig INSTEAD OF UPDATE ON main_table FOR EACH ROW EXECUTE PROCEDURE view_trigger('instead_of_upd');
CREATE TRIGGER invalid_trig INSTEAD OF DELETE ON main_table FOR EACH ROW EXECUTE PROCEDURE view_trigger('instead_of_del');
/* Don't support WHEN clauses with INSTEAD OF triggers */ CREATE TRIGGER invalid_trig INSTEAD OF UPDATE ON main_view FOR EACH ROW WHEN (OLD.a <> NEW.a) EXECUTE PROCEDURE view_trigger('instead_of_upd');
/* Don't support column-level INSTEAD OF triggers */ CREATE TRIGGER invalid_trig INSTEAD OF UPDATE OF a ON main_view FOR EACH ROW EXECUTE PROCEDURE view_trigger('instead_of_upd');
/* Don't support statement-level INSTEAD OF triggers */ CREATE TRIGGER invalid_trig INSTEAD OF UPDATE ON main_view EXECUTE PROCEDURE view_trigger('instead_of_upd');
/* Valid INSTEAD OF triggers */ CREATE TRIGGER instead_of_insert_trig INSTEAD OF INSERT ON main_view FOR EACH ROW EXECUTE PROCEDURE view_trigger('instead_of_ins');
CREATE TRIGGER instead_of_update_trig INSTEAD OF UPDATE ON main_view FOR EACH ROW EXECUTE PROCEDURE view_trigger('instead_of_upd');
CREATE TRIGGER instead_of_delete_trig INSTEAD OF DELETE ON main_view FOR EACH ROW EXECUTE PROCEDURE view_trigger('instead_of_del');
/* Valid BEFORE statement VIEW triggers */ CREATE TRIGGER before_ins_stmt_trig BEFORE INSERT ON main_view FOR EACH STATEMENT EXECUTE PROCEDURE view_trigger('before_view_ins_stmt');
CREATE TRIGGER before_upd_stmt_trig BEFORE UPDATE ON main_view FOR EACH STATEMENT EXECUTE PROCEDURE view_trigger('before_view_upd_stmt');
CREATE TRIGGER before_del_stmt_trig BEFORE DELETE ON main_view FOR EACH STATEMENT EXECUTE PROCEDURE view_trigger('before_view_del_stmt');
/* Valid AFTER statement VIEW triggers */ CREATE TRIGGER after_ins_stmt_trig AFTER INSERT ON main_view FOR EACH STATEMENT EXECUTE PROCEDURE view_trigger('after_view_ins_stmt');
CREATE TRIGGER after_upd_stmt_trig AFTER UPDATE ON main_view FOR EACH STATEMENT EXECUTE PROCEDURE view_trigger('after_view_upd_stmt');
CREATE TRIGGER after_del_stmt_trig AFTER DELETE ON main_view FOR EACH STATEMENT EXECUTE PROCEDURE view_trigger('after_view_del_stmt');
INSERT INTO x VALUES (21, 31) RETURNING x, x;
/* Table trigger will prevent updates */ UPDATE x SET x = 31 WHERE x = 20;
UPDATE x SET x = 32 WHERE x = 21 AND x = 31 RETURNING x, x;
/* Remove table trigger to allow updates */ DROP TRIGGER before_upd_a_row_trig ON main_table;
UPDATE x SET x = 31 WHERE x = 20;
UPDATE x SET x = 32 WHERE x = 21 AND x = 31 RETURNING x, x;
/* Before and after stmt triggers should fire even when no rows are affected */ UPDATE x SET x = 0 WHERE FALSE;
/* Delete from view using trigger */ DELETE FROM x WHERE x IN (20, 21);
DELETE FROM x WHERE x = 31 RETURNING x, x;
DROP TRIGGER instead_of_delete_trig ON main_view;
/* Test triggers on a join view */ CREATE TABLE x (x SERIAL PRIMARY KEY, x TEXT UNIQUE NOT NULL, x TEXT NOT NULL);
INSERT INTO x (x, x) VALUES ('Japan', 'Asia'), ('UK', 'Europe'), ('USA', 'North America') RETURNING *;
CREATE TABLE x (x SERIAL PRIMARY KEY, x TEXT NOT NULL, x BIGINT, x INT REFERENCES x);
CREATE VIEW x AS SELECT x, x, x, x, x FROM x AS x LEFT JOIN x AS x ON x.x = x.x;
BEGIN if NEW.country_name IS NOT NULL then         SELECT country_id, continent INTO ctry_id, NEW.continent             FROM country_table WHERE country_name = NEW.country_name;
if NOT FOUND then             raise exception 'No such country: "%"', NEW.country_name;
if NEW.city_id IS NOT NULL then         INSERT INTO city_table             VALUES(NEW.city_id, NEW.city_name, NEW.population, ctry_id);
x AS x;
COMMIT;
CREATE TRIGGER city_insert_trig INSTEAD OF INSERT ON city_view FOR EACH ROW EXECUTE PROCEDURE city_insert();
if NOT FOUND then RETURN NULL;
x AS x;
COMMIT;
CREATE TRIGGER city_delete_trig INSTEAD OF DELETE ON city_view FOR EACH ROW EXECUTE PROCEDURE city_delete();
BEGIN if NEW.country_name IS DISTINCT FROM OLD.country_name then         SELECT country_id, continent INTO ctry_id, NEW.continent             FROM country_table WHERE country_name = NEW.country_name;
if NOT FOUND then             raise exception 'No such country: "%"', NEW.country_name;
UPDATE x SET x = x.x, x = x.x, x = x WHERE x = x.x;
x.x := x.x;
if NOT FOUND then RETURN NULL;
x AS x;
COMMIT;
CREATE TRIGGER city_update_trig INSTEAD OF UPDATE ON city_view FOR EACH ROW EXECUTE PROCEDURE city_update();
INSERT INTO x (x, x) VALUES ('London', 7556900) RETURNING *;
INSERT INTO x (x, x) VALUES ('Washington DC', 'USA') RETURNING *;
INSERT INTO x (x, x) VALUES (123456, 'New York') RETURNING *;
INSERT INTO x VALUES (234567, 'Birmingham', 1016800, 'UK', 'EU') RETURNING *;
/* UPDATE .. RETURNING */ UPDATE x SET x = 'Japon' WHERE x = 'Tokyo';
/* error */ UPDATE x SET x = 'Japan' WHERE x = 'Takyo';
/* no match */ UPDATE x SET x = 'Japan' WHERE x = 'Tokyo' RETURNING *;
/* OK */ UPDATE x SET x = 13010279 WHERE x = 'Tokyo' RETURNING *;
UPDATE x SET x = 'UK' WHERE x = 'New York' RETURNING *;
UPDATE x SET x = 'USA', x = 8391881 WHERE x = 'New York' RETURNING *;
UPDATE x SET x = 'EU' WHERE x = 'Europe' RETURNING *;
UPDATE x AS x SET x = x.x FROM x AS x WHERE x.x = 'Birmingham' AND x.x = 'London' RETURNING *;
/* DELETE .. RETURNING */ DELETE FROM x WHERE x = 'Birmingham' RETURNING *;
SELECT COUNT(*) FROM x;
CREATE TRIGGER no_op_trig INSTEAD OF INSERT OR UPDATE OR DELETE ON european_city_view FOR EACH ROW EXECUTE PROCEDURE no_op_trig_fn();
UPDATE x SET x = 10000;
DELETE FROM x;
CREATE RULE european_city_update_rule AS ON UPDATE TO european_city_view DO INSTEAD UPDATE city_view SET     city_name = NEW.city_name,     population = NEW.population,     country_name = NEW.country_name WHERE city_id = OLD.city_id RETURNING NEW.*;
CREATE RULE european_city_delete_rule AS ON DELETE TO european_city_view DO INSTEAD DELETE FROM city_view WHERE city_id = OLD.city_id RETURNING *;
UPDATE x SET x = 'UK' WHERE x = 'Cambridge';
DELETE FROM x WHERE x = 'Cambridge';
/* UPDATE and DELETE via rule and trigger */ UPDATE x SET x = 'UK' WHERE x = 'Cambridge' RETURNING *;
UPDATE x SET x = 122800 WHERE x = 'Cambridge' RETURNING *;
DELETE FROM x WHERE x = 'Cambridge' RETURNING *;
/* join UPDATE test */ UPDATE x AS x SET x = 599657 FROM x AS x, x AS x WHERE x.x = 'Washington DC' AND x.x = 'USA' AND x.x = x.x AND x.x = x.x RETURNING x.x, x.x, x.x, x.x, x.x;
DROP TABLE x CASCADE;
DROP TABLE x;
/* Test pg_trigger_depth() */ CREATE TABLE x (x INT NOT NULL PRIMARY KEY);
CREATE TABLE x (x INT NOT NULL PRIMARY KEY);
CREATE TABLE x (x INT NOT NULL PRIMARY KEY);
INSERT INTO x VALUES (x.x);
x AS x;
COMMIT;
create trigger depth_a_tr before insert on depth_a   for each row execute procedure depth_a_tf();
BEGIN execute 'insert into depth_c values (' || new.id::text || ')';
COMMIT;
if new.id = 1 then     execute 'insert into depth_c values (' || new.id::text || ')';
x AS x;
COMMIT;
create trigger depth_b_tr before insert on depth_b   for each row execute procedure depth_b_tf();
if new.id = 1 then     raise exception sqlstate 'U9999';
x AS x;
COMMIT;
create trigger depth_c_tr before insert on depth_c   for each row execute procedure depth_c_tf();
SELECT PG_TRIGGER_DEPTH();
INSERT INTO x VALUES (1);
SELECT PG_TRIGGER_DEPTH();
INSERT INTO x VALUES (2);
SELECT PG_TRIGGER_DEPTH();
DROP FUNCTION x;
DROP FUNCTION x;
DROP FUNCTION x;
/* Test updates to rows during firing of BEFORE ROW triggers. */ /* As of 9.2, such cases should be rejected (see bug #6123). */ CREATE TEMPORARY TABLE x (x INT NOT NULL PRIMARY KEY, x TEXT, x TEXT, x TEXT, x TEXT, x INT NOT NULL DEFAULT 0);
CREATE TEMPORARY TABLE x (x INT NOT NULL PRIMARY KEY, x INT NOT NULL, x TEXT);
DELETE FROM x WHERE x.x = x.x AND x.x = x.x;
x AS x;
COMMIT;
create trigger parent_upd_trig before update on parent   for each row execute procedure parent_upd_func();
x AS x;
COMMIT;
create trigger parent_del_trig before delete on parent   for each row execute procedure parent_del_func();
x AS x;
COMMIT;
create trigger child_ins_trig after insert on child   for each row execute procedure child_ins_func();
x AS x;
COMMIT;
create trigger child_del_trig after delete on child   for each row execute procedure child_del_func();
INSERT INTO x VALUES (1, 'a', 'a', 'a', 'a', 0);
INSERT INTO x VALUES (10, 1, 'b');
SELECT * FROM x;
SELECT * FROM x;
UPDATE x SET x = 'b' WHERE x = 1;
MERGE INTO x AS x USING (VALUES (1)) AS x ON x.x = x.x WHEN MATCHED THEN UPDATE SET x = 'b' /* should fail */;
/* should fail */ SELECT * FROM x;
SELECT * FROM x;
DELETE FROM x WHERE x = 1;
MERGE INTO x AS x USING (VALUES (1)) AS x ON x.x = x.x WHEN MATCHED THEN delete /* should fail */;
/* should fail */ SELECT * FROM x;
SELECT * FROM x;
if found then     delete from parent where aid = old.aid;
x AS x;
x AS x;
COMMIT;
DELETE FROM x WHERE x = 1;
SELECT * FROM x;
SELECT * FROM x;
DROP FUNCTION x;
DROP FUNCTION x;
DROP FUNCTION x;
DROP FUNCTION x;
/* similar case, but with a self-referencing FK so that parent and child */ /* rows can be affected by a single operation */ CREATE TEMPORARY TABLE x (x INT PRIMARY KEY, x INT REFERENCES x, x TEXT, x INT NOT NULL DEFAULT 0);
x AS x;
COMMIT;
create trigger self_ref_trigger_ins_trig before insert on self_ref_trigger   for each row execute procedure self_ref_trigger_ins_func();
x AS x;
COMMIT;
create trigger self_ref_trigger_del_trig before delete on self_ref_trigger   for each row execute procedure self_ref_trigger_del_func();
INSERT INTO x VALUES (1, NULL, 'root');
INSERT INTO x VALUES (2, 1, 'root child A');
INSERT INTO x VALUES (3, 1, 'root child B');
INSERT INTO x VALUES (4, 2, 'grandchild 1');
INSERT INTO x VALUES (5, 3, 'grandchild 2');
UPDATE x SET x = 'root!' WHERE x = 1;
SELECT * FROM x;
DELETE FROM x;
SELECT * FROM x;
DROP TABLE x;
DROP FUNCTION x;
DROP FUNCTION x;
/* Check that statement triggers work correctly even with all children excluded */ CREATE TABLE x (x INT);
CREATE TABLE x INHERITS (x);
x AS x;
COMMIT;
create trigger before_stmt_trigger 	before update on stmt_trig_on_empty_upd 	execute procedure update_stmt_notice();
create trigger before_stmt_trigger 	before update on stmt_trig_on_empty_upd1 	execute procedure update_stmt_notice();
/* inherited no-op update */ UPDATE x SET x = x WHERE FALSE RETURNING x + 1 AS x;
/* simple no-op update */ UPDATE x SET x = x WHERE FALSE RETURNING x + 1 AS x;
DROP TABLE x CASCADE;
DROP FUNCTION x;
/* Check that index creation (or DDL in general) is prohibited in a trigger */ CREATE TABLE x (x INT, x INT);
x AS x;
create trigger trigger_ddl_func before insert on trigger_ddl_table for each row   execute procedure trigger_ddl_func();
INSERT INTO x VALUES (1, 42);
x AS x;
INSERT INTO x VALUES (1, 42);
/* fail */ DROP TABLE x;
DROP FUNCTION x;
/* Verify behavior of before and after triggers with INSERT...ON CONFLICT */ /* DO UPDATE */ CREATE TABLE x (x INT PRIMARY KEY, x TEXT);
if new.key % 2 = 0 then       new.key := new.key + 1;
x.x := x.x || ' trig modified';
x AS x;
COMMIT;
create trigger upsert_before_trig before insert or update on upsert   for each row execute procedure upsert_before_func();
x AS x;
COMMIT;
create trigger upsert_after_trig after insert or update on upsert   for each row execute procedure upsert_after_func();
INSERT INTO x VALUES (1, 'black') ON CONFLICT(x) DO UPDATE SET x = 'updated ' || x.x;
INSERT INTO x VALUES (2, 'red') ON CONFLICT(x) DO UPDATE SET x = 'updated ' || x.x;
INSERT INTO x VALUES (3, 'orange') ON CONFLICT(x) DO UPDATE SET x = 'updated ' || x.x;
INSERT INTO x VALUES (4, 'green') ON CONFLICT(x) DO UPDATE SET x = 'updated ' || x.x;
INSERT INTO x VALUES (5, 'purple') ON CONFLICT(x) DO UPDATE SET x = 'updated ' || x.x;
INSERT INTO x VALUES (6, 'white') ON CONFLICT(x) DO UPDATE SET x = 'updated ' || x.x;
INSERT INTO x VALUES (7, 'pink') ON CONFLICT(x) DO UPDATE SET x = 'updated ' || x.x;
INSERT INTO x VALUES (8, 'yellow') ON CONFLICT(x) DO UPDATE SET x = 'updated ' || x.x;
SELECT * FROM x;
DROP TABLE x;
DROP FUNCTION x;
DROP FUNCTION x;
/* Verify that triggers with transition tables are not allowed on */ /* views */ CREATE TABLE x (x INT);
CREATE VIEW x AS SELECT * FROM x;
create trigger my_trigger after update on my_view referencing old table as old_table    for each statement execute procedure my_trigger_function();
DROP FUNCTION x;
DROP VIEW x;
DROP TABLE x;
/* Verify cases that are unsupported with partitioned tables */ CREATE TABLE x (x INT) WITH (PARTITIONED_BY=LIST(x));
create trigger failed instead of update on parted_trig   for each row execute procedure trigger_nothing();
create trigger failed after update on parted_trig   referencing old table as old_table   for each row execute procedure trigger_nothing();
DROP TABLE x;
/* Verify trigger creation for partitioned tables, and drop behavior */ CREATE TABLE x (x INT, x INT) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (0) TO (1000);
create trigger trg1 after insert on trigpart for each row execute procedure trigger_nothing();
CREATE TABLE x PARTITION OF x FOR VALUES FROM (1000) TO (2000);
CREATE TABLE x (LIKE x);
alter table trigpart attach partition trigpart3 for values from (2000) to (3000);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (3000) TO (4000) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (3000) TO (3500);
CREATE TABLE x (LIKE x);
alter table trigpart4 attach partition trigpart42 for values from (3500) to (4000);
SELECT CAST(x AS REGCLASS), x, CAST(x AS REGPROC) FROM x WHERE CAST(CAST(x AS REGCLASS) AS TEXT) LIKE 'trigpart%' ORDER BY CAST(CAST(x AS REGCLASS) AS TEXT) NULLS LAST;
drop trigger trg1 on trigpart1;
/* fail */ drop trigger trg1 on trigpart2;
/* fail */ drop trigger trg1 on trigpart3;
/* fail */ DROP TABLE x;
/* ok, trigger should be gone in that partition */ SELECT CAST(x AS REGCLASS), x, CAST(x AS REGPROC) FROM x WHERE CAST(CAST(x AS REGCLASS) AS TEXT) LIKE 'trigpart%' ORDER BY CAST(CAST(x AS REGCLASS) AS TEXT) NULLS LAST;
drop trigger trg1 on trigpart;
/* ok, all gone */ SELECT CAST(x AS REGCLASS), x, CAST(x AS REGPROC) FROM x WHERE CAST(CAST(x AS REGCLASS) AS TEXT) LIKE 'trigpart%' ORDER BY CAST(CAST(x AS REGCLASS) AS TEXT) NULLS LAST;
/* check detach behavior */ create trigger trg1 after insert on trigpart for each row execute procedure trigger_nothing();
drop trigger trg1 on trigpart3;
/* fail due to "does not exist" */ alter table trigpart detach partition trigpart4;
drop trigger trg1 on trigpart41;
/* fail due to "does not exist" */ DROP TABLE x;
alter table trigpart attach partition trigpart3 for values from (2000) to (3000);
alter table trigpart detach partition trigpart3;
alter table trigpart attach partition trigpart3 for values from (2000) to (3000);
DROP TABLE x;
SELECT CAST(CAST(x AS REGCLASS) AS TEXT), x, CAST(x AS REGPROC), x, x FROM x WHERE REGEXP_LIKE(x, '^trg1') ORDER BY 1 NULLS LAST;
CREATE TABLE x (LIKE x);
create trigger trg1 after insert on trigpart3 for each row execute procedure trigger_nothing();
/* fail */ DROP TABLE x;
/* check display of unrelated triggers */ create trigger samename after delete on trigpart execute function trigger_nothing();
create trigger samename after delete on trigpart1 execute function trigger_nothing();
DROP FUNCTION x;
/* Verify that triggers are fired for partitioned tables */ CREATE TABLE x (x INT) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN (1);
CREATE TABLE x PARTITION OF x FOR VALUES IN (2);
CREATE TABLE x (x INT) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN (1);
CREATE TABLE x PARTITION OF x FOR VALUES IN (2);
if TG_LEVEL = 'ROW' then        return NEW;
x AS x;
COMMIT;
/* insert/update/delete statement-level triggers on the parent */ create trigger trig_ins_before before insert on parted_stmt_trig   for each statement execute procedure trigger_notice();
create trigger trig_ins_after after insert on parted_stmt_trig   for each statement execute procedure trigger_notice();
create trigger trig_upd_before before update on parted_stmt_trig   for each statement execute procedure trigger_notice();
create trigger trig_upd_after after update on parted_stmt_trig   for each statement execute procedure trigger_notice();
create trigger trig_del_before before delete on parted_stmt_trig   for each statement execute procedure trigger_notice();
create trigger trig_del_after after delete on parted_stmt_trig   for each statement execute procedure trigger_notice();
/* insert/update/delete row-level triggers on the parent */ create trigger trig_ins_after_parent after insert on parted_stmt_trig   for each row execute procedure trigger_notice();
create trigger trig_upd_after_parent after update on parted_stmt_trig   for each row execute procedure trigger_notice();
create trigger trig_del_after_parent after delete on parted_stmt_trig   for each row execute procedure trigger_notice();
/* insert/update/delete row-level triggers on the first partition */ create trigger trig_ins_before_child before insert on parted_stmt_trig1   for each row execute procedure trigger_notice();
create trigger trig_ins_after_child after insert on parted_stmt_trig1   for each row execute procedure trigger_notice();
create trigger trig_upd_before_child before update on parted_stmt_trig1   for each row execute procedure trigger_notice();
create trigger trig_upd_after_child after update on parted_stmt_trig1   for each row execute procedure trigger_notice();
create trigger trig_del_before_child before delete on parted_stmt_trig1   for each row execute procedure trigger_notice();
create trigger trig_del_after_child after delete on parted_stmt_trig1   for each row execute procedure trigger_notice();
/* insert/update/delete statement-level triggers on the parent */ create trigger trig_ins_before_3 before insert on parted2_stmt_trig   for each statement execute procedure trigger_notice();
create trigger trig_ins_after_3 after insert on parted2_stmt_trig   for each statement execute procedure trigger_notice();
create trigger trig_upd_before_3 before update on parted2_stmt_trig   for each statement execute procedure trigger_notice();
create trigger trig_upd_after_3 after update on parted2_stmt_trig   for each statement execute procedure trigger_notice();
create trigger trig_del_before_3 before delete on parted2_stmt_trig   for each statement execute procedure trigger_notice();
create trigger trig_del_after_3 after delete on parted2_stmt_trig   for each statement execute procedure trigger_notice();
WITH x AS (INSERT INTO x VALUES (1), (2) RETURNING x) INSERT INTO x SELECT x FROM x RETURNING CAST(x AS REGCLASS), x;
WITH x AS (UPDATE x SET x = x) UPDATE x SET x = x;
DELETE FROM x;
COPY INTO x (x) FROM x /* insert via copy on the parent */;
INSERT INTO x VALUES (1);
alter table parted_stmt_trig enable trigger trig_ins_after_parent;
INSERT INTO x VALUES (1);
/* Verify that triggers fire in alphabetical order */ CREATE TABLE x (x INT) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (0) TO (1000) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (0) TO (100);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (1000) TO (2000);
create trigger zzz after insert on parted_trig for each row execute procedure trigger_notice();
create trigger mmm after insert on parted_trig_1_1 for each row execute procedure trigger_notice();
create trigger aaa after insert on parted_trig_1 for each row execute procedure trigger_notice();
create trigger bbb after insert on parted_trig for each row execute procedure trigger_notice();
create trigger qqq after insert on parted_trig_1_1 for each row execute procedure trigger_notice();
INSERT INTO x VALUES (50), (1500);
DROP TABLE x;
/* Verify that the correct triggers fire for cross-partition updates */ CREATE TABLE x (x INT) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN (1);
CREATE TABLE x PARTITION OF x FOR VALUES IN (2);
INSERT INTO x VALUES (1);
if TG_LEVEL = 'ROW' then       if TG_OP = 'DELETE' then         return OLD;
x AS x;
COMMIT;
create trigger parted_trig_before_stmt before insert or update or delete on parted_trig    for each statement execute procedure trigger_notice();
create trigger parted_trig_before_row before insert or update or delete on parted_trig    for each row execute procedure trigger_notice();
create trigger parted_trig_after_row after insert or update or delete on parted_trig    for each row execute procedure trigger_notice();
create trigger parted_trig_after_stmt after insert or update or delete on parted_trig    for each statement execute procedure trigger_notice();
UPDATE x SET x = 2 WHERE x = 1;
MERGE INTO x USING (SELECT 1) AS x ON TRUE WHEN MATCHED AND x = 2 THEN UPDATE SET x = 1 /* update action in merge should behave the same */;
DROP TABLE x;
/* Verify propagation of trigger arguments to partitions */ CREATE TABLE x (x INT) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN (1);
BEGIN raise notice 'trigger % on % % % for % args % %', 		TG_NAME, TG_TABLE_NAME, TG_WHEN, TG_OP, TG_LEVEL, arg1, arg2;
x AS x;
COMMIT;
create trigger aaa after insert on parted_trig    for each row execute procedure trigger_notice('quirky', 1);
/* Verify propagation of trigger arguments to partitions attached after creating trigger */ CREATE TABLE x PARTITION OF x FOR VALUES IN (2);
CREATE TABLE x (LIKE x);
alter table parted_trig attach partition parted_trig3 for values in (3);
INSERT INTO x VALUES (1), (2), (3);
DROP TABLE x;
x AS x;
COMMIT;
if TG_LEVEL = 'ROW' then        return NEW;
x AS x;
COMMIT;
CREATE TABLE x (x TEXT, x TEXT, x INT, x INT, x INT) WITH (PARTITIONED_BY=RANGE(x));
ALTER TABLE x DROP COLUMN x, DROP COLUMN x, DROP COLUMN x;
CREATE TABLE x (x INT, x INT, x INT, x TEXT) WITH (PARTITIONED_BY=RANGE(x));
ALTER TABLE x DROP COLUMN x, DROP COLUMN x;
alter table parted_irreg_ancestor attach partition parted_irreg   for values from ('aaaa') to ('zzzz');
CREATE TABLE x (x TEXT, x INT, x INT);
ALTER TABLE x DROP COLUMN x;
alter table parted_irreg attach partition parted1_irreg   for values from ('aaaa') to ('bbbb');
create trigger parted_trig after insert on parted_irreg   for each row execute procedure trigger_notice_ab();
create trigger parted_trig_odd after insert on parted_irreg for each row   when (bark(new.b) AND new.a % 2 = 1) execute procedure trigger_notice_ab();
/* we should hear barking for every insert, but parted_trig_odd only emits */ /* noise for odd values of a. parted_trig does it for all inserts. */ INSERT INTO x VALUES (1, 'aardvark'), (2, 'aanimals');
INSERT INTO x VALUES ('aardwolf', 2);
INSERT INTO x VALUES ('aasvogel', 3);
DROP TABLE x;
/* Before triggers and partitions */ CREATE TABLE x (x INT, x INT, x TEXT) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN (1) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN (1);
x AS x;
COMMIT;
INSERT INTO x VALUES (1, 1, 'uno uno v1');
/* works */ create trigger t before insert or update or delete on parted   for each row execute function parted_trigfunc();
INSERT INTO x VALUES (1, 1, 'uno uno v2');
/* fail */ UPDATE x SET x = x || 'v3';
x AS x;
COMMIT;
INSERT INTO x VALUES (1, 1, 'uno uno v4');
/* fail */ UPDATE x SET x = x || 'v5';
x AS x;
COMMIT;
INSERT INTO x VALUES (1, 1, 'uno uno');
/* works */ UPDATE x SET x = x || ' v6';
/* works */ SELECT CAST(x AS REGCLASS), * FROM x;
CREATE TABLE x PARTITION OF x FOR VALUES IN (2);
INSERT INTO x VALUES (1, 1, 'uno uno v5');
UPDATE x SET x = 2;
SELECT CAST(x AS REGCLASS), * FROM x;
x AS x;
COMMIT;
create trigger t2 before update on parted   for each row execute function parted_trigfunc2();
TRUNCATE TABLE x;
INSERT INTO x VALUES (1, 1, 'uno uno v6');
CREATE TABLE x PARTITION OF x FOR VALUES IN (3);
UPDATE x SET x = x + 1;
SELECT CAST(x AS REGCLASS), * FROM x;
/* there's no partition for a=0, but this update works anyway because */ /* the trigger causes the tuple to be routed to another partition */ UPDATE x SET x = 0;
SELECT CAST(x AS REGCLASS), * FROM x;
DROP TABLE x;
CREATE TABLE x (x INT, x INT, x TEXT) WITH (PARTITIONED_BY=LIST((x + x)));
x AS x;
COMMIT;
CREATE TABLE x PARTITION OF x FOR VALUES IN (1, 2);
CREATE TABLE x PARTITION OF x FOR VALUES IN (3, 4);
create trigger t before insert or update on parted   for each row execute function parted_trigfunc();
INSERT INTO x VALUES (0, 1, 'zero win');
INSERT INTO x VALUES (1, 1, 'one fail');
INSERT INTO x VALUES (1, 2, 'two fail');
SELECT * FROM x;
DROP TABLE x;
DROP FUNCTION x;
/* Constraint triggers and partitioned tables */ CREATE TABLE x (x INT, x TEXT) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x (x INT, x TEXT) WITH (PARTITIONED_BY=RANGE(x));
alter table parted_constr_ancestor attach partition parted_constr   for values from ('aaaa') to ('zzzz');
CREATE TABLE x (x INT, x TEXT);
alter table parted_constr attach partition parted1_constr   for values from ('aaaa') to ('bbbb');
create constraint trigger parted_trig after insert on parted_constr_ancestor   deferrable   for each row execute procedure trigger_notice_ab();
create constraint trigger parted_trig_two after insert on parted_constr   deferrable initially deferred   for each row when (bark(new.b) AND new.a % 2 = 1)   execute procedure trigger_notice_ab();
INSERT INTO x VALUES (1, 'aardvark');
INSERT INTO x VALUES (2, 'aardwolf');
INSERT INTO x VALUES (3, 'aasvogel');
COMMIT;
/* The WHEN clause is immediate, and both constraint triggers are fired at */ /* commit time. */ BEGIN;
set constraints parted_trig deferred;
INSERT INTO x VALUES (1, 'aardvark');
INSERT INTO x VALUES (2, 'aardwolf'), (3, 'aasvogel');
COMMIT;
DROP TABLE x;
DROP FUNCTION x (TEXT);
/* Test that the WHEN clause is set properly to partitions */ CREATE TABLE x (x INT, x TEXT) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (0) TO (1000);
CREATE TABLE x (x INT, x INT, x TEXT);
ALTER TABLE x DROP COLUMN x;
alter table parted_trigger attach partition parted_trigger_2 for values from (1000) to (2000);
create trigger parted_trigger after update on parted_trigger   for each row when (new.a % 2 = 1 and length(old.b) >= 2) execute procedure trigger_notice_ab();
CREATE TABLE x (x TEXT, x INT) WITH (PARTITIONED_BY=RANGE(LENGTH(x)));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (1) TO (3);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (3) TO (5);
alter table parted_trigger attach partition parted_trigger_3 for values from (2000) to (3000);
INSERT INTO x VALUES (0, 'a'), (1, 'bbb'), (2, 'bcd'), (3, 'c'), (1000, 'c'), (1001, 'ddd'), (1002, 'efg'), (1003, 'f'), (2000, 'e'), (2001, 'fff'), (2002, 'ghi'), (2003, 'h');
UPDATE x SET x = x + 2;
/* notice for odd 'a' values, long 'b' values */ DROP TABLE x;
/* try a constraint trigger, also */ CREATE TABLE x (x INT);
CREATE TABLE x (x INT, x TEXT);
/* for comparison purposes */ CREATE TABLE x (x INT, x TEXT) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (0) TO (1000);
CREATE TABLE x (x INT, x INT, x TEXT);
ALTER TABLE x DROP COLUMN x;
alter table parted_trigger attach partition parted_trigger_2 for values from (1000) to (2000);
create constraint trigger parted_trigger after update on parted_trigger   from parted_referenced   for each row execute procedure trigger_notice_ab();
create constraint trigger parted_trigger after update on unparted_trigger   from parted_referenced   for each row execute procedure trigger_notice_ab();
CREATE TABLE x (x TEXT, x INT) WITH (PARTITIONED_BY=RANGE(LENGTH(x)));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (1) TO (3);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (3) TO (5);
alter table parted_trigger attach partition parted_trigger_3 for values from (2000) to (3000);
SELECT x, x, CAST(x.x AS REGCLASS), CAST(x.x AS REGCLASS), CAST(x.x AS REGCLASS), CAST(x.x AS REGCLASS) FROM x AS x JOIN x AS x ON (x.x = x.x) WHERE x = 'parted_trigger' ORDER BY CAST(CAST(x.x AS REGCLASS) AS TEXT) NULLS LAST;
/* verify that the "AFTER UPDATE OF columns" event is propagated correctly */ CREATE TABLE x (x INT, x TEXT) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (0) TO (1000);
CREATE TABLE x (x INT, x INT, x TEXT);
ALTER TABLE x DROP COLUMN x;
alter table parted_trigger attach partition parted_trigger_2 for values from (1000) to (2000);
create trigger parted_trigger after update of b on parted_trigger   for each row execute procedure trigger_notice_ab();
CREATE TABLE x (x TEXT, x INT) WITH (PARTITIONED_BY=RANGE(LENGTH(x)));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (1) TO (4);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (4) TO (8);
alter table parted_trigger attach partition parted_trigger_3 for values from (2000) to (3000);
INSERT INTO x VALUES (0, 'a'), (1000, 'c'), (2000, 'e'), (2001, 'eeee');
UPDATE x SET x = x + 2;
/* no notices here */ UPDATE x SET x = x || 'b';
/* all triggers should fire */ DROP TABLE x;
DROP FUNCTION x;
/* Make sure we don't end up with unnecessary copies of triggers, when */ /* cloning them. */ CREATE TABLE x (x INT) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (0) TO (1000);
alter table trg_clone add constraint uniq unique (a) deferrable;
CREATE TABLE x PARTITION OF x FOR VALUES FROM (1000) TO (2000);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (2000) TO (3000) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (2000) TO (2100);
SELECT CAST(x AS REGCLASS), COUNT(*) FROM x WHERE CAST(x AS REGCLASS) IN ('trg_clone', 'trg_clone1', 'trg_clone2', 'trg_clone3', 'trg_clone_3_3') GROUP BY CAST(x AS REGCLASS) ORDER BY CAST(x AS REGCLASS) NULLS LAST;
DROP TABLE x;
/* Test the interaction between ALTER TABLE .. DISABLE TRIGGER and */ /* both kinds of inheritance.  Historically, legacy inheritance has */ /* not recursed to children, so that behavior is preserved. */ CREATE TABLE x (x INT);
CREATE TABLE x INHERITS (x);
create trigger tg after insert on parent   for each row execute function trig_nothing();
create trigger tg after insert on child1   for each row execute function trig_nothing();
alter table parent disable trigger tg;
SELECT CAST(x AS REGCLASS), x, x FROM x WHERE x IN (CAST('parent' AS REGCLASS), CAST('child1' AS REGCLASS)) ORDER BY CAST(CAST(x AS REGCLASS) AS TEXT) NULLS LAST;
alter table only parent enable always trigger tg;
SELECT CAST(x AS REGCLASS), x, x FROM x WHERE x IN (CAST('parent' AS REGCLASS), CAST('child1' AS REGCLASS)) ORDER BY CAST(CAST(x AS REGCLASS) AS TEXT) NULLS LAST;
CREATE TABLE x (x INT) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN (1);
create trigger tg after insert on parent   for each row execute procedure trig_nothing();
create trigger tg_stmt after insert on parent   for statement execute procedure trig_nothing();
SELECT CAST(x AS REGCLASS), x, x FROM x WHERE x IN (CAST('parent' AS REGCLASS), CAST('child1' AS REGCLASS)) ORDER BY CAST(CAST(x AS REGCLASS) AS TEXT) NULLS LAST, x NULLS LAST;
alter table only parent enable always trigger tg;
/* no recursion because ONLY */ alter table parent enable always trigger tg_stmt;
/* no recursion because statement trigger */ SELECT CAST(x AS REGCLASS), x, x FROM x WHERE x IN (CAST('parent' AS REGCLASS), CAST('child1' AS REGCLASS)) ORDER BY CAST(CAST(x AS REGCLASS) AS TEXT) NULLS LAST, x NULLS LAST;
/* The following is a no-op for the parent trigger but not so */ /* for the child trigger, so recursion should be applied. */ alter table parent enable always trigger tg;
SELECT CAST(x AS REGCLASS), x, x FROM x WHERE x IN (CAST('parent' AS REGCLASS), CAST('child1' AS REGCLASS)) ORDER BY CAST(CAST(x AS REGCLASS) AS TEXT) NULLS LAST, x NULLS LAST;
/* This variant malfunctioned in some releases. */ alter table parent disable trigger user;
SELECT CAST(x AS REGCLASS), x, x FROM x WHERE x IN (CAST('parent' AS REGCLASS), CAST('child1' AS REGCLASS)) ORDER BY CAST(CAST(x AS REGCLASS) AS TEXT) NULLS LAST, x NULLS LAST;
/* Check processing of foreign key triggers */ CREATE TABLE x (x INT PRIMARY KEY, x INT REFERENCES x) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN (1);
SELECT CAST(x AS REGCLASS), RTRIM(x, '0123456789') AS x, CAST(x AS REGPROC), x FROM x WHERE x IN (CAST('parent' AS REGCLASS), CAST('child1' AS REGCLASS)) ORDER BY CAST(CAST(x AS REGCLASS) AS TEXT) NULLS LAST, x NULLS LAST;
alter table parent disable trigger all;
SELECT CAST(x AS REGCLASS), RTRIM(x, '0123456789') AS x, CAST(x AS REGPROC), x FROM x WHERE x IN (CAST('parent' AS REGCLASS), CAST('child1' AS REGCLASS)) ORDER BY CAST(CAST(x AS REGCLASS) AS TEXT) NULLS LAST, x NULLS LAST;
/* Verify that firing state propagates correctly on creation, too */ CREATE TABLE x (x INT) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (1) TO (10);
CREATE TRIGGER tg AFTER INSERT ON trgfire FOR EACH ROW EXECUTE FUNCTION tgf();
INSERT INTO x VALUES (1);
ALTER TABLE trgfire DISABLE TRIGGER tg;
INSERT INTO x VALUES (1);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (10) TO (20);
INSERT INTO x VALUES (11);
CREATE TABLE x (LIKE x);
ALTER TABLE trgfire ATTACH PARTITION trgfire3 FOR VALUES FROM (20) TO (30);
INSERT INTO x VALUES (21);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (30) TO (40) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN (30);
INSERT INTO x VALUES (30);
CREATE TABLE x (LIKE x) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN (40);
ALTER TABLE trgfire ATTACH PARTITION trgfire5 FOR VALUES FROM (40) TO (50);
INSERT INTO x VALUES (40);
SELECT CAST(x AS REGCLASS), x FROM x WHERE CAST(x AS REGCLASS) IN (SELECT x FROM x WHERE x LIKE 'trgfire%') ORDER BY CAST(CAST(x AS REGCLASS) AS TEXT) NULLS LAST;
ALTER TABLE trgfire ENABLE TRIGGER tg;
INSERT INTO x VALUES (1);
INSERT INTO x VALUES (11);
INSERT INTO x VALUES (21);
INSERT INTO x VALUES (30);
INSERT INTO x VALUES (40);
DROP TABLE x;
DROP FUNCTION x;
x AS x;
COMMIT;
x AS x;
COMMIT;
x AS x;
COMMIT;
/* Verify behavior of statement triggers on partition hierarchy with */ /* transition tables.  Tuples should appear to each trigger in the */ /* format of the relation the trigger is attached to. */ /* set up a partition hierarchy with some different TupleDescriptors */ CREATE TABLE x (x TEXT, x INT) WITH (PARTITIONED_BY=LIST(x));
/* a child matching parent */ CREATE TABLE x PARTITION OF x FOR VALUES IN ('AAA');
/* a child with a dropped column */ CREATE TABLE x (x INT, x TEXT, x INT);
ALTER TABLE x DROP COLUMN x;
alter table parent attach partition child2 for values in ('BBB');
/* a child with a different column order */ CREATE TABLE x (x INT, x TEXT);
alter table parent attach partition child3 for values in ('CCC');
create trigger parent_insert_trig   after insert on parent referencing new table as new_table   for each statement execute procedure dump_insert();
create trigger parent_update_trig   after update on parent referencing old table as old_table new table as new_table   for each statement execute procedure dump_update();
create trigger parent_delete_trig   after delete on parent referencing old table as old_table   for each statement execute procedure dump_delete();
create trigger child1_insert_trig   after insert on child1 referencing new table as new_table   for each statement execute procedure dump_insert();
create trigger child1_update_trig   after update on child1 referencing old table as old_table new table as new_table   for each statement execute procedure dump_update();
create trigger child1_delete_trig   after delete on child1 referencing old table as old_table   for each statement execute procedure dump_delete();
create trigger child2_insert_trig   after insert on child2 referencing new table as new_table   for each statement execute procedure dump_insert();
create trigger child2_update_trig   after update on child2 referencing old table as old_table new table as new_table   for each statement execute procedure dump_update();
create trigger child2_delete_trig   after delete on child2 referencing old table as old_table   for each statement execute procedure dump_delete();
create trigger child3_insert_trig   after insert on child3 referencing new table as new_table   for each statement execute procedure dump_insert();
create trigger child3_update_trig   after update on child3 referencing old table as old_table new table as new_table   for each statement execute procedure dump_update();
create trigger child3_delete_trig   after delete on child3 referencing old table as old_table   for each statement execute procedure dump_delete();
SELECT x, x, x, x, x, x, x, x, x, x FROM x.x WHERE x IN ('parent', 'child1', 'child2', 'child3') ORDER BY x COLLATE "x" NULLS LAST, 2 NULLS LAST;
/* insert directly into children sees respective child-format tuples */ INSERT INTO x VALUES ('AAA', 42);
INSERT INTO x VALUES ('BBB', 42);
INSERT INTO x VALUES (42, 'CCC');
/* update via parent sees parent-format tuples */ UPDATE x SET x = x + 1;
/* delete via parent sees parent-format tuples */ DELETE FROM x;
/* insert into parent sees parent-format tuples */ INSERT INTO x VALUES ('AAA', 42);
INSERT INTO x VALUES ('BBB', 42);
INSERT INTO x VALUES ('CCC', 42);
/* delete from children sees respective child-format tuples */ DELETE FROM x;
DELETE FROM x;
DELETE FROM x;
COPY INTO x (x, x) FROM x /* copy into parent sees parent-format tuples */;
drop trigger child1_update_trig on child1;
drop trigger child1_delete_trig on child1;
drop trigger child2_insert_trig on child2;
drop trigger child2_update_trig on child2;
drop trigger child2_delete_trig on child2;
drop trigger child3_insert_trig on child3;
drop trigger child3_update_trig on child3;
drop trigger child3_delete_trig on child3;
DELETE FROM x;
COPY INTO x (x, x) FROM x /* copy into parent sees tuples collected from children even if there */ /* is no transition-table trigger on the children */;
x AS x;
COMMIT;
create trigger intercept_insert_child3   before insert on child3   for each row execute procedure intercept_insert();
/* insert, parent trigger sees post-modification parent-format tuple */ INSERT INTO x VALUES ('AAA', 42), ('BBB', 42), ('CCC', 66);
COPY INTO x (x, x) FROM x /* copy, parent trigger sees post-modification parent-format tuple */;
DROP FUNCTION x;
/* Verify prohibition of row triggers with transition triggers on */ /* partitions */ CREATE TABLE x (x TEXT, x INT) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN ('AAA');
/* adding row trigger with transition table fails */ create trigger child_row_trig   after insert on child referencing new table as new_table   for each row execute procedure dump_insert();
/* detaching it first works */ alter table parent detach partition child;
create trigger child_row_trig   after insert on child referencing new table as new_table   for each row execute procedure dump_insert();
/* but now we're not allowed to reattach it */ alter table parent attach partition child for values in ('AAA');
/* drop the trigger, and now we're allowed to attach it again */ drop trigger child_row_trig on child;
alter table parent attach partition child for values in ('AAA');
x AS x;
COMMIT;
x AS x;
COMMIT;
CREATE TABLE x (x TEXT) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN ('AAA1', 'AAA2');
CREATE TABLE x PARTITION OF x FOR VALUES IN ('BBB1', 'BBB2');
create trigger trans_tab_parent_update_trig   after update on trans_tab_parent referencing old table as old_table   for each statement execute procedure dump_update_old();
create trigger trans_tab_parent_insert_trig   after insert on trans_tab_parent referencing new table as new_table   for each statement execute procedure dump_insert();
create trigger trans_tab_parent_delete_trig   after delete on trans_tab_parent referencing old table as old_table   for each statement execute procedure dump_delete();
INSERT INTO x VALUES ('AAA1'), ('BBB1');
/* should not trigger access to new table when moving across partitions. */ UPDATE x SET x = 'BBB2' WHERE x = 'AAA1';
drop trigger trans_tab_parent_update_trig on trans_tab_parent;
create trigger trans_tab_parent_update_trig   after update on trans_tab_parent referencing new table as new_table   for each statement execute procedure dump_update_new();
/* should not trigger access to old table when moving across partitions. */ UPDATE x SET x = 'AAA2' WHERE x = 'BBB1';
DELETE FROM x;
/* a child matching parent */ CREATE TABLE x INHERITS (x);
/* a child with a different column order */ CREATE TABLE x (x INT, x TEXT);
alter table child2 inherit parent;
/* a child with an extra column */ CREATE TABLE x (x TEXT) INHERITS (x);
create trigger parent_insert_trig   after insert on parent referencing new table as new_table   for each statement execute procedure dump_insert();
create trigger parent_update_trig   after update on parent referencing old table as old_table new table as new_table   for each statement execute procedure dump_update();
create trigger parent_delete_trig   after delete on parent referencing old table as old_table   for each statement execute procedure dump_delete();
create trigger child1_insert_trig   after insert on child1 referencing new table as new_table   for each statement execute procedure dump_insert();
create trigger child1_update_trig   after update on child1 referencing old table as old_table new table as new_table   for each statement execute procedure dump_update();
create trigger child1_delete_trig   after delete on child1 referencing old table as old_table   for each statement execute procedure dump_delete();
create trigger child2_insert_trig   after insert on child2 referencing new table as new_table   for each statement execute procedure dump_insert();
create trigger child2_update_trig   after update on child2 referencing old table as old_table new table as new_table   for each statement execute procedure dump_update();
create trigger child2_delete_trig   after delete on child2 referencing old table as old_table   for each statement execute procedure dump_delete();
create trigger child3_insert_trig   after insert on child3 referencing new table as new_table   for each statement execute procedure dump_insert();
create trigger child3_update_trig   after update on child3 referencing old table as old_table new table as new_table   for each statement execute procedure dump_update();
create trigger child3_delete_trig   after delete on child3 referencing old table as old_table   for each statement execute procedure dump_delete();
/* insert directly into children sees respective child-format tuples */ INSERT INTO x VALUES ('AAA', 42);
INSERT INTO x VALUES (42, 'BBB');
INSERT INTO x VALUES ('CCC', 42, 'foo');
/* update via parent sees parent-format tuples */ UPDATE x SET x = x + 1;
/* delete via parent sees parent-format tuples */ DELETE FROM x;
/* reinsert values into children for next test... */ INSERT INTO x VALUES ('AAA', 42);
INSERT INTO x VALUES (42, 'BBB');
INSERT INTO x VALUES ('CCC', 42, 'foo');
/* delete from children sees respective child-format tuples */ DELETE FROM x;
DELETE FROM x;
DELETE FROM x;
COPY INTO x (x, x) FROM x /* copy into parent sees parent-format tuples (no rerouting, so these */ /* are really inserted into the parent) */;
COPY INTO x (x, x) FROM x;
drop trigger child1_update_trig on child1;
drop trigger child1_delete_trig on child1;
drop trigger child2_insert_trig on child2;
drop trigger child2_update_trig on child2;
drop trigger child2_delete_trig on child2;
drop trigger child3_insert_trig on child3;
drop trigger child3_update_trig on child3;
drop trigger child3_delete_trig on child3;
DELETE FROM x;
/* Verify prohibition of row triggers with transition triggers on */ /* inheritance children */ CREATE TABLE x (x TEXT, x INT);
CREATE TABLE x INHERITS (x);
/* adding row trigger with transition table fails */ create trigger child_row_trig   after insert on child referencing new table as new_table   for each row execute procedure dump_insert();
/* disinheriting it first works */ alter table child no inherit parent;
create trigger child_row_trig   after insert on child referencing new table as new_table   for each row execute procedure dump_insert();
/* but now we're not allowed to make it inherit anymore */ alter table child inherit parent;
/* drop the trigger, and now we're allowed to make it inherit again */ drop trigger child_row_trig on child;
alter table child inherit parent;
/* Verify behavior of queries with wCTEs, where multiple transition */ /* tuplestores can be active at the same time because there are */ /* multiple DML statements that might fire triggers with transition */ /* tables */ CREATE TABLE x (x INT);
CREATE TABLE x (x TEXT);
create trigger table1_trig   after insert on table1 referencing new table as new_table   for each statement execute procedure dump_insert();
create trigger table2_trig   after insert on table2 referencing new table as new_table   for each statement execute procedure dump_insert();
WITH x AS (INSERT INTO x VALUES (42)) INSERT INTO x VALUES ('hello world');
WITH x AS (INSERT INTO x VALUES (43)) INSERT INTO x VALUES (44);
SELECT * FROM x;
SELECT * FROM x;
DROP TABLE x;
DROP TABLE x;
/* Verify behavior of INSERT ... ON CONFLICT DO UPDATE ... with */ /* transition tables. */ CREATE TABLE x (x INT PRIMARY KEY, x TEXT);
create trigger my_table_insert_trig   after insert on my_table referencing new table as new_table   for each statement execute procedure dump_insert();
create trigger my_table_update_trig   after update on my_table referencing old table as old_table new table as new_table   for each statement execute procedure dump_update();
/* inserts only */ INSERT INTO x VALUES (1, 'AAA'), (2, 'BBB') ON CONFLICT(x) DO UPDATE SET x = x.x || ':' || x.x;
/* mixture of inserts and updates */ INSERT INTO x VALUES (1, 'AAA'), (2, 'BBB'), (3, 'CCC'), (4, 'DDD') ON CONFLICT(x) DO UPDATE SET x = x.x || ':' || x.x;
/* updates only */ INSERT INTO x VALUES (3, 'CCC'), (4, 'DDD') ON CONFLICT(x) DO UPDATE SET x = x.x || ':' || x.x;
/* now using a partitioned table */ CREATE TABLE x (x INT PRIMARY KEY, x TEXT) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN (1);
CREATE TABLE x PARTITION OF x FOR VALUES IN (2);
CREATE TABLE x PARTITION OF x FOR VALUES IN (3);
CREATE TABLE x PARTITION OF x FOR VALUES IN (4);
create trigger iocdu_tt_parted_insert_trig   after insert on iocdu_tt_parted referencing new table as new_table   for each statement execute procedure dump_insert();
create trigger iocdu_tt_parted_update_trig   after update on iocdu_tt_parted referencing old table as old_table new table as new_table   for each statement execute procedure dump_update();
/* inserts only */ INSERT INTO x VALUES (1, 'AAA'), (2, 'BBB') ON CONFLICT(x) DO UPDATE SET x = x.x || ':' || x.x;
/* mixture of inserts and updates */ INSERT INTO x VALUES (1, 'AAA'), (2, 'BBB'), (3, 'CCC'), (4, 'DDD') ON CONFLICT(x) DO UPDATE SET x = x.x || ':' || x.x;
/* updates only */ INSERT INTO x VALUES (3, 'CCC'), (4, 'DDD') ON CONFLICT(x) DO UPDATE SET x = x.x || ':' || x.x;
DROP TABLE x;
/* Verify that you can't create a trigger with transition tables for */ /* more than one event. */ create trigger my_table_multievent_trig   after insert or update on my_table referencing new table as new_table   for each statement execute procedure dump_insert();
/* Verify that you can't create a trigger with transition tables with */ /* a column list. */ create trigger my_table_col_update_trig   after update of b on my_table referencing new table as new_table   for each statement execute procedure dump_insert();
DROP TABLE x;
/* Verify that transition tables can't be used in, eg, a view. */ CREATE TABLE x (x INT);
x AS x;
create trigger make_bogus_matview   after insert on my_table   referencing new table as new_table   for each statement execute function make_bogus_matview();
INSERT INTO x VALUES (42);
/* error */ DROP TABLE x;
DROP FUNCTION x;
/* Test firing of triggers with transition tables by foreign key cascades */ CREATE TABLE x (x INT PRIMARY KEY, x TEXT);
CREATE TABLE x (x INT, x TEXT, FOREIGN KEY (x) REFERENCES x ON update CASCADE ON delete CASCADE);
create trigger trig_table_before_trig   before insert or update or delete on trig_table   for each statement execute procedure trigger_func('trig_table');
create trigger trig_table_insert_trig   after insert on trig_table referencing new table as new_table   for each statement execute procedure dump_insert();
create trigger trig_table_update_trig   after update on trig_table referencing old table as old_table new table as new_table   for each statement execute procedure dump_update();
create trigger trig_table_delete_trig   after delete on trig_table referencing old table as old_table   for each statement execute procedure dump_delete();
INSERT INTO x VALUES (1, 'one'), (2, 'two'), (3, 'three');
INSERT INTO x VALUES (1, 'one a'), (1, 'one b'), (2, 'two a'), (2, 'two b'), (3, 'three a'), (3, 'three b');
UPDATE x SET x = 11 WHERE x = 'one';
SELECT * FROM x;
DELETE FROM x WHERE LENGTH(x) = 3;
SELECT * FROM x;
/* Test that we can drop a not-yet-fired deferred trigger */ CREATE TABLE x (x INT PRIMARY KEY);
CREATE TABLE x (x INT REFERENCES x INITIALLY DEFERRED);
BEGIN;
INSERT INTO x VALUES (1);
DROP TABLE x CASCADE;
COMMIT;
DROP TABLE x;
/* self-referential FKs are even more fun */ CREATE TABLE x (x INT PRIMARY KEY, x INT REFERENCES x (x) ON delete CASCADE);
create trigger self_ref_before_trig   before delete on self_ref   for each statement execute procedure trigger_func('self_ref');
create trigger self_ref_r_trig   after delete on self_ref referencing old table as old_table   for each row execute procedure dump_delete();
create trigger self_ref_s_trig   after delete on self_ref referencing old table as old_table   for each statement execute procedure dump_delete();
INSERT INTO x VALUES (1, NULL), (2, 1), (3, 2);
DELETE FROM x WHERE x = 1;
/* without AR trigger, cascaded deletes all end up in one transition table */ drop trigger self_ref_r_trig on self_ref;
INSERT INTO x VALUES (1, NULL), (2, 1), (3, 2), (4, 3);
DELETE FROM x WHERE x = 1;
DROP TABLE x;
/* test transition tables with MERGE */ CREATE TABLE x (x INT PRIMARY KEY, x TEXT);
create trigger merge_target_table_insert_trig   after insert on merge_target_table referencing new table as new_table   for each statement execute procedure dump_insert();
create trigger merge_target_table_update_trig   after update on merge_target_table referencing old table as old_table new table as new_table   for each statement execute procedure dump_update();
create trigger merge_target_table_delete_trig   after delete on merge_target_table referencing old table as old_table   for each statement execute procedure dump_delete();
CREATE TABLE x (x INT, x TEXT);
INSERT INTO x VALUES (1, 'initial1'), (2, 'initial2'), (3, 'initial3'), (4, 'initial4');
MERGE INTO x AS x USING x AS x ON x.x = x.x WHEN NOT MATCHED THEN INSERT VALUES (x, x);
MERGE INTO x AS x USING x AS x ON x.x = x.x WHEN MATCHED AND x.x <= 2 THEN UPDATE SET x = x.x || ' updated by merge' WHEN MATCHED AND x.x > 2 THEN delete WHEN NOT MATCHED THEN INSERT VALUES (x, x);
MERGE INTO x AS x USING x AS x ON x.x = x.x WHEN MATCHED AND x.x <= 2 THEN UPDATE SET x = x.x || ' updated again by merge' WHEN MATCHED AND x.x > 2 THEN delete WHEN NOT MATCHED THEN INSERT VALUES (x, x);
/* cleanup */ DROP FUNCTION x;
DROP FUNCTION x;
DROP FUNCTION x;
/* Tests for CREATE OR REPLACE TRIGGER */ CREATE TABLE x (x INT);
x AS x;
COMMIT;
x AS x;
COMMIT;
create trigger my_trig   after insert on my_table   for each row execute procedure funcA();
create trigger my_trig   before insert on my_table   for each row execute procedure funcB();
/* should fail */ INSERT INTO x VALUES (1);
create or replace trigger my_trig   before insert on my_table   for each row execute procedure funcB();
/* OK */ INSERT INTO x VALUES (2);
x AS x /* this insert should become a no-op */;
DROP TABLE x;
/* test CREATE OR REPLACE TRIGGER on partition table */ CREATE TABLE x (x INT) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (0) TO (1000) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (0) TO (100);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (1000) TO (2000);
CREATE TABLE x PARTITION OF x DEFAULT;
/* test that trigger can be replaced by another one */ /* at the same level of partition table */ create or replace trigger my_trig   after insert on parted_trig   for each row execute procedure funcA();
INSERT INTO x (x) VALUES (50);
create or replace trigger my_trig   after insert on parted_trig   for each row execute procedure funcB();
INSERT INTO x (x) VALUES (50);
/* test that child trigger cannot be replaced directly */ create or replace trigger my_trig   after insert on parted_trig   for each row execute procedure funcA();
INSERT INTO x (x) VALUES (50);
create or replace trigger my_trig   after insert on parted_trig_1   for each row execute procedure funcB();
/* should fail */ INSERT INTO x (x) VALUES (50);
drop trigger my_trig on parted_trig;
INSERT INTO x (x) VALUES (50);
/* test that user trigger can be overwritten by one defined at upper level */ create trigger my_trig   after insert on parted_trig_1   for each row execute procedure funcA();
INSERT INTO x (x) VALUES (50);
create trigger my_trig   after insert on parted_trig   for each row execute procedure funcB();
/* should fail */ INSERT INTO x (x) VALUES (50);
create or replace trigger my_trig   after insert on parted_trig   for each row execute procedure funcB();
INSERT INTO x (x) VALUES (50);
/* cleanup */ DROP TABLE x;
DROP FUNCTION x;
DROP FUNCTION x;
/* Leave around some objects for other tests */ CREATE TABLE x (x INT PRIMARY KEY) WITH (PARTITIONED_BY=LIST(x));
create trigger aft_row after insert or update on trigger_parted   for each row execute function trigger_parted_trigfunc();
CREATE TABLE x PARTITION OF x FOR VALUES IN (1) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN (1);
CREATE TABLE x PARTITION OF x FOR VALUES IN (2) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN (2);
alter table only trigger_parted_p2 disable trigger aft_row;
alter table trigger_parted_p2_2 enable always trigger aft_row;
/* verify transition table conversion slot's lifetime */ /* https://postgr.es/m/39a71864-b120-5a5c-8cc5-c632b6f16761@amazon.com */ CREATE TABLE x (x TEXT PRIMARY KEY);
CREATE TABLE x (x TEXT PRIMARY KEY, FOREIGN KEY (x) REFERENCES x (x) ON delete CASCADE ON update CASCADE);
ALTER TABLE x ADD COLUMN x TEXT NOT NULL DEFAULT 'tutu';
INSERT INTO x (x) VALUES ('1');
INSERT INTO x (x) VALUES ('1');
INSERT INTO x (x) VALUES ('3');
INSERT INTO x (x) VALUES ('3');
x AS x;
COMMIT;
x AS x;
COMMIT;
create trigger but_trigger after update on convslot_test_child referencing new table as new_table for each statement execute function convslot_trig2();
UPDATE x SET x = x || '1';
x AS x;
COMMIT;
create trigger but_trigger2 after update on convslot_test_child referencing old table as old_table new table as new_table for each statement execute function convslot_trig3();
UPDATE x SET x = x || '1';
create trigger bdt_trigger after delete on convslot_test_child referencing old table as old_table for each statement execute function convslot_trig1();
DELETE FROM x;
DROP FUNCTION x;
DROP FUNCTION x;
DROP FUNCTION x;
/* we don't see any ill effects unless trigger tuple requires mapping */ CREATE TABLE x (x INT PRIMARY KEY, x INT) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x (x INT, x INT NOT NULL);
alter table convslot_test_parent   attach partition convslot_test_part for values from (1) to (1000);
create trigger convslot_test_parent_update     after update on convslot_test_parent     referencing old table as old_rows new table as new_rows     for each statement execute procedure convslot_trig4();
INSERT INTO x (x, x) VALUES (1, 2);
BEGIN;
x AS x;
UPDATE x SET x = 3;
ROLLBACK TO x /* error expected */;
ROLLBACK;
DROP TABLE x;
DROP FUNCTION x;
/* Test trigger renaming on partitioned tables */ CREATE TABLE x (x INT, PRIMARY KEY (x NULLS LAST)) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (1) TO (10) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (1) TO (5);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (6) TO (10);
COMMIT;
create trigger a after insert on grandparent for each row execute procedure f();
alter trigger a on grandparent rename to b;
SELECT CAST(x AS REGCLASS), x, (SELECT x FROM x AS x WHERE x.x = x.x) AS x FROM x WHERE x IN (SELECT x FROM x) ORDER BY x NULLS LAST, CAST(CAST(x AS REGCLASS) AS TEXT) COLLATE "x" NULLS LAST;
alter trigger a on only grandparent rename to b;
/* ONLY not supported */ alter trigger b on middle rename to c;
/* can't rename trigger on partition */ create trigger c after insert on middle for each row execute procedure f();
alter trigger b on grandparent rename to c;
/* Rename cascading does not affect statement triggers */ create trigger p after insert on grandparent for each statement execute function f();
create trigger p after insert on middle for each statement execute function f();
alter trigger p on grandparent rename to q;
SELECT CAST(x AS REGCLASS), x, (SELECT x FROM x AS x WHERE x.x = x.x) AS x FROM x WHERE x IN (SELECT x FROM x) ORDER BY x NULLS LAST, CAST(CAST(x AS REGCLASS) AS TEXT) COLLATE "x" NULLS LAST;
DROP TABLE x;
/* Trigger renaming does not recurse on legacy inheritance */ CREATE TABLE x (x INT);
CREATE TABLE x INHERITS (x);
create trigger parenttrig after insert on parent for each row execute procedure f();
create trigger parenttrig after insert on child for each row execute procedure f();
alter trigger parenttrig on parent rename to anothertrig;
DROP FUNCTION x;
/* Test who runs deferred trigger functions */ /* setup */ create role regress_groot;
create role regress_outis;
x AS x;
COMMIT;
alter function whoami() owner to regress_outis;
CREATE TABLE x (x INT);
GRANT INSERT ON x TO x;
create constraint trigger whoami after insert on defer_trig   deferrable initially deferred   for each row   execute function whoami();
/* deferred triggers must run as the user that queued the trigger */ BEGIN;
set role regress_groot;
INSERT INTO x VALUES (1);
RESET role;
set role regress_outis;
INSERT INTO x VALUES (2);
RESET role;
COMMIT;
/* security definer functions override the user who queued the trigger */ alter function whoami() security definer;
BEGIN;
set role regress_groot;
INSERT INTO x VALUES (3);
RESET role;
COMMIT;
alter function whoami() security invoker;
x AS x;
COMMIT;
BEGIN;
set role regress_groot;
INSERT INTO x VALUES (4);
RESET role;
COMMIT;
/* error expected */ SELECT CURRENT_USER() = x;
/* clean up */ DROP TABLE x;
DROP FUNCTION x;
drop role regress_outis;
drop role regress_groot;
/* Test basic TRUNCATE functionality. */ CREATE TABLE x (x INT PRIMARY KEY);
INSERT INTO x VALUES (1);
INSERT INTO x VALUES (2);
SELECT * FROM x;
/* Roll truncate back */ BEGIN;
TRUNCATE TABLE x;
ROLLBACK;
SELECT * FROM x;
/* Commit the truncate this time */ BEGIN;
TRUNCATE TABLE x;
COMMIT;
SELECT * FROM x;
/* Test foreign-key checks */ CREATE TABLE x (x INT REFERENCES x);
CREATE TABLE x (x SERIAL PRIMARY KEY);
CREATE TABLE x (x INT REFERENCES x);
CREATE TABLE x (x INT REFERENCES x, x INT REFERENCES x);
TRUNCATE TABLE x;
TRUNCATE TABLE x, x /* fail */;
TRUNCATE TABLE x, x, x /* fail */;
TRUNCATE TABLE x, x /* ok */;
TRUNCATE TABLE x /* fail */;
TRUNCATE TABLE x, x /* fail */;
TRUNCATE TABLE x, x, x /* fail */;
TRUNCATE TABLE x, x, x, x /* ok */;
TRUNCATE TABLE x, x, x, x, x /* fail */;
TRUNCATE TABLE x RESTRICT /* ok */;
TRUNCATE TABLE x CASCADE /* fail */;
ALTER TABLE x ADD FOREIGN KEY (x) REFERENCES x /* ok */ /* circular references */;
/* Add some data to verify that truncating actually works ... */ INSERT INTO x VALUES (1);
INSERT INTO x VALUES (1);
INSERT INTO x VALUES (1);
INSERT INTO x VALUES (1);
INSERT INTO x VALUES (1, 1);
TRUNCATE TABLE x;
TRUNCATE TABLE x, x;
TRUNCATE TABLE x, x, x;
TRUNCATE TABLE x, x, x, x;
TRUNCATE TABLE x, x, x, x, x;
/* Verify that truncating did actually work */ SELECT * FROM x UNION ALL SELECT * FROM x UNION ALL SELECT * FROM x UNION ALL SELECT * FROM x;
SELECT * FROM x;
/* Add data again to test TRUNCATE ... CASCADE */ INSERT INTO x VALUES (1);
INSERT INTO x VALUES (1);
INSERT INTO x VALUES (1);
INSERT INTO x VALUES (1);
INSERT INTO x VALUES (1, 1);
TRUNCATE TABLE x CASCADE;
/* ok */ SELECT * FROM x UNION ALL SELECT * FROM x UNION ALL SELECT * FROM x UNION ALL SELECT * FROM x;
SELECT * FROM x;
/* Test TRUNCATE with inheritance */ CREATE TABLE x (x INT PRIMARY KEY);
INSERT INTO x VALUES (1);
INSERT INTO x VALUES (2);
CREATE TABLE x (x TEXT) INHERITS (x);
INSERT INTO x VALUES (3, 'three');
CREATE TABLE x (x INT) INHERITS (x);
INSERT INTO x VALUES (4, 444);
CREATE TABLE x (x TEXT) INHERITS (x);
INSERT INTO x VALUES (5, 'five', 'FIVE');
BEGIN;
SELECT * FROM x;
TRUNCATE TABLE x;
SELECT * FROM x;
ROLLBACK;
BEGIN;
SELECT * FROM x;
TRUNCATE TABLE ONLY x;
SELECT * FROM x;
ROLLBACK;
BEGIN;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
TRUNCATE TABLE ONLY x, ONLY x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
ROLLBACK;
BEGIN;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
TRUNCATE TABLE ONLY x, x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
ROLLBACK;
DROP TABLE x CASCADE;
/* Test ON TRUNCATE triggers */ CREATE TABLE x (x INT, x TEXT, x TEXT);
CREATE TABLE x (x TEXT, x TEXT, x TEXT, x TEXT, x NAME, x BIGINT);
BEGIN execute 'select count(*) from ' || quote_ident(tg_table_name) into c;
INSERT INTO x VALUES (x, x, x, x[-1], x, x);
x AS x;
COMMIT;
/* basic before trigger */ INSERT INTO x VALUES (1, 'foo', 'bar'), (2, 'baz', 'quux');
CREATE TRIGGER t BEFORE TRUNCATE ON trunc_trigger_test FOR EACH STATEMENT EXECUTE PROCEDURE trunctrigger('before trigger truncate');
SELECT COUNT(*) AS "x" FROM x;
SELECT * FROM x;
TRUNCATE TABLE x;
SELECT COUNT(*) AS "x" FROM x;
SELECT * FROM x;
DROP TRIGGER t ON trunc_trigger_test;
TRUNCATE TABLE x;
/* same test with an after trigger */ INSERT INTO x VALUES (1, 'foo', 'bar'), (2, 'baz', 'quux');
CREATE TRIGGER tt AFTER TRUNCATE ON trunc_trigger_test FOR EACH STATEMENT EXECUTE PROCEDURE trunctrigger('after trigger truncate');
SELECT COUNT(*) AS "x" FROM x;
SELECT * FROM x;
TRUNCATE TABLE x;
SELECT COUNT(*) AS "x" FROM x;
SELECT * FROM x;
DROP TABLE x;
DROP TABLE x;
DROP FUNCTION x;
/* test TRUNCATE ... RESTART IDENTITY */ CREATE SEQUENCE x START WITH 33;
CREATE TABLE x (x SERIAL, x INT DEFAULT NEXTVAL('truncate_a_id1'));
ALTER SEQUENCE truncate_a_id1 OWNED BY truncate_a.id1;
SELECT * FROM x;
TRUNCATE TABLE x;
SELECT * FROM x;
TRUNCATE TABLE x RESTART IDENTITY;
SELECT * FROM x;
CREATE TABLE x (x INT GENERATED ALWAYS AS IDENTITY (START WITH 44));
SELECT * FROM x;
TRUNCATE TABLE x;
SELECT * FROM x;
TRUNCATE TABLE x RESTART IDENTITY;
SELECT * FROM x;
/* check rollback of a RESTART IDENTITY operation */ BEGIN;
TRUNCATE TABLE x RESTART IDENTITY;
SELECT * FROM x;
ROLLBACK;
SELECT * FROM x;
DROP TABLE x;
SELECT NEXTVAL('truncate_a_id1');
/* fail, seq should have been dropped */ /* partitioned table */ CREATE TABLE x (x INT, x CHAR) WITH (PARTITIONED_BY=LIST(x));
TRUNCATE TABLE ONLY x /* error, can't truncate a partitioned table */;
CREATE TABLE x PARTITION OF x FOR VALUES IN (1);
INSERT INTO x VALUES (1, 'a');
TRUNCATE TABLE ONLY x /* error, must truncate partitions */;
TRUNCATE TABLE x;
DROP TABLE x;
INSERT INTO x VALUES (1), (100), (150);
CREATE TABLE x (x INT PRIMARY KEY);
CREATE TABLE x (x INT REFERENCES x) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (0) TO (100);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (100) TO (200) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (100) TO (150);
CREATE TABLE x PARTITION OF x DEFAULT;
TRUNCATE TABLE x;
/* should fail */ SELECT TP_INS_DATA();
TRUNCATE TABLE x, x /* should truncate everything */;
SELECT * FROM x;
SELECT TP_INS_DATA();
TRUNCATE TABLE x CASCADE /* should truncate everything */;
SELECT * FROM x;
SELECT TP_INS_DATA();
TRUNCATE TABLE x /* should truncate all partitions */;
SELECT * FROM x;
/* test cascade when referencing a partitioned table */ CREATE TABLE x (x INT PRIMARY KEY) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (0) TO (10);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (10) TO (20) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (10) TO (12);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (12) TO (16);
CREATE TABLE x PARTITION OF x DEFAULT;
CREATE TABLE x PARTITION OF x FOR VALUES FROM (20) TO (30);
INSERT INTO x VALUES (0), (5), (10), (15), (20), (25);
/* truncate a partition cascading to a table */ CREATE TABLE x (x INT PRIMARY KEY, x INT REFERENCES x (x) ON DELETE CASCADE);
INSERT INTO x VALUES (10, 0), (50, 5), (100, 10), (150, 15);
TRUNCATE TABLE x CASCADE;
SELECT x FROM x;
DROP TABLE x;
/* truncate a partition cascading to a partitioned table */ CREATE TABLE x (x INT PRIMARY KEY, x INT REFERENCES x (x) ON DELETE CASCADE) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM (100) TO (200);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (200) TO (300);
INSERT INTO x VALUES (100, 10), (150, 15), (200, 20), (250, 25);
TRUNCATE TABLE x CASCADE;
SELECT x AS "x" FROM x;
SELECT x AS "x" FROM x ORDER BY x NULLS LAST;
/* Test text search dictionaries and configurations */ /* Test ISpell dictionary with ispell affix file */ CREATE TEXT SEARCH DICTIONARY ispell (                         Template=ispell,                         DictFile=ispell_sample,                         AffFile=ispell_sample );
SELECT TS_LEXIZE('ispell', 'skies');
SELECT TS_LEXIZE('ispell', 'bookings');
SELECT TS_LEXIZE('ispell', 'booking');
SELECT TS_LEXIZE('ispell', 'foot');
SELECT TS_LEXIZE('ispell', 'foots');
SELECT TS_LEXIZE('ispell', 'rebookings');
SELECT TS_LEXIZE('ispell', 'rebooking');
SELECT TS_LEXIZE('ispell', 'rebook');
SELECT TS_LEXIZE('ispell', 'unbookings');
SELECT TS_LEXIZE('ispell', 'unbooking');
SELECT TS_LEXIZE('ispell', 'unbook');
SELECT TS_LEXIZE('ispell', 'footklubber');
SELECT TS_LEXIZE('ispell', 'footballklubber');
SELECT TS_LEXIZE('ispell', 'ballyklubber');
SELECT TS_LEXIZE('ispell', 'footballyklubber');
/* Test ISpell dictionary with hunspell affix file */ CREATE TEXT SEARCH DICTIONARY hunspell (                         Template=ispell,                         DictFile=ispell_sample,                         AffFile=hunspell_sample );
SELECT TS_LEXIZE('hunspell', 'skies');
SELECT TS_LEXIZE('hunspell', 'bookings');
SELECT TS_LEXIZE('hunspell', 'booking');
SELECT TS_LEXIZE('hunspell', 'foot');
SELECT TS_LEXIZE('hunspell', 'foots');
SELECT TS_LEXIZE('hunspell', 'rebookings');
SELECT TS_LEXIZE('hunspell', 'rebooking');
SELECT TS_LEXIZE('hunspell', 'rebook');
SELECT TS_LEXIZE('hunspell', 'unbookings');
SELECT TS_LEXIZE('hunspell', 'unbooking');
SELECT TS_LEXIZE('hunspell', 'unbook');
SELECT TS_LEXIZE('hunspell', 'footklubber');
SELECT TS_LEXIZE('hunspell', 'footballklubber');
SELECT TS_LEXIZE('hunspell', 'ballyklubber');
SELECT TS_LEXIZE('hunspell', 'footballyklubber');
/* Test ISpell dictionary with hunspell affix file with FLAG long parameter */ CREATE TEXT SEARCH DICTIONARY hunspell_long (                         Template=ispell,                         DictFile=hunspell_sample_long,                         AffFile=hunspell_sample_long );
SELECT TS_LEXIZE('hunspell_long', 'skies');
SELECT TS_LEXIZE('hunspell_long', 'bookings');
SELECT TS_LEXIZE('hunspell_long', 'booking');
SELECT TS_LEXIZE('hunspell_long', 'foot');
SELECT TS_LEXIZE('hunspell_long', 'foots');
SELECT TS_LEXIZE('hunspell_long', 'rebookings');
SELECT TS_LEXIZE('hunspell_long', 'rebooking');
SELECT TS_LEXIZE('hunspell_long', 'rebook');
SELECT TS_LEXIZE('hunspell_long', 'unbookings');
SELECT TS_LEXIZE('hunspell_long', 'unbooking');
SELECT TS_LEXIZE('hunspell_long', 'unbook');
SELECT TS_LEXIZE('hunspell_long', 'booked');
SELECT TS_LEXIZE('hunspell_long', 'footklubber');
SELECT TS_LEXIZE('hunspell_long', 'footballklubber');
SELECT TS_LEXIZE('hunspell_long', 'ballyklubber');
SELECT TS_LEXIZE('hunspell_long', 'ballsklubber');
SELECT TS_LEXIZE('hunspell_long', 'footballyklubber');
SELECT TS_LEXIZE('hunspell_long', 'ex-machina');
/* Test ISpell dictionary with hunspell affix file with FLAG num parameter */ CREATE TEXT SEARCH DICTIONARY hunspell_num (                         Template=ispell,                         DictFile=hunspell_sample_num,                         AffFile=hunspell_sample_num );
SELECT TS_LEXIZE('hunspell_num', 'skies');
SELECT TS_LEXIZE('hunspell_num', 'sk');
SELECT TS_LEXIZE('hunspell_num', 'bookings');
SELECT TS_LEXIZE('hunspell_num', 'booking');
SELECT TS_LEXIZE('hunspell_num', 'foot');
SELECT TS_LEXIZE('hunspell_num', 'foots');
SELECT TS_LEXIZE('hunspell_num', 'rebookings');
SELECT TS_LEXIZE('hunspell_num', 'rebooking');
SELECT TS_LEXIZE('hunspell_num', 'rebook');
SELECT TS_LEXIZE('hunspell_num', 'unbookings');
SELECT TS_LEXIZE('hunspell_num', 'unbooking');
SELECT TS_LEXIZE('hunspell_num', 'unbook');
SELECT TS_LEXIZE('hunspell_num', 'booked');
SELECT TS_LEXIZE('hunspell_num', 'footklubber');
SELECT TS_LEXIZE('hunspell_num', 'footballklubber');
SELECT TS_LEXIZE('hunspell_num', 'ballyklubber');
SELECT TS_LEXIZE('hunspell_num', 'footballyklubber');
/* Test suitability of affix and dict files */ CREATE TEXT SEARCH DICTIONARY hunspell_err ( 						Template=ispell, 						DictFile=ispell_sample, 						AffFile=hunspell_sample_long );
CREATE TEXT SEARCH DICTIONARY hunspell_err ( 						Template=ispell, 						DictFile=ispell_sample, 						AffFile=hunspell_sample_num );
CREATE TEXT SEARCH DICTIONARY hunspell_invalid_1 ( 						Template=ispell, 						DictFile=hunspell_sample_long, 						AffFile=ispell_sample );
CREATE TEXT SEARCH DICTIONARY hunspell_invalid_2 ( 						Template=ispell, 						DictFile=hunspell_sample_long, 						AffFile=hunspell_sample_num );
CREATE TEXT SEARCH DICTIONARY hunspell_invalid_3 ( 						Template=ispell, 						DictFile=hunspell_sample_num, 						AffFile=ispell_sample );
CREATE TEXT SEARCH DICTIONARY hunspell_err ( 						Template=ispell, 						DictFile=hunspell_sample_num, 						AffFile=hunspell_sample_long );
/* Synonym dictionary */ CREATE TEXT SEARCH DICTIONARY synonym ( 						Template=synonym, 						Synonyms=synonym_sample );
SELECT TS_LEXIZE('synonym', 'PoStGrEs');
SELECT TS_LEXIZE('synonym', 'Gogle');
SELECT TS_LEXIZE('synonym', 'indices');
/* test altering boolean parameters */ SELECT x FROM x WHERE x = 'synonym';
ALTER TEXT SEARCH DICTIONARY synonym (CaseSensitive = 1);
SELECT TS_LEXIZE('synonym', 'PoStGrEs');
SELECT x FROM x WHERE x = 'synonym';
ALTER TEXT SEARCH DICTIONARY synonym (CaseSensitive = 2);
/* fail */ ALTER TEXT SEARCH DICTIONARY synonym (CaseSensitive = off);
SELECT TS_LEXIZE('synonym', 'PoStGrEs');
SELECT x FROM x WHERE x = 'synonym';
/* Create and simple test thesaurus dictionary */ /* More tests in configuration checks because ts_lexize() */ /* cannot pass more than one word to thesaurus. */ CREATE TEXT SEARCH DICTIONARY thesaurus (                         Template=thesaurus, 						DictFile=thesaurus_sample, 						Dictionary=english_stem );
SELECT TS_LEXIZE('thesaurus', 'one');
/* Test ispell dictionary in configuration */ CREATE TEXT SEARCH CONFIGURATION ispell_tst ( 						COPY=english );
ALTER TEXT SEARCH CONFIGURATION ispell_tst ALTER MAPPING FOR 	word, numword, asciiword, hword, numhword, asciihword, hword_part, hword_numpart, hword_asciipart 	WITH ispell, english_stem;
SELECT TO_TSVECTOR('ispell_tst', 'Booking the skies after rebookings for footballklubber from a foot');
SELECT TO_TSQUERY('ispell_tst', 'footballklubber');
SELECT TO_TSQUERY('ispell_tst', 'footballyklubber:b & rebookings:A & sky');
/* Test ispell dictionary with hunspell affix in configuration */ CREATE TEXT SEARCH CONFIGURATION hunspell_tst ( 						COPY=ispell_tst );
ALTER TEXT SEARCH CONFIGURATION hunspell_tst ALTER MAPPING 	REPLACE ispell WITH hunspell;
SELECT TO_TSVECTOR('hunspell_tst', 'Booking the skies after rebookings for footballklubber from a foot');
SELECT TO_TSQUERY('hunspell_tst', 'footballklubber');
SELECT TO_TSQUERY('hunspell_tst', 'footballyklubber:b & rebookings:A & sky');
SELECT TO_TSQUERY('hunspell_tst', 'footballyklubber:b <-> sky');
SELECT PHRASETO_TSQUERY('hunspell_tst', 'footballyklubber sky');
/* Test ispell dictionary with hunspell affix with FLAG long in configuration */ ALTER TEXT SEARCH CONFIGURATION hunspell_tst ALTER MAPPING 	REPLACE hunspell WITH hunspell_long;
SELECT TO_TSVECTOR('hunspell_tst', 'Booking the skies after rebookings for footballklubber from a foot');
SELECT TO_TSQUERY('hunspell_tst', 'footballklubber');
SELECT TO_TSQUERY('hunspell_tst', 'footballyklubber:b & rebookings:A & sky');
/* Test ispell dictionary with hunspell affix with FLAG num in configuration */ ALTER TEXT SEARCH CONFIGURATION hunspell_tst ALTER MAPPING 	REPLACE hunspell_long WITH hunspell_num;
SELECT TO_TSVECTOR('hunspell_tst', 'Booking the skies after rebookings for footballklubber from a foot');
SELECT TO_TSQUERY('hunspell_tst', 'footballklubber');
SELECT TO_TSQUERY('hunspell_tst', 'footballyklubber:b & rebookings:A & sky');
/* Test synonym dictionary in configuration */ CREATE TEXT SEARCH CONFIGURATION synonym_tst ( 						COPY=english );
ALTER TEXT SEARCH CONFIGURATION synonym_tst ALTER MAPPING FOR 	asciiword, hword_asciipart, asciihword 	WITH synonym, english_stem;
SELECT TO_TSVECTOR('synonym_tst', 'Postgresql is often called as postgres or pgsql and pronounced as postgre');
SELECT TO_TSVECTOR('synonym_tst', 'Most common mistake is to write Gogle instead of Google');
SELECT TO_TSVECTOR('synonym_tst', 'Indexes or indices - Which is right plural form of index?');
SELECT TO_TSQUERY('synonym_tst', 'Index & indices');
/* test thesaurus in configuration */ /* see thesaurus_sample.ths to understand 'odd' resulting tsvector */ CREATE TEXT SEARCH CONFIGURATION thesaurus_tst ( 						COPY=synonym_tst );
ALTER TEXT SEARCH CONFIGURATION thesaurus_tst ALTER MAPPING FOR 	asciiword, hword_asciipart, asciihword 	WITH synonym, thesaurus, english_stem;
SELECT TO_TSVECTOR('thesaurus_tst', 'one postgres one two one two three one');
SELECT TO_TSVECTOR('thesaurus_tst', 'Supernovae star is very new star and usually called supernovae (abbreviation SN)');
SELECT TO_TSVECTOR('thesaurus_tst', 'Booking tickets is looking like a booking a tickets');
/* invalid: non-lowercase quoted identifiers */ CREATE TEXT SEARCH DICTIONARY tsdict_case ( 	Template = ispell, 	"DictFile" = ispell_sample, 	"AffFile" = ispell_sample );
/* Test grammar for configurations */ CREATE TEXT SEARCH CONFIGURATION dummy_tst (COPY=english);
/* Overridden mapping change with duplicated tokens. */ ALTER TEXT SEARCH CONFIGURATION dummy_tst   ALTER MAPPING FOR word, word WITH ispell;
/* Not a token supported by the configuration's parser, fails. */ ALTER TEXT SEARCH CONFIGURATION dummy_tst   DROP MAPPING FOR not_a_token, not_a_token;
/* Not a token supported by the configuration's parser, fails even */ /* with IF EXISTS. */ ALTER TEXT SEARCH CONFIGURATION dummy_tst   DROP MAPPING IF EXISTS FOR not_a_token, not_a_token;
/* Token supported by the configuration's parser, succeeds. */ ALTER TEXT SEARCH CONFIGURATION dummy_tst   DROP MAPPING FOR word, word;
/* No mapping for token supported by the configuration's parser, fails. */ ALTER TEXT SEARCH CONFIGURATION dummy_tst   DROP MAPPING FOR word;
/* Token supported by the configuration's parser, cannot be found, */ /* succeeds with IF EXISTS. */ ALTER TEXT SEARCH CONFIGURATION dummy_tst   DROP MAPPING IF EXISTS FOR word, word;
/* Re-add mapping, with duplicated tokens supported by the parser. */ ALTER TEXT SEARCH CONFIGURATION dummy_tst   ADD MAPPING FOR word, word WITH ispell;
/* Not a token supported by the configuration's parser, fails. */ ALTER TEXT SEARCH CONFIGURATION dummy_tst   ADD MAPPING FOR not_a_token WITH ispell;
DROP TEXT SEARCH CONFIGURATION dummy_tst;
SELECT x, x FROM x WHERE x = 0 OR x = 0 OR x = 0;
SELECT x, x FROM x WHERE x = 0 OR x = 0;
/* tmplinit is optional */ SELECT x, x FROM x WHERE x = 0 OR x = 0 OR x = 0;
SELECT x, x, x FROM x WHERE x = 0 OR x = 0;
/* Look for pg_ts_config_map entries that aren't one of parser's token types */ SELECT * FROM (SELECT x AS x, (TS_TOKEN_TYPE(x)).x AS x FROM x) AS x RIGHT JOIN x AS x ON (x.x = x.x AND x.x = x.x) WHERE x.x IS NULL OR x.x IS NULL;
/* Load some test data */ CREATE TABLE x (x TEXT, x tsvector);
ANALYZE x;
/* test basic text search behavior without indexes, then with */ SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('wr|qh');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('wr&qh');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('eq&yt');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('eq|yt');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('(eq&yt)|(wr&qh)');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('(eq|yt)&(wr|qh)');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('w:*|q:*');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST(ANY('{wr,qh}'));
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('no_such_lexeme');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('!no_such_lexeme');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('pl <-> yh');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('yh <-> pl');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('qe <2> qt');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('!pl <-> yh');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('!pl <-> !yh');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('!yh <-> pl');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('!qe <2> qt');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('!(pl <-> yh)');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('!(yh <-> pl)');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('!(qe <2> qt)');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('wd:A');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('wd:D');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('!wd:A');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('!wd:D');
CREATE INDEX x ON x USING gist(x NULLS LAST);
SET x = OFF;
SET x = ON;
SET x = OFF;
EXPLAIN (costs off) SELECT count(*) FROM test_tsvector WHERE a @@ 'wr|qh';
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('wr|qh');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('wr&qh');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('eq&yt');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('eq|yt');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('(eq&yt)|(wr&qh)');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('(eq|yt)&(wr|qh)');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('w:*|q:*');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST(ANY('{wr,qh}'));
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('no_such_lexeme');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('!no_such_lexeme');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('pl <-> yh');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('yh <-> pl');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('qe <2> qt');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('!pl <-> yh');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('!pl <-> !yh');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('!yh <-> pl');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('!qe <2> qt');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('!(pl <-> yh)');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('!(yh <-> pl)');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('!(qe <2> qt)');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('wd:A');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('wd:D');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('!wd:A');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('!wd:D');
SET x = OFF;
SET x = ON;
EXPLAIN (costs off) SELECT count(*) FROM test_tsvector WHERE a @@ 'wr|qh';
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('wr|qh');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('wr&qh');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('eq&yt');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('eq|yt');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('(eq&yt)|(wr&qh)');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('(eq|yt)&(wr|qh)');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('w:*|q:*');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST(ANY('{wr,qh}'));
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('no_such_lexeme');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('!no_such_lexeme');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('pl <-> yh');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('yh <-> pl');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('qe <2> qt');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('!pl <-> yh');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('!pl <-> !yh');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('!yh <-> pl');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('!qe <2> qt');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('!(pl <-> yh)');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('!(yh <-> pl)');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('!(qe <2> qt)');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('wd:A');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('wd:D');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('!wd:A');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('!wd:D');
/* Test siglen parameter of GiST tsvector_ops */ CREATE INDEX x ON x USING gist(x x NULLS LAST);
CREATE INDEX x ON x USING gist(x x NULLS LAST);
CREATE INDEX x ON x USING gist(x x NULLS LAST);
CREATE INDEX x ON x USING gist(x x NULLS LAST);
CREATE INDEX x ON x USING gist(x x NULLS LAST);
CREATE INDEX x ON x USING gist(x x NULLS LAST);
EXPLAIN (costs off) SELECT count(*) FROM test_tsvector WHERE a @@ 'wr|qh';
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('wr|qh');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('wr&qh');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('eq&yt');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('eq|yt');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('(eq&yt)|(wr&qh)');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('(eq|yt)&(wr|qh)');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('w:*|q:*');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST(ANY('{wr,qh}'));
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('no_such_lexeme');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('!no_such_lexeme');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('pl <-> yh');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('yh <-> pl');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('qe <2> qt');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('!pl <-> yh');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('!pl <-> !yh');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('!yh <-> pl');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('!qe <2> qt');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('!(pl <-> yh)');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('!(yh <-> pl)');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('!(qe <2> qt)');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('wd:A');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('wd:D');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('!wd:A');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('!wd:D');
DROP INDEX x;
CREATE INDEX x ON x USING gist(x x NULLS LAST);
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('wr|qh');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('wr&qh');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('eq&yt');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('eq|yt');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('(eq&yt)|(wr&qh)');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('(eq|yt)&(wr|qh)');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('w:*|q:*');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST(ANY('{wr,qh}'));
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('no_such_lexeme');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('!no_such_lexeme');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('pl <-> yh');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('yh <-> pl');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('qe <2> qt');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('!pl <-> yh');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('!pl <-> !yh');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('!yh <-> pl');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('!qe <2> qt');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('!(pl <-> yh)');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('!(yh <-> pl)');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('!(qe <2> qt)');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('wd:A');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('wd:D');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('!wd:A');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('!wd:D');
RESET enable_seqscan;
RESET enable_indexscan;
RESET enable_bitmapscan;
DROP INDEX x;
CREATE INDEX x ON x USING gin(x NULLS LAST);
SET x = OFF;
/* GIN only supports bitmapscan, so no need to test plain indexscan */ EXPLAIN (costs off) SELECT count(*) FROM test_tsvector WHERE a @@ 'wr|qh';
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('wr|qh');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('wr&qh');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('eq&yt');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('eq|yt');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('(eq&yt)|(wr&qh)');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('(eq|yt)&(wr|qh)');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('w:*|q:*');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST(ANY('{wr,qh}'));
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('no_such_lexeme');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('!no_such_lexeme');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('pl <-> yh');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('yh <-> pl');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('qe <2> qt');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('!pl <-> yh');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('!pl <-> !yh');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('!yh <-> pl');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('!qe <2> qt');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('!(pl <-> yh)');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('!(yh <-> pl)');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('!(qe <2> qt)');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('wd:A');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('wd:D');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('!wd:A');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('!wd:D');
/* Test optimization of non-empty GIN_SEARCH_MODE_ALL queries */ EXPLAIN (COSTS OFF) SELECT count(*) FROM test_tsvector WHERE a @@ '!qh';
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('!qh');
EXPLAIN (COSTS OFF) SELECT count(*) FROM test_tsvector WHERE a @@ 'wr' AND a @@ '!qh';
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST('wr') AND MATCH(x) AGAINST('!qh');
RESET enable_seqscan;
INSERT INTO x VALUES ('???', 'DFG:1A,2B,6C,10 FGH');
SELECT * FROM x ORDER BY x DESC NULLS FIRST, x DESC NULLS FIRST, x NULLS LAST LIMIT 10;
SELECT * FROM x ORDER BY x DESC NULLS FIRST, x DESC NULLS FIRST, x NULLS LAST;
/* dictionaries and to_tsvector */ SELECT TS_LEXIZE('english_stem', 'skies');
SELECT TS_LEXIZE('english_stem', 'identity');
SELECT * FROM x;
SELECT * FROM x;
SELECT TO_TSVECTOR('english', '345 qwe@efd.r '' http://www.com/ http://aew.werc.ewr/?ad=qwe&dw 1aew.werc.ewr/?ad=qwe&dw 2aew.werc.ewr http://3aew.werc.ewr/?ad=qwe&dw http://4aew.werc.ewr http://5aew.werc.ewr:8100/?  ad=qwe&dw 6aew.werc.ewr:8100/?ad=qwe&dw 7aew.werc.ewr:8100/?ad=qwe&dw=%20%32 +4.0e-10 qwe qwe qwqwe 234.435 455 5.005 teodor@stack.net teodor@123-stack.net 123_teodor@stack.net 123-teodor@stack.net qwe-wer asdf <fr>qwer jf sdjk<we hjwer <werrwe> ewr1> ewri2 <a href="qwe<qwe>"> /usr/local/fff /awdf/dwqe/4325 rewt/ewr wefjn /wqe-324/ewr gist.h gist.h.c gist.c. readline 4.2 4.2. 4.2, readline-4.2 readline-4.2. 234 <i <b> wow  < jqw <> qwerty');
SELECT LENGTH(TO_TSVECTOR('english', '345 qwe@efd.r '' http://www.com/ http://aew.werc.ewr/?ad=qwe&dw 1aew.werc.ewr/?ad=qwe&dw 2aew.werc.ewr http://3aew.werc.ewr/?ad=qwe&dw http://4aew.werc.ewr http://5aew.werc.ewr:8100/?  ad=qwe&dw 6aew.werc.ewr:8100/?ad=qwe&dw 7aew.werc.ewr:8100/?ad=qwe&dw=%20%32 +4.0e-10 qwe qwe qwqwe 234.435 455 5.005 teodor@stack.net teodor@123-stack.net 123_teodor@stack.net 123-teodor@stack.net qwe-wer asdf <fr>qwer jf sdjk<we hjwer <werrwe> ewr1> ewri2 <a href="qwe<qwe>"> /usr/local/fff /awdf/dwqe/4325 rewt/ewr wefjn /wqe-324/ewr gist.h gist.h.c gist.c. readline 4.2 4.2. 4.2, readline-4.2 readline-4.2. 234 <i <b> wow  < jqw <> qwerty'));
/* check parsing of URLs */ SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
SELECT x, x, x, x IS NULL AS x, ARRAY_DIMS(x) AS x, x, x IS NULL AS x, ARRAY_DIMS(x) AS x FROM x;
/* to_tsquery */ SELECT TO_TSQUERY('english', 'qwe & sKies ');
SELECT TO_TSQUERY('simple', 'qwe & sKies ');
SELECT TO_TSQUERY('english', '''the wether'':dc & ''           sKies '':BC ');
SELECT TO_TSQUERY('english', 'asd&(and|fghj)');
SELECT TO_TSQUERY('english', '(asd&and)|fghj');
SELECT TO_TSQUERY('english', '(asd&!and)|fghj');
SELECT TO_TSQUERY('english', '(the|and&(i&1))&fghj');
SELECT PLAINTO_TSQUERY('english', 'the and z 1))& fghj');
SELECT PLAINTO_TSQUERY('english', 'foo bar') && PLAINTO_TSQUERY('english', 'asd');
SELECT PLAINTO_TSQUERY('english', 'foo bar') || PLAINTO_TSQUERY('english', 'asd fg');
SELECT PLAINTO_TSQUERY('english', 'foo bar') || NOT NOT PLAINTO_TSQUERY('english', 'asd fg');
SELECT PLAINTO_TSQUERY('english', 'foo bar') && 'asd | fg';
/* Check stop word deletion, a and s are stop-words */ SELECT TO_TSQUERY('english', '!(a & !b) & c');
SELECT TO_TSQUERY('english', '!(a & !b)');
SELECT TO_TSQUERY('english', '(1 <-> 2) <-> a');
SELECT TO_TSQUERY('english', '(1 <-> a) <-> 2');
SELECT TO_TSQUERY('english', '(a <-> 1) <-> 2');
SELECT TO_TSQUERY('english', 'a <-> (1 <-> 2)');
SELECT TO_TSQUERY('english', '1 <-> (a <-> 2)');
SELECT TO_TSQUERY('english', '1 <-> (2 <-> a)');
SELECT TO_TSQUERY('english', '(1 <-> 2) <3> a');
SELECT TO_TSQUERY('english', '(1 <-> a) <3> 2');
SELECT TO_TSQUERY('english', '(a <-> 1) <3> 2');
SELECT TO_TSQUERY('english', 'a <3> (1 <-> 2)');
SELECT TO_TSQUERY('english', '1 <3> (a <-> 2)');
SELECT TO_TSQUERY('english', '1 <3> (2 <-> a)');
SELECT TO_TSQUERY('english', '(1 <3> 2) <-> a');
SELECT TO_TSQUERY('english', '(1 <3> a) <-> 2');
SELECT TO_TSQUERY('english', '(a <3> 1) <-> 2');
SELECT TO_TSQUERY('english', 'a <-> (1 <3> 2)');
SELECT TO_TSQUERY('english', '1 <-> (a <3> 2)');
SELECT TO_TSQUERY('english', '1 <-> (2 <3> a)');
SELECT TO_TSQUERY('english', '((a <-> 1) <-> 2) <-> s');
SELECT TO_TSQUERY('english', '(2 <-> (a <-> 1)) <-> s');
SELECT TO_TSQUERY('english', '((1 <-> a) <-> 2) <-> s');
SELECT TO_TSQUERY('english', '(2 <-> (1 <-> a)) <-> s');
SELECT TO_TSQUERY('english', 's <-> ((a <-> 1) <-> 2)');
SELECT TO_TSQUERY('english', 's <-> (2 <-> (a <-> 1))');
SELECT TO_TSQUERY('english', 's <-> ((1 <-> a) <-> 2)');
SELECT TO_TSQUERY('english', 's <-> (2 <-> (1 <-> a))');
SELECT TO_TSQUERY('english', '((a <-> 1) <-> s) <-> 2');
SELECT TO_TSQUERY('english', '(s <-> (a <-> 1)) <-> 2');
SELECT TO_TSQUERY('english', '((1 <-> a) <-> s) <-> 2');
SELECT TO_TSQUERY('english', '(s <-> (1 <-> a)) <-> 2');
SELECT TO_TSQUERY('english', '2 <-> ((a <-> 1) <-> s)');
SELECT TO_TSQUERY('english', '2 <-> (s <-> (a <-> 1))');
SELECT TO_TSQUERY('english', '2 <-> ((1 <-> a) <-> s)');
SELECT TO_TSQUERY('english', '2 <-> (s <-> (1 <-> a))');
SELECT TO_TSQUERY('english', 'foo <-> (a <-> (the <-> bar))');
SELECT TO_TSQUERY('english', '((foo <-> a) <-> the) <-> bar');
SELECT TO_TSQUERY('english', 'foo <-> a <-> the <-> bar');
SELECT PHRASETO_TSQUERY('english', 'PostgreSQL can be extended by the user in many ways');
SELECT TS_RANK_CD(STRIP(TO_TSVECTOR('both stripped')), TO_TSQUERY('both & stripped'));
SELECT TS_RANK_CD(TO_TSVECTOR('unstripped') || STRIP(TO_TSVECTOR('stripped')), TO_TSQUERY('unstripped & stripped'));
SELECT TS_HEADLINE('english', 'Lorem ipsum urna.  Nullam nullam ullamcorper urna.', TO_TSQUERY('english', 'Lorem') && PHRASETO_TSQUERY('english', 'ullamcorper urna'), 'MaxWords=100, MinWords=1');
SELECT TS_HEADLINE('english', 'Lorem ipsum urna.  Nullam nullam ullamcorper urna.', PHRASETO_TSQUERY('english', 'ullamcorper urna'), 'MaxWords=100, MinWords=5');
SELECT TS_HEADLINE('simple', CAST('1 2 3 1 3' AS TEXT), '1 <-> 3', 'MaxWords=2, MinWords=1');
SELECT TS_HEADLINE('simple', CAST('1 2 3 1 3' AS TEXT), '1 & 3', 'MaxWords=4, MinWords=1');
SELECT TS_HEADLINE('simple', CAST('1 2 3 1 3' AS TEXT), '1 <-> 3', 'MaxWords=4, MinWords=1');
/* Fragments with phrase search */ SELECT TS_HEADLINE('english', 'Lorem ipsum urna.  Nullam nullam ullamcorper urna.', TO_TSQUERY('english', 'Lorem') && PHRASETO_TSQUERY('english', 'ullamcorper urna'), 'MaxFragments=100, MaxWords=100, MinWords=1');
/* Edge cases with empty query */ SELECT TS_HEADLINE('english', '', TO_TSQUERY('english', ''));
SELECT TS_HEADLINE('english', 'foo bar', TO_TSQUERY('english', ''));
/* Rewrite sub system */ CREATE TABLE x (x TEXT, x TEXT);
UPDATE x SET x = TO_TSQUERY('english', x);
ALTER TABLE x ADD COLUMN x tsquery;
UPDATE x SET x = TO_TSQUERY('english', CAST(x AS TEXT));
SELECT COUNT(*) FROM x WHERE x < 'new <-> york';
SELECT COUNT(*) FROM x WHERE x <= 'new <-> york';
SELECT COUNT(*) FROM x WHERE x = 'new <-> york';
SELECT COUNT(*) FROM x WHERE x >= 'new <-> york';
SELECT COUNT(*) FROM x WHERE x > 'new <-> york';
CREATE UNIQUE INDEX x ON x(x NULLS LAST);
SET x = OFF;
SELECT COUNT(*) FROM x WHERE x < 'new <-> york';
SELECT COUNT(*) FROM x WHERE x <= 'new <-> york';
SELECT COUNT(*) FROM x WHERE x = 'new <-> york';
SELECT COUNT(*) FROM x WHERE x >= 'new <-> york';
SELECT COUNT(*) FROM x WHERE x > 'new <-> york';
RESET enable_seqscan;
SELECT TS_REWRITE('foo & bar & qq & new & york', CAST('new & york' AS tsquery), 'big & apple | nyc | new & york & city');
SELECT TS_REWRITE(TS_REWRITE('new & !york ', 'york', '!jersey'), 'jersey', 'mexico');
SELECT TS_REWRITE('moscow', CAST('SELECT keyword, sample FROM test_tsquery' AS TEXT));
SELECT TS_REWRITE('moscow & hotel', CAST('SELECT keyword, sample FROM test_tsquery' AS TEXT));
SELECT TS_REWRITE('bar & qq & foo & (new <-> york)', CAST('SELECT keyword, sample FROM test_tsquery' AS TEXT));
SELECT TS_REWRITE('moscow', 'SELECT keyword, sample FROM test_tsquery');
SELECT TS_REWRITE('moscow & hotel', 'SELECT keyword, sample FROM test_tsquery');
SELECT TS_REWRITE('bar & qq & foo & (new <-> york)', 'SELECT keyword, sample FROM test_tsquery');
SELECT TS_REWRITE('1 & (2 <-> 3)', CAST('SELECT keyword, sample FROM test_tsquery' AS TEXT));
SELECT TS_REWRITE('1 & (2 <2> 3)', CAST('SELECT keyword, sample FROM test_tsquery' AS TEXT));
SELECT TS_REWRITE('5 <-> (1 & (2 <-> 3))', CAST('SELECT keyword, sample FROM test_tsquery' AS TEXT));
SELECT TS_REWRITE('5 <-> (6 | 8)', CAST('SELECT keyword, sample FROM test_tsquery' AS TEXT));
/* Check empty substitution */ SELECT TS_REWRITE(TO_TSQUERY('5 & (6 | 5)'), TO_TSQUERY('5'), TO_TSQUERY(''));
SELECT TS_REWRITE(TO_TSQUERY('!5'), TO_TSQUERY('5'), TO_TSQUERY(''));
SELECT x FROM x WHERE x @> 'new';
SELECT x FROM x WHERE x @> 'moscow';
SELECT x FROM x WHERE 'new' @> x;
SELECT x FROM x WHERE 'moscow' @> x;
SELECT TS_REWRITE(x, 'SELECT keyword, sample FROM test_tsquery') FROM x AS x;
SELECT TS_REWRITE(x, 'SELECT keyword, sample FROM test_tsquery') FROM x AS x;
SELECT TS_REWRITE(x, 'SELECT keyword, sample FROM test_tsquery') FROM x AS x;
SELECT TS_REWRITE(x, 'SELECT keyword, sample FROM test_tsquery') FROM x AS x;
SELECT TS_REWRITE(x, 'SELECT keyword, sample FROM test_tsquery') FROM x AS x;
SELECT TS_REWRITE(x, 'SELECT keyword, sample FROM test_tsquery') FROM x AS x;
CREATE INDEX x ON x USING gist(x x NULLS LAST);
SET x = OFF;
SELECT x FROM x WHERE x @> 'new';
SELECT x FROM x WHERE x @> 'moscow';
SELECT x FROM x WHERE 'new' @> x;
SELECT x FROM x WHERE 'moscow' @> x;
SELECT TS_REWRITE(x, 'SELECT keyword, sample FROM test_tsquery') FROM x AS x;
SELECT TS_REWRITE(x, 'SELECT keyword, sample FROM test_tsquery') FROM x AS x;
SELECT TS_REWRITE(x, 'SELECT keyword, sample FROM test_tsquery') FROM x AS x;
SELECT TS_REWRITE(x, 'SELECT keyword, sample FROM test_tsquery') FROM x AS x;
SELECT TS_REWRITE(x, 'SELECT keyword, sample FROM test_tsquery') FROM x AS x;
SELECT TS_REWRITE(x, 'SELECT keyword, sample FROM test_tsquery') FROM x AS x;
SELECT TS_REWRITE(TSQUERY_PHRASE('foo', 'foo'), 'foo', 'bar | baz');
SELECT MATCH(TO_TSVECTOR('foo bar')) AGAINST(TS_REWRITE(TSQUERY_PHRASE('foo', 'foo'), 'foo', 'bar | baz'));
SELECT MATCH(TO_TSVECTOR('bar baz')) AGAINST(TS_REWRITE(TSQUERY_PHRASE('foo', 'foo'), 'foo', 'bar | baz'));
RESET enable_seqscan;
SET x = simple /* test GUC */;
SELECT TO_TSVECTOR('SKIES My booKs');
SELECT PLAINTO_TSQUERY('SKIES My booKs');
SELECT TO_TSQUERY('SKIES & My | booKs');
SET x = english;
SELECT TO_TSVECTOR('SKIES My booKs');
SELECT PLAINTO_TSQUERY('SKIES My booKs');
SELECT TO_TSQUERY('SKIES & My | booKs');
/* trigger */ CREATE TRIGGER tsvectorupdate BEFORE UPDATE OR INSERT ON test_tsvector FOR EACH ROW EXECUTE PROCEDURE tsvector_update_trigger(a, 'pg_catalog.english', t);
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST(TO_TSQUERY('345&qwerty'));
INSERT INTO x (x) VALUES ('345 qwerty');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST(TO_TSQUERY('345&qwerty'));
UPDATE x SET x = NULL WHERE x = '345 qwerty';
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST(TO_TSQUERY('345&qwerty'));
INSERT INTO x (x) VALUES ('345 qwerty');
SELECT COUNT(*) FROM x WHERE MATCH(x) AGAINST(TO_TSQUERY('345&qwerty'));
/* Test inlining of immutable constant functions */ /* to_tsquery(text) is not immutable, so it won't be inlined */ EXPLAIN (costs off) select * from test_tsquery, to_tsquery('new') q where txtsample @@ q;
/* to_tsquery(regconfig, text) is an immutable function. */ /* That allows us to get rid of using function scan and join at all. */ EXPLAIN (costs off) select * from test_tsquery, to_tsquery('english', 'new') q where txtsample @@ q;
/* test finding items in GIN's pending list */ CREATE TEMPORARY TABLE x (x tsvector);
CREATE INDEX x ON x USING gin(x NULLS LAST);
INSERT INTO x VALUES (TO_TSVECTOR('Lore ipsam'));
INSERT INTO x VALUES (TO_TSVECTOR('Lore ipsum'));
SELECT * FROM x WHERE MATCH(CAST('ipsu:*' AS tsquery)) AGAINST(x);
SELECT * FROM x WHERE MATCH(CAST('ipsa:*' AS tsquery)) AGAINST(x);
SELECT * FROM x WHERE MATCH(CAST('ips:*' AS tsquery)) AGAINST(x);
SELECT * FROM x WHERE MATCH(CAST('ipt:*' AS tsquery)) AGAINST(x);
SELECT * FROM x WHERE MATCH(CAST('ipi:*' AS tsquery)) AGAINST(x);
/* check OP_PHRASE on index */ CREATE TEMPORARY TABLE x (x tsvector);
INSERT INTO x VALUES ('A fat cat has just eaten a rat.');
INSERT INTO x VALUES (TO_TSVECTOR('english', 'A fat cat has just eaten a rat.'));
CREATE INDEX x ON x USING gin(x NULLS LAST);
SET x = off;
SELECT * FROM x WHERE MATCH(x) AGAINST(PHRASETO_TSQUERY('english', 'fat cat'));
SET x = on;
/* test websearch_to_tsquery function */ SELECT WEBSEARCH_TO_TSQUERY('simple', 'I have a fat:*ABCD cat');
SELECT WEBSEARCH_TO_TSQUERY('simple', 'orange:**AABBCCDD');
SELECT WEBSEARCH_TO_TSQUERY('simple', 'fat:A!cat:B|rat:C<');
SELECT WEBSEARCH_TO_TSQUERY('simple', 'fat:A : cat:B');
SELECT WEBSEARCH_TO_TSQUERY('simple', 'fat*rat');
SELECT WEBSEARCH_TO_TSQUERY('simple', 'fat-rat');
SELECT WEBSEARCH_TO_TSQUERY('simple', 'fat_rat');
/* weights are completely ignored */ SELECT WEBSEARCH_TO_TSQUERY('simple', 'abc : def');
SELECT WEBSEARCH_TO_TSQUERY('simple', 'abc:def');
SELECT WEBSEARCH_TO_TSQUERY('simple', 'a:::b');
SELECT WEBSEARCH_TO_TSQUERY('simple', 'abc:d');
SELECT WEBSEARCH_TO_TSQUERY('simple', ':');
/* these operators are ignored */ SELECT WEBSEARCH_TO_TSQUERY('simple', 'abc & def');
SELECT WEBSEARCH_TO_TSQUERY('simple', 'abc | def');
SELECT WEBSEARCH_TO_TSQUERY('simple', 'abc <-> def');
/* parens are ignored, too */ SELECT WEBSEARCH_TO_TSQUERY('simple', 'abc (pg or class)');
SELECT WEBSEARCH_TO_TSQUERY('simple', '(foo bar) or (ding dong)');
/* NOT is ignored in quotes */ SELECT WEBSEARCH_TO_TSQUERY('english', 'My brand new smartphone');
SELECT WEBSEARCH_TO_TSQUERY('english', 'My brand "new smartphone"');
SELECT WEBSEARCH_TO_TSQUERY('english', 'My brand "new -smartphone"');
/* test OR operator */ SELECT WEBSEARCH_TO_TSQUERY('simple', 'cat or rat');
SELECT WEBSEARCH_TO_TSQUERY('simple', 'cat OR rat');
SELECT WEBSEARCH_TO_TSQUERY('simple', 'cat "OR" rat');
SELECT WEBSEARCH_TO_TSQUERY('simple', 'cat OR');
SELECT WEBSEARCH_TO_TSQUERY('simple', 'OR rat');
SELECT WEBSEARCH_TO_TSQUERY('simple', '"fat cat OR rat"');
SELECT WEBSEARCH_TO_TSQUERY('simple', 'fat (cat OR rat');
SELECT WEBSEARCH_TO_TSQUERY('simple', 'or OR or');
/* OR is an operator here ... */ SELECT WEBSEARCH_TO_TSQUERY('simple', '"fat cat"or"fat rat"');
SELECT WEBSEARCH_TO_TSQUERY('simple', 'fat or(rat');
SELECT WEBSEARCH_TO_TSQUERY('simple', 'fat or)rat');
SELECT WEBSEARCH_TO_TSQUERY('simple', 'fat or&rat');
SELECT WEBSEARCH_TO_TSQUERY('simple', 'fat or|rat');
SELECT WEBSEARCH_TO_TSQUERY('simple', 'fat or!rat');
SELECT WEBSEARCH_TO_TSQUERY('simple', 'fat or<rat');
SELECT WEBSEARCH_TO_TSQUERY('simple', 'fat or>rat');
SELECT WEBSEARCH_TO_TSQUERY('simple', 'fat or ');
/* ... but not here */ SELECT WEBSEARCH_TO_TSQUERY('simple', 'abc orange');
SELECT WEBSEARCH_TO_TSQUERY('simple', 'abc OR1234');
SELECT WEBSEARCH_TO_TSQUERY('simple', 'abc or-abc');
SELECT WEBSEARCH_TO_TSQUERY('simple', 'abc OR_abc');
/* test quotes */ SELECT WEBSEARCH_TO_TSQUERY('english', '"pg_class pg');
SELECT WEBSEARCH_TO_TSQUERY('english', 'pg_class pg"');
SELECT WEBSEARCH_TO_TSQUERY('english', '"pg_class pg"');
SELECT WEBSEARCH_TO_TSQUERY('english', '"pg_class : pg"');
SELECT WEBSEARCH_TO_TSQUERY('english', 'abc "pg_class pg"');
SELECT WEBSEARCH_TO_TSQUERY('english', '"pg_class pg" def');
SELECT WEBSEARCH_TO_TSQUERY('english', 'abc "pg pg_class pg" def');
SELECT WEBSEARCH_TO_TSQUERY('english', ' or "pg pg_class pg" or ');
SELECT WEBSEARCH_TO_TSQUERY('english', '""pg pg_class pg""');
SELECT WEBSEARCH_TO_TSQUERY('english', 'abc """"" def');
SELECT WEBSEARCH_TO_TSQUERY('english', 'cat -"fat rat"');
SELECT WEBSEARCH_TO_TSQUERY('english', 'cat -"fat rat" cheese');
SELECT WEBSEARCH_TO_TSQUERY('english', 'abc "def -"');
SELECT WEBSEARCH_TO_TSQUERY('english', 'abc "def :"');
SELECT WEBSEARCH_TO_TSQUERY('english', '"A fat cat" has just eaten a -rat.');
SELECT WEBSEARCH_TO_TSQUERY('english', '"A fat cat" has just eaten OR !rat.');
SELECT WEBSEARCH_TO_TSQUERY('english', '"A fat cat" has just (+eaten OR -rat)');
SELECT WEBSEARCH_TO_TSQUERY('english', 'this is ----fine');
SELECT WEBSEARCH_TO_TSQUERY('english', '(()) )))) this ||| is && -fine, "dear friend" OR good');
SELECT WEBSEARCH_TO_TSQUERY('english', 'an old <-> cat " is fine &&& too');
SELECT WEBSEARCH_TO_TSQUERY('english', '"A the" OR just on');
SELECT WEBSEARCH_TO_TSQUERY('english', '"a fat cat" ate a rat');
SELECT MATCH(TO_TSVECTOR('english', 'A fat cat ate a rat')) AGAINST(WEBSEARCH_TO_TSQUERY('english', '"a fat cat" ate a rat'));
SELECT MATCH(TO_TSVECTOR('english', 'A fat grey cat ate a rat')) AGAINST(WEBSEARCH_TO_TSQUERY('english', '"a fat cat" ate a rat'));
/* cases handled by gettoken_tsvector() */ SELECT WEBSEARCH_TO_TSQUERY('''');
SELECT WEBSEARCH_TO_TSQUERY('''abc''''def''');
SELECT WEBSEARCH_TO_TSQUERY('\abc');
SELECT WEBSEARCH_TO_TSQUERY('\');
/* tsrf - targetlist set returning function tests */ /* simple srf */ SELECT UNNEST(GENERATE_SERIES(1, 3));
/* parallel iteration */ SELECT UNNEST(GENERATE_SERIES(1, 3)), UNNEST(GENERATE_SERIES(3, 5));
/* parallel iteration, different number of rows */ SELECT UNNEST(GENERATE_SERIES(1, 2)), UNNEST(GENERATE_SERIES(1, 4));
/* srf, with SRF argument */ SELECT UNNEST(GENERATE_SERIES(1, UNNEST(GENERATE_SERIES(1, 3))));
/* but we've traditionally rejected the same in FROM */ SELECT * FROM x;
/* srf, with two SRF arguments */ SELECT UNNEST(GENERATE_SERIES(UNNEST(GENERATE_SERIES(1, 3)), UNNEST(GENERATE_SERIES(2, 4))));
/* check proper nesting of SRFs in different expressions */ EXPLAIN (verbose, costs off) SELECT generate_series(1, generate_series(1, 3)), generate_series(2, 4);
SELECT UNNEST(GENERATE_SERIES(1, UNNEST(GENERATE_SERIES(1, 3)))), UNNEST(GENERATE_SERIES(2, 4));
CREATE TABLE x (x INT, x TEXT, x TEXT);
INSERT INTO x VALUES (1, 'a', 'foo'), (2, 'a', 'bar'), (3, 'b', 'bar');
/* SRF with a provably-dummy relation */ EXPLAIN (verbose, costs off) SELECT unnest(ARRAY[1, 2]) FROM few WHERE false;
SELECT EXPLODE(ARRAY(1, 2)) FROM x WHERE FALSE;
/* SRF shouldn't prevent upper query from recognizing lower as dummy */ EXPLAIN (verbose, costs off) SELECT * FROM few f1,   (SELECT unnest(ARRAY[1,2]) FROM few f2 WHERE false OFFSET 0) ss;
SELECT * FROM x AS x, (SELECT EXPLODE(ARRAY(1, 2)) FROM x AS x WHERE FALSE OFFSET 0) AS x;
/* SRF output order of sorting is maintained, if SRF is not referenced */ SELECT x.x, UNNEST(GENERATE_SERIES(1, 3)) AS x FROM x ORDER BY x DESC NULLS FIRST;
/* but SRFs can be referenced in sort */ SELECT x.x, UNNEST(GENERATE_SERIES(1, 3)) AS x FROM x ORDER BY x NULLS LAST, x DESC NULLS FIRST;
SELECT x.x, UNNEST(GENERATE_SERIES(1, 3)) AS x FROM x ORDER BY x NULLS LAST, UNNEST(GENERATE_SERIES(1, 3)) DESC NULLS FIRST;
/* it's weird to have ORDER BYs that increase the number of results */ SELECT x.x FROM x ORDER BY x NULLS LAST, UNNEST(GENERATE_SERIES(1, 3)) DESC NULLS FIRST;
SET x = 0 /* SRFs are computed after aggregation */;
/* stable output order */ SELECT x.x, COUNT(*), MIN(x), MAX(x), EXPLODE(CAST('{1,1,3}' AS ARRAY<INT>)) FROM x WHERE x.x = 1 GROUP BY x.x;
/* unless referenced in GROUP BY clause */ SELECT x.x, COUNT(*), MIN(x), MAX(x), EXPLODE(CAST('{1,1,3}' AS ARRAY<INT>)) FROM x WHERE x.x = 1 GROUP BY x.x, EXPLODE(CAST('{1,1,3}' AS ARRAY<INT>));
SELECT x.x, COUNT(*), MIN(x), MAX(x), EXPLODE(CAST('{1,1,3}' AS ARRAY<INT>)) FROM x WHERE x.x = 1 GROUP BY x.x, 5;
RESET enable_hashagg;
/* check HAVING works when GROUP BY does [not] reference SRF output */ SELECT x, UNNEST(GENERATE_SERIES(1, 1)), COUNT(*) FROM x GROUP BY 1 HAVING COUNT(*) > 1;
SELECT x, UNNEST(GENERATE_SERIES(1, 1)), COUNT(*) FROM x GROUP BY 1, 2 HAVING COUNT(*) > 1;
/* it's weird to have GROUP BYs that increase the number of results */ SELECT x.x, COUNT(*) FROM x WHERE x = 'a' GROUP BY x.x ORDER BY 2 NULLS LAST;
SELECT x.x, COUNT(*) FROM x WHERE x = 'a' GROUP BY x.x, EXPLODE(CAST('{1,1,3}' AS ARRAY<INT>)) ORDER BY 2 NULLS LAST;
/* SRFs are not allowed if they'd need to be conditionally executed */ SELECT x, CASE WHEN x > 0 THEN UNNEST(GENERATE_SERIES(1, 3)) ELSE 0 END FROM x;
SELECT x, COALESCE(UNNEST(GENERATE_SERIES(1, 3)), 0) FROM x;
/* SRFs are not allowed in aggregate arguments */ SELECT MIN(UNNEST(GENERATE_SERIES(1, 3))) FROM x;
/* ... unless they're within a sub-select */ SELECT SUM(CAST((3 = ANY (SELECT UNNEST(GENERATE_SERIES(1, 4)))) AS INT));
SELECT SUM(CAST((3 = ANY (SELECT LAG(x) OVER (ORDER BY x NULLS LAST) FROM x AS x)) AS INT));
/* SRFs are not allowed in window function arguments, either */ SELECT MIN(UNNEST(GENERATE_SERIES(1, 3))) OVER () FROM x;
/* SRFs are normally computed after window functions */ SELECT x, LAG(x) OVER (), COUNT(*) OVER (), UNNEST(GENERATE_SERIES(1, 3)) FROM x;
/* unless referencing SRFs */ SELECT SUM(COUNT(*)) OVER (PARTITION BY UNNEST(GENERATE_SERIES(1, 3)) ORDER BY UNNEST(GENERATE_SERIES(1, 3)) NULLS LAST), UNNEST(GENERATE_SERIES(1, 3)) AS x FROM x GROUP BY x;
/* sorting + grouping */ SELECT x.x, COUNT(*), MIN(x), MAX(x), UNNEST(GENERATE_SERIES(1, 3)) FROM x GROUP BY x.x ORDER BY 5 NULLS LAST, 1 NULLS LAST;
SET x = FALSE /* grouping sets are a bit special, they produce NULLs in columns not actually NULL */;
SELECT x, x AS x, UNNEST(GENERATE_SERIES(1, 2)) AS x, COUNT(*) FROM x GROUP BY CUBE (x, x);
SELECT x, x AS x, UNNEST(GENERATE_SERIES(1, 2)) AS x, COUNT(*) FROM x GROUP BY CUBE (x, x) ORDER BY x NULLS LAST;
SELECT x, x AS x, UNNEST(GENERATE_SERIES(1, 2)) AS x, COUNT(*) FROM x GROUP BY CUBE (x, x) ORDER BY x NULLS LAST;
SELECT x, x AS x, UNNEST(GENERATE_SERIES(1, 2)) AS x, COUNT(*) FROM x GROUP BY CUBE (x, x, x);
SELECT x, x AS x, UNNEST(GENERATE_SERIES(1, 2)) AS x, COUNT(*) FROM x GROUP BY CUBE (x, x, x) ORDER BY x NULLS LAST;
SELECT x, x AS x, UNNEST(GENERATE_SERIES(1, 2)) AS x, COUNT(*) FROM x GROUP BY CUBE (x, x, x) ORDER BY x NULLS LAST;
RESET enable_hashagg;
/* case with degenerate ORDER BY */ EXPLAIN (verbose, costs off) select 'foo' as f, generate_series(1,2) as g from few order by 1;
SELECT 'foo' AS x, UNNEST(GENERATE_SERIES(1, 2)) AS x FROM x ORDER BY 1 NULLS LAST;
/* data modification */ CREATE TABLE x AS SELECT UNNEST(GENERATE_SERIES(1, 3)) AS x;
INSERT INTO x VALUES (UNNEST(GENERATE_SERIES(4, 5)));
SELECT * FROM x;
/* SRFs are not allowed in UPDATE (they once were, but it was nonsense) */ UPDATE x SET x = UNNEST(GENERATE_SERIES(4, 9));
/* SRFs are not allowed in RETURNING */ INSERT INTO x VALUES (1) RETURNING UNNEST(GENERATE_SERIES(1, 3));
VALUES (1, UNNEST(GENERATE_SERIES(1, 2)));
/* We allow tSRFs that are not at top level */ SELECT INT4MUL(UNNEST(GENERATE_SERIES(1, 2)), 10);
SELECT UNNEST(GENERATE_SERIES(1, 3)) IS DISTINCT FROM 2;
/* but SRFs in function RTEs must be at top level (annoying restriction) */ SELECT * FROM x;
/* DISTINCT ON is evaluated before tSRF evaluation if SRF is not */ /* referenced either in ORDER BY or in the DISTINCT ON list. The ORDER */ /* BY reference can be implicitly generated, if there's no other ORDER BY. */ /* implicit reference (via implicit ORDER) to all columns */ SELECT DISTINCT ON (x) x, x, UNNEST(GENERATE_SERIES(1, 3)) AS x FROM (VALUES (3, 2), (3, 1), (1, 1), (1, 4), (5, 3), (5, 1)) AS x;
/* unreferenced in DISTINCT ON or ORDER BY */ SELECT DISTINCT ON (x) x, x, UNNEST(GENERATE_SERIES(1, 3)) AS x FROM (VALUES (3, 2), (3, 1), (1, 1), (1, 4), (5, 3), (5, 1)) AS x ORDER BY x NULLS LAST, x DESC NULLS FIRST;
/* referenced in ORDER BY */ SELECT DISTINCT ON (x) x, x, UNNEST(GENERATE_SERIES(1, 3)) AS x FROM (VALUES (3, 2), (3, 1), (1, 1), (1, 4), (5, 3), (5, 1)) AS x ORDER BY x NULLS LAST, x DESC NULLS FIRST, x DESC NULLS FIRST;
/* referenced in ORDER BY and DISTINCT ON */ SELECT DISTINCT ON (x, x, x) x, x, UNNEST(GENERATE_SERIES(1, 3)) AS x FROM (VALUES (3, 2), (3, 1), (1, 1), (1, 4), (5, 3), (5, 1)) AS x ORDER BY x NULLS LAST, x DESC NULLS FIRST, x DESC NULLS FIRST;
/* only SRF mentioned in DISTINCT ON */ SELECT DISTINCT ON (x) x, x, UNNEST(GENERATE_SERIES(1, 3)) AS x FROM (VALUES (3, 2), (3, 1), (1, 1), (1, 4), (5, 3), (5, 1)) AS x;
/* LIMIT / OFFSET is evaluated after SRF evaluation */ SELECT x, UNNEST(GENERATE_SERIES(1, 2)) FROM (VALUES (1), (2), (3)) AS x LIMIT 2 OFFSET 2;
/* SRFs are not allowed in LIMIT. */ SELECT 1 LIMIT UNNEST(GENERATE_SERIES(1, 3));
/* tSRF in correlated subquery, referencing table outside */ SELECT (SELECT UNNEST(GENERATE_SERIES(1, 3)) LIMIT 1 OFFSET x.x) FROM x;
/* tSRF in correlated subquery, referencing SRF outside */ SELECT (SELECT UNNEST(GENERATE_SERIES(1, 3)) LIMIT 1 OFFSET x.x) FROM x AS x;
/* Operators can return sets too */ CREATE OPERATOR |@| (PROCEDURE = unnest, RIGHTARG = ANYARRAY);
/* Some fun cases involving duplicate SRF calls */ EXPLAIN (verbose, costs off) select generate_series(1,3) as x, generate_series(1,3) + 1 as xp1;
SELECT UNNEST(GENERATE_SERIES(1, 3)) AS x, UNNEST(GENERATE_SERIES(1, 3)) + 1 AS x;
EXPLAIN (verbose, costs off) select generate_series(1,3)+1 order by generate_series(1,3);
SELECT UNNEST(GENERATE_SERIES(1, 3)) + 1 ORDER BY UNNEST(GENERATE_SERIES(1, 3)) NULLS LAST;
/* Check that SRFs of same nesting level run in lockstep */ EXPLAIN (verbose, costs off) select generate_series(1,3) as x, generate_series(3,6) + 1 as y;
SELECT UNNEST(GENERATE_SERIES(1, 3)) AS x, UNNEST(GENERATE_SERIES(3, 6)) + 1 AS x;
/* Clean up */ DROP TABLE x;
DROP TABLE x;
SET x = 0 /* deal with numeric instability of ts_rank */;
/* Base tsvector test */ SELECT CAST('1' AS tsvector);
SELECT CAST('1 ' AS tsvector);
SELECT CAST(' 1' AS tsvector);
SELECT CAST(' 1 ' AS tsvector);
SELECT CAST('1 2' AS tsvector);
SELECT CAST('''1 2''' AS tsvector);
SELECT CAST('1 \\'2' AS tsvector);
SELECT CAST('1 \\'2'3 AS tsvector);
SELECT CAST('1 \\'2' 3 AS tsvector);
SELECT CAST('1 \\'2' ' 3' 4  AS tsvector);
SELECT CAST('''\\\\as'' ab\\c ab\\\\c AB\\\\\\c ab\\\\\\\\c' AS tsvector);
SELECT TSVECTORIN(TSVECTOROUT(CAST('''\\\\as'' ab\\c ab\\\\c AB\\\\\\c ab\\\\\\\\c' AS tsvector)));
SELECT '''w'':4A,3B,2C,1D,5 a:8';
SELECT CAST('a:3A b:2a' AS tsvector) || 'ba:1234 a:1B';
SELECT CAST(''''' ''1'' ''2''' AS tsvector);
/* error, empty lexeme is not allowed */ /* Also try it with non-error-throwing API */ SELECT PG_INPUT_IS_VALID('foo', 'tsvector');
SELECT PG_INPUT_IS_VALID('''''', 'tsvector');
SELECT * FROM x;
/* Base tsquery test */ SELECT CAST('1' AS tsquery);
SELECT CAST('1 ' AS tsquery);
SELECT CAST(' 1' AS tsquery);
SELECT CAST(' 1 ' AS tsquery);
SELECT CAST('''1 2''' AS tsquery);
SELECT CAST('1 \\'2' AS tsquery);
SELECT CAST('!1' AS tsquery);
SELECT CAST('1|2' AS tsquery);
SELECT CAST('1|!2' AS tsquery);
SELECT CAST('!1|2' AS tsquery);
SELECT CAST('!1|!2' AS tsquery);
SELECT CAST('!(!1|!2)' AS tsquery);
SELECT CAST('!(!1|2)' AS tsquery);
SELECT CAST('!(1|!2)' AS tsquery);
SELECT CAST('!(1|2)' AS tsquery);
SELECT CAST('1&2' AS tsquery);
SELECT CAST('!1&2' AS tsquery);
SELECT CAST('1&!2' AS tsquery);
SELECT CAST('!1&!2' AS tsquery);
SELECT CAST('(1&2)' AS tsquery);
SELECT CAST('1&(2)' AS tsquery);
SELECT CAST('!(1)&2' AS tsquery);
SELECT CAST('!(1&2)' AS tsquery);
SELECT CAST('1|2&3' AS tsquery);
SELECT CAST('1|(2&3)' AS tsquery);
SELECT CAST('(1|2)&3' AS tsquery);
SELECT CAST('1|2&!3' AS tsquery);
SELECT CAST('1|!2&3' AS tsquery);
SELECT CAST('!1|2&3' AS tsquery);
SELECT CAST('!1|(2&3)' AS tsquery);
SELECT CAST('!(1|2)&3' AS tsquery);
SELECT CAST('(!1|2)&3' AS tsquery);
SELECT CAST('1|(2|(4|(5|6)))' AS tsquery);
SELECT CAST('1|2|4|5|6' AS tsquery);
SELECT CAST('1&(2&(4&(5&6)))' AS tsquery);
SELECT CAST('1&2&4&5&6' AS tsquery);
SELECT CAST('1&(2&(4&(5|6)))' AS tsquery);
SELECT CAST('1&(2&(4&(5|!6)))' AS tsquery);
SELECT CAST(1&('2'&(' 4'&(\\|5 | '6 \\' !|&'))) AS tsquery);
SELECT CAST('''\\\\as''' AS tsquery);
SELECT CAST('a:* & nbb:*ac | doo:a* | goo' AS tsquery);
SELECT CAST('!!b' AS tsquery);
SELECT CAST('!!!b' AS tsquery);
SELECT CAST('!(!b)' AS tsquery);
SELECT CAST('a & !!b' AS tsquery);
SELECT CAST('!!a & b' AS tsquery);
SELECT CAST('!!a & !!b' AS tsquery);
/* Also try it with non-error-throwing API */ SELECT PG_INPUT_IS_VALID('foo', 'tsquery');
SELECT PG_INPUT_IS_VALID('foo!', 'tsquery');
SELECT * FROM x;
SELECT * FROM x;
/* comparisons */ SELECT 'a' < CAST('b & c' AS tsquery) AS "x";
SELECT 'a' > CAST('b & c' AS tsquery) AS "x";
SELECT 'a | f' < CAST('b & c' AS tsquery) AS "x";
SELECT 'a | ff' < CAST('b & c' AS tsquery) AS "x";
SELECT 'a | f | g' < CAST('b & c' AS tsquery) AS "x";
/* concatenation */ SELECT NUMNODE(CAST('new' AS tsquery));
SELECT NUMNODE(CAST('new & york' AS tsquery));
SELECT NUMNODE(CAST('new & york | qwery' AS tsquery));
SELECT CAST('foo & bar' AS tsquery) && 'asd';
SELECT CAST('foo & bar' AS tsquery) || 'asd & fg';
SELECT CAST('foo & bar' AS tsquery) || NOT NOT CAST('asd & fg' AS tsquery);
SELECT CAST('foo & bar' AS tsquery) && 'asd | fg';
SELECT 'a' <-> CAST('b & d' AS tsquery);
SELECT 'a & g' <-> CAST('b & d' AS tsquery);
SELECT 'a & g' <-> CAST('b | d' AS tsquery);
SELECT 'a & g' <-> CAST('b <-> d' AS tsquery);
SELECT TSQUERY_PHRASE('a <3> g', 'b & d', 10);
/* tsvector-tsquery operations */ SELECT MATCH(CAST('a b:89  ca:23A,64b d:34c' AS tsvector)) AGAINST('d:AC & ca') AS "x";
SELECT MATCH(CAST('a b:89  ca:23A,64b d:34c' AS tsvector)) AGAINST('d:AC & ca:B') AS "x";
SELECT MATCH(CAST('a b:89  ca:23A,64b d:34c' AS tsvector)) AGAINST('d:AC & ca:A') AS "x";
SELECT MATCH(CAST('a b:89  ca:23A,64b d:34c' AS tsvector)) AGAINST('d:AC & ca:C') AS "x";
SELECT MATCH(CAST('a b:89  ca:23A,64b d:34c' AS tsvector)) AGAINST('d:AC & ca:CB') AS "x";
SELECT MATCH(CAST('a b:89  ca:23A,64b d:34c' AS tsvector)) AGAINST('d:AC & c:*C') AS "x";
SELECT MATCH(CAST('a b:89  ca:23A,64b d:34c' AS tsvector)) AGAINST('d:AC & c:*CB') AS "x";
SELECT MATCH(CAST('a b:89  ca:23A,64b cb:80c d:34c' AS tsvector)) AGAINST('d:AC & c:*C') AS "x";
SELECT MATCH(CAST('a b:89  ca:23A,64c cb:80b d:34c' AS tsvector)) AGAINST('d:AC & c:*C') AS "x";
SELECT MATCH(CAST('a b:89  ca:23A,64c cb:80b d:34c' AS tsvector)) AGAINST('d:AC & c:*B') AS "x";
SELECT MATCH(CAST('wa:1D wb:2A' AS tsvector)) AGAINST(CAST('w:*D & w:*A' AS tsquery)) AS "x";
SELECT MATCH(CAST('wa:1D wb:2A' AS tsvector)) AGAINST(CAST('w:*D <-> w:*A' AS tsquery)) AS "x";
SELECT MATCH(CAST('wa:1A wb:2D' AS tsvector)) AGAINST(CAST('w:*D <-> w:*A' AS tsquery)) AS "x";
SELECT MATCH(CAST('wa:1A' AS tsvector)) AGAINST(CAST('w:*A' AS tsquery)) AS "x";
SELECT MATCH(CAST('wa:1A' AS tsvector)) AGAINST(CAST('w:*D' AS tsquery)) AS "x";
SELECT MATCH(CAST('wa:1A' AS tsvector)) AGAINST(CAST('!w:*A' AS tsquery)) AS "x";
SELECT MATCH(CAST('wa:1A' AS tsvector)) AGAINST(CAST('!w:*D' AS tsquery)) AS "x";
/* historically, a stripped tsvector matches queries ignoring weights: */ SELECT MATCH(STRIP(CAST('wa:1A' AS tsvector))) AGAINST(CAST('w:*A' AS tsquery)) AS "x";
SELECT MATCH(STRIP(CAST('wa:1A' AS tsvector))) AGAINST(CAST('w:*D' AS tsquery)) AS "x";
SELECT MATCH(STRIP(CAST('wa:1A' AS tsvector))) AGAINST(CAST('!w:*A' AS tsquery)) AS "x";
SELECT MATCH(STRIP(CAST('wa:1A' AS tsvector))) AGAINST(CAST('!w:*D' AS tsquery)) AS "x";
SELECT MATCH(CAST('supernova' AS tsvector)) AGAINST(CAST('super' AS tsquery)) AS "x";
SELECT MATCH(CAST('supeanova supernova' AS tsvector)) AGAINST(CAST('super' AS tsquery)) AS "x";
SELECT MATCH(CAST('supeznova supernova' AS tsvector)) AGAINST(CAST('super' AS tsquery)) AS "x";
SELECT MATCH(CAST('supernova' AS tsvector)) AGAINST(CAST('super:*' AS tsquery)) AS "x";
SELECT MATCH(CAST('supeanova supernova' AS tsvector)) AGAINST(CAST('super:*' AS tsquery)) AS "x";
SELECT MATCH(CAST('supeznova supernova' AS tsvector)) AGAINST(CAST('super:*' AS tsquery)) AS "x";
/* phrase search */ SELECT MATCH(TO_TSVECTOR('simple', '1 2 3 1')) AGAINST('1 <-> 2') AS "x";
SELECT MATCH(TO_TSVECTOR('simple', '1 2 3 1')) AGAINST('1 <2> 2') AS "x";
SELECT MATCH(TO_TSVECTOR('simple', '1 2 3 1')) AGAINST('1 <-> 3') AS "x";
SELECT MATCH(TO_TSVECTOR('simple', '1 2 3 1')) AGAINST('1 <2> 3') AS "x";
SELECT MATCH(TO_TSVECTOR('simple', '1 2 1 2')) AGAINST('1 <3> 2') AS "x";
SELECT MATCH(TO_TSVECTOR('simple', '1 2 11 3')) AGAINST('1 <-> 3') AS "x";
SELECT MATCH(TO_TSVECTOR('simple', '1 2 11 3')) AGAINST('1:* <-> 3') AS "x";
SELECT MATCH(TO_TSVECTOR('simple', '1 2 3 4')) AGAINST('1 <-> 2 <-> 3') AS "x";
SELECT MATCH(TO_TSVECTOR('simple', '1 2 3 4')) AGAINST('(1 <-> 2) <-> 3') AS "x";
SELECT MATCH(TO_TSVECTOR('simple', '1 2 3 4')) AGAINST('1 <-> (2 <-> 3)') AS "x";
SELECT MATCH(TO_TSVECTOR('simple', '1 2 3 4')) AGAINST('1 <2> (2 <-> 3)') AS "x";
SELECT MATCH(TO_TSVECTOR('simple', '1 2 1 2 3 4')) AGAINST('(1 <-> 2) <-> 3') AS "x";
SELECT MATCH(TO_TSVECTOR('simple', '1 2 1 2 3 4')) AGAINST('1 <-> 2 <-> 3') AS "x";
/* without position data, phrase search does not match */ SELECT MATCH(STRIP(TO_TSVECTOR('simple', '1 2 3 4'))) AGAINST('1 <-> 2 <-> 3') AS "x";
SELECT MATCH(TO_TSVECTOR('simple', 'q x q y')) AGAINST('q <-> (x & y)') AS "x";
SELECT MATCH(TO_TSVECTOR('simple', 'q x')) AGAINST('q <-> (x | y <-> z)') AS "x";
SELECT MATCH(TO_TSVECTOR('simple', 'q y')) AGAINST('q <-> (x | y <-> z)') AS "x";
SELECT MATCH(TO_TSVECTOR('simple', 'q y z')) AGAINST('q <-> (x | y <-> z)') AS "x";
SELECT MATCH(TO_TSVECTOR('simple', 'q y x')) AGAINST('q <-> (x | y <-> z)') AS "x";
SELECT MATCH(TO_TSVECTOR('simple', 'q x y')) AGAINST('q <-> (x | y <-> z)') AS "x";
SELECT MATCH(TO_TSVECTOR('simple', 'q x')) AGAINST('(x | y <-> z) <-> q') AS "x";
SELECT MATCH(TO_TSVECTOR('simple', 'x q')) AGAINST('(x | y <-> z) <-> q') AS "x";
SELECT MATCH(TO_TSVECTOR('simple', 'x y q')) AGAINST('(x | y <-> z) <-> q') AS "x";
SELECT MATCH(TO_TSVECTOR('simple', 'x y z')) AGAINST('(x | y <-> z) <-> q') AS "x";
SELECT MATCH(TO_TSVECTOR('simple', 'x y z q')) AGAINST('(x | y <-> z) <-> q') AS "x";
SELECT MATCH(TO_TSVECTOR('simple', 'y z q')) AGAINST('(x | y <-> z) <-> q') AS "x";
SELECT MATCH(TO_TSVECTOR('simple', 'y y q')) AGAINST('(x | y <-> z) <-> q') AS "x";
SELECT MATCH(TO_TSVECTOR('simple', 'y y q')) AGAINST('(!x | y <-> z) <-> q') AS "x";
SELECT MATCH(TO_TSVECTOR('simple', 'x y q')) AGAINST('(!x | y <-> z) <-> q') AS "x";
SELECT MATCH(TO_TSVECTOR('simple', 'y y q')) AGAINST('(x | y <-> !z) <-> q') AS "x";
SELECT MATCH(TO_TSVECTOR('simple', 'x q')) AGAINST('(x | y <-> !z) <-> q') AS "x";
SELECT MATCH(TO_TSVECTOR('simple', 'x q')) AGAINST('(!x | y <-> z) <-> q') AS "x";
SELECT MATCH(TO_TSVECTOR('simple', 'z q')) AGAINST('(!x | y <-> z) <-> q') AS "x";
SELECT MATCH(TO_TSVECTOR('simple', 'x y q')) AGAINST('(!x | y) <-> y <-> q') AS "x";
SELECT MATCH(TO_TSVECTOR('simple', 'x y q')) AGAINST('(!x | !y) <-> y <-> q') AS "x";
SELECT MATCH(TO_TSVECTOR('simple', 'x y q')) AGAINST('(x | !y) <-> y <-> q') AS "x";
SELECT MATCH(TO_TSVECTOR('simple', 'x y q')) AGAINST('(x | !!z) <-> y <-> q') AS "x";
SELECT MATCH(TO_TSVECTOR('simple', 'x y q y')) AGAINST('!x <-> y') AS "x";
SELECT MATCH(TO_TSVECTOR('simple', 'x y q y')) AGAINST('!x <-> !y') AS "x";
SELECT MATCH(TO_TSVECTOR('simple', 'x y q y')) AGAINST('!x <-> !!y') AS "x";
SELECT MATCH(TO_TSVECTOR('simple', 'x y q y')) AGAINST('!(x <-> y)') AS "x";
SELECT MATCH(TO_TSVECTOR('simple', 'x y q y')) AGAINST('!(x <2> y)') AS "x";
SELECT MATCH(STRIP(TO_TSVECTOR('simple', 'x y q y'))) AGAINST('!x <-> y') AS "x";
SELECT MATCH(STRIP(TO_TSVECTOR('simple', 'x y q y'))) AGAINST('!x <-> !y') AS "x";
SELECT MATCH(STRIP(TO_TSVECTOR('simple', 'x y q y'))) AGAINST('!x <-> !!y') AS "x";
SELECT MATCH(STRIP(TO_TSVECTOR('simple', 'x y q y'))) AGAINST('!(x <-> y)') AS "x";
SELECT MATCH(STRIP(TO_TSVECTOR('simple', 'x y q y'))) AGAINST('!(x <2> y)') AS "x";
SELECT MATCH(TO_TSVECTOR('simple', 'x y q y')) AGAINST('!foo') AS "x";
SELECT MATCH(TO_TSVECTOR('simple', '')) AGAINST('!foo') AS "x";
/* ranking */ SELECT TS_RANK(CAST(' a:1 s:2C d g' AS tsvector), 'a | s');
SELECT TS_RANK(CAST(' a:1 sa:2C d g' AS tsvector), 'a | s');
SELECT TS_RANK(CAST(' a:1 sa:2C d g' AS tsvector), 'a | s:*');
SELECT TS_RANK(CAST(' a:1 sa:2C d g' AS tsvector), 'a | sa:*');
SELECT TS_RANK(CAST(' a:1 s:2B d g' AS tsvector), 'a | s');
SELECT TS_RANK(CAST(' a:1 s:2 d g' AS tsvector), 'a | s');
SELECT TS_RANK(CAST(' a:1 s:2C d g' AS tsvector), 'a & s');
SELECT TS_RANK(CAST(' a:1 s:2B d g' AS tsvector), 'a & s');
SELECT TS_RANK(CAST(' a:1 s:2 d g' AS tsvector), 'a & s');
SELECT TS_RANK_CD(CAST(' a:1 s:2C d g' AS tsvector), 'a | s');
SELECT TS_RANK_CD(CAST(' a:1 sa:2C d g' AS tsvector), 'a | s');
SELECT TS_RANK_CD(CAST(' a:1 sa:2C d g' AS tsvector), 'a | s:*');
SELECT TS_RANK_CD(CAST(' a:1 sa:2C d g' AS tsvector), 'a | sa:*');
SELECT TS_RANK_CD(CAST(' a:1 sa:3C sab:2c d g' AS tsvector), 'a | sa:*');
SELECT TS_RANK_CD(CAST(' a:1 s:2B d g' AS tsvector), 'a | s');
SELECT TS_RANK_CD(CAST(' a:1 s:2 d g' AS tsvector), 'a | s');
SELECT TS_RANK_CD(CAST(' a:1 s:2C d g' AS tsvector), 'a & s');
SELECT TS_RANK_CD(CAST(' a:1 s:2B d g' AS tsvector), 'a & s');
SELECT TS_RANK_CD(CAST(' a:1 s:2 d g' AS tsvector), 'a & s');
SELECT TS_RANK_CD(CAST(' a:1 s:2A d g' AS tsvector), 'a <-> s');
SELECT TS_RANK_CD(CAST(' a:1 s:2C d g' AS tsvector), 'a <-> s');
SELECT TS_RANK_CD(CAST(' a:1 s:2 d g' AS tsvector), 'a <-> s');
SELECT TS_RANK_CD(CAST(' a:1 s:2 d:2A g' AS tsvector), 'a <-> s');
SELECT TS_RANK_CD(CAST(' a:1 s:2,3A d:2A g' AS tsvector), 'a <2> s:A');
SELECT TS_RANK_CD(CAST(' a:1 b:2 s:3A d:2A g' AS tsvector), 'a <2> s:A');
SELECT TS_RANK_CD(CAST(' a:1 sa:2D sb:2A g' AS tsvector), 'a <-> s:*');
SELECT TS_RANK_CD(CAST(' a:1 sa:2A sb:2D g' AS tsvector), 'a <-> s:*');
SELECT TS_RANK_CD(CAST(' a:1 sa:2A sb:2D g' AS tsvector), 'a <-> s:* <-> sa:A');
SELECT TS_RANK_CD(CAST(' a:1 sa:2A sb:2D g' AS tsvector), 'a <-> s:* <-> sa:B');
SELECT MATCH(CAST('a:1 b:2' AS tsvector)) AGAINST(CAST('a <-> b' AS tsquery)) AS "x";
SELECT MATCH(CAST('a:1 b:2' AS tsvector)) AGAINST(CAST('a <0> b' AS tsquery)) AS "x";
SELECT MATCH(CAST('a:1 b:2' AS tsvector)) AGAINST(CAST('a <1> b' AS tsquery)) AS "x";
SELECT MATCH(CAST('a:1 b:2' AS tsvector)) AGAINST(CAST('a <2> b' AS tsquery)) AS "x";
SELECT MATCH(CAST('a:1 b:3' AS tsvector)) AGAINST(CAST('a <-> b' AS tsquery)) AS "x";
SELECT MATCH(CAST('a:1 b:3' AS tsvector)) AGAINST(CAST('a <0> b' AS tsquery)) AS "x";
SELECT MATCH(CAST('a:1 b:3' AS tsvector)) AGAINST(CAST('a <1> b' AS tsquery)) AS "x";
SELECT MATCH(CAST('a:1 b:3' AS tsvector)) AGAINST(CAST('a <2> b' AS tsquery)) AS "x";
SELECT MATCH(CAST('a:1 b:3' AS tsvector)) AGAINST(CAST('a <3> b' AS tsquery)) AS "x";
SELECT MATCH(CAST('a:1 b:3' AS tsvector)) AGAINST(CAST('a <0> a:*' AS tsquery)) AS "x";
/* tsvector editing operations */ SELECT STRIP(CAST('w:12B w:13* w:12,5,6 a:1,3* a:3 w asd:1dc asd' AS tsvector));
SELECT STRIP(CAST('base:7 hidden:6 rebel:1 spaceship:2,33A,34B,35C,36D strike:3' AS tsvector));
SELECT STRIP(CAST('base hidden rebel spaceship strike' AS tsvector));
SELECT TS_DELETE(TO_TSVECTOR('english', 'Rebel spaceships, striking from a hidden base'), 'spaceship');
SELECT TS_DELETE(CAST('base:7 hidden:6 rebel:1 spaceship:2,33A,34B,35C,36D strike:3' AS tsvector), 'base');
SELECT TS_DELETE(CAST('base:7 hidden:6 rebel:1 spaceship:2,33A,34B,35C,36D strike:3' AS tsvector), 'bas');
SELECT TS_DELETE(CAST('base:7 hidden:6 rebel:1 spaceship:2,33A,34B,35C,36D strike:3' AS tsvector), 'bases');
SELECT TS_DELETE(CAST('base:7 hidden:6 rebel:1 spaceship:2,33A,34B,35C,36D strike:3' AS tsvector), 'spaceship');
SELECT TS_DELETE(CAST('base hidden rebel spaceship strike' AS tsvector), 'spaceship');
SELECT TS_DELETE(CAST('base:7 hidden:6 rebel:1 spaceship:2,33A,34B,35C,36D strike:3' AS tsvector), ARRAY('spaceship', 'rebel'));
SELECT TS_DELETE(CAST('base:7 hidden:6 rebel:1 spaceship:2,33A,34B,35C,36D strike:3' AS tsvector), ARRAY('spaceships', 'rebel'));
SELECT TS_DELETE(CAST('base:7 hidden:6 rebel:1 spaceship:2,33A,34B,35C,36D strike:3' AS tsvector), ARRAY('spaceshi', 'rebel'));
SELECT TS_DELETE(CAST('base:7 hidden:6 rebel:1 spaceship:2,33A,34B,35C,36D strike:3' AS tsvector), ARRAY('spaceship', 'leya', 'rebel'));
SELECT TS_DELETE(CAST('base hidden rebel spaceship strike' AS tsvector), ARRAY('spaceship', 'leya', 'rebel'));
SELECT TS_DELETE(CAST('base hidden rebel spaceship strike' AS tsvector), ARRAY('spaceship', 'leya', 'rebel', 'rebel'));
SELECT TS_DELETE(CAST('base hidden rebel spaceship strike' AS tsvector), ARRAY('spaceship', 'leya', 'rebel', '', NULL));
SELECT EXPLODE(CAST('base:7 hidden:6 rebel:1 spaceship:2,33A,34B,35C,36D strike:3' AS tsvector));
SELECT EXPLODE(CAST('base hidden rebel spaceship strike' AS tsvector));
SELECT * FROM UNNEST(CAST('base:7 hidden:6 rebel:1 spaceship:2,33A,34B,35C,36D strike:3' AS tsvector));
SELECT * FROM UNNEST(CAST('base hidden rebel spaceship strike' AS tsvector));
SELECT x, x[0] FROM UNNEST(CAST('base:7 hidden:6 rebel:1 spaceship:2,33A,34B,35C,36D strike:3' AS tsvector));
SELECT TSVECTOR_TO_ARRAY(CAST('base:7 hidden:6 rebel:1 spaceship:2,33A,34B,35C,36D strike:3' AS tsvector));
SELECT TSVECTOR_TO_ARRAY(CAST('base hidden rebel spaceship strike' AS tsvector));
SELECT ARRAY_TO_TSVECTOR(ARRAY('base', 'hidden', 'rebel', 'spaceship', 'strike'));
/* null and empty string are disallowed, since we mustn't make an empty lexeme */ SELECT ARRAY_TO_TSVECTOR(ARRAY('base', 'hidden', 'rebel', 'spaceship', NULL));
SELECT ARRAY_TO_TSVECTOR(ARRAY('base', 'hidden', 'rebel', 'spaceship', ''));
/* array_to_tsvector must sort and de-dup */ SELECT ARRAY_TO_TSVECTOR(ARRAY('foo', 'bar', 'baz', 'bar'));
SELECT SETWEIGHT(CAST('w:12B w:13* w:12,5,6 a:1,3* a:3 w asd:1dc asd zxc:81,567,222A' AS tsvector), 'c');
SELECT SETWEIGHT(CAST('a:1,3A asd:1C w:5,6,12B,13A zxc:81,222A,567' AS tsvector), 'c');
SELECT SETWEIGHT(CAST('a:1,3A asd:1C w:5,6,12B,13A zxc:81,222A,567' AS tsvector), 'c', '{a}');
SELECT SETWEIGHT(CAST('a:1,3A asd:1C w:5,6,12B,13A zxc:81,222A,567' AS tsvector), 'c', '{a}');
SELECT SETWEIGHT(CAST('a:1,3A asd:1C w:5,6,12B,13A zxc:81,222A,567' AS tsvector), 'c', '{a,zxc}');
SELECT SETWEIGHT(CAST('a asd w:5,6,12B,13A zxc' AS tsvector), 'c', ARRAY('a', 'zxc', '', NULL));
SELECT TS_FILTER(CAST('base:7A empir:17 evil:15 first:11 galact:16 hidden:6A rebel:1A spaceship:2A strike:3A victori:12 won:9' AS tsvector), '{a}');
SELECT TS_FILTER(CAST('base hidden rebel spaceship strike' AS tsvector), '{a}');
SELECT TS_FILTER(CAST('base hidden rebel spaceship strike' AS tsvector), '{a,b,NULL}');
SET x = 0 /* only use parallelism when explicitly intending to do so */;
SET x = 0;
/* A table with contents that, when sorted, triggers abbreviated */ /* key aborts. One easy way to achieve that is to use uuids that all */ /* have the same prefix, as abbreviated keys for uuids just use the */ /* first sizeof(Datum) bytes. */ CREATE TEMPORARY TABLE x (x SERIAL NOT NULL, x UUID, x UUID, x UUID, x UUID);
INSERT INTO x (x, x, x, x) SELECT CAST(('00000000-0000-0000-0000-' || TIME_TO_STR(x.x, '000000000000FM')) AS UUID) AS x, CAST(('00000000-0000-0000-0000-' || TIME_TO_STR(20000 - x.x, '000000000000FM')) AS UUID) AS x, CAST((TIME_TO_STR(x.x % 10009, '00000000FM') || '-0000-0000-0000-' || TIME_TO_STR(x.x, '000000000000FM')) AS UUID) AS x, CAST((TIME_TO_STR(((20000 - x.x) % 10009), '00000000FM') || '-0000-0000-0000-' || TIME_TO_STR(20000 - x.x, '000000000000FM')) AS UUID) AS x FROM x AS x;
/* and a few NULLs */ INSERT INTO x (x) VALUES (0);
/* add just a few duplicates */ INSERT INTO x (x, x, x, x) SELECT x, x, x, x FROM x WHERE (x < 10 OR x > 19990) AND x % 3 = 0 AND NOT x IS NULL;
/* -- */ /* Check sort node uses of tuplesort wrt. abbreviated keys */ /* -- */ /* plain sort triggering abbreviated abort */ SELECT x, x FROM x ORDER BY x NULLS LAST OFFSET 20000 - 4;
SELECT x, x FROM x ORDER BY x OFFSET 20000 - 4;
/* plain sort not triggering abbreviated abort */ SELECT x, x FROM x ORDER BY x NULLS LAST OFFSET 20000 - 4;
SELECT x, x FROM x ORDER BY x OFFSET 20000 - 4;
/* bounded sort (disables abbreviated keys) */ SELECT x, x FROM x ORDER BY x NULLS LAST LIMIT 5;
SELECT x, x FROM x ORDER BY x LIMIT 5;
/* -- */ /* Check index creation uses of tuplesort wrt. abbreviated keys */ /* -- */ /* index creation using abbreviated keys successfully */ CREATE INDEX x ON x(x NULLS LAST);
CREATE INDEX x ON x(x NULLS LAST);
/* verify */ EXPLAIN (COSTS OFF) SELECT id, noabort_increasing, noabort_decreasing FROM abbrev_abort_uuids ORDER BY noabort_increasing LIMIT 5;
SELECT x, x, x FROM x ORDER BY x NULLS LAST LIMIT 5;
EXPLAIN (COSTS OFF) SELECT id, noabort_increasing, noabort_decreasing FROM abbrev_abort_uuids ORDER BY noabort_decreasing LIMIT 5;
SELECT x, x, x FROM x ORDER BY x NULLS LAST LIMIT 5;
/* index creation using abbreviated keys, hitting abort */ CREATE INDEX x ON x(x NULLS LAST);
CREATE INDEX x ON x(x NULLS LAST);
/* verify */ EXPLAIN (COSTS OFF) SELECT id, abort_increasing, abort_decreasing FROM abbrev_abort_uuids ORDER BY abort_increasing LIMIT 5;
SELECT x, x, x FROM x ORDER BY x NULLS LAST LIMIT 5;
EXPLAIN (COSTS OFF) SELECT id, abort_increasing, abort_decreasing FROM abbrev_abort_uuids ORDER BY abort_decreasing LIMIT 5;
SELECT x, x, x FROM x ORDER BY x NULLS LAST LIMIT 5;
/* -- */ /* Check CLUSTER uses of tuplesort wrt. abbreviated keys */ /* -- */ /* when aborting, increasing order */ BEGIN;
SET LOCAL x = FALSE;
/* head */ SELECT x, x, x, x, x FROM x ORDER BY x NULLS LAST LIMIT 5;
/* tail */ SELECT x, x, x, x, x FROM x ORDER BY x DESC NULLS FIRST LIMIT 5;
ROLLBACK;
/* when aborting, decreasing order */ BEGIN;
SET LOCAL x = FALSE;
/* head */ SELECT x, x, x, x, x FROM x ORDER BY x NULLS LAST LIMIT 5;
/* tail */ SELECT x, x, x, x, x FROM x ORDER BY x DESC NULLS FIRST LIMIT 5;
ROLLBACK;
/* when not aborting, increasing order */ BEGIN;
SET LOCAL x = FALSE;
/* head */ SELECT x, x, x, x, x FROM x ORDER BY x NULLS LAST LIMIT 5;
/* tail */ SELECT x, x, x, x, x FROM x ORDER BY x DESC NULLS FIRST LIMIT 5;
ROLLBACK;
/* when no aborting, decreasing order */ BEGIN;
SET LOCAL x = FALSE;
/* head */ SELECT x, x, x, x, x FROM x ORDER BY x NULLS LAST LIMIT 5;
/* tail */ SELECT x, x, x, x, x FROM x ORDER BY x DESC NULLS FIRST LIMIT 5;
ROLLBACK;
/* -- */ /* test sorting of large datums VALUES */ /* -- */ /* Ensure the order is correct and values look intact */ SELECT LEFT(x, 10), x FROM (VALUES (REPEAT('a', 512 * 1024), 1), (REPEAT('b', 512 * 1024), 2)) AS x ORDER BY x.x DESC NULLS FIRST;
/* -- */ /* test forward and backward scans for in-memory and disk based tuplesort */ /* -- */ /* in-memory */ BEGIN;
SET LOCAL x = FALSE;
/* unfortunately can't show analyze output confirming sort method, */ /* the memory used output wouldn't be stable */ EXPLAIN (COSTS OFF) DECLARE c SCROLL CURSOR FOR SELECT noabort_decreasing FROM abbrev_abort_uuids ORDER BY noabort_decreasing;
DECLARE c SCROLL CURSOR FOR SELECT noabort_decreasing FROM abbrev_abort_uuids ORDER BY noabort_decreasing;
/* first and second */ FETCH NEXT FROM c;
FETCH NEXT FROM c;
/* scroll beyond beginning */ FETCH BACKWARD FROM c;
FETCH BACKWARD FROM c;
FETCH BACKWARD FROM c;
FETCH BACKWARD FROM c;
FETCH NEXT FROM c;
/* scroll beyond end */ FETCH LAST FROM c;
FETCH BACKWARD FROM c;
FETCH NEXT FROM c;
FETCH NEXT FROM c;
FETCH NEXT FROM c;
FETCH BACKWARD FROM c;
FETCH NEXT FROM c;
COMMIT;
/* disk based */ BEGIN;
SET LOCAL x = FALSE;
SET LOCAL x = '100kB';
/* unfortunately can't show analyze output confirming sort method, */ /* the memory used output wouldn't be stable */ EXPLAIN (COSTS OFF) DECLARE c SCROLL CURSOR FOR SELECT noabort_decreasing FROM abbrev_abort_uuids ORDER BY noabort_decreasing;
DECLARE c SCROLL CURSOR FOR SELECT noabort_decreasing FROM abbrev_abort_uuids ORDER BY noabort_decreasing;
/* first and second */ FETCH NEXT FROM c;
FETCH NEXT FROM c;
/* scroll beyond beginning */ FETCH BACKWARD FROM c;
FETCH BACKWARD FROM c;
FETCH BACKWARD FROM c;
FETCH BACKWARD FROM c;
FETCH NEXT FROM c;
/* scroll beyond end */ FETCH LAST FROM c;
FETCH BACKWARD FROM c;
FETCH NEXT FROM c;
FETCH NEXT FROM c;
FETCH NEXT FROM c;
FETCH BACKWARD FROM c;
FETCH NEXT FROM c;
COMMIT;
/* -- */ /* test tuplesort using both in-memory and disk sort */ /* - */ /* memory based */ SELECT (ARRAY_AGG(x ORDER BY x DESC NULLS FIRST)) /* fixed-width by-value datum */[0 : 5], (ARRAY_AGG(x ORDER BY x DESC)) /* fixed-width by-ref datum */[0 : 5], (ARRAY_AGG(CAST(x AS TEXT) ORDER BY CAST(x AS TEXT) DESC)) /* variable-width datum */[0 : 5], PERCENTILE_DISC(0.99) /* fixed width by-value datum tuplesort */ WITHIN GROUP (ORDER BY x NULLS LAST), PERCENTILE_DISC(0.01) /* ensure state is shared */ WITHIN GROUP (ORDER BY x NULLS LAST), PERCENTILE_DISC(0.8) /* fixed width by-ref datum tuplesort */ WITHIN GROUP (ORDER BY x NULLS LAST), PERCENTILE_DISC(0.2) /* variable width by-ref datum tuplesort */ WITHIN GROUP (ORDER BY CAST(x AS TEXT) NULLS LAST), RANK('00000000-0000-0000-0000-000000000000', '2', '2') /* multi-column tuplesort */ WITHIN GROUP (ORDER BY x NULLS LAST, x NULLS LAST, CAST(x AS TEXT) NULLS LAST) FROM (SELECT * FROM x UNION ALL SELECT NULL, NULL, NULL, NULL, NULL) AS x;
/* disk based (see also above) */ BEGIN;
SET LOCAL x = '100kB';
SELECT (ARRAY_AGG(x ORDER BY x DESC NULLS FIRST))[0 : 5], (ARRAY_AGG(x ORDER BY x DESC))[0 : 5], (ARRAY_AGG(CAST(x AS TEXT) ORDER BY CAST(x AS TEXT) DESC))[0 : 5], PERCENTILE_DISC(0.99) WITHIN GROUP (ORDER BY x NULLS LAST), PERCENTILE_DISC(0.01) WITHIN GROUP (ORDER BY x NULLS LAST), PERCENTILE_DISC(0.8) WITHIN GROUP (ORDER BY x NULLS LAST), PERCENTILE_DISC(0.2) WITHIN GROUP (ORDER BY CAST(x AS TEXT) NULLS LAST), RANK('00000000-0000-0000-0000-000000000000', '2', '2') WITHIN GROUP (ORDER BY x NULLS LAST, x NULLS LAST, CAST(x AS TEXT) NULLS LAST) FROM (SELECT * FROM x UNION ALL SELECT NULL, NULL, NULL, NULL, NULL) AS x;
ROLLBACK;
/* -- */ /* test tuplesort mark/restore */ /* - */ CREATE TEMPORARY TABLE x (x INT, x INT, x INT);
/* need a few duplicates for mark/restore to matter */ INSERT INTO x (x, x, x) SELECT x.x, x.x, x.x * x.x FROM x AS x, x AS x;
BEGIN;
SET LOCAL x = off;
SET LOCAL x = off;
SET LOCAL x = off;
:qry;
SET LOCAL x = '100kB' /* test mark/restore with on-disk sorts */;
EXPLAIN (COSTS OFF) :qry;
:qry;
COMMIT;
/* txid_snapshot data type and related functions */ /* Note: these are backward-compatibility functions and types, and have been */ /* replaced by new xid8-based variants.  See xid.sql.  The txid variants will */ /* be removed in a future release. */ /* i/o */ SELECT CAST('12:13:' AS txid_snapshot);
SELECT CAST('12:18:14,16' AS txid_snapshot);
SELECT CAST('12:16:14,14' AS txid_snapshot);
/* errors */ SELECT CAST('31:12:' AS txid_snapshot);
SELECT CAST('0:1:' AS txid_snapshot);
SELECT CAST('12:13:0' AS txid_snapshot);
SELECT CAST('12:16:14,13' AS txid_snapshot);
CREATE TEMPORARY TABLE x (x INT, x txid_snapshot);
INSERT INTO x VALUES (1, '12:13:');
INSERT INTO x VALUES (2, '12:20:13,15,18');
INSERT INTO x VALUES (3, '100001:100009:100005,100007,100008');
INSERT INTO x VALUES (4, '100:150:101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131');
SELECT x FROM x ORDER BY x NULLS LAST;
SELECT TXID_SNAPSHOT_XMIN(x), TXID_SNAPSHOT_XMAX(x), TXID_SNAPSHOT_XIP(x) FROM x ORDER BY x NULLS LAST;
SELECT x, TXID_VISIBLE_IN_SNAPSHOT(x, x) FROM x, x AS x WHERE x = 2;
/* test bsearch */ SELECT x, TXID_VISIBLE_IN_SNAPSHOT(x, x) FROM x, x AS x WHERE x = 4;
/* test current values also */ SELECT TXID_CURRENT() >= TXID_SNAPSHOT_XMIN(TXID_CURRENT_SNAPSHOT());
/* we can't assume current is always less than xmax, however */ SELECT TXID_VISIBLE_IN_SNAPSHOT(TXID_CURRENT(), TXID_CURRENT_SNAPSHOT());
SELECT TXID_VISIBLE_IN_SNAPSHOT('1000100010001012', '1000100010001000:1000100010001100:1000100010001012,1000100010001013');
SELECT TXID_VISIBLE_IN_SNAPSHOT('1000100010001015', '1000100010001000:1000100010001100:1000100010001012,1000100010001013');
/* test txid_current_if_assigned */ BEGIN;
SELECT TXID_CURRENT_IF_ASSIGNED() IS NULL;
COMMIT;
/* test xid status functions */ BEGIN;
BEGIN;
BEGIN;
SELECT TXID_STATUS(:rolledback) AS x;
SELECT TXID_STATUS(:inprogress) AS x;
SELECT TXID_STATUS(1);
/* BootstrapTransactionId is always committed */ SELECT TXID_STATUS(2);
/* FrozenTransactionId is always committed */ SELECT TXID_STATUS(3);
COMMIT /* in regress testing FirstNormalTransactionId will always be behind oldestXmin */ /* in regress testing FirstNormalTransactionId will always be behind oldestXmin */;
BEGIN;
COMMIT;
SELECT TEST_FUTURE_XID_STATUS(:inprogress + 10000);
ROLLBACK;
CREATE TABLE ttable1 OF nothing;
CREATE TYPE person_type AS (id int, name text);
CREATE TABLE persons OF person_type;
CREATE TABLE IF NOT EXISTS persons OF person_type;
SELECT * FROM x;
SELECT * FROM x;
ALTER TABLE x ADD COLUMN x TEXT /* certain ALTER TABLE operations on typed tables are not allowed */;
ALTER TABLE x DROP COLUMN x;
ALTER TABLE x RENAME COLUMN x TO x;
ALTER TABLE x ALTER COLUMN x SET DATA TYPE VARCHAR;
CREATE TABLE x (x INT);
ALTER TABLE persons INHERIT stuff;
CREATE TABLE personsx OF person_type (myname WITH OPTIONS NOT NULL);
/* error */ CREATE TABLE persons2 OF person_type (     id WITH OPTIONS PRIMARY KEY,     UNIQUE (name) );
DROP TYPE person_type RESTRICT;
DROP TYPE person_type CASCADE;
CREATE TABLE persons5 OF stuff;
/* only CREATE TYPE AS types may be used */ CREATE TYPE tt_enum_type AS ENUM ('a');
CREATE TABLE of_tt_enum_type OF tt_enum_type;
/* not a composite type at all */ DROP TYPE tt_enum_type;
DROP TABLE x;
/* implicit casting */ CREATE TYPE person_type AS (id int, name text);
CREATE TABLE persons OF person_type;
INSERT INTO x VALUES (1, 'test');
CREATE FUNCTION x(x) RETURNS INT LANGUAGE SQL AS $$ SELECT length($1.name) $$;
SELECT x, NAMELEN(x) FROM x;
CREATE TABLE persons2 OF person_type (     id WITH OPTIONS PRIMARY KEY,     UNIQUE (name) );
/* Look for "pass by value" types that can't be passed by value. */ SELECT x.x, x.x FROM x AS x WHERE x.x AND (x.x <> 1 OR x.x <> 'c') AND (x.x <> 2 OR x.x <> 's') AND (x.x <> 4 OR x.x <> 'i') AND (x.x <> 8 OR x.x <> 'd');
/* Look for "toastable" types that aren't varlena. */ SELECT x.x, x.x FROM x AS x WHERE x.x <> 'p' AND (x.x OR x.x <> -1);
/* Look for complex types that do not have a typrelid entry, */ /* or basic types that do. */ SELECT x.x, x.x FROM x AS x WHERE (x.x = 'c' AND x.x = 0) OR (x.x <> 'c' AND x.x <> 0);
/* Look for types that should have an array type but don't. */ /* Generally anything that's not a pseudotype should have an array type. */ /* However, we do have a small number of exceptions. */ SELECT x.x, x.x FROM x AS x WHERE NOT x.x IN ('p') AND NOT x.x LIKE \\_% AND NOT EXISTS(SELECT 1 FROM x AS x WHERE x.x = CAST(('_' || x.x) AS NAME) AND x.x = x.x AND x.x = x.x) ORDER BY x.x NULLS LAST;
/* Make sure typarray points to a "true" array type of our own base */ SELECT x.x, x.x AS x, x.x AS x, x.x FROM x AS x LEFT JOIN x AS x ON (x.x = x.x) WHERE x.x <> 0 AND (x.x IS NULL OR x.x <> CAST('array_subscript_handler' AS REGPROC));
/* Look for range types that do not have a pg_range entry */ SELECT x.x, x.x FROM x AS x WHERE x.x = 'r' AND NOT EXISTS(SELECT 1 FROM x AS x WHERE x = x.x);
/* Look for range types whose typalign isn't sufficient */ SELECT x.x, x.x, x.x, x.x, x.x FROM x AS x LEFT JOIN x AS x ON x = x.x LEFT JOIN x AS x ON x = x.x WHERE x.x = 'r' AND (x.x <> (CASE WHEN x.x = 'd' THEN CAST('d' AS CHAR) ELSE CAST('i' AS CHAR) END) OR x.x IS NULL);
/* Text conversion routines must be provided. */ SELECT x.x, x.x FROM x AS x WHERE (x.x = 0 OR x.x = 0);
/* Check for bogus typinput routines */ SELECT x.x, x.x, x.x, x.x FROM x AS x, x AS x WHERE x.x = x.x AND NOT ((x.x = 1 AND x.x[-1] = CAST('cstring' AS REGTYPE)) OR (x.x = 2 AND x.x[-1] = CAST('cstring' AS REGTYPE) AND x.x[0] = CAST('oid' AS REGTYPE)) OR (x.x = 3 AND x.x[-1] = CAST('cstring' AS REGTYPE) AND x.x[0] = CAST('oid' AS REGTYPE) AND x.x[1] = CAST('int4' AS REGTYPE)));
/* As of 8.0, this check finds refcursor, which is borrowing */ /* other types' I/O routines */ SELECT x.x, x.x, x.x, x.x FROM x AS x, x AS x WHERE x.x = x.x AND x.x IN ('b', 'p') AND NOT (x.x <> 0 AND x.x < 0) AND NOT (x.x = x.x AND NOT x.x) ORDER BY 1 NULLS LAST;
/* Varlena array types will point to array_in */ /* Exception as of 8.1: int2vector and oidvector have their own I/O routines */ SELECT x.x, x.x, x.x, x.x FROM x AS x, x AS x WHERE x.x = x.x AND (x.x <> 0 AND x.x < 0) AND NOT (x.x = CAST('array_in' AS REGPROC)) ORDER BY 1 NULLS LAST;
/* typinput routines should not be volatile */ SELECT x.x, x.x, x.x, x.x FROM x AS x, x AS x WHERE x.x = x.x AND NOT x.x IN ('i', 's');
/* Composites, domains, enums, multiranges, ranges should all use the same input routines */ SELECT DISTINCT x, x FROM x AS x WHERE NOT x.x IN ('b', 'p') ORDER BY 1 NULLS LAST;
/* Check for bogus typoutput routines */ /* As of 8.0, this check finds refcursor, which is borrowing */ /* other types' I/O routines */ SELECT x.x, x.x, x.x, x.x FROM x AS x, x AS x WHERE x.x = x.x AND x.x IN ('b', 'p') AND NOT (x.x = 1 AND (x.x[-1] = x.x OR (x.x = CAST('array_out' AS REGPROC) AND x.x <> 0 AND x.x = -1))) ORDER BY 1 NULLS LAST;
SELECT x.x, x.x, x.x, x.x FROM x AS x, x AS x WHERE x.x = x.x AND NOT (x.x = CAST('cstring' AS REGTYPE) AND NOT x.x);
/* typoutput routines should not be volatile */ SELECT x.x, x.x, x.x, x.x FROM x AS x, x AS x WHERE x.x = x.x AND NOT x.x IN ('i', 's');
/* Composites, enums, multiranges, ranges should all use the same output routines */ SELECT DISTINCT x, x FROM x AS x WHERE NOT x.x IN ('b', 'd', 'p') ORDER BY 1 NULLS LAST;
/* Domains should have same typoutput as their base types */ SELECT x.x, x.x, x.x, x.x FROM x AS x LEFT JOIN x AS x ON x.x = x.x WHERE x.x = 'd' AND x.x IS DISTINCT FROM x.x;
/* Check for bogus typreceive routines */ SELECT x.x, x.x, x.x, x.x FROM x AS x, x AS x WHERE x.x = x.x AND NOT ((x.x = 1 AND x.x[-1] = CAST('internal' AS REGTYPE)) OR (x.x = 2 AND x.x[-1] = CAST('internal' AS REGTYPE) AND x.x[0] = CAST('oid' AS REGTYPE)) OR (x.x = 3 AND x.x[-1] = CAST('internal' AS REGTYPE) AND x.x[0] = CAST('oid' AS REGTYPE) AND x.x[1] = CAST('int4' AS REGTYPE)));
/* As of 7.4, this check finds refcursor, which is borrowing */ /* other types' I/O routines */ SELECT x.x, x.x, x.x, x.x FROM x AS x, x AS x WHERE x.x = x.x AND x.x IN ('b', 'p') AND NOT (x.x <> 0 AND x.x < 0) AND NOT (x.x = x.x AND NOT x.x) ORDER BY 1 NULLS LAST;
/* Varlena array types will point to array_recv */ /* Exception as of 8.1: int2vector and oidvector have their own I/O routines */ SELECT x.x, x.x, x.x, x.x FROM x AS x, x AS x WHERE x.x = x.x AND (x.x <> 0 AND x.x < 0) AND NOT (x.x = CAST('array_recv' AS REGPROC)) ORDER BY 1 NULLS LAST;
/* Suspicious if typreceive doesn't take same number of args as typinput */ SELECT x.x, x.x, x.x, x.x, x.x, x.x FROM x AS x, x AS x, x AS x WHERE x.x = x.x AND x.x = x.x AND x.x <> x.x;
/* typreceive routines should not be volatile */ SELECT x.x, x.x, x.x, x.x FROM x AS x, x AS x WHERE x.x = x.x AND NOT x.x IN ('i', 's');
/* Composites, domains, enums, multiranges, ranges should all use the same receive routines */ SELECT DISTINCT x, x FROM x AS x WHERE NOT x.x IN ('b', 'p') ORDER BY 1 NULLS LAST;
/* Check for bogus typsend routines */ /* As of 7.4, this check finds refcursor, which is borrowing */ /* other types' I/O routines */ SELECT x.x, x.x, x.x, x.x FROM x AS x, x AS x WHERE x.x = x.x AND x.x IN ('b', 'p') AND NOT (x.x = 1 AND (x.x[-1] = x.x OR (x.x = CAST('array_send' AS REGPROC) AND x.x <> 0 AND x.x = -1))) ORDER BY 1 NULLS LAST;
SELECT x.x, x.x, x.x, x.x FROM x AS x, x AS x WHERE x.x = x.x AND NOT (x.x = CAST('bytea' AS REGTYPE) AND NOT x.x);
/* typsend routines should not be volatile */ SELECT x.x, x.x, x.x, x.x FROM x AS x, x AS x WHERE x.x = x.x AND NOT x.x IN ('i', 's');
/* Composites, enums, multiranges, ranges should all use the same send routines */ SELECT DISTINCT x, x FROM x AS x WHERE NOT x.x IN ('b', 'd', 'p') ORDER BY 1 NULLS LAST;
/* Domains should have same typsend as their base types */ SELECT x.x, x.x, x.x, x.x FROM x AS x LEFT JOIN x AS x ON x.x = x.x WHERE x.x = 'd' AND x.x IS DISTINCT FROM x.x;
/* Check for bogus typmodin routines */ SELECT x.x, x.x, x.x, x.x FROM x AS x, x AS x WHERE x.x = x.x AND NOT (x.x = 1 AND x.x[-1] = CAST('cstring[]' AS REGTYPE) AND x.x = CAST('int4' AS REGTYPE) AND NOT x.x);
/* typmodin routines should not be volatile */ SELECT x.x, x.x, x.x, x.x FROM x AS x, x AS x WHERE x.x = x.x AND NOT x.x IN ('i', 's');
/* Check for bogus typmodout routines */ SELECT x.x, x.x, x.x, x.x FROM x AS x, x AS x WHERE x.x = x.x AND NOT (x.x = 1 AND x.x[-1] = CAST('int4' AS REGTYPE) AND x.x = CAST('cstring' AS REGTYPE) AND NOT x.x);
/* typmodout routines should not be volatile */ SELECT x.x, x.x, x.x, x.x FROM x AS x, x AS x WHERE x.x = x.x AND NOT x.x IN ('i', 's');
/* Array types should have same typmodin/out as their element types */ SELECT x.x, x.x, x.x, x.x FROM x AS x, x AS x WHERE x.x = x.x AND NOT (x.x = x.x AND x.x = x.x);
/* Array types should have same typdelim as their element types */ SELECT x.x, x.x, x.x, x.x FROM x AS x, x AS x WHERE x.x = x.x AND NOT (x.x = x.x);
/* Look for array types whose typalign isn't sufficient */ SELECT x.x, x.x, x.x, x.x, x.x FROM x AS x, x AS x WHERE x.x = x.x AND x.x <> (CASE WHEN x.x = 'd' THEN CAST('d' AS CHAR) ELSE CAST('i' AS CHAR) END);
/* Check for typelem set without a handler */ SELECT x.x, x.x, x.x FROM x AS x WHERE x.x <> 0 AND x.x = 0;
/* Check for misuse of standard subscript handlers */ SELECT x.x, x.x, x.x, x.x, x.x FROM x AS x WHERE x.x = CAST('array_subscript_handler' AS REGPROC) AND NOT (x.x <> 0 AND x.x = -1 AND NOT x.x);
SELECT x.x, x.x, x.x, x.x, x.x FROM x AS x WHERE x.x = CAST('raw_array_subscript_handler' AS REGPROC) AND NOT (x.x <> 0 AND x.x > 0 AND NOT x.x);
/* Check for bogus typanalyze routines */ SELECT x.x, x.x, x.x, x.x FROM x AS x, x AS x WHERE x.x = x.x AND NOT (x.x = 1 AND x.x[-1] = CAST('internal' AS REGTYPE) AND x.x = CAST('bool' AS REGTYPE) AND NOT x.x);
/* there does not seem to be a reason to care about volatility of typanalyze */ /* domains inherit their base type's typanalyze */ SELECT x.x, x.x, x.x, x.x, x.x, x.x FROM x AS x JOIN x AS x ON x.x = x.x WHERE x.x <> x.x;
/* range_typanalyze should be used for all and only range types */ /* (but exclude domains, which we checked above) */ SELECT x.x, x.x, x.x FROM x AS x LEFT JOIN x AS x ON x.x = x.x WHERE x.x = 0 AND (x.x = CAST('range_typanalyze' AS REGPROC)) <> (NOT x.x IS NULL);
/* array_typanalyze should be used for all and only array types */ /* (but exclude domains, which we checked above) */ /* As of 9.2 this finds int2vector and oidvector, which are weird anyway */ SELECT x.x, x.x, x.x FROM x AS x WHERE x.x = 0 AND (x.x = CAST('array_typanalyze' AS REGPROC)) <> (x.x = CAST('array_subscript_handler' AS REGPROC)) ORDER BY 1 NULLS LAST;
/* **************** pg_class **************** */ /* Look for illegal values in pg_class fields */ SELECT x.x, x.x FROM x AS x WHERE NOT x IN ('r', 'i', 'S', 't', 'v', 'm', 'c', 'f', 'p', 'I') OR NOT x IN ('p', 'u', 't') OR NOT x IN ('d', 'n', 'f', 'i');
/* All tables, indexes, partitioned indexes and matviews should have an */ /* access method. */ SELECT x.x, x.x FROM x AS x WHERE NOT x.x IN ('S', 'v', 'f', 'c', 'p') AND x.x = 0;
/* Conversely, sequences, views, foreign tables, types and partitioned */ /* tables shouldn't have them. */ SELECT x.x, x.x FROM x AS x WHERE x.x IN ('S', 'v', 'f', 'c', 'p') AND x.x <> 0;
/* Indexes and partitioned indexes should have AMs of type 'i'. */ SELECT x.x, x.x, x.x, x.x FROM x AS x JOIN x AS x ON (x.x = x.x) WHERE x.x IN ('i', 'I') AND x.x <> 'i';
/* Tables, matviews etc should have AMs of type 't' */ SELECT x.x, x.x, x.x, x.x FROM x AS x JOIN x AS x ON (x.x = x.x) WHERE x.x IN ('r', 't', 'm') AND x.x <> 't';
/* **************** pg_attribute **************** */ /* Look for illegal values in pg_attribute fields */ SELECT x.x, x.x FROM x AS x WHERE x.x = 0 OR x.x = 0 OR x.x = 0 OR x.x < 0 OR (x.x = 0 AND NOT x.x);
/* Cross-check attnum against parent relation */ SELECT x.x, x.x, x.x, x.x FROM x AS x, x AS x WHERE x.x = x.x AND x.x > x.x;
/* Detect missing pg_attribute entries: should have as many non-system */ /* attributes as parent relation expects */ SELECT x.x, x.x FROM x AS x WHERE x.x <> (SELECT COUNT(*) FROM x AS x WHERE x.x = x.x AND x.x > 0);
/* this is mainly for toast tables. */ SELECT x.x, x.x, x.x, x.x FROM x AS x, x AS x WHERE x.x = x.x AND (x.x <> x.x OR x.x <> x.x OR x.x <> x.x OR (x.x <> x.x AND x.x <> 'p'));
/* **************** pg_range **************** */ /* Look for illegal values in pg_range fields. */ SELECT x.x, x.x FROM x AS x WHERE x.x = 0 OR x.x = 0 OR x.x = 0;
/* rngcollation should be specified iff subtype is collatable */ SELECT x.x, x.x, x.x, x.x FROM x AS x JOIN x AS x ON x.x = x.x WHERE (x = 0) <> (x = 0);
/* opclass had better be a btree opclass accepting the subtype. */ /* We must allow anyarray matches, cf IsBinaryCoercible() */ SELECT x.x, x.x, x.x, x.x FROM x AS x JOIN x AS x ON x.x = x.x WHERE x.x <> 403 OR ((x.x <> x.x) AND NOT (x.x = CAST('pg_catalog.anyarray' AS REGTYPE) AND EXISTS(SELECT 1 FROM x.x WHERE x = x.x AND x <> 0 AND x = CAST('array_subscript_handler' AS REGPROC))));
/* canonical function, if any, had better match the range type */ SELECT x.x, x.x, x.x FROM x AS x JOIN x AS x ON x.x = x.x WHERE x <> 1 OR x[-1] <> x OR x <> x;
/* subdiff function, if any, had better match the subtype */ SELECT x.x, x.x, x.x FROM x AS x JOIN x AS x ON x.x = x.x WHERE x <> 2 OR x[-1] <> x OR x[0] <> x OR x <> CAST('pg_catalog.float8' AS REGTYPE);
/* every range should have a valid multirange */ SELECT x.x, x.x, x.x FROM x AS x WHERE x.x IS NULL OR x.x = 0;
/* Create a table that holds all the known in-core data types and leave it */ /* around so as pg_upgrade is able to test their binary compatibility. */ CREATE TABLE x AS SELECT CAST('(11,12)' AS point), CAST('(1,1),(2,2)' AS line), CAST('((11,11),(12,12))' AS lseg), CAST('((11,11),(13,13))' AS box), CAST('((11,12),(13,13),(14,14))' AS path) AS x, CAST('[(11,12),(13,13),(14,14)]' AS path) AS x, CAST('((11,12),(13,13),(14,14))' AS polygon), CAST('1,1,1' AS circle), CAST('today' AS DATE), CAST('now' AS TIME), CAST('now' AS TIMESTAMP), CAST('now' AS TIMETZ), CAST('now' AS TIMESTAMPTZ), CAST('12 seconds' AS INTERVAL), CAST('{"reason":"because"}' AS JSON), CAST('{"when":"now"}' AS JSONB), CAST('$.a[*] ? (@ > 2)' AS jsonpath), CAST('127.0.0.1' AS INET), CAST('127.0.0.0/8' AS cidr), CAST('00:01:03:86:1c:ba' AS macaddr8), CAST('00:01:03:86:1c:ba' AS macaddr), CAST(2 AS SMALLINT), CAST(4 AS INT), CAST(8 AS BIGINT), CAST(4 AS FLOAT), CAST('8' AS DOUBLE), CAST(PI() AS DECIMAL), CAST('foo' AS CHAR), CAST('c' AS BPCHAR), CAST('abc' AS VARCHAR), CAST('name' AS NAME), CAST('txt' AS TEXT), CAST(TRUE AS BOOLEAN), CAST(\\xDEADBEEF AS VARBINARY), CAST(17 AS BIT), CAST(17 AS varbit) AS x, CAST('12.34' AS MONEY), CAST('abc' AS refcursor), CAST('1 2' AS int2vector), CAST('1 2' AS oidvector), CAST(FORMAT('%I=UC/%I', x, x) AS aclitem) AS x, CAST('a fat cat sat on a mat and ate a fat rat' AS tsvector), CAST('fat & rat' AS tsquery), CAST('a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11' AS UUID), CAST('11' AS xid8), CAST('pg_class' AS REGCLASS), CAST('regtype' AS REGTYPE) AS x, CAST('pg_monitor' AS REGROLE), CAST(CAST('pg_class' AS REGCLASS) AS OID), CAST('(1,1)' AS tid), CAST('2' AS xid), CAST('3' AS cid), CAST('10:20:10,14,15' AS txid_snapshot), CAST('10:20:10,14,15' AS pg_snapshot), CAST('16/B374D848' AS pg_lsn), CAST(1 AS information_schema.cardinal_number), CAST('l' AS information_schema.character_data), CAST('n' AS information_schema.sql_identifier), CAST('now' AS information_schema.time_stamp), CAST('YES' AS information_schema.yes_or_no), CAST('(1,2)' AS INT4RANGE), CAST('{(1,2)}' AS INT4MULTIRANGE), CAST('(3,4)' AS INT8RANGE), CAST('{(3,4)}' AS INT8MULTIRANGE), CAST('(3,4)' AS NUMRANGE), CAST('{(3,4)}' AS NUMMULTIRANGE), CAST('(2020-01-02, 2021-02-03)' AS DATERANGE), CAST('{(2020-01-02, 2021-02-03)}' AS DATEMULTIRANGE), CAST('(2020-01-02 03:04:05, 2021-02-03 06:07:08)' AS TSRANGE), CAST('{(2020-01-02 03:04:05, 2021-02-03 06:07:08)}' AS TSMULTIRANGE), CAST('(2020-01-02 03:04:05, 2021-02-03 06:07:08)' AS TSTZRANGE), CAST('{(2020-01-02 03:04:05, 2021-02-03 06:07:08)}' AS TSTZMULTIRANGE);
SELECT NOT UNICODE_VERSION() IS NULL;
SELECT UNICODE_ASSIGNED(x & 'abc');
SELECT UNICODE_ASSIGNED(x & 'abc\+10FFFF');
SELECT NORMALIZE('');
SELECT NORMALIZE(x & '\0061\0308\24D1c') = x & '\00E4\24D1c' COLLATE "x" AS x;
SELECT NORMALIZE(x & '\0061\0308\24D1c', NFC) = x & '\00E4\24D1c' COLLATE "x" AS x;
SELECT NORMALIZE(x & '\00E4bc', NFC) = x & '\00E4bc' COLLATE "x" AS x;
SELECT NORMALIZE(x & '\00E4\24D1c', NFD) = x & '\0061\0308\24D1c' COLLATE "x" AS x;
SELECT NORMALIZE(x & '\0061\0308\24D1c', NFKC) = x & '\00E4bc' COLLATE "x" AS x;
SELECT NORMALIZE(x & '\00E4\24D1c', NFKD) = x & '\0061\0308bc' COLLATE "x" AS x;
SELECT IS_NORMALIZED('abc', 'def');
/* UNION (also INTERSECT, EXCEPT) */ /* Simple UNION constructs */ SELECT 1 AS x UNION SELECT 2 ORDER BY 1 NULLS LAST;
SELECT 1 AS x UNION SELECT 1 ORDER BY 1 NULLS LAST;
SELECT 1 AS x UNION ALL SELECT 2;
SELECT 1 AS x UNION ALL SELECT 1;
SELECT 1 AS x UNION SELECT 2 UNION SELECT 3 ORDER BY 1 NULLS LAST;
SELECT 1 AS x UNION SELECT 2 UNION SELECT 2 ORDER BY 1 NULLS LAST;
SELECT 1 AS x UNION SELECT 2 UNION ALL SELECT 2 ORDER BY 1 NULLS LAST;
SELECT 1.1 AS x UNION SELECT 2.2 ORDER BY 1 NULLS LAST;
/* Mixed types */ SELECT 1.1 AS x UNION SELECT 2 ORDER BY 1 NULLS LAST;
SELECT 1 AS x UNION SELECT 2.2 ORDER BY 1 NULLS LAST;
SELECT 1 AS x UNION SELECT CAST(1.0 AS DOUBLE) ORDER BY 1 NULLS LAST;
SELECT 1.1 AS x UNION ALL SELECT 2 ORDER BY 1 NULLS LAST;
SELECT CAST(1.0 AS DOUBLE) AS x UNION ALL SELECT 1 ORDER BY 1 NULLS LAST;
SELECT 1.1 AS x UNION SELECT 2 UNION SELECT 3 ORDER BY 1 NULLS LAST;
SELECT CAST(1.1 AS DOUBLE) AS x UNION SELECT 2 UNION SELECT CAST(2.0 AS DOUBLE) ORDER BY 1 NULLS LAST;
SELECT 1.1 AS x UNION SELECT 2 UNION ALL SELECT 2 ORDER BY 1 NULLS LAST;
SELECT 1.1 AS x UNION (SELECT 2 UNION ALL SELECT 2) ORDER BY 1 NULLS LAST;
/* Try testing from tables... */ SELECT x AS x FROM x UNION SELECT x FROM x ORDER BY 1 NULLS LAST;
SELECT x AS x FROM x UNION ALL SELECT x FROM x;
SELECT x AS x FROM x UNION SELECT x FROM x ORDER BY 1 NULLS LAST;
SELECT x AS x FROM x UNION ALL SELECT x FROM x;
SELECT x AS x FROM x WHERE x BETWEEN -1e6 AND 1e6 UNION SELECT x FROM x WHERE x BETWEEN 0 AND 1000000 ORDER BY 1 NULLS LAST;
SELECT CAST(x AS CHAR(4)) AS x FROM x UNION SELECT x FROM x ORDER BY 1 NULLS LAST;
SELECT x AS x FROM x UNION SELECT CAST(x AS VARCHAR) FROM x ORDER BY 1 NULLS LAST;
SELECT x AS x FROM x UNION ALL SELECT x FROM x;
SELECT x AS x FROM x UNION SELECT x FROM x UNION SELECT RTRIM(x) FROM x ORDER BY 1 NULLS LAST;
/* INTERSECT and EXCEPT */ SELECT x FROM x INTERSECT SELECT x FROM x ORDER BY 1 NULLS LAST;
SELECT x FROM x INTERSECT ALL SELECT x FROM x ORDER BY 1 NULLS LAST;
SELECT x FROM x EXCEPT SELECT x FROM x ORDER BY 1 NULLS LAST;
SELECT x FROM x EXCEPT ALL SELECT x FROM x ORDER BY 1 NULLS LAST;
SELECT x FROM x EXCEPT ALL SELECT DISTINCT x FROM x ORDER BY 1 NULLS LAST;
SELECT x FROM x EXCEPT SELECT x FROM x ORDER BY 1 NULLS LAST;
SELECT x FROM x EXCEPT ALL SELECT x FROM x ORDER BY 1 NULLS LAST;
SELECT x FROM x EXCEPT ALL SELECT DISTINCT x FROM x ORDER BY 1 NULLS LAST;
(SELECT 1, 2, 3 UNION SELECT 4, 5, 6) /* nested cases */ INTERSECT SELECT 4, 5, 6;
(SELECT 1, 2, 3 UNION SELECT 4, 5, 6 ORDER BY 1 NULLS LAST, 2 NULLS LAST) INTERSECT SELECT 4, 5, 6;
(SELECT 1, 2, 3 UNION SELECT 4, 5, 6) EXCEPT SELECT 4, 5, 6;
(SELECT 1, 2, 3 UNION SELECT 4, 5, 6 ORDER BY 1 NULLS LAST, 2 NULLS LAST) EXCEPT SELECT 4, 5, 6;
SET x = on /* exercise both hashed and sorted implementations of UNION/INTERSECT/EXCEPT */;
EXPLAIN (costs off) select count(*) from   ( select unique1 from tenk1 union select fivethous from tenk1 ) ss;
SELECT COUNT(*) FROM (SELECT x FROM x UNION SELECT x FROM x) AS x;
EXPLAIN (costs off) select count(*) from   ( select unique1 from tenk1 intersect select fivethous from tenk1 ) ss;
SELECT COUNT(*) FROM (SELECT x FROM x INTERSECT SELECT x FROM x) AS x;
SET x = off /* this query will prefer a sorted setop unless we force it. */;
EXPLAIN (costs off) select unique1 from tenk1 except select unique2 from tenk1 where unique2 != 10;
SELECT x FROM x EXCEPT SELECT x FROM x WHERE x <> 10;
RESET enable_indexscan;
/* the hashed implementation is sensitive to child plans' tuple slot types */ EXPLAIN (costs off) select * from int8_tbl intersect select q2, q1 from int8_tbl order by 1, 2;
SELECT * FROM x INTERSECT SELECT x, x FROM x ORDER BY 1 NULLS LAST, 2 NULLS LAST;
SELECT x, x FROM x INTERSECT SELECT * FROM x ORDER BY 1 NULLS LAST, 2 NULLS LAST;
SET x = off;
EXPLAIN (costs off) select count(*) from   ( select unique1 from tenk1 union select fivethous from tenk1 ) ss;
SELECT COUNT(*) FROM (SELECT x FROM x UNION SELECT x FROM x) AS x;
EXPLAIN (costs off) select count(*) from   ( select unique1 from tenk1 intersect select fivethous from tenk1 ) ss;
SELECT COUNT(*) FROM (SELECT x FROM x INTERSECT SELECT x FROM x) AS x;
EXPLAIN (costs off) select unique1 from tenk1 except select unique2 from tenk1 where unique2 != 10;
SELECT x FROM x EXCEPT SELECT x FROM x WHERE x <> 10;
EXPLAIN (costs off) select f1 from int4_tbl union all   (select unique1 from tenk1 union select unique2 from tenk1);
RESET enable_hashagg;
SET x = on /* non-hashable type */;
EXPLAIN (costs off) select x from (values ('11'::varbit), ('10'::varbit)) _(x) union select x from (values ('11'::varbit), ('10'::varbit)) _(x);
SET x = off;
EXPLAIN (costs off) select x from (values ('11'::varbit), ('10'::varbit)) _(x) union select x from (values ('11'::varbit), ('10'::varbit)) _(x);
RESET enable_hashagg;
SET x = on /* arrays */;
EXPLAIN (costs off) select x from (values (array[1, 2]), (array[1, 3])) _(x) union select x from (values (array[1, 2]), (array[1, 4])) _(x);
SELECT x FROM (VALUES (ARRAY(1, 2)), (ARRAY(1, 3))) AS x UNION SELECT x FROM (VALUES (ARRAY(1, 2)), (ARRAY(1, 4))) AS x;
EXPLAIN (costs off) select x from (values (array[1, 2]), (array[1, 3])) _(x) intersect select x from (values (array[1, 2]), (array[1, 4])) _(x);
SELECT x FROM (VALUES (ARRAY(1, 2)), (ARRAY(1, 3))) AS x INTERSECT SELECT x FROM (VALUES (ARRAY(1, 2)), (ARRAY(1, 4))) AS x;
EXPLAIN (costs off) select x from (values (array[1, 2]), (array[1, 3])) _(x) except select x from (values (array[1, 2]), (array[1, 4])) _(x);
SELECT x FROM (VALUES (ARRAY(1, 2)), (ARRAY(1, 3))) AS x EXCEPT SELECT x FROM (VALUES (ARRAY(1, 2)), (ARRAY(1, 4))) AS x;
/* non-hashable type */ EXPLAIN (costs off) select x from (values (array['10'::varbit]), (array['11'::varbit])) _(x) union select x from (values (array['10'::varbit]), (array['01'::varbit])) _(x);
SELECT x FROM (VALUES (ARRAY(CAST('10' AS varbit))), (ARRAY(CAST('11' AS varbit)))) AS x UNION SELECT x FROM (VALUES (ARRAY(CAST('10' AS varbit))), (ARRAY(CAST('01' AS varbit)))) AS x;
SET x = off;
EXPLAIN (costs off) select x from (values (array[1, 2]), (array[1, 3])) _(x) union select x from (values (array[1, 2]), (array[1, 4])) _(x);
SELECT x FROM (VALUES (ARRAY(1, 2)), (ARRAY(1, 3))) AS x UNION SELECT x FROM (VALUES (ARRAY(1, 2)), (ARRAY(1, 4))) AS x;
EXPLAIN (costs off) select x from (values (array[1, 2]), (array[1, 3])) _(x) intersect select x from (values (array[1, 2]), (array[1, 4])) _(x);
SELECT x FROM (VALUES (ARRAY(1, 2)), (ARRAY(1, 3))) AS x INTERSECT SELECT x FROM (VALUES (ARRAY(1, 2)), (ARRAY(1, 4))) AS x;
EXPLAIN (costs off) select x from (values (array[1, 2]), (array[1, 3])) _(x) except select x from (values (array[1, 2]), (array[1, 4])) _(x);
SELECT x FROM (VALUES (ARRAY(1, 2)), (ARRAY(1, 3))) AS x EXCEPT SELECT x FROM (VALUES (ARRAY(1, 2)), (ARRAY(1, 4))) AS x;
RESET enable_hashagg;
SET x = on /* records */;
EXPLAIN (costs off) select x from (values (row(1, 2)), (row(1, 3))) _(x) union select x from (values (row(1, 2)), (row(1, 4))) _(x);
SELECT x FROM (VALUES (ROW(1, 2)), (ROW(1, 3))) AS x UNION SELECT x FROM (VALUES (ROW(1, 2)), (ROW(1, 4))) AS x;
EXPLAIN (costs off) select x from (values (row(1, 2)), (row(1, 3))) _(x) intersect select x from (values (row(1, 2)), (row(1, 4))) _(x);
SELECT x FROM (VALUES (ROW(1, 2)), (ROW(1, 3))) AS x INTERSECT SELECT x FROM (VALUES (ROW(1, 2)), (ROW(1, 4))) AS x;
EXPLAIN (costs off) select x from (values (row(1, 2)), (row(1, 3))) _(x) except select x from (values (row(1, 2)), (row(1, 4))) _(x);
SELECT x FROM (VALUES (ROW(1, 2)), (ROW(1, 3))) AS x EXCEPT SELECT x FROM (VALUES (ROW(1, 2)), (ROW(1, 4))) AS x;
/* non-hashable type */ /* With an anonymous row type, the typcache does not report that the */ /* type is hashable.  (Otherwise, this would fail at execution time.) */ EXPLAIN (costs off) select x from (values (row('10'::varbit)), (row('11'::varbit))) _(x) union select x from (values (row('10'::varbit)), (row('01'::varbit))) _(x);
SELECT x FROM (VALUES (ROW(CAST('10' AS varbit))), (ROW(CAST('11' AS varbit)))) AS x UNION SELECT x FROM (VALUES (ROW(CAST('10' AS varbit))), (ROW(CAST('01' AS varbit)))) AS x;
/* With a defined row type, the typcache can inspect the type's fields */ /* for hashability. */ create type ct1 as (f1 varbit);
EXPLAIN (costs off) select x from (values (row('10'::varbit)::ct1), (row('11'::varbit)::ct1)) _(x) union select x from (values (row('10'::varbit)::ct1), (row('01'::varbit)::ct1)) _(x);
SELECT x FROM (VALUES (CAST(ROW(CAST('10' AS varbit)) AS ct1)), (CAST(ROW(CAST('11' AS varbit)) AS ct1))) AS x UNION SELECT x FROM (VALUES (CAST(ROW(CAST('10' AS varbit)) AS ct1)), (CAST(ROW(CAST('01' AS varbit)) AS ct1))) AS x;
drop type ct1;
SET x = off;
EXPLAIN (costs off) select x from (values (row(1, 2)), (row(1, 3))) _(x) union select x from (values (row(1, 2)), (row(1, 4))) _(x);
SELECT x FROM (VALUES (ROW(1, 2)), (ROW(1, 3))) AS x UNION SELECT x FROM (VALUES (ROW(1, 2)), (ROW(1, 4))) AS x;
EXPLAIN (costs off) select x from (values (row(1, 2)), (row(1, 3))) _(x) intersect select x from (values (row(1, 2)), (row(1, 4))) _(x);
SELECT x FROM (VALUES (ROW(1, 2)), (ROW(1, 3))) AS x INTERSECT SELECT x FROM (VALUES (ROW(1, 2)), (ROW(1, 4))) AS x;
EXPLAIN (costs off) select x from (values (row(1, 2)), (row(1, 3))) _(x) except select x from (values (row(1, 2)), (row(1, 4))) _(x);
SELECT x FROM (VALUES (ROW(1, 2)), (ROW(1, 3))) AS x EXCEPT SELECT x FROM (VALUES (ROW(1, 2)), (ROW(1, 4))) AS x;
/* non-sortable type */ /* Ensure we get a HashAggregate plan.  Keep enable_hashagg=off to ensure */ /* there's no chance of a sort. */ EXPLAIN (costs off) select '123'::xid union select '123'::xid;
RESET enable_hashagg;
/* Mixed types */ SELECT x FROM x INTERSECT SELECT x FROM x ORDER BY 1 NULLS LAST;
SELECT x FROM x EXCEPT SELECT x FROM x ORDER BY 1 NULLS LAST;
/* Operator precedence and (((((extra))))) parentheses */ SELECT x FROM x INTERSECT SELECT x FROM x UNION ALL SELECT x FROM x ORDER BY 1 NULLS LAST;
SELECT x FROM x INTERSECT (((SELECT x FROM x UNION ALL SELECT x FROM x))) ORDER BY 1 NULLS LAST;
(((SELECT x FROM x INTERSECT SELECT x FROM x ORDER BY 1 NULLS LAST))) UNION ALL SELECT x FROM x;
SELECT x FROM x UNION ALL SELECT x FROM x EXCEPT SELECT x FROM x ORDER BY 1 NULLS LAST;
SELECT x FROM x UNION ALL (((SELECT x FROM x EXCEPT SELECT x FROM x ORDER BY 1 NULLS LAST)));
(((SELECT x FROM x UNION ALL SELECT x FROM x))) EXCEPT SELECT x FROM x ORDER BY 1 NULLS LAST;
/* Subqueries with ORDER BY & LIMIT clauses */ /* In this syntax, ORDER BY/LIMIT apply to the result of the EXCEPT */ SELECT x, x FROM x EXCEPT SELECT x, x FROM x ORDER BY x NULLS LAST, x NULLS LAST;
/* This should fail, because q2 isn't a name of an EXCEPT output column */ SELECT x FROM x EXCEPT SELECT x FROM x ORDER BY x NULLS LAST LIMIT 1;
/* But this should work: */ SELECT x FROM x EXCEPT (((SELECT x FROM x ORDER BY x NULLS LAST LIMIT 1))) ORDER BY 1 NULLS LAST;
(((((SELECT * FROM x))))) /* New syntaxes (7.1) permit new tests */;
/* Check behavior with empty select list (allowed since 9.4) */ SELECT UNION SELECT;
SELECT INTERSECT SELECT;
SELECT EXCEPT SELECT;
SET x = TRUE /* check hashed implementation */;
SET x = FALSE;
/* We've no way to check hashed UNION as the empty pathkeys in the Append are */ /* fine to make use of Unique, which is cheaper than HashAggregate and we've */ /* no means to disable Unique. */ EXPLAIN (costs off) select from generate_series(1,5) intersect select from generate_series(1,3);
SELECT FROM x UNION ALL SELECT FROM x;
SELECT FROM x INTERSECT SELECT FROM x;
SELECT FROM x INTERSECT ALL SELECT FROM x;
SELECT FROM x EXCEPT SELECT FROM x;
SELECT FROM x EXCEPT ALL SELECT FROM x;
SET x = FALSE /* check sorted implementation */;
SET x = TRUE;
EXPLAIN (costs off) select from generate_series(1,5) union select from generate_series(1,3);
EXPLAIN (costs off) select from generate_series(1,5) intersect select from generate_series(1,3);
SELECT FROM x UNION SELECT FROM x;
SELECT FROM x UNION ALL SELECT FROM x;
SELECT FROM x INTERSECT SELECT FROM x;
SELECT FROM x INTERSECT ALL SELECT FROM x;
SELECT FROM x EXCEPT SELECT FROM x;
SELECT FROM x EXCEPT ALL SELECT FROM x;
/* Try a variation of the above but with a CTE which contains a column, again */ /* with an empty final select list. */ /* Ensure we get the expected 1 row with 0 columns */ WITH x AS MATERIALIZED (SELECT x FROM x AS x) SELECT FROM x UNION SELECT FROM x;
/* Ensure we get the same result as the above. */ WITH x AS NOT MATERIALIZED (SELECT x FROM x AS x) SELECT FROM x UNION SELECT FROM x;
RESET enable_hashagg;
RESET enable_sort;
/* Check handling of a case with unknown constants.  We don't guarantee */ /* an undecorated constant will work in all cases, but historically this */ /* usage has worked, so test we don't break it. */ SELECT x.x FROM (SELECT 'test' AS x FROM x) AS x UNION SELECT x.x FROM (SELECT x FROM x) AS x ORDER BY 1 NULLS LAST;
/* This should fail, but it should produce an error cursor */ SELECT CAST('3.4' AS DECIMAL) UNION SELECT 'foo';
/* Test that expression-index constraints can be pushed down through */ /* UNION or UNION ALL */ CREATE TEMPORARY TABLE x (x TEXT, x TEXT);
CREATE INDEX x ON x((x || x) NULLS LAST);
CREATE TEMPORARY TABLE x (x TEXT PRIMARY KEY);
INSERT INTO x VALUES ('a', 'b'), ('x', 'y');
INSERT INTO x VALUES ('ab'), ('xy');
SET x = off;
SET x = on;
SET x = off;
SET x = off;
EXPLAIN (costs off)  SELECT * FROM  (SELECT a || b AS ab FROM t1   UNION ALL   SELECT * FROM t2) t  WHERE ab = 'ab';
EXPLAIN (costs off)  SELECT * FROM  (SELECT a || b AS ab FROM t1   UNION   SELECT * FROM t2) t  WHERE ab = 'ab';
/* Test that ORDER BY for UNION ALL can be pushed down to inheritance */ /* children. */ CREATE TEMPORARY TABLE x (x TEXT, x TEXT);
ALTER TABLE t1c INHERIT t1;
CREATE TEMPORARY TABLE x (PRIMARY KEY (x NULLS LAST)) INHERITS (x);
INSERT INTO x VALUES ('v', 'w'), ('c', 'd'), ('m', 'n'), ('e', 'f');
INSERT INTO x VALUES ('vw'), ('cd'), ('mn'), ('ef');
CREATE INDEX x ON x((x || x) NULLS LAST);
SET x = on;
SET x = off;
EXPLAIN (costs off)   SELECT * FROM   (SELECT a || b AS ab FROM t1    UNION ALL    SELECT ab FROM t2) t   ORDER BY 1 LIMIT 8;
SELECT * FROM (SELECT x || x AS x FROM x UNION ALL SELECT x FROM x) AS x ORDER BY 1 NULLS LAST LIMIT 8;
RESET enable_seqscan;
RESET enable_indexscan;
RESET enable_bitmapscan;
RESET enable_sort;
/* This simpler variant of the above test has been observed to fail differently */ CREATE TABLE x (x INT PRIMARY KEY);
CREATE TABLE x (x INT PRIMARY KEY);
CREATE TABLE x INHERITS (x);
EXPLAIN (costs off) select event_id  from (select event_id from events        union all        select event_id from other_events) ss  order by event_id;
RESET enable_indexonlyscan;
/* Test constraint exclusion of UNION ALL subqueries */ EXPLAIN (costs off)  SELECT * FROM   (SELECT 1 AS t, * FROM tenk1 a    UNION ALL    SELECT 2 AS t, * FROM tenk1 b) c  WHERE t = 2;
/* Test that we push quals into UNION sub-selects only when it's safe */ EXPLAIN (costs off) SELECT * FROM   (SELECT 1 AS t, 2 AS x    UNION    SELECT 2 AS t, 4 AS x) ss WHERE x < 4 ORDER BY x;
SELECT * FROM (SELECT 1 AS x, 2 AS x UNION SELECT 2 AS x, 4 AS x) AS x WHERE x < 4 ORDER BY x NULLS LAST;
EXPLAIN (costs off) SELECT * FROM   (SELECT 1 AS t, generate_series(1,10) AS x    UNION    SELECT 2 AS t, 4 AS x) ss WHERE x < 4 ORDER BY x;
SELECT * FROM (SELECT 1 AS x, UNNEST(GENERATE_SERIES(1, 10)) AS x UNION SELECT 2 AS x, 4 AS x) AS x WHERE x < 4 ORDER BY x NULLS LAST;
EXPLAIN (costs off) SELECT * FROM   (SELECT 1 AS t, (random()*3)::int AS x    UNION    SELECT 2 AS t, 4 AS x) ss WHERE x > 3 ORDER BY x;
SELECT * FROM (SELECT 1 AS x, CAST((RAND() * 3) AS INT) AS x UNION SELECT 2 AS x, 4 AS x) AS x WHERE x > 3 ORDER BY x NULLS LAST;
/* Test cases where the native ordering of a sub-select has more pathkeys */ /* than the outer query cares about */ EXPLAIN (costs off) select distinct q1 from   (select distinct * from int8_tbl i81    union all    select distinct * from int8_tbl i82) ss where q2 = q2;
SELECT DISTINCT x FROM (SELECT DISTINCT * FROM x AS x UNION ALL SELECT DISTINCT * FROM x AS x) AS x WHERE x = x;
EXPLAIN (costs off) select distinct q1 from   (select distinct * from int8_tbl i81    union all    select distinct * from int8_tbl i82) ss where -q1 = q2;
SELECT DISTINCT x FROM (SELECT DISTINCT * FROM x AS x UNION ALL SELECT DISTINCT * FROM x AS x) AS x WHERE -x = x;
x;
CREATE TEMPORARY TABLE x AS SELECT UNNEST(GENERATE_SERIES(-1000, 1000)) AS x;
CREATE INDEX x ON x(EXPENSIVEFUNC(x) NULLS LAST);
ANALYZE x;
EXPLAIN (costs off) select * from   (select * from t3 a union all select * from t3 b) ss   join int4_tbl on f1 = expensivefunc(x);
SELECT * FROM (SELECT * FROM x AS x UNION ALL SELECT * FROM x AS x) AS x JOIN x ON x = EXPENSIVEFUNC(x);
DROP TABLE x;
DROP FUNCTION x (INT);
/* Test handling of appendrel quals that const-simplify into an AND */ EXPLAIN (costs off) select * from   (select *, 0 as x from int8_tbl a    union all    select *, 1 as x from int8_tbl b) ss where (x = 0) or (q1 >= q2 and q1 <= q2);
SELECT * FROM (SELECT *, 0 AS x FROM x AS x UNION ALL SELECT *, 1 AS x FROM x AS x) AS x WHERE (x = 0) OR (x >= x AND x <= x);
/* Test the planner's ability to produce cheap startup plans with Append nodes */ /* Ensure we get a Nested Loop join between tenk1 and tenk2 */ EXPLAIN (costs off) select t1.unique1 from tenk1 t1 inner join tenk2 t2 on t1.tenthous = t2.tenthous and t2.thousand = 0    union all (values(1)) limit 1;
/* Ensure there is no problem if cheapest_startup_path is NULL */ EXPLAIN (costs off) select * from tenk1 t1 left join lateral   (select t1.tenthous from tenk2 t2 union all (values(1))) on true limit 1;
SET x = 0 /* UPDATABLE VIEWS */ /* avoid bit-exact output here because operations may not be bit-exact. */;
/* check that non-updatable views and columns are rejected with useful error */ /* messages */ CREATE TABLE x (x INT PRIMARY KEY, x TEXT DEFAULT 'Unspecified');
INSERT INTO x SELECT x, 'Row ' || x FROM x AS x;
CREATE VIEW x AS SELECT DISTINCT x, x FROM x;
/* DISTINCT not supported */ CREATE VIEW x AS SELECT x, x FROM x GROUP BY x, x;
/* GROUP BY not supported */ CREATE VIEW x AS SELECT 1 FROM x HAVING MAX(x) > 0;
/* HAVING not supported */ CREATE VIEW x AS SELECT COUNT(*) FROM x;
/* Aggregate functions not supported */ CREATE VIEW x AS SELECT x, RANK() OVER () FROM x;
/* Window functions not supported */ CREATE VIEW x AS SELECT x, x FROM x UNION SELECT -x, x FROM x;
/* Set ops not supported */ CREATE VIEW x AS WITH x AS (SELECT x, x FROM x) SELECT * FROM x;
/* WITH not supported */ CREATE VIEW x AS SELECT x, x FROM x ORDER BY x NULLS LAST OFFSET 1;
/* OFFSET not supported */ CREATE VIEW x AS SELECT x, x FROM x ORDER BY x NULLS LAST LIMIT 1;
/* LIMIT not supported */ CREATE VIEW x AS SELECT 1 AS x;
/* No base relations */ CREATE VIEW x AS SELECT x.x, x.x FROM x AS x, x AS x;
/* Multiple base relations */ CREATE VIEW x AS SELECT * FROM x AS x;
/* SRF in rangetable */ CREATE VIEW x AS SELECT x, x FROM (SELECT * FROM x) AS x;
/* Subselect in rangetable */ CREATE VIEW x AS SELECT x, x, x FROM x;
/* System columns may be part of an updatable view */ CREATE VIEW x AS SELECT x, UPPER(x) FROM x;
/* Expression/function may be part of an updatable view */ CREATE VIEW x AS SELECT x, x, x AS x FROM x;
/* Repeated column may be part of an updatable view */ CREATE VIEW x AS SELECT * FROM x;
/* Base relation not updatable */ CREATE VIEW x AS SELECT * FROM (VALUES (1)) AS x;
/* VALUES in rangetable */ CREATE SEQUENCE x;
CREATE VIEW x AS SELECT * FROM x;
/* View based on a sequence */ CREATE VIEW x AS SELECT x, x, UNNEST(GENERATE_SERIES(1, x)) AS x FROM x;
/* SRF in targetlist not supported */ SELECT x, x FROM x.x WHERE x LIKE r_\\_view% ORDER BY x NULLS LAST;
SELECT x, x, x FROM x.x WHERE x LIKE r_\\_view% ORDER BY x NULLS LAST;
SELECT x, x, x FROM x.x WHERE x LIKE r_\\_view% ORDER BY x NULLS LAST, x NULLS LAST;
/* Read-only views */ DELETE FROM x;
DELETE FROM x;
DELETE FROM x;
DELETE FROM x;
DELETE FROM x;
DELETE FROM x;
UPDATE x SET x = x + 1;
UPDATE x SET x = x + 1;
UPDATE x SET x = x + 1;
UPDATE x SET x = x + 1;
UPDATE x SET x = x + 1;
UPDATE x SET x = x + 1;
INSERT INTO x VALUES (3, 'Row 3');
MERGE INTO x AS x USING (VALUES (1, 'Row 1')) AS x ON x.x = x.x WHEN MATCHED THEN DELETE;
MERGE INTO x AS x USING (VALUES (2, 'Row 2')) AS x ON x.x = x.x WHEN MATCHED THEN UPDATE SET x = x.x;
MERGE INTO x AS x USING (VALUES (3, 'Row 3')) AS x ON x.x = x.x WHEN NOT MATCHED THEN INSERT VALUES (x.x, x.x);
MERGE INTO x AS x USING (VALUES (2, 'Row 2')) AS x ON x.x = x.x WHEN MATCHED THEN DO NOTHING WHEN NOT MATCHED THEN DO NOTHING;
MERGE INTO x AS x USING (VALUES (3, 'Row 3')) AS x ON x.x = x.x WHEN MATCHED THEN DO NOTHING WHEN NOT MATCHED THEN DO NOTHING /* should be OK to do nothing */;
/* should be OK to do nothing */ /* Partially updatable view */ INSERT INTO x VALUES (NULL, 3, 'Row 3');
/* should fail */ INSERT INTO x (x, x) VALUES (3, 'Row 3');
/* should be OK */ UPDATE x SET x = NULL WHERE x = 3;
/* should fail */ UPDATE x SET x = 'ROW 3' WHERE x = 3;
/* should be OK */ SELECT * FROM x;
DELETE FROM x WHERE x = 3;
MERGE INTO x AS x USING (VALUES (2, 'Merged row 2'), (3, 'Merged row 3')) AS x ON x.x = x.x WHEN MATCHED THEN UPDATE SET x = x.x /* should be OK, except... */ WHEN NOT MATCHED THEN INSERT VALUES (NULL, x.x, x.x) /* should be OK */;
MERGE INTO x AS x USING (VALUES (2, 'Merged row 2'), (3, 'Merged row 3')) AS x ON x.x = x.x WHEN MATCHED THEN UPDATE SET x = x.x /* should be OK */ WHEN NOT MATCHED THEN INSERT (x, x) VALUES (x.x, x.x) /* should fail */;
/* should be OK */ SELECT * FROM x ORDER BY x NULLS LAST;
MERGE INTO x AS x USING (VALUES (2, 'Row 2'), (3, 'Row 3')) AS x ON x.x = x.x WHEN MATCHED AND x.x = 2 THEN UPDATE SET x = x.x /* should be OK */ WHEN MATCHED AND x.x = 3 THEN DELETE;
/* should be OK */ SELECT * FROM x ORDER BY x NULLS LAST;
/* Partially updatable view */ INSERT INTO x VALUES (3, 'ROW 3');
/* should fail */ INSERT INTO x (x) VALUES (3);
/* should be OK */ INSERT INTO x (x) VALUES (3) ON CONFLICT DO NOTHING;
/* succeeds */ SELECT * FROM x;
INSERT INTO x (x) VALUES (3) ON CONFLICT(x) DO NOTHING;
/* succeeds */ SELECT * FROM x;
INSERT INTO x (x) VALUES (3) ON CONFLICT(x) DO UPDATE SET x = x.x;
/* succeeds */ SELECT * FROM x;
INSERT INTO x (x) VALUES (3) ON CONFLICT(x) DO UPDATE SET x = 'blarg';
/* fails */ SELECT * FROM x;
SELECT * FROM x;
ALTER VIEW x ALTER COLUMN x SET DEFAULT 'NOT SET';
INSERT INTO x (x) VALUES (4);
/* should fail */ UPDATE x SET x = 'ROW 3' WHERE x = 3;
/* should fail */ UPDATE x SET x = x WHERE x = 3;
/* should fail */ UPDATE x SET x = 4 WHERE x = 3;
/* should be OK */ SELECT * FROM x;
DELETE FROM x WHERE x = 4;
/* should be OK */ /* Partially updatable view */ INSERT INTO x VALUES (3, 'Row 3', 3);
/* should fail */ INSERT INTO x (x, x) VALUES (3, 'Row 3');
/* should be OK */ UPDATE x SET x = 3, x = -3 WHERE x = 3;
/* should fail */ UPDATE x SET x = -3 WHERE x = 3;
/* should be OK */ SELECT * FROM x;
DELETE FROM x WHERE x = -3;
/* should be OK */ /* Read-only views */ INSERT INTO x VALUES (3, 'ROW 3');
DELETE FROM x;
MERGE INTO x AS x USING (VALUES (1, 'Row 1')) AS x ON x.x = x.x WHEN MATCHED THEN DO NOTHING;
/* should be OK to do nothing */ UPDATE x SET x = 1000;
UPDATE x SET x = UPPER(x);
/* A view with a conditional INSTEAD rule but no unconditional INSTEAD rules */ /* or INSTEAD OF triggers should be non-updatable and generate useful error */ /* messages with appropriate detail */ CREATE RULE rw_view16_ins_rule AS ON INSERT TO rw_view16   WHERE NEW.a > 0 DO INSTEAD INSERT INTO base_tbl VALUES (NEW.a, NEW.b);
CREATE RULE rw_view16_upd_rule AS ON UPDATE TO rw_view16   WHERE OLD.a > 0 DO INSTEAD UPDATE base_tbl SET b=NEW.b WHERE a=OLD.a;
CREATE RULE rw_view16_del_rule AS ON DELETE TO rw_view16   WHERE OLD.a > 0 DO INSTEAD DELETE FROM base_tbl WHERE a=OLD.a;
INSERT INTO x (x, x) VALUES (3, 'Row 3');
/* should fail */ UPDATE x SET x = 'ROW 2' WHERE x = 2;
/* should fail */ DELETE FROM x WHERE x = 2;
MERGE INTO x AS x USING (VALUES (3, 'Row 3')) AS x ON x.x = x.x WHEN NOT MATCHED THEN INSERT VALUES (x.x, x.x) /* should fail */;
/* should fail */ DROP TABLE x CASCADE;
DROP SEQUENCE x CASCADE;
/* simple updatable view */ CREATE TABLE x (x INT PRIMARY KEY, x TEXT DEFAULT 'Unspecified');
INSERT INTO x SELECT x, 'Row ' || x FROM x AS x;
CREATE VIEW x AS SELECT *, 'Const' AS x, (SELECT CONCAT(COALESCE('b: ', ''), COALESCE(x, ''))) AS x FROM x WHERE x > 0;
SELECT x, x FROM x.x WHERE x = 'rw_view1';
SELECT x, x, x FROM x.x WHERE x = 'rw_view1';
SELECT x, x, x FROM x.x WHERE x = 'rw_view1' ORDER BY x NULLS LAST;
INSERT INTO x VALUES (3, 'Row 3');
INSERT INTO x (x) VALUES (4);
UPDATE x SET x = 5 WHERE x = 4;
DELETE FROM x WHERE x = 'Row 2';
SELECT * FROM x;
SET x = 0;
MERGE INTO x AS x USING (VALUES (0, 'ROW 0'), (1, 'ROW 1'), (2, 'ROW 2'), (3, 'ROW 3')) AS x ON x.x = x.x WHEN MATCHED AND x.x <= 1 THEN UPDATE SET x = x.x WHEN MATCHED THEN DELETE WHEN NOT MATCHED AND x > 0 THEN INSERT (x) VALUES (x.x) RETURNING MERGE_ACTION(), x.*, x, x, x.*, x.*, x.*;
SET x = DEFAULT;
SELECT * FROM x ORDER BY x NULLS LAST;
MERGE INTO x AS x USING (VALUES (0, 'R0'), (1, 'R1'), (2, 'R2'), (3, 'R3')) AS x ON x.x = x.x WHEN MATCHED AND x.x <= 1 THEN UPDATE SET x = x.x WHEN MATCHED THEN DELETE WHEN NOT MATCHED BY SOURCE THEN DELETE WHEN NOT MATCHED AND x > 0 THEN INSERT (x) VALUES (x.x) RETURNING MERGE_ACTION(), x.*, x, x, x.*, x.*, x.*;
SELECT * FROM x ORDER BY x NULLS LAST;
EXPLAIN (costs off) UPDATE rw_view1 SET a=6 WHERE a=5;
EXPLAIN (costs off) DELETE FROM rw_view1 WHERE a=5;
EXPLAIN (costs off) MERGE INTO rw_view1 t USING (VALUES (5, 'X')) AS v(a,b) ON t.a = v.a   WHEN MATCHED THEN DELETE;
EXPLAIN (costs off) MERGE INTO rw_view1 t   USING (SELECT * FROM generate_series(1,5)) AS s(a) ON t.a = s.a   WHEN MATCHED THEN UPDATE SET b = 'Updated';
EXPLAIN (costs off) MERGE INTO rw_view1 t   USING (SELECT * FROM generate_series(1,5)) AS s(a) ON t.a = s.a   WHEN NOT MATCHED BY SOURCE THEN DELETE;
EXPLAIN (costs off) MERGE INTO rw_view1 t   USING (SELECT * FROM generate_series(1,5)) AS s(a) ON t.a = s.a   WHEN NOT MATCHED THEN INSERT (a) VALUES (s.a);
/* it's still updatable if we add a DO ALSO rule */ CREATE TABLE x (x TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP(), x INT, x TEXT);
CREATE RULE base_tbl_log AS ON INSERT TO rw_view1 DO ALSO   INSERT INTO base_tbl_hist(a,b) VALUES(new.a, new.b);
SELECT x, x, x FROM x.x WHERE x = 'rw_view1';
/* Check behavior with DEFAULTs (bug #17633) */ INSERT INTO x VALUES (9, DEFAULT), (10, DEFAULT);
SELECT x, x FROM x;
DROP TABLE x CASCADE;
DROP TABLE x;
/* view on top of view */ CREATE TABLE x (x INT PRIMARY KEY, x TEXT DEFAULT 'Unspecified');
INSERT INTO x SELECT x, 'Row ' || x FROM x AS x;
CREATE VIEW x AS SELECT x AS x, x AS x, 'Const1' AS x FROM x WHERE x > 0;
CREATE VIEW x AS SELECT x AS x, x AS x, x AS x, 'Const2' AS x FROM x WHERE x < 10;
SELECT x, x FROM x.x WHERE x = 'rw_view2';
SELECT x, x, x FROM x.x WHERE x = 'rw_view2';
SELECT x, x, x FROM x.x WHERE x = 'rw_view2' ORDER BY x NULLS LAST;
INSERT INTO x VALUES (3, 'Row 3');
INSERT INTO x (x) VALUES (4);
SELECT * FROM x;
UPDATE x SET x = 'Row 4' WHERE x = 4;
DELETE FROM x WHERE x = 2;
SELECT * FROM x;
MERGE INTO x AS x USING (VALUES (3, 'R3'), (4, 'R4'), (5, 'R5')) AS x ON x = x.x WHEN MATCHED AND x = 3 THEN DELETE WHEN MATCHED THEN UPDATE SET x = x.x WHEN NOT MATCHED THEN INSERT (x) VALUES (x.x) RETURNING MERGE_ACTION(), x.*, (SELECT x), (SELECT (SELECT x)), x.*;
SELECT * FROM x ORDER BY x NULLS LAST;
MERGE INTO x AS x USING (VALUES (4, 'r4'), (5, 'r5'), (6, 'r6')) AS x ON x = x.x WHEN MATCHED AND x = 4 THEN DELETE WHEN MATCHED THEN UPDATE SET x = x.x WHEN NOT MATCHED THEN INSERT (x) VALUES (x.x) WHEN NOT MATCHED BY SOURCE THEN UPDATE SET x = 'Not matched by source' RETURNING MERGE_ACTION(), x.*, x, (SELECT x FROM (VALUES ((SELECT x)))), x.*;
SELECT * FROM x ORDER BY x NULLS LAST;
EXPLAIN (costs off) UPDATE rw_view2 SET aaa=5 WHERE aaa=4;
EXPLAIN (costs off) DELETE FROM rw_view2 WHERE aaa=4;
DROP TABLE x CASCADE;
/* view on top of view with rules */ CREATE TABLE x (x INT PRIMARY KEY, x TEXT DEFAULT 'Unspecified');
INSERT INTO x SELECT x, 'Row ' || x FROM x AS x;
CREATE VIEW x AS SELECT * FROM x WHERE x > 0 OFFSET 0;
/* not updatable without rules/triggers */ CREATE VIEW x AS SELECT * FROM x WHERE x < 10;
SELECT x, x FROM x.x WHERE x LIKE 'rw_view%' ORDER BY x NULLS LAST;
SELECT x, x, x FROM x.x WHERE x LIKE 'rw_view%' ORDER BY x NULLS LAST;
SELECT x, x, x FROM x.x WHERE x LIKE 'rw_view%' ORDER BY x NULLS LAST, x NULLS LAST;
CREATE RULE rw_view1_ins_rule AS ON INSERT TO rw_view1   DO INSTEAD INSERT INTO base_tbl VALUES (NEW.a, NEW.b) RETURNING *;
SELECT x, x FROM x.x WHERE x LIKE 'rw_view%' ORDER BY x NULLS LAST;
SELECT x, x, x FROM x.x WHERE x LIKE 'rw_view%' ORDER BY x NULLS LAST;
SELECT x, x, x FROM x.x WHERE x LIKE 'rw_view%' ORDER BY x NULLS LAST, x NULLS LAST;
CREATE RULE rw_view1_upd_rule AS ON UPDATE TO rw_view1   DO INSTEAD UPDATE base_tbl SET b=NEW.b WHERE a=OLD.a RETURNING NEW.*;
SELECT x, x FROM x.x WHERE x LIKE 'rw_view%' ORDER BY x NULLS LAST;
SELECT x, x, x FROM x.x WHERE x LIKE 'rw_view%' ORDER BY x NULLS LAST;
SELECT x, x, x FROM x.x WHERE x LIKE 'rw_view%' ORDER BY x NULLS LAST, x NULLS LAST;
CREATE RULE rw_view1_del_rule AS ON DELETE TO rw_view1   DO INSTEAD DELETE FROM base_tbl WHERE a=OLD.a RETURNING OLD.*;
SELECT x, x FROM x.x WHERE x LIKE 'rw_view%' ORDER BY x NULLS LAST;
SELECT x, x, x FROM x.x WHERE x LIKE 'rw_view%' ORDER BY x NULLS LAST;
SELECT x, x, x FROM x.x WHERE x LIKE 'rw_view%' ORDER BY x NULLS LAST, x NULLS LAST;
INSERT INTO x VALUES (3, 'Row 3') RETURNING x.*, x.*;
UPDATE x SET x = 'R3' WHERE x = 3 RETURNING x.*, x.*;
/* rule returns NEW */ DROP RULE rw_view1_upd_rule ON rw_view1;
CREATE RULE rw_view1_upd_rule AS ON UPDATE TO rw_view1   DO INSTEAD UPDATE base_tbl SET b=NEW.b WHERE a=OLD.a RETURNING *;
UPDATE x SET x = 'Row three' WHERE x = 3 RETURNING x.*, x.*;
SELECT * FROM x;
DELETE FROM x WHERE x = 3 RETURNING x.*, x.*;
SELECT * FROM x;
MERGE INTO x AS x USING (VALUES (3, 'Row 3')) AS x ON x.x = x.x WHEN NOT MATCHED THEN INSERT VALUES (x.x, x.x);
/* should fail */ EXPLAIN (costs off) UPDATE rw_view2 SET a=3 WHERE a=2;
EXPLAIN (costs off) DELETE FROM rw_view2 WHERE a=2;
DROP TABLE x CASCADE;
/* view on top of view with triggers */ CREATE TABLE x (x INT PRIMARY KEY, x TEXT DEFAULT 'Unspecified');
INSERT INTO x SELECT x, 'Row ' || x FROM x AS x;
CREATE VIEW x AS SELECT *, 'Const1' AS x FROM x WHERE x > 0 OFFSET 0;
/* not updatable without rules/triggers */ CREATE VIEW x AS SELECT *, 'Const2' AS x FROM x WHERE x < 10;
SELECT x, x FROM x.x WHERE x LIKE 'rw_view%' ORDER BY x NULLS LAST;
SELECT x, x, x, x, x, x FROM x.x WHERE x LIKE 'rw_view%' ORDER BY x NULLS LAST;
SELECT x, x, x FROM x.x WHERE x LIKE 'rw_view%' ORDER BY x NULLS LAST, x NULLS LAST;
x.x = 'Trigger Const1';
x AS x;
x.x = 'Trigger Const1';
x AS x;
x AS x;
COMMIT;
CREATE TRIGGER rw_view1_ins_trig INSTEAD OF INSERT ON rw_view1   FOR EACH ROW EXECUTE PROCEDURE rw_view1_trig_fn();
SELECT x, x FROM x.x WHERE x LIKE 'rw_view%' ORDER BY x NULLS LAST;
SELECT x, x, x, x, x, x FROM x.x WHERE x LIKE 'rw_view%' ORDER BY x NULLS LAST;
SELECT x, x, x FROM x.x WHERE x LIKE 'rw_view%' ORDER BY x NULLS LAST, x NULLS LAST;
CREATE TRIGGER rw_view1_upd_trig INSTEAD OF UPDATE ON rw_view1   FOR EACH ROW EXECUTE PROCEDURE rw_view1_trig_fn();
SELECT x, x FROM x.x WHERE x LIKE 'rw_view%' ORDER BY x NULLS LAST;
SELECT x, x, x, x, x, x FROM x.x WHERE x LIKE 'rw_view%' ORDER BY x NULLS LAST;
SELECT x, x, x FROM x.x WHERE x LIKE 'rw_view%' ORDER BY x NULLS LAST, x NULLS LAST;
CREATE TRIGGER rw_view1_del_trig INSTEAD OF DELETE ON rw_view1   FOR EACH ROW EXECUTE PROCEDURE rw_view1_trig_fn();
SELECT x, x FROM x.x WHERE x LIKE 'rw_view%' ORDER BY x NULLS LAST;
SELECT x, x, x, x, x, x FROM x.x WHERE x LIKE 'rw_view%' ORDER BY x NULLS LAST;
SELECT x, x, x FROM x.x WHERE x LIKE 'rw_view%' ORDER BY x NULLS LAST, x NULLS LAST;
INSERT INTO x VALUES (3, 'Row 3') RETURNING x.*, x.*;
UPDATE x SET x = 'Row three' WHERE x = 3 RETURNING x.*, x.*;
SELECT * FROM x;
DELETE FROM x WHERE x = 3 RETURNING x.*, x.*;
SELECT * FROM x;
MERGE INTO x AS x USING (SELECT x, 'R' || x FROM x AS x) AS x ON x.x = x.x WHEN MATCHED AND x.x <= 1 THEN DELETE WHEN MATCHED THEN UPDATE SET x = x.x WHEN NOT MATCHED AND x.x > 0 THEN INSERT VALUES (x.x, x.x) RETURNING MERGE_ACTION(), x.*, x, x, x.*;
SELECT * FROM x ORDER BY x NULLS LAST;
MERGE INTO x AS x USING (SELECT x, 'r' || x FROM x AS x) AS x ON x.x = x.x WHEN MATCHED THEN UPDATE SET x = x.x WHEN NOT MATCHED AND x.x > 0 THEN INSERT VALUES (x.x, x.x) WHEN NOT MATCHED BY SOURCE THEN UPDATE SET x = 'Not matched by source' RETURNING MERGE_ACTION(), x.*, x, x, x.*;
SELECT * FROM x ORDER BY x NULLS LAST;
EXPLAIN (costs off) UPDATE rw_view2 SET a=3 WHERE a=2;
EXPLAIN (costs off) DELETE FROM rw_view2 WHERE a=2;
EXPLAIN (costs off) MERGE INTO rw_view2 t   USING (SELECT x, 'R'||x FROM generate_series(0,3) x) AS s(a,b) ON t.a = s.a   WHEN MATCHED AND t.a <= 1 THEN DELETE   WHEN MATCHED THEN UPDATE SET b = s.b   WHEN NOT MATCHED AND s.a > 0 THEN INSERT VALUES (s.a, s.b);
/* MERGE with incomplete set of INSTEAD OF triggers */ DROP TRIGGER rw_view1_del_trig ON rw_view1;
MERGE INTO x AS x USING (SELECT x, 'R' || x FROM x AS x) AS x ON x.x = x.x WHEN MATCHED AND x.x <= 1 THEN DELETE WHEN MATCHED THEN UPDATE SET x = x.x WHEN NOT MATCHED AND x.x > 0 THEN INSERT VALUES (x.x, x.x);
MERGE INTO x AS x USING (SELECT x, 'R' || x FROM x AS x) AS x ON x.x = x.x WHEN MATCHED THEN UPDATE SET x = x.x WHEN NOT MATCHED AND x.x > 0 THEN INSERT VALUES (x.x, x.x) /* should fail */;
/* ok */ DROP TRIGGER rw_view1_ins_trig ON rw_view1;
MERGE INTO x AS x USING (SELECT x, 'R' || x FROM x AS x) AS x ON x.x = x.x WHEN MATCHED THEN UPDATE SET x = x.x WHEN NOT MATCHED AND x.x > 0 THEN INSERT VALUES (x.x, x.x);
MERGE INTO x AS x USING (SELECT x, 'R' || x FROM x AS x) AS x ON x.x = x.x WHEN MATCHED THEN UPDATE SET x = x.x /* should fail */;
/* ok */ /* MERGE with INSTEAD OF triggers on auto-updatable view */ CREATE TRIGGER rw_view2_upd_trig INSTEAD OF UPDATE ON rw_view2   FOR EACH ROW EXECUTE PROCEDURE rw_view1_trig_fn();
MERGE INTO x AS x USING (SELECT x, 'R' || x FROM x AS x) AS x ON x.x = x.x WHEN MATCHED THEN UPDATE SET x = x.x WHEN NOT MATCHED AND x.x > 0 THEN INSERT VALUES (x.x, x.x);
MERGE INTO x AS x USING (SELECT x, 'R' || x FROM x AS x) AS x ON x.x = x.x WHEN MATCHED THEN UPDATE SET x = x.x /* should fail */;
/* ok */ SELECT * FROM x ORDER BY x NULLS LAST;
DROP TABLE x CASCADE;
DROP FUNCTION x;
/* update using whole row from view */ CREATE TABLE x (x INT PRIMARY KEY, x TEXT DEFAULT 'Unspecified');
INSERT INTO x SELECT x, 'Row ' || x FROM x AS x;
CREATE VIEW x AS SELECT x AS x, x AS x FROM x;
CREATE FUNCTION x(x rw_view1) RETURNS INT LANGUAGE sql AS $$ SELECT x.aa $$;
UPDATE x AS x SET x = 'Updated row 2' WHERE RW_VIEW1_AA(x) = 2 RETURNING RW_VIEW1_AA(x), x.x;
SELECT * FROM x;
EXPLAIN (costs off) UPDATE rw_view1 v SET bb='Updated row 2' WHERE rw_view1_aa(v)=2   RETURNING rw_view1_aa(v), v.bb;
DROP TABLE x CASCADE;
/* permissions checks */ CREATE USER regress_view_user1;
CREATE USER regress_view_user2;
CREATE USER regress_view_user3;
SET SESSION AUTHORIZATION regress_view_user1;
CREATE TABLE x (x INT, x TEXT, x DOUBLE);
INSERT INTO x VALUES (1, 'Row 1', 1.0);
CREATE VIEW x AS SELECT x AS x, x AS x, x AS x FROM x;
INSERT INTO x VALUES ('Row 2', 2.0, 2);
GRANT SELECT ON x TO x;
GRANT SELECT ON x TO x;
GRANT UPDATE(x, x) ON x TO x;
GRANT UPDATE(x, x) ON x TO x;
RESET SESSION AUTHORIZATION;
SET SESSION AUTHORIZATION regress_view_user2;
CREATE VIEW x AS SELECT x AS x, x AS x, x AS x FROM x;
SELECT * FROM x;
/* ok */ SELECT * FROM x;
/* ok */ SELECT * FROM x;
/* ok */ INSERT INTO x VALUES (3, 'Row 3', 3.0);
/* not allowed */ INSERT INTO x VALUES ('Row 3', 3.0, 3);
/* not allowed */ INSERT INTO x VALUES ('Row 3', 3.0, 3);
MERGE INTO x AS x USING (VALUES ('Row 3', 3.0, 3)) AS x ON x.x = x.x WHEN NOT MATCHED THEN INSERT VALUES (x.x, x.x, x.x) /* not allowed */;
MERGE INTO x AS x USING (VALUES ('Row 3', 3.0, 3)) AS x ON x.x = x.x WHEN NOT MATCHED THEN INSERT VALUES (x.x, x.x, x.x) /* not allowed */;
/* not allowed */ UPDATE x SET x = x, x = x;
/* ok */ UPDATE x SET x = x;
/* not allowed */ UPDATE x SET x = x, x = x;
/* ok */ UPDATE x SET x = x;
/* not allowed */ UPDATE x SET x = x, x = x;
/* ok */ UPDATE x SET x = x;
MERGE INTO x AS x USING (VALUES (1)) AS x ON x.x = x.x WHEN MATCHED THEN UPDATE SET x = x, x = x /* not allowed */;
MERGE INTO x AS x USING (VALUES (1)) AS x ON x.x = x.x WHEN MATCHED THEN UPDATE SET x = x /* ok */;
MERGE INTO x AS x USING (VALUES (1)) AS x ON x.x = x.x WHEN MATCHED THEN UPDATE SET x = x, x = x /* not allowed */;
MERGE INTO x AS x USING (VALUES (1)) AS x ON x.x = x.x WHEN MATCHED THEN UPDATE SET x = x /* ok */;
/* not allowed */ DELETE FROM x;
/* not allowed */ DELETE FROM x;
/* not allowed */ DELETE FROM x;
/* not allowed */ RESET SESSION AUTHORIZATION;
SET SESSION AUTHORIZATION regress_view_user1;
GRANT INSERT, DELETE ON x TO x;
RESET SESSION AUTHORIZATION;
SET SESSION AUTHORIZATION regress_view_user2;
INSERT INTO x VALUES (3, 'Row 3', 3.0);
/* ok */ INSERT INTO x VALUES ('Row 4', 4.0, 4);
/* not allowed */ INSERT INTO x VALUES ('Row 4', 4.0, 4);
/* ok */ DELETE FROM x WHERE x = 1;
/* ok */ DELETE FROM x WHERE x = 2;
/* not allowed */ DELETE FROM x WHERE x = 2;
MERGE INTO x AS x USING (VALUES (1)) AS x ON x.x = x.x WHEN MATCHED AND x = 'xxx' THEN DELETE /* ok */;
MERGE INTO x AS x USING (VALUES (1)) AS x ON x.x = x.x WHEN MATCHED AND x = 'xxx' THEN DELETE /* not allowed */;
/* ok */ SELECT * FROM x;
RESET SESSION AUTHORIZATION;
SET SESSION AUTHORIZATION regress_view_user1;
REVOKE INSERT, DELETE ON base_tbl FROM regress_view_user2;
GRANT INSERT, DELETE ON x TO x;
RESET SESSION AUTHORIZATION;
SET SESSION AUTHORIZATION regress_view_user2;
INSERT INTO x VALUES (5, 'Row 5', 5.0);
/* not allowed */ INSERT INTO x VALUES ('Row 5', 5.0, 5);
/* ok */ INSERT INTO x VALUES ('Row 6', 6.0, 6);
/* not allowed */ DELETE FROM x WHERE x = 3;
/* not allowed */ DELETE FROM x WHERE x = 3;
/* ok */ DELETE FROM x WHERE x = 4;
MERGE INTO x AS x USING (VALUES (1)) AS x ON x.x = x.x WHEN MATCHED AND x = 'xxx' THEN DELETE /* not allowed */;
MERGE INTO x AS x USING (VALUES (1)) AS x ON x.x = x.x WHEN MATCHED AND x = 'xxx' THEN DELETE /* ok */;
/* not allowed */ SELECT * FROM x;
RESET SESSION AUTHORIZATION;
DROP TABLE x CASCADE;
/* nested-view permissions */ CREATE TABLE x (x INT, x TEXT, x DOUBLE);
INSERT INTO x VALUES (1, 'Row 1', 1.0);
SET SESSION AUTHORIZATION regress_view_user1;
CREATE VIEW x AS SELECT * FROM x;
SELECT * FROM x;
/* not allowed */ SELECT * FROM x;
/* not allowed */ UPDATE x SET x = 'foo' WHERE x = 1;
MERGE INTO x AS x USING (VALUES (1)) AS x ON x.x = x.x WHEN MATCHED THEN UPDATE SET x = 'foo' /* not allowed */;
/* not allowed */ SET SESSION AUTHORIZATION regress_view_user2;
CREATE VIEW x AS SELECT * FROM x;
SELECT * FROM x;
/* not allowed */ SELECT * FROM x;
/* not allowed */ UPDATE x SET x = 'bar' WHERE x = 1;
MERGE INTO x AS x USING (VALUES (1)) AS x ON x.x = x.x WHEN MATCHED THEN UPDATE SET x = 'foo' /* not allowed */;
/* not allowed */ RESET SESSION AUTHORIZATION;
GRANT SELECT ON x TO x;
SET SESSION AUTHORIZATION regress_view_user1;
SELECT * FROM x;
SELECT * FROM x;
/* not allowed */ UPDATE x SET x = 'foo' WHERE x = 1;
MERGE INTO x AS x USING (VALUES (1)) AS x ON x.x = x.x WHEN MATCHED THEN UPDATE SET x = 'foo' /* not allowed */;
/* not allowed */ SET SESSION AUTHORIZATION regress_view_user2;
SELECT * FROM x;
/* not allowed */ SELECT * FROM x;
/* not allowed */ UPDATE x SET x = 'bar' WHERE x = 1;
MERGE INTO x AS x USING (VALUES (1)) AS x ON x.x = x.x WHEN MATCHED THEN UPDATE SET x = 'foo' /* not allowed */;
/* not allowed */ SET SESSION AUTHORIZATION regress_view_user1;
GRANT SELECT ON x TO x;
SET SESSION AUTHORIZATION regress_view_user2;
SELECT * FROM x;
SELECT * FROM x;
/* not allowed */ UPDATE x SET x = 'bar' WHERE x = 1;
MERGE INTO x AS x USING (VALUES (1)) AS x ON x.x = x.x WHEN MATCHED THEN UPDATE SET x = 'foo' /* not allowed */;
/* not allowed */ RESET SESSION AUTHORIZATION;
GRANT UPDATE ON x TO x;
SET SESSION AUTHORIZATION regress_view_user1;
SELECT * FROM x;
SELECT * FROM x;
UPDATE x SET x = 'foo' WHERE x = 1;
MERGE INTO x AS x USING (VALUES (1)) AS x ON x.x = x.x WHEN MATCHED THEN UPDATE SET x = 'foo';
SET SESSION AUTHORIZATION regress_view_user2;
SELECT * FROM x;
SELECT * FROM x;
/* not allowed */ UPDATE x SET x = 'bar' WHERE x = 1;
MERGE INTO x AS x USING (VALUES (1)) AS x ON x.x = x.x WHEN MATCHED THEN UPDATE SET x = 'bar' /* not allowed */;
/* not allowed */ SET SESSION AUTHORIZATION regress_view_user1;
GRANT UPDATE ON x TO x;
SET SESSION AUTHORIZATION regress_view_user2;
SELECT * FROM x;
SELECT * FROM x;
UPDATE x SET x = 'bar' WHERE x = 1;
MERGE INTO x AS x USING (VALUES (1)) AS x ON x.x = x.x WHEN MATCHED THEN UPDATE SET x = 'fud';
RESET SESSION AUTHORIZATION;
REVOKE UPDATE ON base_tbl FROM regress_view_user1;
SET SESSION AUTHORIZATION regress_view_user1;
SELECT * FROM x;
SELECT * FROM x;
/* not allowed */ UPDATE x SET x = 'foo' WHERE x = 1;
MERGE INTO x AS x USING (VALUES (1)) AS x ON x.x = x.x WHEN MATCHED THEN UPDATE SET x = 'foo' /* not allowed */;
/* not allowed */ SET SESSION AUTHORIZATION regress_view_user2;
SELECT * FROM x;
SELECT * FROM x;
/* not allowed */ UPDATE x SET x = 'bar' WHERE x = 1;
MERGE INTO x AS x USING (VALUES (1)) AS x ON x.x = x.x WHEN MATCHED THEN UPDATE SET x = 'foo' /* not allowed */;
/* not allowed */ RESET SESSION AUTHORIZATION;
DROP TABLE x CASCADE;
/* security invoker view permissions */ SET SESSION AUTHORIZATION regress_view_user1;
CREATE TABLE x (x INT, x TEXT, x DOUBLE);
INSERT INTO x VALUES (1, 'Row 1', 1.0);
CREATE VIEW x AS SELECT x AS x, x AS x, x AS x FROM x;
ALTER VIEW x SET x = TRUE;
INSERT INTO x VALUES ('Row 2', 2.0, 2);
GRANT SELECT ON x TO x;
GRANT UPDATE(x, x) ON x TO x;
SET SESSION AUTHORIZATION regress_view_user2;
SELECT * FROM x;
/* not allowed */ SELECT * FROM x;
/* not allowed */ INSERT INTO x VALUES (3, 'Row 3', 3.0);
/* not allowed */ INSERT INTO x VALUES ('Row 3', 3.0, 3);
/* not allowed */ UPDATE x SET x = x;
/* not allowed */ UPDATE x SET x = x, x = x;
MERGE INTO x AS x USING (VALUES (1)) AS x ON x.x = x.x WHEN MATCHED THEN UPDATE SET x = x /* not allowed */;
/* not allowed */ DELETE FROM x;
/* not allowed */ DELETE FROM x;
MERGE INTO x AS x USING (VALUES (1)) AS x ON x.x = x.x WHEN MATCHED THEN DELETE /* not allowed */;
/* not allowed */ SET SESSION AUTHORIZATION regress_view_user1;
GRANT SELECT ON x TO x;
GRANT UPDATE(x, x) ON x TO x;
SET SESSION AUTHORIZATION regress_view_user2;
SELECT * FROM x;
/* ok */ SELECT * FROM x;
/* ok */ UPDATE x SET x = x, x = x;
/* ok */ UPDATE x SET x = x;
/* not allowed */ UPDATE x SET x = x;
MERGE INTO x AS x USING (VALUES (1)) AS x ON x.x = x.x WHEN MATCHED THEN UPDATE SET x = x /* ok */;
/* ok */ UPDATE x SET x = x;
/* not allowed */ UPDATE x SET x = x;
MERGE INTO x AS x USING (VALUES (1)) AS x ON x.x = x.x WHEN MATCHED THEN UPDATE SET x = x /* not allowed */;
MERGE INTO x AS x USING (VALUES (1)) AS x ON x.x = x.x WHEN MATCHED THEN UPDATE SET x = x /* not allowed */;
/* not allowed */ SET SESSION AUTHORIZATION regress_view_user1;
GRANT INSERT, DELETE ON x TO x;
SET SESSION AUTHORIZATION regress_view_user2;
INSERT INTO x VALUES (3, 'Row 3', 3.0);
/* ok */ INSERT INTO x VALUES ('Row 4', 4.0, 4);
/* not allowed */ DELETE FROM x WHERE x = 1;
/* ok */ DELETE FROM x WHERE x = 2;
MERGE INTO x AS x USING (VALUES (1)) AS x ON x.x = x.x WHEN MATCHED THEN DELETE /* not allowed */;
/* not allowed */ SET SESSION AUTHORIZATION regress_view_user1;
REVOKE INSERT, DELETE ON base_tbl FROM regress_view_user2;
GRANT INSERT, DELETE ON x TO x;
SET SESSION AUTHORIZATION regress_view_user2;
INSERT INTO x VALUES ('Row 4', 4.0, 4);
/* not allowed */ DELETE FROM x WHERE x = 2;
MERGE INTO x AS x USING (VALUES (1)) AS x ON x.x = x.x WHEN MATCHED THEN DELETE /* not allowed */;
/* not allowed */ SET SESSION AUTHORIZATION regress_view_user1;
GRANT INSERT, DELETE ON x TO x;
SET SESSION AUTHORIZATION regress_view_user2;
INSERT INTO x VALUES ('Row 4', 4.0, 4);
/* ok */ DELETE FROM x WHERE x = 2;
MERGE INTO x AS x USING (VALUES (3)) AS x ON x.x = x.x WHEN MATCHED THEN DELETE /* ok */;
/* ok */ SELECT * FROM x;
/* ok */ RESET SESSION AUTHORIZATION;
DROP TABLE x CASCADE;
/* ordinary view on top of security invoker view permissions */ CREATE TABLE x (x INT, x TEXT, x DOUBLE);
INSERT INTO x VALUES (1, 'Row 1', 1.0);
SET SESSION AUTHORIZATION regress_view_user1;
CREATE VIEW x AS SELECT x AS x, x AS x, x AS x FROM x;
ALTER VIEW x SET x = TRUE;
SELECT * FROM x;
/* not allowed */ UPDATE x SET x = x;
MERGE INTO x AS x USING (VALUES (2, 'Row 2', 2.0)) AS x ON x.x = x.x WHEN NOT MATCHED THEN INSERT VALUES (x.x, x.x, x.x) /* not allowed */;
/* not allowed */ SET SESSION AUTHORIZATION regress_view_user2;
CREATE VIEW x AS SELECT x AS x, x AS x, x AS x FROM x;
GRANT SELECT, UPDATE ON x TO x;
SELECT * FROM x;
/* not allowed */ UPDATE x SET x = x;
MERGE INTO x AS x USING (VALUES (2, 'Row 2', 2.0)) AS x ON x.x = x.x WHEN NOT MATCHED THEN INSERT VALUES (x.x, x.x, x.x) /* not allowed */;
/* not allowed */ RESET SESSION AUTHORIZATION;
GRANT SELECT ON x TO x;
GRANT UPDATE(x, x) ON x TO x;
SET SESSION AUTHORIZATION regress_view_user1;
SELECT * FROM x;
/* ok */ UPDATE x SET x = x, x = x;
/* ok */ UPDATE x SET x = x;
MERGE INTO x AS x USING (VALUES (1)) AS x ON x.x = x.x WHEN MATCHED THEN UPDATE SET x = x, x = x /* not allowed */;
MERGE INTO x AS x USING (VALUES (1)) AS x ON x.x = x.x WHEN MATCHED THEN UPDATE SET x = x /* ok */;
/* not allowed */ SET SESSION AUTHORIZATION regress_view_user2;
SELECT * FROM x;
/* not allowed */ UPDATE x SET x = x;
MERGE INTO x AS x USING (VALUES (1)) AS x ON x.x = x.x WHEN MATCHED THEN UPDATE SET x = x /* not allowed */;
/* not allowed */ SET SESSION AUTHORIZATION regress_view_user3;
SELECT * FROM x;
/* not allowed */ UPDATE x SET x = x;
MERGE INTO x AS x USING (VALUES (1)) AS x ON x.x = x.x WHEN MATCHED THEN UPDATE SET x = x /* not allowed */;
/* not allowed */ SET SESSION AUTHORIZATION regress_view_user1;
GRANT SELECT ON x TO x;
GRANT UPDATE(x, x) ON x TO x;
SET SESSION AUTHORIZATION regress_view_user2;
SELECT * FROM x;
/* not allowed */ UPDATE x SET x = x;
MERGE INTO x AS x USING (VALUES (1)) AS x ON x.x = x.x WHEN MATCHED THEN UPDATE SET x = x /* not allowed */;
/* not allowed */ SET SESSION AUTHORIZATION regress_view_user3;
SELECT * FROM x;
/* not allowed */ UPDATE x SET x = x;
MERGE INTO x AS x USING (VALUES (1)) AS x ON x.x = x.x WHEN MATCHED THEN UPDATE SET x = x /* not allowed */;
/* not allowed */ RESET SESSION AUTHORIZATION;
GRANT SELECT ON x TO x;
GRANT UPDATE(x, x) ON x TO x;
SET SESSION AUTHORIZATION regress_view_user2;
SELECT * FROM x;
/* ok */ UPDATE x SET x = x;
/* not allowed */ UPDATE x SET x = x;
/* not allowed */ UPDATE x SET x = x;
MERGE INTO x AS x USING (VALUES (1)) AS x ON x.x = x.x WHEN MATCHED THEN UPDATE SET x = x /* ok */;
MERGE INTO x AS x USING (VALUES (1)) AS x ON x.x = x.x WHEN MATCHED THEN UPDATE SET x = x /* not allowed */;
MERGE INTO x AS x USING (VALUES (1)) AS x ON x.x = x.x WHEN MATCHED THEN UPDATE SET x = x /* not allowed */;
/* ok */ SET SESSION AUTHORIZATION regress_view_user3;
SELECT * FROM x;
/* not allowed */ UPDATE x SET x = x;
/* not allowed */ UPDATE x SET x = x;
/* not allowed */ UPDATE x SET x = x;
MERGE INTO x AS x USING (VALUES (1)) AS x ON x.x = x.x WHEN MATCHED THEN UPDATE SET x = x /* not allowed */;
MERGE INTO x AS x USING (VALUES (1)) AS x ON x.x = x.x WHEN MATCHED THEN UPDATE SET x = x /* not allowed */;
MERGE INTO x AS x USING (VALUES (1)) AS x ON x.x = x.x WHEN MATCHED THEN UPDATE SET x = x /* not allowed */;
/* not allowed */ RESET SESSION AUTHORIZATION;
GRANT SELECT ON x TO x;
GRANT UPDATE(x, x) ON x TO x;
SET SESSION AUTHORIZATION regress_view_user3;
SELECT * FROM x;
/* ok */ UPDATE x SET x = x;
/* not allowed */ UPDATE x SET x = x;
/* not allowed */ UPDATE x SET x = x;
MERGE INTO x AS x USING (VALUES (1)) AS x ON x.x = x.x WHEN MATCHED THEN UPDATE SET x = x /* ok */;
MERGE INTO x AS x USING (VALUES (1)) AS x ON x.x = x.x WHEN MATCHED THEN UPDATE SET x = x /* not allowed */;
MERGE INTO x AS x USING (VALUES (1)) AS x ON x.x = x.x WHEN MATCHED THEN UPDATE SET x = x /* not allowed */;
/* ok */ RESET SESSION AUTHORIZATION;
REVOKE SELECT, UPDATE ON base_tbl FROM regress_view_user1;
SET SESSION AUTHORIZATION regress_view_user1;
SELECT * FROM x;
/* not allowed */ UPDATE x SET x = x;
MERGE INTO x AS x USING (VALUES (1)) AS x ON x.x = x.x WHEN MATCHED THEN UPDATE SET x = x /* not allowed */;
/* not allowed */ SET SESSION AUTHORIZATION regress_view_user2;
SELECT * FROM x;
/* ok */ UPDATE x SET x = x;
/* not allowed */ UPDATE x SET x = x;
/* not allowed */ UPDATE x SET x = x;
MERGE INTO x AS x USING (VALUES (1)) AS x ON x.x = x.x WHEN MATCHED THEN UPDATE SET x = x /* ok */;
MERGE INTO x AS x USING (VALUES (1)) AS x ON x.x = x.x WHEN MATCHED THEN UPDATE SET x = x /* not allowed */;
MERGE INTO x AS x USING (VALUES (1)) AS x ON x.x = x.x WHEN MATCHED THEN UPDATE SET x = x /* not allowed */;
/* ok */ SET SESSION AUTHORIZATION regress_view_user3;
SELECT * FROM x;
/* ok */ UPDATE x SET x = x;
/* not allowed */ UPDATE x SET x = x;
/* not allowed */ UPDATE x SET x = x;
MERGE INTO x AS x USING (VALUES (1)) AS x ON x.x = x.x WHEN MATCHED THEN UPDATE SET x = x /* ok */;
MERGE INTO x AS x USING (VALUES (1)) AS x ON x.x = x.x WHEN MATCHED THEN UPDATE SET x = x /* not allowed */;
MERGE INTO x AS x USING (VALUES (1)) AS x ON x.x = x.x WHEN MATCHED THEN UPDATE SET x = x /* not allowed */;
/* ok */ RESET SESSION AUTHORIZATION;
REVOKE SELECT, UPDATE ON base_tbl FROM regress_view_user2;
SET SESSION AUTHORIZATION regress_view_user2;
SELECT * FROM x;
/* not allowed */ UPDATE x SET x = x;
/* not allowed */ UPDATE x SET x = x;
/* not allowed */ UPDATE x SET x = x;
MERGE INTO x AS x USING (VALUES (1)) AS x ON x.x = x.x WHEN MATCHED THEN UPDATE SET x = x /* not allowed */;
MERGE INTO x AS x USING (VALUES (1)) AS x ON x.x = x.x WHEN MATCHED THEN UPDATE SET x = x /* not allowed */;
MERGE INTO x AS x USING (VALUES (1)) AS x ON x.x = x.x WHEN MATCHED THEN UPDATE SET x = x /* not allowed */;
/* not allowed */ SET SESSION AUTHORIZATION regress_view_user3;
SELECT * FROM x;
/* ok */ UPDATE x SET x = x;
/* not allowed */ UPDATE x SET x = x;
/* not allowed */ UPDATE x SET x = x;
MERGE INTO x AS x USING (VALUES (1)) AS x ON x.x = x.x WHEN MATCHED THEN UPDATE SET x = x /* ok */;
MERGE INTO x AS x USING (VALUES (1)) AS x ON x.x = x.x WHEN MATCHED THEN UPDATE SET x = x /* not allowed */;
MERGE INTO x AS x USING (VALUES (1)) AS x ON x.x = x.x WHEN MATCHED THEN UPDATE SET x = x /* not allowed */;
/* ok */ RESET SESSION AUTHORIZATION;
DROP TABLE x CASCADE;
DROP USER regress_view_user1;
DROP USER regress_view_user2;
DROP USER regress_view_user3;
/* column defaults */ CREATE TABLE x (x INT PRIMARY KEY, x TEXT DEFAULT 'Unspecified', x SERIAL);
INSERT INTO x VALUES (1, 'Row 1');
INSERT INTO x VALUES (2, 'Row 2');
INSERT INTO x VALUES (3);
CREATE VIEW x AS SELECT x AS x, x AS x FROM x;
ALTER VIEW x ALTER COLUMN x SET DEFAULT 'View default';
INSERT INTO x VALUES (4, 'Row 4');
INSERT INTO x (x) VALUES (5);
MERGE INTO x AS x USING (VALUES (6)) AS x ON x.x = x.x WHEN NOT MATCHED THEN INSERT (x) VALUES (x.x);
SELECT * FROM x;
DROP TABLE x CASCADE;
/* Table having triggers */ CREATE TABLE x (x INT PRIMARY KEY, x TEXT DEFAULT 'Unspecified');
INSERT INTO x VALUES (1, 'Row 1');
INSERT INTO x VALUES (2, 'Row 2');
x AS x;
x AS x;
COMMIT;
CREATE TRIGGER rw_view1_ins_trig AFTER INSERT ON base_tbl   FOR EACH ROW EXECUTE PROCEDURE rw_view1_trig_fn();
CREATE VIEW x AS SELECT x AS x, x AS x FROM x;
INSERT INTO x VALUES (3, 'Row 3');
SELECT * FROM x;
DROP VIEW x;
DROP TRIGGER rw_view1_ins_trig on base_tbl;
DROP FUNCTION x;
DROP TABLE x;
/* view with ORDER BY */ CREATE TABLE x (x INT, x INT);
INSERT INTO x VALUES (1, 2), (4, 5), (3, -3);
CREATE VIEW x AS SELECT * FROM x ORDER BY x + x NULLS LAST;
SELECT * FROM x;
INSERT INTO x VALUES (7, -8);
SELECT * FROM x;
EXPLAIN (verbose, costs off) UPDATE rw_view1 SET b = b + 1 RETURNING *;
UPDATE x SET x = x + 1 RETURNING *;
SELECT * FROM x;
DROP TABLE x CASCADE;
/* multiple array-column updates */ CREATE TABLE x (x INT, x ARRAY<INT>);
INSERT INTO x VALUES (1, ARRAY(2)), (3, ARRAY(4));
CREATE VIEW x AS SELECT * FROM x;
UPDATE x SET x[0] = 42, x[1] = 77 WHERE x = 3;
SELECT * FROM x;
DROP TABLE x CASCADE;
/* views with updatable and non-updatable columns */ CREATE TABLE x (x DOUBLE);
INSERT INTO x SELECT x / 10.0 FROM x AS x;
CREATE VIEW x AS SELECT x, SIN(x) AS x, x, COS(x) AS x FROM x WHERE x <> 0 ORDER BY ABS(x) NULLS LAST;
INSERT INTO x VALUES (NULL, NULL, 1.1, NULL);
/* should fail */ INSERT INTO x (x, x, x) VALUES (NULL, NULL, 1.1);
/* should fail */ INSERT INTO x (x, x, x) VALUES (DEFAULT, DEFAULT, 1.1);
/* should fail */ INSERT INTO x (x) VALUES (1.1) RETURNING x, x, x;
/* OK */ UPDATE x SET x = x WHERE x = 1.1;
/* should fail */ UPDATE x SET x = 1.05 WHERE x = 1.1 RETURNING x;
/* OK */ DELETE FROM x WHERE x = 1.05;
/* OK */ CREATE VIEW x AS SELECT x, x, x / x AS x, x AS x, x FROM x;
INSERT INTO x VALUES (NULL, NULL, NULL, 1.1, NULL);
/* should fail */ INSERT INTO x (x, x, x) VALUES (NULL, NULL, 1.1);
/* should fail */ INSERT INTO x (x) VALUES (1.1) RETURNING x;
/* OK */ UPDATE x SET x = x WHERE x = 1.1;
/* should fail */ UPDATE x SET x = x WHERE x = 1.1;
/* should fail */ UPDATE x SET x = 1.05 WHERE x = 1.1;
/* OK */ DELETE FROM x WHERE x = 1.05 RETURNING x, x, x, x;
/* OK */ CREATE VIEW x AS SELECT x, x, x / x AS x, x FROM x;
INSERT INTO x VALUES (NULL, NULL, NULL, NULL);
/* should fail */ INSERT INTO x (x) VALUES (NULL);
/* should fail */ UPDATE x SET x = x;
/* should fail */ DELETE FROM x WHERE x = SIN(0.1);
/* should be OK */ SELECT * FROM x ORDER BY x NULLS LAST;
SELECT x, x FROM x.x WHERE x LIKE r_\\_view% ORDER BY x NULLS LAST;
SELECT x, x, x FROM x.x WHERE x LIKE r_\\_view% ORDER BY x NULLS LAST;
SELECT x, x, x FROM x.x WHERE x LIKE r_\\_view% ORDER BY x NULLS LAST, x NULLS LAST;
SELECT x & 4 <> 0 AS x, x & 8 <> 0 AS x, x & 16 <> 0 AS x FROM x.x AS x;
DROP TABLE x CASCADE;
/* view on table with GENERATED columns */ CREATE TABLE x (x INT, x INT AS x + 1);
CREATE VIEW x AS SELECT * FROM x;
INSERT INTO x (x) VALUES (1);
INSERT INTO x (x) VALUES (2);
INSERT INTO x (x, x) VALUES (3, DEFAULT);
INSERT INTO x (x, x) VALUES (4, DEFAULT);
INSERT INTO x (x, x) VALUES (5, 6);
/* error */ INSERT INTO x (x, x) VALUES (6, 7);
/* error */ SELECT * FROM x;
UPDATE x SET x = 2000 WHERE x = 2;
UPDATE x SET x = 3000 WHERE x = 3;
SELECT * FROM x;
DROP TABLE x CASCADE;
/* inheritance tests */ CREATE TABLE x (x INT);
CREATE TABLE x (CHECK (x > 0)) INHERITS (x);
INSERT INTO x SELECT * FROM x;
INSERT INTO x SELECT * FROM x;
CREATE VIEW x AS SELECT * FROM x;
CREATE VIEW x AS SELECT * FROM ONLY x;
SELECT * FROM x ORDER BY x NULLS LAST;
SELECT * FROM ONLY x ORDER BY x NULLS LAST;
SELECT * FROM x ORDER BY x NULLS LAST;
INSERT INTO x VALUES (-100), (100);
INSERT INTO x VALUES (-200), (200);
UPDATE x SET x = x * 10 WHERE x IN (-1, 1);
/* Should produce -10 and 10 */ UPDATE ONLY x SET x = x * 10 WHERE x IN (-2, 2);
/* Should produce -20 and 20 */ UPDATE x SET x = x * 10 WHERE x IN (-3, 3);
/* Should produce -30 only */ UPDATE ONLY x SET x = x * 10 WHERE x IN (-4, 4);
/* Should produce -40 only */ DELETE FROM x WHERE x IN (-5, 5);
/* Should delete -5 and 5 */ DELETE FROM ONLY x WHERE x IN (-6, 6);
/* Should delete -6 and 6 */ DELETE FROM x WHERE x IN (-7, 7);
/* Should delete -7 only */ DELETE FROM ONLY x WHERE x IN (-8, 8);
/* Should delete -8 only */ SELECT * FROM ONLY x ORDER BY x NULLS LAST;
SELECT * FROM x ORDER BY x NULLS LAST;
MERGE INTO x AS x USING (VALUES (-200), (10)) AS x ON x.x = x.x WHEN MATCHED THEN UPDATE SET x = x.x + 1;
MERGE INTO ONLY x AS x USING (VALUES (-100), (20)) AS x ON x.x = x.x WHEN MATCHED THEN UPDATE SET x = x.x + 1 /* Should produce -199 and 11 */;
MERGE INTO x AS x USING (VALUES (-40), (3)) AS x ON x.x = x.x WHEN MATCHED THEN UPDATE SET x = x.x + 1 /* Should produce -99 and 21 */;
MERGE INTO ONLY x AS x USING (VALUES (-30), (4)) AS x ON x.x = x.x WHEN MATCHED THEN UPDATE SET x = x.x + 1 /* Should produce -39 only */;
/* Should produce -29 only */ SELECT * FROM ONLY x ORDER BY x NULLS LAST;
SELECT * FROM x ORDER BY x NULLS LAST;
CREATE TABLE x (x INT);
CREATE TABLE x INHERITS (x);
INSERT INTO x VALUES (7), (200);
INSERT INTO x VALUES (8), (100);
EXPLAIN (costs off) UPDATE rw_view1 SET a = a + 1000 FROM other_tbl_parent WHERE a = id;
UPDATE x SET x = x + 1000 FROM x WHERE x = x;
SELECT * FROM ONLY x ORDER BY x NULLS LAST;
SELECT * FROM x ORDER BY x NULLS LAST;
DROP TABLE x CASCADE;
/* simple WITH CHECK OPTION */ CREATE TABLE x (x INT, x INT DEFAULT 10);
INSERT INTO x VALUES (1, 2), (2, 3), (1, -1);
CREATE VIEW rw_view1 AS SELECT * FROM base_tbl WHERE a < b   WITH LOCAL CHECK OPTION;
INSERT INTO x VALUES (3, 4);
/* ok */ INSERT INTO x VALUES (4, 3);
/* should fail */ INSERT INTO x VALUES (5, NULL);
/* should fail */ UPDATE x SET x = 5 WHERE x = 3;
/* ok */ UPDATE x SET x = -5 WHERE x = 3;
/* should fail */ INSERT INTO x (x) VALUES (9);
/* ok */ INSERT INTO x (x) VALUES (10);
/* should fail */ SELECT * FROM x ORDER BY x NULLS LAST, x NULLS LAST;
MERGE INTO x AS x USING (VALUES (10)) AS x ON x.x = x.x WHEN NOT MATCHED THEN INSERT VALUES (x.x, x.x + 1);
MERGE INTO x AS x USING (VALUES (11)) AS x ON x.x = x.x WHEN NOT MATCHED THEN INSERT VALUES (x.x, x.x - 1) /* ok */;
MERGE INTO x AS x USING (VALUES (1)) AS x ON x.x = x.x WHEN MATCHED THEN UPDATE SET x = x.x - 1 /* should fail */;
MERGE INTO x AS x USING (VALUES (2)) AS x ON x.x = x.x WHEN MATCHED THEN UPDATE SET x = x.x + 1 /* ok */;
/* should fail */ SELECT * FROM x ORDER BY x NULLS LAST, x NULLS LAST;
DROP TABLE x CASCADE;
/* WITH LOCAL/CASCADED CHECK OPTION */ CREATE TABLE x (x INT);
CREATE VIEW x AS SELECT * FROM x WHERE x > 0;
CREATE VIEW rw_view2 AS SELECT * FROM rw_view1 WHERE a < 10   WITH CHECK OPTION;
INSERT INTO x VALUES (-5);
/* should fail */ INSERT INTO x VALUES (5);
/* ok */ INSERT INTO x VALUES (15);
/* should fail */ SELECT * FROM x;
UPDATE x SET x = x - 10;
/* should fail */ UPDATE x SET x = x + 10;
/* should fail */ CREATE OR REPLACE VIEW rw_view2 AS SELECT * FROM rw_view1 WHERE a < 10   WITH LOCAL CHECK OPTION;
INSERT INTO x VALUES (-10);
/* ok, but not in view */ INSERT INTO x VALUES (20);
/* should fail */ SELECT * FROM x;
ALTER VIEW x SET x = x;
ALTER VIEW x SET x = x /* invalid */;
INSERT INTO x VALUES (-20);
/* should fail */ INSERT INTO x VALUES (30);
/* should fail */ ALTER VIEW rw_view2 RESET (check_option);
INSERT INTO x VALUES (30);
/* ok, but not in view */ SELECT * FROM x;
DROP TABLE x CASCADE;
/* WITH CHECK OPTION with no local view qual */ CREATE TABLE x (x INT);
CREATE VIEW rw_view1 AS SELECT * FROM base_tbl WITH CHECK OPTION;
CREATE VIEW x AS SELECT * FROM x WHERE x > 0;
CREATE VIEW rw_view3 AS SELECT * FROM rw_view2 WITH CHECK OPTION;
SELECT * FROM x.x WHERE x LIKE rw\\_view_ ORDER BY x NULLS LAST;
INSERT INTO x VALUES (-1);
/* ok */ INSERT INTO x VALUES (1);
/* ok */ INSERT INTO x VALUES (-2);
/* ok, but not in view */ INSERT INTO x VALUES (2);
/* ok */ INSERT INTO x VALUES (-3);
/* should fail */ INSERT INTO x VALUES (3);
/* ok */ DROP TABLE x CASCADE;
/* WITH CHECK OPTION with scalar array ops */ CREATE TABLE x (x INT, x ARRAY<INT>);
CREATE VIEW rw_view1 AS SELECT * FROM base_tbl WHERE a = ANY (b)   WITH CHECK OPTION;
INSERT INTO x VALUES (1, ARRAY(1, 2, 3));
/* ok */ INSERT INTO x VALUES (10, ARRAY(4, 5));
/* should fail */ UPDATE x SET x[1] = -x[1] WHERE x = 1;
/* ok */ UPDATE x SET x[0] = -x[0] WHERE x = 1;
/* should fail */ PREPARE ins(int, int[]) AS INSERT INTO rw_view1 VALUES($1, $2);
EXECUTE ins(2, ARRAY[1,2,3]);
/* ok */ EXECUTE ins(10, ARRAY[4,5]);
DROP TABLE x CASCADE;
/* WITH CHECK OPTION with subquery */ CREATE TABLE x (x INT);
CREATE TABLE x (x INT PRIMARY KEY);
INSERT INTO x SELECT * FROM x;
CREATE VIEW rw_view1 AS   SELECT * FROM base_tbl b   WHERE EXISTS(SELECT 1 FROM ref_tbl r WHERE r.a = b.a)   WITH CHECK OPTION;
INSERT INTO x VALUES (5);
/* ok */ INSERT INTO x VALUES (15);
/* should fail */ UPDATE x SET x = x + 5;
/* ok */ UPDATE x SET x = x + 5;
/* should fail */ EXPLAIN (costs off) INSERT INTO rw_view1 VALUES (5);
EXPLAIN (costs off) UPDATE rw_view1 SET a = a + 5;
/* WITH CHECK OPTION with BEFORE trigger on base table */ CREATE TABLE x (x INT, x INT);
x AS x;
COMMIT;
CREATE TRIGGER base_tbl_trig BEFORE INSERT OR UPDATE ON base_tbl   FOR EACH ROW EXECUTE PROCEDURE base_tbl_trig_fn();
CREATE VIEW rw_view1 AS SELECT * FROM base_tbl WHERE a < b WITH CHECK OPTION;
INSERT INTO x VALUES (5, 0);
/* ok */ INSERT INTO x VALUES (15, 20);
/* should fail */ UPDATE x SET x = 20, x = 30;
/* should fail */ DROP TABLE x CASCADE;
DROP FUNCTION x;
/* WITH LOCAL CHECK OPTION with INSTEAD OF trigger on base view */ CREATE TABLE x (x INT, x INT);
CREATE VIEW x AS SELECT x FROM x WHERE x < x;
x AS x;
x AS x;
x AS x;
COMMIT;
CREATE TRIGGER rw_view1_trig   INSTEAD OF INSERT OR UPDATE OR DELETE ON rw_view1   FOR EACH ROW EXECUTE PROCEDURE rw_view1_trig_fn();
CREATE VIEW rw_view2 AS   SELECT * FROM rw_view1 WHERE a > 0 WITH LOCAL CHECK OPTION;
INSERT INTO x VALUES (-5);
MERGE INTO x AS x USING (VALUES (-5)) AS x ON x.x = x.x WHEN NOT MATCHED THEN INSERT VALUES (x.x) /* should fail */;
/* should fail */ INSERT INTO x VALUES (5);
MERGE INTO x AS x USING (VALUES (6)) AS x ON x.x = x.x WHEN NOT MATCHED THEN INSERT VALUES (x.x) /* ok */;
/* ok */ INSERT INTO x VALUES (50);
MERGE INTO x AS x USING (VALUES (60)) AS x ON x.x = x.x WHEN NOT MATCHED THEN INSERT VALUES (x.x) /* ok, but not in view */;
/* ok, but not in view */ UPDATE x SET x = x - 10;
MERGE INTO x AS x USING (VALUES (6)) AS x ON x.x = x.x WHEN MATCHED THEN UPDATE SET x = x.x - 10 /* should fail */;
/* should fail */ SELECT * FROM x;
ALTER VIEW x SET x = x /* Check option won't cascade down to base view with INSTEAD OF triggers */;
INSERT INTO x VALUES (100);
/* ok, but not in view (doesn't fail rw_view1's check) */ UPDATE x SET x = 200 WHERE x = 5;
/* ok, but not in view (doesn't fail rw_view1's check) */ SELECT * FROM x;
/* Neither local nor cascaded check options work with INSTEAD rules */ DROP TRIGGER rw_view1_trig ON rw_view1;
CREATE RULE rw_view1_ins_rule AS ON INSERT TO rw_view1   DO INSTEAD INSERT INTO base_tbl VALUES (NEW.a, 10);
CREATE RULE rw_view1_upd_rule AS ON UPDATE TO rw_view1   DO INSTEAD UPDATE base_tbl SET a=NEW.a WHERE a=OLD.a;
INSERT INTO x VALUES (-10);
/* ok, but not in view (doesn't fail rw_view2's check) */ INSERT INTO x VALUES (5);
/* ok */ INSERT INTO x VALUES (20);
/* ok, but not in view (doesn't fail rw_view1's check) */ UPDATE x SET x = 30 WHERE x = 5;
/* ok, but not in view (doesn't fail rw_view1's check) */ INSERT INTO x VALUES (5);
/* ok */ UPDATE x SET x = -5 WHERE x = 5;
/* ok, but not in view (doesn't fail rw_view2's check) */ SELECT * FROM x;
DROP TABLE x CASCADE;
DROP FUNCTION x;
CREATE TABLE x (x INT);
CREATE VIEW x AS SELECT x, 10 AS x FROM x;
CREATE RULE rw_view1_ins_rule AS ON INSERT TO rw_view1   DO INSTEAD INSERT INTO base_tbl VALUES (NEW.a);
CREATE VIEW rw_view2 AS   SELECT * FROM rw_view1 WHERE a > b WITH LOCAL CHECK OPTION;
INSERT INTO x VALUES (2, 3);
/* ok, but not in view (doesn't fail rw_view2's check) */ DROP TABLE x CASCADE;
/* security barrier view */ CREATE TABLE x (x TEXT, x TEXT);
INSERT INTO x VALUES ('Tom', 'public'), ('Dick', 'private'), ('Harry', 'public');
CREATE VIEW x AS SELECT x FROM x WHERE x = 'public';
x AS x;
COMMIT;
COMMIT;
SELECT * FROM x WHERE SNOOP(x);
UPDATE x SET x = x WHERE SNOOP(x);
DELETE FROM x WHERE NOT SNOOP(x);
ALTER VIEW x SET x = TRUE;
SELECT x, x FROM x.x WHERE x = 'rw_view1';
SELECT x, x, x FROM x.x WHERE x = 'rw_view1';
SELECT x, x, x FROM x.x WHERE x = 'rw_view1' ORDER BY x NULLS LAST;
SELECT * FROM x WHERE SNOOP(x);
UPDATE x SET x = x WHERE SNOOP(x);
DELETE FROM x WHERE NOT SNOOP(x);
MERGE INTO x AS x USING (VALUES ('Tom'), ('Dick'), ('Harry')) AS x ON x.x = x.x WHEN MATCHED AND SNOOP(x.x) THEN UPDATE SET x = x.x;
EXPLAIN (costs off) SELECT * FROM rw_view1 WHERE snoop(person);
EXPLAIN (costs off) UPDATE rw_view1 SET person=person WHERE snoop(person);
EXPLAIN (costs off) DELETE FROM rw_view1 WHERE NOT snoop(person);
EXPLAIN (costs off) MERGE INTO rw_view1 t   USING (VALUES ('Tom'), ('Dick'), ('Harry')) AS v(person) ON t.person = v.person   WHEN MATCHED AND snoop(t.person) THEN UPDATE SET person = v.person;
/* security barrier view on top of security barrier view */ CREATE VIEW x WITH (security_barrier=TRUE) AS SELECT * FROM x WHERE SNOOP(x);
SELECT x, x FROM x.x WHERE x = 'rw_view2';
SELECT x, x, x FROM x.x WHERE x = 'rw_view2';
SELECT x, x, x FROM x.x WHERE x = 'rw_view2' ORDER BY x NULLS LAST;
SELECT * FROM x WHERE SNOOP(x);
UPDATE x SET x = x WHERE SNOOP(x);
DELETE FROM x WHERE NOT SNOOP(x);
MERGE INTO x AS x USING (VALUES ('Tom'), ('Dick'), ('Harry')) AS x ON x.x = x.x WHEN MATCHED AND SNOOP(x.x) THEN UPDATE SET x = x.x;
EXPLAIN (costs off) SELECT * FROM rw_view2 WHERE snoop(person);
EXPLAIN (costs off) UPDATE rw_view2 SET person=person WHERE snoop(person);
EXPLAIN (costs off) DELETE FROM rw_view2 WHERE NOT snoop(person);
EXPLAIN (costs off) MERGE INTO rw_view2 t   USING (VALUES ('Tom'), ('Dick'), ('Harry')) AS v(person) ON t.person = v.person   WHEN MATCHED AND snoop(t.person) THEN UPDATE SET person = v.person;
DROP TABLE x CASCADE;
/* security barrier view on top of table with rules */ CREATE TABLE x (x INT PRIMARY KEY, x TEXT, x BOOLEAN);
INSERT INTO x VALUES (1, 'Row 1', FALSE), (2, 'Row 2', TRUE);
CREATE RULE base_tbl_ins_rule AS ON INSERT TO base_tbl   WHERE EXISTS (SELECT 1 FROM base_tbl t WHERE t.id = new.id)   DO INSTEAD     UPDATE base_tbl SET data = new.data, deleted = false WHERE id = new.id;
CREATE RULE base_tbl_del_rule AS ON DELETE TO base_tbl   DO INSTEAD     UPDATE base_tbl SET deleted = true WHERE id = old.id;
CREATE VIEW x WITH (security_barrier=TRUE) AS SELECT x, x FROM x WHERE NOT x;
SELECT * FROM x;
EXPLAIN (costs off) DELETE FROM rw_view1 WHERE id = 1 AND snoop(data);
DELETE FROM x WHERE x = 1 AND SNOOP(x);
EXPLAIN (costs off) INSERT INTO rw_view1 VALUES (2, 'New row 2');
INSERT INTO x VALUES (2, 'New row 2');
SELECT * FROM x;
DROP TABLE x CASCADE;
/* security barrier view based on inheritance set */ CREATE TABLE x (x INT, x DOUBLE, x TEXT);
CREATE INDEX x ON x(x NULLS LAST);
INSERT INTO x SELECT x, x, 't1' FROM x AS x;
ANALYZE x;
CREATE TABLE x (x TEXT) INHERITS (x);
CREATE INDEX x ON x(x NULLS LAST);
INSERT INTO x SELECT x, x, 't11', 't11d' FROM x AS x;
ANALYZE x;
CREATE TABLE x (x ARRAY<INT>) INHERITS (x);
CREATE INDEX x ON x(x NULLS LAST);
INSERT INTO x SELECT x, x, 't12', CAST('{1,2}' AS ARRAY<INT>) FROM x AS x;
ANALYZE x;
CREATE TABLE x INHERITS (x, x);
CREATE INDEX x ON x(x NULLS LAST);
INSERT INTO x SELECT x, x, 't111', 't111d', CAST('{1,1,1}' AS ARRAY<INT>) FROM x AS x;
ANALYZE x;
CREATE VIEW x WITH (security_barrier=TRUE) AS SELECT *, (SELECT x FROM x WHERE x.x = x.x LIMIT 1) AS x FROM x WHERE x > 5 AND EXISTS(SELECT 1 FROM x WHERE x.x = x.x);
SELECT * FROM x WHERE x = 3;
/* should not see anything */ SELECT * FROM x WHERE x = 8;
EXPLAIN (VERBOSE, COSTS OFF) UPDATE v1 SET a=100 WHERE snoop(a) AND leakproof(a) AND a < 7 AND a != 6;
UPDATE x SET x = 100 WHERE SNOOP(x) AND LEAKPROOF(x) AND x < 7 AND x <> 6;
SELECT * FROM x WHERE x = 100;
/* Nothing should have been changed to 100 */ SELECT * FROM x WHERE x = 100;
/* Nothing should have been changed to 100 */ EXPLAIN (VERBOSE, COSTS OFF) UPDATE v1 SET a=a+1 WHERE snoop(a) AND leakproof(a) AND a = 8;
UPDATE x SET x = x + 1 WHERE SNOOP(x) AND LEAKPROOF(x) AND x = 8;
SELECT * FROM x WHERE x = 8;
DELETE FROM x WHERE SNOOP(x) AND LEAKPROOF(x);
x AS x /* should not delete everything, just where a>5 */;
DROP FUNCTION x (anyelement);
DROP FUNCTION x (anyelement);
CREATE TABLE x (x INT);
CREATE TABLE x (x INT);
CREATE TABLE x (x INT);
CREATE VIEW x AS SELECT x FROM x WHERE EXISTS(SELECT 1 FROM x JOIN x ON x = x);
INSERT INTO x VALUES (1);
SELECT * FROM x;
SELECT * FROM x;
DROP VIEW x;
DROP TABLE x;
DROP TABLE x;
DROP TABLE x;
CREATE TABLE x (x INT);
CREATE TABLE x (x INT);
CREATE TABLE x (x INT);
CREATE VIEW x AS SELECT x FROM x WHERE EXISTS(SELECT 1 FROM x JOIN x ON x = x);
INSERT INTO x VALUES (1);
INSERT INTO x VALUES (1);
SELECT * FROM x;
SELECT * FROM x;
DROP VIEW x;
DROP TABLE x;
DROP TABLE x;
DROP TABLE x;
CREATE TABLE x (x INT, x INT);
CREATE TABLE x (x INT, x INT);
CREATE TABLE x (x INT, x INT);
ALTER TABLE x DROP COLUMN x;
ALTER TABLE x DROP COLUMN x;
ALTER TABLE x DROP COLUMN x;
CREATE VIEW x AS SELECT x FROM x WHERE EXISTS(SELECT 1 FROM x JOIN x ON x = x);
INSERT INTO x VALUES (1);
INSERT INTO x VALUES (1);
SELECT * FROM x;
SELECT * FROM x;
DROP VIEW x;
DROP TABLE x;
DROP TABLE x;
DROP TABLE x;
/* Test handling of vars from correlated subqueries in quals from outer */ /* security barrier views, per bug #13988 */ CREATE TABLE x (x INT, x TEXT, x INT);
INSERT INTO x VALUES (1, 'one', 10);
CREATE TABLE x (x INT);
INSERT INTO x VALUES (10), (20);
CREATE VIEW v1 WITH (security_barrier = true) AS   SELECT * FROM t1 WHERE (a > 0)   WITH CHECK OPTION;
CREATE VIEW v2 WITH (security_barrier = true) AS   SELECT * FROM v1 WHERE EXISTS (SELECT 1 FROM t2 WHERE t2.cc = v1.c)   WITH CHECK OPTION;
INSERT INTO x VALUES (2, 'two', 20);
/* ok */ INSERT INTO x VALUES (-2, 'minus two', 20);
/* not allowed */ INSERT INTO x VALUES (3, 'three', 30);
/* not allowed */ UPDATE x SET x = 'ONE' WHERE x = 1;
/* ok */ UPDATE x SET x = -1 WHERE x = 1;
/* not allowed */ UPDATE x SET x = 30 WHERE x = 1;
/* not allowed */ DELETE FROM x WHERE x = 2;
/* ok */ SELECT * FROM x;
DROP VIEW x;
DROP VIEW x;
DROP TABLE x;
DROP TABLE x;
/* Test sub-select in nested security barrier views, per bug #17972 */ CREATE TABLE x (x INT);
CREATE VIEW x WITH (security_barrier=TRUE) AS SELECT * FROM x;
CREATE RULE v1_upd_rule AS ON UPDATE TO v1 DO INSTEAD   UPDATE t1 SET a = NEW.a WHERE a = OLD.a;
CREATE VIEW x WITH (security_barrier=TRUE) AS SELECT * FROM x WHERE EXISTS(SELECT 1);
EXPLAIN (COSTS OFF) UPDATE v2 SET a = 1;
DROP VIEW x;
DROP VIEW x;
DROP TABLE x;
/* Test CREATE OR REPLACE VIEW turning a non-updatable view into an */ /* auto-updatable view and adding check options in a single step */ CREATE TABLE x (x INT, x TEXT);
CREATE VIEW x AS SELECT CAST(NULL AS INT) AS x;
CREATE OR REPLACE VIEW v1 AS SELECT * FROM t1 WHERE a > 0 WITH CHECK OPTION;
INSERT INTO x VALUES (1, 'ok');
/* ok */ INSERT INTO x VALUES (-1, 'invalid');
/* should fail */ DROP VIEW x;
DROP TABLE x;
/* check that an auto-updatable view on a partitioned table works correctly */ CREATE TABLE x (x INT, x INT, x VARCHAR) WITH (PARTITIONED_BY=RANGE(x, x));
CREATE TABLE x (x INT NOT NULL, x VARCHAR, x INT NOT NULL) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x (LIKE x);
ALTER TABLE x drop a;
ALTER TABLE x ADD COLUMN x INT;
ALTER TABLE x drop a;
ALTER TABLE x ADD COLUMN x INT NOT NULL;
alter table uv_pt1 attach partition uv_pt11 for values from (2) to (5);
alter table uv_pt attach partition uv_pt1 for values from (1, 2) to (1, 10);
CREATE VIEW x AS SELECT * FROM x;
SELECT x & 4 <> 0 AS x, x & 8 <> 0 AS x, x & 16 <> 0 AS x FROM x.x AS x;
SELECT x.pg_column_is_updatable(CAST('uv_pt' AS REGCLASS), CAST(1 AS SMALLINT), FALSE);
SELECT x.pg_column_is_updatable(CAST('uv_pt' AS REGCLASS), CAST(2 AS SMALLINT), FALSE);
SELECT x, x, x FROM x.x WHERE x = 'uv_ptv';
SELECT x, x, x FROM x.x WHERE x = 'uv_ptv' ORDER BY x NULLS LAST;
INSERT INTO x VALUES (1, 2);
SELECT CAST(x AS REGCLASS), * FROM x;
create view uv_ptv_wco as select * from uv_pt where a = 0 with check option;
INSERT INTO x VALUES (1, 2);
MERGE INTO x AS x USING (VALUES (1, 2), (1, 4)) AS x ON x.x = x.x /* fail: matches 2 src rows */ WHEN MATCHED THEN UPDATE SET x = x.x + 1 WHEN NOT MATCHED THEN INSERT VALUES (x.x, x.x + 1);
MERGE INTO x AS x USING (VALUES (1, 2), (1, 4)) AS x ON x.x = x.x AND x.x = x.x WHEN MATCHED THEN UPDATE SET x = x.x + 1 WHEN NOT MATCHED THEN INSERT VALUES (x.x, x.x + 1);
MERGE INTO x AS x USING (VALUES (1, 2), (1, 3)) AS x ON x.x = x.x AND x.x = x.x WHEN MATCHED THEN UPDATE SET x = x.x + 1 WHEN NOT MATCHED THEN INSERT VALUES (x.x, x.x + 1) /* fail: no partition for b=5 */;
/* ok */ SELECT CAST(x AS REGCLASS), * FROM x ORDER BY x NULLS LAST, x NULLS LAST;
/* check that wholerow vars appearing in WITH CHECK OPTION constraint expressions */ /* work fine with partitioned tables */ CREATE TABLE x (x INT) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN (1);
create view wcowrtest_v as select * from wcowrtest where wcowrtest = '(2)'::wcowrtest with check option;
INSERT INTO x VALUES (1);
ALTER TABLE x ADD COLUMN x TEXT;
CREATE TABLE x (x TEXT, x INT, x INT);
ALTER TABLE x drop c;
alter table wcowrtest attach partition wcowrtest2 for values in (2);
CREATE TABLE x (x INT, x TEXT);
INSERT INTO x VALUES (1, 'a'), (2, 'b');
create view wcowrtest_v2 as     select *       from wcowrtest r       where r in (select s from sometable s where r.a = s.a) with check option;
/* WITH CHECK qual will be processed with wcowrtest2's */ /* rowtype after tuple-routing */ INSERT INTO x VALUES (2, 'no such row in sometable');
/* Check INSERT .. ON CONFLICT DO UPDATE works correctly when the view's */ /* columns are named and ordered differently than the underlying table's. */ CREATE TABLE x (x TEXT UNIQUE, x DOUBLE);
INSERT INTO x VALUES ('xyxyxy', 0);
CREATE VIEW x AS SELECT x, x + 1 AS x, x, CAST('2.0' AS TEXT) AS x FROM x;
INSERT INTO x (x, x) VALUES ('xyxyxy', 1) ON CONFLICT(x) DO UPDATE SET x = x.x;
SELECT * FROM x;
INSERT INTO x (x, x) VALUES ('xyxyxy', 1) ON CONFLICT(x) DO UPDATE SET x = x.x;
SELECT * FROM x;
/* OK to access view columns that are not present in underlying base */ /* relation in the ON CONFLICT portion of the query */ INSERT INTO x (x, x) VALUES ('xyxyxy', 3) ON CONFLICT(x) DO UPDATE SET x = CAST(x.x AS DOUBLE);
SELECT * FROM x;
EXPLAIN (costs off) insert into uv_iocu_view (a, b) values ('xyxyxy', 3)    on conflict (a) do update set b = excluded.b where excluded.c > 0;
INSERT INTO x (x, x) VALUES ('xyxyxy', 3) ON CONFLICT(x) DO UPDATE SET x = x.x WHERE x.x > 0;
SELECT * FROM x;
DROP VIEW x;
DROP TABLE x;
/* Test whole-row references to the view */ CREATE TABLE x (x INT UNIQUE, x TEXT);
CREATE VIEW x AS SELECT x AS x, x AS x, CAST(x AS TEXT) AS x FROM x;
INSERT INTO x (x, x) VALUES (1, 'x');
EXPLAIN (costs off) insert into uv_iocu_view (aa,bb) values (1,'y')    on conflict (aa) do update set bb = 'Rejected: '||excluded.*    where excluded.aa > 0    and excluded.bb != ''    and excluded.cc is not null;
INSERT INTO x (x, x) VALUES (1, 'y') ON CONFLICT(x) DO UPDATE SET x = 'Rejected: ' || x.* WHERE x.x > 0 AND x.x <> '' AND NOT x.x IS NULL;
SELECT * FROM x;
/* Test omitting a column of the base relation */ DELETE FROM x;
INSERT INTO x (x, x) VALUES (1, 'x');
INSERT INTO x (x) VALUES (1) ON CONFLICT(x) DO UPDATE SET x = 'Rejected: ' || x.*;
SELECT * FROM x;
ALTER TABLE x ALTER COLUMN x SET DEFAULT 'table default';
INSERT INTO x (x) VALUES (1) ON CONFLICT(x) DO UPDATE SET x = 'Rejected: ' || x.*;
SELECT * FROM x;
ALTER VIEW x ALTER COLUMN x SET DEFAULT 'view default';
INSERT INTO x (x) VALUES (1) ON CONFLICT(x) DO UPDATE SET x = 'Rejected: ' || x.*;
SELECT * FROM x;
/* Should fail to update non-updatable columns */ INSERT INTO x (x) VALUES (1) ON CONFLICT(x) DO UPDATE SET x = 'XXX';
DROP VIEW x;
DROP TABLE x;
/* ON CONFLICT DO UPDATE permissions checks */ create user regress_view_user1;
create user regress_view_user2;
set session authorization regress_view_user1;
CREATE TABLE x (x INT UNIQUE, x TEXT, x DOUBLE);
INSERT INTO x VALUES (1, 'xxx', 1.0);
CREATE VIEW x AS SELECT x AS x, x AS x, x AS x FROM x;
GRANT SELECT(x, x) ON x TO x;
GRANT INSERT ON x TO x;
GRANT UPDATE(x) ON x TO x;
set session authorization regress_view_user2;
INSERT INTO x VALUES ('yyy', 2.0, 1) ON CONFLICT(x) DO UPDATE SET x = x.x;
/* Not allowed */ INSERT INTO x VALUES ('yyy', 2.0, 1) ON CONFLICT(x) DO UPDATE SET x = x.x;
/* Not allowed */ INSERT INTO x VALUES ('yyy', 2.0, 1) ON CONFLICT(x) DO UPDATE SET x = x.x;
/* OK */ INSERT INTO x VALUES ('zzz', 2.0, 1) ON CONFLICT(x) DO UPDATE SET x = x.x || 'xxx';
/* OK */ INSERT INTO x VALUES ('zzz', 2.0, 1) ON CONFLICT(x) DO UPDATE SET x = 3.0;
/* Not allowed */ RESET session authorization;
SELECT * FROM x;
set session authorization regress_view_user1;
GRANT SELECT(x, x) ON x TO x;
GRANT INSERT(x, x) ON x TO x;
GRANT UPDATE(x, x) ON x TO x;
set session authorization regress_view_user2;
CREATE VIEW x AS SELECT x AS x, x AS x, x AS x FROM x;
INSERT INTO x (x, x) VALUES (1, 'xxx') ON CONFLICT(x) DO UPDATE SET x = x.x;
/* Not allowed */ CREATE VIEW x AS SELECT x AS x, x AS x FROM x;
INSERT INTO x (x, x) VALUES (1, 'xxx') ON CONFLICT(x) DO UPDATE SET x = x.x;
/* OK */ RESET session authorization;
SELECT * FROM x;
set session authorization regress_view_user2;
CREATE VIEW x AS SELECT x, x, x FROM x;
INSERT INTO x (x, x) VALUES (1, 'yyy') ON CONFLICT(x) DO UPDATE SET x = x.x;
/* Not allowed */ CREATE VIEW x AS SELECT x, x FROM x;
INSERT INTO x (x, x) VALUES (1, 'yyy') ON CONFLICT(x) DO UPDATE SET x = x.x;
/* OK */ RESET session authorization;
SELECT * FROM x;
DROP VIEW x;
DROP VIEW x;
DROP VIEW x;
DROP VIEW x;
DROP VIEW x;
DROP TABLE x;
drop user regress_view_user1;
drop user regress_view_user2;
/* Test single- and multi-row inserts with table and view defaults. */ /* Table defaults should be used, unless overridden by view defaults. */ CREATE TABLE x (x INT, x TEXT DEFAULT 'Table default', x TEXT DEFAULT 'Table default', x TEXT, x TEXT);
CREATE VIEW x AS SELECT * FROM x;
ALTER VIEW x ALTER COLUMN x SET DEFAULT 'View default';
ALTER VIEW x ALTER COLUMN x SET DEFAULT 'View default';
INSERT INTO x VALUES (1);
INSERT INTO x VALUES (2), (3);
INSERT INTO x VALUES (4, DEFAULT, DEFAULT, DEFAULT, DEFAULT);
INSERT INTO x VALUES (5, DEFAULT, DEFAULT, DEFAULT, DEFAULT), (6, DEFAULT, DEFAULT, DEFAULT, DEFAULT);
INSERT INTO x VALUES (11);
INSERT INTO x VALUES (12), (13);
INSERT INTO x VALUES (14, DEFAULT, DEFAULT, DEFAULT, DEFAULT);
INSERT INTO x VALUES (15, DEFAULT, DEFAULT, DEFAULT, DEFAULT), (16, DEFAULT, DEFAULT, DEFAULT, DEFAULT);
INSERT INTO x VALUES (17), (DEFAULT);
SELECT * FROM x ORDER BY x NULLS LAST;
x AS x;
COMMIT;
create trigger base_tab_def_view_instrig instead of insert on base_tab_def_view   for each row execute function base_tab_def_view_instrig_func();
TRUNCATE TABLE x;
INSERT INTO x VALUES (1);
INSERT INTO x VALUES (2), (3);
INSERT INTO x VALUES (4, DEFAULT, DEFAULT, DEFAULT, DEFAULT);
INSERT INTO x VALUES (5, DEFAULT, DEFAULT, DEFAULT, DEFAULT), (6, DEFAULT, DEFAULT, DEFAULT, DEFAULT);
INSERT INTO x VALUES (11);
INSERT INTO x VALUES (12), (13);
INSERT INTO x VALUES (14, DEFAULT, DEFAULT, DEFAULT, DEFAULT);
INSERT INTO x VALUES (15, DEFAULT, DEFAULT, DEFAULT, DEFAULT), (16, DEFAULT, DEFAULT, DEFAULT, DEFAULT);
INSERT INTO x VALUES (17), (DEFAULT);
SELECT * FROM x ORDER BY x NULLS LAST;
/* Using an unconditional DO INSTEAD rule should also cause NULLs to be */ /* inserted where there are no view defaults. */ drop trigger base_tab_def_view_instrig on base_tab_def_view;
DROP FUNCTION x;
create rule base_tab_def_view_ins_rule as on insert to base_tab_def_view   do instead insert into base_tab_def values (new.a, new.b, new.c, new.d, new.e);
TRUNCATE TABLE x;
INSERT INTO x VALUES (1);
INSERT INTO x VALUES (2), (3);
INSERT INTO x VALUES (4, DEFAULT, DEFAULT, DEFAULT, DEFAULT);
INSERT INTO x VALUES (5, DEFAULT, DEFAULT, DEFAULT, DEFAULT), (6, DEFAULT, DEFAULT, DEFAULT, DEFAULT);
INSERT INTO x VALUES (11);
INSERT INTO x VALUES (12), (13);
INSERT INTO x VALUES (14, DEFAULT, DEFAULT, DEFAULT, DEFAULT);
INSERT INTO x VALUES (15, DEFAULT, DEFAULT, DEFAULT, DEFAULT), (16, DEFAULT, DEFAULT, DEFAULT, DEFAULT);
INSERT INTO x VALUES (17), (DEFAULT);
SELECT * FROM x ORDER BY x NULLS LAST;
/* A DO ALSO rule should cause each row to be inserted twice. The first */ /* insert should behave the same as an auto-updatable view (using table */ /* defaults, unless overridden by view defaults). The second insert should */ /* behave the same as a rule-updatable view (inserting NULLs where there are */ /* no view defaults). */ drop rule base_tab_def_view_ins_rule on base_tab_def_view;
create rule base_tab_def_view_ins_rule as on insert to base_tab_def_view   do also insert into base_tab_def values (new.a, new.b, new.c, new.d, new.e);
TRUNCATE TABLE x;
INSERT INTO x VALUES (1);
INSERT INTO x VALUES (2), (3);
INSERT INTO x VALUES (4, DEFAULT, DEFAULT, DEFAULT, DEFAULT);
INSERT INTO x VALUES (5, DEFAULT, DEFAULT, DEFAULT, DEFAULT), (6, DEFAULT, DEFAULT, DEFAULT, DEFAULT);
INSERT INTO x VALUES (11);
INSERT INTO x VALUES (12), (13);
INSERT INTO x VALUES (14, DEFAULT, DEFAULT, DEFAULT, DEFAULT);
INSERT INTO x VALUES (15, DEFAULT, DEFAULT, DEFAULT, DEFAULT), (16, DEFAULT, DEFAULT, DEFAULT, DEFAULT);
INSERT INTO x VALUES (17), (DEFAULT);
SELECT * FROM x ORDER BY x NULLS LAST, x NULLS LAST;
/* Test a DO ALSO INSERT ... SELECT rule */ drop rule base_tab_def_view_ins_rule on base_tab_def_view;
create rule base_tab_def_view_ins_rule as on insert to base_tab_def_view   do also insert into base_tab_def (a, b, e) select new.a, new.b, 'xxx';
TRUNCATE TABLE x;
INSERT INTO x VALUES (1, DEFAULT, DEFAULT, DEFAULT, DEFAULT);
INSERT INTO x VALUES (2, DEFAULT, DEFAULT, DEFAULT, DEFAULT), (3, DEFAULT, DEFAULT, DEFAULT, DEFAULT);
SELECT * FROM x ORDER BY x NULLS LAST, x;
DROP VIEW x;
DROP TABLE x;
/* Test defaults with array assignments */ CREATE TABLE x (x SERIAL, x ARRAY<INT>, x TEXT, x TEXT DEFAULT 'Table default');
CREATE VIEW x AS SELECT x, x, x FROM x;
ALTER VIEW x ALTER COLUMN x SET DEFAULT 'View default';
SELECT * FROM x ORDER BY x NULLS LAST;
DROP VIEW x;
DROP TABLE x;
/* UPDATE syntax tests */ CREATE TABLE x (x INT DEFAULT 10, x INT, x TEXT);
CREATE TABLE x (x INT PRIMARY KEY, x TEXT);
INSERT INTO x VALUES (5, 10, 'foo');
INSERT INTO x (x, x) VALUES (15, 10);
SELECT * FROM x;
UPDATE x SET x = x, x = x;
SELECT * FROM x;
/* aliases for the UPDATE target table */ UPDATE x AS x SET x = 10 WHERE x.x = 10;
SELECT * FROM x;
UPDATE x AS x SET x = x.x + 10 WHERE x.x = 10;
SELECT * FROM x;
/* error, you're not supposed to qualify the target column */ UPDATE x AS x SET x.x = x.x + 10 WHERE x.x = 10;
/* Test VALUES in FROM */ UPDATE x SET x = x.x FROM (VALUES (100, 20)) AS x WHERE x.x = x.x;
SELECT * FROM x;
/* fail, wrong data type: */ UPDATE x SET x = x.* FROM (VALUES (100, 20)) AS x WHERE x.x = x.x;
/* Test multiple-set-clause syntax */ INSERT INTO x SELECT x, x + 1, x FROM x;
SELECT * FROM x;
UPDATE x SET (x, x, x) = ('bugle', x + 11, x) WHERE x = 'foo';
SELECT * FROM x;
UPDATE x SET (x, x) = ('car', x + x), x = x + 1 WHERE x = 10;
SELECT * FROM x;
/* fail, multi assignment to same column: */ UPDATE x SET (x, x) = ('car', x + x), x = x + 1 WHERE x = 10;
/* uncorrelated sub-select: */ UPDATE x SET (x, x) = (SELECT x, x FROM x WHERE x = 41 AND x = 'car') WHERE x = 100 AND x = 20;
SELECT * FROM x;
/* correlated sub-select: */ UPDATE x AS x SET (x, x) = (SELECT x + 1, x FROM x AS x WHERE x.x = x.x AND x.x = x.x AND x.x IS NOT DISTINCT FROM x.x);
SELECT * FROM x;
/* fail, multiple rows supplied: */ UPDATE x SET (x, x) = (SELECT x + 1, x FROM x);
/* set to null if no rows supplied: */ UPDATE x SET (x, x) = (SELECT x + 1, x FROM x WHERE x = 1000) WHERE x = 11;
SELECT * FROM x;
/* *-expansion should work in this context: */ UPDATE x SET (x, x) = ROW(x.*) FROM (VALUES (21, 100)) AS x WHERE x.x = x.x;
/* you might expect this to work, but syntactically it's not a RowExpr: */ UPDATE x SET (x, x) = (x.*) FROM (VALUES (21, 101)) AS x WHERE x.x = x.x;
/* if an alias for the target table is specified, don't allow references */ /* to the original table name */ UPDATE x AS x SET x = x.x + 10 WHERE x.x = 10;
/* Make sure that we can update to a TOASTed value. */ UPDATE x SET x = REPEAT('x', 10000) WHERE x = 'car';
SELECT x, x, LENGTH(x) FROM x;
/* Check multi-assignment with a Result node to handle a one-time filter. */ EXPLAIN (VERBOSE, COSTS OFF) UPDATE update_test t   SET (a, b) = (SELECT b, a FROM update_test s WHERE s.a = t.a)   WHERE CURRENT_USER = SESSION_USER;
UPDATE x AS x SET (x, x) = (SELECT x, x FROM x AS x WHERE x.x = x.x) WHERE CURRENT_USER() = x;
SELECT x, x, LENGTH(x) FROM x;
/* Test ON CONFLICT DO UPDATE */ INSERT INTO x VALUES (1, 'Boo'), (3, 'Zoo');
/* uncorrelated  sub-select: */ WITH x AS (SELECT 1 AS x, 'Foo' AS x) INSERT INTO x VALUES (1, 'Bar') ON CONFLICT(x) DO UPDATE SET (x, x) = (SELECT x, x FROM x) RETURNING *;
/* correlated sub-select: */ INSERT INTO x VALUES (1, 'Baz'), (3, 'Zaz') ON CONFLICT(x) DO UPDATE SET (x, x) = (SELECT x || ', Correlated', x FROM x AS x WHERE x.x = x.x) RETURNING *;
/* correlated sub-select (EXCLUDED.* alias): */ INSERT INTO x VALUES (1, 'Bat'), (3, 'Zot') ON CONFLICT(x) DO UPDATE SET (x, x) = (SELECT x || ', Excluded', x FROM x AS x WHERE x.x = x.x) RETURNING *;
/* ON CONFLICT using system attributes in RETURNING, testing both the */ /* inserting and updating paths. See bug report at: */ /* https://www.postgresql.org/message-id/73436355-6432-49B1-92ED-1FE4F7E7E100%40finefun.com.au */ INSERT INTO x VALUES (2, 'Beeble') ON CONFLICT(x) DO UPDATE SET (x, x) = (SELECT x || ', Excluded', x FROM x AS x WHERE x.x = x.x) RETURNING CAST(x AS REGCLASS), x = CAST(PG_CURRENT_XACT_ID() AS xid) AS x, x = 0 AS x;
/* currently xmax is set after a conflict - that's probably not good, */ /* but it seems worthwhile to have to be explicit if that changes. */ INSERT INTO x VALUES (2, 'Brox') ON CONFLICT(x) DO UPDATE SET (x, x) = (SELECT x || ', Excluded', x FROM x AS x WHERE x.x = x.x) RETURNING CAST(x AS REGCLASS), x = CAST(PG_CURRENT_XACT_ID() AS xid) AS x, x = CAST(PG_CURRENT_XACT_ID() AS xid) AS x;
DROP TABLE x;
DROP TABLE x;
/* Test ON CONFLICT DO UPDATE with partitioned table and non-identical children */ CREATE TABLE x (x INT PRIMARY KEY, x TEXT) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN (1);
CREATE TABLE x (x TEXT, x INT PRIMARY KEY);
ALTER TABLE upsert_test ATTACH PARTITION upsert_test_2 FOR VALUES IN (2);
INSERT INTO x VALUES (1, 'Boo'), (2, 'Zoo');
/* uncorrelated sub-select: */ WITH x AS (SELECT 1 AS x, 'Foo' AS x) INSERT INTO x VALUES (1, 'Bar') ON CONFLICT(x) DO UPDATE SET (x, x) = (SELECT x, x FROM x) RETURNING *;
/* correlated sub-select: */ WITH x AS (SELECT 1 AS x, ' Foo' AS x) INSERT INTO x VALUES (1, 'Bar'), (2, 'Baz') ON CONFLICT(x) DO UPDATE SET (x, x) = (SELECT x.x || x, x.x FROM x) RETURNING *;
DROP TABLE x;
/* ------------------------- */ /* UPDATE with row movement */ /* ------------------------- */ /* When a partitioned table receives an UPDATE to the partitioned key and the */ /* new values no longer meet the partition's bound, the row must be moved to */ /* the correct partition for the new partition key (if one exists). We must */ /* also ensure that updatable views on partitioned tables properly enforce any */ /* WITH CHECK OPTION that is defined. The situation with triggers in this case */ /* also requires thorough testing as partition key updates causing row */ /* movement convert UPDATEs into DELETE+INSERT. */ CREATE TABLE x (x TEXT, x BIGINT, x DECIMAL, x INT, x VARCHAR) WITH (PARTITIONED_BY=RANGE(x, x));
/* Create partitions intentionally in descending bound order, so as to test */ /* that update-row-movement works with the leaf partitions not in bound order. */ CREATE TABLE x (x VARCHAR, x DECIMAL, x TEXT, x BIGINT, x INT);
ALTER TABLE range_parted ATTACH PARTITION part_b_20_b_30 FOR VALUES FROM ('b', 20) TO ('b', 30);
CREATE TABLE x (x VARCHAR, x DECIMAL, x TEXT, x BIGINT, x INT) WITH (PARTITIONED_BY=RANGE(x));
CREATE TABLE x PARTITION OF x FOR VALUES FROM ('b', 1) TO ('b', 10);
ALTER TABLE range_parted ATTACH PARTITION part_b_10_b_20 FOR VALUES FROM ('b', 10) TO ('b', 20);
CREATE TABLE x PARTITION OF x FOR VALUES FROM ('a', 10) TO ('a', 20);
CREATE TABLE x PARTITION OF x FOR VALUES FROM ('a', 1) TO ('a', 10);
/* Check that partition-key UPDATE works sanely on a partitioned table that */ /* does not have any child partitions. */ UPDATE x SET x = x - 6;
/* Create some more partitions following the above pattern of descending bound */ /* order, but let's make the situation a bit more complex by having the */ /* attribute numbers of the columns vary from their parent partition. */ CREATE TABLE x (x VARCHAR, x DECIMAL, x TEXT, x BIGINT, x INT) WITH (PARTITIONED_BY=RANGE(ABS(x)));
ALTER TABLE x DROP COLUMN x, DROP COLUMN x, DROP COLUMN x;
ALTER TABLE x ADD COLUMN x DECIMAL, ADD COLUMN x VARCHAR, ADD COLUMN x TEXT;
ALTER TABLE x DROP COLUMN x;
ALTER TABLE x ADD COLUMN x BIGINT;
CREATE TABLE x PARTITION OF x FOR VALUES FROM (1) TO (15);
CREATE TABLE x PARTITION OF x FOR VALUES FROM (15) TO (20);
ALTER TABLE part_b_10_b_20 ATTACH PARTITION part_c_100_200 FOR VALUES FROM (100) TO (200);
CREATE TABLE x (x VARCHAR, x INT, x DECIMAL, x BIGINT, x TEXT);
ALTER TABLE part_b_10_b_20 ATTACH PARTITION part_c_1_100 FOR VALUES FROM (1) TO (100);
:show_data;
/* The order of subplans should be in bound order */ EXPLAIN (costs off) UPDATE range_parted set c = c - 50 WHERE c > 97;
/* fail, row movement happens only within the partition subtree. */ UPDATE x SET x = x - 20, x = x WHERE x = 105;
/* fail, no partition key update, so no attempt to move tuple, */ /* but "a = 'a'" violates partition constraint enforced by root partition) */ UPDATE x SET x = 'a';
/* ok, partition key update, no constraint violation */ UPDATE x SET x = x - 10 WHERE x > 10;
/* ok, no partition key update, no constraint violation */ UPDATE x SET x = x;
/* No row found */ UPDATE x SET x = x + 20 WHERE x = 98;
/* ok, row movement */ UPDATE x SET x = x + 20 RETURNING x, x, x;
:show_data;
/* fail, row movement happens only within the partition subtree. */ UPDATE x SET x = x - 6 WHERE x > 116 RETURNING *;
/* ok, row movement, with subset of rows moved into different partition. */ UPDATE x SET x = x - 6 WHERE x > 116 RETURNING x, x + x;
:show_data;
/* Common table needed for multiple test scenarios. */ CREATE TABLE x (x INT);
INSERT INTO x VALUES (120);
/* update partition key using updatable view. */ CREATE VIEW upview AS SELECT * FROM range_parted WHERE (select c > c1 FROM mintab) WITH CHECK OPTION;
/* ok */ UPDATE x SET x = 199 WHERE x = 4;
/* fail, check option violation */ UPDATE x SET x = 120 WHERE x = 4;
/* fail, row movement with check option violation */ UPDATE x SET x = 'b', x = 15, x = 120 WHERE x = 4;
/* ok, row movement, check option passes */ UPDATE x SET x = 'b', x = 15 WHERE x = 4;
:show_data;
/* cleanup */ DROP VIEW x;
:init_range_parted;
UPDATE x SET x = 95 WHERE x = 'b' AND x > 10 AND x > 100 RETURNING (x), *;
:show_data;
:init_range_parted;
x AS x;
COMMIT;
CREATE TRIGGER trans_updatetrig   AFTER UPDATE ON range_parted REFERENCING OLD TABLE AS old_table NEW TABLE AS new_table   FOR EACH STATEMENT EXECUTE PROCEDURE trans_updatetrigfunc();
UPDATE x SET x = (CASE WHEN x = 96 THEN 110 ELSE x + 1 END) WHERE x = 'b' AND x > 10 AND x >= 96;
:show_data;
:init_range_parted;
/* Enabling OLD TABLE capture for both DELETE as well as UPDATE stmt triggers */ /* should not cause DELETEd rows to be captured twice. Similar thing for */ /* INSERT triggers and inserted rows. */ CREATE TRIGGER trans_deletetrig   AFTER DELETE ON range_parted REFERENCING OLD TABLE AS old_table   FOR EACH STATEMENT EXECUTE PROCEDURE trans_updatetrigfunc();
CREATE TRIGGER trans_inserttrig   AFTER INSERT ON range_parted REFERENCING NEW TABLE AS new_table   FOR EACH STATEMENT EXECUTE PROCEDURE trans_updatetrigfunc();
UPDATE x SET x = x + 50 WHERE x = 'b' AND x > 10 AND x >= 96;
:show_data;
DROP TRIGGER trans_deletetrig ON range_parted;
DROP TRIGGER trans_inserttrig ON range_parted;
x AS x;
CREATE TRIGGER trig_c1_100 BEFORE UPDATE OR INSERT ON part_c_1_100    FOR EACH ROW EXECUTE PROCEDURE func_parted_mod_b();
CREATE TRIGGER trig_d1_15 BEFORE UPDATE OR INSERT ON part_d_1_15    FOR EACH ROW EXECUTE PROCEDURE func_parted_mod_b();
CREATE TRIGGER trig_d15_20 BEFORE UPDATE OR INSERT ON part_d_15_20    FOR EACH ROW EXECUTE PROCEDURE func_parted_mod_b();
:init_range_parted;
UPDATE x SET x = (CASE WHEN x = 96 THEN 110 ELSE x + 1 END) WHERE x = 'b' AND x > 10 AND x >= 96;
:show_data;
:init_range_parted;
UPDATE x SET x = x + 50 WHERE x = 'b' AND x > 10 AND x >= 96;
:show_data;
:init_range_parted;
UPDATE x SET x = 15 WHERE x = 1;
:show_data;
DROP TRIGGER trans_updatetrig ON range_parted;
DROP TRIGGER trig_c1_100 ON part_c_1_100;
DROP TRIGGER trig_d1_15 ON part_d_1_15;
DROP TRIGGER trig_d15_20 ON part_d_15_20;
DROP FUNCTION x;
/* RLS policies with update-row-movement */ /* --------------------------------------- */ ALTER TABLE range_parted ENABLE ROW LEVEL SECURITY;
CREATE USER regress_range_parted_user;
GRANT ALL ON range_parted, mintab TO regress_range_parted_user;
CREATE POLICY seeall ON range_parted AS PERMISSIVE FOR SELECT USING (true);
CREATE POLICY policy_range_parted ON range_parted for UPDATE USING (true) WITH CHECK (c % 2 = 0);
:init_range_parted;
SET SESSION AUTHORIZATION regress_range_parted_user;
/* This should fail with RLS violation error while moving row from */ /* part_a_10_a_20 to part_d_1_15, because we are setting 'c' to an odd number. */ UPDATE x SET x = 'b', x = 151 WHERE x = 'a' AND x = 200;
RESET SESSION AUTHORIZATION;
x AS x /* Make even numbers odd, or vice versa */;
CREATE TRIGGER trig_d_1_15 BEFORE INSERT ON part_d_1_15    FOR EACH ROW EXECUTE PROCEDURE func_d_1_15();
:init_range_parted;
SET SESSION AUTHORIZATION regress_range_parted_user;
/* Here, RLS checks should succeed while moving row from part_a_10_a_20 to */ /* part_d_1_15. Even though the UPDATE is setting 'c' to an odd number, the */ /* trigger at the destination partition again makes it an even number. */ UPDATE x SET x = 'b', x = 151 WHERE x = 'a' AND x = 200;
RESET SESSION AUTHORIZATION;
:init_range_parted;
SET SESSION AUTHORIZATION regress_range_parted_user;
/* This should fail with RLS violation error. Even though the UPDATE is setting */ /* 'c' to an even number, the trigger at the destination partition again makes */ /* it an odd number. */ UPDATE x SET x = 'b', x = 150 WHERE x = 'a' AND x = 200;
/* Cleanup */ RESET SESSION AUTHORIZATION;
DROP TRIGGER trig_d_1_15 ON part_d_1_15;
DROP FUNCTION x;
/* Policy expression contains SubPlan */ RESET SESSION AUTHORIZATION;
:init_range_parted;
CREATE POLICY policy_range_parted_subplan on range_parted     AS RESTRICTIVE for UPDATE USING (true)     WITH CHECK ((SELECT range_parted.c <= c1 FROM mintab));
SET SESSION AUTHORIZATION regress_range_parted_user;
/* fail, mintab has row with c1 = 120 */ UPDATE x SET x = 'b', x = 122 WHERE x = 'a' AND x = 200;
/* ok */ UPDATE x SET x = 'b', x = 120 WHERE x = 'a' AND x = 200;
/* RLS policy expression contains whole row. */ RESET SESSION AUTHORIZATION;
:init_range_parted;
CREATE POLICY policy_range_parted_wholerow on range_parted AS RESTRICTIVE for UPDATE USING (true)    WITH CHECK (range_parted = row('b', 10, 112, 1, NULL)::range_parted);
SET SESSION AUTHORIZATION regress_range_parted_user;
/* ok, should pass the RLS check */ UPDATE x SET x = 'b', x = 112 WHERE x = 'a' AND x = 200;
RESET SESSION AUTHORIZATION;
:init_range_parted;
SET SESSION AUTHORIZATION regress_range_parted_user;
/* fail, the whole row RLS check should fail */ UPDATE x SET x = 'b', x = 116 WHERE x = 'a' AND x = 200;
/* Cleanup */ RESET SESSION AUTHORIZATION;
DROP POLICY policy_range_parted ON range_parted;
DROP POLICY policy_range_parted_subplan ON range_parted;
DROP POLICY policy_range_parted_wholerow ON range_parted;
REVOKE ALL ON range_parted, mintab FROM regress_range_parted_user;
DROP USER regress_range_parted_user;
DROP TABLE x;
:init_range_parted;
x AS x;
COMMIT;
/* Triggers on root partition */ CREATE TRIGGER parent_delete_trig   AFTER DELETE ON range_parted for each statement execute procedure trigfunc();
CREATE TRIGGER parent_update_trig   AFTER UPDATE ON range_parted for each statement execute procedure trigfunc();
CREATE TRIGGER parent_insert_trig   AFTER INSERT ON range_parted for each statement execute procedure trigfunc();
/* Triggers on leaf partition part_c_1_100 */ CREATE TRIGGER c1_delete_trig   AFTER DELETE ON part_c_1_100 for each statement execute procedure trigfunc();
CREATE TRIGGER c1_update_trig   AFTER UPDATE ON part_c_1_100 for each statement execute procedure trigfunc();
CREATE TRIGGER c1_insert_trig   AFTER INSERT ON part_c_1_100 for each statement execute procedure trigfunc();
/* Triggers on leaf partition part_d_1_15 */ CREATE TRIGGER d1_delete_trig   AFTER DELETE ON part_d_1_15 for each statement execute procedure trigfunc();
CREATE TRIGGER d1_update_trig   AFTER UPDATE ON part_d_1_15 for each statement execute procedure trigfunc();
CREATE TRIGGER d1_insert_trig   AFTER INSERT ON part_d_1_15 for each statement execute procedure trigfunc();
/* Triggers on leaf partition part_d_15_20 */ CREATE TRIGGER d15_delete_trig   AFTER DELETE ON part_d_15_20 for each statement execute procedure trigfunc();
CREATE TRIGGER d15_update_trig   AFTER UPDATE ON part_d_15_20 for each statement execute procedure trigfunc();
CREATE TRIGGER d15_insert_trig   AFTER INSERT ON part_d_15_20 for each statement execute procedure trigfunc();
/* Move all rows from part_c_100_200 to part_c_1_100. None of the delete or */ /* insert statement triggers should be fired. */ UPDATE x SET x = x - 50 WHERE x > 97;
:show_data;
DROP TRIGGER parent_delete_trig ON range_parted;
DROP TRIGGER parent_update_trig ON range_parted;
DROP TRIGGER parent_insert_trig ON range_parted;
DROP TRIGGER c1_delete_trig ON part_c_1_100;
DROP TRIGGER c1_update_trig ON part_c_1_100;
DROP TRIGGER c1_insert_trig ON part_c_1_100;
DROP TRIGGER d1_delete_trig ON part_d_1_15;
DROP TRIGGER d1_update_trig ON part_d_1_15;
DROP TRIGGER d1_insert_trig ON part_d_1_15;
DROP TRIGGER d15_delete_trig ON part_d_15_20;
DROP TRIGGER d15_update_trig ON part_d_15_20;
DROP TRIGGER d15_insert_trig ON part_d_15_20;
:init_range_parted;
CREATE TABLE x PARTITION OF x DEFAULT;
/* ok */ UPDATE x SET x = 'd' WHERE x = 'c';
/* fail */ UPDATE x SET x = 'a' WHERE x = 'd';
:show_data;
UPDATE x SET x = 'ad' WHERE x = 'a';
/* ok */ UPDATE x SET x = 'ad' WHERE x = 'a';
UPDATE x SET x = 'bd' WHERE x = 'b';
:show_data;
/* Update row movement from default to non-default partitions. */ /* ok */ UPDATE x SET x = 'a' WHERE x = 'ad';
UPDATE x SET x = 'b' WHERE x = 'bd';
:show_data;
/* Cleanup: range_parted no longer needed. */ DROP TABLE x;
CREATE TABLE x (x TEXT, x INT) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN ('a', 'b');
CREATE TABLE x PARTITION OF x DEFAULT;
INSERT INTO x VALUES ('a', 1);
INSERT INTO x VALUES ('d', 10);
/* fail */ UPDATE x SET x = 'a' WHERE x = 'd';
/* ok */ UPDATE x SET x = 'x' WHERE x = 'd';
DROP TABLE x;
/* Test retrieval of system columns with non-consistent partition row types. */ /* This is only partially supported, as seen in the results. */ CREATE TABLE x (x INT, x TEXT) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x (x INT CHECK (x IN (1)), x TEXT, x TEXT);
CREATE TABLE x (x INT CHECK (x IN (2)), x TEXT);
ALTER TABLE x DROP COLUMN x;
alter table utrtest attach partition utr1 for values in (1);
alter table utrtest attach partition utr2 for values in (2);
INSERT INTO x VALUES (1, 'foo') RETURNING *, CAST(x AS REGCLASS), x = CAST(PG_CURRENT_XACT_ID() AS xid) AS x;
INSERT INTO x VALUES (2, 'bar') RETURNING *, CAST(x AS REGCLASS), x = CAST(PG_CURRENT_XACT_ID() AS xid) AS x;
/* fails */ INSERT INTO x VALUES (2, 'bar') RETURNING *, CAST(x AS REGCLASS);
UPDATE x SET x = x || x FROM (VALUES (1), (2)) AS x WHERE x = x.x RETURNING *, CAST(x AS REGCLASS), x = CAST(PG_CURRENT_XACT_ID() AS xid) AS x;
UPDATE x SET x = 3 - x FROM (VALUES (1), (2)) AS x WHERE x = x.x RETURNING *, CAST(x AS REGCLASS), x = CAST(PG_CURRENT_XACT_ID() AS xid) AS x;
/* fails */ UPDATE x SET x = 3 - x FROM (VALUES (1), (2)) AS x WHERE x = x.x RETURNING *, CAST(x AS REGCLASS);
DELETE FROM x RETURNING *, CAST(x AS REGCLASS), x = CAST(PG_CURRENT_XACT_ID() AS xid) AS x;
DROP TABLE x;
/* ------------ */ /* Some more update-partition-key test scenarios below. This time use list */ /* partitions. */ /* ------------ */ /* Setup for list partitions */ CREATE TABLE x (x DECIMAL, x INT, x BIGINT) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN (1) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x (x INT, x BIGINT, x DECIMAL);
ALTER TABLE sub_parted ATTACH PARTITION sub_part1 for VALUES in (1);
CREATE TABLE x (x INT, x BIGINT, x DECIMAL);
ALTER TABLE sub_parted ATTACH PARTITION sub_part2 for VALUES in (2);
CREATE TABLE x (x DECIMAL, x INT, x BIGINT);
ALTER TABLE list_parted ATTACH PARTITION list_part1 for VALUES in (2,3);
INSERT INTO x VALUES (2, 5, 50);
INSERT INTO x VALUES (3, 6, 60);
INSERT INTO x VALUES (1, 1, 60);
INSERT INTO x VALUES (1, 2, 10);
/* Test partition constraint violation when intermediate ancestor is used and */ /* constraint is inherited from upper root. */ UPDATE x SET x = 2 WHERE x = 10;
/* Test update-partition-key, where the unpruned partitions do not have their */ /* partition keys updated. */ SELECT CAST(CAST(x AS REGCLASS) AS TEXT), * FROM x WHERE x = 2 ORDER BY 1 NULLS LAST;
UPDATE x SET x = x + x WHERE x = 2;
SELECT CAST(CAST(x AS REGCLASS) AS TEXT), * FROM x WHERE x = 2 ORDER BY 1 NULLS LAST;
x AS x /* This is changing partition key column. */;
CREATE TRIGGER parted_mod_b before update on sub_part1    for each row execute procedure func_parted_mod_b();
SELECT CAST(CAST(x AS REGCLASS) AS TEXT), * FROM x ORDER BY 1 NULLS LAST, 2 NULLS LAST, 3 NULLS LAST, 4 NULLS LAST;
/* This should do the tuple routing even though there is no explicit */ /* partition-key update, because there is a trigger on sub_part1. */ UPDATE x SET x = 70 WHERE x = 1;
SELECT CAST(CAST(x AS REGCLASS) AS TEXT), * FROM x ORDER BY 1 NULLS LAST, 2 NULLS LAST, 3 NULLS LAST, 4 NULLS LAST;
DROP TRIGGER parted_mod_b ON sub_part1;
x AS x;
CREATE TRIGGER trig_skip_delete before delete on sub_part2    for each row execute procedure func_parted_mod_b();
UPDATE x SET x = 1 WHERE x = 70;
SELECT CAST(CAST(x AS REGCLASS) AS TEXT), * FROM x ORDER BY 1 NULLS LAST, 2 NULLS LAST, 3 NULLS LAST, 4 NULLS LAST;
/* Drop the trigger. Now the row should be moved. */ DROP TRIGGER trig_skip_delete ON sub_part2;
UPDATE x SET x = 1 WHERE x = 70;
SELECT CAST(CAST(x AS REGCLASS) AS TEXT), * FROM x ORDER BY 1 NULLS LAST, 2 NULLS LAST, 3 NULLS LAST, 4 NULLS LAST;
DROP FUNCTION x;
/* UPDATE partition-key with FROM clause. If join produces multiple output */ /* rows for the same row to be modified, we should tuple-route the row only */ /* once. There should not be any rows inserted. */ CREATE TABLE x (x INT);
INSERT INTO x VALUES (1), (1), (1), (2), (2), (2), (3), (3), (3);
UPDATE x AS x SET x = 2 FROM x AS x WHERE x.x = x.x AND x = 1;
SELECT CAST(CAST(x AS REGCLASS) AS TEXT), * FROM x ORDER BY 1 NULLS LAST, 2 NULLS LAST, 3 NULLS LAST, 4 NULLS LAST;
DROP TABLE x;
/* Cleanup: list_parted no longer needed. */ DROP TABLE x;
COMMIT;
create operator class custom_opclass for type int4 using hash as operator 1 = , function 2 dummy_hashint4(int4, int8);
CREATE TABLE x PARTITION OF x FOR VALUES WITH (MODULUS 2, REMAINDER 1);
CREATE TABLE x PARTITION OF x FOR VALUES WITH (MODULUS 4, REMAINDER 2);
CREATE TABLE x PARTITION OF x FOR VALUES WITH (MODULUS 8, REMAINDER 0);
CREATE TABLE x PARTITION OF x FOR VALUES WITH (MODULUS 8, REMAINDER 4);
INSERT INTO x VALUES (1, 1);
INSERT INTO x VALUES (2, 5);
INSERT INTO x VALUES (3, 4);
/* fail */ UPDATE x SET x = 3, x = 4 WHERE x = 1;
/* ok, row movement */ UPDATE x SET x = x - 1 WHERE x = 1;
/* ok */ UPDATE x SET x = x + 8 WHERE x = 1;
/* cleanup */ DROP TABLE x;
drop operator class custom_opclass using hash;
/* regression test for the uuid datatype */ /* creating test tables */ CREATE TABLE x (x UUID, x TEXT DEFAULT (CURRENT_TIMESTAMP()));
CREATE TABLE x (x UUID, x TEXT DEFAULT (CURRENT_TIMESTAMP()));
CREATE TABLE x (x SERIAL, x UUID);
/* inserting invalid data tests */ /* too long */ INSERT INTO x (x) VALUES ('11111111-1111-1111-1111-111111111111F');
/* too short */ INSERT INTO x (x) VALUES ('{11111111-1111-1111-1111-11111111111}');
/* valid data but invalid format */ INSERT INTO x (x) VALUES ('111-11111-1111-1111-1111-111111111111');
INSERT INTO x (x) VALUES ('{22222222-2222-2222-2222-222222222222 ');
/* invalid data */ INSERT INTO x (x) VALUES ('11111111-1111-1111-G111-111111111111');
INSERT INTO x (x) VALUES ('11+11111-1111-1111-1111-111111111111');
/* test non-error-throwing API */ SELECT PG_INPUT_IS_VALID('11', 'uuid');
SELECT * FROM x;
/* inserting three input formats */ INSERT INTO x (x) VALUES ('11111111-1111-1111-1111-111111111111');
INSERT INTO x (x) VALUES ('{22222222-2222-2222-2222-222222222222}');
INSERT INTO x (x) VALUES ('3f3e3c3b3a3039383736353433a2313e');
/* retrieving the inserted data */ SELECT x FROM x;
/* ordering test */ SELECT x FROM x ORDER BY x ASC NULLS LAST;
SELECT x FROM x ORDER BY x DESC NULLS FIRST;
/* = operator test */ SELECT COUNT(*) FROM x WHERE x = '3f3e3c3b-3a30-3938-3736-353433a2313e';
/* <> operator test */ SELECT COUNT(*) FROM x WHERE x <> '11111111111111111111111111111111';
/* < operator test */ SELECT COUNT(*) FROM x WHERE x < '22222222-2222-2222-2222-222222222222';
/* <= operator test */ SELECT COUNT(*) FROM x WHERE x <= '22222222-2222-2222-2222-222222222222';
/* > operator test */ SELECT COUNT(*) FROM x WHERE x > '22222222-2222-2222-2222-222222222222';
/* >= operator test */ SELECT COUNT(*) FROM x WHERE x >= '22222222-2222-2222-2222-222222222222';
/* btree and hash index creation test */ CREATE INDEX x ON x USING BTREE(x NULLS LAST);
CREATE INDEX x ON x USING HASH(x NULLS LAST);
/* unique index test */ CREATE UNIQUE INDEX x ON x USING BTREE(x NULLS LAST);
EXPLAIN (COSTS OFF) SELECT COUNT(*) FROM guid1 WHERE guid_field <> '11111111111111111111111111111111' OR 							guid_field <> '3f3e3c3b-3a30-3938-3736-353433a2313e';
EXPLAIN (COSTS OFF) SELECT COUNT(*) FROM guid1 WHERE guid_field <= '22222222-2222-2222-2222-222222222222' OR 									guid_field <= '11111111111111111111111111111111' OR 									guid_field <= '3f3e3c3b-3a30-3938-3736-353433a2313e';
EXPLAIN (COSTS OFF) SELECT COUNT(*) FROM guid1 WHERE guid_field = '3f3e3c3b-3a30-3938-3736-353433a2313e' OR 							guid_field = '11111111111111111111111111111111';
/* should fail */ INSERT INTO x (x) VALUES ('11111111-1111-1111-1111-111111111111');
/* check to see whether the new indexes are actually there */ SELECT COUNT(*) FROM x WHERE x = 'i' AND x LIKE 'guid%';
/* populating the test tables with additional records */ INSERT INTO x (x) VALUES ('44444444-4444-4444-4444-444444444444');
INSERT INTO x (x) VALUES ('11111111-1111-1111-1111-111111111111');
INSERT INTO x (x) VALUES ('{22222222-2222-2222-2222-222222222222}');
INSERT INTO x (x) VALUES ('3f3e3c3b3a3039383736353433a2313e');
/* join test */ SELECT COUNT(*) FROM x AS x INNER JOIN x AS x ON x.x = x.x;
SELECT COUNT(*) FROM x AS x LEFT JOIN x AS x ON x.x = x.x WHERE x.x IS NULL;
TRUNCATE TABLE x /* generation test */;
INSERT INTO x (x) VALUES (UUID());
INSERT INTO x (x) VALUES (UUID());
SELECT COUNT(DISTINCT x) FROM x;
TRUNCATE TABLE x /* test of uuidv4() alias */;
INSERT INTO x (x) VALUES (UUIDV4());
INSERT INTO x (x) VALUES (UUIDV4());
SELECT COUNT(DISTINCT x) FROM x;
TRUNCATE TABLE x /* generation test for v7 */;
INSERT INTO x (x) VALUES (UUIDV7());
INSERT INTO x (x) VALUES (UUIDV7());
INSERT INTO x (x) VALUES (UUIDV7(INTERVAL '1' DAY));
SELECT COUNT(DISTINCT x) FROM x;
/* test sortability of v7 */ INSERT INTO x (x) SELECT UUIDV7() FROM x;
SELECT ARRAY_AGG(x ORDER BY x NULLS LAST) FROM x;
/* extract functions */ /* version */ SELECT UUID_EXTRACT_VERSION('11111111-1111-5111-8111-111111111111');
/* 5 */ SELECT UUID_EXTRACT_VERSION(UUID());
/* 4 */ SELECT UUID_EXTRACT_VERSION('11111111-1111-1111-1111-111111111111');
/* null */ SELECT UUID_EXTRACT_VERSION(UUIDV4());
/* 4 */ SELECT UUID_EXTRACT_VERSION(UUIDV7());
/* 7 */ /* timestamp */ SELECT UUID_EXTRACT_TIMESTAMP('C232AB00-9414-11EC-B3C8-9F6BDECED846') = 'Tuesday, February 22, 2022 2:22:22.00 PM GMT+05:00';
/* RFC 9562 test vector for v1 */ SELECT UUID_EXTRACT_TIMESTAMP('017F22E2-79B0-7CC3-98C4-DC0C0C07398F') = 'Tuesday, February 22, 2022 2:22:22.00 PM GMT+05:00';
/* RFC 9562 test vector for v7 */ SELECT UUID_EXTRACT_TIMESTAMP(UUID());
/* null */ SELECT UUID_EXTRACT_TIMESTAMP('11111111-1111-1111-1111-111111111111');
/* VACUUM */ CREATE TABLE x (x INT);
INSERT INTO x VALUES (1);
INSERT INTO x SELECT * FROM x;
INSERT INTO x SELECT * FROM x;
INSERT INTO x SELECT * FROM x;
INSERT INTO x SELECT * FROM x;
INSERT INTO x SELECT * FROM x;
INSERT INTO x SELECT * FROM x;
INSERT INTO x SELECT * FROM x;
INSERT INTO x SELECT * FROM x;
INSERT INTO x SELECT * FROM x;
INSERT INTO x SELECT * FROM x;
INSERT INTO x SELECT * FROM x;
INSERT INTO x VALUES (0);
SELECT COUNT(*) FROM x;
DELETE FROM x WHERE x <> 0;
SELECT * FROM x;
VACUUM FULL vactst;
UPDATE x SET x = x + 1;
INSERT INTO x SELECT * FROM x;
INSERT INTO x SELECT * FROM x;
INSERT INTO x SELECT * FROM x;
INSERT INTO x SELECT * FROM x;
INSERT INTO x SELECT * FROM x;
INSERT INTO x SELECT * FROM x;
INSERT INTO x SELECT * FROM x;
INSERT INTO x SELECT * FROM x;
INSERT INTO x SELECT * FROM x;
INSERT INTO x SELECT * FROM x;
INSERT INTO x SELECT * FROM x;
INSERT INTO x VALUES (0);
SELECT COUNT(*) FROM x;
DELETE FROM x WHERE x <> 0;
VACUUM (FULL) vactst;
DELETE FROM x;
SELECT * FROM x;
VACUUM (FULL, FREEZE) vactst;
VACUUM (ANALYZE, FULL) vactst;
CREATE TABLE x (x INT PRIMARY KEY);
ALTER TABLE vaccluster CLUSTER ON vaccluster_pkey;
x AS x;
CREATE FUNCTION x() RETURNS VOID VOLATILE LANGUAGE SQL AS 'ANALYZE pg_am';
CREATE FUNCTION x(x INT) RETURNS INT IMMUTABLE LANGUAGE SQL AS 'SELECT $1 FROM public.do_analyze()';
CREATE INDEX ON x(WRAP_DO_ANALYZE(x) NULLS LAST);
INSERT INTO x VALUES (1), (2);
ANALYZE x;
/* Test ANALYZE in transaction, where the transaction surrounding */ /* analyze performed modifications. This tests for the bug at */ /* https://postgr.es/m/c7988239-d42c-ddc4-41db-171b23b35e4f%40ssinger.info */ /* (which hopefully is unlikely to be reintroduced), but also seems */ /* independently worthwhile to cover. */ INSERT INTO x SELECT UNNEST(GENERATE_SERIES(1, 300));
DELETE FROM x WHERE x % 7 = 0;
/* delete a few rows outside */ BEGIN;
INSERT INTO x SELECT UNNEST(GENERATE_SERIES(301, 400));
DELETE FROM x WHERE x % 5 <> 0;
ANALYZE x /* delete a few rows inside */;
COMMIT;
/* Test ANALYZE setting relhassubclass=f for non-partitioning inheritance */ BEGIN;
CREATE TABLE x;
CREATE TABLE x INHERITS (x);
ANALYZE x;
SELECT x, x FROM x WHERE x = CAST('past_inh_parent' AS REGCLASS);
DROP TABLE x;
ANALYZE x;
SELECT x, x FROM x WHERE x = CAST('past_inh_parent' AS REGCLASS);
COMMIT;
/* Test ANALYZE setting relhassubclass=f for partitioning */ BEGIN;
CREATE TABLE x (x INT) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN (1);
INSERT INTO x VALUES (1), (1);
ANALYZE x;
DROP TABLE x;
SELECT x, x FROM x WHERE x = CAST('past_parted' AS REGCLASS);
ANALYZE x;
SELECT x, x FROM x WHERE x = CAST('past_parted' AS REGCLASS);
COMMIT;
VACUUM FULL pg_am;
VACUUM FULL pg_class;
VACUUM FULL pg_database;
VACUUM FULL vaccluster;
VACUUM FULL vactst;
VACUUM (DISABLE_PAGE_SKIPPING) vaccluster;
/* PARALLEL option */ CREATE TABLE x (x INT, x ARRAY<INT>, x POINT) WITH (autovacuum_enabled=off);
INSERT INTO x SELECT x, ARRAY(1, 2, 3), POINT(x, x + 1) FROM x AS x;
CREATE INDEX x ON x USING btree(x NULLS LAST);
CREATE INDEX x ON x USING hash(x NULLS LAST);
CREATE INDEX x ON x USING brin(x NULLS LAST);
CREATE INDEX x ON x USING gin(x NULLS LAST);
CREATE INDEX x ON x USING gist(x NULLS LAST);
CREATE INDEX x ON x USING spgist(x NULLS LAST);
SET x = 0 /* VACUUM invokes parallel index cleanup */;
VACUUM (PARALLEL 2) pvactst;
/* VACUUM invokes parallel bulk-deletion */ UPDATE x SET x = x WHERE x < 1000;
VACUUM (PARALLEL 2) pvactst;
UPDATE x SET x = x WHERE x < 1000;
VACUUM (PARALLEL 0) pvactst;
/* disable parallel vacuum */ VACUUM (PARALLEL -1) pvactst;
/* error */ VACUUM (PARALLEL 2, INDEX_CLEANUP FALSE) pvactst;
VACUUM (PARALLEL 2, FULL TRUE) pvactst;
/* error, cannot use both PARALLEL and FULL */ VACUUM (PARALLEL) pvactst;
/* error, cannot use PARALLEL option without parallel degree */ /* Test different combinations of parallel and full options for temporary tables */ CREATE TEMPORARY TABLE x (x INT PRIMARY KEY);
CREATE INDEX x ON x(x NULLS LAST);
VACUUM (PARALLEL 1, FULL FALSE) tmp;
/* parallel vacuum disabled for temp tables */ VACUUM (PARALLEL 0, FULL TRUE) tmp;
/* can specify parallel disabled (even though that's implied by FULL) */ RESET min_parallel_index_scan_size;
DROP TABLE x;
/* INDEX_CLEANUP option */ CREATE TABLE x (x INT PRIMARY KEY, x TEXT);
/* Use uncompressed data stored in toast. */ CREATE INDEX x ON x(x NULLS LAST);
ALTER TABLE x ALTER COLUMN x DROP DEFAULT, SET STORAGE EXTERNAL;
INSERT INTO x (x, x) VALUES (UNNEST(GENERATE_SERIES(1, 30)), REPEAT('1234567890', 269));
/* index cleanup option is ignored if VACUUM FULL */ VACUUM (INDEX_CLEANUP TRUE, FULL TRUE) no_index_cleanup;
VACUUM (FULL TRUE) no_index_cleanup;
ALTER TABLE x SET x = FALSE /* Toast inherits the value from its parent table. */;
DELETE FROM x WHERE x < 15;
/* Nothing is cleaned up. */ VACUUM no_index_cleanup;
ALTER TABLE x SET x = TRUE /* Both parent relation and toast are cleaned up. */;
VACUUM no_index_cleanup;
ALTER TABLE x SET x = x;
VACUUM no_index_cleanup;
/* Parameter is set for both the parent table and its toast relation. */ INSERT INTO x (x, x) VALUES (UNNEST(GENERATE_SERIES(31, 60)), REPEAT('1234567890', 269));
DELETE FROM x WHERE x < 45;
ALTER TABLE x SET x = x, x.x = x /* Only toast index is cleaned up. */;
VACUUM no_index_cleanup;
ALTER TABLE x SET x = TRUE, x.x = FALSE /* Only parent is cleaned up. */;
VACUUM no_index_cleanup;
/* Test some extra relations. */ VACUUM (INDEX_CLEANUP FALSE) vaccluster;
VACUUM (INDEX_CLEANUP AUTO) vactst;
/* index cleanup option is ignored if no indexes */ VACUUM (INDEX_CLEANUP FALSE, FREEZE TRUE) vaccluster;
/* TRUNCATE option */ CREATE TEMPORARY TABLE x (x INT NOT NULL, x TEXT) WITH (vacuum_truncate=TRUE, autovacuum_enabled=FALSE);
INSERT INTO x VALUES (1, NULL), (NULL, NULL);
VACUUM (TRUNCATE FALSE, DISABLE_PAGE_SKIPPING) vac_truncate_test;
SELECT PG_RELATION_SIZE('vac_truncate_test') > 0;
VACUUM (DISABLE_PAGE_SKIPPING) vac_truncate_test;
SELECT PG_RELATION_SIZE('vac_truncate_test') = 0;
VACUUM (TRUNCATE FALSE, FULL TRUE) vac_truncate_test;
DROP TABLE x;
/* partitioned table */ CREATE TABLE x (x INT, x CHAR) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN (1);
INSERT INTO x VALUES (1, 'a');
UPDATE x SET x = 'b';
VACUUM (ANALYZE) vacparted;
VACUUM (FULL) vacparted;
VACUUM (FREEZE) vacparted;
/* check behavior with duplicate column mentions */ VACUUM ANALYZE vacparted(a,b,a);
ANALYZE x;
/* partitioned table with index */ CREATE TABLE x (x INT PRIMARY KEY, x VARCHAR(100)) WITH (PARTITIONED_BY=HASH(x));
CREATE TABLE x PARTITION OF x FOR VALUES WITH (MODULUS 2, REMAINDER 0);
CREATE TABLE x PARTITION OF x FOR VALUES WITH (MODULUS 2, REMAINDER 1);
INSERT INTO x SELECT x, 'test_' || x FROM x AS x;
VACUUM (ANALYZE) vacparted_i;
VACUUM (FULL) vacparted_i;
VACUUM (FREEZE) vacparted_i;
SELECT x, x FROM x WHERE x LIKE 'vacparted_i%' AND x IN ('p', 'r') ORDER BY x NULLS LAST;
DROP TABLE x;
/* multiple tables specified */ VACUUM vaccluster, vactst;
VACUUM vacparted, does_not_exist;
VACUUM (FREEZE) vacparted, vaccluster, vactst;
VACUUM (FREEZE) does_not_exist, vaccluster;
VACUUM ANALYZE vactst, vacparted (a);
VACUUM ANALYZE vactst (does_not_exist), vacparted (b);
VACUUM FULL vacparted, vactst;
VACUUM FULL vactst, vacparted (a, b), vaccluster (i);
BEGIN;
COMMIT;
/* Tests for ANALYZE ONLY / VACUUM ONLY on partitioned tables */ CREATE TABLE x (x INT, x TEXT) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN (1);
INSERT INTO x VALUES (1, 'a');
SELECT x, NOT x IS NULL AS x, NOT x IS NULL AS x FROM x WHERE x IN (CAST('only_parted' AS REGCLASS), CAST('only_parted1' AS REGCLASS)) ORDER BY x NULLS LAST;
ANALYZE x /* Ensure partitioned table and the partitions are analyzed */;
SELECT x, NOT x IS NULL AS x, NOT x IS NULL AS x FROM x WHERE x IN (CAST('only_parted' AS REGCLASS), CAST('only_parted1' AS REGCLASS)) ORDER BY x NULLS LAST;
DROP TABLE x;
/* VACUUM ONLY on a partitioned table does nothing, ensure we get a warning. */ VACUUM ONLY vacparted;
/* Tests for VACUUM ONLY / ANALYZE ONLY on inheritance tables */ CREATE TABLE x (x INT PRIMARY KEY, x TEXT);
CREATE TABLE x INHERITS (x);
INSERT INTO x (x, x) VALUES (1, 'aaa'), (2, 'bbb'), (3, 'ccc');
SELECT x, NOT x IS NULL AS x, NOT x IS NULL AS x FROM x WHERE x IN (CAST('only_inh_parent' AS REGCLASS), CAST('only_inh_child' AS REGCLASS)) ORDER BY x NULLS LAST;
ANALYZE x /* Ensure the parent and child are analyzed */;
SELECT x, NOT x IS NULL AS x, NOT x IS NULL AS x FROM x WHERE x IN (CAST('only_inh_parent' AS REGCLASS), CAST('only_inh_child' AS REGCLASS)) ORDER BY x NULLS LAST;
/* Ensure only the parent is vacuumed */ VACUUM ONLY only_inh_parent;
SELECT x, NOT x IS NULL AS x, NOT x IS NULL AS x FROM x WHERE x IN (CAST('only_inh_parent' AS REGCLASS), CAST('only_inh_child' AS REGCLASS)) ORDER BY x NULLS LAST;
/* Ensure parent and child are vacuumed */ VACUUM only_inh_parent;
SELECT x, NOT x IS NULL AS x, NOT x IS NULL AS x FROM x WHERE x IN (CAST('only_inh_parent' AS REGCLASS), CAST('only_inh_child' AS REGCLASS)) ORDER BY x NULLS LAST;
DROP TABLE x CASCADE;
SET x = 'ERROR' /* ensure argument order independence, and that SKIP_LOCKED on non-existing */ /* relation still errors out.  Suppress WARNING messages caused by concurrent */ /* autovacuums. */;
/* SKIP_LOCKED option */ VACUUM (SKIP_LOCKED) vactst;
VACUUM (SKIP_LOCKED, FULL) vactst;
RESET client_min_messages;
SET x = serializable /* ensure VACUUM and ANALYZE don't have a problem with serializable */;
VACUUM vactst;
ANALYZE x;
RESET default_transaction_isolation;
BEGIN;
ANALYZE x;
COMMIT;
/* PROCESS_TOAST option */ CREATE TABLE x (x INT, x TEXT);
INSERT INTO x SELECT x, 't' || x FROM x AS x;
ALTER TABLE x ALTER COLUMN x DROP DEFAULT, SET STORAGE EXTERNAL;
/* Check the number of vacuums done on table vac_option_tab and on its */ /* toast relation, to check that PROCESS_TOAST and PROCESS_MAIN work on */ /* what they should. */ CREATE VIEW x AS SELECT CASE WHEN x.x IS NULL THEN 'main' ELSE 'toast' END AS x, x.x FROM x AS x LEFT JOIN x AS x ON x.x = x.x WHERE x.x = 'vac_option_tab' OR x.x = 'vac_option_tab' ORDER BY x NULLS LAST;
VACUUM (PROCESS_TOAST TRUE) vac_option_tab;
SELECT * FROM x;
VACUUM (PROCESS_TOAST FALSE) vac_option_tab;
SELECT * FROM x;
VACUUM (PROCESS_TOAST FALSE, FULL) vac_option_tab;
/* error */ /* PROCESS_MAIN option */ /* Only the toast table is processed. */ VACUUM (PROCESS_MAIN FALSE) vac_option_tab;
SELECT * FROM x;
/* Nothing is processed. */ VACUUM (PROCESS_MAIN FALSE, PROCESS_TOAST FALSE) vac_option_tab;
SELECT * FROM x;
SELECT x = :main_filenode AS x FROM x WHERE x = 'vac_option_tab';
SELECT x.x = :toast_filenode AS x FROM x AS x, x AS x WHERE x.x = x.x AND x.x = 'vac_option_tab';
/* BUFFER_USAGE_LIMIT option */ VACUUM (BUFFER_USAGE_LIMIT '512 kB') vac_option_tab;
/* try disabling the buffer usage limit */ VACUUM (BUFFER_USAGE_LIMIT 0) vac_option_tab;
/* value exceeds max size error */ VACUUM (BUFFER_USAGE_LIMIT 16777220) vac_option_tab;
/* value is less than min size error */ VACUUM (BUFFER_USAGE_LIMIT 120) vac_option_tab;
/* integer overflow error */ VACUUM (BUFFER_USAGE_LIMIT 10000000000) vac_option_tab;
/* incompatible with VACUUM FULL error */ VACUUM (BUFFER_USAGE_LIMIT '512 kB', FULL) vac_option_tab;
/* SKIP_DATABASE_STATS option */ VACUUM (SKIP_DATABASE_STATS) vactst;
/* ONLY_DATABASE_STATS option */ VACUUM (ONLY_DATABASE_STATS);
VACUUM (ONLY_DATABASE_STATS) vactst;
/* error */ DROP VIEW x;
DROP TABLE x;
DROP TABLE x;
DROP TABLE x;
DROP TABLE x;
DROP TABLE x;
/* relation ownership, WARNING logs generated as all are skipped. */ CREATE TABLE x (x INT);
CREATE TABLE x (x INT) WITH (PARTITIONED_BY=LIST(x));
CREATE TABLE x PARTITION OF x FOR VALUES IN (1);
CREATE TABLE x PARTITION OF x FOR VALUES IN (2);
CREATE ROLE regress_vacuum;
SET ROLE regress_vacuum;
/* Simple table */ VACUUM vacowned;
ANALYZE x;
VACUUM (ANALYZE) vacowned;
/* Catalog */ VACUUM pg_catalog.pg_class;
ANALYZE x.x;
VACUUM (ANALYZE) pg_catalog.pg_class;
/* Shared catalog */ VACUUM pg_catalog.pg_authid;
ANALYZE x.x;
VACUUM (ANALYZE) pg_catalog.pg_authid;
/* Partitioned table and its partitions, nothing owned by other user. */ /* Relations are not listed in a single command to test ownership */ /* independently. */ VACUUM vacowned_parted;
VACUUM vacowned_part1;
VACUUM vacowned_part2;
ANALYZE x;
ANALYZE x;
ANALYZE x;
VACUUM (ANALYZE) vacowned_parted;
VACUUM (ANALYZE) vacowned_part1;
VACUUM (ANALYZE) vacowned_part2;
RESET ROLE;
/* Partitioned table and one partition owned by other user. */ ALTER TABLE vacowned_parted OWNER TO regress_vacuum;
ALTER TABLE vacowned_part1 OWNER TO regress_vacuum;
SET ROLE regress_vacuum;
VACUUM vacowned_parted;
VACUUM vacowned_part1;
VACUUM vacowned_part2;
ANALYZE x;
ANALYZE x;
ANALYZE x;
VACUUM (ANALYZE) vacowned_parted;
VACUUM (ANALYZE) vacowned_part1;
VACUUM (ANALYZE) vacowned_part2;
RESET ROLE;
/* Only one partition owned by other user. */ ALTER TABLE vacowned_parted OWNER TO CURRENT_USER;
SET ROLE regress_vacuum;
VACUUM vacowned_parted;
VACUUM vacowned_part1;
VACUUM vacowned_part2;
ANALYZE x;
ANALYZE x;
ANALYZE x;
VACUUM (ANALYZE) vacowned_parted;
VACUUM (ANALYZE) vacowned_part1;
VACUUM (ANALYZE) vacowned_part2;
RESET ROLE;
/* Only partitioned table owned by other user. */ ALTER TABLE vacowned_parted OWNER TO regress_vacuum;
ALTER TABLE vacowned_part1 OWNER TO CURRENT_USER;
SET ROLE regress_vacuum;
VACUUM vacowned_parted;
VACUUM vacowned_part1;
VACUUM vacowned_part2;
ANALYZE x;
ANALYZE x;
ANALYZE x;
VACUUM (ANALYZE) vacowned_parted;
VACUUM (ANALYZE) vacowned_part1;
VACUUM (ANALYZE) vacowned_part2;
RESET ROLE;
DROP TABLE x;
DROP TABLE x;
DROP ROLE regress_vacuum;
SET x = 4;
SET x = '128kB';
/* Bug #17245: Make sure that we don't totally fail to VACUUM individual indexes that */ /* happen to be below min_parallel_index_scan_size during parallel VACUUM: */ CREATE TABLE x (x INT) WITH (autovacuum_enabled=off);
INSERT INTO x SELECT x FROM x AS x;
/* Parallel VACUUM will never be used unless there are at least two indexes */ /* that exceed min_parallel_index_scan_size.  Create two such indexes, and */ /* a third index that is smaller than min_parallel_index_scan_size. */ CREATE INDEX x ON x(x NULLS LAST);
CREATE INDEX x ON x(x NULLS LAST);
/* Note: vacuum_in_leader_small_index can apply deduplication, making it ~3x */ /* smaller than the other indexes */ CREATE INDEX x ON x((1) NULLS LAST);
/* Verify (as best we can) that the cost model for parallel VACUUM */ /* will make our VACUUM run in parallel, while always leaving it up to the */ /* parallel leader to handle the vacuum_in_leader_small_index index: */ SELECT EXISTS(SELECT 1 FROM x WHERE x = CAST('vacuum_in_leader_small_index' AS REGCLASS) AND PG_RELATION_SIZE(x) < PG_SIZE_BYTES(CURRENT_SETTING('min_parallel_index_scan_size'))) AS x;
SELECT COUNT(*) AS x FROM x WHERE x IN (CAST('regular_sized_index' AS REGCLASS), CAST('typically_sized_index' AS REGCLASS)) AND PG_RELATION_SIZE(x) >= PG_SIZE_BYTES(CURRENT_SETTING('min_parallel_index_scan_size'));
/* Parallel VACUUM with B-Tree page deletions, ambulkdelete calls: */ DELETE FROM x;
VACUUM (PARALLEL 4, INDEX_CLEANUP ON) parallel_vacuum_table;
/* Since vacuum_in_leader_small_index uses deduplication, we expect an */ /* assertion failure with bug #17245 (in the absence of bugfix): */ INSERT INTO x SELECT x FROM x AS x;
RESET max_parallel_maintenance_workers;
RESET min_parallel_index_scan_size;
/* VARCHAR */ /* Build a table for testing */ /* (This temporarily hides the table created in test_setup.sql) */ CREATE TEMPORARY TABLE x (x VARCHAR(1));
INSERT INTO x (x) VALUES ('a');
INSERT INTO x (x) VALUES ('A');
/* any of the following three input formats are acceptable */ INSERT INTO x (x) VALUES ('1');
INSERT INTO x (x) VALUES (2);
INSERT INTO x (x) VALUES ('3');
/* zero-length char */ INSERT INTO x (x) VALUES ('');
/* try varchar's of greater than 1 length */ INSERT INTO x (x) VALUES ('cd');
INSERT INTO x (x) VALUES ('c     ');
SELECT * FROM x;
SELECT x.* FROM x AS x WHERE x.x <> 'a';
SELECT x.* FROM x AS x WHERE x.x = 'a';
SELECT x.* FROM x AS x WHERE x.x < 'a';
SELECT x.* FROM x AS x WHERE x.x <= 'a';
SELECT x.* FROM x AS x WHERE x.x > 'a';
SELECT x.* FROM x AS x WHERE x.x >= 'a';
DROP TABLE x;
/* Now test longer arrays of char */ /* This varchar_tbl was already created and filled in test_setup.sql. */ /* Here we just try to insert bad values. */ INSERT INTO x (x) VALUES ('abcde');
SELECT * FROM x;
/* Also try it with non-error-throwing API */ SELECT PG_INPUT_IS_VALID('abcd  ', 'varchar(4)');
SELECT PG_INPUT_IS_VALID('abcde', 'varchar(4)');
SELECT * FROM x;
/* WINDOW FUNCTIONS */ CREATE TEMPORARY TABLE x (x VARCHAR, x BIGINT, x INT, x DATE);
INSERT INTO x VALUES ('develop', 10, 5200, '2007-08-01'), ('sales', 1, 5000, '2006-10-01'), ('personnel', 5, 3500, '2007-12-10'), ('sales', 4, 4800, '2007-08-08'), ('personnel', 2, 3900, '2006-12-23'), ('develop', 7, 4200, '2008-01-01'), ('develop', 9, 4500, '2008-01-01'), ('sales', 3, 4800, '2007-08-01'), ('develop', 8, 6000, '2006-10-01'), ('develop', 11, 5200, '2007-08-15');
SELECT x, x, x, SUM(x) OVER (PARTITION BY x) FROM x ORDER BY x NULLS LAST, x NULLS LAST;
SELECT x, x, x, RANK() OVER (PARTITION BY x ORDER BY x NULLS LAST) FROM x;
/* with GROUP BY */ SELECT x, x, SUM(SUM(x)) OVER (PARTITION BY x), AVG(x) FROM x GROUP BY x, x ORDER BY x NULLS LAST, x NULLS LAST;
SELECT x, x, x, SUM(x) OVER x FROM x WINDOW x AS (PARTITION BY x);
SELECT x, x, x, RANK() OVER x FROM x WINDOW x AS (PARTITION BY x ORDER BY x NULLS LAST) ORDER BY RANK() OVER x NULLS LAST;
/* empty window specification */ SELECT COUNT(*) OVER () FROM x WHERE x < 10;
SELECT COUNT(*) OVER x FROM x WHERE x < 10 WINDOW x AS ();
/* no window operation */ SELECT x FROM x WHERE FALSE WINDOW x AS (PARTITION BY x);
/* cumulative aggregate */ SELECT SUM(x) OVER (PARTITION BY x ORDER BY x NULLS LAST) AS x, x, x FROM x WHERE x < 10;
SELECT ROW_NUMBER() OVER (ORDER BY x NULLS LAST) FROM x WHERE x < 10;
SELECT RANK() OVER (PARTITION BY x ORDER BY x NULLS LAST) AS x, x, x FROM x WHERE x < 10;
SELECT DENSE_RANK() OVER (PARTITION BY x ORDER BY x NULLS LAST), x, x FROM x WHERE x < 10;
SELECT PERCENT_RANK() OVER (PARTITION BY x ORDER BY x NULLS LAST), x, x FROM x WHERE x < 10;
SELECT CUME_DIST() OVER (PARTITION BY x ORDER BY x NULLS LAST), x, x FROM x WHERE x < 10;
SELECT NTILE(3) OVER (ORDER BY x NULLS LAST, x NULLS LAST), x, x FROM x WHERE x < 10;
SELECT NTILE(NULL) OVER (ORDER BY x NULLS LAST, x NULLS LAST), x, x FROM x LIMIT 2;
SELECT LAG(x) OVER (PARTITION BY x ORDER BY x NULLS LAST), x, x FROM x WHERE x < 10;
SELECT LAG(x, x) OVER (PARTITION BY x ORDER BY x NULLS LAST), x, x FROM x WHERE x < 10;
SELECT LAG(x, x, 0) OVER (PARTITION BY x ORDER BY x NULLS LAST), x, x FROM x WHERE x < 10;
SELECT LAG(x, x, 0.7) OVER (PARTITION BY x ORDER BY x NULLS LAST), x, x FROM x WHERE x < 10 ORDER BY x NULLS LAST, x NULLS LAST;
SELECT LEAD(x) OVER (PARTITION BY x ORDER BY x NULLS LAST), x, x FROM x WHERE x < 10;
SELECT LEAD(x * 2, 1) OVER (PARTITION BY x ORDER BY x NULLS LAST), x, x FROM x WHERE x < 10;
SELECT LEAD(x * 2, 1, -1) OVER (PARTITION BY x ORDER BY x NULLS LAST), x, x FROM x WHERE x < 10;
SELECT LEAD(x * 2, 1, -1.4) OVER (PARTITION BY x ORDER BY x NULLS LAST), x, x FROM x WHERE x < 10 ORDER BY x NULLS LAST, x NULLS LAST;
SELECT FIRST_VALUE(x) OVER (PARTITION BY x ORDER BY x NULLS LAST), x, x FROM x WHERE x < 10;
/* last_value returns the last row of the frame, which is CURRENT ROW in ORDER BY window. */ SELECT LAST_VALUE(x) OVER (ORDER BY x NULLS LAST), x, x FROM x WHERE x < 10;
SELECT LAST_VALUE(x) OVER (PARTITION BY x), x, x FROM (SELECT * FROM x WHERE x < 10 ORDER BY x NULLS LAST, x NULLS LAST) AS x ORDER BY x NULLS LAST, x NULLS LAST;
SELECT NTH_VALUE(x, x + 1) OVER (PARTITION BY x), x, x FROM (SELECT * FROM x WHERE x < 10 ORDER BY x NULLS LAST, x NULLS LAST) AS x;
SELECT x, x, SUM(x) AS x, SUM(SUM(x)) OVER (PARTITION BY x ORDER BY x NULLS LAST) AS x FROM x GROUP BY x, x;
SELECT COUNT(*) OVER (PARTITION BY x), x FROM (SELECT * FROM x WHERE x = 1) AS x WHERE x < 10;
SELECT CAST((COUNT(*) OVER (PARTITION BY x ORDER BY x NULLS LAST) + SUM(x) OVER (PARTITION BY x ORDER BY x NULLS LAST)) AS VARCHAR) AS x FROM x WHERE x < 10;
/* opexpr with different windows evaluation. */ SELECT * FROM (SELECT COUNT(*) OVER (PARTITION BY x ORDER BY x NULLS LAST) + SUM(x) OVER (PARTITION BY x ORDER BY x NULLS LAST) AS x, COUNT(*) OVER (PARTITION BY x ORDER BY x NULLS LAST) AS x, SUM(x) OVER (PARTITION BY x ORDER BY x NULLS LAST) AS x FROM x) AS x WHERE x <> x + x;
SELECT AVG(x) OVER (PARTITION BY x ORDER BY x / 100 NULLS LAST) FROM x WHERE x < 10;
SELECT x, x, SUM(x) AS x, SUM(SUM(x)) OVER x AS x FROM x GROUP BY x, x WINDOW x AS (PARTITION BY x ORDER BY x NULLS LAST);
/* more than one window with GROUP BY */ SELECT SUM(x), ROW_NUMBER() OVER (ORDER BY x NULLS LAST), SUM(SUM(x)) OVER (ORDER BY x DESC NULLS FIRST) FROM x GROUP BY x;
/* identical windows with different names */ SELECT SUM(x) OVER x, COUNT(*) OVER x FROM x WINDOW x AS (ORDER BY x NULLS LAST), x AS (ORDER BY x NULLS LAST);
/* subplan */ SELECT LEAD(x, (SELECT x FROM x WHERE x.x = x)) OVER (PARTITION BY x ORDER BY x NULLS LAST) FROM x AS x WHERE x < 10;
/* empty table */ SELECT COUNT(*) OVER (PARTITION BY x) FROM (SELECT * FROM x WHERE FALSE) AS x;
/* mixture of agg/wfunc in the same window */ SELECT SUM(x) OVER x, RANK() OVER x FROM x WINDOW x AS (PARTITION BY x ORDER BY x DESC NULLS FIRST);
/* strict aggs */ SELECT x, x, x, x, x, MIN(x) OVER (ORDER BY x NULLS LAST), MAX(x) OVER () FROM (SELECT *, CASE WHEN x < '2008-01-01' THEN 2008 - EXTRACT(YEAR FROM x) END * 500 AS x, CASE WHEN AVG(x) OVER (PARTITION BY x) < x THEN 200 END AS x FROM x) AS x;
/* window function over ungrouped agg over empty row set (bug before 9.1) */ SELECT SUM(COUNT(x)) OVER () FROM x WHERE x = 42;
/* window function with ORDER BY an expression involving aggregates (9.1 bug) */ SELECT x, SUM(x) + SUM(x) AS x, RANK() OVER (ORDER BY SUM(x) + SUM(x) NULLS LAST) AS x FROM x GROUP BY x ORDER BY x NULLS LAST;
/* window and aggregate with GROUP BY expression (9.2 bug) */ EXPLAIN (costs off) select first_value(max(x)) over (), y   from (select unique1 as x, ten+four as y from tenk1) ss   group by y;
/* window functions returning pass-by-ref values from different rows */ SELECT x, LAG(x, 1) OVER (ORDER BY x NULLS LAST), LEAD(x, 3) OVER (ORDER BY x NULLS LAST) FROM (SELECT CAST(x AS DECIMAL) AS x FROM x AS x);
/* test non-default frame specifications */ SELECT x, x, SUM(x) OVER (PARTITION BY x ORDER BY x NULLS LAST), LAST_VALUE(x) OVER (PARTITION BY x ORDER BY x NULLS LAST) FROM (SELECT DISTINCT x, x FROM x) AS x;
SELECT x, x, SUM(x) OVER (PARTITION BY x ORDER BY x NULLS LAST range BETWEEN UNBOUNDED preceding AND CURRENT ROW), LAST_VALUE(x) OVER (PARTITION BY x ORDER BY x NULLS LAST range BETWEEN UNBOUNDED preceding AND CURRENT ROW) FROM (SELECT DISTINCT x, x FROM x) AS x;
SELECT x, x, SUM(x) OVER (PARTITION BY x ORDER BY x NULLS LAST range BETWEEN UNBOUNDED preceding AND UNBOUNDED following), LAST_VALUE(x) OVER (PARTITION BY x ORDER BY x NULLS LAST range BETWEEN UNBOUNDED preceding AND UNBOUNDED following) FROM (SELECT DISTINCT x, x FROM x) AS x;
SELECT x, x / 4 AS x, SUM(x / 4) OVER (PARTITION BY x ORDER BY x / 4 NULLS LAST range BETWEEN UNBOUNDED preceding AND CURRENT ROW), LAST_VALUE(x / 4) OVER (PARTITION BY x ORDER BY x / 4 NULLS LAST range BETWEEN UNBOUNDED preceding AND CURRENT ROW) FROM (SELECT DISTINCT x, x FROM x) AS x;
SELECT x, x / 4 AS x, SUM(x / 4) OVER (PARTITION BY x ORDER BY x / 4 NULLS LAST rows BETWEEN UNBOUNDED preceding AND CURRENT ROW), LAST_VALUE(x / 4) OVER (PARTITION BY x ORDER BY x / 4 NULLS LAST rows BETWEEN UNBOUNDED preceding AND CURRENT ROW) FROM (SELECT DISTINCT x, x FROM x) AS x;
SELECT SUM(x) OVER (ORDER BY x NULLS LAST range BETWEEN CURRENT ROW AND UNBOUNDED following), x, x FROM x WHERE x < 10;
SELECT SUM(x) OVER (rows BETWEEN CURRENT ROW AND UNBOUNDED following), x, x FROM x WHERE x < 10;
SELECT SUM(x) OVER (rows BETWEEN 2 preceding AND 2 following), x, x FROM x WHERE x < 10;
SELECT SUM(x) OVER (rows BETWEEN 2 preceding AND 1 preceding), x, x FROM x WHERE x < 10;
SELECT SUM(x) OVER (rows BETWEEN 1 following AND 3 following), x, x FROM x WHERE x < 10;
SELECT SUM(x) OVER (rows BETWEEN UNBOUNDED preceding AND 1 following), x, x FROM x WHERE x < 10;
SELECT SUM(x) OVER (x range BETWEEN CURRENT ROW AND UNBOUNDED following), x, x FROM x WHERE x < 10 WINDOW x AS (ORDER BY x NULLS LAST);
SELECT FIRST_VALUE(x) OVER x, NTH_VALUE(x, 2) OVER x AS x, LAST_VALUE(x) OVER x, x, x FROM x WHERE x < 10 WINDOW x AS (ORDER BY x NULLS LAST range BETWEEN CURRENT ROW AND UNBOUNDED following);
SELECT SUM(x) OVER (ORDER BY x NULLS LAST rows BETWEEN (SELECT x FROM x ORDER BY x NULLS LAST LIMIT 1) + 1 PRECEDING AND CURRENT ROW), x FROM x WHERE x < 10;
CREATE TEMPORARY VIEW x AS SELECT x, SUM(x) OVER (ORDER BY x NULLS LAST rows BETWEEN 1 preceding AND 1 following) AS x FROM x AS x;
SELECT * FROM x;
SELECT PG_GET_VIEWDEF('v_window');
SELECT * FROM x;
SELECT PG_GET_VIEWDEF('v_window');
SELECT * FROM x;
SELECT PG_GET_VIEWDEF('v_window');
SELECT * FROM x;
SELECT PG_GET_VIEWDEF('v_window');
SELECT * FROM x;
SELECT PG_GET_VIEWDEF('v_window');
SELECT * FROM x;
SELECT PG_GET_VIEWDEF('v_window');
DROP VIEW x;
CREATE TEMPORARY VIEW x AS SELECT x, MIN(x) OVER (ORDER BY x NULLS LAST range BETWEEN '1 day' preceding AND '10 days' following) AS x FROM x AS x;
SELECT PG_GET_VIEWDEF('v_window');
/* RANGE offset PRECEDING/FOLLOWING tests */ SELECT SUM(x) OVER (ORDER BY x NULLS LAST range BETWEEN CAST(2 AS BIGINT) preceding AND CAST(1 AS SMALLINT) preceding), x, x FROM x WHERE x < 10;
SELECT SUM(x) OVER (ORDER BY x DESC NULLS FIRST range BETWEEN CAST(2 AS BIGINT) preceding AND CAST(1 AS SMALLINT) preceding), x, x FROM x WHERE x < 10;
SELECT SUM(x) OVER (PARTITION BY x ORDER BY x NULLS LAST range BETWEEN CAST(5 AS BIGINT) preceding AND CAST(6 AS SMALLINT) following), x, x FROM x WHERE x < 10;
SELECT SUM(x) OVER (ORDER BY x NULLS LAST range BETWEEN CAST('1 year' AS INTERVAL PRECEDING) AND CAST('1 year' AS INTERVAL FOLLOWING)), x, x FROM x;
SELECT SUM(x) OVER (ORDER BY x DESC NULLS FIRST range BETWEEN CAST('1 year' AS INTERVAL PRECEDING) AND CAST('1 year' AS INTERVAL FOLLOWING)), x, x FROM x;
SELECT SUM(x) OVER (ORDER BY x DESC NULLS FIRST range BETWEEN CAST('1 year' AS INTERVAL FOLLOWING) AND CAST('1 year' AS INTERVAL FOLLOWING)), x, x FROM x;
SELECT FIRST_VALUE(x) OVER (ORDER BY x NULLS LAST range BETWEEN 1000 preceding AND 1000 following), LEAD(x) OVER (ORDER BY x NULLS LAST range BETWEEN 1000 preceding AND 1000 following), NTH_VALUE(x, 1) OVER (ORDER BY x NULLS LAST range BETWEEN 1000 preceding AND 1000 following), x FROM x;
SELECT LAST_VALUE(x) OVER (ORDER BY x NULLS LAST range BETWEEN 1000 preceding AND 1000 following), LAG(x) OVER (ORDER BY x NULLS LAST range BETWEEN 1000 preceding AND 1000 following), x FROM x;
/* RANGE offset PRECEDING/FOLLOWING with null values */ SELECT x, x, FIRST_VALUE(x) OVER x, LAST_VALUE(x) OVER x FROM (SELECT x, x AS x FROM x AS x UNION ALL SELECT NULL, 42 UNION ALL SELECT NULL, 43) AS x WINDOW x AS (ORDER BY x ASC range BETWEEN 2 preceding AND 2 following);
SELECT x, x, FIRST_VALUE(x) OVER x, LAST_VALUE(x) OVER x FROM (SELECT x, x AS x FROM x AS x UNION ALL SELECT NULL, 42 UNION ALL SELECT NULL, 43) AS x WINDOW x AS (ORDER BY x ASC NULLS LAST range BETWEEN 2 preceding AND 2 following);
SELECT x, x, FIRST_VALUE(x) OVER x, LAST_VALUE(x) OVER x FROM (SELECT x, x AS x FROM x AS x UNION ALL SELECT NULL, 42 UNION ALL SELECT NULL, 43) AS x WINDOW x AS (ORDER BY x DESC NULLS FIRST range BETWEEN 2 preceding AND 2 following);
SELECT x, x, FIRST_VALUE(x) OVER x, LAST_VALUE(x) OVER x FROM (SELECT x, x AS x FROM x AS x UNION ALL SELECT NULL, 42 UNION ALL SELECT NULL, 43) AS x WINDOW x AS (ORDER BY x DESC range BETWEEN 2 preceding AND 2 following);
/* There is a syntactic ambiguity in the SQL standard.  Since */ /* UNBOUNDED is a non-reserved word, it could be the name of a */ /* function parameter and be used as an expression.  There is a */ /* grammar hack to resolve such cases as the keyword.  The following */ /* tests record this behavior. */ CREATE FUNCTION x(x INT) RETURNS TABLE (x INT, x INT, x INT) LANGUAGE SQL AS BEGIN ATOMIC   SELECT sum(unique1) over (rows between x preceding and x following),          unique1, four   FROM tenk1 WHERE unique1 < 10;
COMMIT;
/* These will apply the argument to the window specification inside the function. */ SELECT * FROM x;
SELECT * FROM x;
CREATE FUNCTION x(x INT) RETURNS TABLE (x INT, x INT, x INT) LANGUAGE SQL AS BEGIN ATOMIC   SELECT sum(unique1) over (rows between unbounded preceding and unbounded following),          unique1, four   FROM tenk1 WHERE unique1 < 10;
COMMIT;
/* These will not apply the argument but instead treat UNBOUNDED as a keyword. */ SELECT * FROM x;
SELECT * FROM x;
/* Other tests with token UNBOUNDED in potentially problematic position */ CREATE FUNCTION x(x INT) RETURNS INT LANGUAGE SQL IMMUTABLE AS RETURN x;
SELECT SUM(x) OVER (rows BETWEEN 1 preceding AND 1 following), x, x FROM x WHERE x < 10;
DROP FUNCTION x;
/* Check overflow behavior for various integer sizes */ SELECT x, LAST_VALUE(x) OVER (ORDER BY CAST(x AS SMALLINT) NULLS LAST range BETWEEN CURRENT ROW AND 2147450884 following) FROM x AS x;
SELECT x, LAST_VALUE(x) OVER (ORDER BY CAST(x AS SMALLINT) DESC NULLS FIRST range BETWEEN CURRENT ROW AND 2147450885 following) FROM x AS x;
SELECT x, LAST_VALUE(x) OVER (ORDER BY x NULLS LAST range BETWEEN CURRENT ROW AND 4 following) FROM x AS x;
SELECT x, LAST_VALUE(x) OVER (ORDER BY x DESC NULLS FIRST range BETWEEN CURRENT ROW AND 5 following) FROM x AS x;
SELECT x, LAST_VALUE(x) OVER (ORDER BY x NULLS LAST range BETWEEN CURRENT ROW AND 4 following) FROM x AS x;
SELECT x, LAST_VALUE(x) OVER (ORDER BY x DESC NULLS FIRST range BETWEEN CURRENT ROW AND 5 following) FROM x AS x;
/* Test in_range for other numeric datatypes */ CREATE TEMPORARY TABLE x (x INT, x FLOAT, x DOUBLE, x DECIMAL);
INSERT INTO x VALUES (0, '-infinity', '-infinity', '-infinity'), (1, -3, -3, -3), (2, -1, -1, -1), (3, 0, 0, 0), (4, 1.1, 1.1, 1.1), (5, 1.12, 1.12, 1.12), (6, 2, 2, 2), (7, 100, 100, 100), (8, 'infinity', 'infinity', 'infinity'), (9, 'NaN', 'NaN', 'NaN');
SELECT x, x, FIRST_VALUE(x) OVER x, LAST_VALUE(x) OVER x FROM x WINDOW x AS (ORDER BY x NULLS LAST range BETWEEN 1 preceding AND 1 following);
SELECT x, x, FIRST_VALUE(x) OVER x, LAST_VALUE(x) OVER x FROM x WINDOW x AS (ORDER BY x NULLS LAST range BETWEEN 1 preceding AND CAST(1.1 AS FLOAT) following);
SELECT x, x, FIRST_VALUE(x) OVER x, LAST_VALUE(x) OVER x FROM x WINDOW x AS (ORDER BY x NULLS LAST range BETWEEN 'inf' preceding AND 'inf' following);
SELECT x, x, FIRST_VALUE(x) OVER x, LAST_VALUE(x) OVER x FROM x WINDOW x AS (ORDER BY x NULLS LAST range BETWEEN 'inf' preceding AND 'inf' preceding);
SELECT x, x, FIRST_VALUE(x) OVER x, LAST_VALUE(x) OVER x FROM x WINDOW x AS (ORDER BY x NULLS LAST range BETWEEN 'inf' following AND 'inf' following);
SELECT x, x, FIRST_VALUE(x) OVER x, LAST_VALUE(x) OVER x FROM x WINDOW x AS (ORDER BY x NULLS LAST range BETWEEN 1.1 preceding AND 'NaN' following);
/* error, NaN disallowed */ SELECT x, x, FIRST_VALUE(x) OVER x, LAST_VALUE(x) OVER x FROM x WINDOW x AS (ORDER BY x NULLS LAST range BETWEEN 1 preceding AND 1 following);
SELECT x, x, FIRST_VALUE(x) OVER x, LAST_VALUE(x) OVER x FROM x WINDOW x AS (ORDER BY x NULLS LAST range BETWEEN 1 preceding AND CAST(1.1 AS DOUBLE) following);
SELECT x, x, FIRST_VALUE(x) OVER x, LAST_VALUE(x) OVER x FROM x WINDOW x AS (ORDER BY x NULLS LAST range BETWEEN 'inf' preceding AND 'inf' following);
SELECT x, x, FIRST_VALUE(x) OVER x, LAST_VALUE(x) OVER x FROM x WINDOW x AS (ORDER BY x NULLS LAST range BETWEEN 'inf' preceding AND 'inf' preceding);
SELECT x, x, FIRST_VALUE(x) OVER x, LAST_VALUE(x) OVER x FROM x WINDOW x AS (ORDER BY x NULLS LAST range BETWEEN 'inf' following AND 'inf' following);
SELECT x, x, FIRST_VALUE(x) OVER x, LAST_VALUE(x) OVER x FROM x WINDOW x AS (ORDER BY x NULLS LAST range BETWEEN 1.1 preceding AND 'NaN' following);
/* error, NaN disallowed */ SELECT x, x, FIRST_VALUE(x) OVER x, LAST_VALUE(x) OVER x FROM x WINDOW x AS (ORDER BY x NULLS LAST range BETWEEN 1 preceding AND 1 following);
SELECT x, x, FIRST_VALUE(x) OVER x, LAST_VALUE(x) OVER x FROM x WINDOW x AS (ORDER BY x NULLS LAST range BETWEEN 1 preceding AND CAST(1.1 AS DECIMAL) following);
SELECT x, x, FIRST_VALUE(x) OVER x, LAST_VALUE(x) OVER x FROM x WINDOW x AS (ORDER BY x NULLS LAST range BETWEEN 1 preceding AND CAST(1.1 AS DOUBLE) following);
/* currently unsupported */ SELECT x, x, FIRST_VALUE(x) OVER x, LAST_VALUE(x) OVER x FROM x WINDOW x AS (ORDER BY x NULLS LAST range BETWEEN 'inf' preceding AND 'inf' following);
SELECT x, x, FIRST_VALUE(x) OVER x, LAST_VALUE(x) OVER x FROM x WINDOW x AS (ORDER BY x NULLS LAST range BETWEEN 'inf' preceding AND 'inf' preceding);
SELECT x, x, FIRST_VALUE(x) OVER x, LAST_VALUE(x) OVER x FROM x WINDOW x AS (ORDER BY x NULLS LAST range BETWEEN 'inf' following AND 'inf' following);
SELECT x, x, FIRST_VALUE(x) OVER x, LAST_VALUE(x) OVER x FROM x WINDOW x AS (ORDER BY x NULLS LAST range BETWEEN 1.1 preceding AND 'NaN' following);
/* error, NaN disallowed */ /* Test in_range for other datetime datatypes */ CREATE TEMPORARY TABLE x (x INT, x TIME, x TIMETZ, x INTERVAL, x TIMESTAMPTZ, x TIMESTAMP);
INSERT INTO x VALUES (0, '10:00', '10:00 BST', '-infinity', '-infinity', '-infinity'), (1, '11:00', '11:00 BST', '1 year', '2000-10-19 10:23:54+01', '2000-10-19 10:23:54'), (2, '12:00', '12:00 BST', '2 years', '2001-10-19 10:23:54+01', '2001-10-19 10:23:54'), (3, '13:00', '13:00 BST', '3 years', '2001-10-19 10:23:54+01', '2001-10-19 10:23:54'), (4, '14:00', '14:00 BST', '4 years', '2002-10-19 10:23:54+01', '2002-10-19 10:23:54'), (5, '15:00', '15:00 BST', '5 years', '2003-10-19 10:23:54+01', '2003-10-19 10:23:54'), (6, '15:00', '15:00 BST', '5 years', '2004-10-19 10:23:54+01', '2004-10-19 10:23:54'), (7, '17:00', '17:00 BST', '7 years', '2005-10-19 10:23:54+01', '2005-10-19 10:23:54'), (8, '18:00', '18:00 BST', '8 years', '2006-10-19 10:23:54+01', '2006-10-19 10:23:54'), (9, '19:00', '19:00 BST', '9 years', '2007-10-19 10:23:54+01', '2007-10-19 10:23:54'), (10, '20:00', '20:00 BST', '10 years', '2008-10-19 10:23:54+01', '2008-10-19 10:23:54'), (11, '21:00', '21:00 BST', 'infinity', 'infinity', 'infinity');
SELECT x, x, FIRST_VALUE(x) OVER x, LAST_VALUE(x) OVER x FROM x WINDOW x AS (ORDER BY x NULLS LAST range BETWEEN CAST('70 min' AS INTERVAL PRECEDING) AND CAST('2 hours' AS INTERVAL FOLLOWING));
SELECT x, x, FIRST_VALUE(x) OVER x, LAST_VALUE(x) OVER x FROM x WINDOW x AS (ORDER BY x DESC NULLS FIRST range BETWEEN '70 min' preceding AND '2 hours' following);
SELECT x, x, FIRST_VALUE(x) OVER x, LAST_VALUE(x) OVER x FROM x WINDOW x AS (ORDER BY x DESC NULLS FIRST range BETWEEN '-70 min' preceding AND '2 hours' following);
/* error, negative offset disallowed */ SELECT x, x, FIRST_VALUE(x) OVER x, LAST_VALUE(x) OVER x FROM x WINDOW x AS (ORDER BY x NULLS LAST range BETWEEN CAST('infinity' AS INTERVAL PRECEDING) AND CAST('infinity' AS INTERVAL FOLLOWING));
SELECT x, x, FIRST_VALUE(x) OVER x, LAST_VALUE(x) OVER x FROM x WINDOW x AS (ORDER BY x NULLS LAST range BETWEEN CAST('infinity' AS INTERVAL PRECEDING) AND CAST('infinity' AS INTERVAL PRECEDING));
SELECT x, x, FIRST_VALUE(x) OVER x, LAST_VALUE(x) OVER x FROM x WINDOW x AS (ORDER BY x NULLS LAST range BETWEEN CAST('infinity' AS INTERVAL FOLLOWING) AND CAST('infinity' AS INTERVAL FOLLOWING));
SELECT x, x, FIRST_VALUE(x) OVER x, LAST_VALUE(x) OVER x FROM x WINDOW x AS (ORDER BY x NULLS LAST range BETWEEN CAST('-infinity' AS INTERVAL FOLLOWING) AND CAST('infinity' AS INTERVAL FOLLOWING));
/* error, negative offset disallowed */ SELECT x, x, FIRST_VALUE(x) OVER x, LAST_VALUE(x) OVER x FROM x WINDOW x AS (ORDER BY x NULLS LAST range BETWEEN CAST('70 min' AS INTERVAL PRECEDING) AND CAST('2 hours' AS INTERVAL FOLLOWING));
SELECT x, x, FIRST_VALUE(x) OVER x, LAST_VALUE(x) OVER x FROM x WINDOW x AS (ORDER BY x DESC NULLS FIRST range BETWEEN '70 min' preceding AND '2 hours' following);
SELECT x, x, FIRST_VALUE(x) OVER x, LAST_VALUE(x) OVER x FROM x WINDOW x AS (ORDER BY x DESC NULLS FIRST range BETWEEN '70 min' preceding AND '-2 hours' following);
/* error, negative offset disallowed */ SELECT x, x, FIRST_VALUE(x) OVER x, LAST_VALUE(x) OVER x FROM x WINDOW x AS (ORDER BY x NULLS LAST range BETWEEN CAST('infinity' AS INTERVAL PRECEDING) AND CAST('infinity' AS INTERVAL FOLLOWING));
SELECT x, x, FIRST_VALUE(x) OVER x, LAST_VALUE(x) OVER x FROM x WINDOW x AS (ORDER BY x NULLS LAST range BETWEEN CAST('infinity' AS INTERVAL PRECEDING) AND CAST('infinity' AS INTERVAL PRECEDING));
SELECT x, x, FIRST_VALUE(x) OVER x, LAST_VALUE(x) OVER x FROM x WINDOW x AS (ORDER BY x NULLS LAST range BETWEEN CAST('infinity' AS INTERVAL FOLLOWING) AND CAST('infinity' AS INTERVAL FOLLOWING));
SELECT x, x, FIRST_VALUE(x) OVER x, LAST_VALUE(x) OVER x FROM x WINDOW x AS (ORDER BY x NULLS LAST range BETWEEN CAST('infinity' AS INTERVAL FOLLOWING) AND CAST('-infinity' AS INTERVAL FOLLOWING));
/* error, negative offset disallowed */ SELECT x, x, FIRST_VALUE(x) OVER x, LAST_VALUE(x) OVER x FROM x WINDOW x AS (ORDER BY x NULLS LAST range BETWEEN CAST('1 year' AS INTERVAL PRECEDING) AND CAST('1 year' AS INTERVAL FOLLOWING));
SELECT x, x, FIRST_VALUE(x) OVER x, LAST_VALUE(x) OVER x FROM x WINDOW x AS (ORDER BY x DESC NULLS FIRST range BETWEEN '1 year' preceding AND '1 year' following);
SELECT x, x, FIRST_VALUE(x) OVER x, LAST_VALUE(x) OVER x FROM x WINDOW x AS (ORDER BY x DESC NULLS FIRST range BETWEEN '-1 year' preceding AND '1 year' following);
/* error, negative offset disallowed */ SELECT x, x, FIRST_VALUE(x) OVER x, LAST_VALUE(x) OVER x FROM x WINDOW x AS (ORDER BY x NULLS LAST range BETWEEN CAST('infinity' AS INTERVAL PRECEDING) AND CAST('infinity' AS INTERVAL FOLLOWING));
SELECT x, x, FIRST_VALUE(x) OVER x, LAST_VALUE(x) OVER x FROM x WINDOW x AS (ORDER BY x NULLS LAST range BETWEEN CAST('infinity' AS INTERVAL PRECEDING) AND CAST('infinity' AS INTERVAL PRECEDING));
SELECT x, x, FIRST_VALUE(x) OVER x, LAST_VALUE(x) OVER x FROM x WINDOW x AS (ORDER BY x NULLS LAST range BETWEEN CAST('infinity' AS INTERVAL FOLLOWING) AND CAST('infinity' AS INTERVAL FOLLOWING));
SELECT x, x, FIRST_VALUE(x) OVER x, LAST_VALUE(x) OVER x FROM x WINDOW x AS (ORDER BY x NULLS LAST range BETWEEN CAST('-infinity' AS INTERVAL FOLLOWING) AND CAST('infinity' AS INTERVAL FOLLOWING));
/* error, negative offset disallowed */ SELECT x, x, FIRST_VALUE(x) OVER x, LAST_VALUE(x) OVER x FROM x WINDOW x AS (ORDER BY x NULLS LAST range BETWEEN CAST('1 year' AS INTERVAL PRECEDING) AND CAST('1 year' AS INTERVAL FOLLOWING));
SELECT x, x, FIRST_VALUE(x) OVER x, LAST_VALUE(x) OVER x FROM x WINDOW x AS (ORDER BY x DESC NULLS FIRST range BETWEEN '1 year' preceding AND '1 year' following);
SELECT x, x, FIRST_VALUE(x) OVER x, LAST_VALUE(x) OVER x FROM x WINDOW x AS (ORDER BY x DESC NULLS FIRST range BETWEEN '1 year' preceding AND '-1 year' following);
/* error, negative offset disallowed */ SELECT x, x, FIRST_VALUE(x) OVER x, LAST_VALUE(x) OVER x FROM x WINDOW x AS (ORDER BY x NULLS LAST range BETWEEN CAST('infinity' AS INTERVAL PRECEDING) AND CAST('infinity' AS INTERVAL FOLLOWING));
SELECT x, x, FIRST_VALUE(x) OVER x, LAST_VALUE(x) OVER x FROM x WINDOW x AS (ORDER BY x NULLS LAST range BETWEEN CAST('infinity' AS INTERVAL PRECEDING) AND CAST('infinity' AS INTERVAL PRECEDING));
SELECT x, x, FIRST_VALUE(x) OVER x, LAST_VALUE(x) OVER x FROM x WINDOW x AS (ORDER BY x NULLS LAST range BETWEEN CAST('infinity' AS INTERVAL FOLLOWING) AND CAST('infinity' AS INTERVAL FOLLOWING));
SELECT x, x, FIRST_VALUE(x) OVER x, LAST_VALUE(x) OVER x FROM x WINDOW x AS (ORDER BY x NULLS LAST range BETWEEN CAST('-infinity' AS INTERVAL FOLLOWING) AND CAST('infinity' AS INTERVAL FOLLOWING));
/* error, negative offset disallowed */ SELECT x, x, FIRST_VALUE(x) OVER x, LAST_VALUE(x) OVER x FROM x WINDOW x AS (ORDER BY x NULLS LAST range BETWEEN CAST('1 year' AS INTERVAL PRECEDING) AND CAST('1 year' AS INTERVAL FOLLOWING));
SELECT x, x, FIRST_VALUE(x) OVER x, LAST_VALUE(x) OVER x FROM x WINDOW x AS (ORDER BY x DESC NULLS FIRST range BETWEEN '1 year' preceding AND '1 year' following);
SELECT x, x, FIRST_VALUE(x) OVER x, LAST_VALUE(x) OVER x FROM x WINDOW x AS (ORDER BY x DESC NULLS FIRST range BETWEEN '-1 year' preceding AND '1 year' following);
/* error, negative offset disallowed */ SELECT x, x, FIRST_VALUE(x) OVER x, LAST_VALUE(x) OVER x FROM x WINDOW x AS (ORDER BY x NULLS LAST range BETWEEN CAST('infinity' AS INTERVAL PRECEDING) AND CAST('infinity' AS INTERVAL FOLLOWING));
SELECT x, x, FIRST_VALUE(x) OVER x, LAST_VALUE(x) OVER x FROM x WINDOW x AS (ORDER BY x NULLS LAST range BETWEEN CAST('infinity' AS INTERVAL PRECEDING) AND CAST('infinity' AS INTERVAL PRECEDING));
SELECT x, x, FIRST_VALUE(x) OVER x, LAST_VALUE(x) OVER x FROM x WINDOW x AS (ORDER BY x NULLS LAST range BETWEEN CAST('infinity' AS INTERVAL FOLLOWING) AND CAST('infinity' AS INTERVAL FOLLOWING));
SELECT x, x, FIRST_VALUE(x) OVER x, LAST_VALUE(x) OVER x FROM x WINDOW x AS (ORDER BY x NULLS LAST range BETWEEN CAST('-infinity' AS INTERVAL FOLLOWING) AND CAST('infinity' AS INTERVAL FOLLOWING));
/* Show differences in offset interpretation between ROWS, RANGE, and GROUPS */ WITH x AS (SELECT * FROM x) SELECT x, (SUM(x) OVER x) FROM x WINDOW x AS (ORDER BY x NULLS LAST rows BETWEEN 1 preceding AND 1 following);
WITH x AS (SELECT * FROM x) SELECT x, (SUM(x) OVER x) FROM x WINDOW x AS (ORDER BY x NULLS LAST range BETWEEN 1 preceding AND 1 following);
WITH x AS (SELECT 1 UNION ALL SELECT 1 UNION ALL SELECT 1 UNION ALL SELECT * FROM x) SELECT x, (SUM(x) OVER x) FROM x WINDOW x AS (ORDER BY x NULLS LAST rows BETWEEN 1 preceding AND 1 following);
WITH x AS (SELECT 1 UNION ALL SELECT 1 UNION ALL SELECT 1 UNION ALL SELECT * FROM x) SELECT x, (SUM(x) OVER x) FROM x WINDOW x AS (ORDER BY x NULLS LAST range BETWEEN 1 preceding AND 1 following);
/* with UNION */ SELECT COUNT(*) OVER (PARTITION BY x) FROM (SELECT * FROM x UNION ALL SELECT * FROM x) AS x LIMIT 0;
/* check some degenerate cases */ CREATE TEMPORARY TABLE x (x INT, x BIGINT);
INSERT INTO x VALUES (1, 1), (1, 2), (2, 2);
SELECT x, SUM(x) OVER (PARTITION BY x range BETWEEN 1 preceding AND 1 following) FROM x WHERE x = x;
/* error, must have order by */ EXPLAIN (costs off) select f1, sum(f1) over (partition by f1 order by f2                          range between 1 preceding and 1 following) from t1 where f1 = f2;
SELECT x, SUM(x) OVER (PARTITION BY x ORDER BY x NULLS LAST range BETWEEN 1 preceding AND 1 following) FROM x WHERE x = x;
SELECT x, SUM(x) OVER (PARTITION BY x, x ORDER BY x NULLS LAST range BETWEEN 2 preceding AND 1 preceding) FROM x WHERE x = x;
SELECT x, SUM(x) OVER (PARTITION BY x, x ORDER BY x NULLS LAST range BETWEEN 1 following AND 2 following) FROM x WHERE x = x;
/* error, must have order by */ EXPLAIN (costs off) select f1, sum(f1) over (partition by f1 order by f2                          groups between 1 preceding and 1 following) from t1 where f1 = f2;
/* ordering by a non-integer constant is allowed */ SELECT RANK() OVER (ORDER BY LENGTH('abc') NULLS LAST);
/* can't order by another window function */ SELECT RANK() OVER (ORDER BY RANK() OVER (ORDER BY RAND() NULLS LAST) NULLS LAST);
/* some other errors */ SELECT * FROM x WHERE ROW_NUMBER() OVER (ORDER BY x NULLS LAST) < 10;
SELECT * FROM x INNER JOIN x ON ROW_NUMBER() OVER (ORDER BY x NULLS LAST) < 10;
SELECT RANK() OVER (ORDER BY 1 NULLS LAST), COUNT(*) FROM x GROUP BY 1;
SELECT * FROM x;
DELETE FROM x WHERE (RANK() OVER (ORDER BY RAND() NULLS LAST)) > 10;
DELETE FROM x RETURNING RANK() OVER (ORDER BY RAND() NULLS LAST);
SELECT COUNT(*) OVER x FROM x WINDOW x AS (ORDER BY x NULLS LAST), x AS (ORDER BY x NULLS LAST);
SELECT RANK() OVER (PARTITION BY x ORDER BY x NULLS LAST) FROM x;
SELECT COUNT() OVER () FROM x;
SELECT UNNEST(GENERATE_SERIES(1, 100)) OVER () FROM x;
SELECT NTILE(0) OVER (ORDER BY x NULLS LAST), x, x FROM x;
SELECT NTH_VALUE(x, 0) OVER (ORDER BY x NULLS LAST), x, x FROM x;
/* filter */ SELECT SUM(x), ROW_NUMBER() OVER (ORDER BY x NULLS LAST), SUM(SUM(x) FILTER(WHERE x > '2007-01-01')) FILTER(WHERE x <> 'sales') OVER (ORDER BY x DESC NULLS FIRST) AS "x", x FROM x GROUP BY x;
/* Test SupportRequestOptimizeWindowClause's ability to de-duplicate */ /* WindowClauses */ /* Ensure WindowClause frameOptions are changed so that only a single */ /* WindowAgg exists in the plan. */ EXPLAIN (COSTS OFF) SELECT     empno,     depname,     row_number() OVER (PARTITION BY depname ORDER BY enroll_date) rn,     rank() OVER (PARTITION BY depname ORDER BY enroll_date ROWS BETWEEN                  UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) rnk,     dense_rank() OVER (PARTITION BY depname ORDER BY enroll_date RANGE BETWEEN                        CURRENT ROW AND CURRENT ROW) drnk,     ntile(10) OVER (PARTITION BY depname ORDER BY enroll_date RANGE BETWEEN                     CURRENT ROW AND UNBOUNDED FOLLOWING) nt,     percent_rank() OVER (PARTITION BY depname ORDER BY enroll_date ROWS BETWEEN                          CURRENT ROW AND UNBOUNDED FOLLOWING) pr,     cume_dist() OVER (PARTITION BY depname ORDER BY enroll_date RANGE BETWEEN                       CURRENT ROW AND UNBOUNDED FOLLOWING) cd FROM empsalary;
/* Ensure WindowFuncs which cannot support their WindowClause's frameOptions */ /* being changed are untouched */ EXPLAIN (COSTS OFF, VERBOSE) SELECT     empno,     depname,     row_number() OVER (PARTITION BY depname ORDER BY enroll_date) rn,     rank() OVER (PARTITION BY depname ORDER BY enroll_date ROWS BETWEEN                  UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) rnk,     count(*) OVER (PARTITION BY depname ORDER BY enroll_date RANGE BETWEEN                    CURRENT ROW AND CURRENT ROW) cnt FROM empsalary;
/* Ensure the above query gives us the expected results */ SELECT x, x, ROW_NUMBER() OVER (PARTITION BY x ORDER BY x NULLS LAST) AS x, RANK() OVER (PARTITION BY x ORDER BY x NULLS LAST ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS x, COUNT(*) OVER (PARTITION BY x ORDER BY x NULLS LAST RANGE BETWEEN CURRENT ROW AND CURRENT ROW) AS x FROM x;
/* Test pushdown of quals into a subquery containing window functions */ /* pushdown is safe because all PARTITION BY clauses include depname: */ EXPLAIN (COSTS OFF) SELECT * FROM   (SELECT depname,           sum(salary) OVER (PARTITION BY depname) depsalary,           min(salary) OVER (PARTITION BY depname || 'A', depname) depminsalary    FROM empsalary) emp WHERE depname = 'sales';
/* pushdown is unsafe because there's a PARTITION BY clause without depname: */ EXPLAIN (COSTS OFF) SELECT * FROM   (SELECT depname,           sum(salary) OVER (PARTITION BY enroll_date) enroll_salary,           min(salary) OVER (PARTITION BY depname) depminsalary    FROM empsalary) emp WHERE depname = 'sales';
/* Test window function run conditions are properly pushed down into the */ /* WindowAgg */ EXPLAIN (COSTS OFF) SELECT * FROM   (SELECT empno,           row_number() OVER (ORDER BY empno) rn    FROM empsalary) emp WHERE rn < 3;
/* The following 3 statements should result the same result. */ SELECT * FROM (SELECT x, ROW_NUMBER() OVER (ORDER BY x NULLS LAST) AS x FROM x) AS x WHERE x < 3;
SELECT * FROM (SELECT x, ROW_NUMBER() OVER (ORDER BY x NULLS LAST) AS x FROM x) AS x WHERE 3 > x;
SELECT * FROM (SELECT x, ROW_NUMBER() OVER (ORDER BY x NULLS LAST) AS x FROM x) AS x WHERE 2 >= x;
/* Ensure r <= 3 is pushed down into the run condition of the window agg */ EXPLAIN (COSTS OFF) SELECT * FROM   (SELECT empno,           salary,           rank() OVER (ORDER BY salary DESC) r    FROM empsalary) emp WHERE r <= 3;
SELECT * FROM (SELECT x, x, RANK() OVER (ORDER BY x DESC NULLS FIRST) AS x FROM x) AS x WHERE x <= 3;
/* Ensure dr = 1 is converted to dr <= 1 to get all rows leading up to dr = 1 */ EXPLAIN (COSTS OFF) SELECT * FROM   (SELECT empno,           salary,           dense_rank() OVER (ORDER BY salary DESC) dr    FROM empsalary) emp WHERE dr = 1;
SELECT * FROM (SELECT x, x, DENSE_RANK() OVER (ORDER BY x DESC NULLS FIRST) AS x FROM x) AS x WHERE x = 1;
/* Check COUNT() and COUNT(*) */ EXPLAIN (COSTS OFF) SELECT * FROM   (SELECT empno,           salary,           count(*) OVER (ORDER BY salary DESC) c    FROM empsalary) emp WHERE c <= 3;
SELECT * FROM (SELECT x, x, COUNT(*) OVER (ORDER BY x DESC NULLS FIRST) AS x FROM x) AS x WHERE x <= 3;
EXPLAIN (COSTS OFF) SELECT * FROM   (SELECT empno,           salary,           count(empno) OVER (ORDER BY salary DESC) c    FROM empsalary) emp WHERE c <= 3;
SELECT * FROM (SELECT x, x, COUNT(x) OVER (ORDER BY x DESC NULLS FIRST) AS x FROM x) AS x WHERE x <= 3;
EXPLAIN (COSTS OFF) SELECT * FROM   (SELECT empno,           salary,           count(*) OVER (ORDER BY salary DESC ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING) c    FROM empsalary) emp WHERE c >= 3;
EXPLAIN (COSTS OFF) SELECT * FROM   (SELECT empno,           salary,           count(*) OVER () c    FROM empsalary) emp WHERE 11 <= c;
EXPLAIN (COSTS OFF) SELECT * FROM   (SELECT empno,           salary,           count(*) OVER (ORDER BY salary DESC) c,           dense_rank() OVER (ORDER BY salary DESC) dr    FROM empsalary) emp WHERE dr = 1;
/* Ensure we get a run condition when there's a PARTITION BY clause */ EXPLAIN (COSTS OFF) SELECT * FROM   (SELECT empno,           depname,           row_number() OVER (PARTITION BY depname ORDER BY empno) rn    FROM empsalary) emp WHERE rn < 3;
/* and ensure we get the correct results from the above plan */ SELECT * FROM (SELECT x, x, ROW_NUMBER() OVER (PARTITION BY x ORDER BY x NULLS LAST) AS x FROM x) AS x WHERE x < 3;
/* ensure that "unused" subquery columns are not removed when the column only */ /* exists in the run condition */ EXPLAIN (COSTS OFF) SELECT empno, depname FROM   (SELECT empno,           depname,           row_number() OVER (PARTITION BY depname ORDER BY empno) rn    FROM empsalary) emp WHERE rn < 3;
/* likewise with count(empno) instead of row_number() */ EXPLAIN (COSTS OFF) SELECT * FROM   (SELECT empno,           depname,           salary,           count(empno) OVER (PARTITION BY depname ORDER BY salary DESC) c    FROM empsalary) emp WHERE c <= 3;
/* and again, check the results are what we expect. */ SELECT * FROM (SELECT x, x, x, COUNT(x) OVER (PARTITION BY x ORDER BY x DESC NULLS FIRST) AS x FROM x) AS x WHERE x <= 3;
/* Ensure we get the correct run condition when the window function is both */ /* monotonically increasing and decreasing. */ EXPLAIN (COSTS OFF) SELECT * FROM   (SELECT empno,           depname,           salary,           count(empno) OVER () c    FROM empsalary) emp WHERE c = 1;
/* Try another case with a WindowFunc with a byref return type */ SELECT * FROM (SELECT ROW_NUMBER() OVER (PARTITION BY x) AS x, LEAD(x) OVER (PARTITION BY x) || ' Department' AS x FROM x) AS x WHERE x < 1;
/* Some more complex cases with multiple window clauses */ EXPLAIN (COSTS OFF) SELECT * FROM   (SELECT *,           count(salary) OVER (PARTITION BY depname || '') c1, -- w1           row_number() OVER (PARTITION BY depname) rn, -- w2           count(*) OVER (PARTITION BY depname) c2, -- w2           count(*) OVER (PARTITION BY '' || depname) c3, -- w3           ntile(2) OVER (PARTITION BY depname) nt -- w2    FROM empsalary ) e WHERE rn <= 1 AND c1 <= 3 AND nt < 2;
/* Ensure we correctly filter out all of the run conditions from each window */ SELECT * FROM (SELECT *, COUNT(x) OVER (PARTITION BY x || '') AS x /* w1 */, ROW_NUMBER() OVER (PARTITION BY x) AS x /* w2 */, COUNT(*) OVER (PARTITION BY x) AS x /* w2 */, COUNT(*) OVER (PARTITION BY '' || x) AS x /* w3 */, NTILE(2) OVER (PARTITION BY x) AS x /* w2 */ FROM x) AS x WHERE x <= 1 AND x <= 3 AND x < 2;
/* Ensure we remove references to reduced outer joins as nulling rels in run */ /* conditions */ EXPLAIN (COSTS OFF) SELECT 1 FROM   (SELECT ntile(e2.salary) OVER (PARTITION BY e1.depname) AS c    FROM empsalary e1 LEFT JOIN empsalary e2 ON TRUE    WHERE e1.empno = e2.empno) s WHERE s.c = 1;
/* Ensure the run condition optimization is used in cases where the WindowFunc */ /* has a Var from another query level */ EXPLAIN (COSTS OFF) SELECT 1 FROM   (SELECT ntile(s1.x) OVER () AS c    FROM (SELECT (SELECT 1) AS x) AS s1) s WHERE s.c = 1;
/* Tests to ensure we don't push down the run condition when it's not valid to */ /* do so. */ /* Ensure we don't push down when the frame options show that the window */ /* function is not monotonically increasing */ EXPLAIN (COSTS OFF) SELECT * FROM   (SELECT empno,           salary,           count(*) OVER (ORDER BY salary DESC ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING) c    FROM empsalary) emp WHERE c <= 3;
/* Ensure we don't push down when the window function's monotonic properties */ /* don't match that of the clauses. */ EXPLAIN (COSTS OFF) SELECT * FROM   (SELECT empno,           salary,           count(*) OVER (ORDER BY salary) c    FROM empsalary) emp WHERE 3 <= c;
/* Ensure we don't use a run condition when there's a volatile function in the */ /* WindowFunc */ EXPLAIN (COSTS OFF) SELECT * FROM   (SELECT empno,           salary,           count(random()) OVER (ORDER BY empno DESC) c    FROM empsalary) emp WHERE c = 1;
/* Ensure we don't use a run condition when the WindowFunc contains subplans */ EXPLAIN (COSTS OFF) SELECT * FROM   (SELECT empno,           salary,           count((SELECT 1)) OVER (ORDER BY empno DESC) c    FROM empsalary) emp WHERE c = 1;
/* Test Sort node collapsing */ EXPLAIN (COSTS OFF) SELECT * FROM   (SELECT depname,           sum(salary) OVER (PARTITION BY depname order by empno) depsalary,           min(salary) OVER (PARTITION BY depname, empno order by enroll_date) depminsalary    FROM empsalary) emp WHERE depname = 'sales';
/* Ensure that the evaluation order of the WindowAggs results in the WindowAgg */ /* with the same sort order that's required by the ORDER BY is evaluated last. */ EXPLAIN (COSTS OFF) SELECT empno,        enroll_date,        depname,        sum(salary) OVER (PARTITION BY depname order by empno) depsalary,        min(salary) OVER (PARTITION BY depname order by enroll_date) depminsalary FROM empsalary ORDER BY depname, empno;
/* As above, but with an adjusted ORDER BY to ensure the above plan didn't */ /* perform only 2 sorts by accident. */ EXPLAIN (COSTS OFF) SELECT empno,        enroll_date,        depname,        sum(salary) OVER (PARTITION BY depname order by empno) depsalary,        min(salary) OVER (PARTITION BY depname order by enroll_date) depminsalary FROM empsalary ORDER BY depname, enroll_date;
SET x = off;
/* Ensure we don't get a sort for both DISTINCT and ORDER BY.  We expect the */ /* sort for the DISTINCT to provide presorted input for the ORDER BY. */ EXPLAIN (COSTS OFF) SELECT DISTINCT        empno,        enroll_date,        depname,        sum(salary) OVER (PARTITION BY depname order by empno) depsalary,        min(salary) OVER (PARTITION BY depname order by enroll_date) depminsalary FROM empsalary ORDER BY depname, enroll_date;
/* As above but adjust the ORDER BY clause to help ensure the plan with the */ /* minimum amount of sorting wasn't a fluke. */ EXPLAIN (COSTS OFF) SELECT DISTINCT        empno,        enroll_date,        depname,        sum(salary) OVER (PARTITION BY depname order by empno) depsalary,        min(salary) OVER (PARTITION BY depname order by enroll_date) depminsalary FROM empsalary ORDER BY depname, empno;
RESET enable_hashagg;
/* Test Sort node reordering */ EXPLAIN (COSTS OFF) SELECT   lead(1) OVER (PARTITION BY depname ORDER BY salary, enroll_date),   lag(1) OVER (PARTITION BY depname ORDER BY salary,enroll_date,empno) FROM empsalary;
/* Test incremental sorting */ EXPLAIN (COSTS OFF) SELECT * FROM   (SELECT depname,           empno,           salary,           enroll_date,           row_number() OVER (PARTITION BY depname ORDER BY enroll_date) AS first_emp,           row_number() OVER (PARTITION BY depname ORDER BY enroll_date DESC) AS last_emp    FROM empsalary) emp WHERE first_emp = 1 OR last_emp = 1;
SELECT * FROM (SELECT x, x, x, x, ROW_NUMBER() OVER (PARTITION BY x ORDER BY x NULLS LAST) AS x, ROW_NUMBER() OVER (PARTITION BY x ORDER BY x DESC NULLS FIRST) AS x FROM x) AS x WHERE x = 1 OR x = 1;
/* cleanup */ DROP TABLE x;
SELECT NTH_VALUE_DEF(x := 2, x := x) OVER (PARTITION BY x), x, x FROM (SELECT * FROM x WHERE x < 10 ORDER BY x NULLS LAST, x NULLS LAST) AS x;
SELECT NTH_VALUE_DEF(x) OVER (PARTITION BY x), x, x FROM (SELECT * FROM x WHERE x < 10 ORDER BY x NULLS LAST, x NULLS LAST) AS x;
/* Test the basic moving-aggregate machinery */ /* create aggregates that record the series of transform calls (these are */ /* intentionally not true inverses) */ CREATE FUNCTION x(x, x) RETURNS TEXT LANGUAGE SQL IMMUTABLE AS $$ SELECT COALESCE($1, '') || '*' || quote_nullable($2) $$;
CREATE FUNCTION x(x, x) RETURNS TEXT LANGUAGE SQL IMMUTABLE AS $$ SELECT COALESCE($1, '') || '+' || quote_nullable($2) $$;
CREATE FUNCTION x(x, x) RETURNS TEXT LANGUAGE SQL IMMUTABLE AS $$ SELECT $1 || '-' || quote_nullable($2) $$;
CREATE AGGREGATE logging_agg_nonstrict (anyelement) ( 	stype = text, 	sfunc = logging_sfunc_nonstrict, 	mstype = text, 	msfunc = logging_msfunc_nonstrict, 	minvfunc = logging_minvfunc_nonstrict );
CREATE AGGREGATE logging_agg_nonstrict_initcond (anyelement) ( 	stype = text, 	sfunc = logging_sfunc_nonstrict, 	mstype = text, 	msfunc = logging_msfunc_nonstrict, 	minvfunc = logging_minvfunc_nonstrict, 	initcond = 'I', 	minitcond = 'MI' );
CREATE FUNCTION x(x, x) RETURNS TEXT LANGUAGE SQL STRICT IMMUTABLE AS $$ SELECT $1 || '*' || quote_nullable($2) $$;
CREATE FUNCTION x(x, x) RETURNS TEXT LANGUAGE SQL STRICT IMMUTABLE AS $$ SELECT $1 || '+' || quote_nullable($2) $$;
CREATE FUNCTION x(x, x) RETURNS TEXT LANGUAGE SQL STRICT IMMUTABLE AS $$ SELECT $1 || '-' || quote_nullable($2) $$;
CREATE AGGREGATE logging_agg_strict (text) ( 	stype = text, 	sfunc = logging_sfunc_strict, 	mstype = text, 	msfunc = logging_msfunc_strict, 	minvfunc = logging_minvfunc_strict );
CREATE AGGREGATE logging_agg_strict_initcond (anyelement) ( 	stype = text, 	sfunc = logging_sfunc_strict, 	mstype = text, 	msfunc = logging_msfunc_strict, 	minvfunc = logging_minvfunc_strict, 	initcond = 'I', 	minitcond = 'MI' );
/* test strict and non-strict cases */ SELECT CAST(x AS TEXT) || ',' || CAST(x AS TEXT) || ':' || COALESCE(CAST(x AS TEXT), 'NULL') AS x, LOGGING_AGG_NONSTRICT(x) OVER x AS x, LOGGING_AGG_NONSTRICT_INITCOND(x) OVER x AS x, LOGGING_AGG_STRICT(CAST(x AS TEXT)) OVER x AS x, LOGGING_AGG_STRICT_INITCOND(x) OVER x AS x FROM (VALUES (1, 1, NULL), (1, 2, 'a'), (1, 3, 'b'), (1, 4, NULL), (1, 5, NULL), (1, 6, 'c'), (2, 1, NULL), (2, 2, 'x'), (3, 1, 'z')) AS x WINDOW x AS (PARTITION BY x ORDER BY x NULLS LAST ROWS BETWEEN 1 PRECEDING AND CURRENT ROW) ORDER BY x NULLS LAST, x NULLS LAST;
/* and again, but with filter */ SELECT CAST(x AS TEXT) || ',' || CAST(x AS TEXT) || ':' || CASE WHEN x THEN COALESCE(CAST(x AS TEXT), 'NULL') ELSE '-' END AS x, LOGGING_AGG_NONSTRICT(x) FILTER(WHERE x) OVER x AS x, LOGGING_AGG_NONSTRICT_INITCOND(x) FILTER(WHERE x) OVER x AS x, LOGGING_AGG_STRICT(CAST(x AS TEXT)) FILTER(WHERE x) OVER x AS x, LOGGING_AGG_STRICT_INITCOND(x) FILTER(WHERE x) OVER x AS x FROM (VALUES (1, 1, TRUE, NULL), (1, 2, FALSE, 'a'), (1, 3, TRUE, 'b'), (1, 4, FALSE, NULL), (1, 5, FALSE, NULL), (1, 6, FALSE, 'c'), (2, 1, FALSE, NULL), (2, 2, TRUE, 'x'), (3, 1, TRUE, 'z')) AS x WINDOW x AS (PARTITION BY x ORDER BY x NULLS LAST ROWS BETWEEN 1 PRECEDING AND CURRENT ROW) ORDER BY x NULLS LAST, x NULLS LAST;
/* test that volatile arguments disable moving-aggregate mode */ SELECT CAST(x AS TEXT) || ':' || COALESCE(CAST(x AS TEXT), 'NULL') AS x, LOGGING_AGG_STRICT(CAST(x AS TEXT)) OVER x AS x, LOGGING_AGG_STRICT(CAST(x AS TEXT) || CASE WHEN RAND() < 0 THEN '?' ELSE '' END) OVER x AS x FROM (VALUES (1, 'a'), (2, 'b'), (3, 'c')) AS x WINDOW x AS (ORDER BY x NULLS LAST ROWS BETWEEN 1 PRECEDING AND CURRENT ROW) ORDER BY x NULLS LAST;
SELECT CAST(x AS TEXT) || ':' || COALESCE(CAST(x AS TEXT), 'NULL') AS x, LOGGING_AGG_STRICT(CAST(x AS TEXT)) FILTER(WHERE TRUE) OVER x AS x, LOGGING_AGG_STRICT(CAST(x AS TEXT)) FILTER(WHERE RAND() >= 0) OVER x AS x FROM (VALUES (1, 'a'), (2, 'b'), (3, 'c')) AS x WINDOW x AS (ORDER BY x NULLS LAST ROWS BETWEEN 1 PRECEDING AND CURRENT ROW) ORDER BY x NULLS LAST;
/* test that non-overlapping windows don't use inverse transitions */ SELECT LOGGING_AGG_STRICT(CAST(x AS TEXT)) OVER x FROM (VALUES (1, 'a'), (2, 'b'), (3, 'c')) AS x WINDOW x AS (ORDER BY x NULLS LAST ROWS BETWEEN CURRENT ROW AND CURRENT ROW) ORDER BY x NULLS LAST;
/* test that returning NULL from the inverse transition functions */ /* restarts the aggregation from scratch. The second aggregate is supposed */ /* to test cases where only some aggregates restart, the third one checks */ /* that one aggregate restarting doesn't cause others to restart. */ CREATE FUNCTION x(x, x) RETURNS INT LANGUAGE SQL STRICT AS $$ SELECT CASE WHEN random() < 0.2 THEN NULL ELSE $1 - $2 END $$;
CREATE AGGREGATE sum_int_randomrestart (int4) ( 	stype = int4, 	sfunc = int4pl, 	mstype = int4, 	msfunc = int4pl, 	minvfunc = sum_int_randrestart_minvfunc );
WITH x AS (SELECT x, CAST((RAND() * 100) AS INT) AS x FROM x AS x), x AS (SELECT x, SUM(x) OVER (ORDER BY x DESC NULLS FIRST ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS x FROM x) SELECT DISTINCT x.x = SUM_INT_RANDOMRESTART(x) OVER x AS x, -x.x = SUM_INT_RANDOMRESTART(-x) OVER x AS x, 100 * 3 + (x.x - 1) * 3 = LENGTH(LOGGING_AGG_NONSTRICT(CAST('' AS TEXT)) OVER x) AS x FROM x JOIN x ON x.x = x.x WINDOW x AS (ORDER BY x.x NULLS LAST ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING);
/* Test various built-in aggregates that have moving-aggregate support */ /* test inverse transition functions handle NULLs properly */ SELECT x, AVG(CAST(x AS BIGINT)) OVER (ORDER BY x NULLS LAST ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING) FROM (VALUES (1, 1), (2, 2), (3, NULL), (4, NULL)) AS x;
SELECT x, AVG(CAST(x AS INT)) OVER (ORDER BY x NULLS LAST ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING) FROM (VALUES (1, 1), (2, 2), (3, NULL), (4, NULL)) AS x;
SELECT x, AVG(CAST(x AS SMALLINT)) OVER (ORDER BY x NULLS LAST ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING) FROM (VALUES (1, 1), (2, 2), (3, NULL), (4, NULL)) AS x;
SELECT x, AVG(CAST(x AS DECIMAL)) OVER (ORDER BY x NULLS LAST ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING) FROM (VALUES (1, 1.5), (2, 2.5), (3, NULL), (4, NULL)) AS x;
SELECT x, AVG(CAST(x AS INTERVAL)) OVER (ORDER BY x NULLS LAST ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING) FROM (VALUES (1, '1 sec'), (2, '2 sec'), (3, NULL), (4, NULL)) AS x;
/* moving aggregates over infinite intervals */ SELECT x, AVG(x) OVER (ROWS BETWEEN CURRENT ROW AND 1 FOLLOWING) AS x, AVG(x) OVER (ROWS BETWEEN 1 PRECEDING AND CURRENT ROW) AS x, SUM(x) OVER (ROWS BETWEEN CURRENT ROW AND 1 FOLLOWING) AS x, SUM(x) OVER (ROWS BETWEEN 1 PRECEDING AND CURRENT ROW) AS x FROM (VALUES (CAST(NULL AS INTERVAL)), (CAST('infinity' AS INTERVAL)), ('-2147483648 days -2147483648 months -9223372036854775807 usecs') /* extreme interval value */, (CAST('-infinity' AS INTERVAL)), ('2147483647 days 2147483647 months 9223372036854775806 usecs') /* extreme interval value */, (CAST('infinity' AS INTERVAL)), (CAST('6 days' AS INTERVAL)), (CAST('7 days' AS INTERVAL)), (CAST(NULL AS INTERVAL)), (CAST('-infinity' AS INTERVAL))) AS x;
/* should fail. */ SELECT x, AVG(x) OVER (ROWS BETWEEN CURRENT ROW AND 2 FOLLOWING) FROM (VALUES (CAST(NULL AS INTERVAL)), (CAST('3 days' AS INTERVAL)), (CAST('infinity' AS TIMESTAMPTZ) - CURRENT_TIMESTAMP()), (CAST('6 days' AS INTERVAL)), (CAST('-infinity' AS INTERVAL))) AS x;
/* should fail. */ SELECT x, SUM(x) OVER (ROWS BETWEEN CURRENT ROW AND 2 FOLLOWING) FROM (VALUES (CAST(NULL AS INTERVAL)), (CAST('3 days' AS INTERVAL)), (CAST('infinity' AS TIMESTAMPTZ) - CURRENT_TIMESTAMP()), (CAST('6 days' AS INTERVAL)), (CAST('-infinity' AS INTERVAL))) AS x;
SELECT x, SUM(CAST(x AS SMALLINT)) OVER (ORDER BY x NULLS LAST ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING) FROM (VALUES (1, 1), (2, 2), (3, NULL), (4, NULL)) AS x;
SELECT x, SUM(CAST(x AS INT)) OVER (ORDER BY x NULLS LAST ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING) FROM (VALUES (1, 1), (2, 2), (3, NULL), (4, NULL)) AS x;
SELECT x, SUM(CAST(x AS BIGINT)) OVER (ORDER BY x NULLS LAST ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING) FROM (VALUES (1, 1), (2, 2), (3, NULL), (4, NULL)) AS x;
SELECT x, SUM(CAST(x AS MONEY)) OVER (ORDER BY x NULLS LAST ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING) FROM (VALUES (1, '1.10'), (2, '2.20'), (3, NULL), (4, NULL)) AS x;
SELECT x, SUM(CAST(x AS INTERVAL)) OVER (ORDER BY x NULLS LAST ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING) FROM (VALUES (1, '1 sec'), (2, '2 sec'), (3, NULL), (4, NULL)) AS x;
SELECT x, SUM(CAST(x AS DECIMAL)) OVER (ORDER BY x NULLS LAST ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING) FROM (VALUES (1, 1.1), (2, 2.2), (3, NULL), (4, NULL)) AS x;
SELECT SUM(CAST(x AS DECIMAL)) OVER (ORDER BY x NULLS LAST ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING) FROM (VALUES (1, 1.01), (2, 2), (3, 3)) AS x;
SELECT x, COUNT(x) OVER (ORDER BY x NULLS LAST ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING) FROM (VALUES (1, 1), (2, 2), (3, NULL), (4, NULL)) AS x;
SELECT x, COUNT(*) OVER (ORDER BY x NULLS LAST ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING) FROM (VALUES (1, 1), (2, 2), (3, NULL), (4, NULL)) AS x;
SELECT VARIANCE_POP(CAST(x AS BIGINT)) OVER (ORDER BY x NULLS LAST ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING) FROM (VALUES (1, 600), (2, 470), (3, 170), (4, 430), (5, 300)) AS x;
SELECT VARIANCE_POP(CAST(x AS INT)) OVER (ORDER BY x NULLS LAST ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING) FROM (VALUES (1, 600), (2, 470), (3, 170), (4, 430), (5, 300)) AS x;
SELECT VARIANCE_POP(CAST(x AS SMALLINT)) OVER (ORDER BY x NULLS LAST ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING) FROM (VALUES (1, 600), (2, 470), (3, 170), (4, 430), (5, 300)) AS x;
SELECT VARIANCE_POP(CAST(x AS DECIMAL)) OVER (ORDER BY x NULLS LAST ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING) FROM (VALUES (1, 600), (2, 470), (3, 170), (4, 430), (5, 300)) AS x;
SELECT VARIANCE(CAST(x AS BIGINT)) OVER (ORDER BY x NULLS LAST ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING) FROM (VALUES (1, 600), (2, 470), (3, 170), (4, 430), (5, 300)) AS x;
SELECT VARIANCE(CAST(x AS INT)) OVER (ORDER BY x NULLS LAST ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING) FROM (VALUES (1, 600), (2, 470), (3, 170), (4, 430), (5, 300)) AS x;
SELECT VARIANCE(CAST(x AS SMALLINT)) OVER (ORDER BY x NULLS LAST ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING) FROM (VALUES (1, 600), (2, 470), (3, 170), (4, 430), (5, 300)) AS x;
SELECT VARIANCE(CAST(x AS DECIMAL)) OVER (ORDER BY x NULLS LAST ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING) FROM (VALUES (1, 600), (2, 470), (3, 170), (4, 430), (5, 300)) AS x;
SELECT VARIANCE(CAST(x AS BIGINT)) OVER (ORDER BY x NULLS LAST ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING) FROM (VALUES (1, 600), (2, 470), (3, 170), (4, 430), (5, 300)) AS x;
SELECT VARIANCE(CAST(x AS INT)) OVER (ORDER BY x NULLS LAST ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING) FROM (VALUES (1, 600), (2, 470), (3, 170), (4, 430), (5, 300)) AS x;
SELECT VARIANCE(CAST(x AS SMALLINT)) OVER (ORDER BY x NULLS LAST ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING) FROM (VALUES (1, 600), (2, 470), (3, 170), (4, 430), (5, 300)) AS x;
SELECT VARIANCE(CAST(x AS DECIMAL)) OVER (ORDER BY x NULLS LAST ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING) FROM (VALUES (1, 600), (2, 470), (3, 170), (4, 430), (5, 300)) AS x;
SELECT STDDEV_POP(CAST(x AS BIGINT)) OVER (ORDER BY x NULLS LAST ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING) FROM (VALUES (1, NULL), (2, 600), (3, 470), (4, 170), (5, 430), (6, 300)) AS x;
SELECT STDDEV_POP(CAST(x AS INT)) OVER (ORDER BY x NULLS LAST ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING) FROM (VALUES (1, NULL), (2, 600), (3, 470), (4, 170), (5, 430), (6, 300)) AS x;
SELECT STDDEV_POP(CAST(x AS SMALLINT)) OVER (ORDER BY x NULLS LAST ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING) FROM (VALUES (1, NULL), (2, 600), (3, 470), (4, 170), (5, 430), (6, 300)) AS x;
SELECT STDDEV_POP(CAST(x AS DECIMAL)) OVER (ORDER BY x NULLS LAST ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING) FROM (VALUES (1, NULL), (2, 600), (3, 470), (4, 170), (5, 430), (6, 300)) AS x;
SELECT STDDEV_SAMP(CAST(x AS BIGINT)) OVER (ORDER BY x NULLS LAST ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING) FROM (VALUES (1, NULL), (2, 600), (3, 470), (4, 170), (5, 430), (6, 300)) AS x;
SELECT STDDEV_SAMP(CAST(x AS INT)) OVER (ORDER BY x NULLS LAST ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING) FROM (VALUES (1, NULL), (2, 600), (3, 470), (4, 170), (5, 430), (6, 300)) AS x;
SELECT STDDEV_SAMP(CAST(x AS SMALLINT)) OVER (ORDER BY x NULLS LAST ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING) FROM (VALUES (1, NULL), (2, 600), (3, 470), (4, 170), (5, 430), (6, 300)) AS x;
SELECT STDDEV_SAMP(CAST(x AS DECIMAL)) OVER (ORDER BY x NULLS LAST ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING) FROM (VALUES (1, NULL), (2, 600), (3, 470), (4, 170), (5, 430), (6, 300)) AS x;
SELECT STDDEV(CAST(x AS BIGINT)) OVER (ORDER BY x NULLS LAST ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING) FROM (VALUES (0, NULL), (1, 600), (2, 470), (3, 170), (4, 430), (5, 300)) AS x;
SELECT STDDEV(CAST(x AS INT)) OVER (ORDER BY x NULLS LAST ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING) FROM (VALUES (0, NULL), (1, 600), (2, 470), (3, 170), (4, 430), (5, 300)) AS x;
SELECT STDDEV(CAST(x AS SMALLINT)) OVER (ORDER BY x NULLS LAST ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING) FROM (VALUES (0, NULL), (1, 600), (2, 470), (3, 170), (4, 430), (5, 300)) AS x;
SELECT STDDEV(CAST(x AS DECIMAL)) OVER (ORDER BY x NULLS LAST ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING) FROM (VALUES (0, NULL), (1, 600), (2, 470), (3, 170), (4, 430), (5, 300)) AS x;
/* test that inverse transition functions work with various frame options */ SELECT x, SUM(CAST(x AS INT)) OVER (ORDER BY x NULLS LAST ROWS BETWEEN CURRENT ROW AND CURRENT ROW) FROM (VALUES (1, 1), (2, 2), (3, NULL), (4, NULL)) AS x;
SELECT x, SUM(CAST(x AS INT)) OVER (ORDER BY x NULLS LAST ROWS BETWEEN CURRENT ROW AND 1 FOLLOWING) FROM (VALUES (1, 1), (2, 2), (3, NULL), (4, NULL)) AS x;
SELECT x, SUM(CAST(x AS INT)) OVER (ORDER BY x NULLS LAST ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING) FROM (VALUES (1, 1), (2, 2), (3, 3), (4, 4)) AS x;
/* ensure aggregate over numeric properly recovers from NaN values */ SELECT x, x, SUM(x) OVER (ORDER BY x NULLS LAST ROWS BETWEEN 1 PRECEDING AND CURRENT ROW) FROM (VALUES (1, CAST(1 AS DECIMAL)), (2, 2), (3, 'NaN'), (4, 3), (5, 4)) AS x;
/* It might be tempting for someone to add an inverse trans function for */ /* float and double precision. This should not be done as it can give incorrect */ /* results. This test should fail if anyone ever does this without thinking too */ /* hard about it. */ SELECT TIME_TO_STR(SUM(CAST(x AS DOUBLE)) OVER (ORDER BY x NULLS LAST ROWS BETWEEN CURRENT ROW AND 1 FOLLOWING), '999999999999999999999%u9') FROM (VALUES (1, 1e20), (2, 1)) AS x;
SELECT x, x, LOGICAL_AND(x) OVER x, LOGICAL_OR(x) OVER x FROM (VALUES (1, TRUE), (2, TRUE), (3, FALSE), (4, FALSE), (5, TRUE)) AS x WINDOW x AS (ORDER BY x NULLS LAST ROWS BETWEEN CURRENT ROW AND 1 FOLLOWING);
/* Test WindowAgg costing takes into account the number of rows that need to */ /* be fetched before the first row can be output. */ /* Ensure we get a cheap start up plan as the WindowAgg can output the first */ /* row after reading 1 row from the join. */ EXPLAIN (COSTS OFF) SELECT COUNT(*) OVER (ORDER BY t1.unique1) FROM tenk1 t1 INNER JOIN tenk1 t2 ON t1.unique1 = t2.tenthous LIMIT 1;
/* Ensure we get a cheap total plan.  Lack of ORDER BY in the WindowClause */ /* means that all rows must be read from the join, so a cheap startup plan */ /* isn't a good choice. */ EXPLAIN (COSTS OFF) SELECT COUNT(*) OVER () FROM tenk1 t1 INNER JOIN tenk1 t2 ON t1.unique1 = t2.tenthous WHERE t2.two = 1 LIMIT 1;
/* Ensure we get a cheap total plan.  This time use UNBOUNDED FOLLOWING, which */ /* needs to read all join rows to output the first WindowAgg row. */ EXPLAIN (COSTS OFF) SELECT COUNT(*) OVER (ORDER BY t1.unique1 ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) FROM tenk1 t1 INNER JOIN tenk1 t2 ON t1.unique1 = t2.tenthous LIMIT 1;
/* Ensure we get a cheap total plan.  This time use 10000 FOLLOWING so we need */ /* to read all join rows. */ EXPLAIN (COSTS OFF) SELECT COUNT(*) OVER (ORDER BY t1.unique1 ROWS BETWEEN UNBOUNDED PRECEDING AND 10000 FOLLOWING) FROM tenk1 t1 INNER JOIN tenk1 t2 ON t1.unique1 = t2.tenthous LIMIT 1;
/* Tests for problems with failure to walk or mutate expressions */ /* within window frame clauses. */ /* test walker (fails with collation error if expressions are not walked) */ SELECT ARRAY_AGG(x) OVER x FROM x AS x WINDOW x AS (ORDER BY x NULLS LAST ROWS BETWEEN (CAST(('foo' < 'foobar') AS INT)) PRECEDING AND CURRENT ROW);
EXPLAIN (costs off) SELECT * FROM pg_temp.f(2);
SELECT * FROM x.x;
/* Tests for common table expressions (WITH query, ... SELECT ...) */ /* Basic WITH */ WITH x AS (SELECT 1, 2) SELECT * FROM x, x AS x;
/* Multiple uses are evaluated only once */ SELECT COUNT(*) FROM (WITH x AS (SELECT RAND() FROM x) SELECT * FROM x UNION SELECT * FROM x) AS x;
/* WITH RECURSIVE */ /* sum of 1..100 */ WITH RECURSIVE x AS (VALUES (1) UNION ALL SELECT x + 1 FROM x WHERE x < 100) SELECT SUM(x) FROM x;
WITH RECURSIVE x AS (SELECT (VALUES (1)) UNION ALL SELECT x + 1 FROM x WHERE x < 5) SELECT * FROM x;
/* UNION DISTINCT requires hashable type */ WITH RECURSIVE x AS (VALUES (CAST('01' AS varbit)) UNION SELECT x || CAST('10' AS varbit) FROM x WHERE x < CAST('100' AS varbit)) SELECT x FROM x;
/* recursive view */ CREATE RECURSIVE VIEW nums (n) AS     VALUES (1) UNION ALL     SELECT n+1 FROM nums WHERE n < 5;
SELECT * FROM x;
CREATE OR REPLACE RECURSIVE VIEW nums (n) AS     VALUES (1) UNION ALL     SELECT n+1 FROM nums WHERE n < 6;
SELECT * FROM x;
/* This is an infinite loop with UNION ALL, but not with UNION */ WITH RECURSIVE x AS (SELECT 1 UNION SELECT 10 - x FROM x) SELECT * FROM x;
/* This'd be an infinite loop, but outside query reads only as much as needed */ WITH RECURSIVE x AS (VALUES (1) UNION ALL SELECT x + 1 FROM x) SELECT * FROM x LIMIT 10;
/* UNION case should have same property */ WITH RECURSIVE x AS (SELECT 1 UNION SELECT x + 1 FROM x) SELECT * FROM x LIMIT 10;
/* Test behavior with an unknown-type literal in the WITH */ WITH x AS (SELECT 'foo' AS x) SELECT x, PG_TYPEOF(x) FROM x;
WITH RECURSIVE x AS (SELECT 'foo' UNION ALL SELECT x || ' bar' FROM x WHERE LENGTH(x) < 20) SELECT x, PG_TYPEOF(x) FROM x;
/* In a perfect world, this would work and resolve the literal as int ... */ /* but for now, we have to be content with resolving to text too soon. */ WITH RECURSIVE x AS (SELECT '7' UNION ALL SELECT x + 1 FROM x WHERE x < 10) SELECT x, PG_TYPEOF(x) FROM x;
/* Deeply nested WITH caused a list-munging problem in v13 */ /* Detection of cross-references and self-references */ WITH RECURSIVE x AS (WITH x AS (WITH x AS (WITH x AS (WITH x AS (WITH RECURSIVE x AS (WITH x AS (WITH x AS (SELECT 1) SELECT * FROM x) SELECT * FROM x) SELECT * FROM x) SELECT * FROM x) SELECT * FROM x) SELECT * FROM x) SELECT * FROM x) SELECT * FROM x;
/* Detection of invalid self-references */ WITH RECURSIVE x AS (SELECT 1 UNION (WITH x AS (SELECT 2 UNION (WITH x AS (SELECT 3 UNION (WITH x AS (SELECT 4 UNION (WITH x AS (SELECT 5 UNION (WITH x AS (SELECT 6 UNION (WITH x AS (SELECT 7) SELECT * FROM x)) SELECT * FROM x)) SELECT * FROM x)) SELECT * FROM x)) SELECT * FROM x)) SELECT * FROM x UNION SELECT * FROM x)) SELECT * FROM x ORDER BY 1 NULLS LAST;
/* Some examples with a tree */ /* department structure represented here is as follows: */ /* ROOT-+->A-+->B-+->C */ /*      |         | */ /*      |         +->D-+->F */ /*      +->E-+->G */ CREATE TEMPORARY TABLE x (x INT PRIMARY KEY /* department ID */, x INT REFERENCES x /* upper department ID */, x TEXT /* department name */);
INSERT INTO x VALUES (0, NULL, 'ROOT');
INSERT INTO x VALUES (1, 0, 'A');
INSERT INTO x VALUES (2, 1, 'B');
INSERT INTO x VALUES (3, 2, 'C');
INSERT INTO x VALUES (4, 2, 'D');
INSERT INTO x VALUES (5, 0, 'E');
INSERT INTO x VALUES (6, 4, 'F');
INSERT INTO x VALUES (7, 5, 'G');
/* extract all departments under 'A'. Result should be A, B, C, D and F */ WITH RECURSIVE x AS (/* non recursive term */ SELECT x AS x, * FROM x WHERE x = 'A' UNION ALL /* recursive term */ SELECT x.x, x.* FROM x AS x, x AS x WHERE x.x = x.x) SELECT * FROM x ORDER BY x NULLS LAST;
/* extract all departments under 'A' with "level" number */ WITH RECURSIVE x AS (/* non recursive term */ SELECT 1, * FROM x WHERE x = 'A' UNION ALL /* recursive term */ SELECT x.x + 1, x.* FROM x AS x, x AS x WHERE x.x = x.x) SELECT * FROM x ORDER BY x NULLS LAST;
/* extract all departments under 'A' with "level" number. */ /* Only shows level 2 or more */ WITH RECURSIVE x AS (/* non recursive term */ SELECT 1, * FROM x WHERE x = 'A' UNION ALL /* recursive term */ SELECT x.x + 1, x.* FROM x AS x, x AS x WHERE x.x = x.x) SELECT * FROM x WHERE x >= 2 ORDER BY x NULLS LAST;
/* "RECURSIVE" is ignored if the query has no self-reference */ WITH RECURSIVE x AS (/* note lack of recursive UNION structure */ SELECT * FROM x WHERE x = 'A') SELECT * FROM x ORDER BY x NULLS LAST;
/* exercise the deduplication code of a UNION with mixed input slot types */ WITH RECURSIVE x AS (/* select all columns to prevent projection */ SELECT x, x, x FROM x WHERE x = 'A' UNION /* joins do projection */ SELECT x.x, x.x, x.x FROM x AS x INNER JOIN x AS x ON x.x = x.x) SELECT * FROM x ORDER BY x NULLS LAST;
/* inside subqueries */ SELECT COUNT(*) FROM (WITH RECURSIVE x AS (SELECT 1 UNION ALL SELECT x + 1 FROM x WHERE x < 500) SELECT * FROM x) AS x WHERE x < (SELECT COUNT(*) FROM (WITH RECURSIVE x AS (SELECT 1 UNION ALL SELECT x + 1 FROM x WHERE x < 100) SELECT * FROM x WHERE x < 50000) AS x WHERE x < 100);
/* use same CTE twice at different subquery levels */ WITH x AS (SELECT x, SUM(x) FROM x GROUP BY x) SELECT COUNT(*) FROM x WHERE x > (SELECT SUM(x) / 100 FROM x AS x);
/* via a VIEW */ CREATE TEMPORARY VIEW x AS WITH RECURSIVE x AS (/* non recursive term */ SELECT * FROM x WHERE x = 'A' UNION ALL /* recursive term */ SELECT x.* FROM x AS x, x AS x WHERE x.x = x.x) SELECT * FROM x;
SELECT * FROM x ORDER BY x NULLS LAST;
/* Check reverse listing */ SELECT PG_GET_VIEWDEF(CAST('vsubdepartment' AS REGCLASS));
SELECT PG_GET_VIEWDEF(CAST('vsubdepartment' AS REGCLASS), TRUE);
/* Another reverse-listing example */ CREATE VIEW x AS WITH RECURSIVE x AS (VALUES (1) UNION ALL SELECT x + 1 FROM x WHERE x < 100) SELECT SUM(x) FROM x;
WITH RECURSIVE x AS (SELECT * FROM x UNION ALL (WITH RECURSIVE x AS (SELECT * FROM x UNION ALL (SELECT * FROM x UNION ALL SELECT * FROM x)) SELECT * FROM x)) SELECT * FROM x LIMIT 32;
/* recursive term has sub-UNION */ WITH RECURSIVE x AS (VALUES (1, 2) UNION ALL SELECT x.x, x.x + 1 FROM (SELECT 2 AS x UNION ALL SELECT 3 AS x) AS x JOIN x ON (x.x = x.x + 1)) SELECT * FROM x;
/* different tree example */ CREATE TEMPORARY TABLE x (x INT PRIMARY KEY, x INT REFERENCES x (x));
INSERT INTO x VALUES (1, NULL), (2, 1), (3, 1), (4, 2), (5, 2), (6, 2), (7, 3), (8, 3), (9, 4), (10, 4), (11, 7), (12, 7), (13, 7), (14, 9), (15, 11), (16, 11);
/* get all paths from "second level" nodes to leaf nodes */ WITH RECURSIVE x AS (VALUES (1, CAST(ARRAY() AS ARRAY<INT>)) UNION ALL SELECT x.x, x.x || x.x FROM x JOIN x ON (x.x = x.x)) SELECT x.*, x.* FROM x AS x JOIN x AS x ON (x.x[0] = x.x[0] AND ARRAY_UPPER(x.x, 1) = 1 AND ARRAY_UPPER(x.x, 1) > 1) ORDER BY x.x NULLS LAST, x.x NULLS LAST;
/* just count 'em */ WITH RECURSIVE x AS (VALUES (1, CAST(ARRAY() AS ARRAY<INT>)) UNION ALL SELECT x.x, x.x || x.x FROM x JOIN x ON (x.x = x.x)) SELECT x.x, COUNT(x.*) FROM x AS x JOIN x AS x ON (x.x[0] = x.x[0] AND ARRAY_UPPER(x.x, 1) = 1 AND ARRAY_UPPER(x.x, 1) > 1) GROUP BY x.x ORDER BY x.x NULLS LAST;
/* this variant tickled a whole-row-variable bug in 8.4devel */ WITH RECURSIVE x AS (VALUES (1, CAST(ARRAY() AS ARRAY<INT>)) UNION ALL SELECT x.x, x.x || x.x FROM x JOIN x ON (x.x = x.x)) SELECT x.x, x.x, x FROM x AS x JOIN x AS x ON (x.x = x.x);
CREATE TEMPORARY TABLE x (x INT NOT NULL);
INSERT INTO x VALUES (1), (1);
/* Try out a recursive UNION case where the non-recursive part's table slot */ /* uses TTSOpsBufferHeapTuple and contains duplicate rows. */ WITH RECURSIVE x AS (SELECT x FROM x UNION SELECT x FROM x) SELECT x FROM x;
/* test that column statistics from a materialized CTE are available */ /* to upper planner (otherwise, we'd get a stupider plan) */ EXPLAIN (costs off) with x as materialized (select unique1 from tenk1 b) select count(*) from tenk1 a   where unique1 in (select * from x);
EXPLAIN (costs off) with x as materialized (insert into tenk1 default values returning unique1) select count(*) from tenk1 a   where unique1 in (select * from x);
/* test that pathkeys from a materialized CTE are propagated up to the */ /* outer query */ EXPLAIN (costs off) with x as materialized (select unique1 from tenk1 b order by unique1) select count(*) from tenk1 a   where unique1 in (select * from x);
/* SEARCH clause */ CREATE TEMPORARY TABLE x (x INT, x INT, x TEXT);
INSERT INTO x VALUES (1, 2, 'arc 1 -> 2'), (1, 3, 'arc 1 -> 3'), (2, 3, 'arc 2 -> 3'), (1, 4, 'arc 1 -> 4'), (4, 5, 'arc 4 -> 5');
EXPLAIN (verbose, costs off) with recursive search_graph(f, t, label) as ( 	select * from graph0 g 	union all 	select g.* 	from graph0 g, search_graph sg 	where g.f = sg.t ) search depth first by f, t set seq select * from search_graph order by seq;
EXPLAIN (verbose, costs off) with recursive search_graph(f, t, label) as ( 	select * from graph0 g 	union all 	select g.* 	from graph0 g, search_graph sg 	where g.f = sg.t ) search breadth first by f, t set seq select * from search_graph order by seq;
/* a constant initial value causes issues for EXPLAIN */ EXPLAIN (verbose, costs off) with recursive test as (   select 1 as x   union all   select x + 1   from test ) search depth first by x set y select * from test limit 5;
EXPLAIN (verbose, costs off) with recursive test as (   select 1 as x   union all   select x + 1   from test ) search breadth first by x set y select * from test limit 5;
SELECT PG_GET_VIEWDEF('v_search');
SELECT * FROM x;
/* test cycle detection */ CREATE TEMPORARY TABLE x (x INT, x INT, x TEXT);
INSERT INTO x VALUES (1, 2, 'arc 1 -> 2'), (1, 3, 'arc 1 -> 3'), (2, 3, 'arc 2 -> 3'), (1, 4, 'arc 1 -> 4'), (4, 5, 'arc 4 -> 5'), (5, 1, 'arc 5 -> 1');
WITH RECURSIVE x AS (SELECT *, FALSE, ARRAY(ROW(x.x, x.x)) FROM x AS x UNION ALL SELECT x.*, ROW(x.x, x.x) = ANY(x), x || ROW(x.x, x.x) FROM x AS x, x AS x WHERE x.x = x.x AND NOT x) SELECT * FROM x;
/* UNION DISTINCT exercises row type hashing support */ WITH RECURSIVE x AS (SELECT *, FALSE, ARRAY(ROW(x.x, x.x)) FROM x AS x UNION SELECT x.*, ROW(x.x, x.x) = ANY(x), x || ROW(x.x, x.x) FROM x AS x, x AS x WHERE x.x = x.x AND NOT x) SELECT * FROM x;
/* ordering by the path column has same effect as SEARCH DEPTH FIRST */ WITH RECURSIVE x AS (SELECT *, FALSE, ARRAY(ROW(x.x, x.x)) FROM x AS x UNION ALL SELECT x.*, ROW(x.x, x.x) = ANY(x), x || ROW(x.x, x.x) FROM x AS x, x AS x WHERE x.x = x.x AND NOT x) SELECT * FROM x ORDER BY x NULLS LAST;
/* CYCLE clause */ EXPLAIN (verbose, costs off) with recursive search_graph(f, t, label) as ( 	select * from graph g 	union all 	select g.* 	from graph g, search_graph sg 	where g.f = sg.t ) cycle f, t set is_cycle using path select * from search_graph;
EXPLAIN (verbose, costs off) with recursive test as (   select 0 as x   union all   select (x + 1) % 10   from test ) cycle x set is_cycle using path select * from test;
SELECT PG_GET_VIEWDEF('v_cycle1');
SELECT PG_GET_VIEWDEF('v_cycle2');
SELECT * FROM x;
SELECT * FROM x;
/* test multiple WITH queries */ WITH RECURSIVE x AS (SELECT * FROM (VALUES (1)) AS x), x AS (SELECT * FROM x UNION ALL SELECT x + 1 FROM x WHERE x < 5) SELECT * FROM x;
/* forward reference OK */ WITH RECURSIVE x AS (SELECT * FROM x UNION ALL SELECT x + 1 FROM x WHERE x < 5), x AS (SELECT * FROM (VALUES (1)) AS x) SELECT * FROM x;
WITH RECURSIVE x AS (VALUES (1) UNION ALL SELECT x + 1 FROM x WHERE x < 5), x AS (VALUES (1) UNION ALL SELECT x + 1 FROM x WHERE x < 10) SELECT x.*, x.* FROM x LEFT JOIN x USING (x);
WITH RECURSIVE x AS (VALUES (1) UNION ALL SELECT x + 1 FROM x WHERE x < 5), x AS (VALUES (1) UNION ALL SELECT x + 1 FROM x WHERE x < 10) SELECT x.*, x.* FROM x LEFT JOIN x USING (x);
WITH RECURSIVE x AS (SELECT 1 UNION ALL SELECT x + 1 FROM x WHERE x < 3), x AS (SELECT * FROM x UNION ALL SELECT * FROM x), x AS (SELECT * FROM x UNION ALL SELECT x + 1 FROM x WHERE x < 10) SELECT * FROM x;
WITH RECURSIVE x AS (SELECT 1 UNION ALL SELECT x + 1 FROM x WHERE x < 3), x AS (SELECT * FROM x UNION ALL SELECT * FROM x), x AS (SELECT * FROM x UNION ALL SELECT x + 1 FROM x WHERE x < 10) SELECT * FROM x;
/* Test WITH attached to a data-modifying statement */ CREATE TEMPORARY TABLE x (x INT);
INSERT INTO x SELECT UNNEST(GENERATE_SERIES(1, 10));
WITH x AS (SELECT x FROM x) INSERT INTO x SELECT x + 20 FROM x RETURNING *;
SELECT * FROM x;
WITH x AS (SELECT x FROM x) UPDATE x SET x = x.x - 10 FROM x WHERE x.x > 20 AND x.x = x.x RETURNING x.x;
SELECT * FROM x;
WITH RECURSIVE x AS (SELECT 11 UNION ALL SELECT x + 1 FROM x WHERE x < 50) DELETE FROM x USING x WHERE x.x = x.x RETURNING x.x;
SELECT * FROM x;
DROP TABLE x;
/* error cases */ WITH x AS (SELECT 1) SELECT * FROM x;
/* INTERSECT */ WITH RECURSIVE x AS (SELECT 1 INTERSECT SELECT x + 1 FROM x) SELECT * FROM x;
WITH RECURSIVE x AS (SELECT 1 INTERSECT ALL SELECT x + 1 FROM x) SELECT * FROM x;
/* EXCEPT */ WITH RECURSIVE x AS (SELECT 1 EXCEPT SELECT x + 1 FROM x) SELECT * FROM x;
WITH RECURSIVE x AS (SELECT 1 EXCEPT ALL SELECT x + 1 FROM x) SELECT * FROM x;
/* no non-recursive term */ WITH RECURSIVE x AS (SELECT x FROM x) SELECT * FROM x;
/* recursive term in the left hand side (strictly speaking, should allow this) */ WITH RECURSIVE x AS (SELECT x FROM x UNION ALL SELECT 1) SELECT * FROM x;
/* allow this, because we historically have */ WITH RECURSIVE x AS (WITH x AS (SELECT 1 AS x) SELECT 0 UNION SELECT * FROM x) SELECT * FROM x;
/* but this should be rejected */ WITH RECURSIVE x AS (WITH x AS (SELECT 1 FROM x) SELECT 0 UNION SELECT * FROM x) SELECT * FROM x;
/* and this too */ WITH RECURSIVE x AS ((WITH x AS (SELECT 1 FROM x) SELECT * FROM x) UNION SELECT 0) SELECT * FROM x;
/* and this */ WITH RECURSIVE x AS (SELECT 0 UNION SELECT 1 ORDER BY (SELECT x FROM x) NULLS LAST) SELECT * FROM x;
CREATE TEMPORARY TABLE x (x INT);
INSERT INTO x SELECT UNNEST(GENERATE_SERIES(1, 10));
/* LEFT JOIN */ WITH RECURSIVE x AS (SELECT x FROM x WHERE x = 1 UNION ALL SELECT x.x + 1 FROM x LEFT JOIN x ON x.x = x.x WHERE x < 10) SELECT * FROM x;
/* RIGHT JOIN */ WITH RECURSIVE x AS (SELECT x FROM x WHERE x = 1 UNION ALL SELECT x.x + 1 FROM x RIGHT JOIN x ON x.x = x.x WHERE x < 10) SELECT * FROM x;
/* FULL JOIN */ WITH RECURSIVE x AS (SELECT x FROM x WHERE x = 1 UNION ALL SELECT x.x + 1 FROM x FULL JOIN x ON x.x = x.x WHERE x < 10) SELECT * FROM x;
/* subquery */ WITH RECURSIVE x AS (SELECT 1 UNION ALL SELECT x + 1 FROM x WHERE x IN (SELECT * FROM x)) SELECT * FROM x;
/* aggregate functions */ WITH RECURSIVE x AS (SELECT 1 UNION ALL SELECT COUNT(*) FROM x) SELECT * FROM x;
WITH RECURSIVE x AS (SELECT 1 UNION ALL SELECT SUM(x) FROM x) SELECT * FROM x;
/* ORDER BY */ WITH RECURSIVE x AS (SELECT 1 UNION ALL SELECT x + 1 FROM x ORDER BY 1 NULLS LAST) SELECT * FROM x;
/* LIMIT/OFFSET */ WITH RECURSIVE x AS (SELECT 1 UNION ALL SELECT x + 1 FROM x LIMIT 10 OFFSET 1) SELECT * FROM x;
/* FOR UPDATE */ WITH RECURSIVE x AS (SELECT 1 UNION ALL SELECT x + 1 FROM x) SELECT * FROM x;
/* target list has a recursive query name */ WITH RECURSIVE x AS (VALUES (1) UNION ALL SELECT (SELECT * FROM x) FROM x WHERE x < 5) SELECT * FROM x;
/* mutual recursive query (not implemented) */ WITH RECURSIVE x AS (SELECT 1 UNION ALL SELECT x + 1 FROM x WHERE x < 5), x AS (SELECT 1 UNION ALL SELECT x + 1 FROM x WHERE x < 5) SELECT * FROM x;
/* non-linear recursion is not allowed */ WITH RECURSIVE x AS (VALUES (1) UNION ALL (SELECT x + 1 FROM x WHERE x < 10 UNION ALL SELECT x + 1 FROM x WHERE x < 5)) SELECT * FROM x;
WITH RECURSIVE x AS (VALUES (1) UNION ALL SELECT * FROM (SELECT x + 1 FROM x WHERE x < 10 UNION ALL SELECT x + 1 FROM x WHERE x < 5) AS x) SELECT * FROM x;
WITH RECURSIVE x AS (VALUES (1) UNION ALL (SELECT x + 1 FROM x WHERE x < 10 EXCEPT SELECT x + 1 FROM x WHERE x < 5)) SELECT * FROM x;
WITH RECURSIVE x AS (VALUES (1) UNION ALL (SELECT x + 1 FROM x WHERE x < 10 INTERSECT SELECT x + 1 FROM x WHERE x < 5)) SELECT * FROM x;
/* Wrong type induced from non-recursive term */ WITH RECURSIVE x AS (SELECT x FROM (VALUES (1), (2)) AS x UNION ALL SELECT CAST((x + 1) AS DECIMAL(10, 0)) FROM x WHERE x < 10) SELECT * FROM x;
/* rejects different typmod, too (should we allow this?) */ WITH RECURSIVE x AS (SELECT CAST(x AS DECIMAL(3, 0)) FROM (VALUES (1), (2)) AS x UNION ALL SELECT CAST((x + 1) AS DECIMAL(10, 0)) FROM x WHERE x < 10) SELECT * FROM x;
/* disallow OLD/NEW reference in CTE */ CREATE TEMPORARY TABLE x (x INT);
CREATE RULE r2 AS ON UPDATE TO x DO INSTEAD     WITH t AS (SELECT OLD.*) UPDATE y SET a = t.n FROM t;
WITH x AS (SELECT 42) SELECT * FROM ((SELECT x FROM x)) AS x;
/* test CTE referencing an outer-level variable (to see that changed-parameter */ /* signaling still works properly after fixing this bug) */ SELECT (WITH x AS (SELECT * FROM (VALUES (x)) AS x) SELECT (SELECT x FROM x)) FROM x;
/* test for nested-recursive-WITH bug */ WITH RECURSIVE x AS (WITH RECURSIVE x AS (VALUES (1) UNION ALL SELECT x + 1 FROM x WHERE x < 10) SELECT x FROM x UNION ALL SELECT x + 1 FROM x WHERE x < 10) SELECT * FROM x;
/* test WITH attached to intermediate-level set operation */ WITH x AS (SELECT 1 UNION (WITH x AS (SELECT 2) SELECT * FROM x UNION SELECT 3)) SELECT * FROM x ORDER BY 1 NULLS LAST;
WITH x AS (SELECT 1 UNION (WITH x AS (SELECT 2) SELECT * FROM x /* fail */ UNION SELECT * FROM x)) SELECT * FROM x ORDER BY 1 NULLS LAST;
WITH RECURSIVE x AS (SELECT 1 UNION (WITH x AS (SELECT 2) SELECT * FROM x UNION SELECT * FROM x)) SELECT * FROM x ORDER BY 1 NULLS LAST;
WITH RECURSIVE x AS (WITH x /* fail */ AS (SELECT 2 FROM x) SELECT * FROM x UNION SELECT * FROM x) SELECT * FROM x ORDER BY 1 NULLS LAST;
/* This test will fail with the old implementation of PARAM_EXEC parameter */ /* assignment, because the "q1" Var passed down to A's targetlist subselect */ /* looks exactly like the "A.id" Var passed down to C's subselect, causing */ /* the old code to give them the same runtime PARAM_EXEC slot.  But the */ /* lifespans of the two parameters overlap, thanks to B also reading A. */ WITH x AS (SELECT x AS x, (SELECT x) AS x FROM x), x AS (SELECT x, ROW_NUMBER() OVER (PARTITION BY x) AS x FROM x), x AS (SELECT x.x, ARRAY(SELECT x.x FROM x WHERE x.x = x.x) FROM x) SELECT * FROM x;
/* Test CTEs read in non-initialization orders */ WITH RECURSIVE x AS (SELECT * FROM (VALUES (1, 17), (2, 17), (3, 17), (4, 17), (6, 17), (5, 17)) AS x), x AS (SELECT 0, 'base', 17 UNION ALL (WITH x AS (SELECT x.x, CAST('true' AS TEXT), x.x, MIN(x.x) OVER () FROM x INNER JOIN x USING (x) WHERE x.x > x.x), x AS (SELECT x, x, x FROM x WHERE x = x), x AS (SELECT x.x, CAST('new' AS TEXT), x.x FROM x AS x INNER JOIN x ON x.x = x.x WHERE x.x = 'false') SELECT * FROM x UNION ALL SELECT * FROM x)) SELECT * FROM x;
WITH RECURSIVE x AS (SELECT * FROM (VALUES (1, 17), (2, 17), (3, 17), (4, 17), (6, 17), (5, 17)) AS x), x AS (SELECT 0, 'base', 17 UNION (WITH x AS (SELECT x.x, CAST('true' AS TEXT), x.x, MIN(x.x) OVER () FROM x INNER JOIN x USING (x) WHERE x.x > x.x), x AS (SELECT x, x, x FROM x WHERE x = x), x AS (SELECT x.x, CAST('new' AS TEXT), x.x FROM x AS x INNER JOIN x ON x.x = x.x WHERE x.x = 'false') SELECT * FROM x UNION ALL SELECT * FROM x)) SELECT * FROM x;
/* Data-modifying statements in WITH */ /* INSERT ... RETURNING */ WITH x AS (INSERT INTO x VALUES (11), (12), (13), (14), (15), (16), (17), (18), (19), (20) RETURNING *) SELECT * FROM x;
SELECT * FROM x;
/* UPDATE ... RETURNING */ WITH x AS (UPDATE x SET x = x + 1 RETURNING *) SELECT * FROM x;
SELECT * FROM x;
/* DELETE ... RETURNING */ WITH x AS (DELETE FROM x WHERE x <= 10 RETURNING *) SELECT * FROM x;
SELECT * FROM x;
/* forward reference */ WITH RECURSIVE x AS (INSERT INTO x SELECT x + 5 FROM x WHERE x > 5 RETURNING *), x AS (UPDATE x SET x = x - 11 RETURNING *) SELECT * FROM x UNION ALL SELECT * FROM x;
SELECT * FROM x;
/* unconditional DO INSTEAD rule */ CREATE RULE y_rule AS ON DELETE TO y DO INSTEAD   INSERT INTO y VALUES(42) RETURNING *;
WITH x AS (DELETE FROM x RETURNING *) SELECT * FROM x;
SELECT * FROM x;
DROP RULE y_rule ON y;
/* check merging of outer CTE with CTE in a rule action */ CREATE TEMPORARY TABLE x AS SELECT x FROM x AS x;
SELECT * FROM x;
WITH x AS (DELETE FROM x RETURNING *) INSERT INTO x SELECT * FROM x;
SELECT * FROM x;
CREATE TEMPORARY TABLE x (x INT);
CREATE RULE bug6051_ins AS ON INSERT TO bug6051 DO INSTEAD  INSERT INTO bug6051_2  VALUES(NEW.i);
WITH x AS (DELETE FROM x RETURNING *) INSERT INTO x SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
/* check INSERT ... SELECT rule actions are disallowed on commands */ /* that have modifyingCTEs */ CREATE OR REPLACE RULE bug6051_ins AS ON INSERT TO bug6051 DO INSTEAD  INSERT INTO bug6051_2  SELECT NEW.i;
WITH x AS (DELETE FROM x RETURNING *) INSERT INTO x SELECT * FROM x;
/* silly example to verify that hasModifyingCTE flag is propagated */ CREATE TEMPORARY TABLE x AS SELECT x FROM x AS x;
CREATE RULE bug6051_3_ins AS ON INSERT TO bug6051_3 DO INSTEAD   SELECT i FROM bug6051_2;
BEGIN;
SET LOCAL x = on;
WITH x AS (DELETE FROM x RETURNING *) INSERT INTO x SELECT * FROM x;
COMMIT;
SELECT * FROM x;
/* check case where CTE reference is removed due to optimization */ EXPLAIN (VERBOSE, COSTS OFF) SELECT q1 FROM (   WITH t_cte AS (SELECT * FROM int8_tbl t)   SELECT q1, (SELECT q2 FROM t_cte WHERE t_cte.q1 = i8.q1) AS t_sub   FROM int8_tbl i8 ) ss;
SELECT x FROM (WITH x AS (SELECT * FROM x AS x) SELECT x, (SELECT x FROM x WHERE x.x = x.x) AS x FROM x AS x) AS x;
EXPLAIN (VERBOSE, COSTS OFF) SELECT q1 FROM (   WITH t_cte AS MATERIALIZED (SELECT * FROM int8_tbl t)   SELECT q1, (SELECT q2 FROM t_cte WHERE t_cte.q1 = i8.q1) AS t_sub   FROM int8_tbl i8 ) ss;
SELECT x FROM (WITH x AS MATERIALIZED (SELECT * FROM x AS x) SELECT x, (SELECT x FROM x WHERE x.x = x.x) AS x FROM x AS x) AS x;
/* a truly recursive CTE in the same list */ WITH RECURSIVE x AS (SELECT 0 UNION ALL SELECT x + 1 FROM x WHERE x + 1 < 5), x AS (INSERT INTO x SELECT * FROM x RETURNING *) SELECT * FROM x JOIN x USING (x) ORDER BY x NULLS LAST;
SELECT * FROM x;
/* data-modifying WITH in a modifying statement */ WITH x AS (DELETE FROM x WHERE x <= 10 RETURNING *) INSERT INTO x SELECT -x FROM x RETURNING *;
SELECT * FROM x;
/* check that WITH query is run to completion even if outer query isn't */ WITH x AS (UPDATE x SET x = x * 100 RETURNING *) SELECT * FROM x LIMIT 10;
SELECT * FROM x;
/* data-modifying WITH containing INSERT...ON CONFLICT DO UPDATE */ CREATE TABLE x AS SELECT x AS x, CAST((x || ' v') AS TEXT) AS x FROM x AS x;
ALTER TABLE x ADD UNIQUE (x);
WITH x AS (INSERT INTO x SELECT x, 'insert' FROM x AS x ON CONFLICT(x) DO UPDATE SET x = x.x || ', now update' RETURNING *) SELECT * FROM x JOIN x ON x.x = x.x ORDER BY x NULLS LAST, x NULLS LAST;
/* Test EXCLUDED.* reference within CTE */ WITH x AS (INSERT INTO x VALUES (1, 5) ON CONFLICT(x) DO UPDATE SET x = x.x WHERE x.x <> x.x RETURNING *) SELECT * FROM x;
/* New query/snapshot demonstrates side-effects of previous query. */ SELECT * FROM x ORDER BY x NULLS LAST;
/* Ensure subqueries within the update clause work, even if they */ /* reference outside values */ WITH x AS (SELECT 1 AS x, 2 AS x) INSERT INTO x VALUES (1, 'insert') ON CONFLICT(x) DO UPDATE SET x = (SELECT x || ' update' FROM x WHERE x = 1 LIMIT 1);
WITH x AS (SELECT 1 AS x, 2 AS x) INSERT INTO x VALUES (1, 'insert') ON CONFLICT(x) DO UPDATE SET x = ' update' WHERE x.x = (SELECT x FROM x);
WITH x AS (SELECT 1 AS x, 2 AS x) INSERT INTO x VALUES (1, 'insert') ON CONFLICT(x) DO UPDATE SET x = (SELECT x || ' update' FROM x WHERE x = 1 LIMIT 1);
WITH x AS (SELECT 'a' AS x, 'b' AS x UNION ALL SELECT 'a' AS x, 'b' AS x) INSERT INTO x VALUES (1, 'insert') ON CONFLICT(x) DO UPDATE SET x = (SELECT x || ' update' FROM x WHERE x = 'a' LIMIT 1);
WITH x AS (SELECT 1 AS x, 2 AS x) INSERT INTO x VALUES (1, (SELECT x || ' insert' FROM x WHERE x = 1)) ON CONFLICT(x) DO UPDATE SET x = (SELECT x || ' update' FROM x WHERE x = 1 LIMIT 1);
/* Update a row more than once, in different parts of a wCTE. That is */ /* an allowed, presumably very rare, edge case, but since it was */ /* broken in the past, having a test seems worthwhile. */ WITH x AS (SELECT 2 AS x, 'Green' AS x), x AS (INSERT INTO x VALUES (2, 'Blue') ON CONFLICT(x) DO UPDATE SET (x, x) = (SELECT x, x FROM x WHERE x.x = x.x) RETURNING x, x) INSERT INTO x VALUES (2, 'Red') ON CONFLICT(x) DO UPDATE SET (x, x) = (SELECT x, x FROM x WHERE x.x = x.x) RETURNING x, x;
DROP TABLE x;
/* WITH referenced by MERGE statement */ CREATE TABLE x AS SELECT x AS x, CAST((x || ' v') AS TEXT) AS x FROM x AS x;
ALTER TABLE x ADD UNIQUE (x);
WITH RECURSIVE x AS (SELECT 1 AS x, 'cte_basic val' AS x) MERGE INTO x USING (SELECT 0 AS x, 'merge source SubPlan' AS x) AS x ON x.x = x.x WHEN MATCHED THEN UPDATE SET x = (SELECT x || ' merge update' FROM x WHERE x.x = x.x LIMIT 1) WHEN NOT MATCHED THEN INSERT VALUES (x.x, x.x);
/* Basic: */ WITH x AS MATERIALIZED (SELECT 1 AS x, 'cte_basic val' AS x) MERGE INTO x USING (SELECT 0 AS x, 'merge source SubPlan' AS x OFFSET 0) AS x ON x.x = x.x WHEN MATCHED THEN UPDATE SET x = (SELECT x || ' merge update' FROM x WHERE x.x = x.x LIMIT 1) WHEN NOT MATCHED THEN INSERT VALUES (x.x, x.x);
/* Examine */ SELECT * FROM x WHERE x = 0;
/* See EXPLAIN output for same query: */ EXPLAIN (VERBOSE, COSTS OFF) WITH cte_basic AS MATERIALIZED (SELECT 1 a, 'cte_basic val' b) MERGE INTO m USING (select 0 k, 'merge source SubPlan' v offset 0) o ON m.k=o.k WHEN MATCHED THEN UPDATE SET v = (SELECT b || ' merge update' FROM cte_basic WHERE cte_basic.a = m.k LIMIT 1) WHEN NOT MATCHED THEN INSERT VALUES(o.k, o.v);
/* InitPlan */ WITH x AS MATERIALIZED (SELECT 1 AS x, 'cte_init val' AS x) MERGE INTO x USING (SELECT 1 AS x, 'merge source InitPlan' AS x OFFSET 0) AS x ON x.x = x.x WHEN MATCHED THEN UPDATE SET x = (SELECT x || ' merge update' FROM x WHERE x = 1 LIMIT 1) WHEN NOT MATCHED THEN INSERT VALUES (x.x, x.x);
/* Examine */ SELECT * FROM x WHERE x = 1;
/* See EXPLAIN output for same query: */ EXPLAIN (VERBOSE, COSTS OFF) WITH cte_init AS MATERIALIZED (SELECT 1 a, 'cte_init val' b) MERGE INTO m USING (select 1 k, 'merge source InitPlan' v offset 0) o ON m.k=o.k WHEN MATCHED THEN UPDATE SET v = (SELECT b || ' merge update' FROM cte_init WHERE a = 1 LIMIT 1) WHEN NOT MATCHED THEN INSERT VALUES(o.k, o.v);
/* MERGE source comes from CTE: */ WITH x AS MATERIALIZED (SELECT 15 AS x, 'merge_source_cte val' AS x) MERGE INTO x USING (SELECT * FROM x) AS x ON x.x = x.x WHEN MATCHED THEN UPDATE SET x = (SELECT x || CAST(x.* AS TEXT) || ' merge update' FROM x WHERE x = 15) WHEN NOT MATCHED THEN INSERT VALUES (x.x, x.x || (SELECT CAST(x.* AS TEXT) || ' merge insert' FROM x));
/* Examine */ SELECT * FROM x WHERE x = 15;
/* See EXPLAIN output for same query: */ EXPLAIN (VERBOSE, COSTS OFF) WITH merge_source_cte AS MATERIALIZED (SELECT 15 a, 'merge_source_cte val' b) MERGE INTO m USING (select * from merge_source_cte) o ON m.k=o.a WHEN MATCHED THEN UPDATE SET v = (SELECT b || merge_source_cte.*::text || ' merge update' FROM merge_source_cte WHERE a = 15) WHEN NOT MATCHED THEN INSERT VALUES(o.a, o.b || (SELECT merge_source_cte.*::text || ' merge insert' FROM merge_source_cte));
DROP TABLE x;
TRUNCATE TABLE x /* check that run to completion happens in proper ordering */;
INSERT INTO x SELECT UNNEST(GENERATE_SERIES(1, 3));
CREATE TEMPORARY TABLE x (x INT);
WITH RECURSIVE x AS (INSERT INTO x SELECT * FROM x RETURNING *), x AS (INSERT INTO x SELECT * FROM x RETURNING *) SELECT 1;
SELECT * FROM x;
SELECT * FROM x;
WITH RECURSIVE x AS (INSERT INTO x SELECT * FROM x RETURNING *), x AS (INSERT INTO x SELECT * FROM x RETURNING *) SELECT 1;
SELECT * FROM x;
SELECT * FROM x;
TRUNCATE TABLE x /* triggers */;
INSERT INTO x SELECT UNNEST(GENERATE_SERIES(1, 10));
x AS x;
COMMIT;
CREATE TRIGGER y_trig BEFORE INSERT ON y FOR EACH ROW     EXECUTE PROCEDURE y_trigger();
WITH x AS (INSERT INTO x VALUES (21), (22), (23) RETURNING *) SELECT * FROM x;
SELECT * FROM x;
DROP TRIGGER y_trig ON y;
CREATE TRIGGER y_trig AFTER INSERT ON y FOR EACH ROW     EXECUTE PROCEDURE y_trigger();
WITH x AS (INSERT INTO x VALUES (31), (32), (33) RETURNING *) SELECT * FROM x LIMIT 1;
SELECT * FROM x;
DROP TRIGGER y_trig ON y;
x AS x;
COMMIT;
CREATE TRIGGER y_trig AFTER INSERT ON y FOR EACH STATEMENT     EXECUTE PROCEDURE y_trigger();
WITH x AS (INSERT INTO x VALUES (41), (42), (43) RETURNING *) SELECT * FROM x;
SELECT * FROM x;
DROP TRIGGER y_trig ON y;
DROP FUNCTION x;
/* WITH attached to inherited UPDATE or DELETE */ CREATE TEMPORARY TABLE x (x INT, x TEXT);
CREATE TEMPORARY TABLE x INHERITS (x);
CREATE TEMPORARY TABLE x INHERITS (x);
INSERT INTO x VALUES (1, 'p1');
INSERT INTO x VALUES (11, 'c11'), (12, 'c12');
INSERT INTO x VALUES (23, 'c21'), (24, 'c22');
WITH x AS (SELECT SUM(x) AS x FROM x) UPDATE x SET x = x + x FROM x;
SELECT * FROM x;
WITH x AS (INSERT INTO x VALUES (42, 'new') RETURNING x AS x) UPDATE x SET x = x + x FROM x;
SELECT * FROM x;
WITH x AS (SELECT MAX(x) AS x FROM x) DELETE FROM x USING x WHERE x = x;
SELECT * FROM x;
WITH x AS (INSERT INTO x VALUES (42, 'new2') RETURNING x AS x) DELETE FROM x USING x WHERE x = x;
SELECT * FROM x;
/* check EXPLAIN VERBOSE for a wCTE with RETURNING */ EXPLAIN (VERBOSE, COSTS OFF) WITH wcte AS ( INSERT INTO int8_tbl VALUES ( 42, 47 ) RETURNING q2 ) DELETE FROM a_star USING wcte WHERE aa = q2;
/* no RETURNING in a referenced data-modifying WITH */ WITH x AS (INSERT INTO x VALUES (0)) SELECT * FROM x;
/* RETURNING tries to return its own output */ WITH RECURSIVE x AS (MERGE INTO x USING (VALUES (11)) AS x ON x.x = x.x WHEN NOT MATCHED THEN INSERT VALUES (x.x) RETURNING MERGE_ACTION(), (SELECT x FROM x)) SELECT * FROM x;
/* data-modifying WITH allowed only at the top level */ SELECT * FROM (WITH x AS (UPDATE x SET x = x + 1 RETURNING *) SELECT * FROM x) AS x;
/* most variants of rules aren't allowed */ CREATE RULE y_rule AS ON INSERT TO y WHERE a=0 DO INSTEAD DELETE FROM y;
CREATE OR REPLACE RULE y_rule AS ON INSERT TO y DO INSTEAD NOTHING;
CREATE OR REPLACE RULE y_rule AS ON INSERT TO y DO INSTEAD NOTIFY foo;
CREATE OR REPLACE RULE y_rule AS ON INSERT TO y DO ALSO NOTIFY foo;
CREATE OR REPLACE RULE y_rule AS ON INSERT TO y   DO INSTEAD (NOTIFY foo;
DROP RULE y_rule ON y;
/* fail, WITH is a reserved word */ WITH x AS (SELECT 1 AS x) SELECT * FROM x;
/* check sane response to attempt to modify CTE relation */ WITH x AS (SELECT 42) INSERT INTO x VALUES (1);
/* check response to attempt to modify table with same name as a CTE (perhaps */ /* surprisingly it works, because CTEs don't hide tables from data-modifying */ /* statements) */ CREATE TEMPORARY TABLE x (x INT);
WITH x AS (SELECT 42) INSERT INTO x SELECT * FROM x;
SELECT * FROM x;
DROP TABLE x;
/* Tests for WITHOUT OVERLAPS. */ /* We leave behind several tables to test pg_dump etc: */ /* temporal_rng, temporal_rng2, */ /* temporal_fk_rng2rng. */ SET datestyle TO ISO, YMD;
SELECT PG_GET_INDEXDEF(x, 0, TRUE) FROM x WHERE x = 'temporal_rng_pk';
/* PK from LIKE: */ CREATE TABLE x (LIKE x INCLUDING ALL);
/* no PK from INHERITS: */ CREATE TABLE x INHERITS (x);
DROP TABLE x;
/* PK in inheriting table: */ CREATE TABLE x (x INT4RANGE, x DATERANGE);
/* Add PK to already inheriting table: */ CREATE TABLE x (x INT4RANGE, x DATERANGE);
CREATE TABLE x INHERITS (x);
DROP TABLE x;
SELECT PG_GET_INDEXDEF(x, 0, TRUE) FROM x WHERE x = 'temporal_rng2_pk';
/* PK with a custom range type: */ CREATE TYPE textrange2 AS range (subtype=text, collation="C");
ALTER TABLE x DROP CONSTRAINT x;
DROP TABLE x;
DROP TYPE textrange2;
SELECT PG_GET_INDEXDEF(x, 0, TRUE) FROM x WHERE x = 'temporal_mltrng_pk';
SELECT PG_GET_INDEXDEF(x, 0, TRUE) FROM x WHERE x = 'temporal_mltrng2_pk';
SELECT PG_GET_INDEXDEF(x, 0, TRUE) FROM x WHERE x = 'temporal_rng3_uq';
DROP TABLE x;
SELECT PG_GET_INDEXDEF(x, 0, TRUE) FROM x WHERE x = 'temporal_rng3_uq';
DROP TABLE x;
/* UNIQUE with a custom range type: */ CREATE TYPE textrange2 AS range (subtype=text, collation="C");
ALTER TABLE x DROP CONSTRAINT x;
DROP TABLE x;
DROP TYPE textrange2;
/* test ALTER TABLE ADD CONSTRAINT */ CREATE TABLE x (x INT4RANGE, x DATERANGE);
/* PK with USING INDEX (not possible): */ CREATE TABLE x (x INT4RANGE, x DATERANGE);
CREATE INDEX x ON x USING gist(x NULLS LAST, x NULLS LAST);
ALTER TABLE temporal3   ADD CONSTRAINT temporal3_pk   PRIMARY KEY USING INDEX idx_temporal3_uq;
DROP TABLE x;
/* UNIQUE with USING INDEX (not possible): */ CREATE TABLE x (x INT4RANGE, x DATERANGE);
CREATE INDEX x ON x USING gist(x NULLS LAST, x NULLS LAST);
ALTER TABLE temporal3   ADD CONSTRAINT temporal3_uq   UNIQUE USING INDEX idx_temporal3_uq;
DROP TABLE x;
/* UNIQUE with USING [UNIQUE] INDEX (possible but not a temporal constraint): */ CREATE TABLE x (x INT4RANGE, x DATERANGE);
CREATE UNIQUE INDEX x ON x(x NULLS LAST, x NULLS LAST);
ALTER TABLE temporal3   ADD CONSTRAINT temporal3_uq   UNIQUE USING INDEX idx_temporal3_uq;
DROP TABLE x;
/* Add range column and the PK at the same time */ CREATE TABLE x (x INT4RANGE);
DROP TABLE x;
/* Add range column and UNIQUE constraint at the same time */ CREATE TABLE x (x INT4RANGE);
DROP TABLE x;
ALTER TABLE x DROP CONSTRAINT x /* range PK: test with existing rows */;
/* okay: */ INSERT INTO x (x, x) VALUES ('[1,2)', DATERANGE('2018-01-02', '2018-02-03'));
INSERT INTO x (x, x) VALUES ('[1,2)', DATERANGE('2018-03-03', '2018-04-04'));
INSERT INTO x (x, x) VALUES ('[2,3)', DATERANGE('2018-01-01', '2018-01-05'));
INSERT INTO x (x, x) VALUES ('[3,4)', DATERANGE('2018-01-01', NULL));
ALTER TABLE x DROP CONSTRAINT x;
/* should fail: */ BEGIN;
INSERT INTO x (x, x) VALUES ('[1,2)', DATERANGE('2018-01-01', '2018-01-05'));
ROLLBACK;
/* rejects empty: */ BEGIN;
INSERT INTO x (x, x) VALUES ('[3,4)', 'empty');
ROLLBACK;
DELETE FROM x;
/* range PK: test inserts */ /* okay: */ INSERT INTO x (x, x) VALUES ('[1,2)', DATERANGE('2018-01-02', '2018-02-03'));
INSERT INTO x (x, x) VALUES ('[1,2)', DATERANGE('2018-03-03', '2018-04-04'));
INSERT INTO x (x, x) VALUES ('[2,3)', DATERANGE('2018-01-01', '2018-01-05'));
INSERT INTO x (x, x) VALUES ('[3,4)', DATERANGE('2018-01-01', NULL));
/* should fail: */ INSERT INTO x (x, x) VALUES ('[1,2)', DATERANGE('2018-01-01', '2018-01-05'));
INSERT INTO x (x, x) VALUES (NULL, DATERANGE('2018-01-01', '2018-01-05'));
INSERT INTO x (x, x) VALUES ('[3,4)', NULL);
/* rejects empty: */ INSERT INTO x (x, x) VALUES ('[3,4)', 'empty');
SELECT * FROM x ORDER BY x NULLS LAST, x NULLS LAST;
/* range PK: test updates */ /* update the scalar part */ UPDATE x SET x = '[11,12)' WHERE x = '[1,2)' AND x @> CAST('2018-01-15' AS DATE);
/* update the range part */ UPDATE x SET x = '[2020-01-01,2021-01-01)' WHERE x = '[11,12)' AND x @> CAST('2018-01-15' AS DATE);
/* update both at once */ UPDATE x SET x = '[21,22)', x = '[2018-01-02,2018-02-03)' WHERE x = '[11,12)' AND x @> CAST('2020-01-15' AS DATE);
SELECT * FROM x ORDER BY x NULLS LAST, x NULLS LAST;
/* should fail: */ UPDATE x SET x = '[1,2)', x = DATERANGE('2018-03-05', '2018-05-05') WHERE x = '[21,22)';
/* set the scalar part to NULL */ UPDATE x SET x = NULL, x = DATERANGE('2018-03-05', '2018-05-05') WHERE x = '[21,22)';
/* set the range part to NULL */ UPDATE x SET x = '[1,2)', x = NULL WHERE x = '[21,22)';
/* rejects empty: */ UPDATE x SET x = '[1,2)', x = 'empty' WHERE x = '[21,22)';
SELECT * FROM x ORDER BY x NULLS LAST, x NULLS LAST;
/* range UQ: test with existing rows */ CREATE TABLE x (x INT4RANGE, x DATERANGE);
/* okay: */ INSERT INTO x (x, x) VALUES ('[1,2)', DATERANGE('2018-01-02', '2018-02-03'));
INSERT INTO x (x, x) VALUES ('[1,2)', DATERANGE('2018-03-03', '2018-04-04'));
INSERT INTO x (x, x) VALUES ('[2,3)', DATERANGE('2018-01-01', '2018-01-05'));
INSERT INTO x (x, x) VALUES ('[3,4)', DATERANGE('2018-01-01', NULL));
INSERT INTO x (x, x) VALUES (NULL, DATERANGE('2018-01-01', '2018-01-05'));
INSERT INTO x (x, x) VALUES ('[3,4)', NULL);
ALTER TABLE x DROP CONSTRAINT x;
/* should fail: */ BEGIN;
INSERT INTO x (x, x) VALUES ('[1,2)', DATERANGE('2018-01-01', '2018-01-05'));
ROLLBACK;
/* rejects empty: */ BEGIN;
INSERT INTO x (x, x) VALUES ('[3,4)', 'empty');
ROLLBACK;
DELETE FROM x;
/* range UQ: test inserts */ /* okay: */ INSERT INTO x (x, x) VALUES ('[1,2)', DATERANGE('2018-01-02', '2018-02-03'));
INSERT INTO x (x, x) VALUES ('[1,2)', DATERANGE('2018-03-03', '2018-04-04'));
INSERT INTO x (x, x) VALUES ('[2,3)', DATERANGE('2018-01-01', '2018-01-05'));
INSERT INTO x (x, x) VALUES ('[3,4)', DATERANGE('2018-01-01', NULL));
INSERT INTO x (x, x) VALUES (NULL, DATERANGE('2018-01-01', '2018-01-05'));
INSERT INTO x (x, x) VALUES ('[3,4)', NULL);
/* should fail: */ INSERT INTO x (x, x) VALUES ('[1,2)', DATERANGE('2018-01-01', '2018-01-05'));
/* rejects empty: */ INSERT INTO x (x, x) VALUES ('[3,4)', 'empty');
SELECT * FROM x ORDER BY x NULLS LAST, x NULLS LAST;
/* range UQ: test updates */ /* update the scalar part */ UPDATE x SET x = '[11,12)' WHERE x = '[1,2)' AND x @> CAST('2018-01-15' AS DATE);
/* update the range part */ UPDATE x SET x = '[2020-01-01,2021-01-01)' WHERE x = '[11,12)' AND x @> CAST('2018-01-15' AS DATE);
/* update both at once */ UPDATE x SET x = '[21,22)', x = '[2018-01-02,2018-02-03)' WHERE x = '[11,12)' AND x @> CAST('2020-01-15' AS DATE);
/* set the scalar part to NULL */ UPDATE x SET x = NULL, x = DATERANGE('2020-01-01', '2021-01-01') WHERE x = '[21,22)';
/* set the range part to NULL */ UPDATE x SET x = '[1,2)', x = NULL WHERE x IS NULL AND x @> CAST('2020-06-01' AS DATE);
SELECT * FROM x ORDER BY x NULLS LAST, x NULLS LAST;
/* should fail: */ UPDATE x SET x = DATERANGE('2018-03-01', '2018-05-05') WHERE x = '[1,2)' AND x IS NULL;
/* rejects empty: */ UPDATE x SET x = 'empty' WHERE x = '[1,2)' AND x IS NULL;
/* still rejects empty when scalar part is NULL: */ UPDATE x SET x = NULL, x = 'empty' WHERE x = '[1,2)' AND x IS NULL;
SELECT * FROM x ORDER BY x NULLS LAST, x NULLS LAST;
DROP TABLE x;
ALTER TABLE x DROP CONSTRAINT x /* multirange PK: test with existing rows */;
/* okay: */ INSERT INTO x (x, x) VALUES ('[1,2)', DATEMULTIRANGE(DATERANGE('2018-01-02', '2018-02-03')));
INSERT INTO x (x, x) VALUES ('[1,2)', DATEMULTIRANGE(DATERANGE('2018-03-03', '2018-04-04')));
INSERT INTO x (x, x) VALUES ('[2,3)', DATEMULTIRANGE(DATERANGE('2018-01-01', '2018-01-05')));
INSERT INTO x (x, x) VALUES ('[3,4)', DATEMULTIRANGE(DATERANGE('2018-01-01', NULL)));
ALTER TABLE x DROP CONSTRAINT x;
/* should fail: */ BEGIN;
INSERT INTO x (x, x) VALUES ('[1,2)', DATEMULTIRANGE(DATERANGE('2018-01-01', '2018-01-05')));
ROLLBACK;
/* rejects empty: */ BEGIN;
INSERT INTO x (x, x) VALUES ('[3,4)', '{}');
ROLLBACK;
DELETE FROM x;
/* multirange PK: test inserts */ /* okay: */ INSERT INTO x (x, x) VALUES ('[1,2)', DATEMULTIRANGE(DATERANGE('2018-01-02', '2018-02-03')));
INSERT INTO x (x, x) VALUES ('[1,2)', DATEMULTIRANGE(DATERANGE('2018-03-03', '2018-04-04')));
INSERT INTO x (x, x) VALUES ('[2,3)', DATEMULTIRANGE(DATERANGE('2018-01-01', '2018-01-05')));
INSERT INTO x (x, x) VALUES ('[3,4)', DATEMULTIRANGE(DATERANGE('2018-01-01', NULL)));
/* should fail: */ INSERT INTO x (x, x) VALUES ('[1,2)', DATEMULTIRANGE(DATERANGE('2018-01-01', '2018-01-05')));
INSERT INTO x (x, x) VALUES (NULL, DATEMULTIRANGE(DATERANGE('2018-01-01', '2018-01-05')));
INSERT INTO x (x, x) VALUES ('[3,4)', NULL);
/* rejects empty: */ INSERT INTO x (x, x) VALUES ('[3,4)', '{}');
SELECT * FROM x ORDER BY x NULLS LAST, x NULLS LAST;
/* multirange PK: test updates */ /* update the scalar part */ UPDATE x SET x = '[11,12)' WHERE x = '[1,2)' AND x @> CAST('2018-01-15' AS DATE);
/* update the multirange part */ UPDATE x SET x = '{[2020-01-01,2021-01-01)}' WHERE x = '[11,12)' AND x @> CAST('2018-01-15' AS DATE);
/* update both at once */ UPDATE x SET x = '[21,22)', x = '{[2018-01-02,2018-02-03)}' WHERE x = '[11,12)' AND x @> CAST('2020-01-15' AS DATE);
SELECT * FROM x ORDER BY x NULLS LAST, x NULLS LAST;
/* should fail: */ UPDATE x SET x = '[1,2)', x = DATEMULTIRANGE(DATERANGE('2018-03-05', '2018-05-05')) WHERE x = '[21,22)';
/* set the scalar part to NULL */ UPDATE x SET x = NULL, x = DATEMULTIRANGE(DATERANGE('2018-03-05', '2018-05-05')) WHERE x = '[21,22)';
/* set the multirange part to NULL */ UPDATE x SET x = '[1,2)', x = NULL WHERE x = '[21,22)';
/* rejects empty: */ UPDATE x SET x = '[1,2)', x = '{}' WHERE x = '[21,22)';
SELECT * FROM x ORDER BY x NULLS LAST, x NULLS LAST;
/* multirange UQ: test with existing rows */ CREATE TABLE x (x INT4RANGE, x DATEMULTIRANGE);
/* okay: */ INSERT INTO x (x, x) VALUES ('[1,2)', DATEMULTIRANGE(DATERANGE('2018-01-02', '2018-02-03')));
INSERT INTO x (x, x) VALUES ('[1,2)', DATEMULTIRANGE(DATERANGE('2018-03-03', '2018-04-04')));
INSERT INTO x (x, x) VALUES ('[2,3)', DATEMULTIRANGE(DATERANGE('2018-01-01', '2018-01-05')));
INSERT INTO x (x, x) VALUES ('[3,4)', DATEMULTIRANGE(DATERANGE('2018-01-01', NULL)));
INSERT INTO x (x, x) VALUES (NULL, DATEMULTIRANGE(DATERANGE('2018-01-01', '2018-01-05')));
INSERT INTO x (x, x) VALUES ('[3,4)', NULL);
ALTER TABLE x DROP CONSTRAINT x;
/* should fail: */ BEGIN;
INSERT INTO x (x, x) VALUES ('[1,2)', DATEMULTIRANGE(DATERANGE('2018-01-01', '2018-01-05')));
ROLLBACK;
/* rejects empty: */ BEGIN;
INSERT INTO x (x, x) VALUES ('[3,4)', '{}');
ROLLBACK;
DELETE FROM x;
/* multirange UQ: test inserts */ /* okay: */ INSERT INTO x (x, x) VALUES ('[1,2)', DATEMULTIRANGE(DATERANGE('2018-01-02', '2018-02-03')));
INSERT INTO x (x, x) VALUES ('[1,2)', DATEMULTIRANGE(DATERANGE('2018-03-03', '2018-04-04')));
INSERT INTO x (x, x) VALUES ('[2,3)', DATEMULTIRANGE(DATERANGE('2018-01-01', '2018-01-05')));
INSERT INTO x (x, x) VALUES ('[3,4)', DATEMULTIRANGE(DATERANGE('2018-01-01', NULL)));
INSERT INTO x (x, x) VALUES (NULL, DATEMULTIRANGE(DATERANGE('2018-01-01', '2018-01-05')));
INSERT INTO x (x, x) VALUES ('[3,4)', NULL);
/* should fail: */ INSERT INTO x (x, x) VALUES ('[1,2)', DATEMULTIRANGE(DATERANGE('2018-01-01', '2018-01-05')));
/* rejects empty: */ INSERT INTO x (x, x) VALUES ('[3,4)', '{}');
SELECT * FROM x ORDER BY x NULLS LAST, x NULLS LAST;
/* multirange UQ: test updates */ /* update the scalar part */ UPDATE x SET x = '[11,12)' WHERE x = '[1,2)' AND x @> CAST('2018-01-15' AS DATE);
/* update the multirange part */ UPDATE x SET x = '{[2020-01-01,2021-01-01)}' WHERE x = '[11,12)' AND x @> CAST('2018-01-15' AS DATE);
/* update both at once */ UPDATE x SET x = '[21,22)', x = '{[2018-01-02,2018-02-03)}' WHERE x = '[11,12)' AND x @> CAST('2020-01-15' AS DATE);
/* set the scalar part to NULL */ UPDATE x SET x = NULL, x = DATEMULTIRANGE(DATERANGE('2020-01-01', '2021-01-01')) WHERE x = '[21,22)';
/* set the multirange part to NULL */ UPDATE x SET x = '[1,2)', x = NULL WHERE x IS NULL AND x @> CAST('2020-06-01' AS DATE);
SELECT * FROM x ORDER BY x NULLS LAST, x NULLS LAST;
/* should fail: */ UPDATE x SET x = DATEMULTIRANGE(DATERANGE('2018-03-01', '2018-05-05')) WHERE x = '[1,2)' AND x IS NULL;
/* rejects empty: */ UPDATE x SET x = '{}' WHERE x = '[1,2)' AND x IS NULL;
/* still rejects empty when scalar part is NULL: */ UPDATE x SET x = NULL, x = '{}' WHERE x = '[1,2)' AND x IS NULL;
SELECT * FROM x ORDER BY x NULLS LAST, x NULLS LAST;
DROP TABLE x;
INSERT INTO x (x, x, x, x) VALUES ('[1,2)', DATERANGE('2000-01-01', '2010-01-01'), '[7,8)', 'foo'), ('[2,3)', DATERANGE('2000-01-01', '2010-01-01'), '[9,10)', 'bar');
DROP TABLE x;
ALTER TABLE x ALTER COLUMN x DROP NOT NULL;
ALTER TABLE x ALTER COLUMN x SET DATA TYPE TSTZRANGE USING TSTZRANGE(LOWER(x), UPPER(x));
ALTER TABLE x RENAME COLUMN x TO x;
ALTER TABLE x DROP COLUMN x;
DROP TABLE x;
CREATE TABLE x PARTITION OF x FOR VALUES IN ('[1,2)', '[2,3)');
CREATE TABLE x PARTITION OF x FOR VALUES IN ('[3,4)', '[4,5)');
INSERT INTO x (x, x, x) VALUES ('[1,2)', DATERANGE('2000-01-01', '2000-02-01'), 'one'), ('[1,2)', DATERANGE('2000-02-01', '2000-03-01'), 'one'), ('[3,4)', DATERANGE('2000-01-01', '2010-01-01'), 'three');
SELECT * FROM x ORDER BY x NULLS LAST, x NULLS LAST;
SELECT * FROM x ORDER BY x NULLS LAST, x NULLS LAST;
SELECT * FROM x ORDER BY x NULLS LAST, x NULLS LAST;
DROP TABLE x;
CREATE TABLE x PARTITION OF x FOR VALUES IN ('[1,2)', '[2,3)');
CREATE TABLE x PARTITION OF x FOR VALUES IN ('[3,4)', '[4,5)');
INSERT INTO x (x, x, x) VALUES ('[1,2)', DATERANGE('2000-01-01', '2000-02-01'), 'one'), ('[1,2)', DATERANGE('2000-02-01', '2000-03-01'), 'one'), ('[3,4)', DATERANGE('2000-01-01', '2010-01-01'), 'three');
SELECT * FROM x ORDER BY x NULLS LAST, x NULLS LAST;
SELECT * FROM x ORDER BY x NULLS LAST, x NULLS LAST;
SELECT * FROM x ORDER BY x NULLS LAST, x NULLS LAST;
DROP TABLE x;
INSERT INTO x (x, x) VALUES ('[1,2)', DATERANGE('2000-01-01', '2010-01-01'));
/* with a conflict */ INSERT INTO x (x, x) VALUES ('[1,2)', DATERANGE('2005-01-01', '2006-01-01')) ON CONFLICT DO NOTHING;
/* id matches but no conflict */ INSERT INTO x (x, x) VALUES ('[1,2)', DATERANGE('2010-01-01', '2020-01-01')) ON CONFLICT DO NOTHING;
/* date matches but no conflict */ INSERT INTO x (x, x) VALUES ('[2,3)', DATERANGE('2005-01-01', '2006-01-01')) ON CONFLICT DO NOTHING;
SELECT * FROM x ORDER BY x NULLS LAST, x NULLS LAST;
TRUNCATE TABLE x;
INSERT INTO x (x, x) VALUES ('[1,2)', DATERANGE('2000-01-01', '2010-01-01'));
/* with a conflict */ INSERT INTO x (x, x) VALUES ('[1,2)', DATERANGE('2005-01-01', '2006-01-01')) ON CONFLICT(x, x) DO NOTHING;
/* id matches but no conflict */ INSERT INTO x (x, x) VALUES ('[1,2)', DATERANGE('2010-01-01', '2020-01-01')) ON CONFLICT(x, x) DO NOTHING;
/* date matches but no conflict */ INSERT INTO x (x, x) VALUES ('[2,3)', DATERANGE('2005-01-01', '2006-01-01')) ON CONFLICT(x, x) DO NOTHING;
SELECT * FROM x ORDER BY x NULLS LAST, x NULLS LAST;
TRUNCATE TABLE x;
INSERT INTO x (x, x) VALUES ('[1,2)', DATERANGE('2000-01-01', '2010-01-01'));
/* with a conflict */ INSERT INTO x (x, x) VALUES ('[1,2)', DATERANGE('2005-01-01', '2006-01-01')) ON CONFLICT ON CONSTRAINT x DO NOTHING;
/* id matches but no conflict */ INSERT INTO x (x, x) VALUES ('[1,2)', DATERANGE('2010-01-01', '2020-01-01')) ON CONFLICT ON CONSTRAINT x DO NOTHING;
/* date matches but no conflict */ INSERT INTO x (x, x) VALUES ('[2,3)', DATERANGE('2005-01-01', '2006-01-01')) ON CONFLICT ON CONSTRAINT x DO NOTHING;
SELECT * FROM x ORDER BY x NULLS LAST, x NULLS LAST;
TRUNCATE TABLE x;
INSERT INTO x (x, x) VALUES ('[1,2)', DATERANGE('2000-01-01', '2010-01-01'));
/* with a conflict */ INSERT INTO x (x, x) VALUES ('[1,2)', DATERANGE('2005-01-01', '2006-01-01')) ON CONFLICT(x, x) DO UPDATE SET x = x.x + '[2,3)';
/* id matches but no conflict */ INSERT INTO x (x, x) VALUES ('[1,2)', DATERANGE('2010-01-01', '2020-01-01')) ON CONFLICT(x, x) DO UPDATE SET x = x.x + '[3,4)';
/* date matches but no conflict */ INSERT INTO x (x, x) VALUES ('[2,3)', DATERANGE('2005-01-01', '2006-01-01')) ON CONFLICT(x, x) DO UPDATE SET x = x.x + '[4,5)';
SELECT * FROM x ORDER BY x NULLS LAST, x NULLS LAST;
TRUNCATE TABLE x;
INSERT INTO x (x, x) VALUES ('[1,2)', DATERANGE('2000-01-01', '2010-01-01'));
/* with a conflict */ INSERT INTO x (x, x) VALUES ('[1,2)', DATERANGE('2005-01-01', '2006-01-01')) ON CONFLICT ON CONSTRAINT x DO UPDATE SET x = x.x + '[2,3)';
/* id matches but no conflict */ INSERT INTO x (x, x) VALUES ('[1,2)', DATERANGE('2010-01-01', '2020-01-01')) ON CONFLICT ON CONSTRAINT x DO UPDATE SET x = x.x + '[3,4)';
/* date matches but no conflict */ INSERT INTO x (x, x) VALUES ('[2,3)', DATERANGE('2005-01-01', '2006-01-01')) ON CONFLICT ON CONSTRAINT x DO UPDATE SET x = x.x + '[4,5)';
SELECT * FROM x ORDER BY x NULLS LAST, x NULLS LAST;
TRUNCATE TABLE x;
INSERT INTO x (x, x) VALUES ('[1,2)', DATERANGE('2000-01-01', '2010-01-01'));
/* with a conflict */ INSERT INTO x (x, x) VALUES ('[1,2)', DATERANGE('2005-01-01', '2006-01-01')) ON CONFLICT DO NOTHING;
/* id matches but no conflict */ INSERT INTO x (x, x) VALUES ('[1,2)', DATERANGE('2010-01-01', '2020-01-01')) ON CONFLICT DO NOTHING;
/* date matches but no conflict */ INSERT INTO x (x, x) VALUES ('[2,3)', DATERANGE('2005-01-01', '2006-01-01')) ON CONFLICT DO NOTHING;
SELECT * FROM x ORDER BY x NULLS LAST, x NULLS LAST;
TRUNCATE TABLE x;
INSERT INTO x (x, x) VALUES ('[1,2)', DATERANGE('2000-01-01', '2010-01-01'));
/* with a conflict */ INSERT INTO x (x, x) VALUES ('[1,2)', DATERANGE('2005-01-01', '2006-01-01')) ON CONFLICT(x, x) DO NOTHING;
/* id matches but no conflict */ INSERT INTO x (x, x) VALUES ('[1,2)', DATERANGE('2010-01-01', '2020-01-01')) ON CONFLICT(x, x) DO NOTHING;
/* date matches but no conflict */ INSERT INTO x (x, x) VALUES ('[2,3)', DATERANGE('2005-01-01', '2006-01-01')) ON CONFLICT(x, x) DO NOTHING;
SELECT * FROM x ORDER BY x NULLS LAST, x NULLS LAST;
TRUNCATE TABLE x;
INSERT INTO x (x, x) VALUES ('[1,2)', DATERANGE('2000-01-01', '2010-01-01'));
/* with a conflict */ INSERT INTO x (x, x) VALUES ('[1,2)', DATERANGE('2005-01-01', '2006-01-01')) ON CONFLICT ON CONSTRAINT x DO NOTHING;
/* id matches but no conflict */ INSERT INTO x (x, x) VALUES ('[1,2)', DATERANGE('2010-01-01', '2020-01-01')) ON CONFLICT ON CONSTRAINT x DO NOTHING;
/* date matches but no conflict */ INSERT INTO x (x, x) VALUES ('[2,3)', DATERANGE('2005-01-01', '2006-01-01')) ON CONFLICT ON CONSTRAINT x DO NOTHING;
SELECT * FROM x ORDER BY x NULLS LAST, x NULLS LAST;
TRUNCATE TABLE x;
INSERT INTO x (x, x) VALUES ('[1,2)', DATERANGE('2000-01-01', '2010-01-01'));
/* with a conflict */ INSERT INTO x (x, x) VALUES ('[1,2)', DATERANGE('2005-01-01', '2006-01-01')) ON CONFLICT(x, x) DO UPDATE SET x = x.x + '[2,3)';
/* id matches but no conflict */ INSERT INTO x (x, x) VALUES ('[1,2)', DATERANGE('2010-01-01', '2020-01-01')) ON CONFLICT(x, x) DO UPDATE SET x = x.x + '[3,4)';
/* date matches but no conflict */ INSERT INTO x (x, x) VALUES ('[2,3)', DATERANGE('2005-01-01', '2006-01-01')) ON CONFLICT(x, x) DO UPDATE SET x = x.x + '[4,5)';
SELECT * FROM x ORDER BY x NULLS LAST, x NULLS LAST;
TRUNCATE TABLE x;
INSERT INTO x (x, x) VALUES ('[1,2)', DATERANGE('2000-01-01', '2010-01-01'));
/* with a conflict */ INSERT INTO x (x, x) VALUES ('[1,2)', DATERANGE('2005-01-01', '2006-01-01')) ON CONFLICT ON CONSTRAINT x DO UPDATE SET x = x.x + '[2,3)';
/* id matches but no conflict */ INSERT INTO x (x, x) VALUES ('[1,2)', DATERANGE('2010-01-01', '2020-01-01')) ON CONFLICT ON CONSTRAINT x DO UPDATE SET x = x.x + '[3,4)';
/* date matches but no conflict */ INSERT INTO x (x, x) VALUES ('[2,3)', DATERANGE('2005-01-01', '2006-01-01')) ON CONFLICT ON CONSTRAINT x DO UPDATE SET x = x.x + '[4,5)';
SELECT * FROM x ORDER BY x NULLS LAST, x NULLS LAST;
DROP TABLE x;
TRUNCATE TABLE x /* ON CONFLICT: multiranges */;
INSERT INTO x (x, x) VALUES ('[1,2)', DATEMULTIRANGE(DATERANGE('2000-01-01', '2010-01-01')));
/* with a conflict */ INSERT INTO x (x, x) VALUES ('[1,2)', DATEMULTIRANGE(DATERANGE('2005-01-01', '2006-01-01'))) ON CONFLICT DO NOTHING;
/* id matches but no conflict */ INSERT INTO x (x, x) VALUES ('[1,2)', DATEMULTIRANGE(DATERANGE('2010-01-01', '2020-01-01'))) ON CONFLICT DO NOTHING;
/* date matches but no conflict */ INSERT INTO x (x, x) VALUES ('[2,3)', DATEMULTIRANGE(DATERANGE('2005-01-01', '2006-01-01'))) ON CONFLICT DO NOTHING;
SELECT * FROM x ORDER BY x NULLS LAST, x NULLS LAST;
TRUNCATE TABLE x;
INSERT INTO x (x, x) VALUES ('[1,2)', DATEMULTIRANGE(DATERANGE('2000-01-01', '2010-01-01')));
/* with a conflict */ INSERT INTO x (x, x) VALUES ('[1,2)', DATEMULTIRANGE(DATERANGE('2005-01-01', '2006-01-01'))) ON CONFLICT(x, x) DO NOTHING;
/* id matches but no conflict */ INSERT INTO x (x, x) VALUES ('[1,2)', DATEMULTIRANGE(DATERANGE('2010-01-01', '2020-01-01'))) ON CONFLICT(x, x) DO NOTHING;
/* date matches but no conflict */ INSERT INTO x (x, x) VALUES ('[2,3)', DATEMULTIRANGE(DATERANGE('2005-01-01', '2006-01-01'))) ON CONFLICT(x, x) DO NOTHING;
SELECT * FROM x ORDER BY x NULLS LAST, x NULLS LAST;
TRUNCATE TABLE x;
INSERT INTO x (x, x) VALUES ('[1,2)', DATEMULTIRANGE(DATERANGE('2000-01-01', '2010-01-01')));
/* with a conflict */ INSERT INTO x (x, x) VALUES ('[1,2)', DATEMULTIRANGE(DATERANGE('2005-01-01', '2006-01-01'))) ON CONFLICT ON CONSTRAINT x DO NOTHING;
/* id matches but no conflict */ INSERT INTO x (x, x) VALUES ('[1,2)', DATEMULTIRANGE(DATERANGE('2010-01-01', '2020-01-01'))) ON CONFLICT ON CONSTRAINT x DO NOTHING;
/* date matches but no conflict */ INSERT INTO x (x, x) VALUES ('[2,3)', DATEMULTIRANGE(DATERANGE('2005-01-01', '2006-01-01'))) ON CONFLICT ON CONSTRAINT x DO NOTHING;
SELECT * FROM x ORDER BY x NULLS LAST, x NULLS LAST;
TRUNCATE TABLE x;
INSERT INTO x (x, x) VALUES ('[1,2)', DATEMULTIRANGE(DATERANGE('2000-01-01', '2010-01-01')));
/* with a conflict */ INSERT INTO x (x, x) VALUES ('[1,2)', DATEMULTIRANGE(DATERANGE('2005-01-01', '2006-01-01'))) ON CONFLICT(x, x) DO UPDATE SET x = x.x + '[2,3)';
/* id matches but no conflict */ INSERT INTO x (x, x) VALUES ('[1,2)', DATEMULTIRANGE(DATERANGE('2010-01-01', '2020-01-01'))) ON CONFLICT(x, x) DO UPDATE SET x = x.x + '[3,4)';
/* date matches but no conflict */ INSERT INTO x (x, x) VALUES ('[2,3)', DATEMULTIRANGE(DATERANGE('2005-01-01', '2006-01-01'))) ON CONFLICT(x, x) DO UPDATE SET x = x.x + '[4,5)';
SELECT * FROM x ORDER BY x NULLS LAST, x NULLS LAST;
TRUNCATE TABLE x;
INSERT INTO x (x, x) VALUES ('[1,2)', DATEMULTIRANGE(DATERANGE('2000-01-01', '2010-01-01')));
/* with a conflict */ INSERT INTO x (x, x) VALUES ('[1,2)', DATEMULTIRANGE(DATERANGE('2005-01-01', '2006-01-01'))) ON CONFLICT ON CONSTRAINT x DO UPDATE SET x = x.x + '[2,3)';
/* id matches but no conflict */ INSERT INTO x (x, x) VALUES ('[1,2)', DATEMULTIRANGE(DATERANGE('2010-01-01', '2020-01-01'))) ON CONFLICT ON CONSTRAINT x DO UPDATE SET x = x.x + '[3,4)';
/* date matches but no conflict */ INSERT INTO x (x, x) VALUES ('[2,3)', DATEMULTIRANGE(DATERANGE('2005-01-01', '2006-01-01'))) ON CONFLICT ON CONSTRAINT x DO UPDATE SET x = x.x + '[4,5)';
SELECT * FROM x ORDER BY x NULLS LAST, x NULLS LAST;
TRUNCATE TABLE x;
INSERT INTO x (x, x) VALUES ('[1,2)', DATEMULTIRANGE(DATERANGE('2000-01-01', '2010-01-01')));
/* with a conflict */ INSERT INTO x (x, x) VALUES ('[1,2)', DATEMULTIRANGE(DATERANGE('2005-01-01', '2006-01-01'))) ON CONFLICT DO NOTHING;
/* id matches but no conflict */ INSERT INTO x (x, x) VALUES ('[1,2)', DATEMULTIRANGE(DATERANGE('2010-01-01', '2020-01-01'))) ON CONFLICT DO NOTHING;
/* date matches but no conflict */ INSERT INTO x (x, x) VALUES ('[2,3)', DATEMULTIRANGE(DATERANGE('2005-01-01', '2006-01-01'))) ON CONFLICT DO NOTHING;
SELECT * FROM x ORDER BY x NULLS LAST, x NULLS LAST;
TRUNCATE TABLE x;
INSERT INTO x (x, x) VALUES ('[1,2)', DATEMULTIRANGE(DATERANGE('2000-01-01', '2010-01-01')));
/* with a conflict */ INSERT INTO x (x, x) VALUES ('[1,2)', DATEMULTIRANGE(DATERANGE('2005-01-01', '2006-01-01'))) ON CONFLICT(x, x) DO NOTHING;
/* id matches but no conflict */ INSERT INTO x (x, x) VALUES ('[1,2)', DATEMULTIRANGE(DATERANGE('2010-01-01', '2020-01-01'))) ON CONFLICT(x, x) DO NOTHING;
/* date matches but no conflict */ INSERT INTO x (x, x) VALUES ('[2,3)', DATEMULTIRANGE(DATERANGE('2005-01-01', '2006-01-01'))) ON CONFLICT(x, x) DO NOTHING;
SELECT * FROM x ORDER BY x NULLS LAST, x NULLS LAST;
TRUNCATE TABLE x;
INSERT INTO x (x, x) VALUES ('[1,2)', DATEMULTIRANGE(DATERANGE('2000-01-01', '2010-01-01')));
/* with a conflict */ INSERT INTO x (x, x) VALUES ('[1,2)', DATEMULTIRANGE(DATERANGE('2005-01-01', '2006-01-01'))) ON CONFLICT ON CONSTRAINT x DO NOTHING;
/* id matches but no conflict */ INSERT INTO x (x, x) VALUES ('[1,2)', DATEMULTIRANGE(DATERANGE('2010-01-01', '2020-01-01'))) ON CONFLICT ON CONSTRAINT x DO NOTHING;
/* date matches but no conflict */ INSERT INTO x (x, x) VALUES ('[2,3)', DATEMULTIRANGE(DATERANGE('2005-01-01', '2006-01-01'))) ON CONFLICT ON CONSTRAINT x DO NOTHING;
SELECT * FROM x ORDER BY x NULLS LAST, x NULLS LAST;
TRUNCATE TABLE x;
INSERT INTO x (x, x) VALUES ('[1,2)', DATEMULTIRANGE(DATERANGE('2000-01-01', '2010-01-01')));
/* with a conflict */ INSERT INTO x (x, x) VALUES ('[1,2)', DATEMULTIRANGE(DATERANGE('2005-01-01', '2006-01-01'))) ON CONFLICT(x, x) DO UPDATE SET x = x.x + '[2,3)';
/* id matches but no conflict */ INSERT INTO x (x, x) VALUES ('[1,2)', DATEMULTIRANGE(DATERANGE('2010-01-01', '2020-01-01'))) ON CONFLICT(x, x) DO UPDATE SET x = x.x + '[3,4)';
/* date matches but no conflict */ INSERT INTO x (x, x) VALUES ('[2,3)', DATEMULTIRANGE(DATERANGE('2005-01-01', '2006-01-01'))) ON CONFLICT(x, x) DO UPDATE SET x = x.x + '[4,5)';
SELECT * FROM x ORDER BY x NULLS LAST, x NULLS LAST;
TRUNCATE TABLE x;
INSERT INTO x (x, x) VALUES ('[1,2)', DATEMULTIRANGE(DATERANGE('2000-01-01', '2010-01-01')));
/* with a conflict */ INSERT INTO x (x, x) VALUES ('[1,2)', DATEMULTIRANGE(DATERANGE('2005-01-01', '2006-01-01'))) ON CONFLICT ON CONSTRAINT x DO UPDATE SET x = x.x + '[2,3)';
/* id matches but no conflict */ INSERT INTO x (x, x) VALUES ('[1,2)', DATEMULTIRANGE(DATERANGE('2010-01-01', '2020-01-01'))) ON CONFLICT ON CONSTRAINT x DO UPDATE SET x = x.x + '[3,4)';
/* date matches but no conflict */ INSERT INTO x (x, x) VALUES ('[2,3)', DATEMULTIRANGE(DATERANGE('2005-01-01', '2006-01-01'))) ON CONFLICT ON CONSTRAINT x DO UPDATE SET x = x.x + '[4,5)';
SELECT * FROM x ORDER BY x NULLS LAST, x NULLS LAST;
DROP TABLE x;
ALTER TABLE x DROP COLUMN x;
ALTER TABLE x DROP COLUMN x CASCADE;
DROP TABLE x;
DROP TABLE x;
/* test FOREIGN KEY, range references range */ /* test table setup */ DROP TABLE x;
CREATE TABLE x (x INT4RANGE, x DATERANGE);
DROP TABLE x;
DROP TABLE x;
/* Two scalar columns */ DROP TABLE x;
ALTER TABLE x ALTER COLUMN x SET DATA TYPE DATERANGE USING DATERANGE(CAST(LOWER(x) AS DATE), CAST(UPPER(x) AS DATE));
/* test with rows already */ DELETE FROM x;
DELETE FROM x;
INSERT INTO x (x, x) VALUES ('[1,2)', DATERANGE('2018-01-02', '2018-02-03')), ('[1,2)', DATERANGE('2018-03-03', '2018-04-04')), ('[2,3)', DATERANGE('2018-01-01', '2018-01-05')), ('[3,4)', DATERANGE('2018-01-01', NULL));
ALTER TABLE x DROP CONSTRAINT x;
INSERT INTO x (x, x, x) VALUES ('[1,2)', DATERANGE('2018-01-02', '2018-02-01'), '[1,2)');
ALTER TABLE x DROP CONSTRAINT x;
INSERT INTO x (x, x, x) VALUES ('[2,3)', DATERANGE('2018-01-02', '2018-04-01'), '[1,2)');
/* okay again: */ DELETE FROM x;
/* test pg_get_constraintdef */ SELECT PG_GET_CONSTRAINTDEF(x) FROM x WHERE x = 'temporal_fk_rng2rng_fk';
/* test FK referencing inserts */ INSERT INTO x (x, x, x) VALUES ('[1,2)', DATERANGE('2018-01-02', '2018-02-01'), '[1,2)');
/* should fail: */ INSERT INTO x (x, x, x) VALUES ('[2,3)', DATERANGE('2018-01-02', '2018-04-01'), '[1,2)');
/* now it should work: */ INSERT INTO x (x, x) VALUES ('[1,2)', DATERANGE('2018-02-03', '2018-03-03'));
INSERT INTO x (x, x, x) VALUES ('[2,3)', DATERANGE('2018-01-02', '2018-04-01'), '[1,2)');
/* test FK referencing updates */ /* slide the edge across a referenced transition: */ UPDATE x SET x = DATERANGE('2018-01-02', '2018-02-20') WHERE x = '[1,2)';
/* should fail: */ UPDATE x SET x = DATERANGE('2018-01-02', '2018-05-01') WHERE x = '[1,2)';
UPDATE x SET x = '[8,9)' WHERE x = '[1,2)';
/* ALTER FK DEFERRABLE */ BEGIN;
INSERT INTO x (x, x) VALUES ('[5,6)', DATERANGE('2018-01-01', '2018-02-01')), ('[5,6)', DATERANGE('2018-02-01', '2018-03-01'));
INSERT INTO x (x, x, x) VALUES ('[3,4)', DATERANGE('2018-01-05', '2018-01-10'), '[5,6)');
ALTER TABLE temporal_fk_rng2rng     ALTER CONSTRAINT temporal_fk_rng2rng_fk     DEFERRABLE INITIALLY DEFERRED;
DELETE FROM x WHERE x = '[5,6)';
COMMIT /* should not fail yet. */ /* should not fail yet. */;
TRUNCATE TABLE x, x /* should fail here. */ /* test FK referenced updates NO ACTION */;
ALTER TABLE x DROP CONSTRAINT x;
/* a PK update that succeeds because the numeric id isn't referenced: */ INSERT INTO x (x, x) VALUES ('[5,6)', DATERANGE('2018-01-01', '2018-02-01'));
UPDATE x SET x = DATERANGE('2016-01-01', '2016-02-01') WHERE x = '[5,6)';
/* a PK update that succeeds even though the numeric id is referenced because the range isn't: */ DELETE FROM x WHERE x = '[5,6)';
INSERT INTO x (x, x) VALUES ('[5,6)', DATERANGE('2018-01-01', '2018-02-01')), ('[5,6)', DATERANGE('2018-02-01', '2018-03-01'));
INSERT INTO x (x, x, x) VALUES ('[3,4)', DATERANGE('2018-01-05', '2018-01-10'), '[5,6)');
UPDATE x SET x = DATERANGE('2016-02-01', '2016-03-01') WHERE x = '[5,6)' AND x = DATERANGE('2018-02-01', '2018-03-01');
/* A PK update sliding the edge between two referenced rows: */ INSERT INTO x (x, x) VALUES ('[6,7)', DATERANGE('2018-01-01', '2018-02-01')), ('[6,7)', DATERANGE('2018-02-01', '2018-03-01'));
INSERT INTO x (x, x, x) VALUES ('[4,5)', DATERANGE('2018-01-15', '2018-02-15'), '[6,7)');
UPDATE x SET x = CASE WHEN LOWER(x) = '2018-01-01' THEN DATERANGE('2018-01-01', '2018-01-05') WHEN LOWER(x) = '2018-02-01' THEN DATERANGE('2018-01-05', '2018-03-01') END WHERE x = '[6,7)';
/* a PK update shrinking the referenced range but still valid: */ /* There are two references: one fulfilled by the first pk row, */ /* the other fulfilled by both pk rows combined. */ INSERT INTO x (x, x) VALUES ('[1,2)', DATERANGE('2018-01-01', '2018-03-01')), ('[1,2)', DATERANGE('2018-03-01', '2018-06-01'));
INSERT INTO x (x, x, x) VALUES ('[1,2)', DATERANGE('2018-01-15', '2018-02-01'), '[1,2)'), ('[2,3)', DATERANGE('2018-01-15', '2018-05-01'), '[1,2)');
UPDATE x SET x = DATERANGE('2018-01-15', '2018-03-01') WHERE x = '[1,2)' AND x @> CAST('2018-01-15' AS DATE);
/* a PK update growing the referenced range is fine: */ UPDATE x SET x = DATERANGE('2018-01-01', '2018-03-01') WHERE x = '[1,2)' AND x @> CAST('2018-01-25' AS DATE);
/* a PK update shrinking the referenced range and changing the id invalidates the whole range (error): */ UPDATE x SET x = '[2,3)', x = DATERANGE('2018-01-15', '2018-03-01') WHERE x = '[1,2)' AND x @> CAST('2018-01-15' AS DATE);
/* a PK update changing only the id invalidates the whole range (error): */ UPDATE x SET x = '[2,3)' WHERE x = '[1,2)' AND x @> CAST('2018-01-15' AS DATE);
/* a PK update that loses time from both ends, but is still valid: */ INSERT INTO x (x, x) VALUES ('[2,3)', DATERANGE('2018-01-01', '2018-03-01'));
INSERT INTO x (x, x, x) VALUES ('[5,6)', DATERANGE('2018-01-15', '2018-02-01'), '[2,3)');
UPDATE x SET x = DATERANGE('2018-01-15', '2018-02-15') WHERE x = '[2,3)';
/* a PK update that fails because both are referenced: */ UPDATE x SET x = DATERANGE('2016-01-01', '2016-02-01') WHERE x = '[5,6)' AND x = DATERANGE('2018-01-01', '2018-02-01');
/* a PK update that fails because both are referenced, but not 'til commit: */ BEGIN;
ALTER TABLE temporal_fk_rng2rng     ALTER CONSTRAINT temporal_fk_rng2rng_fk     DEFERRABLE INITIALLY DEFERRED;
UPDATE x SET x = DATERANGE('2016-01-01', '2016-02-01') WHERE x = '[5,6)' AND x = DATERANGE('2018-01-01', '2018-02-01');
COMMIT;
/* changing the scalar part fails: */ UPDATE x SET x = '[7,8)' WHERE x = '[5,6)' AND x = DATERANGE('2018-01-01', '2018-02-01');
/* then delete the objecting FK record and the same PK update succeeds: */ DELETE FROM x WHERE x = '[3,4)';
UPDATE x SET x = DATERANGE('2016-01-01', '2016-02-01') WHERE x = '[5,6)' AND x = DATERANGE('2018-01-01', '2018-02-01');
TRUNCATE TABLE x, x /* test FK referenced updates RESTRICT */;
ALTER TABLE x DROP CONSTRAINT x;
TRUNCATE TABLE x, x /* test FK referenced deletes NO ACTION */;
/* a PK delete that succeeds because the numeric id isn't referenced: */ INSERT INTO x (x, x) VALUES ('[5,6)', DATERANGE('2018-01-01', '2018-02-01'));
DELETE FROM x WHERE x = '[5,6)';
/* a PK delete that succeeds even though the numeric id is referenced because the range isn't: */ INSERT INTO x (x, x) VALUES ('[5,6)', DATERANGE('2018-01-01', '2018-02-01')), ('[5,6)', DATERANGE('2018-02-01', '2018-03-01'));
INSERT INTO x (x, x, x) VALUES ('[3,4)', DATERANGE('2018-01-05', '2018-01-10'), '[5,6)');
DELETE FROM x WHERE x = '[5,6)' AND x = DATERANGE('2018-02-01', '2018-03-01');
/* a PK delete that fails because both are referenced: */ DELETE FROM x WHERE x = '[5,6)' AND x = DATERANGE('2018-01-01', '2018-02-01');
/* a PK delete that fails because both are referenced, but not 'til commit: */ BEGIN;
ALTER TABLE temporal_fk_rng2rng     ALTER CONSTRAINT temporal_fk_rng2rng_fk     DEFERRABLE INITIALLY DEFERRED;
DELETE FROM x WHERE x = '[5,6)' AND x = DATERANGE('2018-01-01', '2018-02-01');
COMMIT;
/* then delete the objecting FK record and the same PK delete succeeds: */ DELETE FROM x WHERE x = '[3,4)';
DELETE FROM x WHERE x = '[5,6)' AND x = DATERANGE('2018-01-01', '2018-02-01');
TRUNCATE TABLE x, x /* test FK referenced deletes RESTRICT */;
ALTER TABLE x DROP CONSTRAINT x;
/* test ON UPDATE/DELETE options */ /* test FK referenced updates CASCADE */ INSERT INTO x (x, x) VALUES ('[6,7)', DATERANGE('2018-01-01', '2021-01-01'));
INSERT INTO x (x, x, x) VALUES ('[4,5)', DATERANGE('2018-01-01', '2021-01-01'), '[6,7)');
/* test FK referenced updates SET NULL */ INSERT INTO x (x, x) VALUES ('[9,10)', DATERANGE('2018-01-01', '2021-01-01'));
INSERT INTO x (x, x, x) VALUES ('[6,7)', DATERANGE('2018-01-01', '2021-01-01'), '[9,10)');
/* test FK referenced updates SET DEFAULT */ INSERT INTO x (x, x) VALUES ('[-1,-1]', DATERANGE(NULL, NULL));
INSERT INTO x (x, x) VALUES ('[12,13)', DATERANGE('2018-01-01', '2021-01-01'));
INSERT INTO x (x, x, x) VALUES ('[8,9)', DATERANGE('2018-01-01', '2021-01-01'), '[12,13)');
ALTER TABLE temporal_fk_rng2rng   ALTER COLUMN parent_id SET DEFAULT '[-1,-1]',   ADD CONSTRAINT temporal_fk_rng2rng_fk     FOREIGN KEY (parent_id, PERIOD valid_at)     REFERENCES temporal_rng     ON DELETE SET DEFAULT ON UPDATE SET DEFAULT;
/* test FOREIGN KEY, multirange references multirange */ /* test table setup */ DROP TABLE x;
CREATE TABLE x (x INT4RANGE, x DATEMULTIRANGE);
DROP TABLE x;
DROP TABLE x;
/* Two scalar columns */ DROP TABLE x;
/* test with rows already */ DELETE FROM x;
INSERT INTO x (x, x) VALUES ('[1,2)', DATEMULTIRANGE(DATERANGE('2018-01-02', '2018-02-03'))), ('[1,2)', DATEMULTIRANGE(DATERANGE('2018-03-03', '2018-04-04'))), ('[2,3)', DATEMULTIRANGE(DATERANGE('2018-01-01', '2018-01-05'))), ('[3,4)', DATEMULTIRANGE(DATERANGE('2018-01-01', NULL)));
ALTER TABLE x DROP CONSTRAINT x;
INSERT INTO x (x, x, x) VALUES ('[1,2)', DATEMULTIRANGE(DATERANGE('2018-01-02', '2018-02-01')), '[1,2)');
ALTER TABLE x DROP CONSTRAINT x;
INSERT INTO x (x, x, x) VALUES ('[2,3)', DATEMULTIRANGE(DATERANGE('2018-01-02', '2018-04-01')), '[1,2)');
/* okay again: */ DELETE FROM x;
/* test pg_get_constraintdef */ SELECT PG_GET_CONSTRAINTDEF(x) FROM x WHERE x = 'temporal_fk_mltrng2mltrng_fk';
/* test FK referencing inserts */ INSERT INTO x (x, x, x) VALUES ('[1,2)', DATEMULTIRANGE(DATERANGE('2018-01-02', '2018-02-01')), '[1,2)');
/* should fail: */ INSERT INTO x (x, x, x) VALUES ('[2,3)', DATEMULTIRANGE(DATERANGE('2018-01-02', '2018-04-01')), '[1,2)');
/* now it should work: */ INSERT INTO x (x, x) VALUES ('[1,2)', DATEMULTIRANGE(DATERANGE('2018-02-03', '2018-03-03')));
INSERT INTO x (x, x, x) VALUES ('[2,3)', DATEMULTIRANGE(DATERANGE('2018-01-02', '2018-04-01')), '[1,2)');
/* test FK referencing updates */ /* slide the edge across a referenced transition: */ UPDATE x SET x = DATEMULTIRANGE(DATERANGE('2018-01-02', '2018-02-20')) WHERE x = '[1,2)';
/* should fail: */ UPDATE x SET x = DATEMULTIRANGE(DATERANGE('2018-01-02', '2018-05-01')) WHERE x = '[1,2)';
UPDATE x SET x = '[8,9)' WHERE x = '[1,2)';
/* ALTER FK DEFERRABLE */ BEGIN;
INSERT INTO x (x, x) VALUES ('[5,6)', DATEMULTIRANGE(DATERANGE('2018-01-01', '2018-02-01'))), ('[5,6)', DATEMULTIRANGE(DATERANGE('2018-02-01', '2018-03-01')));
INSERT INTO x (x, x, x) VALUES ('[3,4)', DATEMULTIRANGE(DATERANGE('2018-01-05', '2018-01-10')), '[5,6)');
ALTER TABLE temporal_fk_mltrng2mltrng     ALTER CONSTRAINT temporal_fk_mltrng2mltrng_fk     DEFERRABLE INITIALLY DEFERRED;
DELETE FROM x WHERE x = '[5,6)';
COMMIT /* should not fail yet. */ /* should not fail yet. */;
TRUNCATE TABLE x, x /* should fail here. */ /* test FK referenced updates NO ACTION */;
ALTER TABLE x DROP CONSTRAINT x;
/* a PK update that succeeds because the numeric id isn't referenced: */ INSERT INTO x (x, x) VALUES ('[5,6)', DATEMULTIRANGE(DATERANGE('2018-01-01', '2018-02-01')));
UPDATE x SET x = DATEMULTIRANGE(DATERANGE('2016-01-01', '2016-02-01')) WHERE x = '[5,6)';
/* a PK update that succeeds even though the numeric id is referenced because the range isn't: */ DELETE FROM x WHERE x = '[5,6)';
INSERT INTO x (x, x) VALUES ('[5,6)', DATEMULTIRANGE(DATERANGE('2018-01-01', '2018-02-01'))), ('[5,6)', DATEMULTIRANGE(DATERANGE('2018-02-01', '2018-03-01')));
INSERT INTO x (x, x, x) VALUES ('[3,4)', DATEMULTIRANGE(DATERANGE('2018-01-05', '2018-01-10')), '[5,6)');
UPDATE x SET x = DATEMULTIRANGE(DATERANGE('2016-02-01', '2016-03-01')) WHERE x = '[5,6)' AND x = DATEMULTIRANGE(DATERANGE('2018-02-01', '2018-03-01'));
/* A PK update sliding the edge between two referenced rows: */ INSERT INTO x (x, x) VALUES ('[6,7)', DATEMULTIRANGE(DATERANGE('2018-01-01', '2018-02-01'))), ('[6,7)', DATEMULTIRANGE(DATERANGE('2018-02-01', '2018-03-01')));
INSERT INTO x (x, x, x) VALUES ('[4,5)', DATEMULTIRANGE(DATERANGE('2018-01-15', '2018-02-15')), '[6,7)');
UPDATE x SET x = CASE WHEN LOWER(x) = '2018-01-01' THEN DATEMULTIRANGE(DATERANGE('2018-01-01', '2018-01-05')) WHEN LOWER(x) = '2018-02-01' THEN DATEMULTIRANGE(DATERANGE('2018-01-05', '2018-03-01')) END WHERE x = '[6,7)';
/* a PK update shrinking the referenced multirange but still valid: */ /* There are two references: one fulfilled by the first pk row, */ /* the other fulfilled by both pk rows combined. */ INSERT INTO x (x, x) VALUES ('[1,2)', DATEMULTIRANGE(DATERANGE('2018-01-01', '2018-03-01'))), ('[1,2)', DATEMULTIRANGE(DATERANGE('2018-03-01', '2018-06-01')));
INSERT INTO x (x, x, x) VALUES ('[1,2)', DATEMULTIRANGE(DATERANGE('2018-01-15', '2018-02-01')), '[1,2)'), ('[2,3)', DATEMULTIRANGE(DATERANGE('2018-01-15', '2018-05-01')), '[1,2)');
UPDATE x SET x = DATEMULTIRANGE(DATERANGE('2018-01-15', '2018-03-01')) WHERE x = '[1,2)' AND x @> CAST('2018-01-15' AS DATE);
/* a PK update growing the referenced multirange is fine: */ UPDATE x SET x = DATEMULTIRANGE(DATERANGE('2018-01-01', '2018-03-01')) WHERE x = '[1,2)' AND x @> CAST('2018-01-25' AS DATE);
/* a PK update shrinking the referenced multirange and changing the id invalidates the whole multirange (error): */ UPDATE x SET x = '[2,3)', x = DATEMULTIRANGE(DATERANGE('2018-01-15', '2018-03-01')) WHERE x = '[1,2)' AND x @> CAST('2018-01-15' AS DATE);
/* a PK update changing only the id invalidates the whole multirange (error): */ UPDATE x SET x = '[2,3)' WHERE x = '[1,2)' AND x @> CAST('2018-01-15' AS DATE);
/* a PK update that loses time from both ends, but is still valid: */ INSERT INTO x (x, x) VALUES ('[2,3)', DATEMULTIRANGE(DATERANGE('2018-01-01', '2018-03-01')));
INSERT INTO x (x, x, x) VALUES ('[5,6)', DATEMULTIRANGE(DATERANGE('2018-01-15', '2018-02-01')), '[2,3)');
UPDATE x SET x = DATEMULTIRANGE(DATERANGE('2018-01-15', '2018-02-15')) WHERE x = '[2,3)';
/* a PK update that fails because both are referenced: */ UPDATE x SET x = DATEMULTIRANGE(DATERANGE('2016-01-01', '2016-02-01')) WHERE x = '[5,6)' AND x = DATEMULTIRANGE(DATERANGE('2018-01-01', '2018-02-01'));
/* a PK update that fails because both are referenced, but not 'til commit: */ BEGIN;
ALTER TABLE temporal_fk_mltrng2mltrng     ALTER CONSTRAINT temporal_fk_mltrng2mltrng_fk     DEFERRABLE INITIALLY DEFERRED;
UPDATE x SET x = DATEMULTIRANGE(DATERANGE('2016-01-01', '2016-02-01')) WHERE x = '[5,6)' AND x = DATEMULTIRANGE(DATERANGE('2018-01-01', '2018-02-01'));
COMMIT;
/* changing the scalar part fails: */ UPDATE x SET x = '[7,8)' WHERE x = '[5,6)' AND x = DATEMULTIRANGE(DATERANGE('2018-01-01', '2018-02-01'));
TRUNCATE TABLE x, x /* test FK referenced updates RESTRICT */;
ALTER TABLE x DROP CONSTRAINT x;
TRUNCATE TABLE x, x /* test FK referenced deletes NO ACTION */;
/* a PK delete that succeeds because the numeric id isn't referenced: */ INSERT INTO x (x, x) VALUES ('[5,6)', DATEMULTIRANGE(DATERANGE('2018-01-01', '2018-02-01')));
DELETE FROM x WHERE x = '[5,6)';
/* a PK delete that succeeds even though the numeric id is referenced because the range isn't: */ INSERT INTO x (x, x) VALUES ('[5,6)', DATEMULTIRANGE(DATERANGE('2018-01-01', '2018-02-01'))), ('[5,6)', DATEMULTIRANGE(DATERANGE('2018-02-01', '2018-03-01')));
INSERT INTO x (x, x, x) VALUES ('[3,4)', DATEMULTIRANGE(DATERANGE('2018-01-05', '2018-01-10')), '[5,6)');
DELETE FROM x WHERE x = '[5,6)' AND x = DATEMULTIRANGE(DATERANGE('2018-02-01', '2018-03-01'));
/* a PK delete that fails because both are referenced: */ DELETE FROM x WHERE x = '[5,6)' AND x = DATEMULTIRANGE(DATERANGE('2018-01-01', '2018-02-01'));
/* a PK delete that fails because both are referenced, but not 'til commit: */ BEGIN;
ALTER TABLE temporal_fk_mltrng2mltrng     ALTER CONSTRAINT temporal_fk_mltrng2mltrng_fk     DEFERRABLE INITIALLY DEFERRED;
DELETE FROM x WHERE x = '[5,6)' AND x = DATEMULTIRANGE(DATERANGE('2018-01-01', '2018-02-01'));
COMMIT;
CREATE TABLE x PARTITION OF x FOR VALUES IN ('[1,2)', '[3,4)', '[5,6)', '[7,8)', '[9,10)', '[11,12)');
CREATE TABLE x PARTITION OF x FOR VALUES IN ('[2,3)', '[4,5)', '[6,7)', '[8,9)', '[10,11)', '[12,13)');
INSERT INTO x (x, x, x) VALUES ('[1,2)', DATERANGE('2000-01-01', '2000-02-01'), 'one'), ('[1,2)', DATERANGE('2000-02-01', '2000-03-01'), 'one'), ('[2,3)', DATERANGE('2000-01-01', '2010-01-01'), 'two');
CREATE TABLE x PARTITION OF x FOR VALUES IN ('[1,2)', '[3,4)', '[5,6)', '[7,8)', '[9,10)', '[11,12)');
CREATE TABLE x PARTITION OF x FOR VALUES IN ('[2,3)', '[4,5)', '[6,7)', '[8,9)', '[10,11)', '[12,13)');
/* partitioned FK referencing inserts */ INSERT INTO x (x, x, x) VALUES ('[1,2)', DATERANGE('2000-01-01', '2000-02-15'), '[1,2)'), ('[1,2)', DATERANGE('2001-01-01', '2002-01-01'), '[2,3)'), ('[2,3)', DATERANGE('2000-01-01', '2000-02-15'), '[1,2)');
/* should fail: */ INSERT INTO x (x, x, x) VALUES ('[3,4)', DATERANGE('2010-01-01', '2010-02-15'), '[1,2)');
INSERT INTO x (x, x, x) VALUES ('[3,4)', DATERANGE('2000-01-01', '2000-02-15'), '[3,4)');
/* partitioned FK referencing updates */ UPDATE x SET x = DATERANGE('2000-01-01', '2000-02-13') WHERE x = '[2,3)';
/* move a row from the first partition to the second */ UPDATE x SET x = '[4,5)' WHERE x = '[1,2)';
/* move a row from the second partition to the first */ UPDATE x SET x = '[1,2)' WHERE x = '[4,5)';
/* should fail: */ UPDATE x SET x = DATERANGE('2000-01-01', '2000-04-01') WHERE x = '[1,2)';
TRUNCATE TABLE x, x /* partitioned FK referenced updates NO ACTION */;
INSERT INTO x (x, x) VALUES ('[5,6)', DATERANGE('2016-01-01', '2016-02-01'));
UPDATE x SET x = DATERANGE('2018-01-01', '2018-02-01') WHERE x = '[5,6)';
INSERT INTO x (x, x) VALUES ('[5,6)', DATERANGE('2018-02-01', '2018-03-01'));
INSERT INTO x (x, x, x) VALUES ('[3,4)', DATERANGE('2018-01-05', '2018-01-10'), '[5,6)');
UPDATE x SET x = DATERANGE('2016-02-01', '2016-03-01') WHERE x = '[5,6)' AND x = DATERANGE('2018-02-01', '2018-03-01');
/* should fail: */ UPDATE x SET x = DATERANGE('2016-01-01', '2016-02-01') WHERE x = '[5,6)' AND x = DATERANGE('2018-01-01', '2018-02-01');
TRUNCATE TABLE x, x /* partitioned FK referenced deletes NO ACTION */;
INSERT INTO x (x, x) VALUES ('[5,6)', DATERANGE('2018-01-01', '2018-02-01'));
INSERT INTO x (x, x) VALUES ('[5,6)', DATERANGE('2018-02-01', '2018-03-01'));
INSERT INTO x (x, x, x) VALUES ('[3,4)', DATERANGE('2018-01-05', '2018-01-10'), '[5,6)');
DELETE FROM x WHERE x = '[5,6)' AND x = DATERANGE('2018-02-01', '2018-03-01');
/* should fail: */ DELETE FROM x WHERE x = '[5,6)' AND x = DATERANGE('2018-01-01', '2018-02-01');
/* partitioned FK referenced updates CASCADE */ ALTER TABLE temporal_partitioned_fk_rng2rng   DROP CONSTRAINT temporal_partitioned_fk_rng2rng_fk,   ADD CONSTRAINT temporal_partitioned_fk_rng2rng_fk     FOREIGN KEY (parent_id, PERIOD valid_at)     REFERENCES temporal_partitioned_rng     ON DELETE CASCADE ON UPDATE CASCADE;
/* partitioned FK referenced deletes CASCADE */ /* partitioned FK referenced updates SET NULL */ ALTER TABLE temporal_partitioned_fk_rng2rng   DROP CONSTRAINT temporal_partitioned_fk_rng2rng_fk,   ADD CONSTRAINT temporal_partitioned_fk_rng2rng_fk     FOREIGN KEY (parent_id, PERIOD valid_at)     REFERENCES temporal_partitioned_rng     ON DELETE SET NULL ON UPDATE SET NULL;
/* partitioned FK referenced deletes SET NULL */ /* partitioned FK referenced updates SET DEFAULT */ ALTER TABLE temporal_partitioned_fk_rng2rng   ALTER COLUMN parent_id SET DEFAULT '[-1,-1]',   DROP CONSTRAINT temporal_partitioned_fk_rng2rng_fk,   ADD CONSTRAINT temporal_partitioned_fk_rng2rng_fk     FOREIGN KEY (parent_id, PERIOD valid_at)     REFERENCES temporal_partitioned_rng     ON DELETE SET DEFAULT ON UPDATE SET DEFAULT;
/* partitioned FK referenced deletes SET DEFAULT */ DROP TABLE x;
DROP TABLE x;
CREATE TABLE x PARTITION OF x FOR VALUES IN ('[1,2)', '[3,4)', '[5,6)', '[7,8)', '[9,10)', '[11,12)', '[13,14)', '[15,16)', '[17,18)', '[19,20)', '[21,22)', '[23,24)');
CREATE TABLE x PARTITION OF x FOR VALUES IN ('[0,1)', '[2,3)', '[4,5)', '[6,7)', '[8,9)', '[10,11)', '[12,13)', '[14,15)', '[16,17)', '[18,19)', '[20,21)', '[22,23)', '[24,25)');
INSERT INTO x (x, x, x) VALUES ('[1,2)', DATEMULTIRANGE(DATERANGE('2000-01-01', '2000-02-01')), 'one'), ('[1,2)', DATEMULTIRANGE(DATERANGE('2000-02-01', '2000-03-01')), 'one'), ('[2,3)', DATEMULTIRANGE(DATERANGE('2000-01-01', '2010-01-01')), 'two');
CREATE TABLE x PARTITION OF x FOR VALUES IN ('[1,2)', '[3,4)', '[5,6)', '[7,8)', '[9,10)', '[11,12)', '[13,14)', '[15,16)', '[17,18)', '[19,20)', '[21,22)', '[23,24)');
CREATE TABLE x PARTITION OF x FOR VALUES IN ('[0,1)', '[2,3)', '[4,5)', '[6,7)', '[8,9)', '[10,11)', '[12,13)', '[14,15)', '[16,17)', '[18,19)', '[20,21)', '[22,23)', '[24,25)');
/* partitioned FK referencing inserts */ INSERT INTO x (x, x, x) VALUES ('[1,2)', DATEMULTIRANGE(DATERANGE('2000-01-01', '2000-02-15')), '[1,2)'), ('[1,2)', DATEMULTIRANGE(DATERANGE('2001-01-01', '2002-01-01')), '[2,3)'), ('[2,3)', DATEMULTIRANGE(DATERANGE('2000-01-01', '2000-02-15')), '[1,2)');
/* should fail: */ INSERT INTO x (x, x, x) VALUES ('[3,4)', DATEMULTIRANGE(DATERANGE('2010-01-01', '2010-02-15')), '[1,2)');
INSERT INTO x (x, x, x) VALUES ('[3,4)', DATEMULTIRANGE(DATERANGE('2000-01-01', '2000-02-15')), '[3,4)');
/* partitioned FK referencing updates */ UPDATE x SET x = DATEMULTIRANGE(DATERANGE('2000-01-01', '2000-02-13')) WHERE x = '[2,3)';
/* move a row from the first partition to the second */ UPDATE x SET x = '[4,5)' WHERE x = '[1,2)';
/* move a row from the second partition to the first */ UPDATE x SET x = '[1,2)' WHERE x = '[4,5)';
/* should fail: */ UPDATE x SET x = DATEMULTIRANGE(DATERANGE('2000-01-01', '2000-04-01')) WHERE x = '[1,2)';
TRUNCATE TABLE x, x /* partitioned FK referenced updates NO ACTION */;
INSERT INTO x (x, x) VALUES ('[5,6)', DATEMULTIRANGE(DATERANGE('2016-01-01', '2016-02-01')));
UPDATE x SET x = DATEMULTIRANGE(DATERANGE('2018-01-01', '2018-02-01')) WHERE x = '[5,6)';
INSERT INTO x (x, x) VALUES ('[5,6)', DATEMULTIRANGE(DATERANGE('2018-02-01', '2018-03-01')));
INSERT INTO x (x, x, x) VALUES ('[3,4)', DATEMULTIRANGE(DATERANGE('2018-01-05', '2018-01-10')), '[5,6)');
UPDATE x SET x = DATEMULTIRANGE(DATERANGE('2016-02-01', '2016-03-01')) WHERE x = '[5,6)' AND x = DATEMULTIRANGE(DATERANGE('2018-02-01', '2018-03-01'));
/* should fail: */ UPDATE x SET x = DATEMULTIRANGE(DATERANGE('2016-01-01', '2016-02-01')) WHERE x = '[5,6)' AND x = DATEMULTIRANGE(DATERANGE('2018-01-01', '2018-02-01'));
TRUNCATE TABLE x, x /* partitioned FK referenced deletes NO ACTION */;
INSERT INTO x (x, x) VALUES ('[5,6)', DATEMULTIRANGE(DATERANGE('2018-01-01', '2018-02-01')));
INSERT INTO x (x, x) VALUES ('[5,6)', DATEMULTIRANGE(DATERANGE('2018-02-01', '2018-03-01')));
INSERT INTO x (x, x, x) VALUES ('[3,4)', DATEMULTIRANGE(DATERANGE('2018-01-05', '2018-01-10')), '[5,6)');
DELETE FROM x WHERE x = '[5,6)' AND x = DATEMULTIRANGE(DATERANGE('2018-02-01', '2018-03-01'));
/* should fail: */ DELETE FROM x WHERE x = '[5,6)' AND x = DATEMULTIRANGE(DATERANGE('2018-01-01', '2018-02-01'));
/* partitioned FK referenced updates CASCADE */ ALTER TABLE temporal_partitioned_fk_mltrng2mltrng   DROP CONSTRAINT temporal_partitioned_fk_mltrng2mltrng_fk,   ADD CONSTRAINT temporal_partitioned_fk_mltrng2mltrng_fk     FOREIGN KEY (parent_id, PERIOD valid_at)     REFERENCES temporal_partitioned_mltrng     ON DELETE CASCADE ON UPDATE CASCADE;
/* partitioned FK referenced deletes CASCADE */ /* partitioned FK referenced updates SET NULL */ ALTER TABLE temporal_partitioned_fk_mltrng2mltrng   DROP CONSTRAINT temporal_partitioned_fk_mltrng2mltrng_fk,   ADD CONSTRAINT temporal_partitioned_fk_mltrng2mltrng_fk     FOREIGN KEY (parent_id, PERIOD valid_at)     REFERENCES temporal_partitioned_mltrng     ON DELETE SET NULL ON UPDATE SET NULL;
/* partitioned FK referenced deletes SET NULL */ /* partitioned FK referenced updates SET DEFAULT */ ALTER TABLE temporal_partitioned_fk_mltrng2mltrng   ALTER COLUMN parent_id SET DEFAULT '[0,1)',   DROP CONSTRAINT temporal_partitioned_fk_mltrng2mltrng_fk,   ADD CONSTRAINT temporal_partitioned_fk_mltrng2mltrng_fk     FOREIGN KEY (parent_id, PERIOD valid_at)     REFERENCES temporal_partitioned_mltrng     ON DELETE SET DEFAULT ON UPDATE SET DEFAULT;
/* partitioned FK referenced deletes SET DEFAULT */ DROP TABLE x;
DROP TABLE x;
RESET datestyle;
/* PARALLEL */ BEGIN;
SET x = 0 /* encourage use of parallel plans */;
SET x = 0;
SET x = 0;
SET x = 4;
/* Test write operations that has an underlying query that is eligible */ /* for parallel plans */ EXPLAIN (costs off) create table parallel_write as     select length(stringu1) from tenk1 group by length(stringu1);
CREATE TABLE x AS SELECT LENGTH(x) FROM x GROUP BY LENGTH(x);
DROP TABLE x;
EXPLAIN (costs off) select length(stringu1) into parallel_write     from tenk1 group by length(stringu1);
CREATE TABLE x AS SELECT LENGTH(x) FROM x GROUP BY LENGTH(x);
DROP TABLE x;
EXPLAIN (costs off) create materialized view parallel_mat_view as     select length(stringu1) from tenk1 group by length(stringu1);
CREATE MATERIALIZED VIEW x AS SELECT LENGTH(x) FROM x GROUP BY LENGTH(x);
CREATE UNIQUE INDEX ON x(x NULLS LAST);
REFRESH materialized view parallel_mat_view;
REFRESH materialized view concurrently parallel_mat_view;
DROP MATERIALIZED VIEW x;
PREPARE prep_stmt as select length(stringu1) from tenk1 group by length(stringu1);
EXPLAIN (costs off) create table parallel_write as execute prep_stmt;
CREATE TABLE x EXECUTE AS prep_stmt;
DROP TABLE x;
ROLLBACK;
/* xid and xid8 */ /* values in range, in octal, decimal, hex */ SELECT CAST('010' AS xid), CAST('42' AS xid), CAST('0xffffffff' AS xid), CAST('-1' AS xid), CAST('010' AS xid8), CAST('42' AS xid8), CAST('0xffffffffffffffff' AS xid8), CAST('-1' AS xid8);
/* garbage values */ SELECT CAST('' AS xid);
SELECT CAST('asdf' AS xid);
SELECT CAST('' AS xid8);
SELECT CAST('asdf' AS xid8);
/* Also try it with non-error-throwing API */ SELECT PG_INPUT_IS_VALID('42', 'xid');
SELECT PG_INPUT_IS_VALID('asdf', 'xid');
SELECT * FROM x;
SELECT PG_INPUT_IS_VALID('42', 'xid8');
SELECT PG_INPUT_IS_VALID('asdf', 'xid8');
SELECT * FROM x;
/* equality */ SELECT CAST('1' AS xid) = CAST('1' AS xid);
SELECT CAST('1' AS xid) <> CAST('1' AS xid);
SELECT CAST('1' AS xid8) = CAST('1' AS xid8);
SELECT CAST('1' AS xid8) <> CAST('1' AS xid8);
/* conversion */ SELECT CAST('1' AS xid) = CAST(CAST('1' AS xid8) AS xid);
SELECT CAST('1' AS xid) <> CAST(CAST('1' AS xid8) AS xid);
/* we don't want relational operators for xid, due to use of modular arithmetic */ SELECT CAST('1' AS xid) < CAST('2' AS xid);
SELECT CAST('1' AS xid) <= CAST('2' AS xid);
SELECT CAST('1' AS xid) > CAST('2' AS xid);
SELECT CAST('1' AS xid) >= CAST('2' AS xid);
/* we want them for xid8 though */ SELECT CAST('1' AS xid8) < CAST('2' AS xid8), CAST('2' AS xid8) < CAST('2' AS xid8), CAST('2' AS xid8) < CAST('1' AS xid8);
SELECT CAST('1' AS xid8) <= CAST('2' AS xid8), CAST('2' AS xid8) <= CAST('2' AS xid8), CAST('2' AS xid8) <= CAST('1' AS xid8);
SELECT CAST('1' AS xid8) > CAST('2' AS xid8), CAST('2' AS xid8) > CAST('2' AS xid8), CAST('2' AS xid8) > CAST('1' AS xid8);
SELECT CAST('1' AS xid8) >= CAST('2' AS xid8), CAST('2' AS xid8) >= CAST('2' AS xid8), CAST('2' AS xid8) >= CAST('1' AS xid8);
/* we also have a 3way compare for btrees */ SELECT XID8CMP('1', '2'), XID8CMP('2', '2'), XID8CMP('2', '1');
/* min() and max() for xid8 */ CREATE TABLE x (x xid8);
INSERT INTO x VALUES ('0'), ('010'), ('42'), ('0xffffffffffffffff'), ('-1');
SELECT MIN(x), MAX(x) FROM x;
/* xid8 has btree and hash opclasses */ CREATE INDEX ON x USING btree(x NULLS LAST);
CREATE INDEX ON x USING hash(x NULLS LAST);
DROP TABLE x;
/* pg_snapshot data type and related functions */ /* Note: another set of tests similar to this exists in txid.sql, for a limited */ /* time (the relevant functions share C code) */ /* i/o */ SELECT CAST('12:13:' AS pg_snapshot);
SELECT CAST('12:18:14,16' AS pg_snapshot);
SELECT CAST('12:16:14,14' AS pg_snapshot);
/* errors */ SELECT CAST('31:12:' AS pg_snapshot);
SELECT CAST('0:1:' AS pg_snapshot);
SELECT CAST('12:13:0' AS pg_snapshot);
SELECT CAST('12:16:14,13' AS pg_snapshot);
/* also try it with non-error-throwing API */ SELECT PG_INPUT_IS_VALID('12:13:', 'pg_snapshot');
SELECT PG_INPUT_IS_VALID('31:12:', 'pg_snapshot');
SELECT * FROM x;
SELECT PG_INPUT_IS_VALID('12:16:14,13', 'pg_snapshot');
SELECT * FROM x;
CREATE TEMPORARY TABLE x (x INT, x pg_snapshot);
INSERT INTO x VALUES (1, '12:13:');
INSERT INTO x VALUES (2, '12:20:13,15,18');
INSERT INTO x VALUES (3, '100001:100009:100005,100007,100008');
INSERT INTO x VALUES (4, '100:150:101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131');
SELECT x FROM x ORDER BY x NULLS LAST;
SELECT PG_SNAPSHOT_XMIN(x), PG_SNAPSHOT_XMAX(x), PG_SNAPSHOT_XIP(x) FROM x ORDER BY x NULLS LAST;
SELECT x, PG_VISIBLE_IN_SNAPSHOT(CAST(CAST(x AS TEXT) AS xid8), x) FROM x, x AS x WHERE x = 2;
/* test bsearch */ SELECT x, PG_VISIBLE_IN_SNAPSHOT(CAST(CAST(x AS TEXT) AS xid8), x) FROM x, x AS x WHERE x = 4;
/* test current values also */ SELECT PG_CURRENT_XACT_ID() >= PG_SNAPSHOT_XMIN(PG_CURRENT_SNAPSHOT());
/* we can't assume current is always less than xmax, however */ SELECT PG_VISIBLE_IN_SNAPSHOT(PG_CURRENT_XACT_ID(), PG_CURRENT_SNAPSHOT());
SELECT PG_VISIBLE_IN_SNAPSHOT('1000100010001012', '1000100010001000:1000100010001100:1000100010001012,1000100010001013');
SELECT PG_VISIBLE_IN_SNAPSHOT('1000100010001015', '1000100010001000:1000100010001100:1000100010001012,1000100010001013');
/* test pg_current_xact_id_if_assigned */ BEGIN;
SELECT PG_CURRENT_XACT_ID_IF_ASSIGNED() IS NULL;
COMMIT;
/* test xid status functions */ BEGIN;
BEGIN;
BEGIN;
SELECT PG_XACT_STATUS(CAST(CAST(:rolledback AS TEXT) AS xid8)) AS x;
SELECT PG_XACT_STATUS(CAST(CAST(:inprogress AS TEXT) AS xid8)) AS x;
SELECT PG_XACT_STATUS(CAST('1' AS xid8));
/* BootstrapTransactionId is always committed */ SELECT PG_XACT_STATUS(CAST('2' AS xid8));
/* FrozenTransactionId is always committed */ SELECT PG_XACT_STATUS(CAST('3' AS xid8));
COMMIT /* in regress testing FirstNormalTransactionId will always be behind oldestXmin */ /* in regress testing FirstNormalTransactionId will always be behind oldestXmin */;
BEGIN;
COMMIT;
SELECT TEST_FUTURE_XID_STATUS(CAST(CAST((:inprogress + 10000) AS TEXT) AS xid8));
ROLLBACK;
CREATE TABLE x (x INT, x xml);
INSERT INTO x VALUES (1, '<value>one</value>');
INSERT INTO x VALUES (2, '<value>two</value>');
INSERT INTO x VALUES (3, '<wrong');
SELECT * FROM x;
/* test non-throwing API, too */ SELECT PG_INPUT_IS_VALID('<value>one</value>', 'xml');
SELECT PG_INPUT_IS_VALID('<value>one</', 'xml');
SELECT x FROM x;
SELECT PG_INPUT_IS_VALID('<?xml version="1.0" standalone="y"?><foo/>', 'xml');
SELECT x FROM x;
SELECT XMLCOMMENT('test');
SELECT XMLCOMMENT('-test');
SELECT XMLCOMMENT('test-');
SELECT XMLCOMMENT('--test');
SELECT XMLCOMMENT('te st');
SELECT XMLCONCAT(XMLCOMMENT('hello'), XMLELEMENT(NAME x, 'foo'), XMLCOMMENT('world'));
SELECT XMLCONCAT('hello', 'you');
SELECT XMLCONCAT(1, 2);
SELECT XMLCONCAT('bad', '<syntax');
SELECT XMLCONCAT('<foo/>', NULL, '<?xml version="1.1" standalone="no"?><bar/>');
SELECT XMLCONCAT('<?xml version="1.1"?><foo/>', NULL, '<?xml version="1.1" standalone="no"?><bar/>');
SELECT XMLCONCAT(NULL);
SELECT XMLCONCAT(NULL, NULL);
SELECT XMLELEMENT(NAME x, XMLATTRIBUTES(1 AS x, 'deuce' AS x), 'content');
SELECT XMLELEMENT(NAME x, XMLATTRIBUTES('unnamed and wrong'));
SELECT XMLELEMENT(NAME x, XMLELEMENT(NAME x, 'stuff'));
SELECT XMLELEMENT(NAME x, XMLFOREST(x, x, x AS x)) FROM x;
SELECT XMLELEMENT(NAME x, XMLATTRIBUTES(1 AS x, 2 AS x, 3 AS x));
SELECT XMLELEMENT(NAME x, 37);
SELECT XMLELEMENT(NAME x, CAST('bar' AS TEXT));
SELECT XMLELEMENT(NAME x, CAST('b<a/>r' AS TEXT));
SELECT XMLELEMENT(NAME x, ARRAY(1, 2, 3));
SET x = base64;
SELECT XMLELEMENT(NAME x, CAST('bar' AS VARBINARY));
SET x = hex;
SELECT XMLELEMENT(NAME x, CAST('bar' AS VARBINARY));
SELECT XMLELEMENT(NAME x, XMLATTRIBUTES(TRUE AS x));
SELECT XMLELEMENT(NAME x, XMLATTRIBUTES(CAST('2009-04-09 00:24:37' AS TIMESTAMP) AS x));
SELECT XMLELEMENT(NAME x, XMLATTRIBUTES(CAST('infinity' AS TIMESTAMP) AS x));
SELECT XMLAGG(x) FROM x;
SELECT XMLAGG(x) FROM x WHERE x > 10;
SELECT XMLELEMENT(NAME x, XMLAGG(XMLELEMENT(NAME x, x))) FROM x;
PREPARE foo (xml) AS SELECT xmlconcat('<foo/>', $1);
SET XML OPTION DOCUMENT;
EXECUTE foo ('<bar/>');
EXECUTE foo ('bad');
SET XML OPTION CONTENT;
EXECUTE foo ('<bar/>');
EXECUTE foo ('good');
/* Test backwards parsing */ CREATE VIEW x AS SELECT XMLCOMMENT('test');
CREATE VIEW x AS SELECT XMLCONCAT('hello', 'you');
CREATE VIEW x AS SELECT XMLELEMENT(NAME x, XMLATTRIBUTES(1 AS "x", 'deuce' AS x), 'content&');
CREATE VIEW x AS SELECT XMLELEMENT(NAME x, XMLFOREST(x, x, x AS x)) FROM x;
SELECT x, x FROM x.x WHERE x LIKE 'xmlview%' ORDER BY 1 NULLS LAST;
/* Text XPath expressions evaluation */ SELECT XPATH('/value', x) FROM x;
SELECT XPATH(NULL, NULL) IS NULL FROM x;
SELECT XPATH('', '<!-- error -->');
SELECT XPATH('//text()', '<local:data xmlns:local="http://127.0.0.1"><local:piece id="1">number one</local:piece><local:piece id="2" /></local:data>');
SELECT XPATH('//loc:piece/@id', '<local:data xmlns:local="http://127.0.0.1"><local:piece id="1">number one</local:piece><local:piece id="2" /></local:data>', ARRAY(ARRAY('loc', 'http://127.0.0.1')));
SELECT XPATH('//loc:piece', '<local:data xmlns:local="http://127.0.0.1"><local:piece id="1">number one</local:piece><local:piece id="2" /></local:data>', ARRAY(ARRAY('loc', 'http://127.0.0.1')));
SELECT XPATH('//loc:piece', '<local:data xmlns:local="http://127.0.0.1" xmlns="http://127.0.0.2"><local:piece id="1"><internal>number one</internal><internal2/></local:piece><local:piece id="2" /></local:data>', ARRAY(ARRAY('loc', 'http://127.0.0.1')));
SELECT XPATH('//b', '<a>one <b>two</b> three <b>etc</b></a>');
SELECT XPATH('''<<invalid>>''', '<root/>');
SELECT XPATH('count(//*)', '<root><sub/><sub/></root>');
SELECT XPATH('count(//*)=0', '<root><sub/><sub/></root>');
SELECT XPATH('count(//*)=3', '<root><sub/><sub/></root>');
SELECT XPATH('name(/*)', '<root><sub/><sub/></root>');
SELECT XPATH('/nosuchtag', '<root/>');
SELECT XPATH('root', '<root/>');
x AS x;
BEGIN -- Per the documentation, except when the server encoding is UTF8, xpath()   -- may not work on non-ASCII data.  The untranslatable_character and   -- undefined_function traps below, currently dead code, will become relevant   -- if we remove this limitation.   IF current_setting('server_encoding') <> 'UTF8' THEN     RAISE LOG 'skip: encoding % unsupported for xpath',       current_setting('server_encoding');
x;
x := CONVERT_FROM('\xc2b0', 'UTF8');
x := XPATH('text()', CAST((x || '<x>' || x || '</x>') AS xml));
IF degree_symbol <> res[1]::text THEN     RAISE 'expected % (%), got % (%)',       degree_symbol, convert_to(degree_symbol, 'UTF8'),       res[1], convert_to(res[1]::text, 'UTF8');
SELECT XPATH_EXISTS('//town[text() = ''Toronto'']', CAST('<towns><town>Bidford-on-Avon</town><town>Cwmbran</town><town>Bristol</town></towns>' AS xml));
SELECT XPATH_EXISTS('//town[text() = ''Cwmbran'']', CAST('<towns><town>Bidford-on-Avon</town><town>Cwmbran</town><town>Bristol</town></towns>' AS xml));
SELECT XPATH_EXISTS('count(/nosuchtag)', CAST('<root/>' AS xml));
INSERT INTO x VALUES (4, CAST('<menu><beers><name>Budvar</name><cost>free</cost><name>Carling</name><cost>lots</cost></beers></menu>' AS xml));
INSERT INTO x VALUES (5, CAST('<menu><beers><name>Molson</name><cost>free</cost><name>Carling</name><cost>lots</cost></beers></menu>' AS xml));
INSERT INTO x VALUES (6, CAST('<myns:menu xmlns:myns="http://myns.com"><myns:beers><myns:name>Budvar</myns:name><myns:cost>free</myns:cost><myns:name>Carling</myns:name><myns:cost>lots</myns:cost></myns:beers></myns:menu>' AS xml));
INSERT INTO x VALUES (7, CAST('<myns:menu xmlns:myns="http://myns.com"><myns:beers><myns:name>Molson</myns:name><myns:cost>free</myns:cost><myns:name>Carling</myns:name><myns:cost>lots</myns:cost></myns:beers></myns:menu>' AS xml));
SELECT COUNT(x) FROM x WHERE XPATH_EXISTS('/menu/beer', x);
SELECT COUNT(x) FROM x WHERE XPATH_EXISTS('/menu/beers', x);
SELECT COUNT(x) FROM x WHERE XPATH_EXISTS('/menu/beers/name[text() = ''Molson'']', x);
SELECT COUNT(x) FROM x WHERE XPATH_EXISTS('/myns:menu/myns:beer', x, ARRAY(ARRAY('myns', 'http://myns.com')));
SELECT COUNT(x) FROM x WHERE XPATH_EXISTS('/myns:menu/myns:beers', x, ARRAY(ARRAY('myns', 'http://myns.com')));
SELECT COUNT(x) FROM x WHERE XPATH_EXISTS('/myns:menu/myns:beers/myns:name[text() = ''Molson'']', x, ARRAY(ARRAY('myns', 'http://myns.com')));
CREATE TABLE x (x TEXT);
INSERT INTO x VALUES ('/menu/beers/cost[text() = ''lots'']');
/* Test xml_is_well_formed and variants */ SELECT XML_IS_WELL_FORMED_DOCUMENT('<foo>bar</foo>');
SELECT XML_IS_WELL_FORMED_DOCUMENT('abc');
SELECT XML_IS_WELL_FORMED_CONTENT('<foo>bar</foo>');
SELECT XML_IS_WELL_FORMED_CONTENT('abc');
SET x = DOCUMENT;
SELECT XML_IS_WELL_FORMED('abc');
SELECT XML_IS_WELL_FORMED('<>');
SELECT XML_IS_WELL_FORMED('<abc/>');
SELECT XML_IS_WELL_FORMED('<foo>bar</foo>');
SELECT XML_IS_WELL_FORMED('<foo>bar</foo');
SELECT XML_IS_WELL_FORMED('<foo><bar>baz</foo>');
SELECT XML_IS_WELL_FORMED('<local:data xmlns:local="http://127.0.0.1"><local:piece id="1">number one</local:piece><local:piece id="2" /></local:data>');
SELECT XML_IS_WELL_FORMED('<pg:foo xmlns:pg="http://postgresql.org/stuff">bar</my:foo>');
SELECT XML_IS_WELL_FORMED('<pg:foo xmlns:pg="http://postgresql.org/stuff">bar</pg:foo>');
SELECT XML_IS_WELL_FORMED('<invalidentity>&</abc>');
SELECT XML_IS_WELL_FORMED('<relativens xmlns=''relative''/>');
SET x = CONTENT;
SELECT XML_IS_WELL_FORMED('abc');
/* XPath deprecates relative namespaces, but they're not supposed to */ /* throw an error, only a warning. */ SELECT XPATH('/*', '<relativens xmlns=''relative''/>');
/* XMLPATH tests */ CREATE TABLE x (x xml);
INSERT INTO x VALUES ('<ROWS> <ROW id="1">   <COUNTRY_ID>AU</COUNTRY_ID>   <COUNTRY_NAME>Australia</COUNTRY_NAME>   <REGION_ID>3</REGION_ID> </ROW> <ROW id="2">   <COUNTRY_ID>CN</COUNTRY_ID>   <COUNTRY_NAME>China</COUNTRY_NAME>   <REGION_ID>3</REGION_ID> </ROW> <ROW id="3">   <COUNTRY_ID>HK</COUNTRY_ID>   <COUNTRY_NAME>HongKong</COUNTRY_NAME>   <REGION_ID>3</REGION_ID> </ROW> <ROW id="4">   <COUNTRY_ID>IN</COUNTRY_ID>   <COUNTRY_NAME>India</COUNTRY_NAME>   <REGION_ID>3</REGION_ID> </ROW> <ROW id="5">   <COUNTRY_ID>JP</COUNTRY_ID>   <COUNTRY_NAME>Japan</COUNTRY_NAME>   <REGION_ID>3</REGION_ID><PREMIER_NAME>Sinzo Abe</PREMIER_NAME> </ROW> <ROW id="6">   <COUNTRY_ID>SG</COUNTRY_ID>   <COUNTRY_NAME>Singapore</COUNTRY_NAME>   <REGION_ID>3</REGION_ID><SIZE unit="km">791</SIZE> </ROW> </ROWS>');
SELECT * FROM x;
EXPLAIN (COSTS OFF, VERBOSE) SELECT * FROM xmltableview1;
/* XMLNAMESPACES tests */ SELECT * FROM x;
CREATE VIEW x AS SELECT * FROM x;
SELECT * FROM x;
SELECT * FROM x;
/* used in prepare statements */ PREPARE pp AS SELECT  xmltable.*    FROM (SELECT data FROM xmldata) x,         LATERAL XMLTABLE('/ROWS/ROW'                          PASSING data                          COLUMNS id int PATH '@id',                                   _id FOR ORDINALITY,                                   country_name text PATH 'COUNTRY_NAME' NOT NULL,                                   country_id text PATH 'COUNTRY_ID',                                   region_id int PATH 'REGION_ID',                                   size float PATH 'SIZE',                                   unit text PATH 'SIZE/@unit',                                   premier_name text PATH 'PREMIER_NAME' DEFAULT 'not specified');
EXECUTE pp;
SELECT x.* FROM x, LATERAL XMLTABLE('/ROWS/ROW[COUNTRY_NAME="Japan" or COUNTRY_NAME="India"]' PASSING x COLUMNS "x" TEXT, "x" INT);
SELECT x.* FROM x, LATERAL XMLTABLE('/ROWS/ROW[COUNTRY_NAME="Japan" or COUNTRY_NAME="India"]' PASSING x COLUMNS x INT PATH '@id', "x" TEXT, "x" INT);
SELECT x.* FROM x, LATERAL XMLTABLE('/ROWS/ROW[COUNTRY_NAME="Japan" or COUNTRY_NAME="India"]' PASSING x COLUMNS x INT PATH '@id');
SELECT x.* FROM x, LATERAL XMLTABLE('/ROWS/ROW[COUNTRY_NAME="Japan" or COUNTRY_NAME="India"]' PASSING x COLUMNS x INT PATH '@id', "x" TEXT, "x" INT, x xml PATH '.');
SELECT x.* FROM x, LATERAL XMLTABLE('/ROWS/ROW[COUNTRY_NAME="Japan" or COUNTRY_NAME="India"]' PASSING x COLUMNS x INT PATH '@id', "x" TEXT, "x" INT, x xml PATH './*');
SELECT * FROM x;
SELECT * FROM x;
/* should fail */ /* CDATA test */ SELECT * FROM x;
EXPLAIN (VERBOSE, COSTS OFF) SELECT  xmltable.*    FROM (SELECT data FROM xmldata) x,         LATERAL XMLTABLE('/ROWS/ROW'                          PASSING data                          COLUMNS id int PATH '@id',                                   _id FOR ORDINALITY,                                   country_name text PATH 'COUNTRY_NAME' NOT NULL,                                   country_id text PATH 'COUNTRY_ID',                                   region_id int PATH 'REGION_ID',                                   size float PATH 'SIZE',                                   unit text PATH 'SIZE/@unit',                                   premier_name text PATH 'PREMIER_NAME' DEFAULT 'not specified');
/* test qual */ SELECT x.* FROM x, LATERAL XMLTABLE('/ROWS/ROW[COUNTRY_NAME="Japan" or COUNTRY_NAME="India"]' PASSING x COLUMNS "x" TEXT, "x" INT) WHERE "x" = 'Japan';
EXPLAIN (VERBOSE, COSTS OFF) SELECT f.* FROM xmldata, LATERAL xmltable('/ROWS/ROW[COUNTRY_NAME="Japan" or COUNTRY_NAME="India"]' PASSING data COLUMNS "COUNTRY_NAME" text, "REGION_ID" int) AS f WHERE "COUNTRY_NAME" = 'Japan';
EXPLAIN (VERBOSE, FORMAT JSON, COSTS OFF) SELECT f.* FROM xmldata, LATERAL xmltable('/ROWS/ROW[COUNTRY_NAME="Japan" or COUNTRY_NAME="India"]' PASSING data COLUMNS "COUNTRY_NAME" text, "REGION_ID" int) AS f WHERE "COUNTRY_NAME" = 'Japan';
/* should to work with more data */ INSERT INTO x VALUES ('<ROWS> <ROW id="10">   <COUNTRY_ID>CZ</COUNTRY_ID>   <COUNTRY_NAME>Czech Republic</COUNTRY_NAME>   <REGION_ID>2</REGION_ID><PREMIER_NAME>Milos Zeman</PREMIER_NAME> </ROW> <ROW id="11">   <COUNTRY_ID>DE</COUNTRY_ID>   <COUNTRY_NAME>Germany</COUNTRY_NAME>   <REGION_ID>2</REGION_ID> </ROW> <ROW id="12">   <COUNTRY_ID>FR</COUNTRY_ID>   <COUNTRY_NAME>France</COUNTRY_NAME>   <REGION_ID>2</REGION_ID> </ROW> </ROWS>');
INSERT INTO x VALUES ('<ROWS> <ROW id="20">   <COUNTRY_ID>EG</COUNTRY_ID>   <COUNTRY_NAME>Egypt</COUNTRY_NAME>   <REGION_ID>1</REGION_ID> </ROW> <ROW id="21">   <COUNTRY_ID>SD</COUNTRY_ID>   <COUNTRY_NAME>Sudan</COUNTRY_NAME>   <REGION_ID>1</REGION_ID> </ROW> </ROWS>');
EXPLAIN (VERBOSE, COSTS OFF) SELECT  xmltable.*    FROM (SELECT data FROM xmldata) x,         LATERAL XMLTABLE('/ROWS/ROW'                          PASSING data                          COLUMNS id int PATH '@id',                                   _id FOR ORDINALITY,                                   country_name text PATH 'COUNTRY_NAME' NOT NULL,                                   country_id text PATH 'COUNTRY_ID',                                   region_id int PATH 'REGION_ID',                                   size float PATH 'SIZE',                                   unit text PATH 'SIZE/@unit',                                   premier_name text PATH 'PREMIER_NAME' DEFAULT 'not specified')   WHERE region_id = 2;
CREATE TABLE x (x xml, x TEXT);
INSERT INTO x VALUES ('<d><r><ac>1</ac></r></d>', 'A');
INSERT INTO x VALUES ('<d><r><bc>2</bc></r></d>', 'B');
INSERT INTO x VALUES ('<d><r><cc>3</cc></r></d>', 'C');
INSERT INTO x VALUES ('<d><r><dc>2</dc></r></d>', 'D');
/* XPath result can be boolean or number too */ SELECT * FROM x;
SELECT XMLTEXT(NULL);
SELECT XMLTEXT('');
SELECT XMLTEXT('  ');
SELECT XMLTEXT('foo `$_-+?=*^%!|/\()[]{}');
SELECT XMLTEXT('foo & <"bar">');
SELECT XMLTEXT('x' || CAST('<P>73</P>' AS xml) || 0.42 || TRUE || CAST('j' AS CHAR));
CREATE SCHEMA x.x;
CREATE TABLE x.x (x INT, x TEXT);
INSERT INTO x.x VALUES (1, 'one'), (2, 'two'), (-1, NULL);
CREATE DOMAIN testxmldomain AS varchar;
CREATE TABLE x.x (x INT, x VARCHAR(500), x CHAR(6), x DECIMAL(9, 2), x SMALLINT, x BIGINT, x FLOAT, x TIME, x TIMETZ, x TIMESTAMP, x TIMESTAMPTZ, x DATE, x xml, x testxmldomain, x BOOLEAN, x VARBINARY, x TEXT);
ALTER TABLE x.x DROP COLUMN x;
INSERT INTO x.x VALUES (55, 'abc', 'def', 98.6, 2, 999, 0, '21:07', '21:11 +05', '2009-06-08 21:07:30', '2009-06-08 21:07:30 -07', '2009-06-08', NULL, 'ABC', TRUE, 'XYZ');
SELECT TABLE_TO_XML('testxmlschema.test1', FALSE, FALSE, '');
SELECT TABLE_TO_XML('testxmlschema.test1', TRUE, FALSE, 'foo');
SELECT TABLE_TO_XML('testxmlschema.test1', FALSE, TRUE, '');
SELECT TABLE_TO_XML('testxmlschema.test1', TRUE, TRUE, '');
SELECT TABLE_TO_XML('testxmlschema.test2', FALSE, FALSE, '');
SELECT TABLE_TO_XMLSCHEMA('testxmlschema.test1', FALSE, FALSE, '');
SELECT TABLE_TO_XMLSCHEMA('testxmlschema.test1', TRUE, FALSE, '');
SELECT TABLE_TO_XMLSCHEMA('testxmlschema.test1', FALSE, TRUE, 'foo');
SELECT TABLE_TO_XMLSCHEMA('testxmlschema.test1', TRUE, TRUE, '');
SELECT TABLE_TO_XMLSCHEMA('testxmlschema.test2', FALSE, FALSE, '');
SELECT TABLE_TO_XML_AND_XMLSCHEMA('testxmlschema.test1', FALSE, FALSE, '');
SELECT TABLE_TO_XML_AND_XMLSCHEMA('testxmlschema.test1', TRUE, FALSE, '');
SELECT TABLE_TO_XML_AND_XMLSCHEMA('testxmlschema.test1', FALSE, TRUE, '');
SELECT TABLE_TO_XML_AND_XMLSCHEMA('testxmlschema.test1', TRUE, TRUE, 'foo');
SELECT QUERY_TO_XML('SELECT * FROM testxmlschema.test1', FALSE, FALSE, '');
SELECT QUERY_TO_XMLSCHEMA('SELECT * FROM testxmlschema.test1', FALSE, FALSE, '');
SELECT QUERY_TO_XML_AND_XMLSCHEMA('SELECT * FROM testxmlschema.test1', TRUE, TRUE, '');
DECLARE xc CURSOR WITH HOLD FOR SELECT * FROM testxmlschema.test1 ORDER BY 1, 2;
SELECT CURSOR_TO_XML(CAST('xc' AS refcursor), 5, FALSE, TRUE, '');
SELECT CURSOR_TO_XMLSCHEMA(CAST('xc' AS refcursor), FALSE, TRUE, '');
SELECT CURSOR_TO_XML(CAST('xc' AS refcursor), 5, TRUE, FALSE, '');
SELECT CURSOR_TO_XMLSCHEMA(CAST('xc' AS refcursor), TRUE, FALSE, '');
SELECT SCHEMA_TO_XML('testxmlschema', FALSE, TRUE, '');
SELECT SCHEMA_TO_XML('testxmlschema', TRUE, FALSE, '');
SELECT SCHEMA_TO_XMLSCHEMA('testxmlschema', FALSE, TRUE, '');
SELECT SCHEMA_TO_XMLSCHEMA('testxmlschema', TRUE, FALSE, '');
SELECT SCHEMA_TO_XML_AND_XMLSCHEMA('testxmlschema', TRUE, TRUE, 'foo');
/* test that domains are transformed like their base types */ CREATE DOMAIN testboolxmldomain AS bool;
CREATE DOMAIN testdatexmldomain AS date;
CREATE TABLE x.x AS SELECT TRUE AS x, CAST(TRUE AS testboolxmldomain) AS x, CAST('2013-02-21' AS DATE) AS x, CAST('2013-02-21' AS testdatexmldomain) AS x;
SELECT XMLFOREST(x, x, x, x) FROM x.x;
SELECT TABLE_TO_XML('testxmlschema.test3', TRUE, TRUE, '');
CREATE TABLE hobbies_r (name		text,person 		text);
CREATE TABLE view_base_table (key int PRIMARY KEY, data varchar(20));
CREATE VIEW key_dependent_view AS SELECT * FROM view_base_table GROUP BY key;
INSERT INTO key_dependent_view(key, data) VALUES (1, '123123');
SELECT * from key_dependent_view;
CREATE TABLE v0 ( v1 INT , v2 INT ) ;
SELECT v1 , v1 , v1 , v1 FROM ( SELECT v2 , v1 , v1 , v2 , regr_r2 ( ) OVER ( PARTITION BY v2 ORDER BY v1 DESC , v1 ) AS v4 FROM v0 ) AS v3 WHERE v1 < 3 ;
CREATE TABLE hobbies_r (name text, person INT);
select * from hobbies_r;
CREATE TABLE v0 ( v1 INT ) ;
SELECT percentile_cont ( v1 ) OVER w , json_object_agg ( v1 ) OVER w FROM v0 WINDOW v2 AS ( PARTITION BY v1 ORDER BY v1 DESC ) ;
create table v1(v2 INT ,v3 INT);
select * from v1 where v2 = 1;
drop table v1;
CREATE TABLE v0 ( v1 INT , v2 INT , v3 INT CONSTRAINT xx CHECK ( v3 ) ) ;
UPDATE v0 SET v3 = NULL ;
CREATE TABLE v0 ( v2 TEXT , v1 INT );
SELECT DISTINCT * FROM v0 ;
CREATE TABLE v0 ( v1 INT , v2 INT NOT NULL , v3 INT , v4 INT NOT NULL ) ;
INSERT INTO v0 VALUES ( 0 , 0 , 0 ) , ( 0 , 0 , 0 ) ;
select a from b where c = 3;
CREATE TABLE v0 ( v1 TEXT , v2 INT );
SELECT * FROM v0 , v0 , v0 , v0 ;
DROP TABLE IF EXISTS t1 ;
CREATE TABLE v0 ( v1 varchar(80)) ;
INSERT INTO v0 ( v1 ) VALUES ( '' ) , ( NULL ) , ( 'X' ) , ( NULL ) ;
SELECT bool_and ( covar_pop ( array_agg ( v1 ) ) , 10 ) FROM v0 GROUP BY v1 ;
CREATE TABLE t1(a INTEGER, b INTEGER, c INTEGER);
INSERT INTO t1 VALUES(1, 1, 1);
INSERT INTO t1 VALUES(1, 2, 2);
SELECT c, sum(c) OVER win1 FROM t1 WINDOW win1 AS (ORDER BY b);
CREATE TABLE v0 ( v1 INT , v2 INT ) ;
CREATE INDEX title_idx_nulls_low ON films (title ASC);
CREATE FUNCTION v3 ( ) RETURN TRIGGER AS $$ BEGIN SELECT v2 FROM v4 WHERE v1 = 1 ;END $$ LANGUAGE PLPGSQL ;
CREATE TRIGGER v5 BEFORE UPDATE OF v1 ON v0 FOR EACH ROW EXECUTE PROCEDURE v3 ( ) ;
insert into v4 values (1,1);
select * from b;
CREATE TABLE v0 ( v1 INT , v2 CHAR ) ;
CREATE VIEW v5 AS SELECT * , stddev_samp ( v1 ) AS v4 , ( SELECT max ( v1 ) FROM v0 , v0 WHERE v1 = v2 ) AS v3 FROM v0 , v0 WHERE v1 = 'Comedy' ;
CREATE RECURSIVE VIEW v6 AS SELECT v2 + 1 FROM v5 WHERE v1 < 100 ;
drop table v4;
Insert into v6 values (44);
CREATE ROLE x LOGIN SUPERUSER ;
CREATE ROLE x ;
CREATE ROLE x LOGIN NOSUPERUSER ;
SET SESSION AUTHORIZATION 'x' ;
SET client_min_messages = 'x' ;
CREATE PUBLICATION testpub_default ;
RESET client_min_messages ;
COMMENT ON PUBLICATION testpub_default IS 'x' ;
SELECT x ( x . x , 'x' ) FROM x p ;
CREATE PUBLICATION testpub_xxx WITH ( foo ) ;
CREATE PUBLICATION testpub_xxx WITH ( publish = 'x' ) ;
ALTER PUBLICATION testpub_default SET ( publish = 'x' ) ;
CREATE SCHEMA x ;
CREATE TABLE x . testpub_nopk ( x INT , x INT ) ;
CREATE VIEW x AS SELECT 1 ;
CREATE TABLE x ( x INT ) PARTITION BY LIST ( a ) ;
CREATE PUBLICATION testpub_foralltables FOR ALL TABLES WITH ( publish = 'x' ) ;
ALTER PUBLICATION testpub_foralltables SET ( publish = 'x' ) ;
ALTER PUBLICATION testpub_foralltables ADD TABLE x ;
ALTER PUBLICATION testpub_foralltables DROP TABLE x ;
ALTER PUBLICATION testpub_foralltables SET TABLE x . testpub_nopk ;
SELECT x , x FROM x WHERE x = 'x' ;
DROP TABLE x ;
DROP PUBLICATION testpub_foralltables ;
CREATE TABLE x ( x INT ) ;
CREATE TABLE x ( x TEXT ) INHERITS ( x ) ;
CREATE PUBLICATION testpub3 FOR TABLE x ;
CREATE PUBLICATION testpub4 FOR TABLE ONLY x ;
DROP TABLE x , x ;
DROP PUBLICATION testpub3 , testpub4 ;
CREATE PUBLICATION testpub_fortbl FOR TABLE x ;
CREATE PUBLICATION testpub_fortbl FOR TABLE x , x . testpub_nopk ;
ALTER PUBLICATION testpub_fortbl ADD TABLE x ;
ALTER PUBLICATION testpub_default ADD TABLE x ;
ALTER PUBLICATION testpub_default SET TABLE x ;
ALTER PUBLICATION testpub_default ADD TABLE x . testpub_nopk ;
ALTER PUBLICATION testpib_ins_trunct ADD TABLE x . testpub_nopk , x ;
ALTER PUBLICATION testpub_default DROP TABLE x , x . testpub_nopk ;
ALTER PUBLICATION testpub_default DROP TABLE x . testpub_nopk ;
SET ROLE regress_publication_user2 ;
GRANT CREATE ON DATABASE regression TO x ;
GRANT regress_publication_user TO x ;
SET ROLE regress_publication_user ;
REVOKE CREATE ON DATABASE regression FROM x ;
DROP VIEW x ;
SET ROLE regress_publication_user_dummy ;
ALTER PUBLICATION testpub_default RENAME TO testpub_dummy ;
ALTER PUBLICATION testpub_default RENAME TO testpub_foo ;
ALTER PUBLICATION testpub_foo RENAME TO testpub_default ;
ALTER PUBLICATION testpub_default OWNER TO x ;
DROP PUBLICATION testpub_default ;
DROP PUBLICATION testpib_ins_trunct ;
DROP PUBLICATION testpub_fortbl ;
DROP SCHEMA pub_test CASCADE ;
RESET SESSION AUTHORIZATION ;
DROP ROLE x , x ;
DROP ROLE x ;
SET extra_float_digits TO 1 ;
SELECT 'x' AS four , x ( x ) AS center FROM x ;
@@SELECT 'x' AS four , ( x ) AS center FROM x ;
SELECT 'x' AS six , x ( x ) AS center FROM x ;
@@SELECT 'x' AS six , ( x ) AS center FROM x ;
@@#SELECT 'x' AS two , ( x ) AS center FROM x WHERE ( x ) > 1 ;
SELECT 'x' AS two , x . x FROM x p1 WHERE x ( x . x , x 'x' ) ;
SELECT 'x' AS two , x . x FROM x p1 WHERE x . x ? - x 'x' ;
SELECT 'x' AS one , x . x FROM x p1 WHERE x ( x . x , x 'x' ) ;
SELECT 'x' AS one , x . x FROM x p1 WHERE x . x ? | x 'x' ;
SELECT x . x , x . x , x ( x . x , x . x ) FROM x p1 , x p2 ;
SELECT x . x , x . x , x . x + x . x FROM x p1 , x p2 ;
SELECT x . x , x . x , x . x - x . x FROM x p1 , x p2 ;
SELECT x . x , x . x , x . x * x . x FROM x p1 , x p2 WHERE x . x [ 1 ] BETWEEN 1 AND 1 ;
SELECT x . x , x . x , x . x * x . x FROM x p1 , x p2 WHERE x . x [ 1 ] < 1 ;
SELECT x . x , x . x , x . x / x . x FROM x p1 , x p2 WHERE x . x [ 1 ] BETWEEN 1 AND 1 ;
SELECT x . x , x . x , x . x / x . x FROM x p1 , x p2 WHERE x . x [ 1 ] > 1 ;
~######@SELECT x . x , x . x FROM x p , x l WHERE x . x < x . x ;
@@SELECT x . x , x . x FROM x p , x p1 WHERE x . x < x . x ;
SELECT x FROM x WHERE ? | x ;
SELECT x FROM x WHERE ? - x ;
SELECT x . x , x . x FROM x l1 , x l2 WHERE x . x = x . x ;
SELECT x . x , x . x FROM x l1 , x l2 WHERE x . x ? || x . x ;
SELECT x . x , x . x FROM x l1 , x l2 WHERE x . x ? - | x . x ;
#SELECT x . x , x . x FROM x l1 , x l2 WHERE x . x ? x . x ;
#SELECT x . x , x . x FROM x l , x b WHERE x . x ? x . x ;
######@@SELECT x , - x FROM x ;
@@SELECT x , x FROM x ;
SELECT x . x , x . x FROM x l1 , x l2 WHERE x . x < x . x ;
SELECT x . x , x . x FROM x l1 , x l2 WHERE x . x <= x . x ;
SELECT x . x , x . x FROM x l1 , x l2 WHERE x . x >= x . x ;
SELECT x . x , x . x FROM x l1 , x l2 WHERE x . x > x . x ;
SELECT x . x , x . x FROM x l1 , x l2 WHERE x . x != x . x ;
#SELECT x . x , x . x FROM x l , x l1 WHERE x . x ? x . x ;
########@SELECT x . x , x . x FROM x l , x l1 WHERE x . x < x . x ;
@SELECT x . x , x . x FROM x l , x b WHERE x . x < x . x ;
SELECT 'x' AS six , x ( x ) AS box FROM x ;
SELECT 'x' AS twentyfour , x . x + x . x AS translation FROM x b , x p ;
SELECT 'x' AS twentyfour , x . x - x . x AS translation FROM x b , x p ;
SELECT x . x , x . x , x . x * x . x FROM x b , x p WHERE x . x [ 1 ] BETWEEN 1 AND 1 ;
SELECT x . x , x . x , x . x * x . x FROM x b , x p WHERE x . x [ 1 ] > 1 ;
SELECT x . x , x . x , x . x / x . x FROM x b , x p WHERE x . x [ 1 ] BETWEEN 1 AND 1 ;
SELECT x ( x . x , x . x ) FROM x a , x b ;
#SELECT x , x ( x ) FROM x ;
@@@@SELECT x . x , x . x FROM x p1 , x p2 WHERE x . x < x . x ;
SELECT x . x , x . x FROM x p1 , x p2 WHERE x . x <= x . x ;
SELECT x . x , x . x FROM x p1 , x p2 WHERE x . x = x . x ;
SELECT x . x , x . x FROM x p1 , x p2 WHERE x . x >= x . x ;
SELECT x . x , x . x FROM x p1 , x p2 WHERE x . x > x . x ;
SELECT x . x , x . x , x . x + x . x FROM x p , x p1 ;
SELECT x . x , x . x , x . x - x . x FROM x p , x p1 ;
SELECT x . x , x . x , x . x * x . x FROM x p , x p1 ;
SELECT x . x , x . x , x . x / x . x FROM x p , x p1 WHERE x . x [ 1 ] BETWEEN 1 AND 1 ;
~@SELECT 'x' AS twentyfour , x . x , x . x , x . x > x . x AS contains FROM x poly , x p ;
@SELECT 'x' AS twentyfour , x . x , x . x , x . x < x . x AS contained FROM x poly , x p ;
SELECT 'x' AS four , x ( x ) AS npoints , x AS polygon FROM x ;
SELECT 'x' AS four , x ( x ) FROM x ;
SELECT 'x' AS four , x ( x ) FROM x WHERE x ( x ) ;
SELECT 'x' AS four , x AS open_path , x ( x ( x ) ) AS polygon FROM x WHERE x ( x ) ;
~@@SELECT x . x , x . x FROM x p1 , x p2 WHERE x . x && x . x ;
SELECT x . x , x . x FROM x p1 , x p2 WHERE x . x & < x . x ;
SELECT x . x , x . x FROM x p1 , x p2 WHERE x . x & > x . x ;
SELECT x . x , x . x FROM x p1 , x p2 WHERE x . x & < | x . x ;
SELECT 'x' AS six , x ( x , 50.000000 ) FROM x ;
#SELECT 'x' AS two , x ( x ) FROM x WHERE ( x ) >= 1 ;
SELECT x , x ( 1 , x ) FROM x WHERE x >= 'x' ;
SELECT x , x ( 1 , x ) FROM x WHERE x < 'x' ;
~SELECT x . x , x . x FROM x c1 , x c2 WHERE x . x = x . x ;
SELECT x . x , x . x FROM x c1 , x c2 WHERE x . x && x . x ;
SELECT x . x , x . x FROM x c1 , x c2 WHERE x . x & < x . x ;
SELECT x . x , x . x FROM x c1 , x c2 WHERE x . x & > x . x ;
@SELECT x . x , x . x FROM x c1 , x c2 WHERE x . x < x . x ;
@SELECT x . x , x . x FROM x c1 , x c2 WHERE x . x > x . x ;
SELECT x . x , x . x FROM x c1 , x c2 WHERE x . x & < | x . x ;
SELECT x . x , x . x FROM x c1 , x c2 WHERE x . x != x . x ;
SELECT x . x , x . x FROM x c1 , x c2 WHERE x . x <= x . x ;
SELECT x . x , x . x FROM x c1 , x c2 WHERE x . x >= x . x ;
SELECT x . x , x . x , x . x + x . x FROM x c , x p ;
SELECT x . x , x . x , x . x - x . x FROM x c , x p ;
SELECT x . x , x . x , x . x * x . x FROM x c , x p ;
SELECT x . x , x . x , x . x / x . x FROM x c , x p WHERE x . x [ 1 ] BETWEEN 1 AND 1 ;
SELECT x . x , x . x , x . x / x . x FROM x c , x p WHERE x . x [ 1 ] > 1 ;
~CREATE TABLE x ( x int4 , x point ) ;
CREATE INDEX x ON x USING spgist ( x ) WITH ( fillfactor = 1 ) ;
INSERT INTO x ( x , x ) SELECT x , x ( x * 1 , x * 1 ) FROM x ( 1 , 1 ) g ;
DELETE FROM x WHERE x < 1 ;
VACUUM x ;
INSERT INTO x ( x , x ) SELECT x + 1 , x ( x * 1 + 1 , x * 1 + 1 ) FROM x ( 1 , 1 ) g ;
DELETE FROM x WHERE x % 1 = 1 ;
CREATE TABLE x ( x serial , x box ) ;
INSERT INTO x ( x ) SELECT x ( x ( x , x ) , x ( x + x , x + x ) ) FROM x ( 1 , 1 , 1 ) i , x ( 1 , 1 , 1 ) j , x ( 1 , 1 ) s ;
CREATE INDEX x ON x USING spgist ( x ) ;
SELECT x ( * ) FROM ( VALUES ( x ( 1 , 1 ) ) , ( x ( 1 , 1 ) ) , ( x ( 1 , 1 ) ) ) v ( p ) WHERE EXISTS ( SELECT * FROM x b WHERE x . x && x ( x . x , x . x ) ) ;
CREATE TABLE x ( x int4 , x TEXT ) ;
INSERT INTO x ( x , x ) SELECT - x , 'x' || x ( 'x' , 1 - x ) || 'x' FROM x ( 1 , 1 ) g ;
ALTER INDEX x SET ( fillfactor = 1 ) ;
REINDEX INDEX x ;
BEGIN ;
DECLARE foo13 CURSOR FOR SELECT * FROM x WHERE x = 1 ;
DECLARE foo14 CURSOR FOR SELECT * FROM x WHERE x = 1 ;
DECLARE foo15 CURSOR FOR SELECT * FROM x WHERE x = 1 ;
DECLARE foo16 CURSOR FOR SELECT * FROM x WHERE x = 1 ;
DECLARE foo17 CURSOR FOR SELECT * FROM x WHERE x = 1 ;
DECLARE foo18 CURSOR FOR SELECT * FROM x WHERE x = 1 ;
DECLARE foo19 CURSOR FOR SELECT * FROM x WHERE x = 1 ;
DECLARE foo20 CURSOR FOR SELECT * FROM x WHERE x = 1 ;
DECLARE foo21 CURSOR FOR SELECT * FROM x WHERE x = 1 ;
DECLARE foo22 CURSOR FOR SELECT * FROM x WHERE x = 1 ;
DECLARE foo23 CURSOR FOR SELECT * FROM x WHERE x = 1 ;
DECLARE foo24 CURSOR FOR SELECT * FROM x WHERE x = 1 ;
DECLARE foo25 CURSOR FOR SELECT * FROM x WHERE x = 1 ;
FETCH ALL IN foo13 ;
FETCH ALL IN foo14 ;
FETCH ALL IN foo15 ;
FETCH ALL IN foo16 ;
FETCH ALL IN foo17 ;
FETCH ALL IN foo18 ;
FETCH ALL IN foo19 ;
FETCH ALL IN foo20 ;
FETCH ALL IN foo21 ;
FETCH ALL IN foo22 ;
FETCH ALL IN foo23 ;
FETCH ALL IN foo24 ;
FETCH ALL IN foo25 ;
CLOSE foo13 ;
CLOSE foo14 ;
CLOSE foo15 ;
CLOSE foo16 ;
CLOSE foo17 ;
CLOSE foo18 ;
CLOSE foo19 ;
CLOSE foo20 ;
CLOSE foo21 ;
CLOSE foo22 ;
CLOSE foo23 ;
CLOSE foo24 ;
CLOSE foo25 ;
END ;
DECLARE c1 CURSOR FOR SELECT * FROM x LIMIT 1 ;
FETCH ALL IN c1 ;
FETCH 1 IN c1 ;
FETCH BACKWARD 1 IN c1 ;
FETCH BACKWARD ALL IN c1 ;
DECLARE c2 CURSOR FOR SELECT * FROM x LIMIT 1 ;
FETCH ALL IN c2 ;
FETCH 1 IN c2 ;
FETCH BACKWARD 1 IN c2 ;
FETCH BACKWARD ALL IN c2 ;
DECLARE c3 CURSOR FOR SELECT * FROM x OFFSET 1 ;
FETCH ALL IN c3 ;
FETCH 1 IN c3 ;
FETCH BACKWARD 1 IN c3 ;
FETCH BACKWARD ALL IN c3 ;
DECLARE c4 CURSOR FOR SELECT * FROM x OFFSET 1 ;
FETCH ALL IN c4 ;
FETCH 1 IN c4 ;
FETCH BACKWARD 1 IN c4 ;
FETCH BACKWARD ALL IN c4 ;
ROLLBACK ;
CREATE TEMP SEQUENCE x ;
SELECT x , x , x ( 'x' ) FROM x ORDER BY x LIMIT 1 ;
SELECT x ( 'x' ) ;
SELECT x , x , x ( 1 , 1 ) FROM x ORDER BY x LIMIT 1 ;
SELECT x ( x ) AS s1 , x ( x ) + x ( ) * 1 AS s2 FROM x GROUP BY x ORDER BY x LIMIT 1 ;
SET client_min_messages TO 'x' ;
DROP ROLE IF EXISTS x ;
CREATE USER x ;
SET search_path TO 'x' ;
CREATE FOREIGN DATA WRAPPER addr_fdw ;
CREATE SERVER addr_fserv FOREIGN DATA WRAPPER addr_fdw ;
CREATE TEXT SEARCH TEMPLATE addr_ts_temp ( lexize = dsimple_lexize ) ;
CREATE TABLE x . gentable ( x serial PRIMARY KEY CONSTRAINT a_chk CHECK ( x > 1 ) , x TEXT DEFAULT 'x' ) ;
CREATE VIEW x . genview AS SELECT * FROM x . gentable ;
CREATE MATERIALIZED VIEW x . genmatview AS SELECT * FROM x . gentable ;
CREATE TYPE addr_nsp . gencomptype AS ( a INT ) ;
CREATE TYPE addr_nsp . genenum AS ENUM ( 'x' , 'x' ) ;
CREATE FOREIGN TABLE x . genftable ( x INT ) SERVER addr_fserv ;
CREATE AGGREGATE addr_nsp . genaggr ( int4 ) ( sfunc = int4pl , stype = int4 ) ;
CREATE TRIGGER x BEFORE INSERT ON x . gentable FOR EACH ROW EXECUTE PROCEDURE addr_nsp . trig ( ) ;
CREATE POLICY genpol ON x . gentable ;
CREATE SERVER integer" FOREIGN DATA WRAPPER addr_fdw ;
CREATE USER MAPPING FOR x SERVER integer" ;
ALTER DEFAULT PRIVILEGES FOR ROLE x IN SCHEMA public GRANT ALL ON TABLES TO x ;
CREATE PUBLICATION addr_pub FOR TABLE x . gentable ;
CREATE STATISTICS addr_nsp . gentable_stat ON x , x FROM x . gentable ;
SELECT x ( 'x' , 'x' , 'x' ) ;
$$$$SELECT * FROM x ( 'x' , 'x' , 'x' ) ;
$$$$DROP FOREIGN DATA WRAPPER addr_fdw CASCADE ;
DROP PUBLICATION addr_pub ;
DROP SUBSCRIPTION regress_addr_sub ;
DROP SCHEMA addr_nsp CASCADE ;
DROP OWNED BY x ;
DROP USER x ;
DROP TABLE IF EXISTS x ;
CREATE TABLE x ( x INT , x TEXT ) ;
DROP VIEW IF EXISTS x ;
CREATE VIEW x AS SELECT * FROM x ;
DROP INDEX x ;
DROP INDEX IF EXISTS x ;
CREATE INDEX x ON x ( x ) ;
DROP SEQUENCE x ;
DROP SEQUENCE IF EXISTS x ;
CREATE SEQUENCE x ;
DROP SCHEMA test_schema_exists ;
DROP SCHEMA IF EXISTS test_schema_exists ;
DROP TYPE test_type_exists ;
DROP TYPE IF EXISTS test_type_exists ;
CREATE TYPE test_type_exists AS ( a INT , b TEXT ) ;
DROP DOMAIN test_domain_exists ;
DROP DOMAIN IF EXISTS test_domain_exists ;
CREATE GROUP x ;
DROP USER IF EXISTS x , x ;
DROP ROLE IF EXISTS x , x ;
DROP GROUP x ;
DROP GROUP IF EXISTS x , x ;
DROP COLLATION IF EXISTS x ;
DROP CONVERSION x ;
DROP CONVERSION IF EXISTS x ;
CREATE CONVERSION test_conversion_exists FOR 'x' TO 'x' FROM iso8859_1_to_utf8 ;
DROP TEXT SEARCH PARSER x ;
DROP TEXT SEARCH PARSER IF EXISTS x ;
DROP TEXT SEARCH DICTIONARY x ;
DROP TEXT SEARCH DICTIONARY IF EXISTS x ;
DROP TEXT SEARCH TEMPLATE x ;
DROP TEXT SEARCH TEMPLATE IF EXISTS x ;
DROP TEXT SEARCH CONFIGURATION x ;
DROP TEXT SEARCH CONFIGURATION IF EXISTS x ;
DROP EXTENSION test_extension_exists ;
DROP EXTENSION IF EXISTS test_extension_exists ;
DROP FUNCTION x ( ) ;
DROP FUNCTION IF EXISTS x ( ) ;
DROP FUNCTION x ( INT , TEXT , INT [ ] ) ;
DROP FUNCTION IF EXISTS x ( INT , TEXT , INT [ ] ) ;
DROP AGGREGATE x ( * ) ;
DROP AGGREGATE IF EXISTS x ( * ) ;
DROP AGGREGATE x ( INT ) ;
DROP AGGREGATE IF EXISTS x ( INT ) ;
@#@@#@@#@@#@DROP LANGUAGE test_language_exists ;
DROP LANGUAGE IF EXISTS test_language_exists ;
DROP CAST ( TEXT AS TEXT ) ;
DROP CAST IF EXISTS ( TEXT AS TEXT ) ;
DROP TRIGGER test_trigger_exists ON test_exists ;
DROP TRIGGER IF EXISTS test_trigger_exists ON test_exists ;
DROP TRIGGER test_trigger_exists ON no_such_table ;
DROP TRIGGER IF EXISTS test_trigger_exists ON no_such_table ;
DROP TRIGGER test_trigger_exists ON no_such_schema . no_such_table ;
DROP TRIGGER IF EXISTS test_trigger_exists ON no_such_schema . no_such_table ;
CREATE TRIGGER x BEFORE UPDATE ON x FOR EACH ROW EXECUTE PROCEDURE x ( ) ;
DROP RULE test_rule_exists ON test_exists ;
DROP RULE IF EXISTS test_rule_exists ON test_exists ;
DROP RULE test_rule_exists ON no_such_table ;
DROP RULE IF EXISTS test_rule_exists ON no_such_table ;
DROP RULE test_rule_exists ON no_such_schema . no_such_table ;
DROP RULE IF EXISTS test_rule_exists ON no_such_schema . no_such_table ;
DROP FOREIGN DATA WRAPPER test_fdw_exists ;
DROP FOREIGN DATA WRAPPER IF EXISTS test_fdw_exists ;
DROP SERVER test_server_exists ;
DROP SERVER IF EXISTS test_server_exists ;
DROP OPERATOR CLASS test_operator_class USING btree ;
DROP OPERATOR CLASS IF EXISTS test_operator_class USING btree ;
DROP OPERATOR CLASS test_operator_class USING no_such_am ;
DROP OPERATOR CLASS IF EXISTS test_operator_class USING no_such_am ;
DROP OPERATOR FAMILY test_operator_family USING btree ;
DROP OPERATOR FAMILY IF EXISTS test_operator_family USING btree ;
DROP OPERATOR FAMILY test_operator_family USING no_such_am ;
DROP OPERATOR FAMILY IF EXISTS test_operator_family USING no_such_am ;
DROP ACCESS METHOD no_such_am ;
DROP ACCESS METHOD IF EXISTS no_such_am ;
DROP AGGREGATE IF EXISTS no_such_schema . foo ( INT ) ;
DROP AGGREGATE IF EXISTS x ( no_such_type ) ;
DROP AGGREGATE IF EXISTS x ( no_such_schema . no_such_type ) ;
DROP CAST IF EXISTS ( INTEGER AS no_such_type2 ) ;
DROP CAST IF EXISTS ( no_such_type1 AS INTEGER ) ;
DROP CAST IF EXISTS ( INTEGER AS no_such_schema . bar ) ;
DROP CAST IF EXISTS ( no_such_schema . foo AS INTEGER ) ;
DROP COLLATION IF EXISTS x . foo ;
DROP CONVERSION IF EXISTS x . foo ;
DROP DOMAIN IF EXISTS no_such_schema . foo ;
DROP FOREIGN TABLE IF EXISTS x . foo ;
DROP FUNCTION IF EXISTS no_such_schema . foo ( ) ;
DROP FUNCTION IF EXISTS x ( no_such_type ) ;
DROP FUNCTION IF EXISTS x ( no_such_schema . no_such_type ) ;
DROP INDEX IF EXISTS x . foo ;
DROP MATERIALIZED VIEW IF EXISTS x . foo ;
DROP OPERATOR IF EXISTS no_such_schema . + ( INT , INT ) ;
DROP OPERATOR IF EXISTS + ( no_such_type , no_such_type ) ;
DROP OPERATOR IF EXISTS + ( no_such_schema . no_such_type , no_such_schema . no_such_type ) ;
#DROP OPERATOR CLASS IF EXISTS no_such_schema . widget_ops USING btree ;
DROP OPERATOR FAMILY IF EXISTS no_such_schema . float_ops USING btree ;
DROP RULE IF EXISTS foo ON no_such_schema . bar ;
DROP SEQUENCE IF EXISTS x . foo ;
DROP TABLE IF EXISTS x . foo ;
DROP TEXT SEARCH CONFIGURATION IF EXISTS x . foo ;
DROP TEXT SEARCH DICTIONARY IF EXISTS x . foo ;
DROP TEXT SEARCH PARSER IF EXISTS x . foo ;
DROP TEXT SEARCH TEMPLATE IF EXISTS x . foo ;
DROP TRIGGER IF EXISTS foo ON no_such_schema . bar ;
DROP TYPE IF EXISTS no_such_schema . foo ;
DROP VIEW IF EXISTS x . foo ;
$$$$DROP FUNCTION test_ambiguous_funcname ;
DROP FUNCTION IF EXISTS test_ambiguous_funcname ;
DROP FUNCTION x ( INT ) ;
DROP FUNCTION x ( TEXT ) ;
$$$$DROP PROCEDURE test_ambiguous_procname ;
DROP PROCEDURE IF EXISTS test_ambiguous_procname ;
DROP ROUTINE IF EXISTS test_ambiguous_procname ;
DROP PROCEDURE x ( INT ) ;
DROP PROCEDURE x ( TEXT ) ;
DROP DATABASE x ( FORCE ) ;
DROP DATABASE x WITH ( FORCE ) ;
DROP DATABASE IF EXISTS x ( FORCE ) ;
DROP DATABASE IF EXISTS x WITH ( FORCE ) ;
CREATE TYPE mood AS ENUM ( 'x' , 'x' , 'x' ) ;
DROP TYPE mood ;
CREATE TABLE x ( x int8 , x int8 ) ;
INSERT INTO x VALUES ( 'x' , 'x' ) ;
INSERT INTO x VALUES ( + 1 , 'x' ) ;
INSERT INTO x ( x ) VALUES ( 'x' ) ;
SELECT * FROM x ;
SELECT * FROM x WHERE x = 1 ;
SELECT * FROM x WHERE x < 1 ;
SELECT * FROM x WHERE x > 1 ;
SELECT * FROM x WHERE x <= 1 ;
SELECT * FROM x WHERE x >= 1 ;
SELECT * FROM x WHERE 1 = x ;
SELECT * FROM x WHERE 1 < x ;
SELECT * FROM x WHERE 1 > x ;
SELECT * FROM x WHERE 1 <= x ;
SELECT * FROM x WHERE 1 >= x ;
SELECT 'x' AS five , x AS plus , - x AS minus FROM x ;
SELECT 'x' AS five , x , x , x + x AS plus FROM x ;
SELECT 'x' AS five , x , x , x - x AS minus FROM x ;
SELECT 'x' AS three , x , x , x * x AS multiply FROM x ;
SELECT 'x' AS three , x , x , x * x AS multiply FROM x WHERE x < 1 OR ( x > 1 AND x < 1 ) ;
SELECT 'x' AS five , x , x , x / x AS divide , x % x AS mod FROM x ;
SELECT 'x' AS five , x , x ( x ) FROM x ;
SELECT 1 + x AS plus4 FROM x ;
SELECT 1 - x AS minus4 FROM x ;
SELECT 'x' AS five , 1 * x AS twice int4" FROM x ;
SELECT 'x' AS five , x * 1 AS twice int4" FROM x ;
SELECT x ( x ) , x ( x ) FROM x ;
SELECT 'x' AS to_char_1 , x ( x , 'x' ) , x ( x , 'x' ) FROM x ;
SELECT 'x' AS to_char_2 , x ( x , 'x' ) , x ( x , 'x' ) FROM x ;
SELECT 'x' AS to_char_3 , x ( ( x * 1 ) , 'x' ) , x ( ( x * 1 ) , 'x' ) FROM x ;
SELECT 'x' AS to_char_4 , x ( ( x * 1 ) , 'x' ) , x ( ( x * 1 ) , 'x' ) FROM x ;
SELECT 'x' AS to_char_5 , x ( x , 'x' ) FROM x ;
SELECT 'x' AS to_char_6 , x ( x , 'x' ) FROM x ;
SELECT 'x' AS to_char_7 , x ( x , 'x' ) FROM x ;
SELECT 'x' AS to_char_8 , x ( x , 'x' ) FROM x ;
SELECT 'x' AS to_char_9 , x ( x , 'x' ) FROM x ;
SELECT 'x' AS to_char_10 , x ( x , 'x' ) FROM x ;
SELECT 'x' AS to_char_11 , x ( x , 'x' ) FROM x ;
SELECT 'x' AS to_char_12 , x ( x , 'x' ) FROM x ;
SELECT 'x' AS to_char_13 , x ( x , 'x' ) FROM x ;
SELECT 'x' AS to_char_14 , x ( x , 'x' ) FROM x ;
SELECT 'x' AS to_char_15 , x ( x , 'x' ) FROM x ;
SELECT 'x' AS to_char_16 , x ( x , x 'x' ) FROM x ;
SELECT 'x' AS to_char_17 , x ( x , 'x' ) FROM x ;
SELECT CAST ( x AS int4 ) FROM x WHERE x = 1 ;
SELECT CAST ( x AS int2 ) FROM x WHERE x = 1 ;
SELECT CAST ( x AS float4 ) , CAST ( x AS float8 ) FROM x ;
SELECT CAST ( x AS oid ) FROM x ;
#ANALYZE x ;
SELECT x , EXTRACT ( YEAR FROM x ) , x ( * ) FROM x GROUP BY 1 , 1 ORDER BY 1 , 1 ;
\CREATE TABLE x ( x INT , x INT , x TEXT ) ;
INSERT INTO x SELECT 1 , x , 'x' || x FROM x ( 1 , 1 ) x ;
\CREATE TYPE complex AS ( r float8 , i float8 ) ;
CREATE TYPE quad AS ( c1 complex , c2 complex ) ;
INSERT INTO x VALUES ( 1 , ( ( 3.300000 , 4.400000 ) , ( 5.500000 , 6.600000 ) ) ) ;
INSERT INTO x VALUES ( 1 , ( ( NULL , 4.400000 ) , ( 5.500000 , 6.600000 ) ) ) ;
CREATE TEMP TABLE x ( x fullname , x date ) ;
ALTER TABLE x ADD COLUMN x TEXT DEFAULT 'x' ;
ALTER TABLE x ADD COLUMN x TEXT DEFAULT NULL ;
UPDATE x SET x . suffix = 'x' ;
INSERT INTO x ( x , x . c1 . r , x . c2 . i ) VALUES ( 1 , 1 , 1 ) ;
CREATE TEMP TABLE x ( x TEXT ) ;
INSERT INTO x VALUES ( x ( 'x' , 1 ) ) ;
~~~~~~SELECT ROW ( 1 , 1 ) IN ( ROW ( 1 , 1 ) , ROW ( 1 , 1 ) ) ;
CREATE TEMP TABLE x ( x TEXT , x TEXT ) ;
INSERT INTO x SELECT 'x' , NULL FROM x ( 1 , 1 ) ;
CREATE INDEX ON x ( x , x ) ;
SET enable_sort = off ;
EXPLAIN ( costs off ) SELECT x , x FROM x WHERE ( x , x ) > ( 'x' , 'x' ) ORDER BY x , x ;
SELECT x , x FROM x WHERE ( x , x ) > ( 'x' , 'x' ) ORDER BY x , x ;
RESET enable_sort ;
SELECT ( ROW ( 1 , 2.000000 ) ) . f1 ;
SELECT ( ROW ( 1 , 2.000000 ) ) . f2 ;
SELECT ( x ) . f1 FROM ( SELECT ROW ( 1 , 2.000000 ) AS r ) ss ;
SELECT ROW ( ) ;
SELECT ROW ( ) IS NULL ;
SELECT ROW ( ) = ROW ( ) ;
SELECT ARRAY [ ROW ( 1 , 1 ) , ROW ( 1 , 1 ) , ROW ( 1 , 1 ) ] ;
SELECT ROW ( 1 , 1.100000 ) = ANY ( ARRAY [ ROW ( 1 , 7.700000 ) , ROW ( 1 , 1.100000 ) , ROW ( 1 , 0.000000 ) ] ) ;
SELECT ROW ( 1 , 1.100000 ) = ANY ( ARRAY [ ROW ( 1 , 7.700000 ) , ROW ( 1 , 1.000000 ) , ROW ( 1 , 0.000000 ) ] ) ;
CREATE TYPE cantcompare AS ( p point , r float8 ) ;
CREATE TEMP TABLE x ( x cantcompare ) ;
INSERT INTO x VALUES ( 'x' ) ;
CREATE TYPE testtype3 AS ( a INT , b TEXT ) ;
CREATE TYPE testtype5 AS ( a INT ) ;
CREATE TYPE testtype6 AS ( a INT , b point ) ;
DROP TYPE testtype1 , testtype3 , testtype5 , testtype6 ;
CREATE TYPE testtype1 AS ( a INT , b INT ) ;
SELECT x . x , x . x = ROW ( 1 ) , x . x = ARRAY [ ROW ( 1 ) ] , x . x = ROW ( ROW ( 1 ) ) FROM x ( ARRAY [ ROW ( 1 , ROW ( 1 ) , ARRAY [ ROW ( 1 ) ] , ROW ( ROW ( 1 ) ) ) , ROW ( 1 , ROW ( 1 ) , ARRAY [ ROW ( 1 ) ] , ROW ( ROW ( 1 ) ) ) ] ) AS q ( a INT , b record , c record [ ] , d record ) ;
DROP TYPE testtype1 , testtype2 , testtype3 , testtype4 , testtype5 , testtype6 ;
CREATE TABLE x ( x SERIAL PRIMARY KEY , x BOOLEAN NOT NULL , x NUMERIC ) ;
CREATE TYPE price_input AS ( id INTEGER , price NUMERIC ) ;
CREATE TYPE price_key AS ( id INTEGER ) ;
$$$$INSERT INTO x VALUES ( 1 , FALSE , 1 ) , ( 1 , FALSE , 1 ) , ( 1 , TRUE , 17.990000 ) ;
CREATE TEMP TABLE x ( x INT , x TEXT ) ;
$$$$$$$$$$$$$$SELECT x ( ROW ( 1 , 'x' ) ) ;
SELECT CAST ( x AS TEXT ) FROM x ;
$$SELECT x . x FROM x f ;
SELECT x ( x ) FROM x f ;
ALTER TABLE x ADD COLUMN x TEXT ;
SELECT x ( x ) FROM x i ;
SELECT x ( x ) FROM x i ( x , y ) ;
CREATE TEMP VIEW x AS SELECT * FROM x ;
SELECT x ( x ) FROM ( SELECT x , x FROM x ) AS ss ;
SELECT x ( x ) FROM ( SELECT x , x FROM x OFFSET 1 ) AS ss ;
SELECT x ( x ) FROM ( SELECT x AS a , x AS b FROM x ) AS ss ;
SELECT x ( x ) FROM ( SELECT x AS a , x AS b FROM x OFFSET 1 ) AS ss ;
SELECT x ( x ) FROM ( SELECT x AS a , x AS b FROM x ) AS ss ( x , y ) ;
SELECT x ( x ) FROM ( SELECT x AS a , x AS b FROM x OFFSET 1 ) AS ss ( x , y ) ;
EXPLAIN ( costs off ) SELECT x ( x ) FROM ( SELECT x , x FROM x WHERE x = 1 AND x < 1 OFFSET 1 ) q ;
SELECT x ( x ) FROM ( SELECT x , x FROM x WHERE x = 1 AND x < 1 OFFSET 1 ) q ;
SELECT x ( x ) FROM ( SELECT x AS x , x AS y FROM x WHERE x = 1 AND x < 1 OFFSET 1 ) q ;
SELECT x ( x ) FROM ( SELECT x AS x , x AS y FROM x WHERE x = 1 AND x < 1 OFFSET 1 ) q ( a , b ) ;
CREATE TEMP TABLE x AS SELECT * FROM x LIMIT 1 ;
CREATE TEMP TABLE x ( ) INHERITS ( x ) ;
INSERT INTO x VALUES ( 1 , 1 ) ;
SELECT x ( x ) FROM ( SELECT x , x FROM x OFFSET 1 ) r ;
CREATE TABLE x ( x TEXT , x TEXT ) ;
INSERT INTO x ( x , x ) VALUES ( 'x' , 'x' ) ;
SELECT x . x FROM ( SELECT x AS d FROM x ) s ;
SELECT ( x ) . a , ( x ) . b FROM ( SELECT x AS d FROM x ) s ;
SELECT ( x ) . ctid FROM ( SELECT x AS d FROM x ) s ;
SELECT x ( * ) AS should_be_1 FROM x ;
SELECT x ( * ) AS should_be_2 FROM x ;
SELECT x ( * ) AS should_be_3 FROM x ;
COPY x TO 'x' ;
\BEGIN TRANSACTION READ ONLY ;
BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ ;
COMMIT ;
ABORT ;
START TRANSACTION ;
SAVEPOINT s ;
RELEASE SAVEPOINT s ;
ROLLBACK TO SAVEPOINT s ;
SET synchronous_commit = ON ;
SHOW synchronous_commit ;
RESET synchronous_commit ;
DISCARD TEMP ;
DISCARD ALL ;
DECLARE hsc CURSOR FOR SELECT * FROM x ;
FETCH NEXT FROM hsc ;
FETCH FIRST FROM hsc ;
FETCH LAST FROM hsc ;
FETCH 1 FROM hsc ;
CLOSE hsc ;
PREPARE hsp AS SELECT x ( * ) FROM x ;
$PREPARE hsp_noexec ( INTEGER ) AS INSERT INTO x VALUES ( 1 ) ;
EXECUTE hsp ;
DEALLOCATE hsp ;
LOCK x IN ACCESS SHARE MODE ;
LOCK x IN ROW SHARE MODE ;
LOCK x IN ROW EXCLUSIVE MODE ;
UNLISTEN a ;
UNLISTEN * ;
CHECKPOINT ;
SELECT x ( ) ;
SELECT x ( x ( ) ) ;
_CREATE AGGREGATE x ( sfunc = int4_avg_accum , basetype = int4 , stype = int8 , finalfunc = int8_avg , initcond1 = 'x' ) ;
COMMENT ON AGGREGATE x ( int4 ) IS 'x' ;
COMMENT ON AGGREGATE x ( int4 ) IS NULL ;
CREATE AGGREGATE x ( sfunc1 = int4pl , basetype = int4 , stype1 = int4 , initcond1 = 'x' ) ;
CREATE AGGREGATE x ( sfunc = int8inc , basetype = 'x' , stype = int8 , initcond = 'x' ) ;
CREATE AGGREGATE x ( any" ) ( sfunc = int8inc_any , stype = int8 , initcond = 'x' ) ;
COMMENT ON AGGREGATE x ( * ) IS 'x' ;
COMMENT ON AGGREGATE x ( any" ) IS 'x' ;
CREATE AGGREGATE x ( int8 , int8 ) ( sfunc = sum3 , stype = int8 , initcond = 'x' ) ;
CREATE TYPE aggtype AS ( a INTEGER , b INTEGER , c TEXT ) ;
CREATE AGGREGATE x ( INTEGER , INTEGER , TEXT ) ( sfunc = aggf_trans , stype = aggtype [ ] , initcond = 'x' ) ;
CREATE AGGREGATE x ( INTEGER , INTEGER , TEXT ) ( sfunc = aggfns_trans , stype = aggtype [ ] , sspace = 1 , initcond = 'x' ) ;
CREATE AGGREGATE x ( VARIADIC items anyarray ) ( stype = anyelement , sfunc = least_accum ) ;
ALTER AGGREGATE x ( float8 ORDER BY anyelement ) RENAME TO test_percentile_disc ;
ALTER AGGREGATE x ( VARIADIC any" ORDER BY VARIADIC any" ) RENAME TO test_rank ;
DROP AGGREGATE x ( NUMERIC ) ;
DROP FUNCTION x ( int8 , int8 , int8 , int8 ) ;
$$$$CREATE TABLE x ( x INTEGER PRIMARY KEY ) ;
INSERT INTO x VALUES ( 1 ) ;
@SELECT x 'x' ? 'x' ;
@@@@@@@@@@@@@@@@@@@SELECT x ( 'x' , 'x' ) ;
SELECT x ( 'x' , 'x' , silent => TRUE ) ;
@@@@@@@@@@@@@@@@SELECT x ( 'x' , 'x' , silent => FALSE ) ;
SELECT * FROM x ( 'x' , 'x' ) ;
@@@@@@@@@@@@@SELECT x , x , x ( 'x' , 'x' , x ( 'x' , x , 'x' , x ) ) AS x && y" FROM ( VALUES ( x 'x' ) , ( 'x' ) , ( 'x' ) ) x ( x ) , ( VALUES ( x 'x' ) , ( 'x' ) , ( 'x' ) ) y ( y ) ;
SELECT x , x , x ( 'x' , 'x' , x ( 'x' , x , 'x' , x ) ) AS x || y" FROM ( VALUES ( x 'x' ) , ( 'x' ) , ( 'x' ) ) x ( x ) , ( VALUES ( x 'x' ) , ( 'x' ) , ( 'x' ) ) y ( y ) ;
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@SET TIME ZONE 'x' ;
SET TIME ZONE DEFAULT ;
SELECT x ( 'x' , 'x' , vars => 'x' ) ;
@@@@@@CREATE TABLE x ( x TEXT ) ;
SELECT 'x' AS two , * FROM x ;
SELECT x ( 1 ) ;
SELECT 'x' || 1 + 1 ;
SELECT 1 || 4.000000 ;
SELECT x ( 1 , 1 , 1 , 'x' , TRUE , FALSE , x ( 'x' , 'x' ) ) ;
SELECT x ( 'x' , 1 , 1 , 1 , 'x' , TRUE , FALSE , x ( 'x' , 'x' ) ) ;
SELECT x ( 'x' , 1 , 1 , NULL , 1 ) ;
SELECT x ( NULL , 1 , 1 , NULL , 1 ) IS NULL ;
SELECT x ( x 'x' ) ;
SELECT x ( VARIADIC ARRAY [ 1 , 1 , 1 ] ) ;
SELECT x ( 'x' , VARIADIC ARRAY [ 1 , 1 , 1 ] ) ;
SELECT x ( 'x' , VARIADIC 1 ) ;
SELECT x ( 'x' , 1 ) ;
SELECT x ( 'x' , 'x' , 1 , 'x' ) ;
SELECT x ( 'x' , 'x' , NULL , 'x' ) ;
SELECT x ( 'x' , 'x' , 1 , NULL ) ;
SELECT x ( 'x' , NULL , 1 , 'x' ) ;
SELECT x ( 'x' , 1 , 1 , 1 ) ;
SELECT x ( 'x' , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ) ;
SELECT x ( 'x' , VARIADIC ARRAY [ 'x' , 'x' ] ) ;
SELECT x ( 'x' , VARIADIC ARRAY [ 1 , 1 ] ) ;
SELECT x ( 'x' , VARIADIC ARRAY [ TRUE , FALSE ] ) ;
SELECT x ( x ( 'x' , 'x' ) , VARIADIC x ( x ) ) FROM x ( 1 , 1 ) g ( i ) ;
SELECT x ( 'x' , NULL ) ;
SELECT x ( 'x' , 1 , 'x' ) ;
SELECT x ( 'x' , 1 , NULL ) ;
SELECT x ( 'x' , NULL , 'x' ) ;
CREATE TYPE shell ;
CREATE TYPE int42 ;
CREATE TYPE text_w_default ;
CREATE FUNCTION x ( cstring ) RETURNS int42 AS 'x' LANGUAGE internal STRICT IMMUTABLE ;
CREATE FUNCTION x ( int42 ) RETURNS cstring AS 'x' LANGUAGE internal STRICT IMMUTABLE ;
CREATE FUNCTION x ( cstring ) RETURNS text_w_default AS 'x' LANGUAGE internal STRICT IMMUTABLE ;
CREATE FUNCTION x ( text_w_default ) RETURNS cstring AS 'x' LANGUAGE internal STRICT IMMUTABLE ;
CREATE TABLE x ( x text_w_default , x int42 ) ;
INSERT INTO x DEFAULT VALUES ;
CREATE TYPE case_int42 ( Internallength" = 1 , Input" = int42_in , Output" = int42_out , Alignment" = int4 , Default" = 1 , Passedbyvalue" ) ;
CREATE TYPE default_test_row AS ( f1 text_w_default , f2 int42 ) ;
SELECT * FROM x ( ) ;
COMMENT ON TYPE bad IS 'x' ;
COMMENT ON TYPE default_test_row IS 'x' ;
COMMENT ON TYPE default_test_row IS NULL ;
COMMENT ON COLUMN default_test_row . nope IS 'x' ;
COMMENT ON COLUMN default_test_row . f1 IS 'x' ;
COMMENT ON COLUMN default_test_row . f1 IS NULL ;
CREATE FUNCTION x ( cstring ) RETURNS opaque AS 'x' LANGUAGE internal IMMUTABLE STRICT ;
CREATE FUNCTION x ( opaque ) RETURNS opaque AS 'x' LANGUAGE internal IMMUTABLE STRICT ;
INSERT INTO x VALUES ( 'x' ) , ( 'x' ) ;
TABLE x ;
CREATE DOMAIN domaindroptest int4 ;
COMMENT ON DOMAIN domaindroptest IS 'x' ;
CREATE DOMAIN dependenttypetest domaindroptest ;
DROP DOMAIN domaindroptest ;
DROP DOMAIN domaindroptest CASCADE ;
CREATE DOMAIN domainvarchar VARCHAR ( 1 ) ;
CREATE DOMAIN domainnumeric NUMERIC ( 1 , 1 ) ;
CREATE DOMAIN domainint4 int4 ;
CREATE DOMAIN domaintext TEXT ;
SELECT CAST ( 'x' AS domainvarchar ) ;
CREATE TABLE x ( x domainint4 , x domaintext , x domainvarchar , x domainnumeric ) ;
DROP DOMAIN domainvarchar RESTRICT ;
DROP DOMAIN domainnumeric RESTRICT ;
DROP DOMAIN domainint4 RESTRICT ;
DROP DOMAIN domaintext ;
CREATE DOMAIN domainint4arr int4 [ 1 ] ;
CREATE DOMAIN domainchar4arr VARCHAR ( 1 ) [ 1 ] [ 1 ] ;
CREATE TABLE x ( x domainint4arr , x domainchar4arr ) ;
INSERT INTO x VALUES ( NULL , 'x' ) ;
INSERT INTO x ( x [ 1 ] , x [ 1 ] ) VALUES ( 1 , 1 ) ;
SELECT x [ 1 ] , x [ 1 : 1 ] FROM x ;
COPY x FROM STDIN ;
{UPDATE x SET x [ 1 ] = x [ 1 ] + 1 , x [ 1 ] = x [ 1 ] - 1 WHERE x IS NULL ;
SELECT * FROM x WHERE x IS NULL ;
DROP DOMAIN domainint4arr RESTRICT ;
DROP DOMAIN domainchar4arr RESTRICT ;
CREATE DOMAIN dia AS INT [ ] ;
CREATE TYPE comptype AS ( r float8 , i float8 ) ;
CREATE DOMAIN dcomptype AS comptype ;
CREATE TABLE x ( x dcomptype UNIQUE ) ;
SELECT ( x ) . r , ( x ) . i , ( x ) . * FROM x ;
UPDATE x SET x . r = ( x ) . r + 1 WHERE ( x ) . i > 1 ;
INSERT INTO x ( x . r , x . i ) VALUES ( 1 , 1 ) ;
CREATE RULE silly AS ON DELETE TO x DO INSTEAD UPDATE x SET x . r = ( x ) . r - 1 , x . i = ( x ) . i + 1 WHERE ( x ) . i > 1 ;
DROP TYPE comptype CASCADE ;
COMMENT ON CONSTRAINT c1 ON DOMAIN dcomptype IS 'x' ;
CREATE DOMAIN dcomptypea AS comptype [ ] ;
CREATE TABLE x ( x dcomptypea UNIQUE ) ;
INSERT INTO x ( x [ 1 ] . r ) VALUES ( 1 ) ;
SELECT x [ 1 ] , x [ 1 ] . x , x [ 1 ] . x FROM x ;
UPDATE x SET x [ 1 ] = ROW ( x [ 1 ] . x , x [ 1 ] . x ) ;
UPDATE x SET x [ 1 ] . r = x [ 1 ] . x + 1 WHERE x [ 1 ] . x > 1 ;
INSERT INTO x ( x [ 1 ] . r , x [ 1 ] . i ) VALUES ( 1 , 1 ) ;
CREATE RULE silly AS ON DELETE TO x DO INSTEAD UPDATE x SET x [ 1 ] . r = x [ 1 ] . x - 1 , x [ 1 ] . i = x [ 1 ] . x + 1 WHERE x [ 1 ] . x > 1 ;
CREATE TABLE x ( x posint [ ] ) ;
INSERT INTO x VALUES ( ARRAY [ 1 ] ) ;
CREATE DOMAIN vc4 AS VARCHAR ( 1 ) ;
CREATE TABLE x ( x vc4 [ ] ) ;
DROP TYPE vc4 ;
CREATE DOMAIN dposinta AS posint [ ] ;
CREATE TABLE x ( x dposinta [ ] ) ;
SELECT x ( x ) FROM x ;
SELECT x ( x [ 1 ] ) FROM x ;
SELECT x ( x [ 1 ] [ 1 ] ) FROM x ;
SELECT x ( ( x [ 1 ] ) [ 1 ] ) FROM x ;
UPDATE x SET x [ 1 ] = ARRAY [ 1 ] ;
SELECT x , x [ 1 ] , ( x [ 1 ] ) [ 1 ] FROM x ;
UPDATE x SET x [ 1 ] [ 1 ] = ARRAY [ 1 ] ;
DROP DOMAIN posint CASCADE ;
CREATE DOMAIN dnotnull VARCHAR ( 1 ) NOT NULL ;
CREATE DOMAIN dnull VARCHAR ( 1 ) ;
INSERT INTO x VALUES ( 'x' , 'x' , 'x' , 'x' , 'x' ) ;
INSERT INTO x VALUES ( NULL , 'x' , 'x' , 'x' , 'x' ) ;
INSERT INTO x VALUES ( 'x' , NULL , 'x' , 'x' , 'x' ) ;
INSERT INTO x VALUES ( 'x' , 'x' , NULL , 'x' , 'x' ) ;
SELECT CAST ( 'x' AS dnotnull ) ;
DROP DOMAIN dnotnull RESTRICT ;
DROP DOMAIN dnull RESTRICT ;
DROP DOMAIN dcheck RESTRICT ;
CREATE DOMAIN ddef1 int4 DEFAULT 1 ;
CREATE DOMAIN ddef2 oid DEFAULT 'x' ;
CREATE DOMAIN ddef3 TEXT DEFAULT 1 ;
CREATE DOMAIN ddef4 int4 DEFAULT x ( 'x' ) ;
CREATE DOMAIN ddef5 NUMERIC ( 1 , 1 ) NOT NULL DEFAULT 'x' ;
CREATE TABLE x ( x ddef1 , x ddef2 , x ddef3 , x ddef4 PRIMARY KEY , x ddef1 NOT NULL DEFAULT NULL , x ddef2 DEFAULT 'x' , x ddef4 DEFAULT 1 , x ddef5 ) ;
COPY x ( x ) FROM STDIN ;
DROP TABLE x CASCADE ;
CREATE DOMAIN dnotnulltest INTEGER ;
CREATE TABLE x ( x dnotnulltest , x dnotnulltest ) ;
ALTER DOMAIN dnotnulltest SET NOT NULL ;
UPDATE x SET x = NULL ;
DROP DOMAIN dnotnulltest CASCADE ;
CREATE TABLE x ( x ddef1 ) ;
ALTER DOMAIN ddef1 SET DEFAULT 'x' ;
ALTER DOMAIN ddef1 DROP DEFAULT ;
CREATE DOMAIN con AS INTEGER ;
CREATE TABLE x ( x con ) ;
ALTER DOMAIN con DROP CONSTRAINT t ;
ALTER DOMAIN con DROP CONSTRAINT nonexistent ;
ALTER DOMAIN con DROP CONSTRAINT IF EXISTS nonexistent ;
CREATE DOMAIN things AS INT ;
CREATE TABLE x ( x things ) ;
INSERT INTO x ( x ) VALUES ( 1 ) ;
ALTER DOMAIN things VALIDATE CONSTRAINT meow ;
UPDATE x SET x = 1 ;
CREATE TABLE x ( x INTEGER ) ;
CREATE DOMAIN dom AS INTEGER ;
CREATE VIEW x AS SELECT CAST ( x AS dom ) FROM x ;
INSERT INTO x ( x ) VALUES ( NULL ) ;
ALTER DOMAIN dom SET NOT NULL ;
DROP DOMAIN ddef1 RESTRICT ;
DROP DOMAIN ddef2 RESTRICT ;
DROP DOMAIN ddef3 RESTRICT ;
DROP DOMAIN ddef4 RESTRICT ;
DROP DOMAIN ddef5 RESTRICT ;
CREATE DOMAIN vchar4 VARCHAR ( 1 ) ;
DROP DOMAIN vchar4 CASCADE ;
CREATE DOMAIN str_domain AS TEXT NOT NULL ;
CREATE TABLE x ( x INT , x INT ) ;
ALTER TABLE x ADD COLUMN x str_domain ;
ALTER TABLE x ADD COLUMN x str_domain2 ;
$EXECUTE s1 ( 1 ) ;
$$$$$$CREATE TYPE ddtest1 AS ( f1 posint ) ;
CREATE TABLE x ( x ddtest1 ) ;
INSERT INTO x VALUES ( ROW ( 1 ) ) ;
CREATE TABLE x ( x ddtest1 [ ] ) ;
CREATE DOMAIN ddtest1d AS ddtest1 ;
CREATE TABLE x ( x ddtest1d ) ;
DROP DOMAIN ddtest1d ;
CREATE DOMAIN ddtest1d AS ddtest1 [ ] ;
CREATE TYPE rposint AS RANGE ( subtype = posint ) ;
CREATE TABLE x ( x rposint ) ;
DROP TYPE rposint ;
CREATE TABLE x ( x posint2 ) ;
DROP TYPE ddtest1 ;
$$$$SELECT x ( 121.000000 ) ;
SELECT x ( 1.234560 ) ;
CREATE DOMAIN mynums AS NUMERIC ( 1 , 1 ) [ 1 ] ;
$$$$CREATE DOMAIN mynums2 AS mynums ;
$$$$DROP FUNCTION x ( NUMERIC ) ;
$$$$CREATE DOMAIN di AS INT ;
$$$$$$$$DROP DOMAIN di ;
CREATE TABLE x ( x inotnull ) ;
INSERT INTO x VALUES ( NULL ) ;
DROP DOMAIN inotnull ;
DROP FUNCTION x ( anyelement , anyelement ) ;
CREATE DOMAIN testdomain1 AS INT ;
ALTER DOMAIN testdomain1 RENAME TO testdomain2 ;
ALTER DOMAIN testdomain1 RENAME CONSTRAINT unsigned TO unsigned_foo ;
ALTER DOMAIN testdomain1 DROP CONSTRAINT unsigned_foo ;
DROP DOMAIN testdomain1 ;
INSERT INTO x VALUES ( x ) ;
$$$$$$SELECT x ( * ) > 1 FROM x ;
CREATE TABLE x ( x float8 ) ;
SELECT 'x' AS five , * FROM x ;
SELECT 'x' AS one , x . * FROM x f WHERE x . x = 'x' ;
SELECT 'x' AS three , x . * FROM x f WHERE 'x' > x . x ;
SELECT 'x' AS three , x . * FROM x f WHERE x . x < 'x' ;
SELECT 'x' AS four , x . * FROM x f WHERE 'x' >= x . x ;
SELECT 'x' AS four , x . * FROM x f WHERE x . x <= 'x' ;
SELECT 'x' AS three , x . x , x . x * 'x' AS x FROM x f WHERE x . x > 'x' ;
SELECT 'x' AS three , x . x , x . x + 'x' AS x FROM x f WHERE x . x > 'x' ;
SELECT 'x' AS three , x . x , x . x / 'x' AS x FROM x f WHERE x . x > 'x' ;
SELECT 'x' AS three , x . x , x . x - 'x' AS x FROM x f WHERE x . x > 'x' ;
SELECT 'x' AS one , x . x ^ 'x' AS square_f1 FROM x f WHERE x . x = 'x' ;
@SELECT 'x' AS five , x . x , x . x AS abs_f1 FROM x f ;
SELECT 'x' AS five , x . x , x ( x . x ) AS trunc_f1 FROM x f ;
SELECT 'x' AS five , x . x , x ( x . x ) AS round_f1 FROM x f ;
SELECT x ( x ) AS ceil_f1 FROM x f ;
SELECT x ( x ) AS ceiling_f1 FROM x f ;
SELECT x ( x ) AS floor_f1 FROM x f ;
SELECT x ( x ) AS sign_f1 FROM x f ;
SET extra_float_digits = 1 ;
SELECT x ( x 'x' ) AS eight ;
SELECT x ( x 'x' , x 'x' ) ;
SELECT 'x' AS three , x . x , x ( x ( x . x ) ) AS exp_ln_f1 FROM x f WHERE x . x > 'x' ;
UPDATE x SET x = x . x * 'x' WHERE x . x > 'x' ;
SELECT 'x' AS bad , x . x * 'x' FROM x f ;
SELECT 'x' AS bad , x . x ^ 'x' FROM x f ;
SELECT 1 ^ 1 + 1 ^ 1 + 1 ^ 0.000000 + 1 ^ 0.500000 ;
SELECT 'x' AS bad , x ( x . x ) FROM x f WHERE x . x = 'x' ;
SELECT 'x' AS bad , x ( x . x ) FROM x f WHERE x . x < 'x' ;
SELECT 'x' AS bad , x ( x . x ) FROM x f ;
SELECT 'x' AS bad , x . x / 'x' FROM x f ;
RESET extra_float_digits ;
DELETE FROM x ;
CREATE TYPE xfloat8 ;
CREATE FUNCTION x ( cstring ) RETURNS xfloat8 IMMUTABLE STRICT LANGUAGE internal AS 'x' ;
CREATE FUNCTION x ( xfloat8 ) RETURNS cstring IMMUTABLE STRICT LANGUAGE internal AS 'x' ;
CREATE CAST ( xfloat8 AS float8 ) WITHOUT FUNCTION ;
CREATE CAST ( float8 AS xfloat8 ) WITHOUT FUNCTION ;
CREATE CAST ( xfloat8 AS BIGINT ) WITHOUT FUNCTION ;
CREATE CAST ( BIGINT AS xfloat8 ) WITHOUT FUNCTION ;
DROP TYPE xfloat8 CASCADE ;
INSERT INTO x VALUES ( 1 , 'x' , 1 ) , ( 1 , 'x' , 1 ) , ( 1 , 'x' , 1 ) , ( 1 , 'x' , 1 ) , ( 1 , 'x' , 1 ) ;
REFRESH MATERIALIZED VIEW x ;
CREATE MATERIALIZED VIEW x AS SELECT x ( x ) AS grandtot FROM x ;
CREATE UNIQUE INDEX x ON x ( ( x > 1 ) ) ;
CREATE UNIQUE INDEX x ON x ( x ) WHERE x < 1 ;
CREATE VIEW x AS SELECT x ( x ) AS grandtot FROM x ;
EXPLAIN ( costs off ) CREATE MATERIALIZED VIEW x AS SELECT * FROM x ;
CREATE MATERIALIZED VIEW x AS SELECT * FROM x ;
ALTER MATERIALIZED VIEW x SET SCHEMA mvtest_mvschema ;
SET search_path = mvtest_mvschema , public ;
INSERT INTO x VALUES ( 1 , 'x' , 1 ) ;
REFRESH MATERIALIZED VIEW CONCURRENTLY x ;
RESET search_path ;
EXPLAIN ( costs off ) SELECT * FROM x ;
DROP MATERIALIZED VIEW IF EXISTS x ;
REFRESH MATERIALIZED VIEW CONCURRENTLY x WITH NO DATA ;
SELECT * FROM x FOR SHARE ;
CREATE VIEW x AS SELECT 1 moo ;
CREATE VIEW x AS SELECT x , 1 * x FROM x UNION ALL SELECT x , 1 * x FROM x ;
CREATE MATERIALIZED VIEW x AS SELECT x , 1 * x FROM x UNION ALL SELECT x , 1 * x FROM x ;
CREATE MATERIALIZED VIEW x AS SELECT * FROM x WHERE x = 1 ;
DROP VIEW x CASCADE ;
CREATE TABLE x ( x , x ) AS VALUES ( 1 , 1 ) ;
CREATE UNIQUE INDEX ON x ( x ) ;
INSERT INTO x SELECT * FROM x ;
CREATE TABLE x ( x , x , x ) AS VALUES ( 1 , 1 , 1 ) ;
INSERT INTO x VALUES ( 1 , 1 , 1 ) ;
CREATE MATERIALIZED VIEW x AS SELECT 1 AS col1 WITH NO DATA ;
CREATE MATERIALIZED VIEW x AS SELECT * FROM x WHERE x = ( SELECT LEAST ( x ) FROM x ) WITH NO DATA ;
DROP MATERIALIZED VIEW x CASCADE ;
CREATE TABLE x ( x serial PRIMARY KEY , x box ) ;
INSERT INTO x ( x ) VALUES ( 'x' ) , ( 'x' ) , ( 'x' ) ;
CREATE UNIQUE INDEX x ON x ( x ) ;
UPDATE x SET x = 'x' WHERE x = 1 ;
SELECT * FROM x ORDER BY x ;
UPDATE x SET x = 1 WHERE x = 1 ;
DROP MATERIALIZED VIEW x ;
CREATE TABLE x AS SELECT x ( 1 , 1 ) AS a ;
CREATE MATERIALIZED VIEW x AS SELECT x FROM x WHERE x <= 1 ;
DELETE FROM x WHERE EXISTS ( SELECT * FROM x WHERE x . x = x . x ) ;
SET ROLE regress_user_mvtest ;
CREATE MATERIALIZED VIEW IF NOT EXISTS x AS SELECT * FROM x ;
DROP OWNED BY x CASCADE ;
$$CREATE MATERIALIZED VIEW x AS SELECT 1 AS x WITH NO DATA ;
$$SELECT x FROM x TABLESAMPLE x ( 1 ) REPEATABLE ( 1 ) ;
SELECT x FROM x TABLESAMPLE x ( 5.500000 ) REPEATABLE ( 1 ) ;
FETCH FIRST FROM tablesample_cur ;
FETCH NEXT FROM tablesample_cur ;
CLOSE tablesample_cur ;
EXPLAIN ( COSTS OFF ) SELECT * FROM x ;
EXPLAIN ( costs off ) SELECT x ( * ) FROM x TABLESAMPLE x ( 1 ) ;
SELECT x ( * ) FROM x TABLESAMPLE x ( 1 ) ;
SELECT x ( * ) FROM x ;
SELECT * FROM ( VALUES ( 1 ) , ( 1 ) ) v ( pct ) , LATERAL ( SELECT x ( * ) FROM x TABLESAMPLE x ( x ) ) ss ;
EXPLAIN ( costs off ) SELECT x , x ( x ) FROM ( VALUES ( 1 ) , ( 1 ) ) v ( pct ) , LATERAL ( SELECT * FROM x TABLESAMPLE x ( x ) ) ss GROUP BY x ;
SELECT x , x ( x ) FROM ( VALUES ( 1 ) , ( 1 ) ) v ( pct ) , LATERAL ( SELECT * FROM x TABLESAMPLE x ( x ) ) ss GROUP BY x ;
SELECT x FROM x TABLESAMPLE x ( 1 ) ;
WITH query_select AS ( SELECT * FROM x ) SELECT * FROM x TABLESAMPLE x ( 5.500000 ) REPEATABLE ( 1 ) ;
CREATE TABLE x ( x INT ) PARTITION BY list ( a ) ;
CREATE TABLE x PARTITION OF x FOR VALUES IN ( 1 ) ;
EXPLAIN ( costs off ) SELECT * FROM x TABLESAMPLE x ( 1 ) ;
DROP TABLE x , x , x ;
$$$$SELECT * INTO TABLE x FROM x ;
SELECT * INTO TABLE x FROM x WHERE x < 1 ;
INSERT INTO x VALUES ( 'x' , 'x' , 'x' ) , ( 'x' , 'x' , 'x' ) ;
UPDATE x SET x = 'x' ;
CREATE TABLE x ( x int4 , x float4 , x polygon ) ;
SET DateStyle = 'x' ;
SELECT TIMESTAMP WITH TIME ZONE 'x' ;
SET datestyle TO dmy ;
RESET datestyle ;
SELECT TIME WITHOUT TIME ZONE 'x' ;
SELECT TIME WITH TIME ZONE 'x' ;
SELECT x 'x' AS Confucius' Birthday" ;
SELECT x 'x' AS Julian Epoch" ;
SELECT x 'x' + TIME 'x' AS Date + Time" ;
SELECT x 'x' + TIME WITH TIME ZONE 'x' AS Date + Time PST" ;
SELECT x 'x' + TIME WITH TIME ZONE 'x' AS Date + Time UTC" ;
SELECT x 'x' + INTERVAL 'x' AS Add Two Years" ;
SELECT x 'x' - INTERVAL 'x' AS Subtract Two Years" ;
SELECT x 'x' - TIME 'x' AS Subtract Time" ;
SELECT x 'x' - TIME WITH TIME ZONE 'x' AS Subtract Time UTC" ;
SELECT TIMESTAMP WITHOUT TIME ZONE 'x' - INTERVAL 'x' AS Feb 29" ;
SELECT TIMESTAMP WITHOUT TIME ZONE 'x' - INTERVAL 'x' AS Feb 28" ;
SELECT TIMESTAMP WITHOUT TIME ZONE 'x' + INTERVAL 'x' AS Dec 31" ;
SELECT TIMESTAMP WITHOUT TIME ZONE 'x' + INTERVAL 'x' AS Feb 23, 285506" ;
SELECT TIMESTAMP WITHOUT TIME ZONE 'x' + INTERVAL 'x' AS Jan 20, 288244" ;
SELECT TIMESTAMP WITHOUT TIME ZONE 'x' + INTERVAL 'x' AS Dec 31, 294276" ;
SELECT TIMESTAMP WITHOUT TIME ZONE 'x' - TIMESTAMP WITHOUT TIME ZONE 'x' AS 106751991 Days" ;
SELECT ( TIMESTAMP WITHOUT TIME ZONE 'x' = ( TIMESTAMP WITHOUT TIME ZONE 'x' + INTERVAL 'x' ) ) AS True" ;
SELECT ( TIMESTAMP WITHOUT TIME ZONE 'x' = ( TIMESTAMP WITHOUT TIME ZONE 'x' - INTERVAL 'x' ) ) AS True" ;
SELECT ( TIMESTAMP WITHOUT TIME ZONE 'x' > 'x' ) AS True" ;
SELECT x 'x' + TIME 'x' AS Jan_01_1994_11am" ;
SELECT x 'x' + TIME 'x' AS Jan_01_1994_10am" ;
SELECT x 'x' + x 'x' AS Jan_01_1994_8am" ;
SELECT x ( x 'x' , TIME WITH TIME ZONE 'x' ) AS Jan_01_1994_8am" ;
SELECT 'x' AS 64" , x + INTERVAL 'x' AS one_year FROM x ;
SELECT 'x' AS 64" , x - INTERVAL 'x' AS one_year FROM x ;
SELECT TIMESTAMP WITH TIME ZONE 'x' - INTERVAL 'x' AS Feb 29" ;
SELECT TIMESTAMP WITH TIME ZONE 'x' - INTERVAL 'x' AS Feb 28" ;
SELECT TIMESTAMP WITH TIME ZONE 'x' + INTERVAL 'x' AS Dec 31" ;
SELECT ( TIMESTAMP WITH TIME ZONE 'x' = ( TIMESTAMP WITH TIME ZONE 'x' + INTERVAL 'x' ) ) AS True" ;
SELECT ( TIMESTAMP WITH TIME ZONE 'x' = ( TIMESTAMP WITH TIME ZONE 'x' - INTERVAL 'x' ) ) AS True" ;
SELECT ( TIMESTAMP WITH TIME ZONE 'x' > 'x' ) AS True" ;
SELECT TIMESTAMP WITH TIME ZONE 'x' + INTERVAL 'x' AS Apr 3, 12:00" ;
SELECT TIMESTAMP WITH TIME ZONE 'x' + INTERVAL 'x' AS Apr 3, 13:00" ;
SELECT TIMESTAMP WITH TIME ZONE 'x' - INTERVAL 'x' AS Apr 2, 12:00" ;
SELECT TIMESTAMP WITH TIME ZONE 'x' - INTERVAL 'x' AS Apr 2, 11:00" ;
RESET TIME ZONE ;
SELECT x ( x 'x' , TIME 'x' ) AS Jan_01_1994_10am" ;
SELECT x ( x 'x' , TIME 'x' ) AS Jan_01_1994_9am" ;
SELECT x ( x 'x' , TIME WITH TIME ZONE 'x' ) AS Jan_01_1994_11am" ;
SELECT x ( x 'x' , TIME WITH TIME ZONE 'x' ) AS Jan_01_1994_10am" ;
SELECT CAST ( TIME 'x' AS INTERVAL ) AS +01:02" ;
SELECT CAST ( INTERVAL 'x' AS TIME ) AS 02:03:00" ;
SELECT TIME 'x' + INTERVAL 'x' AS 03:31:00" ;
SELECT TIME 'x' - INTERVAL 'x' AS 23:29:00" ;
SELECT TIME 'x' + INTERVAL 'x' AS 14:31:00" ;
SELECT TIME 'x' + INTERVAL 'x' AS 07:31:00" ;
SELECT CAST ( TIME WITH TIME ZONE 'x' AS INTERVAL ) AS +00:01" ;
SELECT CAST ( INTERVAL 'x' AS TIME WITH TIME ZONE ) AS 02:03:00-08" ;
SELECT TIME WITH TIME ZONE 'x' - INTERVAL 'x' AS 23:29:00-08" ;
SELECT TIME WITH TIME ZONE 'x' + INTERVAL 'x' AS 14:31:00-08" ;
SELECT CAST ( CAST ( x 'x' + TIME WITH TIME ZONE 'x' + INTERVAL 'x' AS TIME WITH TIME ZONE ) AS TIME ) AS 07:31:00" ;
SELECT CAST ( CAST ( x 'x' + TIME WITH TIME ZONE 'x' + INTERVAL 'x' AS TIMESTAMP WITHOUT TIME ZONE ) AS TIME ) AS 07:31:00" ;
SELECT x . x AS t , x . x AS i , x . x + x . x AS add" , x . x - x . x AS subtract" FROM x t , x i WHERE x . x BETWEEN 'x' AND 'x' AND x . x BETWEEN 'x' AND 'x' ORDER BY 1 , 1 ;
SELECT x . x AS t , x . x AS i , x . x + x . x AS add" , x . x - x . x AS subtract" FROM x t , x i ORDER BY 1 , 1 ;
SELECT ( TIMESTAMP WITH TIME ZONE 'x' , TIMESTAMP WITH TIME ZONE 'x' ) OVERLAPS ( TIMESTAMP WITH TIME ZONE 'x' , TIMESTAMP WITH TIME ZONE 'x' ) AS True" ;
SELECT ( TIMESTAMP WITH TIME ZONE 'x' , TIMESTAMP WITH TIME ZONE 'x' ) OVERLAPS ( TIMESTAMP WITH TIME ZONE 'x' , TIMESTAMP WITH TIME ZONE 'x' ) AS False" ;
SELECT ( TIMESTAMP WITH TIME ZONE 'x' , TIMESTAMP WITH TIME ZONE 'x' ) OVERLAPS ( TIMESTAMP WITH TIME ZONE 'x' , INTERVAL 'x' ) AS True" ;
SELECT ( TIMESTAMP WITH TIME ZONE 'x' , INTERVAL 'x' ) OVERLAPS ( TIMESTAMP WITH TIME ZONE 'x' , TIMESTAMP WITH TIME ZONE 'x' ) AS False" ;
SELECT ( TIMESTAMP WITH TIME ZONE 'x' , INTERVAL 'x' ) OVERLAPS ( TIMESTAMP WITH TIME ZONE 'x' , INTERVAL 'x' ) AS True" ;
SELECT ( TIMESTAMP WITH TIME ZONE 'x' , INTERVAL 'x' ) OVERLAPS ( TIMESTAMP WITH TIME ZONE 'x' , INTERVAL 'x' ) AS False" ;
SELECT ( TIMESTAMP WITHOUT TIME ZONE 'x' , TIMESTAMP WITHOUT TIME ZONE 'x' ) OVERLAPS ( TIMESTAMP WITHOUT TIME ZONE 'x' , TIMESTAMP WITHOUT TIME ZONE 'x' ) AS True" ;
SELECT ( TIMESTAMP WITHOUT TIME ZONE 'x' , TIMESTAMP WITHOUT TIME ZONE 'x' ) OVERLAPS ( TIMESTAMP WITHOUT TIME ZONE 'x' , TIMESTAMP WITHOUT TIME ZONE 'x' ) AS False" ;
SELECT ( TIMESTAMP WITHOUT TIME ZONE 'x' , TIMESTAMP WITHOUT TIME ZONE 'x' ) OVERLAPS ( TIMESTAMP WITHOUT TIME ZONE 'x' , INTERVAL 'x' ) AS True" ;
SELECT ( TIMESTAMP WITHOUT TIME ZONE 'x' , INTERVAL 'x' ) OVERLAPS ( TIMESTAMP WITHOUT TIME ZONE 'x' , TIMESTAMP WITHOUT TIME ZONE 'x' ) AS False" ;
SELECT ( TIMESTAMP WITHOUT TIME ZONE 'x' , INTERVAL 'x' ) OVERLAPS ( TIMESTAMP WITHOUT TIME ZONE 'x' , INTERVAL 'x' ) AS True" ;
SELECT ( TIMESTAMP WITHOUT TIME ZONE 'x' , INTERVAL 'x' ) OVERLAPS ( TIMESTAMP WITHOUT TIME ZONE 'x' , INTERVAL 'x' ) AS False" ;
SELECT ( TIME 'x' , TIME 'x' ) OVERLAPS ( TIME 'x' , TIME 'x' ) AS True" ;
SELECT ( TIME 'x' , INTERVAL 'x' ) OVERLAPS ( TIME 'x' , INTERVAL 'x' ) AS True" ;
SELECT ( TIME 'x' , INTERVAL 'x' ) OVERLAPS ( TIME 'x' , INTERVAL 'x' ) AS False" ;
CREATE TABLE x ( x TIMESTAMP WITH TIME ZONE ) ;
INSERT INTO x ( x ) SELECT x FROM x WHERE x BETWEEN 'x' AND 'x' OR x BETWEEN 'x' AND 'x' ;
SELECT 'x' AS 16" , x AS timestamp" FROM x ORDER BY x ;
SELECT 'x' AS 160" , x . x AS timestamp" , x . x AS interval" , x . x + x . x AS plus FROM x d , x t ORDER BY x , x , x ;
SELECT 'x' AS 160" , x . x AS timestamp" , x . x AS interval" , x . x - x . x AS minus FROM x d , x t WHERE x ( x . x ) ORDER BY x , x , x ;
SELECT 'x' AS 16" , x . x AS timestamp" , TIMESTAMP WITH TIME ZONE 'x' AS gpstime_zero , x . x - TIMESTAMP WITH TIME ZONE 'x' AS difference FROM x d ORDER BY x ;
SELECT 'x' AS 226" , x . x AS timestamp1 , x . x AS timestamp2 , x . x - x . x AS difference FROM x d1 , x d2 ORDER BY x , x , x ;
SET DateStyle TO 'x' ;
SHOW DateStyle ;
SELECT 'x' AS 64" , x AS us_postgres FROM x ;
SELECT 'x' AS 64" , x AS us_iso FROM x ;
SELECT 'x' AS 64" , x AS us_sql FROM x ;
SELECT x ( * ) AS one FROM x WHERE x = 'x' ;
SELECT 'x' AS 65" , x AS european_postgres FROM x ;
SELECT 'x' AS 65" , x AS european_iso FROM x ;
SELECT 'x' AS 65" , x AS european_sql FROM x ;
RESET DateStyle ;
SELECT x ( 'x' , x 'x' ) ;
SELECT x , x ( 'x' , 'x' || x ) FROM x ( 1 , 1 ) i ;
SHOW TIME ZONE ;
CREATE TEMP TABLE x ( x INT ) ;
CREATE TEMP TABLE x ( x FLOAT ) ;
INSERT INTO x VALUES ( 2.100000 ) ;
\CREATE TEMP TABLE x ( x INT ) ON COMMIT DELETE ROWS ;
CREATE INDEX ON x ( x ( 'x' ) ) ;
CREATE TEMP TABLE x ( x ) ON COMMIT DELETE ROWS AS SELECT 1 ;
CREATE TEMP TABLE x ( x INT ) ON COMMIT DROP ;
CREATE TEMP TABLE x ( x ) ON COMMIT DROP AS SELECT 1 ;
CREATE TABLE x ( x INT ) ON COMMIT DELETE ROWS ;
CREATE TABLE x ( x ) ON COMMIT DELETE ROWS AS SELECT 1 ;
CREATE TEMP TABLE x ( x INT PRIMARY KEY ) ;
CREATE TEMP TABLE x ( x INT REFERENCES x ) ON COMMIT DELETE ROWS ;
CREATE TEMP TABLE x ( x INT PRIMARY KEY ) ON COMMIT DELETE ROWS ;
CREATE TEMP TABLE x ( x INT REFERENCES x ) ;
CREATE TABLE x . whereami ( x TEXT ) ;
INSERT INTO x . whereami VALUES ( 'x' ) ;
$$$$SET search_path = pg_temp , public ;
SET search_path = public , pg_temp ;
SELECT pg_temp . whoami ( ) ;
DROP TABLE x . whereami ;
SELECT pg_temp . nonempty ( 'x' ) ;
CREATE TEMP TABLE x ( x INT ) PARTITION BY list ( a ) ON COMMIT DELETE ROWS ;
CREATE TEMP TABLE x PARTITION OF x FOR VALUES IN ( 1 ) ON COMMIT DELETE ROWS ;
CREATE TEMP TABLE x ( x INT ) PARTITION BY list ( a ) ON COMMIT DROP ;
CREATE TEMP TABLE x PARTITION OF x FOR VALUES IN ( 1 ) ON COMMIT DROP ;
INSERT INTO x VALUES ( 1 ) , ( 1 ) ;
~SELECT x FROM x WHERE x 'x' ;
CREATE TEMP TABLE x PARTITION OF x FOR VALUES IN ( 1 ) ON COMMIT PRESERVE ROWS ;
~SELECT x FROM x WHERE x 'x' ORDER BY x ;
CREATE TEMP TABLE x ( ) INHERITS ( x ) ON COMMIT DELETE ROWS ;
~CREATE TEMP TABLE x ( ) INHERITS ( x ) ON COMMIT DROP ;
~$$PREPARE TRANSACTION 'x' ;
$$DROP FUNCTION pg_temp . twophase_func ( ) ;
@@CREATE TYPE pg_temp . twophase_type AS ( a INT ) ;
CREATE VIEW x . twophase_view AS SELECT 1 ;
CREATE SEQUENCE x . twophase_seq ;
SELECT x FROM x ;
LOCK x IN ACCESS EXCLUSIVE MODE ;
\CREATE TABLE x ( x INT DEFAULT 1 , x INT , x TEXT ) ;
CREATE TABLE x ( x INT PRIMARY KEY , x TEXT ) ;
INSERT INTO x VALUES ( 1 , 1 , 'x' ) ;
INSERT INTO x ( x , x ) VALUES ( 1 , 1 ) ;
UPDATE x SET x = DEFAULT , x = DEFAULT ;
UPDATE x AS x SET x = 1 WHERE x . x = 1 ;
UPDATE x x SET x = x . x + 1 WHERE x . x = 1 ;
UPDATE x SET x = x . x FROM ( VALUES ( 1 , 1 ) ) AS v ( i , j ) WHERE x . x = x . x ;
UPDATE x SET x = x . * FROM ( VALUES ( 1 , 1 ) ) AS v ( i , j ) WHERE x . x = x . x ;
INSERT INTO x SELECT x , x + 1 , x FROM x ;
UPDATE x SET ( x , x , x ) = ( 'x' , x + 1 , DEFAULT ) WHERE x = 'x' ;
UPDATE x SET ( x , x ) = ( 'x' , x + x ) , x = x + 1 WHERE x = 1 ;
UPDATE x SET ( x , x ) = ( SELECT x , x FROM x WHERE x = 1 AND x = 'x' ) WHERE x = 1 AND x = 1 ;
UPDATE x x SET ( x , x ) = ( SELECT x + 1 , x FROM x i WHERE x . x = x . x AND x . x = x . x AND x . x IS NOT DISTINCT FROM x . x ) ;
UPDATE x SET ( x , x ) = ( SELECT x + 1 , x FROM x ) ;
UPDATE x SET ( x , x ) = ( SELECT x + 1 , x FROM x WHERE x = 1 ) WHERE x = 1 ;
UPDATE x SET ( x , x ) = ROW ( x . * ) FROM ( VALUES ( 1 , 1 ) ) AS v ( i , j ) WHERE x . x = x . x ;
UPDATE x SET ( x , x ) = ( x . * ) FROM ( VALUES ( 1 , 1 ) ) AS v ( i , j ) WHERE x . x = x . x ;
UPDATE x AS x SET x = x . x + 1 WHERE x . x = 1 ;
UPDATE x SET x = x ( 'x' , 1 ) WHERE x = 'x' ;
SELECT x , x , x ( x ) FROM x ;
UPDATE x x SET ( x , x ) = ( SELECT x , x FROM x s WHERE x . x = x . x ) WHERE CURRENT_USER = SESSION_USER ;
INSERT INTO x VALUES ( 1 , 'x' ) ;
WITH aaa AS ( SELECT 1 AS a , 'x' AS b ) INSERT INTO x VALUES ( 1 , 'x' ) ON CONFLICT ( x ) DO UPDATE SET ( x , x ) = ( SELECT x , x FROM x ) RETURNING * ;
INSERT INTO x VALUES ( 1 , 'x' ) ON CONFLICT ( x ) DO UPDATE SET ( x , x ) = ( SELECT x || 'x' , x FROM x i WHERE x . x = x . x ) RETURNING * ;
CREATE TABLE x ( x VARCHAR , x NUMERIC , x TEXT , x BIGINT , x INT ) ;
ALTER TABLE x ATTACH PARTITION x FOR VALUES FROM ( 'x' , 1 ) TO ( 'x' , 1 ) ;
CREATE TABLE x PARTITION OF x FOR VALUES FROM ( 'x' , 1 ) TO ( 'x' , 1 ) ;
UPDATE x SET x = x - 1 ;
ALTER TABLE x DROP COLUMN x , DROP COLUMN x , DROP COLUMN x ;
ALTER TABLE x ADD COLUMN x NUMERIC , ADD COLUMN x VARCHAR , ADD COLUMN x TEXT ;
ALTER TABLE x DROP COLUMN x ;
ALTER TABLE x ADD COLUMN x BIGINT ;
CREATE TABLE x PARTITION OF x FOR VALUES FROM ( 1 ) TO ( 1 ) ;
ALTER TABLE x ATTACH PARTITION x FOR VALUES FROM ( 1 ) TO ( 1 ) ;
CREATE TABLE x ( x VARCHAR , x INT , x NUMERIC , x BIGINT , x TEXT ) ;
\EXPLAIN ( costs off ) UPDATE x SET x = x - 1 WHERE x > 1 ;
UPDATE x SET x = x - 1 , x = x WHERE x = 1 ;
UPDATE x SET x = x - 1 WHERE x > 1 ;
UPDATE x SET x = x ;
UPDATE x SET x = x + 1 WHERE x = 1 ;
UPDATE x SET x = x + 1 RETURNING x , x , x ;
UPDATE x SET x = x - 1 WHERE x > 1 RETURNING * ;
UPDATE x SET x = x - 1 WHERE x > 1 RETURNING x , x + x ;
CREATE VIEW x AS SELECT * FROM x WHERE ( SELECT x > x FROM x ) WITH CHECK OPTION ;
UPDATE x SET x = 'x' , x = 1 , x = 1 WHERE x = 1 ;
UPDATE x SET x = 'x' , x = 1 WHERE x = 1 ;
UPDATE x SET x = 1 WHERE x = 'x' AND x > 1 AND x > 1 RETURNING ( x ) , * ;
$$CREATE TRIGGER x AFTER UPDATE ON x REFERENCING OLD TABLE AS old_table NEW TABLE AS new_table FOR EACH STATEMENT EXECUTE PROCEDURE x ( ) ;
UPDATE x SET x = ( CASE WHEN x = 1 THEN 1 ELSE x + 1 END ) WHERE x = 'x' AND x > 1 AND x >= 1 ;
CREATE TRIGGER x AFTER DELETE ON x REFERENCING OLD TABLE AS old_table FOR EACH STATEMENT EXECUTE PROCEDURE x ( ) ;
CREATE TRIGGER x AFTER INSERT ON x REFERENCING NEW TABLE AS new_table FOR EACH STATEMENT EXECUTE PROCEDURE x ( ) ;
UPDATE x SET x = x + 1 WHERE x = 'x' AND x > 1 AND x >= 1 ;
DROP TRIGGER trans_deletetrig ON range_parted ;
DROP TRIGGER trans_inserttrig ON range_parted ;
$$CREATE TRIGGER x BEFORE UPDATE OR INSERT ON x FOR EACH ROW EXECUTE PROCEDURE x ( ) ;
DROP TRIGGER trans_updatetrig ON range_parted ;
DROP TRIGGER trig_c1_100 ON part_c_1_100 ;
DROP TRIGGER trig_d1_15 ON part_d_1_15 ;
DROP TRIGGER trig_d15_20 ON part_d_15_20 ;
ALTER TABLE x ENABLE ROW LEVEL SECURITY ;
GRANT ALL ON x , x TO x ;
CREATE POLICY seeall ON x AS PERMISSIVE FOR SELECT USING ( TRUE ) ;
CREATE POLICY policy_range_parted ON x FOR UPDATE USING ( TRUE ) WITH CHECK ( x % 1 = 1 ) ;
SET SESSION AUTHORIZATION regress_range_parted_user ;
UPDATE x SET x = 'x' , x = 1 WHERE x = 'x' AND x = 1 ;
$$CREATE TRIGGER x BEFORE INSERT ON x FOR EACH ROW EXECUTE PROCEDURE x ( ) ;
DROP TRIGGER trig_d_1_15 ON part_d_1_15 ;
CREATE POLICY policy_range_parted_subplan ON x AS RESTRICTIVE FOR UPDATE USING ( TRUE ) WITH CHECK ( ( SELECT x . x <= x FROM x ) ) ;
DROP POLICY policy_range_parted ON range_parted ;
DROP POLICY policy_range_parted_subplan ON range_parted ;
DROP POLICY policy_range_parted_wholerow ON range_parted ;
REVOKE ALL ON x , x FROM x ;
$$CREATE TRIGGER x AFTER DELETE ON x FOR EACH STATEMENT EXECUTE PROCEDURE x ( ) ;
CREATE TRIGGER x AFTER UPDATE ON x FOR EACH STATEMENT EXECUTE PROCEDURE x ( ) ;
CREATE TRIGGER x AFTER INSERT ON x FOR EACH STATEMENT EXECUTE PROCEDURE x ( ) ;
DROP TRIGGER parent_delete_trig ON range_parted ;
DROP TRIGGER parent_update_trig ON range_parted ;
DROP TRIGGER parent_insert_trig ON range_parted ;
DROP TRIGGER c1_delete_trig ON part_c_1_100 ;
DROP TRIGGER c1_update_trig ON part_c_1_100 ;
DROP TRIGGER c1_insert_trig ON part_c_1_100 ;
DROP TRIGGER d1_delete_trig ON part_d_1_15 ;
DROP TRIGGER d1_update_trig ON part_d_1_15 ;
DROP TRIGGER d1_insert_trig ON part_d_1_15 ;
DROP TRIGGER d15_delete_trig ON part_d_15_20 ;
DROP TRIGGER d15_update_trig ON part_d_15_20 ;
DROP TRIGGER d15_insert_trig ON part_d_15_20 ;
CREATE TABLE x PARTITION OF x DEFAULT ;
INSERT INTO x VALUES ( 'x' , 1 ) ;
UPDATE x SET x = 'x' WHERE x = 'x' ;
CREATE TABLE x ( x TEXT , x INT ) PARTITION BY list ( a ) ;
CREATE TABLE x PARTITION OF x FOR VALUES IN ( 'x' , 'x' ) ;
CREATE TABLE x ( x NUMERIC , x INT , x int8 ) PARTITION BY list ( a ) ;
CREATE TABLE x PARTITION OF x FOR VALUES IN ( 1 ) PARTITION BY list ( b ) ;
CREATE TABLE x ( x INT , x int8 , x NUMERIC ) ;
ALTER TABLE x ATTACH PARTITION x FOR VALUES IN ( 1 ) ;
CREATE TABLE x ( x NUMERIC , x INT , x int8 ) ;
ALTER TABLE x ATTACH PARTITION x FOR VALUES IN ( 1 , 1 ) ;
UPDATE x SET x = x + x WHERE x = 1 ;
$$DROP TRIGGER parted_mod_b ON sub_part1 ;
$$CREATE TRIGGER x BEFORE DELETE ON x FOR EACH ROW EXECUTE PROCEDURE x ( ) ;
DROP TRIGGER trig_skip_delete ON sub_part2 ;
INSERT INTO x VALUES ( 1 ) , ( 1 ) , ( 1 ) , ( 1 ) , ( 1 ) , ( 1 ) , ( 1 ) , ( 1 ) , ( 1 ) ;
UPDATE x x SET x = 1 FROM x t2 WHERE x . x = x . x AND x = 1 ;
$$CREATE TABLE x ( x INT , x INT ) PARTITION BY hash ( a custom_opclass , b custom_opclass ) ;
CREATE TABLE x PARTITION OF x FOR VALUES WITH ( modulus 1 , remainder 1 ) ;
UPDATE x SET x = 1 , x = 1 WHERE x = 1 ;
UPDATE x SET x = x - 1 WHERE x = 1 ;
DROP OPERATOR CLASS custom_opclass USING hash ;
DROP FUNCTION x ( a int4 , seed int8 ) ;
EXPLAIN ( costs off ) INSERT INTO x VALUES ( 1 , 'x' ) ON CONFLICT ( x ) DO NOTHING ;
CREATE UNIQUE INDEX x ON x ( x ( x ) COLLATE C" , x ( x ) text_pattern_ops ) ;
EXPLAIN ( costs off ) INSERT INTO x VALUES ( 1 , 'x' ) ON CONFLICT ( x ( x ) text_pattern_ops , x ( x ) COLLATE C" ) DO NOTHING ;
EXPLAIN ( costs off ) INSERT INTO x VALUES ( 1 , 'x' ) ON CONFLICT ( x ( x ) COLLATE C" , x ( x ) text_pattern_ops ) DO NOTHING ;
INSERT INTO x VALUES ( 1 , 'x' ) ON CONFLICT DO UPDATE SET x = x . x ;
INSERT INTO x VALUES ( 1 , 'x' ) ON CONFLICT ( x ) DO UPDATE SET x = x . x ;
INSERT INTO x VALUES ( 1 , 'x' ) ON CONFLICT ( x ( x ) ) DO UPDATE SET x = x . x ;
CREATE UNIQUE INDEX x ON x ( x ( x ) ) ;
INSERT INTO x VALUES ( 1 , 'x' ) ON CONFLICT ( x ( x ) , x ( x ) ) DO UPDATE SET x = x . x ;
INSERT INTO x VALUES ( 1 , 'x' ) ON CONFLICT ( x ) WHERE x LIKE 'x' DO UPDATE SET x = x . x ;
CREATE TABLE x ( x BIGINT , x BIGINT ) ;
CREATE UNIQUE INDEX x ON x ( COALESCE ( x , 1 ) ) ;
CREATE UNIQUE INDEX x ON x ( x ) WHERE COALESCE ( x , 1 ) > 1 ;
INSERT INTO x VALUES ( 1 , 1 ) ON CONFLICT ( COALESCE ( x , 1 ) ) DO NOTHING ;
INSERT INTO x VALUES ( 1 , 1 ) ON CONFLICT ( x ) WHERE COALESCE ( x , 1 ) > 1 DO NOTHING ;
CREATE VIEW x AS SELECT * FROM x WITH CASCADED CHECK OPTION ;
CREATE TABLE x ( x CHAR ( 1 ) ) INHERITS ( x ) ;
INSERT INTO x VALUES ( 'x' , 1 , 1 ) ;
ALTER TABLE x DROP COLUMN x , DROP COLUMN x ;
CREATE TABLE x ( x INT UNIQUE , x box , EXCLUDE USING gist ( x WITH && ) ) ;
CREATE TABLE x ( x INT PRIMARY KEY , x INT ) ;
BEGIN TRANSACTION ISOLATION LEVEL READ COMMITTED ;
INSERT INTO x VALUES ( 1 , 1 ) , ( 1 , 1 ) ON CONFLICT DO NOTHING ;
BEGIN TRANSACTION ISOLATION LEVEL SERIALIZABLE ;
INSERT INTO x VALUES ( 1 , 1 ) , ( 1 , 1 ) ON CONFLICT ( x ) DO UPDATE SET x = 1 ;
CREATE TABLE x ( x INT UNIQUE , x CHAR ) PARTITION BY list ( a ) ;
CREATE TABLE x PARTITION OF x ( x UNIQUE ) FOR VALUES IN ( 1 , 1 ) ;
INSERT INTO x VALUES ( 1 , 'x' ) ON CONFLICT DO NOTHING ;
INSERT INTO x VALUES ( 1 , 'x' ) ON CONFLICT ( x ) DO NOTHING ;
CREATE TABLE x ( x CHAR , x INT UNIQUE ) ;
TRUNCATE x ;
ALTER TABLE x DROP x , ADD x CHAR ;
INSERT INTO x ( x , x ) VALUES ( 1 , 'x' ) ON CONFLICT ( x ) DO UPDATE SET x = x . x ;
INSERT INTO x ( x , x ) VALUES ( 1 , 'x' ) ON CONFLICT ( x ) DO UPDATE SET x = x . x WHERE x . x = 'x' ;
CREATE TABLE x PARTITION OF x FOR VALUES IN ( 1 ) PARTITION BY list ( a ) ;
INSERT INTO x ( x , x ) VALUES ( 1 , 'x' ) , ( 1 , 'x' ) , ( 1 , 'x' ) ON CONFLICT ( x ) DO UPDATE SET x = x . x WHERE x . x = 'x' ;
CREATE UNIQUE INDEX ON ONLY x ( x ) ;
ALTER INDEX x ATTACH PARTITION x ;
CREATE TABLE x ( x TEXT , x INT , x INT , x TEXT ) ;
CREATE UNIQUE INDEX ON x ( x , x ) ;
INSERT INTO x VALUES ( 1 , 'x' , 1 ) ON CONFLICT ( x , x ) DO UPDATE SET ( x , x , x ) = ROW ( x . * ) WHERE x = ( 1 , TEXT 'x' , 1 ) AND x = ( 1 , TEXT 'x' , 1 ) ;
$$CREATE TRIGGER x AFTER UPDATE ON x REFERENCING NEW TABLE AS inserted FOR EACH STATEMENT EXECUTE PROCEDURE x ( ) ;
INSERT INTO x VALUES ( 1 , 'x' , 1 ) ON CONFLICT ( x , x ) DO UPDATE SET x = x . x + 1 ;
##@#@#@#########$$$$SELECT FALSE <= 1 BETWEEN 1 AND 1 ;
SELECT FALSE >= 1 BETWEEN 1 AND 1 ;
BEGIN TRANSACTION ;
GRANT USAGE ON SCHEMA schema_op1 TO x ;
REVOKE USAGE ON SCHEMA schema_op1 FROM x ;
SET ROLE regress_rol_op1 ;
######$$$$#@##@##@#CREATE OPERATOR % ( leftarg = int8 ) ;
CREATE TYPE type_op3 AS ENUM ( 'x' , 'x' , 'x' ) ;
$$$$REVOKE USAGE ON TYPE type_op3 FROM x ;
##CREATE TYPE type_op4 AS ENUM ( 'x' , 'x' , 'x' ) ;
$$$$REVOKE USAGE ON TYPE type_op4 FROM x ;
##CREATE TYPE type_op5 AS ENUM ( 'x' , 'x' , 'x' ) ;
$$$$##CREATE TYPE type_op6 AS ENUM ( 'x' , 'x' , 'x' ) ;
$$$$REVOKE USAGE ON TYPE type_op6 FROM x ;
##CREATE SCHEMA x CREATE UNIQUE INDEX x ON x ( x ) CREATE VIEW x AS SELECT x + 1 AS a , x + 1 AS b FROM x CREATE TABLE x ( x serial , x INT UNIQUE ) ;
SELECT x ( * ) FROM x WHERE x = ( SELECT x FROM x WHERE x = 'x' ) ;
INSERT INTO x . abc DEFAULT VALUES ;
SELECT * FROM x . abc ;
SELECT * FROM x . abc_view ;
ALTER SCHEMA x RENAME TO x ;
DROP SCHEMA test_ns_schema_renamed CASCADE ;
CREATE TABLE x ( x int4 ) ;
COMMENT ON TABLE attmp_wrong IS 'x' ;
COMMENT ON TABLE attmp IS 'x' ;
COMMENT ON TABLE attmp IS NULL ;
ALTER TABLE x ADD COLUMN x float8 ;
ALTER TABLE x ADD COLUMN x float4 ;
ALTER TABLE x ADD COLUMN x int2 ;
ALTER TABLE x ADD COLUMN x polygon ;
ALTER TABLE x ADD COLUMN x CHAR ;
ALTER TABLE x ADD COLUMN x int4 ;
ALTER TABLE x ADD COLUMN x tid ;
ALTER TABLE x ADD COLUMN x xid ;
ALTER TABLE x ADD COLUMN x oidvector ;
ALTER TABLE x ADD COLUMN x BOOLEAN ;
ALTER TABLE x ADD COLUMN x point ;
ALTER TABLE x ADD COLUMN x lseg ;
ALTER TABLE x ADD COLUMN x path ;
ALTER TABLE x ADD COLUMN x box ;
ALTER TABLE x ADD COLUMN x TIMESTAMP ;
ALTER TABLE x ADD COLUMN x INTERVAL ;
ALTER TABLE x ADD COLUMN x float8 [ ] ;
ALTER TABLE x ADD COLUMN x float4 [ ] ;
ALTER TABLE x ADD COLUMN x int2 [ ] ;
INSERT INTO x ( x , x , x , x , x , x , x , x , x , x , x , x , x , x , x , x , x , x , x , x , x , x ) VALUES ( 1 , 'x' , 'x' , 4.100000 , 4.100000 , 1 , 'x' , 'x' , 1 , 'x' , 'x' , 'x' , TRUE , 'x' , 'x' , 'x' , 'x' , 'x' , 'x' , 'x' , 'x' , 'x' ) ;
CREATE INDEX x ON x ( x , ( x + x ) , x ) ;
ALTER INDEX x ALTER COLUMN 1 SET STATISTICS 1 ;
ALTER TABLE x RENAME TO x ;
ALTER INDEX x RENAME TO x ;
SET ROLE regress_alter_table_user1 ;
______ALTER INDEX IF EXISTS x RENAME TO x ;
__CREATE VIEW x ( x ) AS SELECT x FROM x ;
SET enable_seqscan TO off ;
SET enable_bitmapscan TO off ;
SELECT x FROM x WHERE x < 1 ;
RESET enable_seqscan ;
RESET enable_bitmapscan ;
ALTER TABLE x ADD CONSTRAINT onek_unique1_constraint UNIQUE ( x ) ;
ALTER TABLE x DROP CONSTRAINT onek_unique1_constraint_foo ;
ALTER TABLE x ADD CONSTRAINT onek_check_constraint CHECK ( x >= 1 ) ;
ALTER TABLE x RENAME CONSTRAINT onek_check_constraint TO onek_check_constraint_foo ;
ALTER TABLE x DROP CONSTRAINT onek_check_constraint_foo ;
CREATE TABLE x ( x INT CONSTRAINT con1 CHECK ( x > 1 ) , x INT , x INT ) ;
CREATE TABLE x ( x INT CONSTRAINT con1 CHECK ( x > 1 ) , x INT ) INHERITS ( x ) ;
CREATE TABLE x ( x INT , CONSTRAINT chk_a CHECK ( x > 1 ) , PRIMARY KEY ( x ) ) ;
ALTER TABLE x RENAME CONSTRAINT chk_a TO chk_a_new ;
ALTER TABLE x RENAME CONSTRAINT constraint_rename_cache_pkey TO constraint_rename_pkey_new ;
CREATE TABLE x ( LIKE x INCLUDING ALL ) ;
CREATE TABLE x ( x INT PRIMARY KEY ) ;
CREATE TABLE x ( x INT , x INT , UNIQUE ( x , x ) ) ;
ALTER TABLE x ADD CONSTRAINT attmpconstr FOREIGN KEY ( x ) REFERENCES x MATCH FULL ;
ALTER TABLE x ADD CONSTRAINT attmpconstr FOREIGN KEY ( x ) REFERENCES x ( x ) MATCH FULL ;
DELETE FROM x WHERE x = 1 ;
ALTER TABLE x DROP CONSTRAINT attmpconstr ;
ALTER TABLE x ADD CONSTRAINT attmpconstr FOREIGN KEY ( x ) REFERENCES x MATCH FULL NOT VALID ;
ALTER TABLE x VALIDATE CONSTRAINT attmpconstr ;
CREATE TABLE x ( ) INHERITS ( x ) ;
INSERT INTO x VALUES ( 1 , 1 ) , ( 1 , 1 ) ;
ALTER TABLE x ADD CONSTRAINT b_le_20 CHECK ( x <= 1 ) NOT VALID ;
ALTER TABLE x ADD CONSTRAINT check_a_is_2 CHECK ( x = 1 ) NO INHERIT NOT VALID ;
ALTER TABLE x VALIDATE CONSTRAINT check_a_is_2 ;
DELETE FROM ONLY x ;
SET constraint_exclusion TO 'x' ;
CREATE TABLE x ( x date , CHECK ( FALSE ) NO INHERIT NOT VALID ) ;
EXPLAIN ( costs off ) SELECT * FROM x WHERE x BETWEEN 'x' AND 'x' ;
ALTER TABLE x VALIDATE CONSTRAINT nv_child_2011_d_check ;
CREATE TEMP TABLE x ( x inet ) ;
ALTER TABLE x ADD FOREIGN KEY ( x ) REFERENCES x ;
ALTER TABLE x ADD FOREIGN KEY ( x ) REFERENCES x ( x ) ;
CREATE TEMP TABLE x ( x int8 ) ;
CREATE TEMP TABLE x ( x NUMERIC ) ;
CREATE TEMP TABLE x ( x NUMERIC PRIMARY KEY ) ;
CREATE TEMP TABLE x ( x INT , x inet , PRIMARY KEY ( x , x ) ) ;
CREATE TEMP TABLE x ( x cidr , x TIMESTAMP ) ;
ALTER TABLE x ADD FOREIGN KEY ( x , x ) REFERENCES x ;
ALTER TABLE x ADD FOREIGN KEY ( x , x ) REFERENCES x ( x , x ) ;
CREATE TEMP TABLE x ( x INT , x inet ) ;
ALTER TABLE x ADD CONSTRAINT fknd FOREIGN KEY ( x ) REFERENCES x ON DELETE CASCADE ON UPDATE NO ACTION NOT DEFERRABLE ;
ALTER TABLE x ADD CONSTRAINT fkdd FOREIGN KEY ( x ) REFERENCES x ON DELETE CASCADE ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED ;
ALTER TABLE x ADD CONSTRAINT fkdi FOREIGN KEY ( x ) REFERENCES x ON DELETE CASCADE ON UPDATE NO ACTION DEFERRABLE INITIALLY IMMEDIATE ;
ALTER TABLE x ADD CONSTRAINT fknd2 FOREIGN KEY ( x ) REFERENCES x ON DELETE CASCADE ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED ;
ALTER TABLE x ALTER CONSTRAINT fknd2 NOT DEFERRABLE ;
ALTER TABLE x ADD CONSTRAINT fkdd2 FOREIGN KEY ( x ) REFERENCES x ON DELETE CASCADE ON UPDATE NO ACTION NOT DEFERRABLE ;
ALTER TABLE x ALTER CONSTRAINT fkdd2 DEFERRABLE INITIALLY DEFERRED ;
ALTER TABLE x ADD CONSTRAINT fkdi2 FOREIGN KEY ( x ) REFERENCES x ON DELETE CASCADE ON UPDATE NO ACTION NOT DEFERRABLE ;
ALTER TABLE x ALTER CONSTRAINT fkdi2 DEFERRABLE INITIALLY IMMEDIATE ;
ALTER TABLE x ADD CONSTRAINT atacc_test1 CHECK ( x > 1 ) ;
CREATE TABLE x ( x INT , x INT , x INT ) ;
ALTER TABLE x ADD CONSTRAINT atacc_test1 CHECK ( x + x < x * 1 ) ;
INSERT INTO x ( x , x , x ) VALUES ( 1 , 1 , 1 ) ;
CREATE TABLE x ( x INT CHECK ( x > 1 ) , x INT ) ;
ALTER TABLE x ADD CHECK ( x > x ) ;
CREATE TABLE x ( x INT ) INHERITS ( x , x ) ;
ALTER TABLE x ADD CONSTRAINT foo CHECK ( x > 1 ) ;
ALTER TABLE x NO INHERIT x ;
ALTER TABLE x INHERIT x ;
ALTER TABLE x RENAME x TO x ;
ALTER TABLE x ADD x bool ;
ALTER TABLE x DROP x ;
ALTER TABLE x ADD x INT ;
UPDATE x SET x = 1 WHERE x IS NULL ;
CREATE TABLE x ( x INT ) INHERITS ( x ) ;
ALTER TABLE x ADD CONSTRAINT foo CHECK ( x > 1 ) NO INHERIT ;
ALTER TABLE x ADD CONSTRAINT atacc_test1 UNIQUE ( x ) ;
ALTER TABLE x ALTER COLUMN x TYPE INTEGER USING 1 ;
ALTER TABLE x ADD CONSTRAINT atacc_test1 UNIQUE ( x , x ) ;
CREATE TABLE x ( x INT , x INT , UNIQUE ( x ) ) ;
ALTER TABLE x ADD UNIQUE ( x ) ;
CREATE TABLE x ( x serial , x INT ) ;
ALTER TABLE x ADD CONSTRAINT atacc_test1 PRIMARY KEY ( x ) ;
ALTER TABLE x ADD CONSTRAINT atacc_oid1 PRIMARY KEY ( x ) ;
ALTER TABLE x DROP CONSTRAINT atacc_test1 RESTRICT ;
ALTER TABLE x ADD COLUMN x INT PRIMARY KEY ;
ALTER TABLE x ADD COLUMN x INT DEFAULT 1 PRIMARY KEY ;
ALTER TABLE x ADD COLUMN x float8 NOT NULL DEFAULT x ( ) , ADD PRIMARY KEY ( x ) ;
ALTER TABLE x ADD CONSTRAINT atacc_test1 PRIMARY KEY ( x , x ) ;
ALTER TABLE x ADD CONSTRAINT atacc_test2 PRIMARY KEY ( x ) ;
INSERT INTO x ( x , x ) VALUES ( NULL , 1 ) ;
INSERT INTO x ( x , x ) VALUES ( 1 , NULL ) ;
INSERT INTO x ( x , x ) VALUES ( NULL , NULL ) ;
CREATE TABLE x ( x INT , x INT , PRIMARY KEY ( x ) ) ;
ALTER TABLE x ALTER COLUMN x DROP NOT NULL ;
ALTER TABLE x ALTER x SET NOT NULL ;
ALTER TABLE x ALTER COLUMN x SET NOT NULL ;
CREATE TABLE x ( x INT NOT NULL ) ;
ALTER TABLE x ADD CONSTRAINT atacc1_pkey" PRIMARY KEY ( x ) ;
ALTER TABLE x DROP CONSTRAINT atacc1_pkey" ;
ALTER TABLE x ALTER x DROP NOT NULL ;
INSERT INTO x VALUES ( NULL , 1 ) ;
ALTER TABLE x ADD CONSTRAINT atacc1_constr_or CHECK ( x IS NOT NULL OR x < 1 ) ;
ALTER TABLE x DROP CONSTRAINT atacc1_constr_or ;
ALTER TABLE x ADD CONSTRAINT atacc1_constr_invalid CHECK ( x IS NOT NULL ) NOT VALID ;
ALTER TABLE x DROP CONSTRAINT atacc1_constr_invalid ;
ALTER TABLE x ADD CONSTRAINT atacc1_constr_a_valid CHECK ( x IS NOT NULL ) ;
INSERT INTO x VALUES ( 1 , NULL ) ;
ALTER TABLE x ALTER x SET NOT NULL , ALTER x SET NOT NULL ;
ALTER TABLE x ALTER x DROP NOT NULL , ALTER x DROP NOT NULL ;
ALTER TABLE x ADD CONSTRAINT atacc1_constr_b_valid CHECK ( x IS NOT NULL ) ;
CREATE TABLE x ( x VARCHAR ( 1 ) ) INHERITS ( x ) ;
INSERT INTO x ( x , x ) VALUES ( NULL , 'x' ) ;
ALTER TABLE ONLY x ALTER x SET NOT NULL ;
CREATE TABLE x ( x int4 DEFAULT 1 , x TEXT DEFAULT 'x' ) ;
ALTER TABLE x ALTER COLUMN x DROP DEFAULT ;
ALTER TABLE x ALTER COLUMN x SET DEFAULT 1 ;
ALTER TABLE x ALTER COLUMN x SET DEFAULT 'x' ;
DROP RULE def_view_test_ins ON def_view_test ;
CREATE TABLE x ( x int4 NOT NULL , x int4 , x int4 NOT NULL , x int4 ) ;
INSERT INTO x VALUES ( 1 , 1 , 1 , 1 ) ;
SELECT * FROM x GROUP BY x ;
SELECT x . * FROM x ;
SELECT x . x FROM x ;
SELECT x , x , x FROM x ;
SELECT x , x , x , x FROM x ;
INSERT INTO x VALUES ( DEFAULT , 1 , 1 , 1 ) ;
INSERT INTO x ( x ) VALUES ( DEFAULT ) ;
INSERT INTO x ( x , x , x , x ) VALUES ( 1 , 1 , 1 , 1 ) ;
INSERT INTO x ( x , x , x , x ) VALUES ( DEFAULT , 1 , 1 , 1 ) ;
ALTER TABLE x SET WITHOUT OIDS ;
ANALYZE x ( a ) ;
ANALYZE x ( ........pg.dropped.1........" ) ;
VACUUM ANALYZE x ( a ) ;
VACUUM ANALYZE x ( ........pg.dropped.1........" ) ;
COMMENT ON COLUMN atacc1 . a IS 'x' ;
COMMENT ON COLUMN atacc1 . ........pg.dropped.1........" IS 'x' ;
ALTER TABLE x ALTER x SET STATISTICS 1 ;
ALTER TABLE x ALTER x SET DEFAULT 1 ;
ALTER TABLE x ALTER x DROP DEFAULT ;
ALTER TABLE x ADD PRIMARY KEY ( x ) ;
ALTER TABLE x ADD CHECK ( x > 1 ) ;
CREATE TABLE x ( x int4 UNIQUE ) ;
CREATE TABLE x AS SELECT * FROM x ;
SELECT * INTO x FROM x ;
CREATE TABLE x ( x float8 , x NUMERIC ( 1 , 1 ) , x TEXT COLLATE C" ) ;
CREATE TABLE x ( x int4 , x int4 , x int4 ) ;
COPY x TO STDOUT ;
COPY x ( x ) TO STDOUT ;
COPY x ( x , x ) FROM STDIN ;
ALTER TABLE ONLY x DROP COLUMN x ;
ALTER TABLE x RENAME COLUMN x TO x ;
ALTER TABLE ONLY x RENAME COLUMN x TO x ;
ALTER TABLE IF EXISTS x RENAME COLUMN x TO x ;
ALTER TABLE x ADD COLUMN x INT ;
ALTER TABLE ONLY x ADD COLUMN x INT ;
CREATE TABLE x ( x INT NOT NULL ) INHERITS ( x ) ;
CREATE TABLE x ( ) ;
DROP TABLE x , x CASCADE ;
ALTER TABLE x ADD x TEXT ;
CREATE TABLE x ( x TEXT , x INT ) INHERITS ( x ) ;
ALTER TABLE x ADD COLUMN x INT CHECK ( x > 1 ) ;
UPDATE x SET x = x + 1 , x = x ( x ) ;
CREATE DOMAIN mytype AS TEXT ;
CREATE TEMP TABLE x ( x TEXT , x mytype , x TEXT ) ;
INSERT INTO x VALUES ( 'x' , 'x' , 'x' ) ;
DROP DOMAIN mytype CASCADE ;
SELECT x , x ( x ) FROM x GROUP BY x ;
CREATE TABLE x ( x serial8 , x BOOLEAN , CONSTRAINT anothertab_chk CHECK ( x <= 1 ) ) ;
INSERT INTO x ( x , x ) VALUES ( DEFAULT , TRUE ) ;
INSERT INTO x ( x , x ) VALUES ( DEFAULT , FALSE ) ;
ALTER TABLE x ALTER COLUMN x TYPE TEXT USING CASE WHEN x IS TRUE THEN 'x' WHEN x IS FALSE THEN 'x' ELSE 'x' END ;
CREATE TABLE x ( x INT PRIMARY KEY , x INT UNIQUE , x INT , x INT , x INT ) ;
ALTER TABLE x ADD EXCLUDE USING btree ( x WITH = ) ;
ALTER TABLE x ADD EXCLUDE USING btree ( x WITH = ) WHERE ( x IS NOT NULL ) ;
ALTER TABLE x ADD EXCLUDE USING btree ( x WITH = ) WHERE ( x > 1 ) ;
ALTER TABLE x ADD UNIQUE ( x , x ) ;
ALTER TABLE x ALTER COLUMN x TYPE BIGINT ;
ALTER TABLE x ALTER COLUMN x TYPE BIGINT , ALTER COLUMN x TYPE BIGINT , ALTER COLUMN x TYPE BIGINT ;
ALTER TABLE x ALTER x TYPE TEXT USING x || 'x' , ALTER x TYPE BIGINT USING x * 1 ;
CREATE TABLE x ( x INT , x tab1 ) ;
CREATE TABLE x ( x TEXT , x INT ) ;
CREATE INDEX ON x ( x ) ;
COMMENT ON CONSTRAINT at_partitioned_id_name_key ON at_partitioned IS 'x' ;
COMMENT ON INDEX at_partitioned_id_name_key IS 'x' ;
COMMENT ON CONSTRAINT at_partitioned_0_id_name_key ON at_partitioned_0 IS 'x' ;
COMMENT ON INDEX at_partitioned_0_id_name_key IS 'x' ;
COMMENT ON CONSTRAINT at_partitioned_1_id_name_key ON at_partitioned_1 IS 'x' ;
COMMENT ON INDEX at_partitioned_1_id_name_key IS 'x' ;
CREATE TEMP TABLE x AS SELECT x , x AS oldoid , x AS oldfilenode FROM x WHERE x LIKE 'x' ;
CREATE TABLE x ( x FLOAT CHECK ( x > 10.200000 ) , x FLOAT ) ;
SELECT x , x , x , x , x FROM x c , x r WHERE x LIKE 'x' AND x . x = x . x ORDER BY 1 , 1 ;
ALTER TABLE x ALTER COLUMN x TYPE NUMERIC ;
ALTER TABLE x ADD CONSTRAINT bnoinherit CHECK ( x > 1 ) NO INHERIT ;
ALTER TABLE x ADD CONSTRAINT blocal CHECK ( x < 1 ) ;
ALTER TABLE x ADD CONSTRAINT bmerged CHECK ( x > 1 ) ;
CREATE TABLE x ( x SMALLINT ) INHERITS ( x ) ;
CREATE TABLE x ( x int2 , x int4 , x int8 ) ;
CREATE TABLE x ( x int4 , x int8 , x int2 ) ;
CREATE TABLE x ( x int8 , x int2 , x int4 ) ;
ALTER TABLE x ALTER COLUMN x TYPE int4 USING ( x ( x ) ) ;
CREATE TABLE x ( x INT REFERENCES x , x TEXT ) ;
ALTER TABLE x DROP CONSTRAINT check_fk_presence_2_id_fkey ;
CREATE VIEW x AS SELECT * FROM x bt ;
CREATE VIEW x AS SELECT * , x ( x ) AS j FROM x v1 ;
CREATE OR REPLACE VIEW x AS SELECT * , 1 + 1 AS more FROM x bt ;
EXECUTE p_ddl ;
$$$$$$$$$$$$$$$$$$$$$$$$$$DROP FUNCTION x ( regclass , TEXT ) ;
DROP TYPE lockmodes ;
CREATE TYPE lockmodes AS ENUM ( 'x' , 'x' , 'x' , 'x' , 'x' , 'x' , 'x' , 'x' , 'x' ) ;
BEGIN ; ALTER TABLE x ALTER COLUMN x SET STATISTICS 1 ;
SELECT * FROM x ORDER BY 1 ;
BEGIN ; ALTER TABLE x CLUSTER ON alterlock_pkey ;
BEGIN ; ALTER TABLE x SET WITHOUT CLUSTER ;
BEGIN ; ALTER TABLE x SET ( fillfactor = 1 ) ;
BEGIN ; ALTER TABLE x RESET ( fillfactor ) ;
BEGIN ; ALTER TABLE x SET ( toast . autovacuum_enabled = off ) ;
BEGIN ; ALTER TABLE x SET ( autovacuum_enabled = off ) ;
BEGIN ; ALTER TABLE x ALTER COLUMN x SET ( n_distinct = 1 ) ;
BEGIN ; ALTER TABLE x SET ( autovacuum_enabled = off , fillfactor = 1 ) ;
BEGIN ; ALTER TABLE x ALTER COLUMN x SET DEFAULT 'x' ;
CREATE TRIGGER x BEFORE DELETE OR UPDATE ON x FOR EACH ROW EXECUTE PROCEDURE x ( 1 , 1 ) ;
ALTER TABLE x VALIDATE CONSTRAINT alterlock2nv ;
ALTER TABLE x RESET ( autovacuum_enabled ) ;
ALTER VIEW x RESET ( autovacuum_enabled ) ;
ALTER VIEW x SET ( security_barrier = off ) ;
ALTER VIEW x RESET ( security_barrier ) ;
ALTER TABLE x SET ( security_barrier = off ) ;
ALTER TABLE x RESET ( security_barrier ) ;
SELECT x ( NULL ) ;
ALTER FUNCTION x ( TEXT ) CALLED ON NULL INPUT ;
ALTER FUNCTION x ( TEXT ) RETURNS NULL ON NULL INPUT ;
CREATE TABLE x . t1 ( x serial PRIMARY KEY , x INT CHECK ( x > 1 ) ) ;
CREATE VIEW x . v1 AS SELECT * FROM x . t1 ;
CREATE TYPE alter1 . ctype AS ( f1 INT , f2 TEXT ) ;
CREATE OPERATOR CLASS alter1 . ctype_hash_ops DEFAULT FOR TYPE alter1 . ctype USING hash AS OPERATOR 1 alter1 . = ( alter1 . ctype , alter1 . ctype ) ;
CREATE CONVERSION alter1 . latin1_to_utf8 FOR 'x' TO 'x' FROM iso8859_1_to_utf8 ;
CREATE TEXT SEARCH TEMPLATE alter1 . tmpl ( init = dsimple_init , lexize = dsimple_lexize ) ;
INSERT INTO x . t1 ( x ) VALUES ( 1 ) ;
ALTER TABLE x . v1 SET SCHEMA alter2 ;
ALTER FUNCTION alter1 . plus1 ( INT ) SET SCHEMA alter2 ;
ALTER DOMAIN alter1 . posint SET SCHEMA alter2 ;
ALTER OPERATOR CLASS alter1 . ctype_hash_ops USING hash SET SCHEMA alter2 ;
ALTER OPERATOR FAMILY alter1 . ctype_hash_ops USING hash SET SCHEMA alter2 ;
ALTER OPERATOR alter1 . = ( alter1 . ctype , alter1 . ctype ) SET SCHEMA alter2 ;
ALTER FUNCTION alter1 . same ( alter1 . ctype , alter1 . ctype ) SET SCHEMA alter2 ;
ALTER CONVERSION alter1 . latin1_to_utf8 SET SCHEMA alter2 ;
ALTER TEXT SEARCH PARSER alter1 . prs SET SCHEMA alter2 ;
ALTER TEXT SEARCH CONFIGURATION alter1 . cfg SET SCHEMA alter2 ;
ALTER TEXT SEARCH TEMPLATE alter1 . tmpl SET SCHEMA alter2 ;
ALTER TEXT SEARCH DICTIONARY alter1 . dict SET SCHEMA alter2 ;
DROP SCHEMA alter1 ;
SELECT * FROM x . t1 ;
SELECT * FROM x . v1 ;
SELECT alter2 . plus1 ( 1 ) ;
DROP SCHEMA alter2 CASCADE ;
CREATE TYPE test_type AS ( a INT ) ;
ALTER TYPE test_type ALTER ATTRIBUTE b SET DATA TYPE INTEGER ;
ALTER TYPE test_type DROP ATTRIBUTE b ;
ALTER TYPE test_type DROP ATTRIBUTE a , ADD ATTRIBUTE d BOOLEAN ;
ALTER TYPE test_type RENAME ATTRIBUTE a TO aa ;
ALTER TYPE test_type RENAME ATTRIBUTE d TO dd ;
DROP TYPE test_type ;
CREATE TYPE test_type1 AS ( a INT , b TEXT ) ;
CREATE TABLE x ( x INT , x test_type1 ) ;
CREATE TABLE x OF test_type2 ;
CREATE TYPE test_typex AS ( a INT , b TEXT ) ;
CREATE TABLE x ( x INT , x test_typex CHECK ( ( x ) . a > 1 ) ) ;
DROP TYPE test_typex ;
CREATE TYPE test_type3 AS ( a INT ) ;
ALTER TYPE test_type3 DROP ATTRIBUTE a , ADD ATTRIBUTE b INT ;
CREATE TYPE test_type_empty AS ( ) ;
DROP TYPE test_type_empty ;
CREATE TYPE tt_t0 AS ( z inet , x INT , y NUMERIC ( 1 , 1 ) ) ;
ALTER TYPE tt_t0 DROP ATTRIBUTE z ;
ALTER TABLE x OF tt_t0 ;
CREATE TYPE tt_t1 AS ( x INT , y NUMERIC ( 1 , 1 ) ) ;
CREATE TABLE x ( x TEXT CHECK ( x IS NOT NULL ) ) ;
ALTER TABLE ONLY x DROP CONSTRAINT test_drop_constr_parent_c_check" ;
ALTER TABLE IF EXISTS x ADD COLUMN x INT ;
ALTER TABLE IF EXISTS x ADD CONSTRAINT xxx PRIMARY KEY ( x ) ;
ALTER TABLE IF EXISTS x ADD CHECK ( x BETWEEN 1 AND 1 ) ;
ALTER TABLE IF EXISTS x ALTER COLUMN x SET DEFAULT 1 ;
ALTER TABLE IF EXISTS x SET SCHEMA alter2 ;
DROP TABLE x . tt8 ;
DROP SCHEMA alter2 ;
CREATE TABLE x ( x INT , x INT CHECK ( x > 1 ) , x INT , CONSTRAINT comment_test_pk PRIMARY KEY ( x ) ) ;
COMMENT ON COLUMN comment_test . id IS 'x' ;
COMMENT ON INDEX comment_test_index IS 'x' ;
COMMENT ON CONSTRAINT comment_test_positive_col_check ON comment_test IS 'x' ;
COMMENT ON CONSTRAINT comment_test_pk ON comment_test IS 'x' ;
COMMENT ON INDEX comment_test_pk IS 'x' ;
ALTER TABLE x ALTER COLUMN x SET DATA TYPE INT ;
ALTER TABLE x ALTER COLUMN x SET DATA TYPE TEXT ;
ALTER TABLE x ALTER COLUMN x SET DATA TYPE BIGINT ;
CREATE TABLE x ( x TEXT CONSTRAINT comment_test_child_fk REFERENCES x ) ;
COMMENT ON COLUMN comment_test_child . id IS 'x' ;
COMMENT ON INDEX comment_test_child_fk IS 'x' ;
COMMENT ON CONSTRAINT comment_test_child_fk ON comment_test_child IS 'x' ;
SHOW allow_system_table_mods ;
CREATE TABLE x . new_system_table ( ) ;
CREATE TABLE x ( x serial PRIMARY KEY , x TEXT ) ;
ALTER TABLE x SET SCHEMA pg_catalog ;
ALTER TABLE x SET SCHEMA public ;
INSERT INTO x ( x ) VALUES ( 'x' ) , ( 'x' ) ;
UPDATE x SET x = - x ;
DELETE FROM x WHERE x = 'x' ;
ALTER TABLE x DROP CONSTRAINT new_system_table_pkey ;
CREATE UNLOGGED TABLE x ( x SERIAL PRIMARY KEY , x TEXT ) ;
~~CREATE TABLE x ( x SERIAL PRIMARY KEY , x TEXT ) ;
~ALTER TABLE x SET UNLOGGED ;
~ALTER TABLE x ADD COLUMN x INTEGER ;
ALTER TABLE x ADD EXCLUDE USING gist ( x WITH && ) ;
ALTER TABLE x ALTER COLUMN x TYPE CHAR ( 1 ) ;
ALTER TABLE x ADD CONSTRAINT chk_a CHECK ( x > 1 ) NO INHERIT ;
CREATE TABLE x ( LIKE x ) ;
ALTER TABLE x ATTACH PARTITION x FOR VALUES IN ( 'x' ) ;
CREATE TABLE x ( x INT NOT NULL , x CHAR ( 1 ) COLLATE C" , CONSTRAINT check_a CHECK ( x > 1 ) ) PARTITION BY LIST ( a ) ;
ALTER TABLE x OWNER TO x ;
SET SESSION AUTHORIZATION regress_test_me ;
CREATE TEMP TABLE x ( x INT ) PARTITION BY LIST ( a ) ;
CREATE TYPE mytype AS ( a INT ) ;
CREATE TABLE x OF mytype ;
DROP TYPE mytype CASCADE ;
CREATE TABLE x ( LIKE x , x INT ) ;
CREATE TABLE x ( x CHAR ( 1 ) , x INT NOT NULL ) ;
ALTER TABLE x ALTER x TYPE CHAR ( 1 ) COLLATE POSIX" ;
CREATE TABLE x ( x CHAR ( 1 ) COLLATE C" , x INT NOT NULL ) ;
ALTER TABLE x ADD CONSTRAINT check_a CHECK ( x >= 1 ) ;
CREATE TABLE x ( x INT NOT NULL , x CHAR ( 1 ) COLLATE C" , CONSTRAINT check_a CHECK ( x > 1 ) ) ;
CREATE TABLE x ( LIKE x INCLUDING CONSTRAINTS ) ;
ALTER TABLE x ATTACH PARTITION x DEFAULT ;
CREATE TABLE x ( x INT , x CHAR ) PARTITION BY LIST ( a ) ;
CREATE TABLE x ( LIKE x , CONSTRAINT check_a CHECK ( x IN ( 1 ) ) ) ;
ALTER TABLE x DETACH PARTITION x ;
ALTER TABLE x ADD CONSTRAINT check_a CHECK ( x IN ( 1 , 1 ) ) ;
CREATE TABLE x PARTITION OF x FOR VALUES IN ( 1 , 1 ) ;
CREATE TABLE x ( x INT NOT NULL CHECK ( x = 1 ) , x INT NOT NULL CHECK ( x >= 1 AND x <= 1 ) ) ;
ALTER TABLE x ATTACH PARTITION x FOR VALUES FROM ( 1 , 1 ) TO ( 1 , 1 ) ;
CREATE TABLE x ( x INT NOT NULL CHECK ( x = 1 ) , x INT NOT NULL CHECK ( x >= 1 AND x < 1 ) ) ;
CREATE TABLE x ( LIKE x ) PARTITION BY LIST ( b ) ;
CREATE TABLE x PARTITION OF x FOR VALUES IN ( 'x' ) ;
INSERT INTO x ( x , x ) VALUES ( 1 , 'x' ) ;
DELETE FROM x WHERE x NOT IN ( 1 ) ;
ALTER TABLE x ADD CONSTRAINT check_a CHECK ( x IS NOT NULL AND x = 1 ) ;
ALTER TABLE x DROP CONSTRAINT check_a ;
ALTER TABLE x ADD CONSTRAINT check_a CHECK ( x IN ( 1 ) ) , ALTER x SET NOT NULL ;
CREATE TABLE x ( x INT , LIKE x , CONSTRAINT check_a CHECK ( x IS NOT NULL AND x = 1 ) ) ;
CREATE TABLE x ( LIKE x , CONSTRAINT check_a CHECK ( x IS NOT NULL AND x = 1 ) ) PARTITION BY LIST ( b ) ;
ALTER TABLE x DROP x , DROP x , DROP x ;
ALTER TABLE x ATTACH PARTITION x FOR VALUES IN ( 'x' , NULL ) ;
CREATE TABLE x PARTITION OF x DEFAULT PARTITION BY LIST ( a ) ;
CREATE TABLE x ( x INT , x TEXT ) PARTITION BY LIST ( a ) ;
CREATE TABLE x PARTITION OF x DEFAULT PARTITION BY LIST ( b ) ;
CREATE TABLE x PARTITION OF x ( CONSTRAINT check_1 CHECK ( x IS NOT NULL AND x = 1 ) ) FOR VALUES IN ( 'x' ) ;
CREATE TABLE x ( x INT , x INT ) PARTITION BY HASH ( a part_test_int4_ops ) ;
CREATE TABLE x PARTITION OF x FOR VALUES WITH ( MODULUS 1 , REMAINDER 1 ) ;
ALTER TABLE x ATTACH PARTITION x FOR VALUES WITH ( MODULUS 1 , REMAINDER 1 ) ;
CREATE TABLE x PARTITION OF x FOR VALUES IN ( 'x' , 'x' , 'x' ) ;
ALTER TABLE x ALTER COLUMN x TYPE TEXT ;
ALTER TABLE ONLY x ALTER x DROP NOT NULL ;
ALTER TABLE ONLY x DROP CONSTRAINT check_b ;
ALTER TABLE ONLY x ADD CONSTRAINT check_a CHECK ( x > 1 ) ;
ALTER TABLE ONLY x DROP CONSTRAINT check_a ;
ALTER TABLE x ALTER x SET NOT NULL , ADD CONSTRAINT check_a2 CHECK ( x > 1 ) ;
ALTER TABLE x DROP CONSTRAINT check_a2 ;
ALTER TABLE x ADD x INT NOT NULL ;
ALTER TABLE x ADD CONSTRAINT parted_validate_test_chka CHECK ( x > 1 ) NOT VALID ;
ALTER TABLE x VALIDATE CONSTRAINT parted_validate_test_chka ;
ALTER TABLE x ALTER COLUMN x SET ( n_distinct = 1 , n_distinct_inherited = 1 ) ;
ALTER TABLE x ALTER COLUMN x RESET ( n_distinct_inherited ) ;
CREATE TEMP TABLE x ( x INT ) PARTITION BY list ( a ) ;
$$CREATE TRIGGER x BEFORE INSERT ON x FOR EACH STATEMENT EXECUTE PROCEDURE x ( ) ;
$$CREATE OPERATOR CLASS at_test_sql_partop FOR TYPE int4 USING btree AS OPERATOR 1 < ( int4 , int4 ) , OPERATOR 1 <= ( int4 , int4 ) , OPERATOR 1 = ( int4 , int4 ) , OPERATOR 1 >= ( int4 , int4 ) , OPERATOR 1 > ( int4 , int4 ) , FUNCTION 1 x ( int4 , int4 ) ;
DROP OPERATOR CLASS at_test_sql_partop USING btree ;
DROP FUNCTION at_test_sql_partop ;
RESET max_stack_depth ;
SELECT x ( x ( x ) , FALSE ) FROM ( SELECT x AS b , x * 1 AS c FROM x ( 1 , 1 ) x ) q ;
SELECT x ( x ( x ) , TRUE ) FROM ( SELECT x AS b , x * 1 AS c FROM x ( 1 , 1 ) x ) q ;
$$$$SELECT x ( x ( x ) , FALSE ) FROM ( SELECT x || x AS b , x AS c , ARRAY [ ROW ( x . * , ARRAY [ 1 , 1 , 1 ] ) , ROW ( x . * , ARRAY [ 1 , 1 , 1 ] ) ] AS z FROM x ( 1 , 1 ) x , x ( 1 , 1 ) y ) q ;
SELECT x ( x ( x ) , FALSE ) FROM x ( 1 , 1 ) x ;
$$$$SELECT x ( x ) FROM ( SELECT x || x AS b , x AS c , ARRAY [ ROW ( x . * , ARRAY [ 1 , 1 , 1 ] ) , ROW ( x . * , ARRAY [ 1 , 1 , 1 ] ) ] AS z FROM x ( 1 , 1 ) x , x ( 1 , 1 ) y ) q ;
$$$$SELECT x ( x , TRUE ) FROM ( SELECT x || x AS b , x AS c , ARRAY [ ROW ( x . * , ARRAY [ 1 , 1 , 1 ] ) , ROW ( x . * , ARRAY [ 1 , 1 , 1 ] ) ] AS z FROM x ( 1 , 1 ) x , x ( 1 , 1 ) y ) q ;
SELECT x ( ROW ( ( SELECT x ( x ) AS d FROM x ( 1 , 1 ) x ) ) , FALSE ) ;
SELECT x ( TIMESTAMP 'x' ) ;
SET LOCAL TIME ZONE 10.500000 ;
SET LOCAL TIME ZONE 1 ;
$$$$CREATE TEMP TABLE x ( x TEXT , x json ) ;
INSERT INTO x VALUES ( 'x' , 'x' ) , ( 'x' , 'x' ) , ( 'x' , 'x' ) ;
SELECT * FROM x ( 'x' ) q ;
SELECT x ( 'x' , 'x' , 'x' ) IS NULL AS expect_false ;
SELECT x ( 'x' , 'x' , 'x' ) IS NULL AS expect_true ;
CREATE TYPE jpop AS ( a TEXT , b INT , c TIMESTAMP ) ;
CREATE DOMAIN js_int_not_null AS INT NOT NULL ;
CREATE TYPE j_unordered_pair AS ( x INT , y INT ) ;
_CREATE TYPE jsrec AS ( i INT , ia int4 , ia1 INT [ ] , ia2 INT [ ] [ ] , ia3 INT [ ] [ ] [ ] , ia1d js_int_array_1d , ia2d js_int_array_2d , t TEXT , ta TEXT [ ] , c CHAR ( 1 ) , ca CHAR ( 1 ) [ ] , ts TIMESTAMP , js json , jsb jsonb , jsa json [ ] , rec jpop , reca jpop [ ] ) ;
CREATE TYPE jsrec_i_not_null AS ( i js_int_not_null ) ;
SELECT x ( ROW ( 1 , 1 ) , 'x' ) ;
CREATE TYPE jpop2 AS ( a INT , b json , c INT , d INT ) ;
SELECT x , x ( ROW ( x , 1 ) , 'x' ) FROM ( VALUES ( 1 ) , ( 1 ) ) v ( i ) ;
CREATE TEMP TABLE x ( x json ) ;
DROP TYPE jsrec ;
DROP TYPE jsrec_i_not_null ;
DROP DOMAIN js_int_not_null ;
DROP DOMAIN js_int_array_1d ;
DROP DOMAIN js_int_array_2d ;
DROP DOMAIN j_ordered_pair ;
DROP TYPE j_unordered_pair ;
SELECT x ( 'x' , 1 , 'x' , 1.200000 , 'x' , TRUE , 'x' , NULL , 'x' , x 'x' ) ;
SELECT x ( 1 , 1 ) ;
SELECT x ( NULL , 1 ) ;
SELECT x ( x , 1 ) FROM ( SELECT 1 AS a , 1 AS b ) r ;
SELECT x ( x 'x' , 1 ) ;
INSERT INTO x VALUES ( 1 , 'x' , 'x' ) ;
INSERT INTO x VALUES ( 1 , NULL , 'x' ) ;
SELECT * FROM x ( 'x' ) AS x ( a INT , b TEXT , d TEXT ) ;
SELECT * FROM x ( 'x' ) AS x ( a INT , b TEXT , c BOOLEAN ) ;
SELECT * FROM x ( 'x' ) AS x ( a INT , b json , c BOOLEAN ) ;
_SELECT * FROM x ( 'x' ) AS x ( ia int4 ) ;
_____SELECT * FROM x ( 'x' ) AS x ( ia2 INT [ ] [ ] ) ;
SELECT * FROM x ( 'x' ) AS x ( ia2 int4 [ ] [ ] ) ;
CREATE TABLE x ( x INT , x macaddr8 ) ;
CREATE INDEX x ON x USING btree ( x ) ;
CREATE INDEX x ON x USING hash ( x ) ;
SELECT x , x , x ( x ) FROM x ORDER BY 1 , 1 ;
SELECT x & 'x' FROM x ;
SELECT x | 'x' FROM x ;
GRANT ALL ON SCHEMA temp_func_test TO x ;
SET search_path TO temp_func_test , public ;
CREATE FUNCTION x ( TEXT , date ) RETURNS bool LANGUAGE 'x' AS 'x' ;
CREATE FUNCTION x ( TEXT [ ] ) RETURNS INT LANGUAGE 'x' AS 'x' ;
CREATE FUNCTION x ( ) RETURNS bool LANGUAGE 'x' AS 'x' ;
CREATE FUNCTION x ( INT ) RETURNS bool LANGUAGE 'x' AS 'x' ;
CREATE FUNCTION x ( INT ) RETURNS bool LANGUAGE 'x' IMMUTABLE AS 'x' ;
CREATE FUNCTION x ( INT ) RETURNS bool LANGUAGE 'x' STABLE AS 'x' ;
CREATE FUNCTION x ( INT ) RETURNS bool LANGUAGE 'x' VOLATILE AS 'x' ;
ALTER FUNCTION x ( INT ) VOLATILE ;
CREATE FUNCTION x ( INT ) RETURNS bool LANGUAGE 'x' SECURITY DEFINER AS 'x' ;
CREATE FUNCTION x ( INT ) RETURNS bool LANGUAGE 'x' SECURITY INVOKER AS 'x' ;
ALTER FUNCTION x ( INT ) SECURITY DEFINER ;
CREATE FUNCTION x ( INT ) RETURNS bool LANGUAGE 'x' LEAKPROOF AS 'x' ;
ALTER FUNCTION x ( INT ) LEAKPROOF ;
ALTER FUNCTION x ( INT ) OWNER TO x ;
SET SESSION AUTHORIZATION regress_unpriv_user ;
ALTER FUNCTION x ( INT ) NOT LEAKPROOF ;
CREATE FUNCTION x ( INT ) RETURNS bool LANGUAGE 'x' CALLED ON NULL INPUT AS 'x' ;
CREATE FUNCTION x ( INT ) RETURNS bool LANGUAGE 'x' RETURNS NULL ON NULL INPUT AS 'x' ;
CREATE FUNCTION x ( INT ) RETURNS bool LANGUAGE 'x' STRICT AS 'x' ;
ALTER FUNCTION x ( INT ) CALLED ON NULL INPUT ;
DROP FUNCTION x ( INT , INT , TEXT ) , x ( INT ) , x ( INT ) ;
CREATE FUNCTION x ( BIGINT ) RETURNS bool LANGUAGE 'x' IMMUTABLE AS 'x' ;
DROP FUNCTION functest_b_1 ;
DROP FUNCTION x ( a INT ) ;
SELECT * FROM x ( 1 ) ;
DROP SCHEMA temp_func_test CASCADE ;
SELECT x ( x ) AS avg_1 FROM x ;
SELECT x ( x ) AS avg_32 FROM x WHERE x < 1 ;
SELECT x ( x ) AS avg_3_4 FROM ONLY x ;
SELECT x ( x ) AS sum_1500 FROM x ;
SELECT x ( x ) AS sum_198 FROM x ;
SELECT x ( x ) AS avg_431_773 FROM x ;
SELECT x ( x ) AS avg_6_8 FROM ONLY x ;
SELECT x ( x ) AS max_3 FROM x ;
SELECT x ( x ) AS max_100 FROM x ;
SELECT x ( x . x ) AS max_324_78 FROM x ;
SELECT x ( x . x ) AS max_3_7 FROM x ;
SELECT x ( 1.000000 ) , x ( 2.000000 ) ;
SELECT x ( x , x ) FROM x ;
SELECT x ( x , x ) , x ( x , x ) FROM x ;
CREATE TABLE x ( x float8 , x float8 ) ;
INSERT INTO x VALUES ( 1 , 1 ) , ( 1 , 1 ) , ( 1 , 1 ) , ( 1 , 1 ) , ( 1 , 1 ) ;
SELECT x ( * ) , x ( x ) , x ( x , x ) , x ( x ) , x ( x , x ) , x ( x , x ) FROM x WHERE x IN ( 1 , 1 , 1 , 1 ) ;
SELECT x ( * ) , x ( x ) , x ( x , x ) , x ( x ) , x ( x , x ) , x ( x , x ) FROM x ;
SELECT x ( * ) , x ( x ) , x ( x , x ) , x ( x ) , x ( x , x ) , x ( x , x ) FROM x WHERE x IN ( 1 , 1 , 1 ) ;
SELECT x ( * ) , x ( x ) , x ( x , x ) , x ( x ) , x ( x , x ) , x ( x , x ) FROM x WHERE x IN ( 1 , 1 ) ;
SELECT x ( x ) AS cnt_1000 FROM x ;
SELECT x ( DISTINCT x ) AS cnt_4 FROM x ;
SELECT x ( * ) AS cnt_1000 FROM x ;
SELECT ( SELECT x ( ( SELECT x . x FROM x i WHERE x . x = x . x ) ) ) FROM x o ;
SELECT ARRAY ( SELECT x ( x + x ) s FROM x ( 1 , 1 ) y GROUP BY x ORDER BY x ) FROM x ( 1 , 1 ) x ;
CREATE TEMPORARY TABLE x ( x INT2 , x INT4 , x INT8 , x INTEGER , x INT2 , x BIT ( 1 ) ) ;
SELECT x ( x ) AS ?" , x ( x ) AS ?" FROM x ;
COPY x FROM STDIN NULL 'x' ;
CREATE TEMPORARY TABLE x ( x BOOL , x BOOL , x BOOL , x BOOL ) ;
SELECT x ( x ) AS n" , x ( x ) AS n" FROM x ;
SELECT x ( x ) AS f" , x ( x ) AS t" , x ( x ) AS f" , x ( x ) AS n" , x ( NOT x ) AS f" , x ( NOT x ) AS t" FROM x ;
SELECT x ( x ) AS t" , x ( x ) AS t" , x ( x ) AS f" , x ( x ) AS n" , x ( NOT x ) AS f" , x ( NOT x ) AS t" FROM x ;
EXPLAIN ( costs off ) SELECT x ( x ) FROM x ;
EXPLAIN ( costs off ) SELECT x ( x ) FROM x WHERE x < 1 ;
SELECT x ( x ) FROM x WHERE x < 1 ;
EXPLAIN ( costs off ) SELECT x ( x ) FROM x WHERE x > 1 ;
SELECT x ( x ) FROM x WHERE x > 1 ;
SET LOCAL max_parallel_workers_per_gather = 1 ;
EXPLAIN ( costs off ) SELECT x ( x ) FROM x WHERE x = 1 ;
SELECT x ( x ) FROM x WHERE x = 1 ;
EXPLAIN ( costs off ) SELECT x , ( SELECT x ( x ) FROM x WHERE x > x ) AS gt FROM x ;
SELECT x , ( SELECT x ( x ) FROM x WHERE x > x ) AS gt FROM x ;
EXPLAIN ( costs off ) SELECT DISTINCT x ( x ) FROM x ;
SELECT DISTINCT x ( x ) FROM x ;
EXPLAIN ( costs off ) SELECT x ( x ) FROM x ORDER BY 1 ;
SELECT x ( x ) FROM x ORDER BY 1 ;
EXPLAIN ( costs off ) SELECT x ( x ) FROM x ORDER BY x ( x ) ;
SELECT x ( x ) FROM x ORDER BY x ( x ) ;
EXPLAIN ( costs off ) SELECT x ( x ) FROM x ORDER BY x ( x ) + 1 ;
SELECT x ( x ) FROM x ORDER BY x ( x ) + 1 ;
EXPLAIN ( costs off ) SELECT x ( x ) , x ( 1 , 1 ) AS g FROM x ORDER BY x DESC ;
SELECT x ( x ) , x ( 1 , 1 ) AS g FROM x ORDER BY x DESC ;
EXPLAIN ( costs off ) SELECT x ( 1 ) FROM x ;
SELECT x ( 1 ) FROM x ;
CREATE INDEX x ON x ( x DESC ) ;
CREATE INDEX x ON x ( x ) WHERE x IS NOT NULL ;
EXPLAIN ( costs off ) SELECT x ( x ) , x ( x ) FROM x ;
EXPLAIN ( costs off ) SELECT DISTINCT x ( x ) , x ( x ) FROM x ;
SELECT DISTINCT x ( x ) , x ( x ) FROM x ;
SELECT x ( x ( x ) ) FROM x ;
SELECT ( SELECT x ( x ( x ) ) FROM x ) FROM x ;
CREATE TEMP TABLE x ( x INT , x INT , x INT , x INT , PRIMARY KEY ( x , x ) ) ;
CREATE TEMP TABLE x ( x INT , x INT , x INT , PRIMARY KEY ( x , x ) ) ;
CREATE TEMP TABLE x ( x INT , x INT , x INT , PRIMARY KEY ( x , x ) DEFERRABLE ) ;
EXPLAIN ( costs off ) SELECT * FROM x GROUP BY x , x , x , x ;
EXPLAIN ( costs off ) SELECT x , x FROM x GROUP BY x , x , x ;
EXPLAIN ( costs off ) SELECT * FROM x GROUP BY x , x , x ;
EXPLAIN ( costs off ) SELECT * FROM ONLY x GROUP BY x , x , x , x ;
CREATE TEMP TABLE x ( x INT , x INT , x INT , x INT , PRIMARY KEY ( x , x ) ) PARTITION BY list ( a ) ;
CREATE TEMP TABLE x PARTITION OF x FOR VALUES IN ( 1 ) ;
SELECT x ( x ORDER BY x ) FROM ( VALUES ( 1 , 1 ) , ( 1 , 1 ) , ( 1 , 1 ) , ( 1 , 1 ) ) v ( a , b ) ;
SELECT x ( x ORDER BY x DESC ) FROM ( VALUES ( 1 , 1 ) , ( 1 , 1 ) , ( 1 , 1 ) , ( 1 , 1 ) ) v ( a , b ) ;
SELECT x ( DISTINCT x ) FROM ( VALUES ( 1 ) , ( 1 ) , ( 1 ) , ( 1 ) , ( NULL ) , ( 1 ) ) v ( a ) ;
SELECT x ( DISTINCT x ORDER BY x ) FROM ( VALUES ( 1 ) , ( 1 ) , ( 1 ) , ( 1 ) , ( NULL ) , ( 1 ) ) v ( a ) ;
SELECT x ( DISTINCT x ORDER BY x DESC ) FROM ( VALUES ( 1 ) , ( 1 ) , ( 1 ) , ( 1 ) , ( NULL ) , ( 1 ) ) v ( a ) ;
SELECT x ( DISTINCT x ORDER BY x DESC NULLS LAST ) FROM ( VALUES ( 1 ) , ( 1 ) , ( 1 ) , ( 1 ) , ( NULL ) , ( 1 ) ) v ( a ) ;
SELECT x ( x , x , x ) FROM ( VALUES ( 1 , 1 , 'x' ) , ( 1 , NULL , NULL ) , ( 1 , 1 , 'x' ) , ( 1 , 1 , 'x' ) ) v ( a , b , c ) ;
SELECT x ( DISTINCT x , x , x ) FROM ( VALUES ( 1 , 1 , 'x' ) , ( 1 , NULL , NULL ) , ( 1 , 1 , 'x' ) , ( 1 , 1 , 'x' ) ) v ( a , b , c ) , x ( 1 , 1 ) i ;
SELECT x ( DISTINCT x , x , x ORDER BY x ) FROM ( VALUES ( 1 , 1 , 'x' ) , ( 1 , NULL , NULL ) , ( 1 , 1 , 'x' ) , ( 1 , 1 , 'x' ) ) v ( a , b , c ) , x ( 1 , 1 ) i ;
~~SELECT x ( DISTINCT x , x , x ORDER BY x USING < , x ) FROM ( VALUES ( 1 , 1 , 'x' ) , ( 1 , NULL , NULL ) , ( 1 , 1 , 'x' ) , ( 1 , 1 , 'x' ) ) v ( a , b , c ) , x ( 1 , 1 ) i ;
~~SELECT x ( DISTINCT x , x , x ORDER BY x USING < ) FROM ( VALUES ( 1 , 1 , 'x' ) , ( 1 , NULL , NULL ) , ( 1 , 1 , 'x' ) , ( 1 , 1 , 'x' ) ) v ( a , b , c ) , x ( 1 , 1 ) i ;
~~SELECT x ( DISTINCT x , x , x ORDER BY x , x USING < , x ) FROM ( VALUES ( 1 , 1 , 'x' ) , ( 1 , NULL , NULL ) , ( 1 , 1 , 'x' ) , ( 1 , 1 , 'x' ) ) v ( a , b , c ) , x ( 1 , 1 ) i ;
CREATE VIEW x AS SELECT x ( x , x , x ) FROM ( VALUES ( 1 , 1 , 'x' ) , ( 1 , NULL , NULL ) , ( 1 , 1 , 'x' ) , ( 1 , 1 , 'x' ) ) v ( a , b , c ) ;
CREATE OR REPLACE VIEW x AS SELECT x ( DISTINCT x , x , x ) FROM ( VALUES ( 1 , 1 , 'x' ) , ( 1 , NULL , NULL ) , ( 1 , 1 , 'x' ) , ( 1 , 1 , 'x' ) ) v ( a , b , c ) , x ( 1 , 1 ) i ;
CREATE OR REPLACE VIEW x AS SELECT x ( DISTINCT x , x , x ORDER BY x ) FROM ( VALUES ( 1 , 1 , 'x' ) , ( 1 , NULL , NULL ) , ( 1 , 1 , 'x' ) , ( 1 , 1 , 'x' ) ) v ( a , b , c ) , x ( 1 , 1 ) i ;
CREATE OR REPLACE VIEW x AS SELECT x ( x , x , x ORDER BY x + 1 ) FROM ( VALUES ( 1 , 1 , 'x' ) , ( 1 , NULL , NULL ) , ( 1 , 1 , 'x' ) , ( 1 , 1 , 'x' ) ) v ( a , b , c ) ;
CREATE OR REPLACE VIEW x AS SELECT x ( x , x , x ORDER BY x ) FROM ( VALUES ( 1 , 1 , 'x' ) , ( 1 , NULL , NULL ) , ( 1 , 1 , 'x' ) , ( 1 , 1 , 'x' ) ) v ( a , b , c ) ;
~~CREATE OR REPLACE VIEW x AS SELECT x ( x , x , x ORDER BY x USING < ) FROM ( VALUES ( 1 , 1 , 'x' ) , ( 1 , NULL , NULL ) , ( 1 , 1 , 'x' ) , ( 1 , 1 , 'x' ) ) v ( a , b , c ) ;
~~CREATE OR REPLACE VIEW x AS SELECT x ( DISTINCT x , x , x ORDER BY x , x USING < , x ) FROM ( VALUES ( 1 , 1 , 'x' ) , ( 1 , NULL , NULL ) , ( 1 , 1 , 'x' ) , ( 1 , 1 , 'x' ) ) v ( a , b , c ) , x ( 1 , 1 ) i ;
SELECT x ( DISTINCT x , x , x ORDER BY x ) FROM ( VALUES ( 1 , 1 , 'x' ) ) v ( a , b , c ) , x ( 1 , 1 ) i ;
SELECT x ( DISTINCT x , x , x ORDER BY x , x + 1 ) FROM ( VALUES ( 1 , 1 , 'x' ) ) v ( a , b , c ) , x ( 1 , 1 ) i ;
SELECT x ( DISTINCT x , x , x ORDER BY x , x , x , x ) FROM ( VALUES ( 1 , 1 , 'x' ) ) v ( a , b , c ) , x ( 1 , 1 ) i ;
SELECT x ( DISTINCT x , x , x ORDER BY x , x ) FROM ( VALUES ( 1 , 1 , 'x' ) ) v ( a , b , c ) , x ( 1 , 1 ) i ;
SELECT x ( x , 'x' ) FROM ( VALUES ( 'x' ) , ( 'x' ) , ( 'x' ) ) g ( a ) ;
SELECT x ( x , 'x' ) FROM ( VALUES ( 'x' ) , ( NULL ) , ( 'x' ) , ( 'x' ) ) g ( a ) ;
SELECT x ( x , 'x' ) FROM ( VALUES ( NULL ) , ( NULL ) , ( 'x' ) , ( 'x' ) ) g ( a ) ;
SELECT x ( x , 'x' ) FROM ( VALUES ( NULL ) , ( NULL ) ) g ( a ) ;
SELECT x ( x , 'x' ) FROM x ;
INSERT INTO x VALUES ( x ( 'x' , 'x' ) ) ;
SELECT x ( x , NULL ) FROM x ;
SELECT x ( x , x ( 'x' , 'x' ) ) FROM x ;
SELECT x ( x ) FILTER ( WHERE x > 1 ) FROM x ;
SELECT x ( 1 / x ) FILTER ( WHERE x > 1 ) FROM x ;
SELECT x ( x COLLATE C" ) FILTER ( WHERE ( x COLLATE POSIX" ) > 'x' ) FROM ( VALUES ( 'x' , 'x' ) ) AS v ( foo , bar ) ;
~~SELECT x ( DISTINCT x , x , x ORDER BY x , x USING < , x ) FILTER ( WHERE x > 1 ) FROM ( VALUES ( 1 , 1 , 'x' ) , ( 1 , NULL , NULL ) , ( 1 , 1 , 'x' ) , ( 1 , 1 , 'x' ) ) v ( a , b , c ) , x ( 1 , 1 ) i ;
SELECT x ( 0.500000 ) WITHIN GROUP ( ORDER BY x ) FROM x ;
SELECT x ( 0.500000 ) WITHIN GROUP ( ORDER BY x ) , x ( x ) FROM x ;
SELECT x ( 1 ) WITHIN GROUP ( ORDER BY x ) FROM ( VALUES ( 1 ) , ( 1 ) , ( 1 ) , ( 1 ) , ( 1 ) , ( 1 ) , ( 1 ) ) v ( x ) ;
SELECT x ( 1 ) WITHIN GROUP ( ORDER BY x ) FROM ( VALUES ( 1 ) , ( 1 ) , ( 1 ) , ( 1 ) , ( 1 ) , ( 1 ) , ( 1 ) , ( 1 ) ) v ( x ) ;
SELECT x ( ARRAY [ 1 , 0.100000 , 0.250000 , 0.500000 , 0.750000 , 0.900000 , 1 ] ) WITHIN GROUP ( ORDER BY x ) FROM x ;
SELECT x ( ARRAY [ 1 , 0.250000 , 0.500000 , 0.750000 , 1 ] ) WITHIN GROUP ( ORDER BY x ) FROM x ;
SELECT x ( ARRAY [ [ NULL , 1 , 0.500000 ] , [ 0.750000 , 0.250000 , NULL ] ] ) WITHIN GROUP ( ORDER BY x ) FROM x ;
SELECT x ( ARRAY [ 1 , 1 , 0.250000 , 0.750000 , 0.500000 , 1 , 0.300000 , 0.320000 , 0.350000 , 0.380000 , 0.400000 ] ) WITHIN GROUP ( ORDER BY x ) FROM x ( 1 , 1 ) x ;
SELECT x ( x ( 1 ) WITHIN GROUP ( ORDER BY x COLLATE POSIX" ) ) FROM ( VALUES ( 'x' ) , ( 'x' ) ) v ( x ) ;
SELECT x ( x ) WITHIN GROUP ( ORDER BY x ) FROM x ( 1 , 1 ) x ;
SELECT ARRAY ( SELECT x ( x ) WITHIN GROUP ( ORDER BY x ) FROM ( VALUES ( 0.300000 ) , ( 0.700000 ) ) v ( a ) GROUP BY x ) FROM x ( 1 , 1 ) g ( x ) ;
SELECT x ( x ( x ) ) WITHIN GROUP ( ORDER BY x ) FROM x ( 1 , 1 ) x ;
SELECT x ( 1 ) WITHIN GROUP ( ORDER BY x ) FROM ( VALUES ( 'x' ) , ( 'x' ) ) v ( x ) ;
SELECT x ( 1 ) WITHIN GROUP ( ORDER BY x , x ) FROM x ;
SELECT x ( 'x' ) WITHIN GROUP ( ORDER BY x ) FROM x ( 1 , 1 ) x ;
SELECT x ( 1 ) WITHIN GROUP ( ORDER BY x ) FROM x ( 1 , 1 ) x ;
SELECT x ( VARIADIC ARRAY [ x , x ] ) FROM x ;
BEGIN WORK ;
CREATE TYPE avg_state AS ( total BIGINT , count BIGINT ) ;
$$$$$$$$$$$$SELECT x ( x ) , x ( x ) FROM ( VALUES ( 1 ) , ( 1 ) ) t ( one ) ;
SELECT x ( DISTINCT x ) , x ( DISTINCT x ) FROM ( VALUES ( 1 ) , ( 1 ) , ( 1 ) ) t ( one ) ;
SELECT x ( DISTINCT x ) , x ( x ) FROM ( VALUES ( 1 ) , ( 1 ) ) t ( one ) ;
SELECT x ( x ) FILTER ( WHERE x > 1 ) , x ( x ) FROM ( VALUES ( 1 ) , ( 1 ) ) t ( one ) ;
SELECT x ( x ) , x ( x ) FROM ( VALUES ( 1 , 1 ) , ( 1 , 1 ) ) t ( one , two ) ;
SELECT x ( 1 ) WITHIN GROUP ( ORDER BY x ) , x ( 1 ) WITHIN GROUP ( ORDER BY x ) FROM ( VALUES ( 1 ) , ( 1 ) , ( 1 ) , ( 1 ) ) t ( a ) ;
$$$$$$$$SELECT x ( x ) , x ( x ) FROM ( VALUES ( 1 ) , ( 1 ) , ( 1 ) , ( 1 ) ) t ( one ) ;
$$BEGIN ISOLATION LEVEL REPEATABLE READ ;
$$ALTER TABLE x SET ( parallel_workers = 1 ) ;
SET LOCAL parallel_setup_cost = 1 ;
EXPLAIN ( COSTS OFF ) SELECT x ( x ) FROM x ;
SET parallel_setup_cost = 1 ;
SET parallel_tuple_cost = 1 ;
SET min_parallel_table_scan_size = 1 ;
SET max_parallel_workers_per_gather = 1 ;
SET enable_indexonlyscan = off ;
SELECT x ( x ) WITHIN GROUP ( ORDER BY x ) FROM ( VALUES ( 1 ) , ( 1 ) , ( 1 ) , ( 1 ) , ( 1 ) , ( 1 ) ) v ( x ) GROUP BY ( x ) ORDER BY 1 ;
SELECT x ( x ORDER BY x ) FROM ( VALUES ( 1 , NULL ) ) AS d ( x , y ) ;
SELECT x ( x ORDER BY x ) FROM ( VALUES ( 1 , 1 ) ) AS d ( x , y ) ;
SELECT x || 'x' , CASE x || 'x' WHEN 'x' THEN 1 ELSE 1 END , x ( * ) FROM x ( ARRAY [ 'x' , 'x' ] ) u ( v ) GROUP BY x || 'x' ORDER BY 1 ;
SELECT x || 'x' , CASE WHEN x || 'x' = 'x' THEN 1 ELSE 1 END , x ( * ) FROM x ( ARRAY [ 'x' , 'x' ] ) u ( v ) GROUP BY x || 'x' ORDER BY 1 ;
EXPLAIN ( costs off ) SELECT 1 FROM x WHERE ( x , x ) IN ( SELECT x , x FROM x ) ;
~~~~~~~~~~~~~~~~~~~~~~~~~CREATE TABLE x ( x SERIAL PRIMARY KEY , x INT , x TEXT ) ;
INSERT INTO x ( x , x ) VALUES ( 1 , x ( 'x' , 1 ) ) ;
DELETE FROM x AS x WHERE x . x > 1 ;
DELETE FROM x x WHERE x . x > 1 ;
DELETE FROM x WHERE x > 1 ;
CREATE TABLE x ( x date ) ;
SELECT x AS Fifteen" FROM x ;
SELECT x AS Nine" FROM x WHERE x < 'x' ;
SELECT x AS Three" FROM x WHERE x BETWEEN 'x' AND 'x' ;
SELECT x 'x' ;
SET datestyle TO mdy ;
SELECT x - x 'x' AS Days From 2K" FROM x ;
SELECT x - x 'x' AS Days From Epoch" FROM x ;
SELECT x 'x' - x 'x' AS One day" ;
SELECT x 'x' - x 'x' AS Two days" ;
SELECT x ( 1 , 1 , 1 ) ;
SELECT x ( 1 , 1 , 0.000000 ) ;
SELECT x ( 1 , 1 , 100.099998 ) ;
SELECT x ( 1 , 1 , 2.100000 ) ;
CREATE TABLE x ( x INT , x INT , x CHAR ( 1 ) , x CHAR ) ;
INSERT INTO x VALUES ( 1 , 1 , 'x' , 'x' ) ;
SELECT x , x ( * ) FROM x GROUP BY x . x ORDER BY x ;
SELECT x ( * ) FROM x GROUP BY x . x ORDER BY x ;
SELECT x ( * ) FROM x GROUP BY x ORDER BY x ;
SELECT x . x , x ( * ) FROM x GROUP BY x ORDER BY x ;
SELECT x FROM x ORDER BY x ;
SELECT x ( * ) FROM x GROUP BY x ORDER BY x DESC ;
SELECT x ( * ) FROM x ORDER BY 1 DESC ;
SELECT x , x ( * ) FROM x GROUP BY 1 ORDER BY 1 ;
SELECT x , x ( * ) FROM x GROUP BY 1 ;
SELECT x ( * ) FROM x x , x y WHERE x . x = x . x GROUP BY x ORDER BY x ;
SELECT x , x FROM x ORDER BY x ;
SELECT x / 1 , x / 1 FROM x ORDER BY x / 1 ;
SELECT x / 1 , x / 1 FROM x GROUP BY x / 1 ORDER BY x / 1 ;
SELECT x . x , x ( * ) FROM x x , x y WHERE x . x = x . x GROUP BY x . x ORDER BY x . x ;
SELECT x ( * ) FROM x x , x y WHERE x . x = x . x GROUP BY x . x ORDER BY x . x ;
SELECT x ( x ) FROM x GROUP BY x ORDER BY x ;
SELECT x ( x ) FROM x GROUP BY x / 1 ORDER BY x / 1 ;
SELECT x ( x . x ) , x ( x ) FROM x GROUP BY x ( x ) ORDER BY x ( x ) ;
SELECT x FROM x ORDER BY x ( x ) ;
SELECT x ( x ) FROM x GROUP BY ( x + 1 ) / 1 ORDER BY ( x + 1 ) / 1 DESC ;
SELECT x ( x . x ) FROM x x , x y WHERE x . x = x . x GROUP BY x / 1 ORDER BY x / 1 ;
SELECT x . x / 1 , x ( x . x ) FROM x x , x y WHERE x . x = x . x GROUP BY x . x / 1 ORDER BY x . x / 1 ;
SELECT x ( x ) FROM x x , x y WHERE x . x = x . x GROUP BY x . x / 1 ;
CREATE TABLE x ( x INTEGER , x INTEGER , x TEXT ) ;
CREATE TABLE x ( x INTEGER , x INTEGER ) ;
INSERT INTO x VALUES ( NULL , NULL , 'x' ) ;
INSERT INTO x VALUES ( NULL , 1 , 'x' ) ;
INSERT INTO x VALUES ( NULL , NULL ) ;
CREATE TEMP TABLE x ( ) ;
SELECT 'x' AS xxx" , * FROM x AS tx ;
SELECT 'x' AS xxx" , * FROM x tx ;
SELECT 'x' AS xxx" , * FROM x AS t1 ( a , b , c ) ;
SELECT 'x' AS xxx" , * FROM x t1 ( a , b , c ) ;
SELECT 'x' AS xxx" , * FROM x t1 ( a , b , c ) , x t2 ( d , e ) ;
SELECT 'x' AS xxx" , x . x , x . x FROM x t1 ( a , b , c ) , x t2 ( d , e ) WHERE x . x = x . x ;
SELECT 'x' AS xxx" , * FROM x CROSS JOIN x ;
SELECT 'x' AS xxx" , x , x , x FROM x CROSS JOIN x ;
SELECT 'x' AS xxx" , x . x , x , x FROM x t1 CROSS JOIN x t2 ;
SELECT 'x' AS xxx" , x , x , x FROM ( x CROSS JOIN x ) AS tx ( ii , jj , tt , ii2 , kk ) ;
SELECT 'x' AS xxx" , x . x , x . x , x . x FROM ( x t1 ( a , b , c ) CROSS JOIN x t2 ( d , e ) ) AS tx ( ii , jj , tt , ii2 , kk ) ;
SELECT 'x' AS xxx" , * FROM x CROSS JOIN x a CROSS JOIN x b ;
SELECT 'x' AS xxx" , * FROM x INNER JOIN x USING ( i ) ;
SELECT 'x' AS xxx" , * FROM x JOIN x USING ( i ) ;
SELECT 'x' AS xxx" , * FROM x t1 ( a , b , c ) JOIN x t2 ( a , d ) USING ( a ) ORDER BY x , x ;
SELECT 'x' AS xxx" , * FROM x t1 ( a , b , c ) JOIN x t2 ( a , b ) USING ( b ) ORDER BY x , x . x ;
SELECT 'x' AS xxx" , * FROM x NATURAL JOIN x ;
SELECT 'x' AS xxx" , * FROM x t1 ( a , b , c ) NATURAL JOIN x t2 ( a , d ) ;
SELECT 'x' AS xxx" , * FROM x t1 ( a , b , c ) NATURAL JOIN x t2 ( d , a ) ;
SELECT 'x' AS xxx" , * FROM x t1 ( a , b ) NATURAL JOIN x t2 ( a ) ;
SELECT 'x' AS xxx" , * FROM x JOIN x ON ( x . x = x . x ) ;
SELECT 'x' AS xxx" , * FROM x JOIN x ON ( x . x <= x . x ) ;
SELECT 'x' AS xxx" , * FROM x LEFT OUTER JOIN x USING ( i ) ORDER BY x , x , x ;
SELECT 'x' AS xxx" , * FROM x LEFT JOIN x USING ( i ) ORDER BY x , x , x ;
SELECT 'x' AS xxx" , * FROM x RIGHT OUTER JOIN x USING ( i ) ;
SELECT 'x' AS xxx" , * FROM x RIGHT JOIN x USING ( i ) ;
SELECT 'x' AS xxx" , * FROM x FULL OUTER JOIN x USING ( i ) ORDER BY x , x , x ;
SELECT 'x' AS xxx" , * FROM x FULL JOIN x USING ( i ) ORDER BY x , x , x ;
SELECT 'x' AS xxx" , * FROM x LEFT JOIN x USING ( i ) WHERE ( x = 1 ) ;
CREATE TEMP TABLE x ( x INT , x INT ) ;
SELECT * FROM x LEFT JOIN x ON ( x = x AND x IS NOT NULL ) ;
SELECT * FROM ( x LEFT JOIN x ON ( x = x ) ) LEFT JOIN x xx ( xx1 , xx2 ) ON ( x = x ) ;
SELECT * FROM ( x LEFT JOIN x ON ( x = x ) ) LEFT JOIN x xx ( xx1 , xx2 ) ON ( x = x AND x IS NOT NULL ) ;
SELECT * FROM ( x LEFT JOIN x ON ( x = x ) ) LEFT JOIN x xx ( xx1 , xx2 ) ON ( x = x ) WHERE ( x IS NOT NULL ) ;
SELECT x ( * ) FROM x a WHERE x IN ( SELECT x FROM x b JOIN x c USING ( unique1 ) WHERE x . x = 1 ) ;
SELECT x ( * ) FROM x x WHERE x . x IN ( SELECT x . x FROM x a , x b WHERE x . x = x . x ) AND x . x = 1 AND x . x IN ( SELECT x . x FROM x aa , x bb WHERE x . x = x . x ) ;
SET geqo = ON ;
SET geqo_threshold = 1 ;
EXPLAIN ( costs off ) SELECT x , x , x , x FROM x RIGHT JOIN x ON x = x WHERE x < x AND x IS NULL ;
SELECT x , x , x , x FROM x RIGHT JOIN x ON x = x WHERE x < x AND x IS NULL ;
EXPLAIN ( costs off ) SELECT * FROM x FULL JOIN ( SELECT * FROM x ORDER BY x . x DESC , x . x ASC ) j2_tbl ON x . x = x . x AND x . x = x . x ;
SELECT * FROM x FULL JOIN ( SELECT * FROM x ORDER BY x . x DESC , x . x ASC ) j2_tbl ON x . x = x . x AND x . x = x . x ;
EXPLAIN ( costs off ) SELECT x ( * ) FROM ( SELECT * FROM x x ORDER BY x . x , x . x , x . x ) x LEFT JOIN ( SELECT * FROM x y ORDER BY x . x ) y ON x . x = x . x AND x . x = x . x AND x . x = x . x ;
SELECT x ( * ) FROM ( SELECT * FROM x x ORDER BY x . x , x . x , x . x ) x LEFT JOIN ( SELECT * FROM x y ORDER BY x . x ) y ON x . x = x . x AND x . x = x . x AND x . x = x . x ;
DELETE FROM x USING x table1 WHERE x . x = x . x ;
DELETE FROM x USING x JOIN x USING ( a ) WHERE x . x > x . x ;
DELETE FROM x USING x t3_other WHERE x . x = x . x AND x . x = x . x ;
SELECT * FROM x LEFT JOIN x ON ( x . x = x . x ) ;
SELECT x . x FROM x JOIN x ON ( x . x = x . x ) ;
CREATE TEMP TABLE x ( x int4 , x int4 ) ;
SET enable_hashjoin TO off ;
SET enable_nestloop TO off ;
SELECT x . * , x . * FROM x LEFT JOIN x ON x . x = x . x ;
SELECT x . * , x . * FROM x RIGHT JOIN x ON x . x = x . x ;
RESET enable_hashjoin ;
RESET enable_nestloop ;
SET work_mem TO 'x' ;
SET enable_mergejoin TO off ;
EXPLAIN ( costs off ) SELECT x ( * ) FROM x a , x b WHERE x . x = x . x AND ( x . x % 1 ) < 1 ;
SELECT x ( * ) FROM x a , x b WHERE x . x = x . x AND ( x . x % 1 ) < 1 ;
RESET work_mem ;
RESET enable_mergejoin ;
INSERT INTO x SELECT x , x ( 'x' , 1 ) FROM x ( 1 , 1 ) x ;
INSERT INTO x VALUES ( 1 ) , ( 1 ) , ( 1 ) ;
CREATE TEMP TABLE x ( x INT , x INT , x INT ) ;
SELECT * FROM x , x WHERE x . x = x . x AND x . x = x . x - x . x ;
SELECT * FROM x LEFT JOIN x ON ( x = x ) LEFT JOIN x ON ( x = x ) WHERE x = 1 ;
$PREPARE foo ( bool ) AS SELECT x ( * ) FROM x a LEFT JOIN x b ON ( x . x = x . x AND EXISTS ( SELECT 1 FROM x c WHERE x . x = x . x AND 1 ) ) ;
EXECUTE foo ( TRUE ) ;
EXECUTE foo ( FALSE ) ;
SET enable_mergejoin = 1 ;
SET enable_hashjoin = 1 ;
SET enable_nestloop = 1 ;
CREATE TEMP TABLE x ( x INTEGER ) ;
CREATE TEMP TABLE x ( x INTEGER , x INTEGER ) ;
SELECT * FROM x LEFT JOIN x ON x = x AND x = x AND x = x ;
CREATE TYPE mycomptype AS ( id INT , v BIGINT ) ;
CREATE TEMP TABLE x ( x mycomptype ) ;
EXPLAIN ( costs off ) SELECT x . x , x . x FROM x a , x b WHERE x . x = x . x ;
SELECT x . x , x ( x . * ) FROM x t1 LEFT JOIN x t2 ON ( x . x = x . x ) GROUP BY x . x ORDER BY 1 ;
SELECT x . x , x ( x . * ) FROM x t1 LEFT JOIN ( SELECT * FROM x ) t2 ON ( x . x = x . x ) GROUP BY x . x ORDER BY 1 ;
SELECT x . x , x ( x . * ) FROM x t1 LEFT JOIN ( SELECT * FROM x OFFSET 1 ) t2 ON ( x . x = x . x ) GROUP BY x . x ORDER BY 1 ;
SELECT x . x , x ( x . * ) FROM x t1 LEFT JOIN ( SELECT x , CASE WHEN x = 1 THEN 1 ELSE x END AS q2 FROM x ) t2 ON ( x . x = x . x ) GROUP BY x . x ORDER BY 1 ;
CREATE TEMP TABLE x ( x CHAR NOT NULL , CONSTRAINT a_pk PRIMARY KEY ( x ) ) ;
CREATE TEMP TABLE x ( x CHAR NOT NULL , x INTEGER NOT NULL , CONSTRAINT b_pk PRIMARY KEY ( x , x ) ) ;
INSERT INTO x ( x , x ) VALUES ( 'x' , 1 ) ;
EXPLAIN ( COSTS OFF ) SELECT x , x FROM ( SELECT COALESCE ( x , 1 ) AS qq FROM x a ) AS ss1 FULL OUTER JOIN ( SELECT COALESCE ( x , 1 ) AS qq FROM x b ) AS ss2 USING ( qq ) INNER JOIN x c ON x = x ;
SELECT x , x FROM ( SELECT COALESCE ( x , 1 ) AS qq FROM x a ) AS ss1 FULL OUTER JOIN ( SELECT COALESCE ( x , 1 ) AS qq FROM x b ) AS ss2 USING ( qq ) INNER JOIN x c ON x = x ;
CREATE TEMP TABLE x ( x INT PRIMARY KEY , x BOOLEAN , x BOOLEAN ) ;
CREATE TEMP TABLE x ( x INT PRIMARY KEY , x INT , x BOOLEAN , x BOOLEAN , FOREIGN KEY ( x ) REFERENCES x ( x ) ) ;
CREATE TEMP TABLE x ( x INT PRIMARY KEY , x INT , x BOOLEAN , FOREIGN KEY ( x ) REFERENCES x ( x ) ) ;
INSERT INTO x VALUES ( 1 , TRUE , TRUE ) ;
INSERT INTO x VALUES ( 1 , TRUE , FALSE ) ;
INSERT INTO x VALUES ( 1 , FALSE , FALSE ) ;
INSERT INTO x VALUES ( 1 , 1 , TRUE , TRUE ) ;
INSERT INTO x VALUES ( 1 , 1 , TRUE , FALSE ) ;
INSERT INTO x VALUES ( 1 , 1 , FALSE , FALSE ) ;
INSERT INTO x VALUES ( 1 , 1 , TRUE ) ;
INSERT INTO x VALUES ( 1 , 1 , FALSE ) ;
SELECT * FROM x a FULL JOIN x b ON TRUE ;
SELECT * FROM x a FULL JOIN x b ON FALSE ;
CREATE TEMP TABLE x AS SELECT 1 AS q1 ;
CREATE TEMP TABLE x AS SELECT 1 AS q2 ;
EXPLAIN ( costs off ) SELECT x . x , x . x , x . x , x . x FROM x t1 INNER JOIN x i1 LEFT JOIN ( SELECT x . x , x . x , 1 AS d1 FROM ( SELECT 1 , 1 FROM x ) v1 ( x1 , x2 ) LEFT JOIN ( SELECT 1 , 1 FROM x ) v2 ( y1 , y2 ) ON x . x = x . x ) subq1 ON ( x . x = x . x ) ON ( x . x = x . x ) LEFT JOIN x t2 ON ( x . x = x . x ) WHERE x . x < 1 AND x . x > x . x ;
SELECT x . x , x . x , x . x , x . x FROM x t1 INNER JOIN x i1 LEFT JOIN ( SELECT x . x , x . x , 1 AS d1 FROM ( SELECT 1 , 1 FROM x ) v1 ( x1 , x2 ) LEFT JOIN ( SELECT 1 , 1 FROM x ) v2 ( y1 , y2 ) ON x . x = x . x ) subq1 ON ( x . x = x . x ) ON ( x . x = x . x ) LEFT JOIN x t2 ON ( x . x = x . x ) WHERE x . x < 1 AND x . x > x . x ;
EXPLAIN ( costs off ) SELECT x . x , x . x , x . x , x . x FROM x t1 INNER JOIN x i1 LEFT JOIN ( SELECT x . x , x . x , 1 AS d1 FROM ( VALUES ( 1 , 1 ) ) v1 ( x1 , x2 ) LEFT JOIN ( VALUES ( 1 , 1 ) ) v2 ( y1 , y2 ) ON x . x = x . x ) subq1 ON ( x . x = x . x ) ON ( x . x = x . x ) LEFT JOIN x t2 ON ( x . x = x . x ) WHERE x . x < 1 AND x . x > x . x ;
SELECT x . x , x . x , x . x , x . x FROM x t1 INNER JOIN x i1 LEFT JOIN ( SELECT x . x , x . x , 1 AS d1 FROM ( VALUES ( 1 , 1 ) ) v1 ( x1 , x2 ) LEFT JOIN ( VALUES ( 1 , 1 ) ) v2 ( y1 , y2 ) ON x . x = x . x ) subq1 ON ( x . x = x . x ) ON ( x . x = x . x ) LEFT JOIN x t2 ON ( x . x = x . x ) WHERE x . x < 1 AND x . x > x . x ;
$$EXPLAIN ( costs off ) SELECT x FROM x , x ( 1 ) x WHERE x = x ;
EXPLAIN ( costs off ) SELECT x FROM x , LATERAL x ( 1 ) x WHERE x = x ;
EXPLAIN ( costs off ) SELECT x , x FROM x JOIN x ( 1 ) x ON x = x ;
EXPLAIN ( costs off ) SELECT x , x FROM x LEFT JOIN x ( 1 ) x ON x = x ;
EXPLAIN ( costs off ) SELECT x , x FROM x RIGHT JOIN x ( 1 ) x ON x = x ;
EXPLAIN ( costs off ) SELECT x , x FROM x FULL JOIN x ( 1 ) x ON x = x ;
EXPLAIN ( costs off ) SELECT x FROM x , x ( 1 ) x WHERE x = 1 ;
$$$$SELECT * FROM x ( 1 , 1 ) ;
DROP FUNCTION x ( BIGINT , BIGINT ) ;
EXPLAIN ( costs off ) SELECT * FROM x a JOIN x b ON ( x . x = 1 AND x . x = 1 ) OR ( x . x = 1 AND x . x = 1 ) ;
EXPLAIN ( costs off ) SELECT * FROM x a JOIN x b ON ( x . x = 1 AND x . x = 1 ) OR ( ( x . x = 1 OR x . x = 1 ) AND x . x = 1 ) ;
EXPLAIN ( costs off ) SELECT x ( * ) FROM x a JOIN x b ON x . x = x . x LEFT JOIN x c ON x . x = x . x AND x . x = x . x JOIN x ON x . x = x ;
SELECT x ( * ) FROM x a JOIN x b ON x . x = x . x LEFT JOIN x c ON x . x = x . x AND x . x = x . x JOIN x ON x . x = x ;
EXPLAIN ( costs off ) SELECT x . x FROM x a JOIN x b ON x . x = x . x LEFT JOIN x c ON x . x = 1 AND x . x = x . x JOIN x i1 ON x . x = x RIGHT JOIN x i2 ON x . x = x . x ORDER BY 1 ;
SELECT x . x FROM x a JOIN x b ON x . x = x . x LEFT JOIN x c ON x . x = 1 AND x . x = x . x JOIN x i1 ON x . x = x RIGHT JOIN x i2 ON x . x = x . x ORDER BY 1 ;
EXPLAIN ( costs off ) SELECT * FROM ( VALUES ( 1 , ARRAY [ 1 , 1 ] ) , ( 1 , ARRAY [ 1 , 1 ] ) ) AS v1 ( v1x , v1ys ) LEFT JOIN ( VALUES ( 1 , 1 ) , ( 1 , 1 ) ) AS v2 ( v2x , v2y ) ON x = x JOIN x ( x ) AS u1 ( u1y ) ON x = x ;
SELECT * FROM ( VALUES ( 1 , ARRAY [ 1 , 1 ] ) , ( 1 , ARRAY [ 1 , 1 ] ) ) AS v1 ( v1x , v1ys ) LEFT JOIN ( VALUES ( 1 , 1 ) , ( 1 , 1 ) ) AS v2 ( v2x , v2y ) ON x = x JOIN x ( x ) AS u1 ( u1y ) ON x = x ;
EXPLAIN ( costs off ) SELECT x , x , x , x FROM x a LEFT JOIN x b ON x = x WHERE COALESCE ( x , 1 ) = x AND x = COALESCE ( x , 1 ) ;
SELECT x , x , x , x FROM x a LEFT JOIN x b ON x = x WHERE COALESCE ( x , 1 ) = x AND x = COALESCE ( x , 1 ) ;
EXPLAIN ( costs off ) SELECT x , x , CASE WHEN x IS NULL THEN x ELSE 1 END FROM x a LEFT JOIN x b ON x = x WHERE ( CASE WHEN x IS NULL THEN x ELSE 1 END ) = 1 ;
SELECT x , x , CASE WHEN x IS NULL THEN x ELSE 1 END FROM x a LEFT JOIN x b ON x = x WHERE ( CASE WHEN x IS NULL THEN x ELSE 1 END ) = 1 ;
EXPLAIN ( costs off ) SELECT x . x , x . x , x . x , COALESCE ( x . x , x . x ) FROM x a LEFT JOIN x b ON x . x = x . x LEFT JOIN x c ON x . x = COALESCE ( x . x , x . x ) WHERE x . x < 1 AND COALESCE ( x . x , x . x ) = 1 ;
SELECT x . x , x . x , x . x , COALESCE ( x . x , x . x ) FROM x a LEFT JOIN x b ON x . x = x . x LEFT JOIN x c ON x . x = COALESCE ( x . x , x . x ) WHERE x . x < 1 AND COALESCE ( x . x , x . x ) = 1 ;
SELECT * FROM x t1 INNER JOIN x i8 ON x . x = 1 RIGHT JOIN x t2 ON x . x = 'x' LEFT JOIN x i4 ON x . x = x . x ;
EXPLAIN ( costs off ) SELECT * FROM ( SELECT 1 AS id ) AS xx LEFT JOIN ( x AS a1 FULL JOIN ( SELECT 1 AS id ) AS yy ON ( x . x = x . x ) ) ON ( x . x = COALESCE ( x . x ) ) ;
SELECT * FROM ( SELECT 1 AS id ) AS xx LEFT JOIN ( x AS a1 FULL JOIN ( SELECT 1 AS id ) AS yy ON ( x . x = x . x ) ) ON ( x . x = COALESCE ( x . x ) ) ;
EXPLAIN ( costs off ) SELECT * FROM x a LEFT JOIN x b ON x = x WHERE x = 1 ;
EXPLAIN ( costs off ) SELECT * FROM x a FULL JOIN x b USING ( unique2 ) WHERE x = 1 ;
SELECT x . x , x . x FROM x a LEFT JOIN x b ON x . x = COALESCE ( x . x , 1 ) WHERE COALESCE ( x . x , 1 ) > 1 ;
CREATE TEMP TABLE x ( x INT PRIMARY KEY , x INT ) ;
INSERT INTO x VALUES ( 1 , 1 ) , ( 1 , NULL ) ;
INSERT INTO x VALUES ( 1 , 1 ) , ( 1 , 1 ) , ( 1 , 1 ) ;
EXPLAIN ( costs off ) SELECT x . * FROM x LEFT JOIN x ON x . x = x . x ;
EXPLAIN ( costs off ) SELECT x . * FROM x LEFT JOIN ( x LEFT JOIN x ON x . x = x . x ) ON ( x . x = x . x ) ;
EXPLAIN ( costs off ) SELECT x FROM x WHERE x IN ( SELECT x . x FROM x LEFT JOIN x ON x . x = x . x ) ;
EXPLAIN ( costs off ) SELECT x . * FROM x LEFT JOIN ( SELECT * FROM x GROUP BY x . x , x . x ) s ON x . x = x . x AND x . x = x . x ;
EXPLAIN ( costs off ) SELECT x . * FROM x LEFT JOIN ( SELECT DISTINCT * FROM x ) s ON x . x = x . x AND x . x = x . x ;
EXPLAIN ( costs off ) SELECT x . * FROM x LEFT JOIN ( SELECT * FROM x GROUP BY x . x , x . x ) s ON x . x = x . x ;
EXPLAIN ( costs off ) SELECT x . * FROM x LEFT JOIN ( SELECT DISTINCT * FROM x ) s ON x . x = x . x ;
EXPLAIN ( costs off ) SELECT x . * FROM x LEFT JOIN ( SELECT x FROM x UNION SELECT x FROM x ) s ON x . x = x . x ;
EXPLAIN ( costs off ) SELECT x . * FROM x i8 LEFT JOIN ( SELECT x FROM x GROUP BY x ) i4 ON x . x = x . x ;
EXPLAIN ( costs off ) SELECT 1 FROM ( SELECT x . x FROM x LEFT JOIN x ON x . x = x . x ) q , LATERAL x ( 1 , x . x ) gs ( i ) WHERE x . x = x . x ;
CREATE TEMP TABLE x ( x INT UNIQUE , x INT ) ;
SELECT x . * FROM x p LEFT JOIN x c ON ( x . x = x . x ) ;
EXPLAIN ( costs off ) SELECT x . * FROM x p LEFT JOIN x c ON ( x . x = x . x ) ;
SELECT x . * , x FROM x p LEFT JOIN ( SELECT x . * , TRUE AS linked FROM x c ) AS ss ON ( x . x = x . x ) ;
EXPLAIN ( costs off ) SELECT x . * , x FROM x p LEFT JOIN ( SELECT x . * , TRUE AS linked FROM x c ) AS ss ON ( x . x = x . x ) ;
SELECT x . * FROM x p LEFT JOIN x c ON ( x . x = x . x ) WHERE x . x = 1 AND x . x = 1 ;
EXPLAIN ( costs off ) SELECT x . * FROM x p LEFT JOIN x c ON ( x . x = x . x ) WHERE x . x = 1 AND x . x = 1 ;
SELECT x . * FROM ( x p LEFT JOIN x c ON ( x . x = x . x ) ) JOIN x x ON x . x = x . x WHERE x . x = 1 AND x . x = 1 ;
